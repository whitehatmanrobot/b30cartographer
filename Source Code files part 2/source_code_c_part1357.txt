oration
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*      BRENTMID 11/29/1999 - Redesigned UI to match functional spec.
*
*******************************************************************************/
#ifndef _SRDlg_h
#define _SRDlg_h

#include "audiodlg.h"

// External Declarations
class CEnvrDlg;
class CEnvrPropDlg;
#define IDH_NOHELP          -1
#define CPL_HELPFILE        L"sapicpl.hlp"
#define WM_RECOEVENT    WM_APP      // Window message used for recognition events

// Constant Declarations
const int iMaxColLength_c = 255;
const int iMaxAddedProfiles_c = 100;    // maximum number of profiles a user can add
                                        // in one session
const int iMaxDeletedProfiles_c = 100;  // maximum number of profiles a user can delete
                                        // and rollback in one session
// Typedefs
typedef enum EPD_RETURN_VALUE
{
    EPD_OK,
    EPD_DUP,
    EPD_EMPTY_NAME,
    EPD_FAILED
}   EPD_RETURN_VALUE;


typedef enum SRDLGUPDATEFLAGS
{
    SRDLGF_RECOGNIZER              = 0x01,
    SRDLGF_AUDIOINPUT   = 0x02,
    SRDLGF_ALL =0x03
} SRDLGUPDATEFLAGS;


// Class Declarations
class CSRDlg
{
  private:
    
    HACCEL                  m_hAccelTable;
    HWND                	m_hDlg;
    HWND                    m_hSRCombo;         // engine selection combobox
    HWND                	m_hUserList;        // user selection window
	BOOL					m_fDontDelete;
    BOOL                	m_bInitEngine;      // has the default engine been initialized
    BOOL                	m_bPreferredDevice;
    
    CComPtr<ISpRecognizer>  m_cpRecoEngine;
    CComPtr<ISpRecoContext> m_cpRecoCtxt;       // Recognition context
    CAudioDlg          		*m_pAudioDlg;
    ISpObjectToken     		*m_pCurRecoToken;   // holds the token for the currently selected engine
    CSpDynamicString        m_dstrOldUserTokenId;   
                                                // the original user token ID - need to revert to this on Cancel
	
    ISpObjectToken*         m_aDeletedTokens[iMaxDeletedProfiles_c];  
                                                // array holding the tokens
    int                     m_iDeletedTokens;   // holds the number of currently deleted tokens

    CSpDynamicString        m_aAddedTokens[ iMaxAddedProfiles_c ];
    int                     m_iAddedTokens;
	
    int                     m_iLastSelected;    // index of the previously selected item
    WCHAR                   m_szCaption[ MAX_LOADSTRING ];

    HRESULT CreateRecoContext(BOOL *pfContextInitialized = NULL, BOOL fInitialize = FALSE, ULONG ulFlags = SRDLGF_ALL);      
	void RecoEvent();
    
    void PopulateList();             // Populates the list
    void InitUserList(HWND hWnd);    // initializes user profile list
    void ProfileProperties();        // Modifies the profile properties through engine UI
	void DrawItemColumn(HDC hdc, WCHAR* lpsz, LPRECT prcClip);
	CSpDynamicString        CalcStringEllipsis(HDC hdc, CSpDynamicString lpszString, int cchMax, UINT uColWidth);
    void SetCheckmark( HWND hList, int iIndex, bool bCheck );
    
    HRESULT UserPropDlg( ISpObjectToken * pToken); // user wants to add a new profile
  
  public:
    CSRDlg() :
        m_hAccelTable( NULL ),
        m_hDlg( NULL ),
        m_hSRCombo( NULL ),
        m_hUserList( NULL ),
        m_fDontDelete( FALSE ),
        m_bInitEngine( FALSE ),
        m_bPreferredDevice( TRUE ),
        m_cpRecoEngine( NULL ),
        m_cpRecoCtxt( NULL ),
        m_pAudioDlg(NULL),
        m_pCurRecoToken( NULL ),
        m_dstrOldUserTokenId( (WCHAR *) NULL ),
        m_iDeletedTokens( 0 ),
        m_iAddedTokens( 0 ),
        m_pCurUserToken( NULL ),
        m_pDefaultRecToken( NULL )
    {
            ::memset( m_aAddedTokens, 0, sizeof( CSpDynamicString ) * iMaxAddedProfiles_c );
    }

    ~CSRDlg()
    {
        if ( m_pAudioDlg )
        {
            delete m_pAudioDlg;
        }
    }

    ISpObjectToken     *m_pCurUserToken;      // currently selected user token
    ISpObjectToken     *m_pDefaultRecToken;   // current default recognizer token.
                                              // This is the token of the engine that is 
                                              // currently running (except for temporary switches
                                              // in order to train non-default engines.
    void CreateNewUser();                     // Adds a new speech user profile to the registry
    void DeleteCurrentUser();        // Deletes the current user
    void OnCancel();                 // Handles undoing the changes to the settings
    void UserSelChange( int iSelIndex);            
                                     // Handles a new selection
	void OnDrawItem( HWND hWnd, const DRAWITEMSTRUCT * pDrawStruct );  // handles item drawing
    void OnApply();
    void OnDestroy();
    void OnInitDialog(HWND hWnd);
    void ChangeDefaultUser();               // Changes the default user in the registry
    void ShutDown();                    // Shuts off the engine
    void EngineSelChange(BOOL fInitialize = FALSE);
    HRESULT IsCurRecoEngineAndCurRecoTokenMatch( bool *pfMatch );
    HRESULT TrySwitchDefaultEngine( bool fShowErrorMessages = false );
    HRESULT ResetDefaultEngine( bool fShowErrorMessages = true);
    bool IsRecoTokenCurrentlyBeingUsed( ISpObjectToken *pRecoToken );
    bool HasRecognizerChanged();
    void KickCPLUI();                       // Looks at the current requested defaults
                                            // and decides if "Apply" needs to be enabled
    void RecoContextError( BOOL fRecoContextExists = FALSE, BOOL fGiveErrorMessage = TRUE,
                            HRESULT hrRelevantError = E_FAIL );
    UINT HRESULTToErrorID( HRESULT hr );
    bool IsProfileNameInvisible( WCHAR *pwszProfile );

    HWND GetHDlg() { return m_hDlg; }
    ISpRecognizer *GetRecognizer() { return m_cpRecoEngine; }
    ISpRecoContext *GetRecoContext() { return m_cpRecoCtxt; }
    BOOL IsPreferredDevice() { return m_bPreferredDevice; }
    void SetPreferredDevice( BOOL b ) { m_bPreferredDevice = b; }

    friend BOOL CALLBACK SRDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend CEnvrPropDlg;
};

// Function Declarations
BOOL CALLBACK SRDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

class CEnvrPropDlg
{
public:
    CSRDlg            *         m_pParent;
    HWND                        m_hDlg;
    CComPtr<ISpObjectToken>     m_cpToken;
    int                         m_isModify;  // is this a new profile or a modify of an old profile

    CEnvrPropDlg(CSRDlg * pParent, ISpObjectToken * pToken) :
        m_cpToken(pToken),
        m_pParent(pParent)
    {
        CSpUnicodeSupport unicode;
        m_hinstRichEdit = unicode.LoadLibrary(L"riched20.dll");
        m_hDlg = NULL;
        m_isModify = 0;
    }

    ~CEnvrPropDlg()
    {
        FreeLibrary(m_hinstRichEdit);
    }

    BOOL InitDialog(HWND hDlg);
    EPD_RETURN_VALUE ApplyChanges();
    static INT_PTR CALLBACK DialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

private:
        HINSTANCE           m_hinstRichEdit; // used to allow rich edit controls
};

// Function Declarations
// Callback function to handle windows messages
BOOL CALLBACK EnvrDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Globals
extern CSRDlg *g_pSRDlg;
extern CEnvrDlg *g_pEnvrDlg;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\stuff.h ===
/*******************************************************************************
* Stuff.h *
*---------*
*   Description:
*       This is the header file for the speech control panel applet.
*-------------------------------------------------------------------------------
*  Created By: MIKEAR                            Date: 11/17/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef _Stuff_h
#define _Stuff_h

#include "TTSDlg.h"
#include "SRDlg.h"

// Globals

static BOOL   g_bNoInstallError = FALSE;
CTTSDlg      *g_pTTSDlg = NULL;
CSRDlg       *g_pSRDlg = NULL;
CEnvrDlg     *g_pEnvrDlg = NULL;

// Constants

const UINT      kcMaxPages = 3;

// This isn't in the NT4 headers

#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL		0x00400000L
#endif

#endif  // #ifdef _Stuff_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\speechcpl.cpp ===
// SpeechCpl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SpeechCplps.mk in the project directory.



#include "stdafx.h"
#include <initguid.h>
#include <assertwithstack.cpp>
#include "resource.h"
#include "stuff.h"
#include "sapiver.h"
#include <SpSatellite.h>

#define SAPI4CPL    L"speech.cpl"

#define SHLWAPIDLL "shlwapi.dll"


const CLSID LIBID_SPEECHCPLLib = { /* ae9b6e4a-dc9a-41cd-8d53-dcbc3673d5e2 */
    0xae9b6e4a,
    0xdc9a,
    0x41cd,
    {0x8d, 0x53, 0xdc, 0xbc, 0x36, 0x73, 0xd5, 0xe2}
  };


CComModule _Module;

BOOL IsIECurrentEnough();
BOOL g_fIEVersionGoodEnough = IsIECurrentEnough();
HINSTANCE g_hInstance;

CSpSatelliteDLL g_SatelliteDLL;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

// Forward definition of About dlgproc
BOOL CALLBACK AboutDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
bool IsSAPI4Installed();

/*****************************************************************************
* DllMain *
*---------*
*   Description:
*       DLL Entry Point
****************************************************************** MIKEAR ***/
#ifdef _WIN32_WCE
extern "C"
BOOL WINAPI DllMain(HANDLE hInst, DWORD dwReason, LPVOID /*lpReserved*/)
    HINSTANCE hInstance = (HINSTANCE)hInst;
#else
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
#endif
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;
		_Module.Init(ObjectMap, g_hInstance, &LIBID_SPEECHCPLLib);
        SHFusionInitializeFromModuleID(hInstance, 124);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        SHFusionUninitialize();
    }
    return TRUE;    // ok
} /* DllMain */

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}



// Error Messages
#if 0
void Error(HWND hWnd, HRESULT hRes, UINT uResID)
{
    SPDBG_FUNC( "Error" );
    WCHAR	szErrorTemplate[256];
    WCHAR	szError[288];
    WCHAR	szCaption[128];
    HMODULE hMod;
    UINT	uFlags;
    DWORD	dwRes;
    LPVOID	pvMsg;
    int		iLen;

    // Load the caption for the error message box

    iLen = LoadString(_Module.GetResourceInstance(), IDS_CAPTION, szCaption, 128);

    SPDBG_ASSERT(iLen != 0);

    // Was a resource ID specified?

    if (uResID == 0xFFFFFFFF) {

	    // Nope. Use the HRESULT.

	    // Is it a Speech error? NOTE: we have to check this before
	    // system error messages because there are conflicts between
	    // some speech errors (e.g. 0x80040202) and system errors.

	    // NOTE NOTE NOTE!!! This is NOT perfect. Since we don't know
	    // the context of the error here we won't be able to distinguish
	    // whether the error is really a speech error or a system error.
	    // Since we use speech heavily and the system errors that conflict
	    // are unlikely to occur in here, we'll check the speech errors
	    // first.

	    uFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;

	    if ((hRes >= 0x80040200) && (hRes <= 0x80040502)) {

		    WCHAR szSpeechDll[_MAX_PATH];
		    WCHAR *pchWindows;

		    // NOTE NOTE NOTE: use GetSystemDirectory instead of
		    // GetWindowsDirectory. GetWindowsDirectory doesn't
		    // work without registry manipulation under Hydra.

		    GetSystemDirectory(szSpeechDll, _MAX_PATH);

		    pchWindows = wcsrchr(szSpeechDll, '\\');

		    if (pchWindows)
			    *pchWindows = 0;

		    wcscat(szSpeechDll, kpszSpeechDllPath);

		    // Load speech.dll

            CSpUnicodeSupport unicode;
		    hMod = unicode.LoadLibrary(szSpeechDll);

		    if (hMod)
			    uFlags |= FORMAT_MESSAGE_FROM_HMODULE;
	    }

	    // Get the error string

	    dwRes = FormatMessage(uFlags, hMod, hRes, 0, (LPWSTR)&pvMsg, 0, NULL);

	    // Unload speech.dll (if necessary)

	    if (hMod)
		    FreeLibrary(hMod);

	    // Did we get the error message?

	    if (dwRes != 0)
            {
                MessageBox(hWnd, (LPTSTR)pvMsg, szCaption, MB_OK|MB_TOPMOST|g_dwIsRTLLayout);
                LocalFree(pvMsg);
                return;
	    }
    }

    // If this is an unknown error just put up a generic
    // message.

    if (uResID == 0xFFFFFFFF)
        uResID = IDS_E_INSTALL;

    // We don't want to show the user the IDS_E_INSTALL message more
    // than once.

    if ((uResID == IDS_E_INSTALL) && g_bNoInstallError)
        return;

    // Load the string resource

    iLen = LoadString(_Module.GetResourceInstance(), uResID, szErrorTemplate, 256);
    
    // It better be there

    SPDBG_ASSERT(iLen != 0);

    // Format and show the error

    wsprintf(szError, szErrorTemplate, hRes);
    MessageBox(hWnd, szError, szCaption, MB_OK|MB_TOPMOST|g_dwIsRTLLayout);
}
#endif


/*****************************************************************************
* RunControlPanel *
*-----------------*
*   Description:
*       Perform Control Panel initialization and display property sheet
****************************************************************** MIKEAR ***/
void RunControlPanel(HWND hWndCpl)
{

    SPDBG_FUNC( "RunControlPanel" );
    PROPSHEETHEADER psh;
    PROPSHEETPAGE rgpsp[kcMaxPages];
    HPROPSHEETPAGE rPages[kcMaxPages];

    UINT kcPages = 0;

    // Set up the property sheet header. NOTE: the
    // resources for the control panel applet are in
    // this module. For NT5, the resource loader handles
    // the multi-lingual UI by searching for a speech.cpl.mui
    // resource only DLL in the %system%\mui\XXXX directory
    // where XXXX is the hex langid.

    ZeroMemory(rgpsp, sizeof(PROPSHEETPAGE) * kcMaxPages);
    ZeroMemory(&psh, sizeof(PROPSHEETHEADER));
    ZeroMemory(rPages, sizeof(HPROPSHEETPAGE) * kcMaxPages);

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_DEFAULT;
    psh.hwndParent = hWndCpl;
    psh.hInstance = _Module.GetResourceInstance();
    psh.pszCaption = MAKEINTRESOURCE(IDS_CAPTION);
    psh.phpage = rPages;
    psh.nPages = 0;    // make sure psh.nPages gets an initial value

//    CComPtr<ISpEnumAudioInstance> cpEnumDevice;
    BOOL  fHaveVoices = FALSE;
    BOOL  fHaveRecognizers = FALSE;
    ULONG ulNumInputDevices = 1;
    ULONG ulNumOutputDevices = 1;

    // Get the voice and recognizer count
    CComPtr<ISpObjectToken> cpDefVoice;
    fHaveVoices = SUCCEEDED(SpGetDefaultTokenFromCategoryId(SPCAT_VOICES, &cpDefVoice));

    CComPtr<ISpObjectToken> cpDefReco;
    fHaveRecognizers = SUCCEEDED(SpGetDefaultTokenFromCategoryId(SPCAT_RECOGNIZERS, &cpDefReco));

    // Set up the PROPSHEETPAGE structure(s). If there are no voices
    // or no recognizers, then don't show the corresponding pages.  Also
    // don't show the page if there is only 1 voice or recognizer and
    // one device.

    if( fHaveRecognizers ) 
    {
        rgpsp[kcPages].dwSize = IsOS(OS_WHISTLERORGREATER)? sizeof(PROPSHEETPAGE) : PROPSHEETPAGE_V2_SIZE;
        rgpsp[kcPages].dwFlags = PSP_DEFAULT;
        rgpsp[kcPages].hInstance = _Module.GetResourceInstance();
        rgpsp[kcPages].pszTemplate = MAKEINTRESOURCE(IDD_SR);
        rgpsp[kcPages].pfnDlgProc = (DLGPROC)SRDlgProc;
        rPages[kcPages] = CreatePropertySheetPage(rgpsp+kcPages);
        kcPages++;
    }
    else
    {
        if ( g_pSRDlg )
        {
            delete g_pSRDlg;
            g_pSRDlg = NULL;
        }
    }

    if( fHaveVoices ) 
    {
        rgpsp[kcPages].dwSize = IsOS(OS_WHISTLERORGREATER)? sizeof(PROPSHEETPAGE) : PROPSHEETPAGE_V2_SIZE;
       rgpsp[kcPages].dwFlags = PSP_DEFAULT;
        rgpsp[kcPages].hInstance = _Module.GetResourceInstance();
        rgpsp[kcPages].pszTemplate = MAKEINTRESOURCE(IDD_TTS);
        rgpsp[kcPages].pfnDlgProc = (DLGPROC)TTSDlgProc;
        rPages[kcPages] = CreatePropertySheetPage(rgpsp+kcPages);
        kcPages++;
    }
    else
    {
        if ( g_pTTSDlg )
        {
            delete g_pTTSDlg;
            g_pTTSDlg = NULL;
        }
    }

    // Always display the "Other" (formerly "About") pane on OS <=Win2000 or
    // on Whister and beyond if Sapi4 is present
    if ( !IsOS(OS_WHISTLERORGREATER) || IsSAPI4Installed() )
    {
        rgpsp[kcPages].dwSize = IsOS(OS_WHISTLERORGREATER)? sizeof(PROPSHEETPAGE) : PROPSHEETPAGE_V2_SIZE;
        rgpsp[kcPages].dwFlags = PSP_DEFAULT ;
        rgpsp[kcPages].hInstance = _Module.GetResourceInstance();
        rgpsp[kcPages].pszTemplate = MAKEINTRESOURCE(IDD_ABOUT);
        rgpsp[kcPages].pfnDlgProc = (DLGPROC)AboutDlgProc;
        rPages[kcPages] = CreatePropertySheetPage(rgpsp+kcPages);
        kcPages++;
    }


    psh.nPages = kcPages;

    // Is the current default working language a
    // RTL reading language?

    if (GetSystemMetrics(SM_MIDEASTENABLED))
    {
        psh.dwFlags |= PSH_RTLREADING;
        rgpsp[0].dwFlags |= PSP_RTLREADING;
        g_dwIsRTLLayout = MB_RTLREADING;
    }

    // Show the property sheet
    ::PropertySheet(&psh);
   
} /* RunControlPanel */

/*****************************************************************************
* IsSAPI4Installed *
*------------------*
*   Description:
*       Returns true iff speech.cpl is found in the system directory
****************************************************************** BeckyW ***/
bool IsSAPI4Installed()
{
    WCHAR wszSystemDir[ MAX_PATH ];
    if ( ::GetSystemDirectory( wszSystemDir, sp_countof( wszSystemDir ) ) )
    {
        WCHAR wszFoundPath[ MAX_PATH ];
        WCHAR *pwchFile = NULL;
        wszFoundPath[0] = 0;
        return (0 != ::SearchPath( wszSystemDir, SAPI4CPL, NULL,
            sp_countof( wszFoundPath ), wszFoundPath, &pwchFile ));
    }

    return false;

}   /* IsSAPI4Installed */

/*****************************************************************************
* RunSAPI4CPL *
*-------------*
*   Description:
*       Runs speech.cpl and waits for it to exit
****************************************************************** BeckyW ***/
void RunSAPI4CPL()
{
    // Different OS's keep rundll32.exe in different directories,
    // so we'll just find it here
    WCHAR szStartProg[MAX_PATH];
    WCHAR *pchFilePart;
    ::SearchPath( NULL, _T("rundll32.exe"), NULL, MAX_PATH, 
        szStartProg, &pchFilePart );
    STARTUPINFO si;
    ZeroMemory( &si, sizeof(si) );
    PROCESS_INFORMATION pi;
    si.cb = sizeof(STARTUPINFO);
   ::CreateProcess( szStartProg, L"rundll32 shell32.dll,Control_RunDLL speech.cpl", 
      NULL, NULL, false, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi );

    // Wait for it to exit
    ::WaitForSingleObject( pi.hProcess, INFINITE );
}   /* RunSAPI4CPL */

/*****************************************************************************
* IsIECurrentEnough *
*-------------------*
*   Description:
*       Returns true iff the version of IE installed meets our requirements
*       (IE5 and higher)
****************************************************************** BeckyW ***/
BOOL IsIECurrentEnough()
{
    BOOL fCurrentEnough = false;

    DWORD dwDummy = 0;
    BYTE *pbBlock = NULL;
    DWORD dwSize = ::GetFileVersionInfoSizeA( SHLWAPIDLL, &dwDummy );
    if ( dwSize )
    {
        pbBlock = new BYTE[ dwSize ];
    }

    BOOL fSuccess = FALSE;
    if ( pbBlock )
    {
        fSuccess = ::GetFileVersionInfoA( SHLWAPIDLL, 0, dwSize, pbBlock );
    }

    LPVOID pvInfo = NULL;
    if ( fSuccess )
    {
        UINT uiLen = 0;
        fSuccess = ::VerQueryValueA( pbBlock, "\\", &pvInfo, &uiLen );
    }

    if ( fSuccess )
    {
        VS_FIXEDFILEINFO *pvffi = (VS_FIXEDFILEINFO *) pvInfo;
        WORD wVersion = HIWORD(pvffi->dwFileVersionMS);
        fCurrentEnough = HIWORD(pvffi->dwFileVersionMS) >= 5;
    }

    delete[] pbBlock;

    return fCurrentEnough;
}   /* IsIECurrentEnough */

/*****************************************************************************
* CPlApplet *
*-----------*
*   Description:
*       Required export for Control Panel applets
****************************************************************** MIKEAR ***/
LONG APIENTRY CPlApplet(HWND hWndCpl, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    SPDBG_FUNC( "CPlApplet" );

    // Standard CPL
    LPNEWCPLINFO lpNewCPlInfo;
    int tmpFlag;

	HRESULT hr = S_OK;

    switch (uMsg)
    { 
    case CPL_INIT:

        if (g_fIEVersionGoodEnough)
        {
            _Module.m_hInstResource = g_SatelliteDLL.Load(g_hInstance, TEXT("spcplui.dll"));
        }
#ifdef _DEBUG
        // Turn on memory leak checking
        tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag( tmpFlag );
#endif

        if ( FAILED( hr ) )
        {
            // CoInitialize failed, we can't run the CPL
            return 0;
        }
        
        return TRUE;
	          
    case CPL_EXIT:
        // These were new'ed right before RunControlPanel() was called
        if ( g_pSRDlg )
        {
            delete g_pSRDlg;
        }
        if ( g_pTTSDlg )
        {
            delete g_pTTSDlg;
        }

        return TRUE;
	          
    case CPL_GETCOUNT:
        {
            return g_fIEVersionGoodEnough ? 1 : 0;
        }
     
    case CPL_INQUIRE:
        LPCPLINFO lpCPLInfo;
        lpCPLInfo = (LPCPLINFO)lParam2;
        lpCPLInfo->lData = 0;
        
        lpCPLInfo->idIcon = IDI_SAPICPL;
        lpCPLInfo->idName = IDS_NAME;
        lpCPLInfo->idInfo = IDS_DESCRIPTION;
        break;

    case CPL_NEWINQUIRE:
        LPNEWCPLINFO lpNewCPLInfo;
        lpNewCPLInfo = (LPNEWCPLINFO) lParam2;

        lpNewCPLInfo->dwSize = sizeof( NEWCPLINFO );
        lpNewCPLInfo->hIcon = ::LoadIcon( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDI_SAPICPL ) );
        ::LoadString( _Module.GetResourceInstance(), IDS_NAME, lpNewCPLInfo->szName, 32 );
        ::LoadString( _Module.GetResourceInstance(), IDS_DESCRIPTION, lpNewCPLInfo->szInfo, 64 );

        break;
    
    case CPL_DBLCLK:
        {
            // Construct dialog pages and display property sheet

            if ( !g_fIEVersionGoodEnough )
            {
                // No can do: Can't run this guy since there isn't enough IE love
                WCHAR szError[ 256 ];
                szError[0] = 0;
                ::LoadString( _Module.GetResourceInstance(), IDS_NO_IE5, szError, sp_countof( szError ) );
                ::MessageBox( NULL, szError, NULL, MB_ICONEXCLAMATION | g_dwIsRTLLayout );
            }
            else
            {
                // setup TTS dialog
                g_pTTSDlg = new CTTSDlg();

                // setup SR dialog
                g_pSRDlg = new CSRDlg();

                if ( g_pTTSDlg && g_pSRDlg )
                {
                    RunControlPanel(hWndCpl);
                }
                else
                {
		            WCHAR szError[256];
		            szError[0] = '\0';
                    ::LoadString(_Module.GetResourceInstance(), IDS_OUTOFMEMORY, szError, sizeof(szError));
                    ::MessageBox(NULL, szError, NULL, MB_ICONWARNING|g_dwIsRTLLayout);
                }
            }

        }
        break;
    }     

    return 0; 
} /* CPlApplet */


/*****************************************************************************
* AboutDlgProc *
*--------------*
*   Description:
*       Dialog proc for the about propsheet
****************************************************************** BECKYW ****/
BOOL CALLBACK AboutDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SPDBG_FUNC( "AboutDlgProc" );

	USES_CONVERSION;

    static bool fSAPI4 = false;
    static WCHAR szHelpFile[ MAX_PATH ];

    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            WCHAR szVerString[ MAX_LOADSTRING ];
            ::LoadString( _Module.GetResourceInstance(),
                IDS_SAPI_VERSION, szVerString, sp_countof( szVerString ) );
            wcscat( szVerString, _T(VER_PRODUCTVERSION_STR) );
            ::SetDlgItemText( hWnd, IDC_STATIC_SAPIVER, szVerString );
                
            // Don't display help or file versioning on Whistler and beyond
            if ( IsOS(OS_WHISTLERORGREATER) )
            {
                ::ShowWindow( ::GetDlgItem( hWnd, IDC_ABOUT_HELP ), SW_HIDE );
                ::ShowWindow( ::GetDlgItem( hWnd, IDC_VERSION_STATIC ), SW_HIDE );
                ::ShowWindow( ::GetDlgItem( hWnd, IDC_STATIC_SAPIVER ), SW_HIDE );
            }
            else
            {
                // Display help only if it's there
                WCHAR szHelpDir[ MAX_PATH ];
                UINT uiRet = ::GetWindowsDirectory( szHelpDir, sp_countof( szHelpDir ) );
                DWORD dwRet = 0;
                if ( uiRet > 0 )
                {
                    wcscat( szHelpDir, L"\\Help" );
                    WCHAR *pchFilePart = NULL;
                    dwRet = ::SearchPath( szHelpDir, L"speech.chm", NULL, 
                        sp_countof( szHelpFile ), szHelpFile, &pchFilePart );
                }
                if ( 0 == dwRet )
                {
                    szHelpFile[0] = 0;
                    ::ShowWindow( ::GetDlgItem( hWnd, IDC_ABOUT_HELP ), SW_HIDE );
                }
            }

            // Display the link to SAPI4 only if SAPI4 is installed
            fSAPI4 = IsSAPI4Installed();
            if ( !fSAPI4 )
            {
                ::ShowWindow( ::GetDlgItem( hWnd, IDC_GROUP_SAPI4 ), SW_HIDE );
                ::ShowWindow( ::GetDlgItem( hWnd, IDC_STATIC_SAPI4 ), SW_HIDE );
                ::ShowWindow( ::GetDlgItem( hWnd, IDC_CPL_SAPI4 ), SW_HIDE );
            }
            break;
        }

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDC_ABOUT_HELP:
                {
                    if ( *szHelpFile )
                    {
                        CSpUnicodeSupport unicode;
                        unicode.HtmlHelp( NULL, szHelpFile, 0, 0 );
                    }

                    break;
                }

                case IDC_CPL_SAPI4:
                {
                    // Run SAPI4's control panel after exiting ours with a "Cancel"
                    HWND hwndParent = ::GetParent( hWnd );
                    PSHNOTIFY pshnot;
                    pshnot.lParam = 0;
                    pshnot.hdr.hwndFrom = hwndParent;
                    pshnot.hdr.code = PSN_QUERYCANCEL;
                    pshnot.hdr.idFrom = 0;
                    if ( g_pSRDlg )
                    {
                        ::SendMessage( g_pSRDlg->GetHDlg(), WM_NOTIFY, (WPARAM) hwndParent, (LPARAM) &pshnot );
                    }
                    if ( g_pTTSDlg )
                    {
                        ::SendMessage( g_pTTSDlg->GetHDlg(), WM_NOTIFY, (WPARAM) hwndParent, (LPARAM) &pshnot );
                    }

                    ::DestroyWindow( hwndParent );

                    RunSAPI4CPL();
                    break;
                }
                break;
            }
    }

    return FALSE;
} /* AboutDlgProc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\tom_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Apr 20 10:28:51 1999
 */
/* Compiler settings for tom.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_tom = {0x8CC497C9,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextDocument = {0x8CC497C0,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextRange = {0x8CC497C2,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextSelection = {0x8CC497C1,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextFont = {0x8CC497C3,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextPara = {0x8CC497C4,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextStoryRanges = {0x8CC497C5,0xA1DF,0x11ce,{0x80,0x98,0x00,0xAA,0x00,0x47,0xBE,0x5D}};


const IID IID_ITextDocument2 = {0x01c25500,0x4268,0x11d1,{0x88,0x3a,0x3c,0x8b,0x00,0xc1,0x00,0x00}};


const IID IID_ITextMsgFilter = {0xa3787420,0x4267,0x11d1,{0x88,0x3a,0x3c,0x8b,0x00,0xc1,0x00,0x00}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__20E01DF1_138E_11D3_A9DA_00C04F72DB1F__INCLUDED_)
#define AFX_STDAFX_H__20E01DF1_138E_11D3_A9DA_00C04F72DB1F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif

#define _WIN32_WINNT 0x0600

#ifndef _WIN32_IE
#define _WIN32_IE   0x0401
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <w95wraps.h>
#include <shlwapip.h>
#include <crtdbg.h>
#include <tchar.h>
#include <cpl.h>
#include <commctrl.h>
#include <htmlhelp.h>
#include <sapi.h>
#include <spdebug.h>
#include <spunicode.h>
#include <spuihelp.h>
#include <spddkhlp.h>
#include <shfusion.h>

static DWORD  g_dwIsRTLLayout = FALSE;

#ifdef _WIN32_WCE
#include <WinCEstub.h>
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__20E01DF1_138E_11D3_A9DA_00C04F72DB1F__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\include\makefile.inc ===
GenerateBuildNum :
	cd $(SPEECH_ROOT)
	cscript $(SPEECH_ROOT)\builder\makebldnum.sapi5.10.vbs $(O)
	cd $(SPEECH_ROOT)\sapi\include
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\ttsdlg.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <sapi.h>
#include <string.h>
#include "TTSDlg.h"
#include "audiodlg.h"
#include <spddkhlp.h>
#include "helpresource.h"
#include "srdlg.h"
#include "richedit.h"
#include <SPCollec.h>
#include "SAPIINT.h"
#include "SpATL.h"
#include "SpAutoHandle.h"
#include "SpAutoMutex.h"
#include "SpAutoEvent.h"
#include "spvoice.h"
#include <richedit.h>
#include <richole.h>
#include "tom.h"

static DWORD aKeywordIds[] = {
   // Control ID           // Help Context ID
   IDC_COMBO_VOICES,        IDH_LIST_TTS,
   IDC_TTS_ADV,             IDH_TTS_ADV,
   IDC_OUTPUT_SETTINGS,     IDH_OUTPUT_SETTINGS,
   IDC_SLIDER_SPEED,        IDH_SLIDER_SPEED,
   IDC_EDIT_SPEAK,          IDH_EDIT_SPEAK,
   IDC_SPEAK,               IDH_SPEAK,
   IDC_TTS_ICON,			IDH_NOHELP,
	IDC_DIRECTIONS,			IDH_NOHELP,
	IDC_TTS_CAP,			IDH_NOHELP,
	IDC_SLOW,				IDH_NOHELP,				
	IDC_NORMAL,				IDH_NOHELP,
	IDC_FAST,				IDH_NOHELP,
	IDC_GROUP_VOICESPEED,	IDH_NOHELP,
	IDC_GROUP_PREVIEWVOICE,	IDH_NOHELP,
   0,                       0
};

// Address of the TrackBar's WNDPROC
WNDPROC g_TrackBarWindowProc; 

// Our own internal TrackBar WNDPROC used to intercept and process VK_UP and VK_DOWN messages
LRESULT CALLBACK MyTrackBarWindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

/*****************************************************************************
* TTSDlgProc *
*------------*
*   Description:
*       DLGPROC for the TTS
****************************************************************** MIKEAR ***/
BOOL CALLBACK TTSDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SPDBG_FUNC( "TTSDlgProc" );

	USES_CONVERSION;

    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            g_pTTSDlg->OnInitDialog(hWnd);
            break;
        }

        case WM_DESTROY:
        {
            g_pTTSDlg->OnDestroy();
            break;
        }
       
		// Handle the context sensitive help
		case WM_CONTEXTMENU:
		{
			WinHelp((HWND) wParam, CPL_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR) aKeywordIds);
			break;
		}

		case WM_HELP:
		{
			WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, CPL_HELPFILE, HELP_WM_HELP,(DWORD_PTR)(LPSTR) aKeywordIds);
			break;
		}

        case WM_HSCROLL:
        {
            g_pTTSDlg->ChangeSpeed();

            break;
        }

        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code)
            {
                case PSN_APPLY:
                {
                    g_pTTSDlg->OnApply();
                    break;
                }
                
                case PSN_KILLACTIVE:
                {
                    // if the voice is speaking, stop it before switching tabs
                    if (g_pTTSDlg->m_bIsSpeaking) {
                        g_pTTSDlg->Speak();
                    }

                    break;
                }

                case PSN_QUERYCANCEL:  // user clicks the Cancel button
                {
                    if ( g_pSRDlg )
                    {
                        g_pSRDlg->OnCancel();
                    }
					break;
                }
            }
            break;

        case WM_COMMAND:
            switch ( LOWORD(wParam) )
            { 
                case IDC_COMBO_VOICES:
                {
                    if ( CBN_SELCHANGE == HIWORD(wParam) )
                    {
                        HRESULT hr = g_pTTSDlg->DefaultVoiceChange(false);
                        if ( SUCCEEDED( hr ) )
                        {
                            g_pTTSDlg->Speak();
                        }
                    }
                    break;
                }
                case IDC_OUTPUT_SETTINGS:
                {
					// if it's speaking make it stop
					g_pTTSDlg->StopSpeak();

                    ::SetFocus(GetDlgItem(g_pTTSDlg->m_hDlg, IDC_OUTPUT_SETTINGS));

                    // The m_pAudioDlg will be non-NULL only if the audio dialog
                    // has been previously brough up.
                    // Otherwise, we need a newly-initialized one
                    if ( !g_pTTSDlg->m_pAudioDlg )
                    {
                        g_pTTSDlg->m_pAudioDlg = new CAudioDlg(eOUTPUT );
                    }
                    
                    if (g_pTTSDlg->m_pAudioDlg != NULL)
                    {
                        ::DialogBoxParam( _Module.GetResourceInstance(), 
                                    MAKEINTRESOURCE( IDD_AUDIO_DEFAULT ),
                                    hWnd, 
                                    (DLGPROC) AudioDlgProc,
                                    (LPARAM) g_pTTSDlg->m_pAudioDlg );

                        if ( g_pTTSDlg->m_pAudioDlg->IsAudioDeviceChangedSinceLastTime() )
                        {
                            // Warn the user that he needs to apply the changes
                            WCHAR szWarning[MAX_LOADSTRING];
                            szWarning[0] = 0;
                            LoadString( _Module.GetResourceInstance(), IDS_AUDIOOUT_CHANGE_WARNING, szWarning, MAX_LOADSTRING);
                            MessageBox( g_pTTSDlg->GetHDlg(), szWarning, g_pTTSDlg->m_szCaption, MB_ICONWARNING | g_dwIsRTLLayout );
                        }
                    }

                    g_pTTSDlg->KickCPLUI();

                    break;
                }

				case IDC_EDIT_SPEAK:
				{
                    if (HIWORD(wParam) == EN_CHANGE)  // user is changing text
					{
						g_pTTSDlg->SetEditModified(true);
					}

                    break;
                }

                case IDC_SPEAK:
                {
                    g_pTTSDlg->Speak();
                    break;
                }

				case IDC_TTS_ADV:
				{
                    // convert the title of the window to wide chars
                    CSpDynamicString dstrTitle;
                    WCHAR szTitle[256];
                    szTitle[0] = '\0';
                    LoadString(_Module.GetResourceInstance(), IDS_ENGINE_SETTINGS, szTitle, sizeof(szTitle));
                    dstrTitle = szTitle;
					HRESULT hr = g_pTTSDlg->m_cpCurVoiceToken->DisplayUI(
                        hWnd, dstrTitle, SPDUI_EngineProperties, NULL, 0, NULL );
                    if ( FAILED( hr ) )
                    {
                        WCHAR szError[ MAX_LOADSTRING ];
                        ::LoadString( _Module.GetResourceInstance(), IDS_TTSUI_ERROR, szError, sp_countof( szError ) );
                        ::MessageBox( hWnd, szError, g_pTTSDlg->m_szCaption, MB_ICONEXCLAMATION | g_dwIsRTLLayout );
                        ::EnableWindow( ::GetDlgItem( hWnd, IDC_TTS_ADV ), FALSE );
                    }
					break;
				}
            }
            break;
    }

    return FALSE;
} /* TTSDlgProc */

/*****************************************************************************
* MyTrackBarWindowProc *
*------------*
*   Description:
*       This is our own privately sub-classed WNDPROC for the rate TrackBar. We 
*       tell the TTS dialog to use this one so we can pre-process the VK_UP and
*       VK_DOWN messages before the TrackBar's WNDPROC "incorrectly" handles them
*       on it's own. All other messages we just pass through to the TrackBar's 
*       WNDPROC.
****************************************************************** Leonro ***/
LRESULT CALLBACK MyTrackBarWindowProc( 
  HWND hwnd,      // handle to window
  UINT uMsg,      // message identifier
  WPARAM wParam,  // first message parameter
  LPARAM lParam   // second message parameter
)
{
    switch( uMsg )
    {
    case WM_KEYDOWN:
    case WM_KEYUP:
        if( wParam == VK_UP )
        {
            wParam = VK_RIGHT;
        }
        else if( wParam == VK_DOWN )
        {
            wParam = VK_LEFT;
        }
        break;  
    }

    return CallWindowProc( g_TrackBarWindowProc, hwnd, uMsg, wParam, lParam );
}

/*****************************************************************************
* CTTSDlg::SetEditModified( bool fModify ) *
*-----------------------*
*   Description:
*       Access method for m_fTextModified
****************************************************************** BRENTMID ***/
void CTTSDlg::SetEditModified( bool fModify )
{
	m_fTextModified = fModify;
}

/*****************************************************************************
* CTTSDlg::OnInitDialog *
*-----------------------*
*   Description:
*       Dialog Initialization
****************************************************************** BECKYW ***/
void CTTSDlg::OnInitDialog(HWND hWnd)
{
    USES_CONVERSION;
    SPDBG_FUNC( "CTTSDlg::OnInitDialog" );
    SPDBG_ASSERT(IsWindow(hWnd));
    m_hDlg = hWnd;

    // Put text on the speak button
    ChangeSpeakButton();

    // This is to be the caption for error messages
    m_szCaption[0] = 0;
    ::LoadString( _Module.GetResourceInstance(), IDS_CAPTION, m_szCaption, sp_countof( m_szCaption ) );

    // Initialize the TTS personality list
    InitTTSList( hWnd );

    // Set the range on the slider
    HWND hSlider = ::GetDlgItem( hWnd, IDC_SLIDER_SPEED );
    ::SendMessage( hSlider, TBM_SETRANGE, true, MAKELONG( VOICE_MIN_SPEED, VOICE_MAX_SPEED ) );

    // Retrieve address of the TrackBar's WNDPROC so we can sub-class it and intercept
    // and process the VK_UP and VK_DOWN messages before it handle's them on it's
    // own "incorrectly"
    g_TrackBarWindowProc = (WNDPROC)GetWindowLongPtr( hSlider, GWLP_WNDPROC );

    // Set the WNDPROC of the TrackBar to MyTrackBarWindowProc
    SetWindowLongPtr( hSlider, GWLP_WNDPROC, (LONG_PTR)MyTrackBarWindowProc );

    // Limit the text in the preview pane
    ::SendDlgItemMessage( hWnd, IDC_EDIT_SPEAK, EM_LIMITTEXT, MAX_EDIT_TEXT - 1, 0 );

    // Find the original default token
    SpGetDefaultTokenFromCategoryId( SPCAT_VOICES, &m_cpOriginalDefaultVoiceToken );

    // Set the appropriate voice
    DefaultVoiceChange(true);

} /* CTTSDlg::OnInitDialog */

/*****************************************************************************
* CTTSDlg::InitTTSList *
*----------------------*
*   Description:
*       Initializes the list control for the TTS dialog box.
*******************************************************************BECKYW****/
void CTTSDlg::InitTTSList( HWND hWnd )
{
    m_hTTSCombo = ::GetDlgItem( hWnd, IDC_COMBO_VOICES );

    SpInitTokenComboBox( m_hTTSCombo, SPCAT_VOICES );
}


/*****************************************************************************
* CTTSDlg::OnDestroy *
*--------------------*
*   Description:
*       Destruction
****************************************************************** MIKEAR ***/
void CTTSDlg::OnDestroy()
{
    SPDBG_FUNC( "CTTSDlg::OnDestroy" );

    if (m_cpVoice)
    {
        m_cpVoice->SetNotifySink(NULL);
        m_cpVoice.Release();
    }

    // Let go of the tokens in the combo box
    SpDestroyTokenComboBox( m_hTTSCombo );

} /* CTTSDlg::OnDestroy */

/*****************************************************************************
* CTTSDlg::OnApply *
*------------------*
*   Description:
*       Set user specified options
****************************************************************** BECKYW ***/
void CTTSDlg::OnApply()
{
    // SOFTWARE ENGINEERING OPPORTUNITY (BeckyW 7/28/00): This needs to 
    // return an error code

    SPDBG_FUNC( "CTTSDlg::OnApply" );

    m_bApplied = true;

    // Store the current voice
    HRESULT hr = E_FAIL;
    if (m_cpCurVoiceToken)
    {
        hr = SpSetDefaultTokenForCategoryId(SPCAT_VOICES,  m_cpCurVoiceToken );
    }
    if ( SUCCEEDED( hr ) )
    {
        m_cpOriginalDefaultVoiceToken = m_cpCurVoiceToken;
    }

    // Store the current audio out
    hr = S_OK;
    if ( m_pAudioDlg )
    {
        hr = m_pAudioDlg->OnApply();
        if ( FAILED( hr ) )
        {
            WCHAR szError[256];
			szError[0] = '\0';
			LoadString(_Module.GetResourceInstance(), IDS_AUDIO_CHANGE_FAILED, szError, sizeof(szError));
			MessageBox(m_hDlg, szError, m_szCaption, MB_ICONWARNING | g_dwIsRTLLayout);
        }

        // Kill the audio dialog, as we are done with it.
        delete m_pAudioDlg;
        m_pAudioDlg = NULL;

        // Re-create the voice, since we have audio changes to pick up
        DefaultVoiceChange(false);
    }

	// Store the voice rate in the registry
	int iCurRate = 0;
    HWND hSlider = ::GetDlgItem( m_hDlg, IDC_SLIDER_SPEED );
    iCurRate = (int)::SendMessage( hSlider, TBM_GETPOS, 0, 0 );

	CComPtr<ISpObjectTokenCategory> cpCategory;
	if (SUCCEEDED(SpGetCategoryFromId(SPCAT_VOICES, &cpCategory)))
	{
		CComPtr<ISpDataKey> cpDataKey;
		if (SUCCEEDED(cpCategory->GetDataKey(SPDKL_CurrentUser, &cpDataKey)))
		{
			cpDataKey->SetDWORD(SPVOICECATEGORY_TTSRATE, iCurRate);
		}
	}

    // Keep around the slider position for determining UI state later
    m_iOriginalRateSliderPos = iCurRate;
    

    KickCPLUI();

} /* CTTSDlg::OnApply */

/*****************************************************************************
* CTTSDlg::PopulateEditCtrl *
*---------------------------*
*   Description:
*       Populates the edit control with the name of the default voice.
****************************************************************** MIKEAR ***/
void CTTSDlg::PopulateEditCtrl( ISpObjectToken * pToken )
{
    SPDBG_FUNC( "CTTSDlg::PopulateEditCtrl" );
    HRESULT hr = S_OK;

    // Richedit/TOM 
    CComPtr<IRichEditOle>  cpRichEdit;         // OLE interface to the rich edit control
    CComPtr<ITextDocument> cpTextDoc;
    CComPtr<ITextRange>    cpTextRange;
    LANGID                 langId;

    WCHAR text[128], editText[MAX_PATH];
    HWND hWndEdit = ::GetDlgItem(m_hDlg, IDC_EDIT_SPEAK);

    CSpDynamicString dstrDescription;
    if ((SUCCEEDED(SpGetLanguageFromVoiceToken(pToken, &langId))) && (!m_fTextModified))
    {
        CComPtr<ISpObjectTokenCategory> cpCategory;
        CComPtr<ISpDataKey>             cpAttributesKey;
        CComPtr<ISpDataKey>             cpPreviewKey;
        CComPtr<ISpDataKey>             cpVoicesKey;
        int                             len;

        // First get language of voice from token.
        hr = SpGetDescription(pToken, &dstrDescription, langId);
        // Now get hold of preview key to try and find the appropriate text.
        if (SUCCEEDED(hr))
        {
            hr = SpGetCategoryFromId(SPCAT_VOICES, &cpCategory);
        }
        if (SUCCEEDED(hr))
        {
            hr = cpCategory->GetDataKey(SPDKL_LocalMachine, &cpVoicesKey);
        }
        if (SUCCEEDED(hr))
        {
            hr = cpVoicesKey->OpenKey(L"Preview", &cpPreviewKey);
        }
        if (SUCCEEDED(hr))
        {
            CSpDynamicString dstrText;
            swprintf(text, L"%x", langId);
            hr = cpPreviewKey->GetStringValue(text, &dstrText);
            if (SUCCEEDED(hr))
            {
                wcsncpy(text, dstrText, 127);
                text[127] = 0;
            }
        }
        // If preview key did not contain appropriate text, fall back to the hard-coded (and
        // potentially localized) text in the cpl resources.
        if (FAILED(hr))
        {
            len = LoadString( _Module.GetResourceInstance(), IDS_DEF_VOICE_TEXT, text, 128);
            if (len != 0)
            {
                hr = S_OK;
            }
        }
        if(SUCCEEDED(hr))
        {
            swprintf( editText, text, dstrDescription );

           ::SendMessage( hWndEdit, EM_GETOLEINTERFACE, 0, (LPARAM)(LPVOID FAR *)&cpRichEdit );
            if ( !cpRichEdit )
            {
                hr = E_FAIL;
            }
            if (SUCCEEDED(hr))
            {
               hr = cpRichEdit->QueryInterface( IID_ITextDocument, (void**)&cpTextDoc );
            }
            if (SUCCEEDED(hr))
            {
                hr = cpTextDoc->Range(0, MAX_EDIT_TEXT-1, &cpTextRange);
            }
            if (SUCCEEDED(hr))
            {
                BSTR bstrText = SysAllocString(editText);
                hr = cpTextRange->SetText(bstrText);
                SysFreeString(bstrText);
            }
            if (FAILED(hr))
            {
               // Do best we can with this API - unicode languages not equal to the OS language will be replaced with ???'s.
               SetWindowText(hWndEdit, editText );
            }
        }
    }
} /* CTTSDlg::PopulateEditCtrl */

/*****************************************************************************
* CTTSDlg::DefaultVoiceChange *
*-----------------------------*
*   Description:
*       Changes the current default voice.
*       If there is already a default voice in effect (i.e., if this is
*       not the first time we are calling this function), removes the 
*       checkmark from the appropriate item in the list.
*       Sets the checkmark to the appropriate item in the list.
*       Sets the voice with the appropriate token.
*   Return:
*       S_OK
*       E_UNEXPECTED if there is no token currently selected in the voice list
*       failure codes of SAPI voice initialization functions    
******************************************************************* BECKYW ***/
HRESULT CTTSDlg::DefaultVoiceChange(bool fUsePersistentRate)
{
    SPDBG_FUNC( "CTTSDlg::DefaultVoiceChange" );
    
    if ( m_bIsSpeaking )
    {
        // This forces the voice to stop speaking
        m_cpVoice->Speak( NULL, SPF_PURGEBEFORESPEAK, NULL );

        m_bIsSpeaking = false;

        ChangeSpeakButton();
    }

    if (m_cpVoice)
    {
        m_cpVoice->SetNotifySink(NULL);
        m_cpVoice.Release();
    }

    // Find out what is selected
    int iSelIndex = (int) ::SendMessage( m_hTTSCombo, CB_GETCURSEL, 0, 0 );
    m_cpCurVoiceToken = (ISpObjectToken *) ::SendMessage( m_hTTSCombo, CB_GETITEMDATA, iSelIndex, 0 );
    if ( CB_ERR == (LRESULT) m_cpCurVoiceToken.p )
    {
        m_cpCurVoiceToken = NULL;
    }

    HRESULT hr = E_UNEXPECTED;
    if (m_cpCurVoiceToken)
    {
        BOOL fSupported = FALSE;
        hr = m_cpCurVoiceToken->IsUISupported(SPDUI_EngineProperties, NULL, 0, NULL, &fSupported);
        if ( FAILED( hr ) )
        {
            fSupported = FALSE;
        }
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_TTS_ADV), fSupported);

        // Get the voice from the SR Dlg's recognizer, if possible.
        // Otherwise just CoCreate the voice
        ISpRecoContext *pRecoContext = 
            g_pSRDlg ? g_pSRDlg->GetRecoContext() : NULL;
        if ( pRecoContext )
        {
            hr = pRecoContext->GetVoice( &m_cpVoice );

            // Since the recocontext might not have changed, but we might have
            // changed the default audio object, just to be sure, we 
            // go and get the default audio out token and SetOutput
            CComPtr<ISpObjectToken> cpAudioToken;
            if ( SUCCEEDED( hr ) )
            {
                hr = SpGetDefaultTokenFromCategoryId( SPCAT_AUDIOOUT, &cpAudioToken );
            }
            else
            {
                hr = m_cpVoice.CoCreateInstance(CLSID_SpVoice);
            }

            
            if ( SUCCEEDED( hr ) )
            {
                hr = m_cpVoice->SetOutput( cpAudioToken, TRUE );
            }
        }
        else
        {
            hr = m_cpVoice.CoCreateInstance(CLSID_SpVoice);
        }

        if( SUCCEEDED( hr ) )
        {
            hr = m_cpVoice->SetVoice(m_cpCurVoiceToken);
        }
        if (SUCCEEDED(hr))
        {												    
            CComPtr<ISpNotifyTranslator> cpNotify;
            cpNotify.CoCreateInstance(CLSID_SpNotifyTranslator);
            cpNotify->InitSpNotifyCallback(this, 0, 0);
            m_cpVoice->SetInterest(SPFEI(SPEI_WORD_BOUNDARY) | SPFEI(SPEI_END_INPUT_STREAM), 0);
            m_cpVoice->SetNotifySink(cpNotify);

            // Set the appropriate speed on the slider
            if (fUsePersistentRate)
            {
			    CComPtr<ISpObjectTokenCategory> cpCategory;
			    ULONG ulCurRate=0;
			    if (SUCCEEDED(SpGetCategoryFromId(SPCAT_VOICES, &cpCategory)))
			    {
				    CComPtr<ISpDataKey> cpDataKey;
				    if (SUCCEEDED(cpCategory->GetDataKey(SPDKL_CurrentUser, &cpDataKey)))
				    {
					    cpDataKey->GetDWORD(SPVOICECATEGORY_TTSRATE, (ULONG*)&ulCurRate);
				    }
			    } 
                m_iOriginalRateSliderPos = ulCurRate;
            }
            else
            {
                m_iOriginalRateSliderPos = m_iSpeed;
            }

            HWND hSlider = ::GetDlgItem( m_hDlg, IDC_SLIDER_SPEED );
            ::SendMessage( hSlider, TBM_SETPOS, true, m_iOriginalRateSliderPos );

            // Enable the Preview Voice button
            ::EnableWindow( ::GetDlgItem( g_pTTSDlg->GetHDlg(), IDC_SPEAK ), TRUE );

        }
        else
        {
            // Warn the user of failure
            WCHAR szError[MAX_LOADSTRING];
            szError[0] = 0;
            LoadString( _Module.GetResourceInstance(), IDS_TTS_ERROR, szError, MAX_LOADSTRING);
            MessageBox( GetHDlg(), szError, m_szCaption, MB_ICONEXCLAMATION | g_dwIsRTLLayout );

            // Disable the Preview Voice button
            ::EnableWindow( ::GetDlgItem( GetHDlg(), IDC_SPEAK ), FALSE );
        }

        // Put text corresponding to this voice into the edit control
        PopulateEditCtrl(m_cpCurVoiceToken);
        
        // Kick the UI
        KickCPLUI();
    }

    return hr;
} /* CTTSDlg::DefaultVoiceChange */

/*****************************************************************************
* CTTSDlg::SetCheckmark *
*-----------------------*
*   Description:
*       Sets the specified item in the list control to be either checked
*       or unchecked (as the default voice)
******************************************************************************/
void CTTSDlg::SetCheckmark( HWND hList, int iIndex, bool bCheck )
{
    m_fForceCheckStateChange = true;
    
    ListView_SetCheckState( hList, iIndex, bCheck );

    m_fForceCheckStateChange = false;
}   /* CTTSDlg::SetCheckmark */

/*****************************************************************************
* CTTSDlg::KickCPLUI *
*--------------------*
*   Description:
*       Determines if there is anything to apply right now
******************************************************************************/
void CTTSDlg::KickCPLUI()
{
    bool fChanged = false;

    // Compare IDs
    CSpDynamicString dstrSelTokenID;
    CSpDynamicString dstrOriginalDefaultTokenID;
    HRESULT hr = E_FAIL;
    if ( m_cpOriginalDefaultVoiceToken && m_cpCurVoiceToken )
    {
        hr = m_cpCurVoiceToken->GetId( &dstrSelTokenID );
    }
    if ( SUCCEEDED( hr ) )
    {
        hr = m_cpOriginalDefaultVoiceToken->GetId( &dstrOriginalDefaultTokenID );
    }
    if ( SUCCEEDED( hr ) 
        && ( 0 != wcsicmp( dstrOriginalDefaultTokenID, dstrSelTokenID ) ) )
    {
        fChanged = true;
    }
    
    // Check the audio device
    if ( m_pAudioDlg && m_pAudioDlg->IsAudioDeviceChanged() )
    {
        fChanged = true;
    }

    // Check the voice rate
    int iSpeed = (int) ::SendDlgItemMessage( m_hDlg, IDC_SLIDER_SPEED, 
        TBM_GETPOS, 0, 0 );
    if ( m_iOriginalRateSliderPos != iSpeed )
    {
        fChanged = true;
    }

    // Tell the main propsheet
	HWND hwndParent = ::GetParent( m_hDlg );
    ::SendMessage( hwndParent, fChanged ? PSM_CHANGED : PSM_UNCHANGED, (WPARAM)(m_hDlg), 0 ); 

}   /* CTTSDlg::KickCPLUI */

/*****************************************************************************
* CTTSDlg::ChangeSpeed *
*----------------------*
*   Description:
*       Called when the slider has moved.
*       Adjusts the speed of the voice
****************************************************************** BECKYW ***/
void CTTSDlg::ChangeSpeed()
{
    HWND hSlider = ::GetDlgItem( m_hDlg, IDC_SLIDER_SPEED );
    m_iSpeed = (int)::SendMessage( hSlider, TBM_GETPOS, 0, 0 );
    m_cpVoice->SetRate( m_iSpeed );

    KickCPLUI();
}   /* CTTSDlg::ChangeSpeed */

/*****************************************************************************
* CTTSDlg::ChangeSpeakButton *
*----------------------------*
*   Description:
*       Changes the text in the "Preview Voice" button in order to
*       reflect whether there is currently a speak happening.
****************************************************************** BECKYW ***/
void CTTSDlg::ChangeSpeakButton()
{
    WCHAR pszButtonCaption[ MAX_LOADSTRING ];
    HWND hButton = ::GetDlgItem( m_hDlg, IDC_SPEAK );
    ::LoadString( _Module.GetResourceInstance(), m_bIsSpeaking ? IDS_STOP_PREVIEW : IDS_PREVIEW, 
        pszButtonCaption, MAX_LOADSTRING );
    ::SendMessage( hButton, WM_SETTEXT, 0, (LPARAM) pszButtonCaption );

	if (!m_bIsSpeaking)
	{
		::SetFocus(GetDlgItem(m_hDlg, IDC_SPEAK));
    }
}   /* CTTSDlg::ChangeSpeakButton */

/*****************************************************************************
* CTTSDlg::Speak *
*----------------*
*   Description:
*       Speaks the contents of the edit control.
*       If it is already speaking, shuts up.
****************************************************************** BECKYW ***/
void CTTSDlg::Speak()
{
    SPDBG_FUNC( "CTTSDlg::Speak" );
    if ( m_bIsSpeaking )
    {
        // This forces the voice to stop speaking
        m_cpVoice->Speak( NULL, SPF_PURGEBEFORESPEAK, NULL );

        m_bIsSpeaking = false;

        ChangeSpeakButton();
    }
    else
    {
        ChangeSpeed();

        GETTEXTEX gtex = { sp_countof(m_wszCurSpoken), GT_DEFAULT, 1200, NULL, NULL };
        m_wszCurSpoken[0] = 0;
        LRESULT cChars = ::SendDlgItemMessage(m_hDlg, 
            IDC_EDIT_SPEAK, EM_GETTEXTEX, (WPARAM)&gtex, (LPARAM)m_wszCurSpoken);

        if (cChars)
        {
            HRESULT hr = m_cpVoice->Speak(m_wszCurSpoken, SPF_ASYNC | SPF_PURGEBEFORESPEAK, NULL);
            if ( SUCCEEDED( hr ) )
            {
                m_bIsSpeaking = true;

                ::SetFocus(GetDlgItem(m_hDlg, IDC_EDIT_SPEAK));                 
                
                ChangeSpeakButton();             
            }
            else
            {
                // Warn the user that he needs to apply the changes
                WCHAR szError[MAX_LOADSTRING];
                szError[0] = 0;
                LoadString( _Module.GetResourceInstance(), IDS_SPEAK_ERROR, szError, MAX_LOADSTRING);
                MessageBox( GetHDlg(), szError, m_szCaption, MB_ICONWARNING | g_dwIsRTLLayout );
            }
        }
    }

} /* CTTSDlg::Speak */

/*****************************************************************************
* CTTSDlg::StopSpeak *
*----------------*
*   Description:
*       Stops the voice from speaking.
*       If it is already speaking, shuts up.
****************************************************************** BECKYW ***/
void CTTSDlg::StopSpeak()
{
    SPDBG_FUNC( "CTTSDlg::StopSpeak" );
    if ( m_bIsSpeaking )
    {
        // This forces the voice to stop speaking
        m_cpVoice->Speak( NULL, SPF_PURGEBEFORESPEAK, NULL );

        m_bIsSpeaking = false;
    }

    ChangeSpeakButton();
} /* CTTSDlg::StopSpeak */

/*****************************************************************************
* CTTSDlg::NotifyCallback *
*-------------------------*
*   Description:
*       Callback function that highlights words as they are spoken.
****************************************************************** MIKEAR ***/
STDMETHODIMP CTTSDlg::NotifyCallback(WPARAM /* wParam */, LPARAM /* lParam */)
{
    SPDBG_FUNC( "CTTSDlg::NotifyCallback" );

    SPVOICESTATUS Stat;
    m_cpVoice->GetStatus(&Stat, NULL);
    WPARAM nStart;
    LPARAM nEnd;
    if (Stat.dwRunningState & SPRS_DONE)
    {
        nStart = nEnd = 0;
        m_bIsSpeaking = false;
        ChangeSpeakButton();

        // Set the selection to an IP at the start of the text to speak
        ::SendDlgItemMessage( m_hDlg, IDC_EDIT_SPEAK, EM_SETSEL, 0, 0 );
    }
    else
    {
        nStart = (LPARAM)Stat.ulInputWordPos;
        nEnd = nStart + Stat.ulInputWordLen;
    
        CHARRANGE cr;
        cr.cpMin = (LONG)nStart;
        cr.cpMax = (LONG)nEnd;
        ::SendDlgItemMessage( m_hDlg, IDC_EDIT_SPEAK, EM_EXSETSEL, 0, (LPARAM) &cr );
    } 

    return S_OK;
} /* CTTSDlg::NotifyCallback */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\tom.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 07 14:12:12 1998
 */
/* Compiler settings for tom.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tomtmp_h__
#define __tomtmp_h__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __ITextDocument_FWD_DEFINED__
#define __ITextDocument_FWD_DEFINED__
typedef interface ITextDocument ITextDocument;
#endif 	/* __ITextDocument_FWD_DEFINED__ */


#ifndef __ITextRange_FWD_DEFINED__
#define __ITextRange_FWD_DEFINED__
typedef interface ITextRange ITextRange;
#endif 	/* __ITextRange_FWD_DEFINED__ */


#ifndef __ITextSelection_FWD_DEFINED__
#define __ITextSelection_FWD_DEFINED__
typedef interface ITextSelection ITextSelection;
#endif 	/* __ITextSelection_FWD_DEFINED__ */


#ifndef __ITextFont_FWD_DEFINED__
#define __ITextFont_FWD_DEFINED__
typedef interface ITextFont ITextFont;
#endif 	/* __ITextFont_FWD_DEFINED__ */


#ifndef __ITextPara_FWD_DEFINED__
#define __ITextPara_FWD_DEFINED__
typedef interface ITextPara ITextPara;
#endif 	/* __ITextPara_FWD_DEFINED__ */


#ifndef __ITextStoryRanges_FWD_DEFINED__
#define __ITextStoryRanges_FWD_DEFINED__
typedef interface ITextStoryRanges ITextStoryRanges;
#endif 	/* __ITextStoryRanges_FWD_DEFINED__ */


#ifndef __ITextDocument2_FWD_DEFINED__
#define __ITextDocument2_FWD_DEFINED__
typedef interface ITextDocument2 ITextDocument2;
#endif 	/* __ITextDocument2_FWD_DEFINED__ */


#ifndef __ITextMsgFilter_FWD_DEFINED__
#define __ITextMsgFilter_FWD_DEFINED__
typedef interface ITextMsgFilter ITextMsgFilter;
#endif 	/* __ITextMsgFilter_FWD_DEFINED__ */


#ifndef __ITextDocument_FWD_DEFINED__
#define __ITextDocument_FWD_DEFINED__
typedef interface ITextDocument ITextDocument;
#endif 	/* __ITextDocument_FWD_DEFINED__ */


#ifndef __ITextRange_FWD_DEFINED__
#define __ITextRange_FWD_DEFINED__
typedef interface ITextRange ITextRange;
#endif 	/* __ITextRange_FWD_DEFINED__ */


#ifndef __ITextSelection_FWD_DEFINED__
#define __ITextSelection_FWD_DEFINED__
typedef interface ITextSelection ITextSelection;
#endif 	/* __ITextSelection_FWD_DEFINED__ */


#ifndef __ITextFont_FWD_DEFINED__
#define __ITextFont_FWD_DEFINED__
typedef interface ITextFont ITextFont;
#endif 	/* __ITextFont_FWD_DEFINED__ */


#ifndef __ITextPara_FWD_DEFINED__
#define __ITextPara_FWD_DEFINED__
typedef interface ITextPara ITextPara;
#endif 	/* __ITextPara_FWD_DEFINED__ */


#ifndef __ITextStoryRanges_FWD_DEFINED__
#define __ITextStoryRanges_FWD_DEFINED__
typedef interface ITextStoryRanges ITextStoryRanges;
#endif 	/* __ITextStoryRanges_FWD_DEFINED__ */


#ifndef __ITextDocument2_FWD_DEFINED__
#define __ITextDocument2_FWD_DEFINED__
typedef interface ITextDocument2 ITextDocument2;
#endif 	/* __ITextDocument2_FWD_DEFINED__ */


#ifndef __ITextMsgFilter_FWD_DEFINED__
#define __ITextMsgFilter_FWD_DEFINED__
typedef interface ITextMsgFilter ITextMsgFilter;
#endif 	/* __ITextMsgFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL_itf_tom_0000
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */











extern RPC_IF_HANDLE __MIDL_itf_tom_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tom_0000_v0_0_s_ifspec;


#ifndef __tom_LIBRARY_DEFINED__
#define __tom_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: tom
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [version][uuid] */


typedef /* [public] */
enum __MIDL___MIDL_itf_tom_0000_0001
    {	tomFalse	= 0,
	tomTrue	= -1,
	tomUndefined	= -9999999,
	tomToggle	= -9999998,
	tomAutoColor	= -9999997,
	tomDefault	= -9999996,
	tomSuspend	= -9999995,
	tomResume	= -9999994,
	tomApplyNow	= 0,
	tomApplyLater	= 1,
	tomTrackParms	= 2,
	tomCacheParms	= 3,
	tomBackward	= 0xc0000001,
	tomForward	= 0x3fffffff,
	tomMove	= 0,
	tomExtend	= 1,
	tomNoSelection	= 0,
	tomSelectionIP	= 1,
	tomSelectionNormal	= 2,
	tomSelectionFrame	= 3,
	tomSelectionColumn	= 4,
	tomSelectionRow	= 5,
	tomSelectionBlock	= 6,
	tomSelectionInlineShape	= 7,
	tomSelectionShape	= 8,
	tomSelStartActive	= 1,
	tomSelAtEOL	= 2,
	tomSelOvertype	= 4,
	tomSelActive	= 8,
	tomSelReplace	= 16,
	tomEnd	= 0,
	tomStart	= 32,
	tomCollapseEnd	= 0,
	tomCollapseStart	= 1,
	tomClientCoord	= 256,
	tomNone	= 0,
	tomSingle	= 1,
	tomWords	= 2,
	tomDouble	= 3,
	tomDotted	= 4,
	tomDash	= 5,
	tomDashDot	= 6,
	tomDashDotDot	= 7,
	tomWave	= 8,
	tomThick	= 9,
	tomHair	= 10,
	tomLineSpaceSingle	= 0,
	tomLineSpace1pt5	= 1,
	tomLineSpaceDouble	= 2,
	tomLineSpaceAtLeast	= 3,
	tomLineSpaceExactly	= 4,
	tomLineSpaceMultiple	= 5,
	tomAlignLeft	= 0,
	tomAlignCenter	= 1,
	tomAlignRight	= 2,
	tomAlignJustify	= 3,
	tomAlignDecimal	= 3,
	tomAlignBar	= 4,
	tomAlignInterWord	= 3,
	tomAlignInterLetter	= 4,
	tomAlignScaled	= 5,
	tomAlignGlyphs	= 6,
	tomAlignSnapGrid	= 7,
	tomSpaces	= 0,
	tomDots	= 1,
	tomDashes	= 2,
	tomLines	= 3,
	tomThickLines	= 4,
	tomEquals	= 5,
	tomTabBack	= -3,
	tomTabNext	= -2,
	tomTabHere	= -1,
	tomListNone	= 0,
	tomListBullet	= 1,
	tomListNumberAsArabic	= 2,
	tomListNumberAsLCLetter	= 3,
	tomListNumberAsUCLetter	= 4,
	tomListNumberAsLCRoman	= 5,
	tomListNumberAsUCRoman	= 6,
	tomListNumberAsSequence	= 7,
	tomListParentheses	= 0x10000,
	tomListPeriod	= 0x20000,
	tomListPlain	= 0x30000,
	tomCharacter	= 1,
	tomWord	= 2,
	tomSentence	= 3,
	tomParagraph	= 4,
	tomLine	= 5,
	tomStory	= 6,
	tomScreen	= 7,
	tomSection	= 8,
	tomColumn	= 9,
	tomRow	= 10,
	tomWindow	= 11,
	tomCell	= 12,
	tomCharFormat	= 13,
	tomParaFormat	= 14,
	tomTable	= 15,
	tomObject	= 16,
	tomMatchWord	= 2,
	tomMatchCase	= 4,
	tomMatchPattern	= 8,
	tomUnknownStory	= 0,
	tomMainTextStory	= 1,
	tomFootnotesStory	= 2,
	tomEndnotesStory	= 3,
	tomCommentsStory	= 4,
	tomTextFrameStory	= 5,
	tomEvenPagesHeaderStory	= 6,
	tomPrimaryHeaderStory	= 7,
	tomEvenPagesFooterStory	= 8,
	tomPrimaryFooterStory	= 9,
	tomFirstPageHeaderStory	= 10,
	tomFirstPageFooterStory	= 11,
	tomNoAnimation	= 0,
	tomLasVegasLights	= 1,
	tomBlinkingBackground	= 2,
	tomSparkleText	= 3,
	tomMarchingBlackAnts	= 4,
	tomMarchingRedAnts	= 5,
	tomShimmer	= 6,
	tomWipeDown	= 7,
	tomWipeRight	= 8,
	tomAnimationMax	= 8,
	tomLowerCase	= 0,
	tomUpperCase	= 1,
	tomTitleCase	= 2,
	tomSentenceCase	= 4,
	tomToggleCase	= 5,
	tomReadOnly	= 0x100,
	tomShareDenyRead	= 0x200,
	tomShareDenyWrite	= 0x400,
	tomPasteFile	= 0x1000,
	tomCreateNew	= 0x10,
	tomCreateAlways	= 0x20,
	tomOpenExisting	= 0x30,
	tomOpenAlways	= 0x40,
	tomTruncateExisting	= 0x50,
	tomRTF	= 0x1,
	tomText	= 0x2,
	tomHTML	= 0x3,
	tomWordDocument	= 0x4,
	tomBold	= 0x80000001,
	tomItalic	= 0x80000002,
	tomUnderline	= 0x80000004,
	tomStrikeout	= 0x80000008,
	tomProtected	= 0x80000010,
	tomLink	= 0x80000020,
	tomSmallCaps	= 0x80000040,
	tomAllCaps	= 0x80000080,
	tomHidden	= 0x80000100,
	tomOutline	= 0x80000200,
	tomShadow	= 0x80000400,
	tomEmboss	= 0x80000800,
	tomImprint	= 0x80001000,
	tomDisabled	= 0x80002000,
	tomRevised	= 0x80004000,
	tomNormalCaret	= 0,
	tomKoreanBlockCaret	= 0x1,
	tomIncludeInset	= 0x1,
	tomIgnoreCurrentFont	= 0,
	tomMatchFontCharset	= 0x1,
	tomMatchFontSignature	= 0x2,
	tomCharset	= 0x80000000
    }	tomConstants;










EXTERN_C const IID LIBID_tom;

#ifndef __ITextDocument_INTERFACE_DEFINED__
#define __ITextDocument_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextDocument
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("8CC497C0-A1DF-11ce-8098-00AA0047BE5D")
    ITextDocument : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetName(
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSelection(
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryCount(
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryRanges(
            /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSaved(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSaved(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDefaultTabStop(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetDefaultTabStop(
            /* [in] */ float Value) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE New( void) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Open(
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Save(
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Freeze(
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Unfreeze(
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginEditCollection( void) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndEditCollection( void) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Undo(
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Redo(
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Range(
            /* [in] */ long cp1,
            /* [in] */ long cp2,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RangeFromPoint(
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextDocumentVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextDocument __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextDocument __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelection )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryCount )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryRanges )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaved )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSaved )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultTabStop )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultTabStop )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ float Value);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *New )(
            ITextDocument __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Freeze )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unfreeze )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEditCollection )(
            ITextDocument __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEditCollection )(
            ITextDocument __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Range )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ long cp1,
            /* [in] */ long cp2,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeFromPoint )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        END_INTERFACE
    } ITextDocumentVtbl;

    interface ITextDocument
    {
        CONST_VTBL struct ITextDocumentVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextDocument_GetName(This,pName)	\
    (This)->lpVtbl -> GetName(This,pName)

#define ITextDocument_GetSelection(This,ppSel)	\
    (This)->lpVtbl -> GetSelection(This,ppSel)

#define ITextDocument_GetStoryCount(This,pCount)	\
    (This)->lpVtbl -> GetStoryCount(This,pCount)

#define ITextDocument_GetStoryRanges(This,ppStories)	\
    (This)->lpVtbl -> GetStoryRanges(This,ppStories)

#define ITextDocument_GetSaved(This,pValue)	\
    (This)->lpVtbl -> GetSaved(This,pValue)

#define ITextDocument_SetSaved(This,Value)	\
    (This)->lpVtbl -> SetSaved(This,Value)

#define ITextDocument_GetDefaultTabStop(This,pValue)	\
    (This)->lpVtbl -> GetDefaultTabStop(This,pValue)

#define ITextDocument_SetDefaultTabStop(This,Value)	\
    (This)->lpVtbl -> SetDefaultTabStop(This,Value)

#define ITextDocument_New(This)	\
    (This)->lpVtbl -> New(This)

#define ITextDocument_Open(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Open(This,pVar,Flags,CodePage)

#define ITextDocument_Save(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Save(This,pVar,Flags,CodePage)

#define ITextDocument_Freeze(This,pCount)	\
    (This)->lpVtbl -> Freeze(This,pCount)

#define ITextDocument_Unfreeze(This,pCount)	\
    (This)->lpVtbl -> Unfreeze(This,pCount)

#define ITextDocument_BeginEditCollection(This)	\
    (This)->lpVtbl -> BeginEditCollection(This)

#define ITextDocument_EndEditCollection(This)	\
    (This)->lpVtbl -> EndEditCollection(This)

#define ITextDocument_Undo(This,Count,prop)	\
    (This)->lpVtbl -> Undo(This,Count,prop)

#define ITextDocument_Redo(This,Count,prop)	\
    (This)->lpVtbl -> Redo(This,Count,prop)

#define ITextDocument_Range(This,cp1,cp2,ppRange)	\
    (This)->lpVtbl -> Range(This,cp1,cp2,ppRange)

#define ITextDocument_RangeFromPoint(This,x,y,ppRange)	\
    (This)->lpVtbl -> RangeFromPoint(This,x,y,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetName_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB ITextDocument_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetSelection_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);


void __RPC_STUB ITextDocument_GetSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetStoryCount_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextDocument_GetStoryCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetStoryRanges_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories);


void __RPC_STUB ITextDocument_GetStoryRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetSaved_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextDocument_GetSaved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_SetSaved_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextDocument_SetSaved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetDefaultTabStop_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextDocument_GetDefaultTabStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_SetDefaultTabStop_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextDocument_SetDefaultTabStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_New_Proxy(
    ITextDocument __RPC_FAR * This);


void __RPC_STUB ITextDocument_New_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Open_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Flags,
    /* [in] */ long CodePage);


void __RPC_STUB ITextDocument_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Save_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Flags,
    /* [in] */ long CodePage);


void __RPC_STUB ITextDocument_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Freeze_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextDocument_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Unfreeze_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextDocument_Unfreeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_BeginEditCollection_Proxy(
    ITextDocument __RPC_FAR * This);


void __RPC_STUB ITextDocument_BeginEditCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_EndEditCollection_Proxy(
    ITextDocument __RPC_FAR * This);


void __RPC_STUB ITextDocument_EndEditCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Undo_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *prop);


void __RPC_STUB ITextDocument_Undo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Redo_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *prop);


void __RPC_STUB ITextDocument_Redo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Range_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ long cp1,
    /* [in] */ long cp2,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextDocument_Range_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_RangeFromPoint_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ long x,
    /* [in] */ long y,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextDocument_RangeFromPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextDocument_INTERFACE_DEFINED__ */


#ifndef __ITextRange_INTERFACE_DEFINED__
#define __ITextRange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextRange
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextRange;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("8CC497C2-A1DF-11ce-8098-00AA0047BE5D")
    ITextRange : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetText(
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetText(
            /* [in] */ BSTR bstr) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetChar(
            /* [retval][out] */ long __RPC_FAR *pch) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetChar(
            /* [in] */ long ch) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDuplicate(
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFormattedText(
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetFormattedText(
            /* [in] */ ITextRange __RPC_FAR *pRange) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStart(
            /* [retval][out] */ long __RPC_FAR *pcpFirst) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStart(
            /* [in] */ long cpFirst) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetEnd(
            /* [retval][out] */ long __RPC_FAR *pcpLim) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetEnd(
            /* [in] */ long cpLim) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFont(
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetFont(
            /* [in] */ ITextFont __RPC_FAR *pFont) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetPara(
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetPara(
            /* [in] */ ITextPara __RPC_FAR *pPara) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryLength(
            /* [retval][out] */ long __RPC_FAR *pcch) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryType(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Collapse(
            /* [in] */ long bStart) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Expand(
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetIndex(
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pIndex) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetIndex(
            /* [in] */ long Unit,
            /* [in] */ long Index,
            /* [in] */ long Extend) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetRange(
            /* [in] */ long cpActive,
            /* [in] */ long cpOther) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE InRange(
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE InStory(
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsEqual(
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Select( void) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StartOf(
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndOf(
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Move(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveStart(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveEnd(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveWhile(
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveStartWhile(
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveEndWhile(
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveUntil(
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveStartUntil(
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveEndUntil(
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindText(
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindTextStart(
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindTextEnd(
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Delete(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Cut(
            /* [out] */ VARIANT __RPC_FAR *pVar) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Copy(
            /* [out] */ VARIANT __RPC_FAR *pVar) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Paste(
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanPaste(
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanEdit(
            /* [retval][out] */ long __RPC_FAR *pbCanEdit) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ChangeCase(
            /* [in] */ long Type) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetPoint(
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetPoint(
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long Type,
            /* [in] */ long Extend) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ScrollIntoView(
            /* [in] */ long Value) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEmbeddedObject(
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextRangeVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextRange __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextRange __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextRange __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextRange __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextRange __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetText )(
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChar )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pch);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetChar )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long ch);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormattedText )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormattedText )(
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStart )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpFirst);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStart )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long cpFirst);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnd )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpLim);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnd )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long cpLim);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFont )(
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPara )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPara )(
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryLength )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcch);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryType )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Collapse )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long bStart);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndex )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pIndex);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIndex )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Index,
            /* [in] */ long Extend);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRange )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long cpActive,
            /* [in] */ long cpOther);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InRange )(
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InStory )(
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )(
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )(
            ITextRange __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartOf )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndOf )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStart )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEnd )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveWhile )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartWhile )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndWhile )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveUntil )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartUntil )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndUntil )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindText )(
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextStart )(
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextEnd )(
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cut )(
            ITextRange __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )(
            ITextRange __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Paste )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanPaste )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanEdit )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pbCanEdit);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeCase )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Type);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPoint )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPoint )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long Type,
            /* [in] */ long Extend);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScrollIntoView )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Value);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmbeddedObject )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);

        END_INTERFACE
    } ITextRangeVtbl;

    interface ITextRange
    {
        CONST_VTBL struct ITextRangeVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextRange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextRange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextRange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextRange_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextRange_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextRange_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextRange_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextRange_GetText(This,pbstr)	\
    (This)->lpVtbl -> GetText(This,pbstr)

#define ITextRange_SetText(This,bstr)	\
    (This)->lpVtbl -> SetText(This,bstr)

#define ITextRange_GetChar(This,pch)	\
    (This)->lpVtbl -> GetChar(This,pch)

#define ITextRange_SetChar(This,ch)	\
    (This)->lpVtbl -> SetChar(This,ch)

#define ITextRange_GetDuplicate(This,ppRange)	\
    (This)->lpVtbl -> GetDuplicate(This,ppRange)

#define ITextRange_GetFormattedText(This,ppRange)	\
    (This)->lpVtbl -> GetFormattedText(This,ppRange)

#define ITextRange_SetFormattedText(This,pRange)	\
    (This)->lpVtbl -> SetFormattedText(This,pRange)

#define ITextRange_GetStart(This,pcpFirst)	\
    (This)->lpVtbl -> GetStart(This,pcpFirst)

#define ITextRange_SetStart(This,cpFirst)	\
    (This)->lpVtbl -> SetStart(This,cpFirst)

#define ITextRange_GetEnd(This,pcpLim)	\
    (This)->lpVtbl -> GetEnd(This,pcpLim)

#define ITextRange_SetEnd(This,cpLim)	\
    (This)->lpVtbl -> SetEnd(This,cpLim)

#define ITextRange_GetFont(This,pFont)	\
    (This)->lpVtbl -> GetFont(This,pFont)

#define ITextRange_SetFont(This,pFont)	\
    (This)->lpVtbl -> SetFont(This,pFont)

#define ITextRange_GetPara(This,pPara)	\
    (This)->lpVtbl -> GetPara(This,pPara)

#define ITextRange_SetPara(This,pPara)	\
    (This)->lpVtbl -> SetPara(This,pPara)

#define ITextRange_GetStoryLength(This,pcch)	\
    (This)->lpVtbl -> GetStoryLength(This,pcch)

#define ITextRange_GetStoryType(This,pValue)	\
    (This)->lpVtbl -> GetStoryType(This,pValue)

#define ITextRange_Collapse(This,bStart)	\
    (This)->lpVtbl -> Collapse(This,bStart)

#define ITextRange_Expand(This,Unit,pDelta)	\
    (This)->lpVtbl -> Expand(This,Unit,pDelta)

#define ITextRange_GetIndex(This,Unit,pIndex)	\
    (This)->lpVtbl -> GetIndex(This,Unit,pIndex)

#define ITextRange_SetIndex(This,Unit,Index,Extend)	\
    (This)->lpVtbl -> SetIndex(This,Unit,Index,Extend)

#define ITextRange_SetRange(This,cpActive,cpOther)	\
    (This)->lpVtbl -> SetRange(This,cpActive,cpOther)

#define ITextRange_InRange(This,pRange,pb)	\
    (This)->lpVtbl -> InRange(This,pRange,pb)

#define ITextRange_InStory(This,pRange,pb)	\
    (This)->lpVtbl -> InStory(This,pRange,pb)

#define ITextRange_IsEqual(This,pRange,pb)	\
    (This)->lpVtbl -> IsEqual(This,pRange,pb)

#define ITextRange_Select(This)	\
    (This)->lpVtbl -> Select(This)

#define ITextRange_StartOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> StartOf(This,Unit,Extend,pDelta)

#define ITextRange_EndOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> EndOf(This,Unit,Extend,pDelta)

#define ITextRange_Move(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Move(This,Unit,Count,pDelta)

#define ITextRange_MoveStart(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveStart(This,Unit,Count,pDelta)

#define ITextRange_MoveEnd(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveEnd(This,Unit,Count,pDelta)

#define ITextRange_MoveWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveWhile(This,Cset,Count,pDelta)

#define ITextRange_MoveStartWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartWhile(This,Cset,Count,pDelta)

#define ITextRange_MoveEndWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndWhile(This,Cset,Count,pDelta)

#define ITextRange_MoveUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveUntil(This,Cset,Count,pDelta)

#define ITextRange_MoveStartUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartUntil(This,Cset,Count,pDelta)

#define ITextRange_MoveEndUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndUntil(This,Cset,Count,pDelta)

#define ITextRange_FindText(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindText(This,bstr,cch,Flags,pLength)

#define ITextRange_FindTextStart(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextStart(This,bstr,cch,Flags,pLength)

#define ITextRange_FindTextEnd(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextEnd(This,bstr,cch,Flags,pLength)

#define ITextRange_Delete(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Delete(This,Unit,Count,pDelta)

#define ITextRange_Cut(This,pVar)	\
    (This)->lpVtbl -> Cut(This,pVar)

#define ITextRange_Copy(This,pVar)	\
    (This)->lpVtbl -> Copy(This,pVar)

#define ITextRange_Paste(This,pVar,Format)	\
    (This)->lpVtbl -> Paste(This,pVar,Format)

#define ITextRange_CanPaste(This,pVar,Format,pb)	\
    (This)->lpVtbl -> CanPaste(This,pVar,Format,pb)

#define ITextRange_CanEdit(This,pbCanEdit)	\
    (This)->lpVtbl -> CanEdit(This,pbCanEdit)

#define ITextRange_ChangeCase(This,Type)	\
    (This)->lpVtbl -> ChangeCase(This,Type)

#define ITextRange_GetPoint(This,Type,px,py)	\
    (This)->lpVtbl -> GetPoint(This,Type,px,py)

#define ITextRange_SetPoint(This,x,y,Type,Extend)	\
    (This)->lpVtbl -> SetPoint(This,x,y,Type,Extend)

#define ITextRange_ScrollIntoView(This,Value)	\
    (This)->lpVtbl -> ScrollIntoView(This,Value)

#define ITextRange_GetEmbeddedObject(This,ppv)	\
    (This)->lpVtbl -> GetEmbeddedObject(This,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetText_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ITextRange_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetText_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ITextRange_SetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetChar_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pch);


void __RPC_STUB ITextRange_GetChar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetChar_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long ch);


void __RPC_STUB ITextRange_SetChar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetDuplicate_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextRange_GetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetFormattedText_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextRange_GetFormattedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetFormattedText_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange);


void __RPC_STUB ITextRange_SetFormattedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetStart_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcpFirst);


void __RPC_STUB ITextRange_GetStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetStart_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long cpFirst);


void __RPC_STUB ITextRange_SetStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetEnd_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcpLim);


void __RPC_STUB ITextRange_GetEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetEnd_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long cpLim);


void __RPC_STUB ITextRange_SetEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetFont_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont);


void __RPC_STUB ITextRange_GetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetFont_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextFont __RPC_FAR *pFont);


void __RPC_STUB ITextRange_SetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetPara_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara);


void __RPC_STUB ITextRange_GetPara_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetPara_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextPara __RPC_FAR *pPara);


void __RPC_STUB ITextRange_SetPara_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetStoryLength_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcch);


void __RPC_STUB ITextRange_GetStoryLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetStoryType_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextRange_GetStoryType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Collapse_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long bStart);


void __RPC_STUB ITextRange_Collapse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Expand_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_Expand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetIndex_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [retval][out] */ long __RPC_FAR *pIndex);


void __RPC_STUB ITextRange_GetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetIndex_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Index,
    /* [in] */ long Extend);


void __RPC_STUB ITextRange_SetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetRange_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long cpActive,
    /* [in] */ long cpOther);


void __RPC_STUB ITextRange_SetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_InRange_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_InRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_InStory_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_InStory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_IsEqual_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Select_Proxy(
    ITextRange __RPC_FAR * This);


void __RPC_STUB ITextRange_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_StartOf_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_StartOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_EndOf_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_EndOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Move_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveStart_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveEnd_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveWhile_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveWhile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveStartWhile_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveStartWhile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveEndWhile_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveEndWhile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveUntil_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveStartUntil_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveStartUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveEndUntil_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveEndUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_FindText_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ long cch,
    /* [in] */ long Flags,
    /* [retval][out] */ long __RPC_FAR *pLength);


void __RPC_STUB ITextRange_FindText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_FindTextStart_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ long cch,
    /* [in] */ long Flags,
    /* [retval][out] */ long __RPC_FAR *pLength);


void __RPC_STUB ITextRange_FindTextStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_FindTextEnd_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ long cch,
    /* [in] */ long Flags,
    /* [retval][out] */ long __RPC_FAR *pLength);


void __RPC_STUB ITextRange_FindTextEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Delete_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Cut_Proxy(
    ITextRange __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *pVar);


void __RPC_STUB ITextRange_Cut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Copy_Proxy(
    ITextRange __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *pVar);


void __RPC_STUB ITextRange_Copy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Paste_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Format);


void __RPC_STUB ITextRange_Paste_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_CanPaste_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Format,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_CanPaste_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_CanEdit_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pbCanEdit);


void __RPC_STUB ITextRange_CanEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_ChangeCase_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Type);


void __RPC_STUB ITextRange_ChangeCase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetPoint_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Type,
    /* [out] */ long __RPC_FAR *px,
    /* [out] */ long __RPC_FAR *py);


void __RPC_STUB ITextRange_GetPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetPoint_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long x,
    /* [in] */ long y,
    /* [in] */ long Type,
    /* [in] */ long Extend);


void __RPC_STUB ITextRange_SetPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_ScrollIntoView_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextRange_ScrollIntoView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetEmbeddedObject_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB ITextRange_GetEmbeddedObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextRange_INTERFACE_DEFINED__ */


#ifndef __ITextSelection_INTERFACE_DEFINED__
#define __ITextSelection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextSelection
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("8CC497C1-A1DF-11ce-8098-00AA0047BE5D")
    ITextSelection : public ITextRange
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFlags(
            /* [retval][out] */ long __RPC_FAR *pFlags) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetFlags(
            /* [in] */ LONG Flags) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetType(
            /* [retval][out] */ long __RPC_FAR *pType) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveLeft(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveRight(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveUp(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveDown(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE HomeKey(
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndKey(
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE TypeText(
            /* [in] */ BSTR bstr) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextSelectionVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextSelection __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextSelection __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextSelection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetText )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChar )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pch);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetChar )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long ch);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormattedText )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormattedText )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStart )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpFirst);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStart )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long cpFirst);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnd )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpLim);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnd )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long cpLim);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFont )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPara )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPara )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryLength )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcch);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryType )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Collapse )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long bStart);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndex )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pIndex);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIndex )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Index,
            /* [in] */ long Extend);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRange )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long cpActive,
            /* [in] */ long cpOther);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InRange )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InStory )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )(
            ITextSelection __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartOf )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndOf )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStart )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEnd )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveWhile )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartWhile )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndWhile )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveUntil )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartUntil )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndUntil )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindText )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextStart )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextEnd )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cut )(
            ITextSelection __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )(
            ITextSelection __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Paste )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanPaste )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanEdit )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pbCanEdit);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeCase )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Type);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPoint )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPoint )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long Type,
            /* [in] */ long Extend);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScrollIntoView )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Value);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmbeddedObject )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pFlags);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ LONG Flags);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pType);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveLeft )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveRight )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveUp )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveDown )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HomeKey )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndKey )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TypeText )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr);

        END_INTERFACE
    } ITextSelectionVtbl;

    interface ITextSelection
    {
        CONST_VTBL struct ITextSelectionVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextSelection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextSelection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextSelection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextSelection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextSelection_GetText(This,pbstr)	\
    (This)->lpVtbl -> GetText(This,pbstr)

#define ITextSelection_SetText(This,bstr)	\
    (This)->lpVtbl -> SetText(This,bstr)

#define ITextSelection_GetChar(This,pch)	\
    (This)->lpVtbl -> GetChar(This,pch)

#define ITextSelection_SetChar(This,ch)	\
    (This)->lpVtbl -> SetChar(This,ch)

#define ITextSelection_GetDuplicate(This,ppRange)	\
    (This)->lpVtbl -> GetDuplicate(This,ppRange)

#define ITextSelection_GetFormattedText(This,ppRange)	\
    (This)->lpVtbl -> GetFormattedText(This,ppRange)

#define ITextSelection_SetFormattedText(This,pRange)	\
    (This)->lpVtbl -> SetFormattedText(This,pRange)

#define ITextSelection_GetStart(This,pcpFirst)	\
    (This)->lpVtbl -> GetStart(This,pcpFirst)

#define ITextSelection_SetStart(This,cpFirst)	\
    (This)->lpVtbl -> SetStart(This,cpFirst)

#define ITextSelection_GetEnd(This,pcpLim)	\
    (This)->lpVtbl -> GetEnd(This,pcpLim)

#define ITextSelection_SetEnd(This,cpLim)	\
    (This)->lpVtbl -> SetEnd(This,cpLim)

#define ITextSelection_GetFont(This,pFont)	\
    (This)->lpVtbl -> GetFont(This,pFont)

#define ITextSelection_SetFont(This,pFont)	\
    (This)->lpVtbl -> SetFont(This,pFont)

#define ITextSelection_GetPara(This,pPara)	\
    (This)->lpVtbl -> GetPara(This,pPara)

#define ITextSelection_SetPara(This,pPara)	\
    (This)->lpVtbl -> SetPara(This,pPara)

#define ITextSelection_GetStoryLength(This,pcch)	\
    (This)->lpVtbl -> GetStoryLength(This,pcch)

#define ITextSelection_GetStoryType(This,pValue)	\
    (This)->lpVtbl -> GetStoryType(This,pValue)

#define ITextSelection_Collapse(This,bStart)	\
    (This)->lpVtbl -> Collapse(This,bStart)

#define ITextSelection_Expand(This,Unit,pDelta)	\
    (This)->lpVtbl -> Expand(This,Unit,pDelta)

#define ITextSelection_GetIndex(This,Unit,pIndex)	\
    (This)->lpVtbl -> GetIndex(This,Unit,pIndex)

#define ITextSelection_SetIndex(This,Unit,Index,Extend)	\
    (This)->lpVtbl -> SetIndex(This,Unit,Index,Extend)

#define ITextSelection_SetRange(This,cpActive,cpOther)	\
    (This)->lpVtbl -> SetRange(This,cpActive,cpOther)

#define ITextSelection_InRange(This,pRange,pb)	\
    (This)->lpVtbl -> InRange(This,pRange,pb)

#define ITextSelection_InStory(This,pRange,pb)	\
    (This)->lpVtbl -> InStory(This,pRange,pb)

#define ITextSelection_IsEqual(This,pRange,pb)	\
    (This)->lpVtbl -> IsEqual(This,pRange,pb)

#define ITextSelection_Select(This)	\
    (This)->lpVtbl -> Select(This)

#define ITextSelection_StartOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> StartOf(This,Unit,Extend,pDelta)

#define ITextSelection_EndOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> EndOf(This,Unit,Extend,pDelta)

#define ITextSelection_Move(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Move(This,Unit,Count,pDelta)

#define ITextSelection_MoveStart(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveStart(This,Unit,Count,pDelta)

#define ITextSelection_MoveEnd(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveEnd(This,Unit,Count,pDelta)

#define ITextSelection_MoveWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveWhile(This,Cset,Count,pDelta)

#define ITextSelection_MoveStartWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartWhile(This,Cset,Count,pDelta)

#define ITextSelection_MoveEndWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndWhile(This,Cset,Count,pDelta)

#define ITextSelection_MoveUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveUntil(This,Cset,Count,pDelta)

#define ITextSelection_MoveStartUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartUntil(This,Cset,Count,pDelta)

#define ITextSelection_MoveEndUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndUntil(This,Cset,Count,pDelta)

#define ITextSelection_FindText(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindText(This,bstr,cch,Flags,pLength)

#define ITextSelection_FindTextStart(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextStart(This,bstr,cch,Flags,pLength)

#define ITextSelection_FindTextEnd(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextEnd(This,bstr,cch,Flags,pLength)

#define ITextSelection_Delete(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Delete(This,Unit,Count,pDelta)

#define ITextSelection_Cut(This,pVar)	\
    (This)->lpVtbl -> Cut(This,pVar)

#define ITextSelection_Copy(This,pVar)	\
    (This)->lpVtbl -> Copy(This,pVar)

#define ITextSelection_Paste(This,pVar,Format)	\
    (This)->lpVtbl -> Paste(This,pVar,Format)

#define ITextSelection_CanPaste(This,pVar,Format,pb)	\
    (This)->lpVtbl -> CanPaste(This,pVar,Format,pb)

#define ITextSelection_CanEdit(This,pbCanEdit)	\
    (This)->lpVtbl -> CanEdit(This,pbCanEdit)

#define ITextSelection_ChangeCase(This,Type)	\
    (This)->lpVtbl -> ChangeCase(This,Type)

#define ITextSelection_GetPoint(This,Type,px,py)	\
    (This)->lpVtbl -> GetPoint(This,Type,px,py)

#define ITextSelection_SetPoint(This,x,y,Type,Extend)	\
    (This)->lpVtbl -> SetPoint(This,x,y,Type,Extend)

#define ITextSelection_ScrollIntoView(This,Value)	\
    (This)->lpVtbl -> ScrollIntoView(This,Value)

#define ITextSelection_GetEmbeddedObject(This,ppv)	\
    (This)->lpVtbl -> GetEmbeddedObject(This,ppv)


#define ITextSelection_GetFlags(This,pFlags)	\
    (This)->lpVtbl -> GetFlags(This,pFlags)

#define ITextSelection_SetFlags(This,Flags)	\
    (This)->lpVtbl -> SetFlags(This,Flags)

#define ITextSelection_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ITextSelection_MoveLeft(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveLeft(This,Unit,Count,Extend,pDelta)

#define ITextSelection_MoveRight(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveRight(This,Unit,Count,Extend,pDelta)

#define ITextSelection_MoveUp(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveUp(This,Unit,Count,Extend,pDelta)

#define ITextSelection_MoveDown(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveDown(This,Unit,Count,Extend,pDelta)

#define ITextSelection_HomeKey(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> HomeKey(This,Unit,Extend,pDelta)

#define ITextSelection_EndKey(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> EndKey(This,Unit,Extend,pDelta)

#define ITextSelection_TypeText(This,bstr)	\
    (This)->lpVtbl -> TypeText(This,bstr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextSelection_GetFlags_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pFlags);


void __RPC_STUB ITextSelection_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextSelection_SetFlags_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ LONG Flags);


void __RPC_STUB ITextSelection_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextSelection_GetType_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pType);


void __RPC_STUB ITextSelection_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveLeft_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveRight_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveRight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveUp_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveDown_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_HomeKey_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_HomeKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_EndKey_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_EndKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_TypeText_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ITextSelection_TypeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextSelection_INTERFACE_DEFINED__ */


#ifndef __ITextFont_INTERFACE_DEFINED__
#define __ITextFont_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextFont
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextFont;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("8CC497C3-A1DF-11ce-8098-00AA0047BE5D")
    ITextFont : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDuplicate(
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppFont) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetDuplicate(
            /* [in] */ ITextFont __RPC_FAR *pFont) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanChange(
            /* [retval][out] */ long __RPC_FAR *pB) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsEqual(
            /* [in] */ ITextFont __RPC_FAR *pFont,
            /* [retval][out] */ long __RPC_FAR *pB) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Reset(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStyle(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStyle(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetAllCaps(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetAllCaps(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetAnimation(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetAnimation(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetBackColor(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetBackColor(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetBold(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetBold(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetEmboss(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetEmboss(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetForeColor(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetForeColor(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetHidden(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetHidden(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetEngrave(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetEngrave(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetItalic(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetItalic(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetKerning(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetKerning(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLanguageID(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetLanguageID(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetName(
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetName(
            /* [in] */ BSTR bstr) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetOutline(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetOutline(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetPosition(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetPosition(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetProtected(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetProtected(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetShadow(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetShadow(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSize(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSize(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSmallCaps(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSmallCaps(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSpacing(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSpacing(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStrikeThrough(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStrikeThrough(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSubscript(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSubscript(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSuperscript(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSuperscript(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetUnderline(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetUnderline(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetWeight(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetWeight(
            /* [in] */ long Value) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextFontVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextFont __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextFont __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextFont __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextFont __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextFont __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextFont __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextFont __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppFont);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDuplicate )(
            ITextFont __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanChange )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pB);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )(
            ITextFont __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont,
            /* [retval][out] */ long __RPC_FAR *pB);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStyle )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStyle )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllCaps )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllCaps )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAnimation )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAnimation )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackColor )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackColor )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBold )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBold )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmboss )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEmboss )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForeColor )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForeColor )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHidden )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHidden )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEngrave )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEngrave )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItalic )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItalic )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKerning )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKerning )(
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguageID )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLanguageID )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )(
            ITextFont __RPC_FAR * This,
            /* [in] */ BSTR bstr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutline )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutline )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPosition )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPosition )(
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProtected )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProtected )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetShadow )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetShadow )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSize )(
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSmallCaps )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSmallCaps )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpacing )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSpacing )(
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStrikeThrough )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStrikeThrough )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubscript )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSubscript )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSuperscript )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSuperscript )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUnderline )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUnderline )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWeight )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWeight )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        END_INTERFACE
    } ITextFontVtbl;

    interface ITextFont
    {
        CONST_VTBL struct ITextFontVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextFont_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextFont_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextFont_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextFont_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextFont_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextFont_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextFont_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextFont_GetDuplicate(This,ppFont)	\
    (This)->lpVtbl -> GetDuplicate(This,ppFont)

#define ITextFont_SetDuplicate(This,pFont)	\
    (This)->lpVtbl -> SetDuplicate(This,pFont)

#define ITextFont_CanChange(This,pB)	\
    (This)->lpVtbl -> CanChange(This,pB)

#define ITextFont_IsEqual(This,pFont,pB)	\
    (This)->lpVtbl -> IsEqual(This,pFont,pB)

#define ITextFont_Reset(This,Value)	\
    (This)->lpVtbl -> Reset(This,Value)

#define ITextFont_GetStyle(This,pValue)	\
    (This)->lpVtbl -> GetStyle(This,pValue)

#define ITextFont_SetStyle(This,Value)	\
    (This)->lpVtbl -> SetStyle(This,Value)

#define ITextFont_GetAllCaps(This,pValue)	\
    (This)->lpVtbl -> GetAllCaps(This,pValue)

#define ITextFont_SetAllCaps(This,Value)	\
    (This)->lpVtbl -> SetAllCaps(This,Value)

#define ITextFont_GetAnimation(This,pValue)	\
    (This)->lpVtbl -> GetAnimation(This,pValue)

#define ITextFont_SetAnimation(This,Value)	\
    (This)->lpVtbl -> SetAnimation(This,Value)

#define ITextFont_GetBackColor(This,pValue)	\
    (This)->lpVtbl -> GetBackColor(This,pValue)

#define ITextFont_SetBackColor(This,Value)	\
    (This)->lpVtbl -> SetBackColor(This,Value)

#define ITextFont_GetBold(This,pValue)	\
    (This)->lpVtbl -> GetBold(This,pValue)

#define ITextFont_SetBold(This,Value)	\
    (This)->lpVtbl -> SetBold(This,Value)

#define ITextFont_GetEmboss(This,pValue)	\
    (This)->lpVtbl -> GetEmboss(This,pValue)

#define ITextFont_SetEmboss(This,Value)	\
    (This)->lpVtbl -> SetEmboss(This,Value)

#define ITextFont_GetForeColor(This,pValue)	\
    (This)->lpVtbl -> GetForeColor(This,pValue)

#define ITextFont_SetForeColor(This,Value)	\
    (This)->lpVtbl -> SetForeColor(This,Value)

#define ITextFont_GetHidden(This,pValue)	\
    (This)->lpVtbl -> GetHidden(This,pValue)

#define ITextFont_SetHidden(This,Value)	\
    (This)->lpVtbl -> SetHidden(This,Value)

#define ITextFont_GetEngrave(This,pValue)	\
    (This)->lpVtbl -> GetEngrave(This,pValue)

#define ITextFont_SetEngrave(This,Value)	\
    (This)->lpVtbl -> SetEngrave(This,Value)

#define ITextFont_GetItalic(This,pValue)	\
    (This)->lpVtbl -> GetItalic(This,pValue)

#define ITextFont_SetItalic(This,Value)	\
    (This)->lpVtbl -> SetItalic(This,Value)

#define ITextFont_GetKerning(This,pValue)	\
    (This)->lpVtbl -> GetKerning(This,pValue)

#define ITextFont_SetKerning(This,Value)	\
    (This)->lpVtbl -> SetKerning(This,Value)

#define ITextFont_GetLanguageID(This,pValue)	\
    (This)->lpVtbl -> GetLanguageID(This,pValue)

#define ITextFont_SetLanguageID(This,Value)	\
    (This)->lpVtbl -> SetLanguageID(This,Value)

#define ITextFont_GetName(This,pbstr)	\
    (This)->lpVtbl -> GetName(This,pbstr)

#define ITextFont_SetName(This,bstr)	\
    (This)->lpVtbl -> SetName(This,bstr)

#define ITextFont_GetOutline(This,pValue)	\
    (This)->lpVtbl -> GetOutline(This,pValue)

#define ITextFont_SetOutline(This,Value)	\
    (This)->lpVtbl -> SetOutline(This,Value)

#define ITextFont_GetPosition(This,pValue)	\
    (This)->lpVtbl -> GetPosition(This,pValue)

#define ITextFont_SetPosition(This,Value)	\
    (This)->lpVtbl -> SetPosition(This,Value)

#define ITextFont_GetProtected(This,pValue)	\
    (This)->lpVtbl -> GetProtected(This,pValue)

#define ITextFont_SetProtected(This,Value)	\
    (This)->lpVtbl -> SetProtected(This,Value)

#define ITextFont_GetShadow(This,pValue)	\
    (This)->lpVtbl -> GetShadow(This,pValue)

#define ITextFont_SetShadow(This,Value)	\
    (This)->lpVtbl -> SetShadow(This,Value)

#define ITextFont_GetSize(This,pValue)	\
    (This)->lpVtbl -> GetSize(This,pValue)

#define ITextFont_SetSize(This,Value)	\
    (This)->lpVtbl -> SetSize(This,Value)

#define ITextFont_GetSmallCaps(This,pValue)	\
    (This)->lpVtbl -> GetSmallCaps(This,pValue)

#define ITextFont_SetSmallCaps(This,Value)	\
    (This)->lpVtbl -> SetSmallCaps(This,Value)

#define ITextFont_GetSpacing(This,pValue)	\
    (This)->lpVtbl -> GetSpacing(This,pValue)

#define ITextFont_SetSpacing(This,Value)	\
    (This)->lpVtbl -> SetSpacing(This,Value)

#define ITextFont_GetStrikeThrough(This,pValue)	\
    (This)->lpVtbl -> GetStrikeThrough(This,pValue)

#define ITextFont_SetStrikeThrough(This,Value)	\
    (This)->lpVtbl -> SetStrikeThrough(This,Value)

#define ITextFont_GetSubscript(This,pValue)	\
    (This)->lpVtbl -> GetSubscript(This,pValue)

#define ITextFont_SetSubscript(This,Value)	\
    (This)->lpVtbl -> SetSubscript(This,Value)

#define ITextFont_GetSuperscript(This,pValue)	\
    (This)->lpVtbl -> GetSuperscript(This,pValue)

#define ITextFont_SetSuperscript(This,Value)	\
    (This)->lpVtbl -> SetSuperscript(This,Value)

#define ITextFont_GetUnderline(This,pValue)	\
    (This)->lpVtbl -> GetUnderline(This,pValue)

#define ITextFont_SetUnderline(This,Value)	\
    (This)->lpVtbl -> SetUnderline(This,Value)

#define ITextFont_GetWeight(This,pValue)	\
    (This)->lpVtbl -> GetWeight(This,pValue)

#define ITextFont_SetWeight(This,Value)	\
    (This)->lpVtbl -> SetWeight(This,Value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetDuplicate_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppFont);


void __RPC_STUB ITextFont_GetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetDuplicate_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ ITextFont __RPC_FAR *pFont);


void __RPC_STUB ITextFont_SetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextFont_CanChange_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextFont_CanChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextFont_IsEqual_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ ITextFont __RPC_FAR *pFont,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextFont_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextFont_Reset_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetStyle_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetStyle_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetAllCaps_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetAllCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetAllCaps_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetAllCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetAnimation_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetAnimation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetAnimation_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetAnimation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetBackColor_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetBackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetBackColor_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetBackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetBold_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetBold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetBold_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetBold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetEmboss_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetEmboss_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetEmboss_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetEmboss_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetForeColor_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetForeColor_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetHidden_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetHidden_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetHidden_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetHidden_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetEngrave_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetEngrave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetEngrave_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetEngrave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetItalic_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetItalic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetItalic_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetItalic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetKerning_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetKerning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetKerning_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetKerning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetLanguageID_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetLanguageID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetLanguageID_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetLanguageID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetName_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ITextFont_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetName_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ITextFont_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetOutline_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetOutline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetOutline_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetOutline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetPosition_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetPosition_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetProtected_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetProtected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetProtected_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetProtected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetShadow_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetShadow_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSize_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSize_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSmallCaps_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSmallCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSmallCaps_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetSmallCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSpacing_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSpacing_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetStrikeThrough_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetStrikeThrough_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetStrikeThrough_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetStrikeThrough_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSubscript_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSubscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSubscript_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetSubscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSuperscript_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSuperscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSuperscript_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetSuperscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetUnderline_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetUnderline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetUnderline_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetUnderline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetWeight_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetWeight_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextFont_INTERFACE_DEFINED__ */


#ifndef __ITextPara_INTERFACE_DEFINED__
#define __ITextPara_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextPara
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextPara;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("8CC497C4-A1DF-11ce-8098-00AA0047BE5D")
    ITextPara : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDuplicate(
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppPara) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetDuplicate(
            /* [in] */ ITextPara __RPC_FAR *pPara) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanChange(
            /* [retval][out] */ long __RPC_FAR *pB) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsEqual(
            /* [in] */ ITextPara __RPC_FAR *pPara,
            /* [retval][out] */ long __RPC_FAR *pB) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Reset(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStyle(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStyle(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetAlignment(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetAlignment(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetHyphenation(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetHyphenation(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFirstLineIndent(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetKeepTogether(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetKeepTogether(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetKeepWithNext(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetKeepWithNext(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLeftIndent(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLineSpacing(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLineSpacingRule(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListAlignment(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListAlignment(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListLevelIndex(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListLevelIndex(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListStart(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListStart(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListTab(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListTab(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListType(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListType(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetNoLineNumber(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetNoLineNumber(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetPageBreakBefore(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetPageBreakBefore(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetRightIndent(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetRightIndent(
            /* [in] */ float Value) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetIndents(
            /* [in] */ float StartIndent,
            /* [in] */ float LeftIndent,
            /* [in] */ float RightIndent) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetLineSpacing(
            /* [in] */ long LineSpacingRule,
            /* [in] */ float LineSpacing) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSpaceAfter(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSpaceAfter(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSpaceBefore(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSpaceBefore(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetWidowControl(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetWidowControl(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetTabCount(
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddTab(
            /* [in] */ float tbPos,
            /* [in] */ long tbAlign,
            /* [in] */ long tbLeader) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ClearAllTabs( void) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteTab(
            /* [in] */ float tbPos) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetTab(
            /* [in] */ long iTab,
            /* [out] */ float __RPC_FAR *ptbPos,
            /* [out] */ long __RPC_FAR *ptbAlign,
            /* [out] */ long __RPC_FAR *ptbLeader) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextParaVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextPara __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextPara __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextPara __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextPara __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextPara __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextPara __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextPara __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppPara);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDuplicate )(
            ITextPara __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanChange )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pB);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )(
            ITextPara __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara,
            /* [retval][out] */ long __RPC_FAR *pB);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStyle )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStyle )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAlignment )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlignment )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHyphenation )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHyphenation )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstLineIndent )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeepTogether )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKeepTogether )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeepWithNext )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKeepWithNext )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLeftIndent )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineSpacing )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineSpacingRule )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListAlignment )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListAlignment )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListLevelIndex )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListLevelIndex )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListStart )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListStart )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListTab )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListTab )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListType )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListType )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNoLineNumber )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNoLineNumber )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPageBreakBefore )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPageBreakBefore )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRightIndent )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRightIndent )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIndents )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float StartIndent,
            /* [in] */ float LeftIndent,
            /* [in] */ float RightIndent);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLineSpacing )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long LineSpacingRule,
            /* [in] */ float LineSpacing);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpaceAfter )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSpaceAfter )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpaceBefore )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSpaceBefore )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWidowControl )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWidowControl )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTabCount )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddTab )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float tbPos,
            /* [in] */ long tbAlign,
            /* [in] */ long tbLeader);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearAllTabs )(
            ITextPara __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteTab )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float tbPos);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTab )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long iTab,
            /* [out] */ float __RPC_FAR *ptbPos,
            /* [out] */ long __RPC_FAR *ptbAlign,
            /* [out] */ long __RPC_FAR *ptbLeader);

        END_INTERFACE
    } ITextParaVtbl;

    interface ITextPara
    {
        CONST_VTBL struct ITextParaVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextPara_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextPara_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextPara_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextPara_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextPara_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextPara_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextPara_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextPara_GetDuplicate(This,ppPara)	\
    (This)->lpVtbl -> GetDuplicate(This,ppPara)

#define ITextPara_SetDuplicate(This,pPara)	\
    (This)->lpVtbl -> SetDuplicate(This,pPara)

#define ITextPara_CanChange(This,pB)	\
    (This)->lpVtbl -> CanChange(This,pB)

#define ITextPara_IsEqual(This,pPara,pB)	\
    (This)->lpVtbl -> IsEqual(This,pPara,pB)

#define ITextPara_Reset(This,Value)	\
    (This)->lpVtbl -> Reset(This,Value)

#define ITextPara_GetStyle(This,pValue)	\
    (This)->lpVtbl -> GetStyle(This,pValue)

#define ITextPara_SetStyle(This,Value)	\
    (This)->lpVtbl -> SetStyle(This,Value)

#define ITextPara_GetAlignment(This,pValue)	\
    (This)->lpVtbl -> GetAlignment(This,pValue)

#define ITextPara_SetAlignment(This,Value)	\
    (This)->lpVtbl -> SetAlignment(This,Value)

#define ITextPara_GetHyphenation(This,pValue)	\
    (This)->lpVtbl -> GetHyphenation(This,pValue)

#define ITextPara_SetHyphenation(This,Value)	\
    (This)->lpVtbl -> SetHyphenation(This,Value)

#define ITextPara_GetFirstLineIndent(This,pValue)	\
    (This)->lpVtbl -> GetFirstLineIndent(This,pValue)

#define ITextPara_GetKeepTogether(This,pValue)	\
    (This)->lpVtbl -> GetKeepTogether(This,pValue)

#define ITextPara_SetKeepTogether(This,Value)	\
    (This)->lpVtbl -> SetKeepTogether(This,Value)

#define ITextPara_GetKeepWithNext(This,pValue)	\
    (This)->lpVtbl -> GetKeepWithNext(This,pValue)

#define ITextPara_SetKeepWithNext(This,Value)	\
    (This)->lpVtbl -> SetKeepWithNext(This,Value)

#define ITextPara_GetLeftIndent(This,pValue)	\
    (This)->lpVtbl -> GetLeftIndent(This,pValue)

#define ITextPara_GetLineSpacing(This,pValue)	\
    (This)->lpVtbl -> GetLineSpacing(This,pValue)

#define ITextPara_GetLineSpacingRule(This,pValue)	\
    (This)->lpVtbl -> GetLineSpacingRule(This,pValue)

#define ITextPara_GetListAlignment(This,pValue)	\
    (This)->lpVtbl -> GetListAlignment(This,pValue)

#define ITextPara_SetListAlignment(This,Value)	\
    (This)->lpVtbl -> SetListAlignment(This,Value)

#define ITextPara_GetListLevelIndex(This,pValue)	\
    (This)->lpVtbl -> GetListLevelIndex(This,pValue)

#define ITextPara_SetListLevelIndex(This,Value)	\
    (This)->lpVtbl -> SetListLevelIndex(This,Value)

#define ITextPara_GetListStart(This,pValue)	\
    (This)->lpVtbl -> GetListStart(This,pValue)

#define ITextPara_SetListStart(This,Value)	\
    (This)->lpVtbl -> SetListStart(This,Value)

#define ITextPara_GetListTab(This,pValue)	\
    (This)->lpVtbl -> GetListTab(This,pValue)

#define ITextPara_SetListTab(This,Value)	\
    (This)->lpVtbl -> SetListTab(This,Value)

#define ITextPara_GetListType(This,pValue)	\
    (This)->lpVtbl -> GetListType(This,pValue)

#define ITextPara_SetListType(This,Value)	\
    (This)->lpVtbl -> SetListType(This,Value)

#define ITextPara_GetNoLineNumber(This,pValue)	\
    (This)->lpVtbl -> GetNoLineNumber(This,pValue)

#define ITextPara_SetNoLineNumber(This,Value)	\
    (This)->lpVtbl -> SetNoLineNumber(This,Value)

#define ITextPara_GetPageBreakBefore(This,pValue)	\
    (This)->lpVtbl -> GetPageBreakBefore(This,pValue)

#define ITextPara_SetPageBreakBefore(This,Value)	\
    (This)->lpVtbl -> SetPageBreakBefore(This,Value)

#define ITextPara_GetRightIndent(This,pValue)	\
    (This)->lpVtbl -> GetRightIndent(This,pValue)

#define ITextPara_SetRightIndent(This,Value)	\
    (This)->lpVtbl -> SetRightIndent(This,Value)

#define ITextPara_SetIndents(This,StartIndent,LeftIndent,RightIndent)	\
    (This)->lpVtbl -> SetIndents(This,StartIndent,LeftIndent,RightIndent)

#define ITextPara_SetLineSpacing(This,LineSpacingRule,LineSpacing)	\
    (This)->lpVtbl -> SetLineSpacing(This,LineSpacingRule,LineSpacing)

#define ITextPara_GetSpaceAfter(This,pValue)	\
    (This)->lpVtbl -> GetSpaceAfter(This,pValue)

#define ITextPara_SetSpaceAfter(This,Value)	\
    (This)->lpVtbl -> SetSpaceAfter(This,Value)

#define ITextPara_GetSpaceBefore(This,pValue)	\
    (This)->lpVtbl -> GetSpaceBefore(This,pValue)

#define ITextPara_SetSpaceBefore(This,Value)	\
    (This)->lpVtbl -> SetSpaceBefore(This,Value)

#define ITextPara_GetWidowControl(This,pValue)	\
    (This)->lpVtbl -> GetWidowControl(This,pValue)

#define ITextPara_SetWidowControl(This,Value)	\
    (This)->lpVtbl -> SetWidowControl(This,Value)

#define ITextPara_GetTabCount(This,pCount)	\
    (This)->lpVtbl -> GetTabCount(This,pCount)

#define ITextPara_AddTab(This,tbPos,tbAlign,tbLeader)	\
    (This)->lpVtbl -> AddTab(This,tbPos,tbAlign,tbLeader)

#define ITextPara_ClearAllTabs(This)	\
    (This)->lpVtbl -> ClearAllTabs(This)

#define ITextPara_DeleteTab(This,tbPos)	\
    (This)->lpVtbl -> DeleteTab(This,tbPos)

#define ITextPara_GetTab(This,iTab,ptbPos,ptbAlign,ptbLeader)	\
    (This)->lpVtbl -> GetTab(This,iTab,ptbPos,ptbAlign,ptbLeader)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetDuplicate_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppPara);


void __RPC_STUB ITextPara_GetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetDuplicate_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ ITextPara __RPC_FAR *pPara);


void __RPC_STUB ITextPara_SetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_CanChange_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextPara_CanChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_IsEqual_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ ITextPara __RPC_FAR *pPara,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextPara_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_Reset_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetStyle_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetStyle_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetAlignment_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetAlignment_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetHyphenation_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetHyphenation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetHyphenation_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetHyphenation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetFirstLineIndent_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetFirstLineIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetKeepTogether_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetKeepTogether_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetKeepTogether_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetKeepTogether_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetKeepWithNext_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetKeepWithNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetKeepWithNext_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetKeepWithNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetLeftIndent_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetLeftIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetLineSpacing_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetLineSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetLineSpacingRule_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetLineSpacingRule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListAlignment_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListAlignment_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListLevelIndex_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListLevelIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListLevelIndex_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListLevelIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListStart_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListStart_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListTab_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListTab_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetListTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListType_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListType_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetNoLineNumber_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetNoLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetNoLineNumber_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetNoLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetPageBreakBefore_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetPageBreakBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetPageBreakBefore_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetPageBreakBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetRightIndent_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetRightIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetRightIndent_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetRightIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetIndents_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float StartIndent,
    /* [in] */ float LeftIndent,
    /* [in] */ float RightIndent);


void __RPC_STUB ITextPara_SetIndents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetLineSpacing_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long LineSpacingRule,
    /* [in] */ float LineSpacing);


void __RPC_STUB ITextPara_SetLineSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetSpaceAfter_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetSpaceAfter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetSpaceAfter_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetSpaceAfter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetSpaceBefore_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetSpaceBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetSpaceBefore_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetSpaceBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetWidowControl_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetWidowControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetWidowControl_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetWidowControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetTabCount_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextPara_GetTabCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_AddTab_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float tbPos,
    /* [in] */ long tbAlign,
    /* [in] */ long tbLeader);


void __RPC_STUB ITextPara_AddTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_ClearAllTabs_Proxy(
    ITextPara __RPC_FAR * This);


void __RPC_STUB ITextPara_ClearAllTabs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_DeleteTab_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float tbPos);


void __RPC_STUB ITextPara_DeleteTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetTab_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long iTab,
    /* [out] */ float __RPC_FAR *ptbPos,
    /* [out] */ long __RPC_FAR *ptbAlign,
    /* [out] */ long __RPC_FAR *ptbLeader);


void __RPC_STUB ITextPara_GetTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextPara_INTERFACE_DEFINED__ */


#ifndef __ITextStoryRanges_INTERFACE_DEFINED__
#define __ITextStoryRanges_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextStoryRanges
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextStoryRanges;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("8CC497C5-A1DF-11ce-8098-00AA0047BE5D")
    ITextStoryRanges : public IDispatch
    {
    public:
        virtual /* [restricted][id] */ HRESULT STDMETHODCALLTYPE _NewEnum(
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkEnum) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item(
            /* [in] */ long Index,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetCount(
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextStoryRangesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextStoryRanges __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextStoryRanges __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextStoryRanges __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [restricted][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )(
            ITextStoryRanges __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkEnum);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )(
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ long Index,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )(
            ITextStoryRanges __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        END_INTERFACE
    } ITextStoryRangesVtbl;

    interface ITextStoryRanges
    {
        CONST_VTBL struct ITextStoryRangesVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextStoryRanges_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoryRanges_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoryRanges_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoryRanges_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextStoryRanges_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextStoryRanges_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextStoryRanges_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextStoryRanges__NewEnum(This,ppunkEnum)	\
    (This)->lpVtbl -> _NewEnum(This,ppunkEnum)

#define ITextStoryRanges_Item(This,Index,ppRange)	\
    (This)->lpVtbl -> Item(This,Index,ppRange)

#define ITextStoryRanges_GetCount(This,pCount)	\
    (This)->lpVtbl -> GetCount(This,pCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [restricted][id] */ HRESULT STDMETHODCALLTYPE ITextStoryRanges__NewEnum_Proxy(
    ITextStoryRanges __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkEnum);


void __RPC_STUB ITextStoryRanges__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextStoryRanges_Item_Proxy(
    ITextStoryRanges __RPC_FAR * This,
    /* [in] */ long Index,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextStoryRanges_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextStoryRanges_GetCount_Proxy(
    ITextStoryRanges __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextStoryRanges_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoryRanges_INTERFACE_DEFINED__ */


#ifndef __ITextDocument2_INTERFACE_DEFINED__
#define __ITextDocument2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextDocument2
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextDocument2;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("01c25500-4268-11d1-883a-3c8b00c10000")
    ITextDocument2 : public ITextDocument
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachMsgFilter(
            /* [in] */ IUnknown __RPC_FAR *pFilter) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEffectColor(
            /* [in] */ long Index,
            /* [in] */ COLORREF cr) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEffectColor(
            /* [in] */ long Index,
            /* [out] */ COLORREF __RPC_FAR *pcr) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE GetCaretType(
            /* [retval][out] */ long __RPC_FAR *pCaretType) = 0;

        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE SetCaretType(
            /* [in] */ long CaretType) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetImmContext(
            /* [retval][out] */ long __RPC_FAR *pContext) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseImmContext(
            /* [in] */ long Context) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPreferredFont(
            /* [in] */ long cp,
            /* [in] */ long CodePage,
            /* [in] */ long Option,
            /* [out] */ BSTR __RPC_FAR *pbstr,
            /* [out] */ long __RPC_FAR *pPitchAndFamily) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE GetNotificationMode(
            /* [retval][out] */ long __RPC_FAR *pMode) = 0;

        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE SetNotificationMode(
            /* [in] */ long Mode) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetClientRect(
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *pLeft,
            /* [out] */ long __RPC_FAR *pTop,
            /* [out] */ long __RPC_FAR *pRight,
            /* [out] */ long __RPC_FAR *pBottom) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE GetSelectionEx(
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWindow(
            /* [out] */ long __RPC_FAR *phWnd) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFEFlags(
            /* [out] */ long __RPC_FAR *pFlags) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateWindow( void) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckTextLimit(
            long cch,
            long __RPC_FAR *pcch) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMEInProgress(
            long Mode) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextDocument2Vtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextDocument2 __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextDocument2 __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextDocument2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelection )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryCount )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryRanges )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaved )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSaved )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultTabStop )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultTabStop )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ float Value);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *New )(
            ITextDocument2 __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Freeze )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unfreeze )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEditCollection )(
            ITextDocument2 __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEditCollection )(
            ITextDocument2 __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Range )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long cp1,
            /* [in] */ long cp2,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeFromPoint )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachMsgFilter )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pFilter);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEffectColor )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Index,
            /* [in] */ COLORREF cr);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEffectColor )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Index,
            /* [out] */ COLORREF __RPC_FAR *pcr);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCaretType )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCaretType);

        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCaretType )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long CaretType);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImmContext )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pContext);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseImmContext )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Context);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPreferredFont )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long cp,
            /* [in] */ long CodePage,
            /* [in] */ long Option,
            /* [out] */ BSTR __RPC_FAR *pbstr,
            /* [out] */ long __RPC_FAR *pPitchAndFamily);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNotificationMode )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pMode);

        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotificationMode )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Mode);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClientRect )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *pLeft,
            /* [out] */ long __RPC_FAR *pTop,
            /* [out] */ long __RPC_FAR *pRight,
            /* [out] */ long __RPC_FAR *pBottom);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelectionEx )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWindow )(
            ITextDocument2 __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *phWnd);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFEFlags )(
            ITextDocument2 __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *pFlags);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateWindow )(
            ITextDocument2 __RPC_FAR * This);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckTextLimit )(
            ITextDocument2 __RPC_FAR * This,
            long cch,
            long __RPC_FAR *pcch);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IMEInProgress )(
            ITextDocument2 __RPC_FAR * This,
            long Mode);

        END_INTERFACE
    } ITextDocument2Vtbl;

    interface ITextDocument2
    {
        CONST_VTBL struct ITextDocument2Vtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextDocument2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextDocument2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextDocument2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextDocument2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextDocument2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextDocument2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextDocument2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextDocument2_GetName(This,pName)	\
    (This)->lpVtbl -> GetName(This,pName)

#define ITextDocument2_GetSelection(This,ppSel)	\
    (This)->lpVtbl -> GetSelection(This,ppSel)

#define ITextDocument2_GetStoryCount(This,pCount)	\
    (This)->lpVtbl -> GetStoryCount(This,pCount)

#define ITextDocument2_GetStoryRanges(This,ppStories)	\
    (This)->lpVtbl -> GetStoryRanges(This,ppStories)

#define ITextDocument2_GetSaved(This,pValue)	\
    (This)->lpVtbl -> GetSaved(This,pValue)

#define ITextDocument2_SetSaved(This,Value)	\
    (This)->lpVtbl -> SetSaved(This,Value)

#define ITextDocument2_GetDefaultTabStop(This,pValue)	\
    (This)->lpVtbl -> GetDefaultTabStop(This,pValue)

#define ITextDocument2_SetDefaultTabStop(This,Value)	\
    (This)->lpVtbl -> SetDefaultTabStop(This,Value)

#define ITextDocument2_New(This)	\
    (This)->lpVtbl -> New(This)

#define ITextDocument2_Open(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Open(This,pVar,Flags,CodePage)

#define ITextDocument2_Save(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Save(This,pVar,Flags,CodePage)

#define ITextDocument2_Freeze(This,pCount)	\
    (This)->lpVtbl -> Freeze(This,pCount)

#define ITextDocument2_Unfreeze(This,pCount)	\
    (This)->lpVtbl -> Unfreeze(This,pCount)

#define ITextDocument2_BeginEditCollection(This)	\
    (This)->lpVtbl -> BeginEditCollection(This)

#define ITextDocument2_EndEditCollection(This)	\
    (This)->lpVtbl -> EndEditCollection(This)

#define ITextDocument2_Undo(This,Count,prop)	\
    (This)->lpVtbl -> Undo(This,Count,prop)

#define ITextDocument2_Redo(This,Count,prop)	\
    (This)->lpVtbl -> Redo(This,Count,prop)

#define ITextDocument2_Range(This,cp1,cp2,ppRange)	\
    (This)->lpVtbl -> Range(This,cp1,cp2,ppRange)

#define ITextDocument2_RangeFromPoint(This,x,y,ppRange)	\
    (This)->lpVtbl -> RangeFromPoint(This,x,y,ppRange)


#define ITextDocument2_AttachMsgFilter(This,pFilter)	\
    (This)->lpVtbl -> AttachMsgFilter(This,pFilter)

#define ITextDocument2_SetEffectColor(This,Index,cr)	\
    (This)->lpVtbl -> SetEffectColor(This,Index,cr)

#define ITextDocument2_GetEffectColor(This,Index,pcr)	\
    (This)->lpVtbl -> GetEffectColor(This,Index,pcr)

#define ITextDocument2_GetCaretType(This,pCaretType)	\
    (This)->lpVtbl -> GetCaretType(This,pCaretType)

#define ITextDocument2_SetCaretType(This,CaretType)	\
    (This)->lpVtbl -> SetCaretType(This,CaretType)

#define ITextDocument2_GetImmContext(This,pContext)	\
    (This)->lpVtbl -> GetImmContext(This,pContext)

#define ITextDocument2_ReleaseImmContext(This,Context)	\
    (This)->lpVtbl -> ReleaseImmContext(This,Context)

#define ITextDocument2_GetPreferredFont(This,cp,CodePage,Option,pbstr,pPitchAndFamily)	\
    (This)->lpVtbl -> GetPreferredFont(This,cp,CodePage,Option,pbstr,pPitchAndFamily)

#define ITextDocument2_GetNotificationMode(This,pMode)	\
    (This)->lpVtbl -> GetNotificationMode(This,pMode)

#define ITextDocument2_SetNotificationMode(This,Mode)	\
    (This)->lpVtbl -> SetNotificationMode(This,Mode)

#define ITextDocument2_GetClientRect(This,Type,pLeft,pTop,pRight,pBottom)	\
    (This)->lpVtbl -> GetClientRect(This,Type,pLeft,pTop,pRight,pBottom)

#define ITextDocument2_GetSelectionEx(This,ppSel)	\
    (This)->lpVtbl -> GetSelectionEx(This,ppSel)

#define ITextDocument2_GetWindow(This,phWnd)	\
    (This)->lpVtbl -> GetWindow(This,phWnd)

#define ITextDocument2_GetFEFlags(This,pFlags)	\
    (This)->lpVtbl -> GetFEFlags(This,pFlags)

#define ITextDocument2_UpdateWindow(This)	\
    (This)->lpVtbl -> UpdateWindow(This)

#define ITextDocument2_CheckTextLimit(This,cch,pcch)	\
    (This)->lpVtbl -> CheckTextLimit(This,cch,pcch)

#define ITextDocument2_IMEInProgress(This,Mode)	\
    (This)->lpVtbl -> IMEInProgress(This,Mode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_AttachMsgFilter_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pFilter);


void __RPC_STUB ITextDocument2_AttachMsgFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SetEffectColor_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Index,
    /* [in] */ COLORREF cr);


void __RPC_STUB ITextDocument2_SetEffectColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetEffectColor_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Index,
    /* [out] */ COLORREF __RPC_FAR *pcr);


void __RPC_STUB ITextDocument2_GetEffectColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetCaretType_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCaretType);


void __RPC_STUB ITextDocument2_GetCaretType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SetCaretType_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long CaretType);


void __RPC_STUB ITextDocument2_SetCaretType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetImmContext_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pContext);


void __RPC_STUB ITextDocument2_GetImmContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_ReleaseImmContext_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Context);


void __RPC_STUB ITextDocument2_ReleaseImmContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetPreferredFont_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long cp,
    /* [in] */ long CodePage,
    /* [in] */ long Option,
    /* [out] */ BSTR __RPC_FAR *pbstr,
    /* [out] */ long __RPC_FAR *pPitchAndFamily);


void __RPC_STUB ITextDocument2_GetPreferredFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetNotificationMode_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pMode);


void __RPC_STUB ITextDocument2_GetNotificationMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SetNotificationMode_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Mode);


void __RPC_STUB ITextDocument2_SetNotificationMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetClientRect_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Type,
    /* [out] */ long __RPC_FAR *pLeft,
    /* [out] */ long __RPC_FAR *pTop,
    /* [out] */ long __RPC_FAR *pRight,
    /* [out] */ long __RPC_FAR *pBottom);


void __RPC_STUB ITextDocument2_GetClientRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetSelectionEx_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);


void __RPC_STUB ITextDocument2_GetSelectionEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetWindow_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *phWnd);


void __RPC_STUB ITextDocument2_GetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetFEFlags_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *pFlags);


void __RPC_STUB ITextDocument2_GetFEFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_UpdateWindow_Proxy(
    ITextDocument2 __RPC_FAR * This);


void __RPC_STUB ITextDocument2_UpdateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_CheckTextLimit_Proxy(
    ITextDocument2 __RPC_FAR * This,
    long cch,
    long __RPC_FAR *pcch);


void __RPC_STUB ITextDocument2_CheckTextLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_IMEInProgress_Proxy(
    ITextDocument2 __RPC_FAR * This,
    long Mode);


void __RPC_STUB ITextDocument2_IMEInProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextDocument2_INTERFACE_DEFINED__ */


#ifndef __ITextMsgFilter_INTERFACE_DEFINED__
#define __ITextMsgFilter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextMsgFilter
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][version][uuid] */



EXTERN_C const IID IID_ITextMsgFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("a3787420-4267-11d1-883a-3c8b00c10000")
    ITextMsgFilter : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachDocument(
            /* [in] */ HWND hwnd,
            /* [in] */ ITextDocument2 __RPC_FAR *pTextDoc) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HandleMessage(
            /* [out][in] */ UINT __RPC_FAR *pmsg,
            /* [out][in] */ WPARAM __RPC_FAR *pwparam,
            /* [out][in] */ LPARAM __RPC_FAR *plparam,
            /* [out] */ LRESULT __RPC_FAR *plres) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachMsgFilter(
            /* [in] */ ITextMsgFilter __RPC_FAR *pMsgFilter) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextMsgFilterVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextMsgFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextMsgFilter __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextMsgFilter __RPC_FAR * This);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachDocument )(
            ITextMsgFilter __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ ITextDocument2 __RPC_FAR *pTextDoc);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandleMessage )(
            ITextMsgFilter __RPC_FAR * This,
            /* [out][in] */ UINT __RPC_FAR *pmsg,
            /* [out][in] */ WPARAM __RPC_FAR *pwparam,
            /* [out][in] */ LPARAM __RPC_FAR *plparam,
            /* [out] */ LRESULT __RPC_FAR *plres);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachMsgFilter )(
            ITextMsgFilter __RPC_FAR * This,
            /* [in] */ ITextMsgFilter __RPC_FAR *pMsgFilter);

        END_INTERFACE
    } ITextMsgFilterVtbl;

    interface ITextMsgFilter
    {
        CONST_VTBL struct ITextMsgFilterVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextMsgFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextMsgFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextMsgFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextMsgFilter_AttachDocument(This,hwnd,pTextDoc)	\
    (This)->lpVtbl -> AttachDocument(This,hwnd,pTextDoc)

#define ITextMsgFilter_HandleMessage(This,pmsg,pwparam,plparam,plres)	\
    (This)->lpVtbl -> HandleMessage(This,pmsg,pwparam,plparam,plres)

#define ITextMsgFilter_AttachMsgFilter(This,pMsgFilter)	\
    (This)->lpVtbl -> AttachMsgFilter(This,pMsgFilter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextMsgFilter_AttachDocument_Proxy(
    ITextMsgFilter __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ ITextDocument2 __RPC_FAR *pTextDoc);


void __RPC_STUB ITextMsgFilter_AttachDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextMsgFilter_HandleMessage_Proxy(
    ITextMsgFilter __RPC_FAR * This,
    /* [out][in] */ UINT __RPC_FAR *pmsg,
    /* [out][in] */ WPARAM __RPC_FAR *pwparam,
    /* [out][in] */ LPARAM __RPC_FAR *plparam,
    /* [out] */ LRESULT __RPC_FAR *plres);


void __RPC_STUB ITextMsgFilter_HandleMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextMsgFilter_AttachMsgFilter_Proxy(
    ITextMsgFilter __RPC_FAR * This,
    /* [in] */ ITextMsgFilter __RPC_FAR *pMsgFilter);


void __RPC_STUB ITextMsgFilter_AttachMsgFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextMsgFilter_INTERFACE_DEFINED__ */

#endif /* __tom_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * );
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * );

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * );
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * );

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * );
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\cpl\ttsdlg.h ===
/*******************************************************************************
* TTSDlg.h *
*------------*
*   Description:
*       This is the header file for the default voice dialog.
*-------------------------------------------------------------------------------
*  Created By: MIKEAR                            Date: 11/17/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef _TTSDlg_h
#define _TTSDlg_h

#include "audiodlg.h"

#define MAX_EDIT_TEXT       1000
#define MAX_ATTRIB_LENGTH   1000 

const int VOICE_MAX_SPEED = 10;
const int VOICE_MIN_SPEED = -10;
 
class CTTSDlg : public ISpNotifyCallback
{
  private:
    BOOL                        m_bPreferredDevice;
    BOOL                        m_bApplied;
    BOOL                        m_bIsSpeaking;
    CComPtr<ISpVoice>           m_cpVoice;
    CComPtr<ISpObjectToken>     m_cpCurVoiceToken;
    CComPtr<ISpObjectToken>     m_cpOriginalDefaultVoiceToken;
    int                         m_iOriginalRateSliderPos;
    int                         m_iSpeed;
    CAudioDlg                   *m_pAudioDlg;
    HWND                        m_hDlg;
    HWND                        m_hTTSCombo;
    WCHAR                       m_wszCurSpoken[MAX_EDIT_TEXT];
    bool                        m_fTextModified;
    bool                        m_fForceCheckStateChange;
    WCHAR                       m_szCaption[ MAX_LOADSTRING ];

    HINSTANCE                   m_hinstRichEdit;

  public:
    CTTSDlg() :
        m_bPreferredDevice( true ),
        m_bApplied( false ),
        m_bIsSpeaking( false ),
        m_iOriginalRateSliderPos( 0 ),
        m_iSpeed( 0 ),
        m_pAudioDlg( NULL ),
        m_hDlg( NULL ),
        m_cpCurVoiceToken( NULL ),
        m_fTextModified( false ),
        m_fForceCheckStateChange( false )
    {
        CSpUnicodeSupport unicode;
        m_hinstRichEdit = unicode.LoadLibrary( L"riched20.dll" );
    }

    ~CTTSDlg()
    {
        if ( m_pAudioDlg )
        {
            delete m_pAudioDlg;
        }

        m_cpVoice.Release();
        m_cpCurVoiceToken.Release();
        m_cpOriginalDefaultVoiceToken.Release();

        if ( m_hinstRichEdit )
        {
            ::FreeLibrary( m_hinstRichEdit );
        }
    }
    
    STDMETHODIMP NotifyCallback(WPARAM wParam, LPARAM lParam);
    void OnApply();
    void OnDestroy();
    void OnInitDialog(HWND hWnd);
    void InitTTSList( HWND hWnd );
    void PopulateEditCtrl(ISpObjectToken *);
    HRESULT DefaultVoiceChange(bool fUsePersistentRate);
    void SetCheckmark( HWND hList, int iIndex, bool bCheck );
    void KickCPLUI();                       // Looks at the current requested defaults
                                            // and decides if "Apply" needs to be enabled
    void ChangeSpeed();
    void ChangeSpeakButton();
    void Speak();
    void StopSpeak();  // stops speaking if it's speaking
    inline HWND GetHDlg() { return m_hDlg; }
    inline BOOL IsPreferredDevice() { return m_bPreferredDevice; }
    inline void SetPreferredDevice( BOOL b ) { m_bPreferredDevice = b; }
	void SetEditModified( bool fModify );

    friend BOOL CALLBACK TTSDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

};

// Globals
extern CTTSDlg *g_pTTSDlg;
extern const LPTSTR kpszHelpFilename;
extern const DWORD krgHelpIDs[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\include\spcollec.h ===
/*****************************************************************************
* SPCollec.h *
*------------*
*       This header file contains the SAPI5 collection class templates. These
*   are a modified version of the MFC template classes without the dependencies.
*-----------------------------------------------------------------------------
*   Copyright (c) Microsoft Corporation. All rights reserved.
*****************************************************************************/
#ifndef SPCollec_h
#define SPCollec_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_STRING
#include <string.h>
#endif

#ifndef _INC_STDLIB
#include <stdlib.h>
#endif

#ifndef _WIN32_WCE
#ifndef _INC_SEARCH
#include <search.h>
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
#define SPASSERT_VALID( a )             // This doesn't do anything right now

typedef void* SPLISTPOS;
typedef DWORD SPLISTHANDLE;

#define SP_BEFORE_START_POSITION ((void*)-1L)

inline BOOL SPIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)
template<class TYPE>
inline HRESULT SPConstructElements(TYPE* pElements, int nCount)
{
    HRESULT hr = S_OK;
    SPDBG_ASSERT( nCount == 0 ||
             SPIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE ) );

    // default is bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));
    return hr;
}

template<class TYPE>
inline void SPDestructElements(TYPE* pElements, int nCount)
{
    SPDBG_ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE  ) ) );
    pElements;  // not used
    nCount; // not used

    // default does nothing
}

template<class TYPE>
inline HRESULT SPCopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    HRESULT hr = S_OK;
    SPDBG_ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pDest, nCount * sizeof(TYPE), TRUE  )) );
    SPDBG_ASSERT( ( nCount == 0 ||
               SPIsValidAddress( pSrc, nCount * sizeof(TYPE), FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof(TYPE));
    return hr;
}

template<class TYPE, class ARG_TYPE>
BOOL SPCompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    SPDBG_ASSERT( SPIsValidAddress( pElement1, sizeof(TYPE), FALSE ) );
    SPDBG_ASSERT( SPIsValidAddress( pElement2, sizeof(ARG_TYPE), FALSE ) );
    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT SPHashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(void*)(DWORD)key) >> 4;
}

/////////////////////////////////////////////////////////////////////////////
// CSPPlex

struct CSPPlex    // warning variable length structure
{
    CSPPlex* pNext;
    UINT nMax;
    UINT nCur;
    /* BYTE data[maxNum*elementSize]; */
    void* data() { return this+1; }

    static CSPPlex* PASCAL Create( CSPPlex*& pHead, UINT nMax, UINT cbElement )
    {
        CSPPlex* p = (CSPPlex*) new BYTE[sizeof(CSPPlex) + nMax * cbElement];
        SPDBG_ASSERT(p);
        p->nMax = nMax;
        p->nCur = 0;
        p->pNext = pHead;
        pHead = p;  // change head (adds in reverse order for simplicity)
        return p;
    }

    void FreeDataChain()
    {
        CSPPlex* p = this;
        while (p != NULL)
        {
            BYTE* bytes = (BYTE*) p;
            CSPPlex* pNext = p->pNext;
            delete[] bytes;
            p = pNext;
        }
    }
};


/////////////////////////////////////////////////////////////////////////////
// CSPArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CSPArray
{
public:
// Construction
    CSPArray();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    HRESULT SetSize(int nNewSize, int nGrowBy = -1);

// Operations
    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    HRESULT SetAtGrow(int nIndex, ARG_TYPE newElement);
    int Add(ARG_TYPE newElement);
    int Append(const CSPArray& src);
    HRESULT Copy(const CSPArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    HRESULT InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
    void    RemoveAt(int nIndex, int nCount = 1);
    HRESULT InsertAt(int nStartIndex, CSPArray* pNewArray);
    void    Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ));

// Implementation
protected:
    TYPE* m_pData;   // the actual array of data
    int m_nSize;     // # of elements (upperBound - 1)
    int m_nMaxSize;  // max allocated
    int m_nGrowBy;   // grow amount

public:
    ~CSPArray();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSPArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CSPArray<TYPE, ARG_TYPE>::GetSize() const
    { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CSPArray<TYPE, ARG_TYPE>::GetUpperBound() const
    { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CSPArray<TYPE, ARG_TYPE>::RemoveAll()
    { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { SPDBG_ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CSPArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { SPDBG_ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { SPDBG_ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CSPArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CSPArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CSPArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CSPArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CSPArray<TYPE, ARG_TYPE>::CSPArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CSPArray<TYPE, ARG_TYPE>::~CSPArray()
{
    SPASSERT_VALID( this );

    if (m_pData != NULL)
    {
        SPDestructElements(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
    SPASSERT_VALID( this );
    SPDBG_ASSERT( nNewSize >= 0 );
    HRESULT hr = S_OK;

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            SPDestructElements(m_pData, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        SPDBG_ASSERT( nNewSize <= SIZE_T_MAX/sizeof(TYPE) );    // no overflow
#endif
        m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
        if( m_pData )
        {
            hr = SPConstructElements(m_pData, nNewSize);
            if( SUCCEEDED( hr ) )
            {
                m_nSize = m_nMaxSize = nNewSize;
            }
            else
            {
                delete[] (BYTE*)m_pData;
                m_pData = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            hr = SPConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            SPDestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
        }

        if( SUCCEEDED( hr ) )
        {
            m_nSize = nNewSize;
        }
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determe growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        SPDBG_ASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
        SPDBG_ASSERT( nNewMax <= SIZE_T_MAX/sizeof(TYPE) ); // no overflow
#endif
        TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

        if( pNewData )
        {
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

            // construct remaining elements
            SPDBG_ASSERT( nNewSize > m_nSize );
            hr = SPConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

            // get rid of old stuff (note: no destructors called)
            delete[] (BYTE*)m_pData;
            m_pData = pNewData;
            m_nSize = nNewSize;
            m_nMaxSize = nNewMax;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

template<class TYPE, class ARG_TYPE>
int CSPArray<TYPE, ARG_TYPE>::Append(const CSPArray& src)
{
    SPASSERT_VALID( this );
    SPDBG_ASSERT( this != &src );   // cannot append to itself

    int nOldSize = m_nSize;
    HRESULT hr = SetSize(m_nSize + src.m_nSize);
    if( SUCCEEDED( hr ) )
    {
        hr = SPCopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);
    }
    return ( SUCCEEDED( hr ) )?(nOldSize):(-1);
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::Copy(const CSPArray& src)
{
    SPASSERT_VALID( this );
    SPDBG_ASSERT( this != &src );   // cannot copy to itself

    HRESULT hr = SetSize(src.m_nSize);
    if( SUCCEEDED( hr ) )
    {
        hr = SPCopyElements(m_pData, src.m_pData, src.m_nSize);
    }
    return hr;
}

template<class TYPE, class ARG_TYPE>
void CSPArray<TYPE, ARG_TYPE>::FreeExtra()
{
    SPASSERT_VALID( this );

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        SPDBG_ASSERT( m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
            SPDBG_ASSERT(pNewData);
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    SPASSERT_VALID( this );
    SPDBG_ASSERT( nIndex >= 0 );
    HRESULT hr = S_OK;

    if (nIndex >= m_nSize)
    {
        hr = SetSize(nIndex+1, -1);
    }

    if( SUCCEEDED( hr ) )
    {
        m_pData[nIndex] = newElement;
    }
    return hr;
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    SPASSERT_VALID( this );
    SPDBG_ASSERT( nIndex >= 0 );    // will expand to meet need
    SPDBG_ASSERT( nCount > 0 );     // zero or negative size not allowed
    HRESULT hr = S_OK;

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        hr = SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        hr = SetSize(m_nSize + nCount, -1);  // grow it to new size
        if( SUCCEEDED( hr ) )
        {
            // shift old data up to fill gap
            memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
                (nOldSize-nIndex) * sizeof(TYPE));

            // re-init slots we copied from
            hr = SPConstructElements(&m_pData[nIndex], nCount);
        }
    }

    // insert new value in the gap
    if( SUCCEEDED( hr ) )
    {
        SPDBG_ASSERT( nIndex + nCount <= m_nSize );
        while (nCount--)
            m_pData[nIndex++] = newElement;
    }
    return hr;
}

template<class TYPE, class ARG_TYPE>
void CSPArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
    SPASSERT_VALID( this );
    SPDBG_ASSERT( nIndex >= 0 );
    SPDBG_ASSERT( nCount >= 0 );
    SPDBG_ASSERT( nIndex + nCount <= m_nSize );

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    SPDestructElements(&m_pData[nIndex], nCount);
    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(TYPE));
    m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
HRESULT CSPArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CSPArray* pNewArray)
{
    SPASSERT_VALID( this );
    SPASSERT_VALID( pNewArray );
    SPDBG_ASSERT( nStartIndex >= 0 );
    HRESULT hr = S_OK;

    if (pNewArray->GetSize() > 0)
    {
        hr = InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; SUCCEEDED( hr )&& (i < pNewArray->GetSize()); i++)
        {
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
        }
    }
    return hr;
}

template<class TYPE, class ARG_TYPE>
void CSPArray<TYPE, ARG_TYPE>::Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ))
{
    SPASSERT_VALID( this );
    SPDBG_ASSERT( m_pData != NULL );

    qsort( m_pData, m_nSize, sizeof(TYPE), compare );
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CSPArray<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_pData == NULL)
    {
        SPDBG_ASSERT( m_nSize == 0 );
        SPDBG_ASSERT( m_nMaxSize == 0 );
    }
    else
    {
        SPDBG_ASSERT( m_nSize >= 0 );
        SPDBG_ASSERT( m_nMaxSize >= 0 );
        SPDBG_ASSERT( m_nSize <= m_nMaxSize );
        SPDBG_ASSERT( SPIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE), TRUE ) );
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CSPList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CSPList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:

// Construction
    CSPList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    SPLISTPOS AddHead(ARG_TYPE newElement);
    SPLISTPOS AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CSPList* pNewList);
    void AddTail(CSPList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    SPLISTPOS GetHeadPosition() const;
    SPLISTPOS GetTailPosition() const;
    TYPE& GetNext(SPLISTPOS& rPosition); // return *Position++
    TYPE GetNext(SPLISTPOS& rPosition) const; // return *Position++
    TYPE& GetPrev(SPLISTPOS& rPosition); // return *Position--
    TYPE GetPrev(SPLISTPOS& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(SPLISTPOS position);
    TYPE GetAt(SPLISTPOS position) const;
    void SetAt(SPLISTPOS pos, ARG_TYPE newElement);
    void RemoveAt(SPLISTPOS position);

    // inserting before or after a given position
    SPLISTPOS InsertBefore(SPLISTPOS position, ARG_TYPE newElement);
    SPLISTPOS InsertAfter(SPLISTPOS position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    SPLISTPOS Find(ARG_TYPE searchValue, SPLISTPOS startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    SPLISTPOS FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CSPPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CSPList();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSPList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CSPList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CSPList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetHead()
    {   SPDBG_ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetHead() const
    {   SPDBG_ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetTail()
    {   SPDBG_ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetTail() const
    {   SPDBG_ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline SPLISTPOS CSPList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (SPLISTPOS) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline SPLISTPOS CSPList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (SPLISTPOS) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetNext(SPLISTPOS& rPosition) // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        SPDBG_ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (SPLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetNext(SPLISTPOS& rPosition) const // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        SPDBG_ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (SPLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetPrev(SPLISTPOS& rPosition) // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        SPDBG_ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (SPLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetPrev(SPLISTPOS& rPosition) const // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        SPDBG_ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (SPLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CSPList<TYPE, ARG_TYPE>::GetAt(SPLISTPOS position)
    {   CNode* pNode = (CNode*) position;
        SPDBG_ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CSPList<TYPE, ARG_TYPE>::GetAt(SPLISTPOS position) const
    {   CNode* pNode = (CNode*) position;
        SPDBG_ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CSPList<TYPE, ARG_TYPE>::SetAt(SPLISTPOS pos, ARG_TYPE newElement)
    {   CNode* pNode = (CNode*) pos;
        SPDBG_ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode->data = newElement; }

/////////////////////////////////////////////////////////////////////////////
// CSPList<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CSPList<TYPE, ARG_TYPE>::CSPList( int nBlockSize )
{
    SPDBG_ASSERT( nBlockSize > 0 );

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::RemoveAll()
{
    SPASSERT_VALID( this );

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        SPDestructElements(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CSPList<TYPE, ARG_TYPE>::~CSPList()
{
    RemoveAll();
    SPDBG_ASSERT( m_nCount == 0 );
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CSPPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CSPPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CSPPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
CSPList<TYPE, ARG_TYPE>::CNode*
CSPList<TYPE, ARG_TYPE>::NewNode(CSPList::CNode* pPrev, CSPList::CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CSPPlex* pNewBlock = CSPPlex::Create(m_pBlocks, m_nBlockSize,sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }

    CSPList::CNode* pNode = m_pNodeFree;
    if( pNode )
    {
        if( SUCCEEDED( SPConstructElements(&pNode->data, 1) ) )
        {
            m_pNodeFree  = m_pNodeFree->pNext;
            pNode->pPrev = pPrev;
            pNode->pNext = pNext;
            m_nCount++;
            SPDBG_ASSERT( m_nCount > 0 );  // make sure we don't overflow
        }
    }
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::FreeNode(CSPList::CNode* pNode)
{
    SPDestructElements(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    SPDBG_ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    SPASSERT_VALID( this );

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    if( pNewNode )
    {
        pNewNode->data = newElement;
        if (m_pNodeHead != NULL)
            m_pNodeHead->pPrev = pNewNode;
        else
            m_pNodeTail = pNewNode;
        m_pNodeHead = pNewNode;
    }
    return (SPLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    SPASSERT_VALID( this );

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    if( pNewNode )
    {
        pNewNode->data = newElement;
        if (m_pNodeTail != NULL)
            m_pNodeTail->pNext = pNewNode;
        else
            m_pNodeHead = pNewNode;
        m_pNodeTail = pNewNode;
    }
    return (SPLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::AddHead(CSPList* pNewList)
{
    SPASSERT_VALID( this );
    SPASSERT_VALID( pNewList );

    // add a list of same elements to head (maintain order)
    SPLISTPOS pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::AddTail(CSPList* pNewList)
{
    SPASSERT_VALID( this );
    SPASSERT_VALID( pNewList );

    // add a list of same elements
    SPLISTPOS pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CSPList<TYPE, ARG_TYPE>::RemoveHead()
{
    SPASSERT_VALID( this );
    SPDBG_ASSERT( m_pNodeHead != NULL );  // don't call on empty list !!!
    SPDBG_ASSERT( SPIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CSPList<TYPE, ARG_TYPE>::RemoveTail()
{
    SPASSERT_VALID( this );
    SPDBG_ASSERT( m_pNodeTail != NULL );  // don't call on empty list !!!
    SPDBG_ASSERT( SPIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::InsertBefore(SPLISTPOS position, ARG_TYPE newElement)
{
    SPASSERT_VALID( this );

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    if( pNewNode )
    {
        pNewNode->data = newElement;

        if (pOldNode->pPrev != NULL)
        {
            SPDBG_ASSERT( SPIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
            pOldNode->pPrev->pNext = pNewNode;
        }
        else
        {
            SPDBG_ASSERT( pOldNode == m_pNodeHead );
            m_pNodeHead = pNewNode;
        }
        pOldNode->pPrev = pNewNode;
    }
    return (SPLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::InsertAfter(SPLISTPOS position, ARG_TYPE newElement)
{
    SPASSERT_VALID( this );

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    SPDBG_ASSERT( SPIsValidAddress(pOldNode, sizeof(CNode), TRUE ));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    if( pNewNode )
    {
        pNewNode->data = newElement;

        if (pOldNode->pNext != NULL)
        {
            SPDBG_ASSERT( SPIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ));
            pOldNode->pNext->pPrev = pNewNode;
        }
        else
        {
            SPDBG_ASSERT( pOldNode == m_pNodeTail );
            m_pNodeTail = pNewNode;
        }
        pOldNode->pNext = pNewNode;
    }
    return (SPLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::RemoveAt(SPLISTPOS position)
{
    SPASSERT_VALID( this );

    CNode* pOldNode = (CNode*) position;
    SPDBG_ASSERT( SPIsValidAddress(pOldNode, sizeof(CNode), TRUE ) );

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        SPDBG_ASSERT( SPIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        SPDBG_ASSERT( SPIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ) );
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    SPASSERT_VALID( this );
    SPDBG_ASSERT( nIndex >= 0 );

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        SPDBG_ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ));
        pNode = pNode->pNext;
    }
    return (SPLISTPOS) pNode;
}

template<class TYPE, class ARG_TYPE>
SPLISTPOS CSPList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, SPLISTPOS startAfter) const
{
    SPASSERT_VALID( this );

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        SPDBG_ASSERT( SPIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (SPCompareElements(&pNode->data, &searchValue))
            return (SPLISTPOS)pNode;
    return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CSPList<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_nCount == 0)
    {
        // empty list
        SPDBG_ASSERT( m_pNodeHead == NULL );
        SPDBG_ASSERT( m_pNodeTail == NULL );
    }
    else
    {
        // non-empty list
        SPDBG_ASSERT( SPIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ));
        SPDBG_ASSERT( SPIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ));
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CSPMap
{
protected:
    // Association
    struct CAssoc
    {
        CAssoc* pNext;
        UINT nHashValue;  // needed for efficient iteration
        KEY key;
        VALUE value;
    };
public:
// Construction
    CSPMap( int nBlockSize = 10 );

// Attributes
    // number of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // Lookup
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
    // Lookup and add if not there
    VALUE& operator[](ARG_KEY key);

    // add a new (key, value) pair
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

    // removing existing (key, ?) pair
    BOOL RemoveKey(ARG_KEY key);
    void RemoveAll();

    // iterating all (key, value) pairs
    SPLISTPOS GetStartPosition() const;
    void GetNextAssoc(SPLISTPOS& rNextPosition, KEY& rKey, VALUE& rValue) const;

    // advanced features for derived classes
    UINT    GetHashTableSize() const;
    HRESULT InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
    CAssoc** m_pHashTable;
    UINT m_nHashTableSize;
    int m_nCount;
    CAssoc* m_pFreeList;
    struct CSPPlex* m_pBlocks;
    int m_nBlockSize;

    CAssoc* NewAssoc();
    void FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
    ~CSPMap();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
    { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
    { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
    { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline SPLISTPOS CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
    { return (m_nCount == 0) ? NULL : SP_BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
    { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CSPMap( int nBlockSize )
{
    SPDBG_ASSERT( nBlockSize > 0 );

    m_pHashTable = NULL;
    m_nHashTableSize = 17;  // default size
    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
HRESULT CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
                UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
    SPASSERT_VALID( this );
    SPDBG_ASSERT( m_nCount == 0 );
    SPDBG_ASSERT( nHashSize > 0 );
    HRESULT hr = S_OK;

    if (m_pHashTable != NULL)
    {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow)
    {
        m_pHashTable = new CAssoc* [nHashSize];
        if( m_pHashTable )
        {
            memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    m_nHashTableSize = ( SUCCEEDED( hr ) )?(nHashSize):(0);
    return hr;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
    SPASSERT_VALID( this );

    if (m_pHashTable != NULL)
    {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
            CAssoc* pAssoc;
            for( pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
                 pAssoc = pAssoc->pNext)
            {
                SPDestructElements(&pAssoc->value, 1);
                SPDestructElements(&pAssoc->key, 1);
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CSPMap()
{
    RemoveAll();
    SPDBG_ASSERT( m_nCount == 0 );
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
    if (m_pFreeList == NULL)
    {
        // add another block
        CSPPlex* newBlock = CSPPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CSPMap::CAssoc));

        if( newBlock )
        {
            // chain them into free list
            CSPMap::CAssoc* pAssoc = (CSPMap::CAssoc*) newBlock->data();
            // free in reverse order to make it easier to debug
            pAssoc += m_nBlockSize - 1;
            for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
            {
                pAssoc->pNext = m_pFreeList;
                m_pFreeList = pAssoc;
            }
        }
    }

    CSPMap::CAssoc* pAssoc = m_pFreeList;
    if( pAssoc )
    {
        if( SUCCEEDED( SPConstructElements(&pAssoc->key, 1   ) ) )
        {
            if( SUCCEEDED( SPConstructElements(&pAssoc->value, 1 ) ) )
            {
                m_pFreeList = m_pFreeList->pNext;
                m_nCount++;
                SPDBG_ASSERT( m_nCount > 0 );  // make sure we don't overflow
            }
            else
            {
                SPDestructElements( &pAssoc->key, 1 );
            }
        }
        else
        {
            pAssoc = NULL;
        }
    }
    return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CSPMap::CAssoc* pAssoc)
{
    SPDestructElements(&pAssoc->value, 1);
    SPDestructElements(&pAssoc->key, 1);
    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    SPDBG_ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
    nHash = SPHashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (SPCompareElements(&pAssoc->key, &key))
            return pAssoc;
    }
    return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    SPASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;  // not in map

    rValue = pAssoc->value;
    return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
    SPASSERT_VALID( this );
    HRESULT hr = S_OK;
    static const CAssoc ErrAssoc = 0;

    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        if( m_pHashTable == NULL )
        {
            hr = InitHashTable(m_nHashTableSize);
        }

        if( SUCCEEDED( hr ) )
        {
            // it doesn't exist, add a new Association
            pAssoc = NewAssoc();
            if( pAssoc )
            {
                pAssoc->nHashValue = nHash;
                pAssoc->key = key;
                // 'pAssoc->value' is a constructed object, nothing more

                // put into hash table
                pAssoc->pNext = m_pHashTable[nHash];
                m_pHashTable[nHash] = pAssoc;
            }
            else
            {
                pAssoc = &ErrAssoc;
            }
        }
    }
    return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
    SPASSERT_VALID( this );

    if (m_pHashTable == NULL)
        return FALSE;  // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[SPHashKey(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (SPCompareElements(&pAssoc->key, &key))
        {
            // remove it
            *ppAssocPrev = pAssoc->pNext;  // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }
    return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(SPLISTPOS& rNextPosition,
    KEY& rKey, VALUE& rValue) const
{
    SPASSERT_VALID( this );
    SPDBG_ASSERT( m_pHashTable != NULL );  // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    SPDBG_ASSERT( pAssocRet != NULL );

    if (pAssocRet == (CAssoc*) SP_BEFORE_START_POSITION)
    {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
        SPDBG_ASSERT( pAssocRet != NULL );  // must find something
    }

    // find next association
    SPDBG_ASSERT( SPIsValidAddress(pAssocRet, sizeof(CAssoc), TRUE ));
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL)
    {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (SPLISTPOS) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CSPMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
    SPDBG_ASSERT( m_nHashTableSize > 0 );
    SPDBG_ASSERT( (m_nCount == 0 || m_pHashTable != NULL) );
        // non-empty map should have hash table
}
#endif //_DEBUG

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\include\spddkhlp.h ===
/*******************************************************************************
* SPDDKHLP.h *
*------------*
*   Description:
*       This is the header file for core helper functions implementation.
*
*   Copyright (c) Microsoft Corporation. All rights reserved.
*
*******************************************************************************/
#ifndef SPDDKHLP_h
#define SPDDKHLP_h

#ifndef SPHelper_h
#include <sphelper.h>
#endif

#include <sapiddk.h>

#ifndef SPError_h
#include <SPError.h>
#endif

#ifndef SPDebug_h
#include <SPDebug.h>
#endif

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

#ifndef _INC_MALLOC
#include <malloc.h>
#endif

#ifndef _INC_MMSYSTEM
#include <mmsystem.h>
#endif

#ifndef __comcat_h__
#include <comcat.h>
#endif

//=== Constants ==============================================================
#define sp_countof(x) ((sizeof(x) / sizeof(*(x))))

#define SP_IS_BAD_WRITE_PTR(p)     ( SPIsBadWritePtr( p, sizeof(*(p)) ))
#define SP_IS_BAD_READ_PTR(p)      ( SPIsBadReadPtr(  p, sizeof(*(p)) ))
#define SP_IS_BAD_CODE_PTR(p)      ( ::IsBadCodePtr((FARPROC)(p) )
#define SP_IS_BAD_INTERFACE_PTR(p) ( SPIsBadInterfacePtr( (p) )  )
#define SP_IS_BAD_VARIANT_PTR(p)   ( SPIsBadVARIANTPtr( (p) ) )
#define SP_IS_BAD_STRING_PTR(p)    ( SPIsBadStringPtr( (p) ) )

#define SP_IS_BAD_OPTIONAL_WRITE_PTR(p)     ((p) && SPIsBadWritePtr( p, sizeof(*(p)) ))
#define SP_IS_BAD_OPTIONAL_READ_PTR(p)      ((p) && SPIsBadReadPtr(  p, sizeof(*(p)) ))
#define SP_IS_BAD_OPTIONAL_INTERFACE_PTR(p) ((p) && SPIsBadInterfacePtr(p))
#define SP_IS_BAD_OPTIONAL_STRING_PTR(p)    ((p) && SPIsBadStringPtr(p))

//=== Class, Enum, Struct, Template, and Union Declarations ==================

//=== Inlines ================================================================

/*** Pointer validation functions
*/

// TODO:  Add decent debug output for bad parameters

inline BOOL SPIsBadStringPtr( const WCHAR * psz, ULONG cMaxChars = 0xFFFF )
{
    BOOL IsBad = false;
    __try
    {
        do
        {
            if( *psz++ == 0 ) return IsBad;
        }
        while( --cMaxChars );
    }
    __except( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION )
    {
        IsBad = true;
    }

    return IsBad;
}

inline BOOL SPIsBadReadPtr( const void* pMem, UINT Size )
{
#ifdef _DEBUG
    BOOL bIsBad = ::IsBadReadPtr( pMem, Size );
    SPDBG_ASSERT(!bIsBad);
    return bIsBad;
#else
    return ::IsBadReadPtr( pMem, Size );
#endif
}

inline BOOL SPIsBadWritePtr( void* pMem, UINT Size )
{
#ifdef _DEBUG
    BOOL bIsBad = ::IsBadWritePtr( pMem, Size );
    SPDBG_ASSERT(!bIsBad);
    return bIsBad;
#else
    return ::IsBadWritePtr( pMem, Size );
#endif
}

inline BOOL SPIsBadInterfacePtr( const IUnknown* pUnknown )
{
#ifdef _DEBUG
    BOOL bIsBad = ( ::IsBadReadPtr( pUnknown, sizeof( *pUnknown ) ) ||
                    ::IsBadCodePtr( (FARPROC)((void**)pUnknown)[0] ))?
                   (true):(false);
    SPDBG_ASSERT(!bIsBad);
    return bIsBad;
#else
    return ( ::IsBadReadPtr( pUnknown, sizeof( *pUnknown ) ) ||
             ::IsBadCodePtr( (FARPROC)((void**)pUnknown)[0] ))?
            (true):(false);
#endif
}

inline BOOL SPIsBadVARIANTPtr( const VARIANT* pVar )
{
#ifdef _DEBUG
    BOOL bIsBad = ::IsBadReadPtr( pVar, sizeof( *pVar ) );
    SPDBG_ASSERT(!bIsBad);
    return bIsBad;
#else
    return ::IsBadReadPtr( pVar, sizeof( *pVar ) );
#endif
}

#ifdef __ATLCOM_H__     //--- Only enable these if ATL is being used

//
//  Helper functions can be used to implement GetObjectToken/SetObjectToken for objects that 
//  support ISpObjectWithToken
//
inline HRESULT SpGenericSetObjectToken(ISpObjectToken * pCallersToken, CComPtr<ISpObjectToken> & cpObjToken)
{
    HRESULT hr = S_OK;
    if (SP_IS_BAD_INTERFACE_PTR(pCallersToken))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (cpObjToken)
        {
            hr = SPERR_ALREADY_INITIALIZED;
        }
        else
        {
            cpObjToken = pCallersToken;
        }
    }
    return hr;
}


inline HRESULT SpGenericGetObjectToken(ISpObjectToken ** ppCallersToken, CComPtr<ISpObjectToken> & cpObjToken)
{
    HRESULT hr = S_OK;
    if (SP_IS_BAD_WRITE_PTR(ppCallersToken))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppCallersToken = cpObjToken;
        if (*ppCallersToken)
        {
            (*ppCallersToken)->AddRef();
        }
        else
        {
            hr = S_FALSE;
        }
    }
    return hr;
}

#endif  // __ATLCOM_H__


//
//  Helper class for SPSTATEINFO sturcture automatically initializes and cleans up
//  the structure + provides a few helper functions.
//
class CSpStateInfo : public SPSTATEINFO
{
public:
    CSpStateInfo()
    {
        cAllocatedEntries = NULL;
        pTransitions = NULL;
    }
    ~CSpStateInfo()
    {
        ::CoTaskMemFree(pTransitions);
    }
    SPTRANSITIONENTRY * FirstEpsilon()
    {
        return pTransitions;
    }
    SPTRANSITIONENTRY * FirstRule()
    {
        return pTransitions + cEpsilons;
    }
    SPTRANSITIONENTRY * FirstWord()
    {
        return pTransitions + cEpsilons + cRules;
    }
    SPTRANSITIONENTRY * FirstSpecialTransition()
    {
        return pTransitions + cEpsilons + cRules + cWords;
    }
};


//
//  This basic queue implementation can be used to maintin linked lists of classes.  The class T
//  must contain the member m_pNext which is used by this template to point to the next element.
//  If the bPurgeWhenDeleted is TRUE then all of the elements in the queue will be deleted
//  when the queue is deleted, otherwise they will not.
//  If bMaintainCount is TRUE then a running count will be maintained, and GetCount() will be
//  efficent.  If it is FALSE then a running count will not be maintained, and GetCount() will
//  be an order N operation.  If you do not require a count, then 
//

template <class T, BOOL bPurgeWhenDeleted> class CSpBasicList;

template <class T, BOOL bPurgeWhenDeleted = TRUE, BOOL bMaintainCount = FALSE>
class CSpBasicQueue
{
public:
    T     * m_pHead;
    T     * m_pTail;
    ULONG   m_cElements;    // Warning!  Use GetCount() -- Not maintained if bMaintainCount is FALSE.

    CSpBasicQueue() 
    {
        m_pHead = NULL;
        if (bMaintainCount)
        {
            m_cElements = 0;
        }
    }

    ~CSpBasicQueue()
    {
        if (bPurgeWhenDeleted)
        {
            Purge();
        }
    }

    HRESULT CreateNode(T ** ppNode)
    {
        *ppNode = new T;
        if (*ppNode)
        {
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    T * GetNext(const T * pNode)
    {
        return pNode->m_pNext;
    }


    T * Item(ULONG i)
    {
        T * pNode = m_pHead;
        while (pNode && i)
        {
            i--;
            pNode = pNode->m_pNext;
        }
        return pNode;
    }

    void InsertAfter(T * pPrev, T * pNewNode)
    {
        if (pPrev)
        {
            pNewNode->m_pNext = pPrev->m_pNext;
            pPrev->m_pNext = pNewNode;
            if (pNewNode->m_pNext == NULL)
            {
                m_pTail = pNewNode;
            }
            if (bMaintainCount) ++m_cElements;
        }
        else
        {
            InsertHead(pNewNode);
        }
    }

    void InsertTail(T * pNode)
    {
        pNode->m_pNext = NULL;
        if (m_pHead)
        {
            m_pTail->m_pNext = pNode;
        }
        else
        {
            m_pHead = pNode;
        }
        m_pTail = pNode;
        if (bMaintainCount) ++m_cElements;
    }

    void InsertHead(T * pNode)
    {
        pNode->m_pNext = m_pHead;
        if (m_pHead == NULL)
        {
            m_pTail = pNode;
        }
        m_pHead = pNode;
        if (bMaintainCount) ++m_cElements;
    }

    T * RemoveHead()
    {
        T * pNode = m_pHead;
        if (pNode)
        {
            m_pHead = pNode->m_pNext;
            if (bMaintainCount) --m_cElements;
        }
        return pNode;
    }

    T * RemoveTail()
    {
        T * pNode = m_pHead;
        if (pNode)
        {
            if (pNode == m_pTail)
            {
                m_pHead = NULL;
            }
            else
            {
                T * pPrev;
                do
                {
                    pPrev = pNode;
                    pNode = pNode->m_pNext;
                } while ( pNode != m_pTail );
                pPrev->m_pNext = NULL;
                m_pTail = pPrev;
            }
            if (bMaintainCount) --m_cElements;
        }
        return pNode;
    }

    void Purge()
    {
        while (m_pHead)
        {
            T * pDie = m_pHead;
            m_pHead = pDie->m_pNext;
            delete pDie;
        }
        if (bMaintainCount) m_cElements = 0;
    }

    void ExplicitPurge()
    {
        T * pDie;
        BYTE * pb;

        while (m_pHead)
        {
            pDie = m_pHead;
            m_pHead = pDie->m_pNext;

            pDie->~T();

            pb = reinterpret_cast<BYTE *>(pDie);
            delete [] pb;
        }
        if (bMaintainCount) m_cElements = 0;
    }


    T * GetTail() const
    {
        if (m_pHead)
        {
            return m_pTail;
        }
        return NULL;
    }

    T * GetHead() const
    {
        return m_pHead;
    }

    BOOL IsEmpty() const
    {
        return m_pHead == NULL; 
    }

    BOOL Remove(T * pNode)
    {
        if (m_pHead == pNode)
        {
            m_pHead = pNode->m_pNext;
            if (bMaintainCount) --m_cElements;
            return TRUE;
        }
        else
        {
            T * pCur = m_pHead;
            while (pCur)
            {
                T * pNext = pCur->m_pNext;
                if (pNext == pNode)
                {
                    if ((pCur->m_pNext = pNode->m_pNext) == NULL)
                    {
                        m_pTail = pCur;
                    }
                    if (bMaintainCount) --m_cElements;
                    return TRUE;
                }
                pCur = pNext;
            }
        }
        return FALSE;
    }

    void MoveAllToHeadOf(CSpBasicQueue & DestQueue)
    {
        if (m_pHead)
        {
            m_pTail->m_pNext = DestQueue.m_pHead;
            if (DestQueue.m_pHead == NULL)
            {
                DestQueue.m_pTail = m_pTail;
            }
            DestQueue.m_pHead = m_pHead;
            m_pHead = NULL;
            if (bMaintainCount)
            {
                DestQueue.m_cElements += m_cElements;
                m_cElements = 0;
            }
        }
    }

    void MoveAllToList(CSpBasicList<T, bPurgeWhenDeleted> & List)
    {
        if (m_pHead)
        {
            m_pTail->m_pNext = List.m_pFirst;
            List.m_pFirst = m_pHead;
            m_pHead = NULL;
        }
        if (bMaintainCount)
        {
            m_cElements = 0;
        }
    }

    BOOL MoveToList(T * pNode, CSpBasicList<T, bPurgeWhenDeleted> & List)
    {
        BOOL bFound = Remove(pNode);
        if (bFound)
        {
            List.AddNode(pNode);
        }
        return bFound;
    }

    ULONG GetCount() const
    {
        if (bMaintainCount)
        {
            return m_cElements;
        }
        else
        {
            ULONG c = 0;
            for (T * pNode = m_pHead;
                 pNode;
                 pNode = pNode->m_pNext, c++) {}
            return c;
        }
    }

    //
    //  The following functions require the class T to implement a static function:
    //
    //      LONG Compare(const T * pElem1, const T * pElem2)
    //
    //  which returns < 0 if pElem1 is less than pElem2, 0 if they are equal, and > 0 if
    //  pElem1 is greater than pElem2.
    //
    void InsertSorted(T * pNode)
    {
        if (m_pHead)
        {
            if (T::Compare(pNode, m_pTail) >= 0)
            {
                pNode->m_pNext = NULL;
                m_pTail->m_pNext = pNode;
                m_pTail = pNode;
            }
            else
            {
                //
                //  We don't have to worry about walking off of the end of the list here since
                //  we have already checked the tail.
                //
                T ** ppNext = &m_pHead;
                while (T::Compare(pNode, *ppNext) >= 0)
                {
                    ppNext = &((*ppNext)->m_pNext);
                }
                pNode->m_pNext = *ppNext;
                *ppNext = pNode;
            }
        }
        else
        {
            pNode->m_pNext = NULL;
            m_pHead = m_pTail = pNode;
        }
        if (bMaintainCount) ++m_cElements;
    }

    HRESULT InsertSortedUnique(T * pNode)
    {
        HRESULT hr = S_OK;
        if (m_pHead)
        {
            if (T::Compare(pNode, m_pTail) > 0)
            {
                pNode->m_pNext = NULL;
                m_pTail->m_pNext = pNode;
                m_pTail = pNode;
            }
            else
            {
                //
                //  We don't have to worry about walking off of the end of the list here since
                //  we have already checked the tail.
                //
                T ** ppNext = &m_pHead;
                while (T::Compare(pNode, *ppNext) > 0)
                {
                    ppNext = &((*ppNext)->m_pNext);
                }
                if (T::Compare(pNode, *ppNext) != 0)
                {
                    pNode->m_pNext = *ppNext;
                    *ppNext = pNode;
                }
                else
                {
                    delete pNode;
                    hr = S_FALSE;
                }
            }
        }
        else
        {
            pNode->m_pNext = NULL;
            m_pHead = m_pTail = pNode;
        }
        if (bMaintainCount) ++m_cElements;
        return hr;
    }

    //
    //  These functions must support the "==" operator for the TFIND type.
    //
    template <class TFIND> 
    T * Find(TFIND & FindVal) const 
    {
        for (T * pNode = m_pHead; pNode && (!(*pNode == FindVal)); pNode = pNode->m_pNext)
        {}
        return pNode;
    }

    template <class TFIND> 
    T * FindNext(const T * pCurNode, TFIND & FindVal) const 
    {
        for (T * pNode = pCurNode->m_pNext; pNode && (!(*pNode == FindVal)); pNode = pNode->m_pNext)
        {}
        return pNode;
    }

    //
    //  Searches for and removes a single list element
    //  
    template <class TFIND> 
    T * FindAndRemove(TFIND & FindVal)
    {
        T * pNode = m_pHead;
        if (pNode)
        {
            if (*pNode == FindVal)
            {
                m_pHead = pNode->m_pNext;
                if (bMaintainCount) --m_cElements;
            }
            else
            {
                T * pPrev = pNode;
                for (pNode = pNode->m_pNext;
                     pNode;
                     pPrev = pNode, pNode = pNode->m_pNext)
                {
                    if (*pNode == FindVal)
                    {
                        pPrev->m_pNext = pNode->m_pNext;
                        if (pNode->m_pNext == NULL)
                        {
                            m_pTail = pPrev;
                        }
                        if (bMaintainCount) --m_cElements;
                        break;
                    }
                }
            }
        }
        return pNode;
    }

    //
    //  Searches for and deletes all list elements that match
    //  
    template <class TFIND> 
    void FindAndDeleteAll(TFIND & FindVal)
    {
        T * pNode = m_pHead;
        while (pNode && *pNode == FindVal)
        {
            m_pHead = pNode->m_pNext;
            delete pNode;
            if (bMaintainCount) --m_cElements;
            pNode = m_pHead;
        }
        T * pPrev = pNode;
        while (pNode)
        {
            T * pNext = pNode->m_pNext;
            if (*pNode == FindVal)
            {
                pPrev->m_pNext = pNext;
                delete pNode;
                if (bMaintainCount) --m_cElements;
            }
            else
            {
                pPrev = pNode;
            }
            pNode = pNext;
        }
        m_pTail = pPrev;    // Just always set it in case we removed the tail.
    }


};

template <class T, BOOL bPurgeWhenDeleted = TRUE>
class CSpBasicList
{
public:
    T * m_pFirst;
    CSpBasicList() : m_pFirst(NULL) {}
    ~CSpBasicList()
    {
        if (bPurgeWhenDeleted)
        {
            Purge();
        }
    }

    void Purge()
    {
        while (m_pFirst)
        {
            T * pNext = m_pFirst->m_pNext;
            delete m_pFirst;
            m_pFirst = pNext;
        }
    }

    void ExplicitPurge()
    {
        T * pDie;
        BYTE * pb;

        while (m_pFirst)
        {
            pDie = m_pFirst;
            m_pFirst = pDie->m_pNext;

            pDie->~T();

            pb = reinterpret_cast<BYTE *>(pDie);
            delete [] pb;
        }
    }

    HRESULT RemoveFirstOrAllocateNew(T ** ppNode)
    {
        if (m_pFirst)
        {
            *ppNode = m_pFirst;
            m_pFirst = m_pFirst->m_pNext;
        }
        else
        {
            *ppNode = new T;
            if (*ppNode == NULL)
            {
                return E_OUTOFMEMORY;
            }
        }
        return S_OK;
    }

    void AddNode(T * pNode)
    {
        pNode->m_pNext = m_pFirst;
        m_pFirst = pNode;
    }
    T * GetFirst()
    {
        return m_pFirst;
    }
    T * RemoveFirst()
    {
        T * pNode = m_pFirst;
        if (pNode)
        {
            m_pFirst = pNode->m_pNext;
        }
        return pNode;
    }
};

#define STACK_ALLOC(TYPE, COUNT) (TYPE *)_alloca(sizeof(TYPE) * (COUNT))
#define STACK_ALLOC_AND_ZERO(TYPE, COUNT) (TYPE *)memset(_alloca(sizeof(TYPE) * (COUNT)), 0, (sizeof(TYPE) * (COUNT)))
#define STACK_ALLOC_AND_COPY(TYPE, COUNT, SOURCE) (TYPE *)memcpy(_alloca(sizeof(TYPE) * (COUNT)), (SOURCE), (sizeof(TYPE) * (COUNT)))

inline HRESULT SpGetSubTokenFromToken(
    ISpObjectToken * pToken,
    const WCHAR * pszSubKeyName,
    ISpObjectToken ** ppToken,
    BOOL fCreateIfNotExist = FALSE)
{
    SPDBG_FUNC("SpGetTokenFromDataKey");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_INTERFACE_PTR(pToken) ||
        SP_IS_BAD_STRING_PTR(pszSubKeyName) ||
        SP_IS_BAD_WRITE_PTR(ppToken))
    {
        hr = E_POINTER;
    }

    // First, either create or open the datakey for the new token
    CComPtr<ISpDataKey> cpDataKeyForNewToken;
    if (SUCCEEDED(hr))
    {
        if (fCreateIfNotExist)
        {
            hr = pToken->CreateKey(pszSubKeyName, &cpDataKeyForNewToken);
        }
        else
        {
            hr = pToken->OpenKey(pszSubKeyName, &cpDataKeyForNewToken);
        }
    }

    // The sub token's category will be the token id of it's parent token
    CSpDynamicString dstrCategoryId;
    if (SUCCEEDED(hr))
    {
        hr = pToken->GetId(&dstrCategoryId);
    }

    // The sub token's token id will be it's category id + "\\" the key name
    CSpDynamicString dstrTokenId;
    if (SUCCEEDED(hr))
    {
        dstrTokenId = dstrCategoryId;
        dstrTokenId.Append2(L"\\", pszSubKeyName);
    }

    // Now create the token and initalize it
    CComPtr<ISpObjectTokenInit> cpTokenInit;
    if (SUCCEEDED(hr))
    {
        hr = cpTokenInit.CoCreateInstance(CLSID_SpObjectToken);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpTokenInit->InitFromDataKey(dstrCategoryId, dstrTokenId, cpDataKeyForNewToken);
    }

    if (SUCCEEDED(hr))
    {
        *ppToken = cpTokenInit.Detach();
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

template<class T>
HRESULT SpCreateObjectFromSubToken(ISpObjectToken * pToken, const WCHAR * pszSubKeyName, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
    SPDBG_FUNC("SpCreateObjectFromSubToken");
    HRESULT hr;

    CComPtr<ISpObjectToken> cpSubToken;
    hr = SpGetSubTokenFromToken(pToken, pszSubKeyName, &cpSubToken);
    
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(cpSubToken, ppObject, pUnkOuter, dwClsCtxt);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\include\spdebug.h ===
/*******************************************************************************
* SPDebug.h *
*-----------*
*   Description:
*       This header file contains debug output services for SAPI5
*-------------------------------------------------------------------------------
*   Copyright (c) Microsoft Corporation. All rights reserved.
*******************************************************************************/

#pragma once

#include <TCHAR.h>
#include <crtdbg.h>

#ifdef ASSERT_WITH_STACK
#include "AssertWithStack.h"
#endif

const TCHAR g_szSpDebugKey[] = _T("SPDebug");
const TCHAR g_szSpDebugFuncTraceReportMode[] = _T("FuncTraceMode");
const TCHAR g_szSpDebugFuncTraceReportFile[] = _T("FuncTraceFile");
const TCHAR g_szSpDebugParamInfoReportMode[] = _T("ParamInfoMode");
const TCHAR g_szSpDebugParamInfoReportFile[] = _T("ParamInfoFile");
const TCHAR g_szSpDebugDumpInfoReportMode[] = _T("DumpInfoMode");
const TCHAR g_szSpDebugDumpInfoReportFile[] = _T("DumpInfoFile");
const TCHAR g_szSpDebugAssertReportMode[] = _T("AssertMode");
const TCHAR g_szSpDebugAssertReportFile[] = _T("AssertFile");
const TCHAR g_szSpDebugHRFailReportMode[] = _T("HRFailMode");
const TCHAR g_szSpDebugHRFailReportFile[] = _T("HRFailFile");

const TCHAR g_szSpDebugAssertSettingsReReadEachTime[] = _T("AssertSettingsReReadEachTime");
const TCHAR g_szSpDebugServerOnStart[] = _T("DebugServerOnStart");
const TCHAR g_szSpDebugClientOnStart[] = _T("DebugClientOnStart");

const TCHAR g_szSpDebugLog[] = _T("c:\\spdebug.log");

#ifdef _DEBUG

class CSpDebug
{
public:
    
    CSpDebug()
    {
        m_mutex = NULL;
        m_reportModePrev = -1;
        m_hfilePrev = NULL;
        Read();
    }

    ~CSpDebug()
    {
        if (m_mutex != NULL)
        {
            CloseHandle(m_mutex);
        }
    }
 
    BOOL FuncTrace(BOOL fEnter = TRUE)
    {
        return fEnter
            ? Enter(_CRT_WARN, m_FuncTraceMode, m_szFuncTraceFile)
            : Leave();
    }
    
    BOOL ParamInfo(BOOL fEnter = TRUE)
    {
        return fEnter
            ? Enter(_CRT_WARN, m_ParamInfoMode, m_szParamInfoFile)
            : Leave();
    }
    
    BOOL DumpInfo(BOOL fEnter = TRUE)
    {
        return fEnter
            ? Enter(_CRT_WARN, m_DumpInfoMode, m_szDumpInfoFile)
            : Leave();
    }
    
    BOOL Assert(BOOL fEnter = TRUE)
    {
        if (m_fAssertSettingsReReadEachTime)
            Read();

        return fEnter
            ? Enter(_CRT_ASSERT, m_AssertMode, m_szAssertFile)
            : Leave();
    }
    
    BOOL HRFail(BOOL fEnter = TRUE)
    {
        return fEnter
            ? Enter(_CRT_WARN, m_HRFailMode, m_szHRFailFile)
            : Leave();
    }
    
    BOOL DebugServerOnStart()
    {
        return m_fDebugServerOnStart;
    }
    
    BOOL DebugClientOnStart()
    {
        return m_fDebugClientOnStart;
    }
    
private:

    void Read()
    {
        HKEY hkeyDebug;
        RegCreateKeyEx(
            HKEY_CLASSES_ROOT, 
            g_szSpDebugKey, 
            0, 
            NULL, 
            0,
            KEY_READ | KEY_WRITE, 
            NULL, 
            &hkeyDebug, 
            NULL);
        if (hkeyDebug == NULL)
        {
            RegCreateKeyEx(
                HKEY_CLASSES_ROOT, 
                g_szSpDebugKey, 
                0, 
                NULL, 
                0,
                KEY_READ,
                NULL, 
                &hkeyDebug, 
                NULL);
        }
        
        DWORD dw = sizeof(m_fAssertSettingsReReadEachTime);
        if (RegQueryValueEx(
                hkeyDebug,
                g_szSpDebugAssertSettingsReReadEachTime,
                NULL,
                NULL,
                LPBYTE(&m_fAssertSettingsReReadEachTime),
                &dw) != ERROR_SUCCESS)
        {
            m_fAssertSettingsReReadEachTime = FALSE;
            RegSetValueEx(
                hkeyDebug,
                g_szSpDebugAssertSettingsReReadEachTime,
                NULL,
                REG_DWORD,
                LPBYTE(&m_fAssertSettingsReReadEachTime),
                sizeof(m_fAssertSettingsReReadEachTime));
        }
            
        ReadFor(
            hkeyDebug, 
            g_szSpDebugFuncTraceReportMode,
            g_szSpDebugFuncTraceReportFile, 
            &m_FuncTraceMode, 
            m_szFuncTraceFile, 
            0, 
            g_szSpDebugLog);
        ReadFor(
            hkeyDebug, 
            g_szSpDebugParamInfoReportMode, 
            g_szSpDebugParamInfoReportFile, 
            &m_ParamInfoMode, 
            m_szParamInfoFile, 
            0, 
            g_szSpDebugLog);
        ReadFor(
            hkeyDebug, 
            g_szSpDebugDumpInfoReportMode, 
            g_szSpDebugDumpInfoReportFile, 
            &m_DumpInfoMode, 
            m_szDumpInfoFile, 
            _CRTDBG_MODE_DEBUG, 
            g_szSpDebugLog);
        ReadFor(
            hkeyDebug, 
            g_szSpDebugAssertReportMode, 
            g_szSpDebugAssertReportFile, 
            &m_AssertMode, 
            m_szAssertFile, 
            _CRTDBG_MODE_WNDW,
            g_szSpDebugLog);
        ReadFor(
            hkeyDebug, 
            g_szSpDebugHRFailReportMode,
            g_szSpDebugHRFailReportFile, 
            &m_HRFailMode, 
            m_szHRFailFile, 
            _CRTDBG_MODE_DEBUG,
            g_szSpDebugLog);
        
        dw = sizeof(m_fDebugServerOnStart);
        if (RegQueryValueEx(
                hkeyDebug,
                g_szSpDebugServerOnStart,
                NULL,
                NULL,
                LPBYTE(&m_fDebugServerOnStart),
                &dw) != ERROR_SUCCESS)
        {
            m_fDebugServerOnStart = FALSE;
            RegSetValueEx(
                hkeyDebug,
                g_szSpDebugServerOnStart,
                NULL,
                REG_DWORD,
                LPBYTE(&m_fDebugServerOnStart),
                sizeof(m_fDebugServerOnStart));
        }
            
        dw = sizeof(m_fDebugClientOnStart);
        if (RegQueryValueEx(
                hkeyDebug,
                g_szSpDebugClientOnStart,
                NULL,
                NULL,
                LPBYTE(&m_fDebugClientOnStart),
                &dw) != ERROR_SUCCESS)
        {
            m_fDebugClientOnStart = FALSE;
            RegSetValueEx(
                hkeyDebug,
                g_szSpDebugClientOnStart,
                NULL,
                REG_DWORD,
                LPBYTE(&m_fDebugClientOnStart),
                sizeof(m_fDebugClientOnStart));
        }
        
        RegCloseKey(hkeyDebug);
    }

    void ReadFor(
            HKEY hkey, 
            const TCHAR * pszModeValueName, 
            const TCHAR * pszFileValueName, 
            DWORD * pdwModeValue,
            TCHAR * pszFileValue,
            DWORD dwDefaultModeValue,
            const TCHAR * pszDefaultFileValue)
    {
        DWORD dw = sizeof(*pdwModeValue);
        if (RegQueryValueEx(
                hkey,
                pszModeValueName,
                NULL,
                NULL,
                LPBYTE(pdwModeValue),
                &dw) != ERROR_SUCCESS)
        {
            *pdwModeValue = dwDefaultModeValue;
            RegSetValueEx(
                hkey,
                pszModeValueName,
                NULL,
                REG_DWORD,
                LPBYTE(pdwModeValue),
                sizeof(*pdwModeValue));
        }
        
        dw = MAX_PATH;
        if (RegQueryValueEx(
                hkey,
                pszFileValueName,
                NULL,
                NULL,
                LPBYTE(pszFileValue),
                &dw) != ERROR_SUCCESS)
        {
            _tcscpy(pszFileValue, pszDefaultFileValue);
            RegSetValueEx(
                hkey,
                pszFileValueName,
                NULL,
                REG_SZ,
                LPBYTE(pszFileValue),
                MAX_PATH);
        }
    }

    BOOL Enter(int reportType, DWORD &reportMode, TCHAR * pszFile)
    {
        if (reportMode != 0)
        {
            // We'll hold the mutex, until the caller also calls Leave
            if (m_mutex == NULL)
            {
                m_mutex = CreateMutex(NULL, FALSE, _T("SpDebug"));
            }
            WaitForSingleObject(m_mutex, INFINITE);
            
            m_reportType = reportType;
            m_reportModePrev = _CrtSetReportMode(reportType, reportMode);
            if (reportMode & _CRTDBG_MODE_FILE)
            {
                HANDLE hfile = CreateFile(
                    pszFile, 
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_ALWAYS,
                    0,
                    NULL);
                SetFilePointer(hfile, 0, NULL, FILE_END);
                m_hfilePrev = (_HFILE)_CrtSetReportFile(reportType, (_HFILE)hfile);
            }
            
            return TRUE;
        }

        return FALSE;
    }

    BOOL Leave()
    {
        int reportMode = _CrtSetReportMode(m_reportType, m_reportModePrev);
        if (reportMode & _CRTDBG_MODE_FILE)
        {
            CloseHandle((_HFILE)_CrtSetReportFile(m_reportType, (_HFILE)m_hfilePrev));
        }
        
        ReleaseMutex(m_mutex);

        return TRUE;
    }
    
private:

    HANDLE m_mutex;
    
    int    m_reportType;
    int    m_reportModePrev;
    _HFILE m_hfilePrev;
    
    BOOL  m_fAssertSettingsReReadEachTime;
    
    DWORD m_FuncTraceMode;
    TCHAR  m_szFuncTraceFile[MAX_PATH + 1];
    DWORD m_ParamInfoMode;
    TCHAR  m_szParamInfoFile[MAX_PATH + 1];
    DWORD m_DumpInfoMode;
    TCHAR  m_szDumpInfoFile[MAX_PATH + 1];
    DWORD m_AssertMode;
    TCHAR  m_szAssertFile[MAX_PATH + 1];
    DWORD m_HRFailMode;
    TCHAR  m_szHRFailFile[MAX_PATH + 1];
    
    BOOL m_fDebugServerOnStart;
    BOOL m_fDebugClientOnStart;
};

inline CSpDebug *PSpDebug()
{
    static CSpDebug debug;
    return &debug;
}

class CSpFuncTrace
{
public:
  
    CSpFuncTrace(PCHAR pFuncName)
    {
        m_pFuncName = pFuncName;
        if (PSpDebug()->FuncTrace())
        {
            _RPT1( _CRT_WARN, "\nEntering Function: %s\n", m_pFuncName );
            PSpDebug()->FuncTrace(FALSE);
        }
    }
    
    ~CSpFuncTrace()
    {
        if (PSpDebug()->FuncTrace())
        {
            _RPT1( _CRT_WARN, "Leaving Function: %s\n", m_pFuncName );
            PSpDebug()->FuncTrace(FALSE);
        }
    }
    
private:

    PCHAR m_pFuncName;
};

#endif // _DEBUG

//=== User macros ==============================================================

#ifdef _DEBUG

#define SPDBG_FUNC(name)            \
    CSpFuncTrace functrace(name)

#if defined(ASSERT_WITH_STACK) && !defined(_WIN64)
#define SPDBG_REPORT_ON_FAIL(hr)                                                      \
    do                                                                                \
    {                                                                                 \
        HRESULT _hr = (hr);                                                           \
        if (FAILED(_hr) && PSpDebug()->HRFail())                                      \
        {                                                                             \
            SYSTEMTIME sysTime;                                                       \
            GetLocalTime(&sysTime);                                                   \
            CHAR pszHrWithTime[100];                                                  \
            sprintf(pszHrWithTime, "%lX\n\n%d.%d.%d %02d:%02d:%02d",            \
                _hr,                                                                  \
                sysTime.wMonth,sysTime.wDay,sysTime.wYear,                            \
                sysTime.wHour,sysTime.wMinute,sysTime.wSecond);                       \
            PCHAR pszStack =                                                          \
                (PCHAR)_alloca(                                                       \
                    cchMaxAssertStackLevelStringLen *                                 \
                         cfrMaxAssertStackLevels + 1);                                \
            GetStringFromStackLevels(0, 10, pszStack);                                \
            _RPT4(_CRT_WARN,                                                          \
                "%s(%d): Failed HR = %s\n\n%s\n",                                     \
                __FILE__,                                                             \
                __LINE__,                                                             \
                pszHrWithTime,                                                        \
                pszStack);                                                            \
            PSpDebug()->HRFail(FALSE);                                                \
        }                                                                             \
    } while (0)
#else // ASSERT_WITH_STACK & !_WIN64
#define SPDBG_REPORT_ON_FAIL(hr)                                                      \
    do                                                                                \
    {                                                                                 \
        HRESULT _hr = (hr);                                                           \
        if (FAILED(_hr) && PSpDebug()->HRFail())                                      \
        {                                                                             \
            _RPT3(_CRT_WARN, "%s(%d): Failed HR = %lX\n", __FILE__, __LINE__, (_hr) );\
            PSpDebug()->HRFail(FALSE);                                                \
        }                                                                             \
    } while (0)
#endif // ASSERT_WITH_STACK

#define SPDBG_ASSERT(expr)                  \
    do                                      \
    {                                       \
        if (!(expr))                        \
        {                                   \
            if (PSpDebug()->Assert())       \
            {                               \
                _ASSERTE( expr );           \
                PSpDebug()->Assert(FALSE);  \
            }                               \
        }                                   \
    }                                       \
    while (0)

#define SPDBG_VERIFY(expr)  \
    SPDBG_ASSERT(expr)

#define SPDBG_PMSG0(format)                                    \
    do                                                         \
    {                                                          \
        if (PSpDebug()->ParamInfo())                           \
        {                                                      \
            _RPT0(_CRT_WARN, format);                          \
            PSpDebug()->ParamInfo(FALSE);                      \
        }                                                      \
    } while (0)
#define SPDBG_PMSG1(format, arg1)                              \
    do                                                         \
    {                                                          \
        if (PSpDebug()->ParamInfo())                           \
        {                                                      \
            _RPT1(_CRT_WARN, format, arg1);                    \
            PSpDebug()->ParamInfo(FALSE);                      \
        }                                                      \
    } while (0)
#define SPDBG_PMSG2(format, arg1, arg2)                        \
    do                                                         \
    {                                                          \
        if (PSpDebug()->ParamInfo())                           \
        {                                                      \
            _RPT2(_CRT_WARN, format, arg1, arg2);              \
            PSpDebug()->ParamInfo(FALSE);                      \
        }                                                      \
    } while (0)
#define SPDBG_PMSG3(format, arg1, arg2, arg3)                  \
    do                                                         \
    {                                                          \
        if (PSpDebug()->ParamInfo())                           \
        {                                                      \
            _RPT3(_CRT_WARN, format, arg1, arg2, arg3);        \
            PSpDebug()->ParamInfo(FALSE);                      \
        }                                                      \
    } while (0)
#define SPDBG_PMSG4(format, arg1, arg2, arg3, arg4)            \
    do                                                         \
    {                                                          \
        if (PSpDebug()->ParamInfo())                           \
        {                                                      \
            _RPT4(_CRT_WARN, format, arg1, arg2, arg3, arg4);  \
            PSpDebug()->ParamInfo(FALSE);                      \
        }                                                      \
    } while (0)
    
#define SPDBG_DMSG0(format)                                    \
    do                                                         \
    {                                                          \
        if (PSpDebug()->DumpInfo())                            \
        {                                                      \
            _RPT0(_CRT_WARN, format);                          \
            PSpDebug()->DumpInfo(FALSE);                       \
        }                                                      \
    } while (0)
#define SPDBG_DMSG1(format, arg1)                              \
    do                                                         \
    {                                                          \
        if (PSpDebug()->DumpInfo())                            \
        {                                                      \
            _RPT1(_CRT_WARN, format, arg1);                    \
            PSpDebug()->DumpInfo(FALSE);                       \
        }                                                      \
    } while (0)
#define SPDBG_DMSG2(format, arg1, arg2)                        \
    do                                                         \
    {                                                          \
        if (PSpDebug()->DumpInfo())                            \
        {                                                      \
            _RPT2(_CRT_WARN, format, arg1, arg2);              \
            PSpDebug()->DumpInfo(FALSE);                       \
        }                                                      \
    } while (0)
#define SPDBG_DMSG3(format, arg1, arg2, arg3)                  \
    do                                                         \
    {                                                          \
        if (PSpDebug()->DumpInfo())                            \
        {                                                      \
            _RPT3(_CRT_WARN, format, arg1, arg2, arg3);        \
            PSpDebug()->DumpInfo(FALSE);                       \
        }                                                      \
    } while (0)
#define SPDBG_DMSG4(format, arg1, arg2, arg3, arg4)            \
    do                                                         \
    {                                                          \
        if (PSpDebug()->DumpInfo())                            \
        {                                                      \
            _RPT4(_CRT_WARN, format, arg1, arg2, arg3, arg4);  \
            PSpDebug()->DumpInfo(FALSE);                       \
        }                                                      \
    } while (0)

#define SPDBG_RETURN(hr)                \
    {                                   \
        HRESULT __hr = (hr);            \
        if (FAILED(__hr))               \
        {                               \
            SPDBG_REPORT_ON_FAIL(__hr); \
        }                               \
        return __hr;                    \
    }                                                    

#define SPDBG_DEBUG_SERVER_ON_START()           \
    {                                           \
        if (PSpDebug()->DebugServerOnStart())   \
        {                                       \
            if (MessageBox(                     \
                    GetDesktopWindow(),         \
                    _T("Attach Debugger to the SAPI Server process?"),   \
                    _T("SAPI"),                 \
                    MB_YESNO) == IDYES)         \
            {                                   \
                USES_CONVERSION;                \
                TCHAR szCommand[MAX_PATH + 1];  \
                wsprintf(                       \
                    szCommand,                  \
                    _T("msdev -p %d"),          \
                    GetCurrentProcessId());     \
                system(T2A(szCommand));         \
            }                                   \
        }                                       \
    }

#define SPDBG_DEBUG_CLIENT_ON_START()           \
    {                                           \
        if (PSpDebug()->DebugClientOnStart())   \
        {                                       \
            TCHAR szModule[MAX_PATH + 1];       \
            szModule[0] = '\0';                 \
            TCHAR * pszSapiServer =             \
                _T("sapisvr.exe");              \
            GetModuleFileName(                  \
                NULL,                           \
                szModule,                       \
                MAX_PATH);                      \
            if ((_tcslen(szModule) <=           \
                    _tcslen(pszSapiServer) ||   \
                 _tcsicmp(                      \
                    szModule +                  \
                        _tcslen(szModule) -     \
                        _tcslen(pszSapiServer), \
                    pszSapiServer) != 0) &&     \
                MessageBox(                     \
                    GetDesktopWindow(),         \
                    _T("Attach Debugger to the SAPI Client process?"),   \
                    _T("SAPI"),                 \
                    MB_YESNO) == IDYES)         \
            {                                   \
                USES_CONVERSION;                \
                TCHAR szCommand[MAX_PATH + 1];  \
                wsprintf(                       \
                    szCommand,                  \
                    _T("msdev -p %d"),          \
                    GetCurrentProcessId());     \
                system(T2A(szCommand));         \
            }                                   \
        }                                       \
    }
        
#else // _DEBUG

#define SPDBG_FUNC(name)
#define SPDBG_REPORT_ON_FAIL(hr)
#define SPDBG_ASSERT(expr)
#define SPDBG_VERIFY(expr) (expr)
#define SPDBG_PMSG0(format)
#define SPDBG_PMSG1(format, arg1)
#define SPDBG_PMSG2(format, arg1, arg2)
#define SPDBG_PMSG3(format, arg1, arg2, arg3)
#define SPDBG_PMSG4(format, arg1, arg2, arg3, arg4)
#define SPDBG_DMSG0(format)
#define SPDBG_DMSG1(format, arg1)
#define SPDBG_DMSG2(format, arg1, arg2)
#define SPDBG_DMSG3(format, arg1, arg2, arg3)
#define SPDBG_DMSG4(format, arg1, arg2, arg3, arg4)
#define SPDBG_RETURN(hr) return (hr)
#define SPDBG_DEBUG_SERVER_ON_START()
#define SPDBG_DEBUG_CLIENT_ON_START()

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\include\sperror.h ===
/*******************************************************************************
* SPError.h *
*-----------*
*   Description:
*       This header file contains the custom error codes specific to SAPI5
*-------------------------------------------------------------------------------
*   Copyright (c) Microsoft Corporation. All rights reserved.
*******************************************************************************/
#ifndef SPError_h
#define SPError_h

#ifndef _WINERROR_
#include <winerror.h>
#endif

#define FACILITY_SAPI      FACILITY_ITF
#define SAPI_ERROR_BASE    0x5000

#define MAKE_SAPI_HRESULT(sev, err)    MAKE_HRESULT(sev, FACILITY_SAPI, err)
#define MAKE_SAPI_ERROR(err)           MAKE_SAPI_HRESULT(SEVERITY_ERROR, err + SAPI_ERROR_BASE)
#define MAKE_SAPI_SCODE(scode)         MAKE_SAPI_HRESULT(SEVERITY_SUCCESS, scode + SAPI_ERROR_BASE)

/*** SPERR_UNINITIALIZED                                   0x80045001    -2147201023
*   The object has not been properly initialized.
*/
#define SPERR_UNINITIALIZED                                MAKE_SAPI_ERROR(0x001)

/*** SPERR_ALREADY_INITIALIZED                             0x80045002    -2147201022
*   The object has already been initialized.
*/
#define SPERR_ALREADY_INITIALIZED                          MAKE_SAPI_ERROR(0x002)

/*** SPERR_UNSUPPORTED_FORMAT                              0x80045003    -2147201021
*   The caller has specified an unsupported format.
*/
#define SPERR_UNSUPPORTED_FORMAT                           MAKE_SAPI_ERROR(0x003)

/*** SPERR_INVALID_FLAGS                                   0x80045004    -2147201020
*   The caller has specified invalid flags for this operation.
*/
#define SPERR_INVALID_FLAGS                                MAKE_SAPI_ERROR(0x004)

/*** SP_END_OF_STREAM                                      0x00045005    282629
*   The operation has reached the end of stream.
*/
#define SP_END_OF_STREAM                                   MAKE_SAPI_SCODE(0x005)

/*** SPERR_DEVICE_BUSY                                     0x80045006    -2147201018
*   The wave device is busy.
*/
#define SPERR_DEVICE_BUSY                                  MAKE_SAPI_ERROR(0x006)

/*** SPERR_DEVICE_NOT_SUPPORTED                            0x80045007    -2147201017
*   The wave device is not supported.
*/
#define SPERR_DEVICE_NOT_SUPPORTED                         MAKE_SAPI_ERROR(0x007)

/*** SPERR_DEVICE_NOT_ENABLED                              0x80045008    -2147201016
*   The wave device is not enabled.
*/
#define SPERR_DEVICE_NOT_ENABLED                           MAKE_SAPI_ERROR(0x008)

/*** SPERR_NO_DRIVER                                       0x80045009    -2147201015
*   There is no wave driver installed.
*/
#define SPERR_NO_DRIVER                                    MAKE_SAPI_ERROR(0x009)

/*** SPERR_FILEMUSTBEUNICODE                               0x8004500a    -2147201014
*   The file must be Unicode.
*/
#define SPERR_FILE_MUST_BE_UNICODE                         MAKE_SAPI_ERROR(0x00a)

/*** SP_INSUFFICIENTDATA                                   0x0004500b    282635
*
*/
#define SP_INSUFFICIENT_DATA                               MAKE_SAPI_SCODE(0x00b)

/*** SPERR_INVALID_PHRASE_ID                               0x8004500c    -2147201012
*   The phrase ID specified does not exist or is out of range.
*/
#define SPERR_INVALID_PHRASE_ID                            MAKE_SAPI_ERROR(0x00c)

/*** SPERR_BUFFER_TOO_SMALL                                0x8004500d    -2147201011
*   The caller provided a buffer too small to return a result.
*/
#define SPERR_BUFFER_TOO_SMALL                             MAKE_SAPI_ERROR(0x00d)

/*** SPERR_FORMAT_NOT_SPECIFIED                            0x8004500e    -2147201010
*   Caller did not specify a format prior to opening a stream.
*/
#define SPERR_FORMAT_NOT_SPECIFIED                         MAKE_SAPI_ERROR(0x00e)

/*** SPERR_AUDIO_STOPPED                                   0x8004500f    -2147201009
*   This method is deprecated. Use SP_AUDIO_STOPPED instead.
*/
#define SPERR_AUDIO_STOPPED                                MAKE_SAPI_ERROR(0x00f)

/*** SP_AUDIO_PAUSED                                       0x00045010    282640
*   This will be returned only on input (read) streams when the stream is paused.  Reads on
*   paused streams will not block, and this return code indicates that all of the data has been
*   removed from the stream.
*/
#define SP_AUDIO_PAUSED                                    MAKE_SAPI_SCODE(0x010)

/*** SPERR_RULE_NOT_FOUND                                  0x80045011    -2147201007
*   Invalid rule name passed to ActivateGrammar.
*/
#define SPERR_RULE_NOT_FOUND                               MAKE_SAPI_ERROR(0x011)

/*** SPERR_TTS_ENGINE_EXCEPTION                            0x80045012    -2147201006
*   An exception was raised during a call to the current TTS driver.
*/
#define SPERR_TTS_ENGINE_EXCEPTION                         MAKE_SAPI_ERROR(0x012)

/*** SPERR_TTS_NLP_EXCEPTION                               0x80045013    -2147201005
*   An exception was raised during a call to an application sentence filter.
*/
#define SPERR_TTS_NLP_EXCEPTION                            MAKE_SAPI_ERROR(0x013)

/*** SPERR_ENGINE_BUSY                                     0x80045014    -2147201004
*   In speech recognition, the current method can not be performed while
*   a grammar rule is active.
*/
#define SPERR_ENGINE_BUSY                                  MAKE_SAPI_ERROR(0x014)

/*** SP_AUDIO_CONVERSION_ENABLED                           0x00045015    282645
*   The operation was successful, but only with automatic stream format conversion.
*/
#define SP_AUDIO_CONVERSION_ENABLED                        MAKE_SAPI_SCODE(0x015)

/*** SP_NO_HYPOTHESIS_AVAILABLE                            0x00045016    282646
*   There is currently no hypothesis recognition available.
*/
#define SP_NO_HYPOTHESIS_AVAILABLE                         MAKE_SAPI_SCODE(0x016)

/*** SPERR_CANT_CREATE                                     0x80045017    -2147201001
*   Can not create a new object instance for the specified object category.
*/
#define SPERR_CANT_CREATE                                  MAKE_SAPI_ERROR(0x017)

/*** SP_ALREADY_IN_LEX                                     0x00045018    282648
*   The word, pronunciation, or POS pair being added is already in lexicon.
*/
#define SP_ALREADY_IN_LEX                                  MAKE_SAPI_SCODE(0x018)

/*** SPERR_NOT_IN_LEX                                      0x80045019    -2147200999
*   The word does not exist in the lexicon.
*/
#define SPERR_NOT_IN_LEX                                   MAKE_SAPI_ERROR(0x019)

/*** SP_LEX_NOTHING_TO_SYNC                                0x0004501a    282650
*   The client is currently synced with the lexicon.
*/
#define SP_LEX_NOTHING_TO_SYNC                             MAKE_SAPI_SCODE(0x01a)

/*** SPERR_LEX_VERY_OUT_OF_SYNC                            0x8004501b    -2147200997
*   The client is excessively out of sync with the lexicon. Mismatches may not be incrementally sync'd.
*/
#define SPERR_LEX_VERY_OUT_OF_SYNC                         MAKE_SAPI_ERROR(0x01b)

/*** SPERR_UNDEFINED_FORWARD_RULE_REF                      0x8004501c    -2147200996
*   A rule reference in a grammar was made to a named rule that was never defined.
*/
#define SPERR_UNDEFINED_FORWARD_RULE_REF                   MAKE_SAPI_ERROR(0x01c)

/*** SPERR_EMPTY_RULE                                      0x8004501d    -2147200995
*   A non-dynamic grammar rule that has no body.
*/
#define SPERR_EMPTY_RULE                                   MAKE_SAPI_ERROR(0x01d)

/*** SPERR_GRAMMAR_COMPILER_INTERNAL_ERROR                 0x8004501e    -2147200994
*   The grammar compiler failed due to an internal state error.
*/
#define SPERR_GRAMMAR_COMPILER_INTERNAL_ERROR              MAKE_SAPI_ERROR(0x01e)


/*** SPERR_RULE_NOT_DYNAMIC                                0x8004501f    -2147200993
*   An attempt was made to modify a non-dynamic rule.
*/
#define SPERR_RULE_NOT_DYNAMIC                             MAKE_SAPI_ERROR(0x01f)

/*** SPERR_DUPLICATE_RULE_NAME                             0x80045020    -2147200992
*   A rule name was duplicated.
*/
#define SPERR_DUPLICATE_RULE_NAME                          MAKE_SAPI_ERROR(0x020)

/*** SPERR_DUPLICATE_RESOURCE_NAME                         0x80045021    -2147200991
*   A resource name was duplicated for a given rule.
*/
#define SPERR_DUPLICATE_RESOURCE_NAME                      MAKE_SAPI_ERROR(0x021)


/*** SPERR_TOO_MANY_GRAMMARS                               0x80045022    -2147200990
*   Too many grammars have been loaded.
*/
#define SPERR_TOO_MANY_GRAMMARS                            MAKE_SAPI_ERROR(0x022)

/*** SPERR_CIRCULAR_REFERENCE                              0x80045023    -2147200989
*   Circular reference in import rules of grammars.
*/
#define SPERR_CIRCULAR_REFERENCE                           MAKE_SAPI_ERROR(0x023)

/*** SPERR_INVALID_IMPORT                                  0x80045024    -2147200988
*   A rule reference to an imported grammar that could not be resolved.
*/
#define SPERR_INVALID_IMPORT                               MAKE_SAPI_ERROR(0x024)

/*** SPERR_INVALID_WAV_FILE                                0x80045025    -2147200987
*   The format of the WAV file is not supported.
*/
#define SPERR_INVALID_WAV_FILE                             MAKE_SAPI_ERROR(0x025)

/*** SP_REQUEST_PENDING                                    0x00045026    282662
*   This success code indicates that an SR method called with the SPRIF_ASYNC flag is
*   being processed.  When it has finished processing, an SPFEI_ASYNC_COMPLETED event will be generated.
*/
#define SP_REQUEST_PENDING                                 MAKE_SAPI_SCODE(0x026)

/*** SPERR_ALL_WORDS_OPTIONAL                              0x80045027    -2147200985
*   A grammar rule was defined with a null path through the rule.  That is, it is possible
*   to satisfy the rule conditions with no words.
*/
#define SPERR_ALL_WORDS_OPTIONAL                           MAKE_SAPI_ERROR(0x027)

/*** SPERR_INSTANCE_CHANGE_INVALID                         0x80045028    -2147200984
*   It is not possible to change the current engine or input.  This occurs in the
*   following cases:
*
*       1) SelectEngine called while a recognition context exists, or
*       2) SetInput called in the shared instance case.
*/
#define SPERR_INSTANCE_CHANGE_INVALID                      MAKE_SAPI_ERROR(0x028)

/*** SPERR_RULE_NAME_ID_CONFLICT                          0x80045029    -2147200983
*   A rule exists with matching IDs (names) but different names (IDs).  
*/
#define SPERR_RULE_NAME_ID_CONFLICT                        MAKE_SAPI_ERROR(0x029)

/*** SPERR_NO_RULES                                       0x8004502a    -2147200982
*   A grammar contains no top-level, dynamic, or exported rules.  There is no possible
*   way to activate or otherwise use any rule in this grammar.
*/
#define SPERR_NO_RULES                                     MAKE_SAPI_ERROR(0x02a)

/*** SPERR_CIRCULAR_RULE_REF                              0x8004502b    -2147200981
*   Rule 'A' refers to a second rule 'B' which, in turn, refers to rule 'A'. 
*/
#define SPERR_CIRCULAR_RULE_REF                            MAKE_SAPI_ERROR(0x02b)

/*** SP_NO_PARSE_FOUND                                    0x0004502c    282668
*   Parse path cannot be parsed given the currently active rules.
*/
#define SP_NO_PARSE_FOUND                                  MAKE_SAPI_SCODE(0x02c)

/*** SPERR_NO_PARSE_FOUND                                 0x8004502d    -2147200979
*   Parse path cannot be parsed given the currently active rules.
*/
#define SPERR_INVALID_HANDLE                               MAKE_SAPI_ERROR(0x02d)

/*** SPERR_REMOTE_CALL_TIMED_OUT                          0x8004502e    -2147200978
*   A marshaled remote call failed to respond.
*/
#define SPERR_REMOTE_CALL_TIMED_OUT                        MAKE_SAPI_ERROR(0x02e)

/*** SPERR_AUDIO_BUFFER_OVERFLOW                           0x8004502f    -2147200977
*   This will only be returned on input (read) streams when the stream is paused because
*   the SR driver has not retrieved data recently.
*/
#define SPERR_AUDIO_BUFFER_OVERFLOW                        MAKE_SAPI_ERROR(0x02f)


/*** SPERR_NO_AUDIO_DATA                                   0x80045030    -2147200976
*   The result does not contain any audio, nor does the portion of the element chain of the result
*   contain any audio.
*/
#define SPERR_NO_AUDIO_DATA                                MAKE_SAPI_ERROR(0x030)

/*** SPERR_DEAD_ALTERNATE                                  0x80045031    -2147200975
*   This alternate is no longer a valid alternate to the result it was obtained from.
*   Returned from ISpPhraseAlt methods.
*/
#define SPERR_DEAD_ALTERNATE                               MAKE_SAPI_ERROR(0x031)

/*** SPERR_HIGH_LOW_CONFIDENCE                             0x80045032    -2147200974
*   The result does not contain any audio, nor does the portion of the element chain of the result
*   contain any audio.  Returned from ISpResult::GetAudio and ISpResult::SpeakAudio.
*/
#define SPERR_HIGH_LOW_CONFIDENCE                          MAKE_SAPI_ERROR(0x032)

/*** SPERR_INVALID_FORMAT_STRING                           0x80045033    -2147200973
*   The XML format string for this RULEREF is invalid, e.g. not a GUID or REFCLSID.
*/
#define SPERR_INVALID_FORMAT_STRING                        MAKE_SAPI_ERROR(0x033)

/*** SP_UNSUPPORTED_ON_STREAM_INPUT                        0x00045034    282676
*   The operation is not supported for stream input.
*/
#define SP_UNSUPPORTED_ON_STREAM_INPUT                     MAKE_SAPI_SCODE(0x034)

/*** SPERR_APPLEX_READ_ONLY                                0x80045035    -2147200971
*   The operation is invalid for all but newly created application lexicons.
*/
#define SPERR_APPLEX_READ_ONLY                             MAKE_SAPI_ERROR(0x035)

/*** SPERR_NO_TERMINATING_RULE_PATH                        0x80045036    -2147200970
*
*/

#define SPERR_NO_TERMINATING_RULE_PATH                     MAKE_SAPI_ERROR(0x036)

/*** SP_WORD_EXISTS_WITHOUT_PRONUNCIATION                  0x00045037    282679
*   The word exists but without pronunciation.
*/
#define SP_WORD_EXISTS_WITHOUT_PRONUNCIATION               MAKE_SAPI_SCODE(0x037)

/*** SPERR_STREAM_CLOSED                                   0x80045038    -2147200968
*   An operation was attempted on a stream object that has been closed.
*/
#define SPERR_STREAM_CLOSED                                MAKE_SAPI_ERROR(0x038)

// --- The following error codes are taken directly from WIN32  ---

/*** SPERR_NO_MORE_ITEMS                                   0x80045039    -2147200967
*   When enumerating items, the requested index is greater than the count of items.
*/
#define SPERR_NO_MORE_ITEMS                                MAKE_SAPI_ERROR(0x039)

/*** SPERR_NOT_FOUND                                       0x8004503a    -2147200966
*   The requested data item (data key, value, etc.) was not found.
*/
#define SPERR_NOT_FOUND                                    MAKE_SAPI_ERROR(0x03a)

/*** SPERR_INVALID_AUDIO_STATE                             0x8004503b    -2147200965
*   Audio state passed to SetState() is invalid.
*/
#define SPERR_INVALID_AUDIO_STATE                          MAKE_SAPI_ERROR(0x03b)

/*** SPERR_GENERIC_MMSYS_ERROR                             0x8004503c    -2147200964
*   A generic MMSYS error not caught by _MMRESULT_TO_HRESULT.
*/
#define SPERR_GENERIC_MMSYS_ERROR                          MAKE_SAPI_ERROR(0x03c)

/*** SPERR_MARSHALER_EXCEPTION                             0x8004503d    -2147200963
*   An exception was raised during a call to the marshaling code.
*/
#define SPERR_MARSHALER_EXCEPTION                          MAKE_SAPI_ERROR(0x03d)

/*** SPERR_NOT_DYNAMIC_GRAMMAR                             0x8004503e    -2147200962
*   Attempt was made to manipulate a non-dynamic grammar.
*/
#define SPERR_NOT_DYNAMIC_GRAMMAR                          MAKE_SAPI_ERROR(0x03e)

/*** SPERR_AMBIGUOUS_PROPERTY                              0x8004503f    -2147200961
*   Cannot add ambiguous property.
*/
#define SPERR_AMBIGUOUS_PROPERTY                           MAKE_SAPI_ERROR(0x03f)

/*** SPERR_INVALID_REGISTRY_KEY                            0x80045040    -2147200960
*   The key specified is invalid.
*/
#define SPERR_INVALID_REGISTRY_KEY                         MAKE_SAPI_ERROR(0x040)

/*** SPERR_INVALID_TOKEN_ID                                0x80045041    -2147200959
*   The token specified is invalid.
*/
#define SPERR_INVALID_TOKEN_ID                             MAKE_SAPI_ERROR(0x041)

/*** SPERR_XML_BAD_SYNTAX                                  0x80045042    -2147200958
*   The xml parser failed due to bad syntax.
*/
#define SPERR_XML_BAD_SYNTAX                               MAKE_SAPI_ERROR(0x042)

/*** SPERR_XML_RESOURCE_NOT_FOUND                          0x80045043    -2147200957
*   The xml parser failed to load a required resource (e.g., voice, phoneconverter, etc.).
*/
#define SPERR_XML_RESOURCE_NOT_FOUND                       MAKE_SAPI_ERROR(0x043)

/*** SPERR_TOKEN_IN_USE                                    0x80045044    -2147200956
*   Attempted to remove registry data from a token that is already in use elsewhere.
*/
#define SPERR_TOKEN_IN_USE                                 MAKE_SAPI_ERROR(0x044)

/*** SPERR_TOKEN_DELETED                                   0x80045045    -2147200955
*   Attempted to perform an action on an object token that has had associated registry key deleted.
*/
#define SPERR_TOKEN_DELETED                                MAKE_SAPI_ERROR(0x045)

/*** SPERR_MULTI_LINGUAL_NOT_SUPPORTED                     0x80045046    -2147200954
*   The selected voice was registered as multi-lingual. SAPI does not support multi-lingual registration. 
*/
#define SPERR_MULTI_LINGUAL_NOT_SUPPORTED                  MAKE_SAPI_ERROR(0x046)

/*** SPERR_EXPORT_DYNAMIC_RULE                             0x80045047    -2147200953
*   Exported rules cannot refer directly or indirectly to a dynamic rule.
*/
#define SPERR_EXPORT_DYNAMIC_RULE                          MAKE_SAPI_ERROR(0x047)

/*** SPERR_STGF_ERROR                                      0x80045048    -2147200952
*   Error parsing the SAPI Text Grammar Format (XML grammar).
*/
#define SPERR_STGF_ERROR                                   MAKE_SAPI_ERROR(0x048)

/*** SPERR_WORDFORMAT_ERROR                                0x80045049    -2147200951
*   Incorrect word format, probably due to incorrect pronunciation string.
*/
#define SPERR_WORDFORMAT_ERROR                             MAKE_SAPI_ERROR(0x049)

/*** SPERR_STREAM_NOT_ACTIVE                               0x8004504a    -2147200950
*   Methods associated with active audio stream cannot be called unless stream is active.
*/
#define SPERR_STREAM_NOT_ACTIVE                            MAKE_SAPI_ERROR(0x04a)

/*** SPERR_ENGINE_RESPONSE_INVALID                         0x8004504b    -2147200949
*   Arguments or data supplied by the engine are in an invalid format or are inconsistent.
*/
#define SPERR_ENGINE_RESPONSE_INVALID                      MAKE_SAPI_ERROR(0x04b)

/*** SPERR_SR_ENGINE_EXCEPTION                             0x8004504c    -2147200948
*   An exception was raised during a call to the current SR engine.
*/
#define SPERR_SR_ENGINE_EXCEPTION                          MAKE_SAPI_ERROR(0x04c)

/*** SPERR_STREAM_POS_INVALID                              0x8004504d    -2147200947
*   Stream position information supplied from engine is inconsistent.
*/
#define SPERR_STREAM_POS_INVALID                           MAKE_SAPI_ERROR(0x04d)

/*** SP_RECOGNIZER_INACTIVE                                0x0004504e    282702
*   Operation could not be completed because the recognizer is inactive. It is inactive either
*   because the recognition state is currently inactive or because no rules are active .
*/
#define SP_RECOGNIZER_INACTIVE                             MAKE_SAPI_SCODE(0x04e)

/*** SPERR_REMOTE_CALL_ON_WRONG_THREAD                     0x8004504f    -2147200945
*   When making a remote call to the server, the call was made on the wrong thread.
*/
#define SPERR_REMOTE_CALL_ON_WRONG_THREAD                  MAKE_SAPI_ERROR(0x04f)

/*** SPERR_REMOTE_PROCESS_TERMINATED                       0x80045050    -2147200944
*   The remote process terminated unexpectedly.
*/
#define SPERR_REMOTE_PROCESS_TERMINATED                    MAKE_SAPI_ERROR(0x050)

/*** SPERR_REMOTE_PROCESS_ALREADY_RUNNING                  0x80045051    -2147200943
*   The remote process is already running; it cannot be started a second time.
*/
#define SPERR_REMOTE_PROCESS_ALREADY_RUNNING               MAKE_SAPI_ERROR(0x051)

/*** SPERR_LANGID_MISMATCH                                 0x80045052    -2147200942
*   An attempt to load a CFG grammar with a LANGID different than other loaded grammars.
*/
#define SPERR_LANGID_MISMATCH                              MAKE_SAPI_ERROR(0x052)

/*** SP_PARTIAL_PARSE_FOUND                               0x00045053    282707
*   A grammar-ending parse has been found that does not use all available words.
*/
#define SP_PARTIAL_PARSE_FOUND                             MAKE_SAPI_SCODE(0x053)

/*** SPERR_NOT_TOPLEVEL_RULE                              0x80045054    -2147200940
*   An attempt to deactivate or activate a non-toplevel rule.
*/
#define SPERR_NOT_TOPLEVEL_RULE                            MAKE_SAPI_ERROR(0x054)

/*** SP_NO_RULE_ACTIVE                                    0x00045055    282709
*   An attempt to parse when no rule was active.
*/
#define SP_NO_RULE_ACTIVE                                  MAKE_SAPI_SCODE(0x055)

/*** SPERR_LEX_REQUIRES_COOKIE                            0x80045056    -2147200938
*   An attempt to ask a container lexicon for all words at once.
*/
#define SPERR_LEX_REQUIRES_COOKIE                          MAKE_SAPI_ERROR(0x056)

/*** SP_STREAM_UNINITIALIZED                              0x00045057    282711
*   An attempt to activate a rule/dictation/etc without calling SetInput 
*   first in the inproc case.
*/
#define SP_STREAM_UNINITIALIZED                            MAKE_SAPI_SCODE(0x057)


// Error x058 is not used in SAPI 5.0


/*** SPERR_UNSUPPORTED_LANG                               0x80045059    -2147200935
*   The requested language is not supported.
*/
#define SPERR_UNSUPPORTED_LANG                             MAKE_SAPI_ERROR(0x059)

/*** SPERR_VOICE_PAUSED                                   0x8004505a    -2147200934
*   The operation cannot be performed because the voice is currently paused.
*/
#define SPERR_VOICE_PAUSED                                 MAKE_SAPI_ERROR(0x05a)

/*** SPERR_AUDIO_BUFFER_UNDERFLOW                          0x8004505b    -2147200933
*   This will only be returned on input (read) streams when the real time audio device
*   stops returning data for a long period of time.
*/
#define SPERR_AUDIO_BUFFER_UNDERFLOW                       MAKE_SAPI_ERROR(0x05b)

/*** SPERR_AUDIO_STOPPED_UNEXPECTEDLY                     0x8004505c    -2147200932
*   An audio device stopped returning data from the Read() method even though it was in
*   the run state.  This error is only returned in the END_SR_STREAM event.
*/
#define SPERR_AUDIO_STOPPED_UNEXPECTEDLY                   MAKE_SAPI_ERROR(0x05c)

/*** SPERR_NO_WORD_PRONUNCIATION                           0x8004505d    -2147200931
*   The SR engine is unable to add this word to a grammar. The application may need to supply 
*   an explicit pronunciation for this word.
*/
#define SPERR_NO_WORD_PRONUNCIATION                        MAKE_SAPI_ERROR(0x05d)

/*** SPERR_ALTERNATES_WOULD_BE_INCONSISTENT                0x8004505e    -2147200930
*   An attempt to call ScaleAudio on a recognition result having previously
*   called GetAlternates. Allowing the call to succeed would result in
*   the previously created alternates located in incorrect audio stream positions.
*/
#define SPERR_ALTERNATES_WOULD_BE_INCONSISTENT             MAKE_SAPI_ERROR(0x05e)

/*** SPERR_NOT_SUPPORTED_FOR_SHARED_RECOGNIZER             0x8004505f    -2147200929
*   The method called is not supported for the shared recognizer.
*   For example, ISpRecognizer::GetInputStream().
*/
#define SPERR_NOT_SUPPORTED_FOR_SHARED_RECOGNIZER          MAKE_SAPI_ERROR(0x05f)

/*** SPERR_TIMEOUT                                         0x80045060    -2147200928
*   A task could not complete because the SR engine had timed out.
*/
#define SPERR_TIMEOUT                                      MAKE_SAPI_ERROR(0x060)


/*** SPERR_REENTER_SYNCHRONIZE                             0x80045061    -2147200927
*   A SR engine called synchronize while inside of a synchronize call.
*/
#define SPERR_REENTER_SYNCHRONIZE                          MAKE_SAPI_ERROR(0x061)

/*** SPERR_STATE_WITH_NO_ARCS                              0x80045062    -2147200926
*   The grammar contains a node no arcs.
*/
#define SPERR_STATE_WITH_NO_ARCS                           MAKE_SAPI_ERROR(0x062)

/*** SPERR_NOT_ACTIVE_SESSION                              0x80045063    -2147200925
*   Neither audio output and input is supported for non-active console sessions.
*/
#define SPERR_NOT_ACTIVE_SESSION                           MAKE_SAPI_ERROR(0x063)

/*** SPERR_ALREADY_DELETED                                 0x80045064    -2147200924
*   The object is a stale reference and is invalid to use.
*   For example having a ISpeechGrammarRule object reference and then calling 
*   ISpeechRecoGrammar::Reset() will cause the rule object to be invalidated.
*   Calling any methods after this will result in this error.
*/
#define SPERR_ALREADY_DELETED                              MAKE_SAPI_ERROR(0x064)

/*** SP_AUDIO_STOPPED                                      0x00045065    282725
*   This can be returned from Read or Write calls audio streams when the stream is stopped.
*/
#define SP_AUDIO_STOPPED                                   MAKE_SAPI_SCODE(0x065)

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\include\speventq.h ===
/*******************************************************************************
* SPEventQ.h *
*------------*
*   Description:
*       This is the header file for the SAPI5 event queue implementation.
*-------------------------------------------------------------------------------
*   Copyright (c) Microsoft Corporation. All rights reserved.
*******************************************************************************/
#ifndef SPEventQ_h
#define SPEventQ_h

#ifndef SPHelper_h
#include <SPHelper.h>
#endif

#ifndef SPCollec_h
#include <SPCollec.h>
#endif

//=== Inline helpers for copying and deleting events ============================


//=== Class definition ==========================================================

class CSpEventNode : public CSpEvent
{
public:
    CSpEventNode    * m_pNext;
    static LONG Compare(const CSpEventNode * p1, const CSpEventNode *p2)
    {
        // Assumes offsets DO or DO NOT reset when stream number changes
        if (p1->ulStreamNum < p2->ulStreamNum)
        {
            return -1;
        }
        else if (p1->ulStreamNum > p2->ulStreamNum)
        {
            return 1;
        }
        else if (p1->ullAudioStreamOffset < p2->ullAudioStreamOffset)
        {
            return -1;
        }
        else if (p1->ullAudioStreamOffset > p2->ullAudioStreamOffset)
        {
            return 1;
        }
        return 0;
    }
};


typedef CSpBasicQueue<CSpEventNode, TRUE, TRUE> CSpEventList;

#define DECLARE_SPNOTIFYSOURCE_METHODS(T) \
STDMETHODIMP SetNotifySink(ISpNotifySink * pNotifySink) \
{ return T._SetNotifySink(pNotifySink); } \
STDMETHODIMP SetNotifyWindowMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam) \
{ return T._SetNotifyWindowMessage(hWnd, Msg, wParam, lParam); } \
STDMETHODIMP SetNotifyCallbackFunction(SPNOTIFYCALLBACK * pfnCallback, WPARAM wParam, LPARAM lParam) \
{ return T._SetNotifyCallbackFunction(pfnCallback, wParam, lParam); } \
STDMETHODIMP SetNotifyCallbackInterface(ISpNotifyCallback * pSpCallback, WPARAM wParam, LPARAM lParam) \
{ return T._SetNotifyCallbackInterface(pSpCallback, wParam, lParam); } \
STDMETHODIMP SetNotifyWin32Event() \
{ return T._SetNotifyWin32Event(); } \
STDMETHODIMP WaitForNotifyEvent(DWORD dwMilliseconds) \
{ return T._WaitForNotifyEvent(dwMilliseconds); } \
STDMETHODIMP_(HANDLE) GetNotifyEventHandle() \
{ return T._GetNotifyEventHandle(); } 

#define DECLARE_SPEVENTSOURCE_METHODS(T) \
DECLARE_SPNOTIFYSOURCE_METHODS(T) \
STDMETHODIMP SetInterest(ULONGLONG ullEventInterest, ULONGLONG ullQueuedInterest) \
{ return T._SetInterest(ullEventInterest, ullQueuedInterest); } \
STDMETHODIMP GetEvents(ULONG ulCount, SPEVENT* pEventArray, ULONG * pulFetched) \
{ return T._GetEvents(ulCount, pEventArray, pulFetched); } \
STDMETHODIMP GetInfo(SPEVENTSOURCEINFO *pInfo) \
{ return T._GetInfo(pInfo); }



class CSpEventSource 
{
  public:
    CSpEventSource(CComObjectRootEx<CComMultiThreadModel> * pParent) :
        m_pParent(pParent)
    {
        m_ullEventInterest = 0; m_ullQueuedInterest = 0;
        m_ulStreamNum = 0;
    }
    HRESULT _SetNotifySink(ISpNotifySink * pNotifySink);
    HRESULT _SetNotifyWindowMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    HRESULT _SetNotifyCallbackFunction(SPNOTIFYCALLBACK * pfnCallback, WPARAM wParam, LPARAM lParam);
    HRESULT _SetNotifyCallbackInterface(ISpNotifyCallback * pSpCallback, WPARAM wParam, LPARAM lParam);
    HRESULT _SetNotifyWin32Event();
    HRESULT _WaitForNotifyEvent(DWORD dwMilliseconds);
    HANDLE  _GetNotifyEventHandle();

    HRESULT _SetInterest(ULONGLONG ullEventInterest , ULONGLONG ullQueuedInterest);
    HRESULT _GetEvents( ULONG ulCount, SPEVENT* pEventArray, ULONG * pulFetched );
    HRESULT _GetInfo(SPEVENTSOURCEINFO *pInfo );

    /*--- Non interface methods ---*/
    HRESULT _CompleteEvents( ULONGLONG ullPos = 0xFFFFFFFFFFFFFFFF );
    inline void _MoveAllToFreeList(CSpEventList * pList);
    inline void _RemoveAllEvents();
    inline HRESULT _AddEvent(const SPEVENT & Event);
    inline HRESULT _AddEvents(const SPEVENT* pEventArray, ULONG ulCount);
    inline HRESULT _DeserializeAndAddEvent(const BYTE * pBuffer, ULONG * pcbUsed);
    inline HRESULT _GetStreamNumber(const ULONGLONG ullAudioOffset, ULONG *pulStreamNum);
    //=== Data members ==============================
  public:
    ULONGLONG                   m_ullEventInterest;
    ULONGLONG                   m_ullQueuedInterest;
    ULONG                       m_ulStreamNum;
    CSpEventList                m_PendingList;
    CSpEventList                m_CompletedList;
    CSpEventList                m_FreeList;
    CComPtr<ISpNotifySink>      m_cpNotifySink;
    CComPtr<ISpNotifyTranslator> m_cpEventTranslator;   // If non-NULL then Win32 events being used
    CComObjectRootEx<CComMultiThreadModel> * m_pParent;
    CComAutoCriticalSection     m_NotifyObjChangeCrit;  // Critical section used to make sure that
                                                        // the notify object (m_cpNotifySink) not changed
                                                        // while waiting on it.
                                                       
};


//
//=== Inlines =========================================================
//

//
//  WARNING:  If this logic changes, you will need to change the logic in SetNotifyWin32Event also.
//
inline HRESULT CSpEventSource::_SetNotifySink(ISpNotifySink * pNotifySink)
{
    if (SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pNotifySink))
    {
        return E_INVALIDARG;
    }
    else
    {
        m_pParent->Lock();
        m_NotifyObjChangeCrit.Lock();
        m_cpEventTranslator.Release();
        m_cpNotifySink = pNotifySink;
        if (m_cpNotifySink && m_CompletedList.GetHead())
        {
            m_cpNotifySink->Notify();
        }
        m_NotifyObjChangeCrit.Unlock();
        m_pParent->Unlock();
        return S_OK;
    }
}

/****************************************************************************
* CSpEventSource::_SetNotifyWindowMessage *
*-----------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT CSpEventSource::_SetNotifyWindowMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    SPDBG_FUNC("CSpEventSource::_SetNotifyWindowMessage");
    HRESULT hr = S_OK;
    CComPtr<ISpNotifyTranslator> cpTranslator;
    hr = cpTranslator.CoCreateInstance(CLSID_SpNotifyTranslator);
    if (SUCCEEDED(hr))
    {
        hr = cpTranslator->InitWindowMessage(hWnd, Msg, wParam, lParam);
    }
    if (SUCCEEDED(hr))
    {
        hr = _SetNotifySink(cpTranslator);
    }
    return hr;
}
/****************************************************************************
* CSpEventSource::_SetNotifyCallbackFunction *
*--------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT CSpEventSource::_SetNotifyCallbackFunction(SPNOTIFYCALLBACK * pfnCallback, WPARAM wParam, LPARAM lParam)
{
    SPDBG_FUNC("CSpEventSource::_SetNotifyCallbackFunction");
    HRESULT hr = S_OK;
    CComPtr<ISpNotifyTranslator> cpTranslator;
    hr = cpTranslator.CoCreateInstance(CLSID_SpNotifyTranslator);
    if (SUCCEEDED(hr))
    {
        hr = cpTranslator->InitCallback(pfnCallback, wParam, lParam);
    }
    if (SUCCEEDED(hr))
    {
        hr = _SetNotifySink(cpTranslator);
    }
    return hr;
}
/****************************************************************************
* CSpEventSource::_SetNotifyCallbackInterface *
*---------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT CSpEventSource::_SetNotifyCallbackInterface(ISpNotifyCallback * pSpCallback, WPARAM wParam, LPARAM lParam)
{
    SPDBG_FUNC("CSpEventSource::_SetNotifyCallbackInterface");
    HRESULT hr = S_OK;
    CComPtr<ISpNotifyTranslator> cpTranslator;
    hr = cpTranslator.CoCreateInstance(CLSID_SpNotifyTranslator);
    if (SUCCEEDED(hr))
    {
        hr = cpTranslator->InitSpNotifyCallback(pSpCallback, wParam, lParam);
    }
    if (SUCCEEDED(hr))
    {
        hr = _SetNotifySink(cpTranslator);
    }
    return hr;
}
/****************************************************************************
* CSpEventSource::_SetNotifyWin32Event *
*--------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT CSpEventSource::_SetNotifyWin32Event(void)
{
    SPDBG_FUNC("CSpEventSource::_SetNotifyWin32Event");
    HRESULT hr = S_OK;
    CComPtr<ISpNotifyTranslator> cpTranslator;
    hr = cpTranslator.CoCreateInstance(CLSID_SpNotifyTranslator);
    if (SUCCEEDED(hr))
    {
        hr = cpTranslator->InitWin32Event(NULL, TRUE);
    }
    if (SUCCEEDED(hr))
    {
        //
        //  In this case we do NOT call _SetNotify sink since we want to set the cpEventTranslator
        //
        m_pParent->Lock();
        m_NotifyObjChangeCrit.Lock();
        m_cpEventTranslator = cpTranslator;
        m_cpNotifySink = cpTranslator;
        if (m_cpNotifySink && m_CompletedList.GetHead())
        {
            m_cpNotifySink->Notify();
        }
        m_NotifyObjChangeCrit.Unlock();
        m_pParent->Unlock();
    }
    return hr;
}
/****************************************************************************
* CSpEventSource::_WaitForNotifyEvent *
*-------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT CSpEventSource::_WaitForNotifyEvent(DWORD dwMilliseconds)
{
    SPDBG_FUNC("CSpEventSource::_WaitForNotifyEvent");
    HRESULT hr = S_OK;
    m_NotifyObjChangeCrit.Lock();
    if (m_cpEventTranslator)
    {
        hr = m_cpEventTranslator->Wait(dwMilliseconds);
    }
    else
    {
        if (m_cpNotifySink)
        {
            hr = SPERR_ALREADY_INITIALIZED;
        }
        else
        {
            hr = _SetNotifyWin32Event();
            if (SUCCEEDED(hr))
            {
                hr = m_cpEventTranslator->Wait(dwMilliseconds);
            }
        }
    }
    m_NotifyObjChangeCrit.Unlock();
    return hr;
}
/****************************************************************************
* CSpEventSource::_GetNotifyEventHandle *
*---------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HANDLE CSpEventSource::_GetNotifyEventHandle()
{
    HANDLE h = NULL;
    SPDBG_FUNC("CSpEventSource::_GetNotifyEventHandle");
    m_NotifyObjChangeCrit.Lock();
    if (!m_cpNotifySink)
    {
        _SetNotifyWin32Event();
    }
    if (m_cpEventTranslator)
    {
        h = m_cpEventTranslator->GetEventHandle();
    }
    m_NotifyObjChangeCrit.Unlock();
    return h;
}


inline HRESULT CSpEventSource::_SetInterest( ULONGLONG ullEventInterest, ULONGLONG ullQueuedInterest )
{
    HRESULT hr = S_OK;
    m_pParent->Lock();

    if(ullEventInterest && SPFEI_FLAGCHECK != (ullEventInterest & SPFEI_FLAGCHECK))
    {
        hr = E_INVALIDARG;
    }
    else if(ullQueuedInterest && SPFEI_FLAGCHECK != (ullQueuedInterest & SPFEI_FLAGCHECK))
    {
        hr = E_INVALIDARG;
    }
    else if ((ullQueuedInterest | ullEventInterest) != ullEventInterest)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_ullEventInterest = ullEventInterest;
        m_ullQueuedInterest = ullQueuedInterest;
    }
    m_pParent->Unlock();
    return hr;
}


//
//  Same as AddEvents except:  No param validation, and caller must take the critical section
//  prior to calling.
//
inline HRESULT CSpEventSource::_AddEvents( const SPEVENT* pEventArray, ULONG ulCount )
{
    HRESULT hr = S_OK;
    for( ULONG i = 0; i < ulCount && SUCCEEDED(hr = _AddEvent(pEventArray[i])); ++i ) {}
    return hr;
}

inline HRESULT CSpEventSource::_AddEvent(const SPEVENT & Event)
{
    SPDBG_ASSERT(Event.eEventId < 64);
    SPDBG_ASSERT(Event.elParamType == SPET_LPARAM_IS_UNDEFINED ||
                 Event.elParamType == SPET_LPARAM_IS_TOKEN ||
                 Event.elParamType == SPET_LPARAM_IS_OBJECT ||
                 Event.elParamType == SPET_LPARAM_IS_POINTER ||
                 Event.elParamType == SPET_LPARAM_IS_STRING);
#ifdef _DEBUG
    if (Event.eEventId == SPEI_VOICE_CHANGE)
    {
        SPDBG_ASSERT(Event.elParamType == SPET_LPARAM_IS_TOKEN);
    }
    else if (Event.eEventId == SPEI_RECOGNITION || Event.eEventId == SPEI_FALSE_RECOGNITION || Event.eEventId == SPEI_HYPOTHESIS)
    {
        SPDBG_ASSERT(Event.elParamType == SPET_LPARAM_IS_OBJECT);
    }
    else if (Event.eEventId ==SPEI_REQUEST_UI || Event.eEventId == SPEI_TTS_BOOKMARK)
    {
        SPDBG_ASSERT(Event.elParamType == SPET_LPARAM_IS_STRING);
    }
#endif

    if ( (1i64 << Event.eEventId) & m_ullEventInterest )
    {
        CSpEventNode *pNode = m_FreeList.RemoveHead();
        if (pNode == NULL)
        {
            pNode = new CSpEventNode();
            if (pNode == NULL)
            {
                return E_OUTOFMEMORY;
            }
        }
        pNode->CopyFrom(&Event);
        m_PendingList.InsertSorted(pNode);
    }
    return S_OK;
}

inline HRESULT CSpEventSource::
    _DeserializeAndAddEvent(const BYTE *pBuffer, ULONG * pcbUsed)
{
    HRESULT hr = S_OK;
    const SPEVENT * pSrcEvent = (const SPEVENT *)pBuffer;
    SPDBG_ASSERT(pSrcEvent->eEventId < 64);
    if ( (1i64 << pSrcEvent->eEventId) & m_ullEventInterest )
    {
        CSpEventNode *pNode = m_FreeList.RemoveHead();
        if (pNode == NULL)
        {
            pNode = new CSpEventNode();
            if (pNode == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = pNode->Deserialize(((const SPSERIALIZEDEVENT64 *)(pBuffer)), pcbUsed);
            if (SUCCEEDED(hr))
            {
                m_PendingList.InsertSorted(pNode);
            }
            else
            {
                m_FreeList.InsertHead(pNode);
            }
        }
    }
    else
    {
// WCE compiler does not work propertly with template
#ifndef _WIN32_WCE
        *pcbUsed = SpEventSerializeSize<SPSERIALIZEDEVENT64>(pSrcEvent);
#else
        *pcbUsed = SpEventSerializeSize(pSrcEvent, sizeof(SPSERIALIZEDEVENT64));
#endif
    }
    return hr;
}

inline HRESULT CSpEventSource::_GetEvents( ULONG ulCount, SPEVENT* pEventArray, ULONG *pulFetched )
{
    HRESULT hr = S_OK;
    m_pParent->Lock();
    if( SPIsBadWritePtr( pEventArray, sizeof( SPEVENT ) * ulCount ) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR(pulFetched) )
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        ULONG ulCopied = 0;
        ULONG ulRemaining = ulCount;
        CSpEventNode * pCur = m_CompletedList.m_pHead;
        CSpEventNode * pLastCopied = NULL;
        while (ulRemaining && pCur)
        {
            pCur->Detach(pEventArray + ulCopied);
            pLastCopied = pCur;
            ulCopied++;
            pCur = pCur->m_pNext;
            ulRemaining--;
        }
        if (ulCopied)
        {
            if (m_FreeList.m_pHead == NULL)
            {
                m_FreeList.m_pTail = pLastCopied;
            }
            pLastCopied->m_pNext = m_FreeList.m_pHead;
            m_FreeList.m_pHead = m_CompletedList.m_pHead;
            m_CompletedList.m_pHead = pCur;
            m_CompletedList.m_cElements -= ulCopied;
            m_FreeList.m_cElements += ulCopied;
        }
        if (ulCopied < ulCount)
        {
            hr = S_FALSE;
        }
        if (pulFetched) 
        {
            *pulFetched = ulCopied;
        }
    }
    m_pParent->Unlock();
    return hr;
}


inline HRESULT CSpEventSource::_GetInfo( SPEVENTSOURCEINFO * pInfo )
{
    HRESULT hr = S_OK;
    m_pParent->Lock();    
    if( SP_IS_BAD_WRITE_PTR( pInfo ) )
    {
        hr = E_POINTER;
    }
    else
    {
        pInfo->ulCount = m_CompletedList.GetCount();
        pInfo->ullEventInterest = m_ullEventInterest;
        pInfo->ullQueuedInterest= m_ullQueuedInterest;
    }
    m_pParent->Unlock();
    return hr;
}



//
//  The caller must call this function with the critical section owned
//
inline HRESULT CSpEventSource::_CompleteEvents( ULONGLONG ullPos )
{
    HRESULT hr = S_OK;

    if (m_PendingList.m_pHead && m_PendingList.m_pHead->ullAudioStreamOffset <= ullPos)
    {
        BOOL bNotify = FALSE;
        while (m_PendingList.m_pHead &&
               m_PendingList.m_pHead->ullAudioStreamOffset <= ullPos)
        {
            CSpEventNode *pNode = m_PendingList.RemoveHead();
            if(pNode->ulStreamNum != m_ulStreamNum)
            {
                m_ulStreamNum = pNode->ulStreamNum;
            }
            if ( (1i64 << pNode->eEventId) & m_ullEventInterest )
            {
                bNotify = TRUE;
                //
                //  NOTE:  If we're forwarding events to an event sink then we'll only
                //  pay attention to the Interest flags.  If we're going to notify, then
                //  we'll only queue completed events that the user has explicitly asked
                //  us to store as completed events.
                //
                if ( (1i64 << pNode->eEventId) & m_ullQueuedInterest )
                {
                    m_CompletedList.InsertSorted(pNode);
                }
                else
                {
                    pNode->Clear();
                    m_FreeList.InsertHead(pNode);
                }
            }
            else
            {
                pNode->Clear();
                m_FreeList.InsertHead(pNode);
            }
        }    
        if (bNotify && m_cpNotifySink)
        {
            hr = m_cpNotifySink->Notify();
        }
    }
    return hr;
};


inline void CSpEventSource::_MoveAllToFreeList(CSpEventList * pList)
{
    CSpEventNode * pNode;
    while ((pNode = pList->RemoveHead()) != NULL)
    {
        pNode->Clear();
        m_FreeList.InsertHead(pNode);
    }
}
inline void CSpEventSource::_RemoveAllEvents( )
{
    m_pParent->Lock();

    _MoveAllToFreeList(&m_CompletedList);
    _MoveAllToFreeList(&m_PendingList);
    m_pParent->Unlock();
}

inline HRESULT CSpEventSource::_GetStreamNumber(const ULONGLONG ullAudioOffset, ULONG *pulStreamNum)
{
    CSpEventNode *pNode = m_PendingList.m_pHead;
    *pulStreamNum = m_ulStreamNum;
    for(;pNode && pNode->ullAudioStreamOffset <= ullAudioOffset; pNode = pNode->m_pNext)
    {
        *pulStreamNum = pNode->ulStreamNum;
    }
    return S_OK;
}



#endif //--- This must be the last line in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\include\spuihelp.h ===
/*******************************************************************************
* SPUIHelp.h *
*------------*
*   Description:
*       This is the header file for user-interface helper functions.  Note that
*       unlike SpHelper.H, this file requires the use of ATL.
*-------------------------------------------------------------------------------
*   Copyright (c) Microsoft Corporation. All rights reserved.
*******************************************************************************/

#ifndef SPUIHelp_h
#define SPUIHelp_h

#ifndef __sapi_h__
#include <sapi.h>
#endif

#ifndef SPError_h
#include <SPError.h>
#endif

#ifndef SPDebug_h
#include <SPDebug.h>
#endif

#ifndef SPHelper_h
#include <SPHelper.h>
#endif

#ifndef __ATLBASE_H__
#include <ATLBASE.h>
#endif

#ifndef __ATLCONV_H__
#include <ATLCONV.H>
#endif

/****************************************************************************
* 
*
*
********************************************************************* RAL ***/

//
//  Dont call this function directly.  Use SpInitTokenComboBox or SpInitTokenListBox.
//
inline HRESULT SpInitTokenList(UINT MsgAddString, UINT MsgSetItemData, UINT MsgSetCurSel,
                               HWND hwnd, const WCHAR * pszCatName,
                               const WCHAR * pszRequiredAttrib, const WCHAR * pszOptionalAttrib)
{
    HRESULT hr;
    ISpObjectToken * pToken;        // NOTE:  Not a CComPtr!  Be Careful.
    CComPtr<IEnumSpObjectTokens> cpEnum;
    hr = SpEnumTokens(pszCatName, pszRequiredAttrib, pszOptionalAttrib, &cpEnum);
    if (hr == S_OK)
    {
        bool fSetDefault = false;
        while (cpEnum->Next(1, &pToken, NULL) == S_OK)
        {
            CSpDynamicString dstrDesc;
            hr = SpGetDescription(pToken, &dstrDesc);
            if (SUCCEEDED(hr))
            {
                USES_CONVERSION;
                LRESULT i = ::SendMessage(hwnd, MsgAddString, 0, (LPARAM)W2T(dstrDesc));
                if (i == CB_ERR || i == CB_ERRSPACE)    // Note:  CB_ and LB_ errors are identical values...
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    ::SendMessage(hwnd, MsgSetItemData, i, (LPARAM)pToken);
                    if (!fSetDefault)
                    {
                        ::SendMessage(hwnd, MsgSetCurSel, i, 0);
                        fSetDefault = true;
                    }
                }
            }
            if (FAILED(hr))
            {
                pToken->Release();
            }
        }
    }
    else
    {
        hr = SPERR_NO_MORE_ITEMS;
    }
    return hr;
}

inline HRESULT SpInitTokenComboBox(HWND hwnd, const WCHAR * pszCatName,
                                   const WCHAR * pszRequiredAttrib = NULL, const WCHAR * pszOptionalAttrib = NULL)
{
    return SpInitTokenList(CB_ADDSTRING, CB_SETITEMDATA, CB_SETCURSEL, hwnd, pszCatName, pszRequiredAttrib, pszOptionalAttrib);
}

inline HRESULT SpInitTokenListBox(HWND hwnd, const WCHAR * pszCatName,
                                   const WCHAR * pszRequiredAttrib = NULL, const WCHAR * pszOptionalAttrib = NULL)
{
    return SpInitTokenList(LB_ADDSTRING, LB_SETITEMDATA, LB_SETCURSEL, hwnd, pszCatName, pszRequiredAttrib, pszOptionalAttrib);
}

//
//  Dont call this function directly.  Use SpDestoyTokenComboBox or SpDestroyTokenListBox.
//
inline void SpDestroyTokenList(UINT MsgGetCount, UINT MsgGetItemData, HWND hwnd)
{
    LRESULT c = ::SendMessage(hwnd, MsgGetCount, 0, 0);
    for (LRESULT i = 0; i < c; i++)
    {
        IUnknown * pUnkObj = (IUnknown *)::SendMessage(hwnd, MsgGetItemData, i, 0);
        if (pUnkObj)
        {
            pUnkObj->Release();
        }
    }
}

inline void SpDestroyTokenComboBox(HWND hwnd)
{
    SpDestroyTokenList(CB_GETCOUNT, CB_GETITEMDATA, hwnd);
}

inline void SpDestroyTokenListBox(HWND hwnd)
{
    SpDestroyTokenList(LB_GETCOUNT, LB_GETITEMDATA, hwnd);
}


inline ISpObjectToken * SpGetComboBoxToken(HWND hwnd, WPARAM Index)
{
    return (ISpObjectToken *)::SendMessage(hwnd, CB_GETITEMDATA, Index, 0);
}

inline ISpObjectToken * SpGetListBoxToken(HWND hwnd, WPARAM Index)
{
    return (ISpObjectToken *)::SendMessage(hwnd, LB_GETITEMDATA, Index, 0);
}

inline ISpObjectToken * SpGetCurSelComboBoxToken(HWND hwnd)
{
    LRESULT i = ::SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    return (i == CB_ERR) ? NULL : SpGetComboBoxToken(hwnd, i);
}

inline ISpObjectToken * SpGetCurSelListBoxToken(HWND hwnd)
{
    LRESULT i = ::SendMessage(hwnd, LB_GETCURSEL, 0, 0);
    return (i == LB_ERR) ? NULL : SpGetListBoxToken(hwnd, i);
}

//
//  Don't call this directly.  Use SpUpdateCurSelComboBoxToken or SpUpdateCurSelListBoxToken
//
inline HRESULT SpUpdateCurSelToken(UINT MsgDelString, UINT MsgInsertString, UINT MsgGetItemData, UINT MsgSetItemData, UINT MsgGetCurSel, UINT MsgSetCurSel,
                                   HWND hwnd)
{
    HRESULT hr = S_OK;
    LRESULT i = ::SendMessage(hwnd, MsgGetCurSel, 0, 0);
    if (i != CB_ERR)
    {
        ISpObjectToken * pToken = (ISpObjectToken *)::SendMessage(hwnd, MsgGetItemData, i, 0);
        CSpDynamicString dstrDesc;
        hr = SpGetDescription(pToken, &dstrDesc);
        if (SUCCEEDED(hr))
        {
            USES_CONVERSION;
            ::SendMessage(hwnd, MsgDelString, i, 0);
            ::SendMessage(hwnd, MsgInsertString, i, (LPARAM)W2T(dstrDesc));
            ::SendMessage(hwnd, MsgSetItemData, i, (LPARAM)pToken);
            ::SendMessage(hwnd, MsgSetCurSel, i, 0);
        }
    }
    return hr;
}

inline HRESULT SpUpdateCurSelComboBoxToken(HWND hwnd)
{
    return SpUpdateCurSelToken(CB_DELETESTRING, CB_INSERTSTRING, CB_GETITEMDATA, CB_SETITEMDATA, CB_GETCURSEL, CB_SETCURSEL, hwnd);
}

inline HRESULT SpUpdateCurSelListBoxToken(HWND hwnd)
{
    return SpUpdateCurSelToken(LB_DELETESTRING, LB_INSERTSTRING, LB_GETITEMDATA, LB_SETITEMDATA, LB_GETCURSEL, LB_SETCURSEL, hwnd);
}

inline HRESULT SpAddTokenToList(UINT MsgAddString, UINT MsgSetItemData, UINT MsgSetCurSel, HWND hwnd, ISpObjectToken * pToken)
{
    CSpDynamicString dstrDesc;
    HRESULT hr = SpGetDescription(pToken, &dstrDesc);
    if (SUCCEEDED(hr))
    {
        USES_CONVERSION;
        LRESULT i = ::SendMessage(hwnd, MsgAddString, 0, (LPARAM)W2T(dstrDesc));
        if (i == CB_ERR || i == CB_ERRSPACE)    // Note:  CB_ and LB_ errors are identical values...
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            ::SendMessage(hwnd, MsgSetItemData, i, (LPARAM)pToken);
            ::SendMessage(hwnd, MsgSetCurSel, i, 0);
            pToken->AddRef();
        }
    }
    return hr;
}

inline HRESULT SpAddTokenToComboBox(HWND hwnd, ISpObjectToken * pToken)
{
    return SpAddTokenToList(CB_ADDSTRING, CB_SETITEMDATA, CB_SETCURSEL, hwnd, pToken);
}

inline HRESULT SpAddTokenToListBox(HWND hwnd, ISpObjectToken * pToken)
{
    return SpAddTokenToList(LB_ADDSTRING, LB_SETITEMDATA, LB_SETCURSEL, hwnd, pToken);
}


inline HRESULT SpDeleteCurSelToken(UINT MsgGetCurSel, UINT MsgSetCurSel, UINT MsgGetItemData, UINT MsgDeleteString, HWND hwnd)
{
    HRESULT hr = S_OK;
    LRESULT i = ::SendMessage(hwnd, MsgGetCurSel, 0, 0);
    if (i == CB_ERR)
    {
        hr = S_FALSE;
    }
    else
    {
        ISpObjectToken * pToken = (ISpObjectToken *)::SendMessage(hwnd, MsgGetItemData, i, 0);
        if (pToken)
        {
            pToken->Release();
        }
        ::SendMessage(hwnd, MsgDeleteString, i, 0);
        ::SendMessage(hwnd, MsgSetCurSel, i, 0);
    }
    return hr;
}

inline HRESULT SpDeleteCurSelComboBoxToken(HWND hwnd)
{
    return SpDeleteCurSelToken(CB_GETCURSEL, CB_SETCURSEL, CB_GETITEMDATA, CB_DELETESTRING, hwnd);
}

inline HRESULT SpDeleteCurSelListBoxToken(HWND hwnd)
{
    return SpDeleteCurSelToken(LB_GETCURSEL, CB_SETCURSEL, LB_GETITEMDATA, LB_DELETESTRING, hwnd);
}

#endif /* #ifndef SPUIHelp_h -- This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\chs\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\chs\itngramver.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif
#include <windows.h>
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Microsoft Speech Recognition ITN"
#define VER_INTERNALNAME_STR        "ITNGRAM"
#define VER_ORIGINALFILENAME_STR    "ITNGRAM.DLL"

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* this include file is generated by the build process to       */
/* reflect the current build number                             */
/*--------------------------------------------------------------*/

#include "currver.inc"

#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifdef _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft Speech Engine\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#include "_common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\chs\itngram_chs.cpp ===
// itngram_CHS.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f itngramps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "itngram_CHS.h"

#include "itngram_CHS_i.c"
#include "TestITN_CHS.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TestITN_CHS, CTestITN_CHS)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ITNGRAMLib);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\include\wincestub.h ===
#ifndef WinCEStub_h
#define WinCEStub_h

#include "basetsd_ce.h"
#include <spdebug.h>
#include <spcollec.h>

#define InterlockedExchangePointer( pv, v)  InterlockedExchange( (long*)pv, (long)v)
#define SetWindowLongPtr                    SetWindowLong
#define GetWindowLongPtr                    GetWindowLong

// winuser.h
#define GWLP_WNDPROC    GWL_WNDPROC
#define GWLP_STYLE      GWL_STYLE
#define GWLP_EXSTYLE    GWL_EXSTYLE
#define GWLP_USERDATA   GWL_USERDATA
#define GWLP_ID         GWL_ID

// from basetsd.h
/*#define LongToHandle( h) ((HANDLE)(LONG_PTR) (h))
#define PtrToUint( p ) ((UINT)(UINT_PTR) (p) )
#define PtrToInt( p ) ((INT)(INT_PTR) (p) )
#define IntToPtr( i )    ((VOID *)(INT_PTR)((int)i))
#define UIntToPtr( ui )  ((VOID *)(UINT_PTR)((unsigned int)ui))
#define LongToPtr( l )   ((VOID *)(LONG_PTR)((long)l))
#define ULongToPtr( ul )  ((VOID *)(ULONG_PTR)((unsigned long)ul))

#define UlongToPtr(ul) ULongToPtr(ul)
#define UintToPtr(ui) UIntToPtr(ui)

typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;
*/

// from winbase.h
#define NORMAL_PRIORITY_CLASS       0x00000020

// from winbase.h
#define LOCKFILE_FAIL_IMMEDIATELY   0x00000001
#define LOCKFILE_EXCLUSIVE_LOCK     0x00000002


//
#define CSIDL_FLAG_CREATE               0x8000      // new for Win2K, or this in to force creation of folder

// stdlib.d defined in sapiguid.cpp
void *bsearch( const void *key, const void *base, size_t num, size_t width, int ( __cdecl *compare ) ( const void *elem1, const void *elem2 ) );

//  Fix misaligment exception
#if defined (_M_ALPHA)||defined(_M_MRX000)||defined(_M_PPC)||defined(_SH4_)
   #undef  UNALIGNED
   #define UNALIGNED __unaligned
#endif

// WCE does not have LockFileEx function. We do need emulate this functionality.
class CWCELock
{
public:
    CWCELock(   DWORD       dwFlags, 
                DWORD       nNumberOfBytesToLockLow, 
                DWORD       nNumberOfBytesToLockHigh, 
                LPOVERLAPPED  pOverlapped): m_dwFlags(dwFlags), 
                                            m_nNumberOfBytesToLockLow(nNumberOfBytesToLockLow), 
                                            m_nNumberOfBytesToLockHigh(nNumberOfBytesToLockHigh),
                                            m_Offset(0),
                                            m_OffsetHigh(0),
                                            hEvent(0)
    {
//        memcpy(&m_Overlapped, pOverlapped, sizeof(OVERLAPPED));
        if (pOverlapped)
        {
            m_Offset        = pOverlapped->Offset;
            m_OffsetHigh    = pOverlapped->OffsetHigh;
            hEvent          = pOverlapped->hEvent;
        }

        m_ProcessID     = ::GetCurrentProcessId();
    }
    ~CWCELock()
    {
        m_Offset        = 0;
        m_OffsetHigh    = 0;
        hEvent          = 0;
        m_ProcessID     = 0;
    }

/*    BOOL IsEqual(   DWORD           nNumberOfBytesToLockLow, 
                    DWORD           nNumberOfBytesToLockHigh, 
                    LPOVERLAPPED    pOverlapped
                )
    {
        if (    nNumberOfBytesToLockLow==m_nNumberOfBytesToLockLow &&
                nNumberOfBytesToLockHigh==m_nNumberOfBytesToLockHigh &&
                !memcmp(&m_Overlapped, pOverlapped, sizeof(OVERLAPPED))
           )
        {
           return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
*/

private:
    DWORD       m_dwFlags;                  // lock options
    DWORD       m_nNumberOfBytesToLockLow;  // low-order word of length 
    DWORD       m_nNumberOfBytesToLockHigh; // high-order word of length
    DWORD       m_Offset;
    DWORD       m_OffsetHigh;
    HANDLE      hEvent;

    DWORD       m_ProcessID;
};

typedef CSPList<CWCELock*,CWCELock*> CWCELockList;

class CWCELocks
{
public:

    CWCELocks() { 
        m_pCWCELockList = new CWCELockList(); 
    }
    ~CWCELocks() {
        while(!m_pCWCELockList->IsEmpty())
        {
            CWCELock* pCWCELock = m_pCWCELockList->RemoveHead();
            delete pCWCELock;
        }
        delete m_pCWCELockList;
    }

    BOOL LockFileEx(
        IN HANDLE hFile,
        IN DWORD dwFlags,
        IN DWORD dwReserved,
        IN DWORD nNumberOfBytesToLockLow,
        IN DWORD nNumberOfBytesToLockHigh,
        IN LPOVERLAPPED lpOverlapped
    )
    {
        return TRUE;
    }

    BOOL UnlockFileEx(
        IN HANDLE hFile,
        IN DWORD dwReserved,
        IN DWORD nNumberOfBytesToUnlockLow,
        IN DWORD nNumberOfBytesToUnlockHigh,
        IN LPOVERLAPPED lpOverlapped
    )
    {
        return TRUE;
    }
    

private:

    CWCELockList*    m_pCWCELockList;
};


#endif //WinCEStub_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\include\sphelper.h ===
/*******************************************************************************
* SPHelper.h *
*------------*
*   Description:
*       This is the header file for core helper functions implementation.
*-------------------------------------------------------------------------------
*   Copyright (c) Microsoft Corporation. All rights reserved.
*******************************************************************************/
#ifndef SPHelper_h
#define SPHelper_h

#ifndef _INC_MALLOC
#include <malloc.h>
#endif

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

#ifndef __sapi_h__
#include <sapi.h>
#endif

#ifndef __sapiddk_h__
#include <sapiddk.h>
#endif

#ifndef SPError_h
#include <SPError.h>
#endif

#ifndef SPDebug_h
#include <SPDebug.h>
#endif

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_MMSYSTEM
#include <mmsystem.h>
#endif

#ifndef __comcat_h__
#include <comcat.h>
#endif

#ifndef _INC_MMREG
#include <mmreg.h>
#endif

#ifndef __ATLBASE_H__
#include <atlbase.h>
#endif

//=== Constants ==============================================================
#define sp_countof(x) ((sizeof(x) / sizeof(*(x))))

/*** CSpDynamicString helper class
*
*/
class CSpDynamicString 
{
public:

    WCHAR *     m_psz;
    CSpDynamicString()
    {
        m_psz = NULL;
    }
    CSpDynamicString(ULONG cchReserve)
    {
        m_psz = (WCHAR *)::CoTaskMemAlloc(cchReserve * sizeof(WCHAR));
    }
    WCHAR * operator=(const CSpDynamicString& src)
    {
        if (m_psz != src.m_psz)
        {
            ::CoTaskMemFree(m_psz);
            m_psz = src.Copy();
        }
        return m_psz;
    }
    WCHAR * operator=(const WCHAR * pSrc)
    {
        Clear();
        if (pSrc)
        {
            ULONG cbNeeded = (wcslen(pSrc) + 1) * sizeof(WCHAR);
            m_psz = (WCHAR *)::CoTaskMemAlloc(cbNeeded);
            SPDBG_ASSERT(m_psz);
            if (m_psz)
            {
                memcpy(m_psz, pSrc, cbNeeded);    
            }
        }
        return m_psz;
    }

    WCHAR * operator=(const char * pSrc)
    {
        Clear();
        if (pSrc)
        {
            ULONG cbNeeded = (lstrlenA(pSrc) + 1) * sizeof(WCHAR);
            m_psz = (WCHAR *)::CoTaskMemAlloc(cbNeeded);
            SPDBG_ASSERT(m_psz);
            if (m_psz)
            {
                ::MultiByteToWideChar(CP_ACP, 0, pSrc, -1, m_psz, cbNeeded/sizeof(WCHAR));
            }
        }
        return m_psz;
    }

    WCHAR * operator=(REFGUID rguid)
    {
        Clear();
        ::StringFromCLSID(rguid, &m_psz);
        return m_psz;
    }


    /*explicit*/ CSpDynamicString(const WCHAR * pSrc)
    {
        m_psz = NULL;
        operator=(pSrc);
    }
    /*explicit*/ CSpDynamicString(const char * pSrc)
    {
        m_psz = NULL;
        operator=(pSrc);
    }
    /*explicit*/ CSpDynamicString(const CSpDynamicString& src)
    {
        m_psz = src.Copy();
    }
    /*explicit*/ CSpDynamicString(REFGUID rguid)
    {
        ::StringFromCLSID(rguid, &m_psz);
    }


    ~CSpDynamicString()
    {
        ::CoTaskMemFree(m_psz);
    }
    unsigned int Length() const
    {
        return (m_psz == NULL)? 0 : wcslen(m_psz);
    }

    operator WCHAR * () const
    {
        return m_psz;
    }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the m_psz member explicitly.
    WCHAR ** operator&()
    {
        SPDBG_ASSERT(m_psz == NULL);
        return &m_psz;
    }

    WCHAR * Append(const WCHAR * pszSrc)
    {
        if (pszSrc)
        {
            ULONG lenSrc = wcslen(pszSrc);
            if (lenSrc)
            {
                ULONG lenMe = Length();
                WCHAR *pszNew = (WCHAR *)::CoTaskMemAlloc((lenMe + lenSrc + 1) * sizeof(WCHAR));
                if (pszNew)
                {
                    if (m_psz)  // Could append to an empty string so check...
                    {
                        if (lenMe)
                        {
                            memcpy(pszNew, m_psz, lenMe * sizeof(WCHAR));
                        }
                        ::CoTaskMemFree(m_psz);
                    }
                    memcpy(pszNew + lenMe, pszSrc, (lenSrc + 1) * sizeof(WCHAR));
                    m_psz = pszNew;
                }
                else
                {
                    SPDBG_ASSERT(FALSE);
                }
            }
        }
        return m_psz;
    }

    WCHAR * Append(const WCHAR * pszSrc, const ULONG lenSrc)
    {
        if (pszSrc && lenSrc)
        {
            ULONG lenMe = Length();
            WCHAR *pszNew = (WCHAR *)::CoTaskMemAlloc((lenMe + lenSrc + 1) * sizeof(WCHAR));
            if (pszNew)
            {
                if (m_psz)  // Could append to an empty string so check...
                {
                    if (lenMe)
                    {
                        memcpy(pszNew, m_psz, lenMe * sizeof(WCHAR));
                    }
                    ::CoTaskMemFree(m_psz);
                }
                memcpy(pszNew + lenMe, pszSrc, lenSrc * sizeof(WCHAR));
                *(pszNew + lenMe + lenSrc) = L'\0';
                m_psz = pszNew;
            }
            else
            {
                SPDBG_ASSERT(FALSE);
            }
        }
        return m_psz;
    }

    WCHAR * Append2(const WCHAR * pszSrc1, const WCHAR * pszSrc2)
    {
        ULONG lenSrc1 = pszSrc1 ? wcslen(pszSrc1) : 0;
        ULONG lenSrc2 = pszSrc2 ? wcslen(pszSrc2) : 0;

        if (lenSrc1 || lenSrc2)
        {
            ULONG lenMe = Length();
            WCHAR *pszNew = (WCHAR *)::CoTaskMemAlloc((lenMe + lenSrc1 + lenSrc2 + 1) * sizeof(WCHAR));
            if (pszNew)
            {
                if (m_psz)  // Could append to an empty string so check...
                {
                    if (lenMe)
                    {
                        memcpy(pszNew, m_psz, lenMe * sizeof(WCHAR));
                    }
                    ::CoTaskMemFree(m_psz);
                }
                // In both of these cases, we copy the trailing NULL so that we're sure it gets
                // there (if lenSrc2 is 0 then we better copy it from pszSrc1).
                if (lenSrc1)
                {
                    memcpy(pszNew + lenMe, pszSrc1, (lenSrc1 + 1) * sizeof(WCHAR));
                }
                if (lenSrc2)
                {
                    memcpy(pszNew + lenMe + lenSrc1, pszSrc2, (lenSrc2 + 1) * sizeof(WCHAR));
                }
                m_psz = pszNew;
            }
            else
            {
                SPDBG_ASSERT(FALSE);
            }
        }
        return m_psz;
    }
    WCHAR * Copy() const
    {
        if (m_psz)
        {
            CSpDynamicString szNew(m_psz);
            return szNew.Detach();
        }
        return NULL;
    }
    CHAR * CopyToChar() const
    {
        if (m_psz)
        {
            CHAR* psz;
            ULONG cbNeeded = ::WideCharToMultiByte(CP_ACP, 0, m_psz, -1, NULL, NULL, NULL, NULL);
            psz = (CHAR *)::CoTaskMemAlloc(cbNeeded);
            SPDBG_ASSERT(psz);
            if (psz)
            {
                ::WideCharToMultiByte(CP_ACP, 0, m_psz, -1, psz, cbNeeded/sizeof(CHAR), NULL, NULL);
            }
            return psz;
        }
        return NULL;
    }
    void Attach(WCHAR * pszSrc)
    {
        SPDBG_ASSERT(m_psz == NULL);
        m_psz = pszSrc;
    }
    WCHAR * Detach()
    {
        WCHAR * s = m_psz;
        m_psz = NULL;
        return s;
    }
    void Clear()
    {
        ::CoTaskMemFree(m_psz);
        m_psz = NULL;
    }
    bool operator!() const
    {
        return (m_psz == NULL);
    }
    HRESULT CopyToBSTR(BSTR * pbstr)
    {
        if (m_psz)
        {
            *pbstr = ::SysAllocString(m_psz);
            if (*pbstr == NULL)
            {
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            *pbstr = NULL;
        }
        return S_OK;
    }
    void TrimToSize(ULONG ulNumChars)
    {
        if (m_psz && ulNumChars < Length())
        {
            m_psz[ulNumChars] = 0;
        }
    }
    WCHAR * Compact()
    {
        if (m_psz)
        {
            ULONG cch = wcslen(m_psz);
            m_psz = (WCHAR *)::CoTaskMemRealloc(m_psz, (cch + 1) * sizeof(WCHAR));
        }
        return m_psz;
    }
    WCHAR * ClearAndGrowTo(ULONG cch)
    {
        if (m_psz)
        {
            Clear();
        }
        m_psz = (WCHAR *)::CoTaskMemAlloc(cch * sizeof(WCHAR));
        return m_psz;
    }
    WCHAR * LTrim()
    {
        if (m_psz)
        {
            WCHAR * pszRead = m_psz;
            while (iswspace(*pszRead))
            {
                pszRead++;
            }
            if (pszRead != m_psz)
            {
                WCHAR * pszWrite = m_psz;
                while (*pszRead)
                {
                    *pszWrite++ = *pszRead++;
                }
                *pszWrite = '\0';
            }
        }
        return m_psz;
    }
    WCHAR * RTrim()
    {
        if (m_psz)
        {
            WCHAR * pszTail = m_psz + wcslen(m_psz);
            WCHAR * pszZeroTerm = pszTail;
            while (pszZeroTerm > m_psz && iswspace(pszZeroTerm[-1]))
            {
                pszZeroTerm--;
            }
            if (pszZeroTerm != pszTail)
            {
                *pszZeroTerm = '\0';
            }
        }
        return m_psz;        
    }
    WCHAR * TrimBoth()
    {
        RTrim();
        return LTrim();
    }
};



//
//  Simple inline function converts a ulong to a hex string.
//
inline void SpHexFromUlong(WCHAR * psz, ULONG ul)
{
    const static WCHAR szHexChars[] = L"0123456789ABCDEF";
    if (ul == 0)
    {
        psz[0] = L'0';
        psz[1] = 0;
    }
    else
    {
        ULONG ulChars = 1;
        psz[0] = 0;
        while (ul)
        {
            memmove(psz + 1, psz, ulChars * sizeof(WCHAR));
            psz[0] = szHexChars[ul % 16];
            ul /= 16;
            ulChars++;
        }
    }
}


//=== Token helpers

inline HRESULT SpGetTokenFromId(
    const WCHAR * pszTokenId, 
    ISpObjectToken ** ppToken,
    BOOL fCreateIfNotExist = FALSE)
{
    SPDBG_FUNC("SpGetTokenFromId");
    HRESULT hr;
    
    CComPtr<ISpObjectToken> cpToken;
    hr = cpToken.CoCreateInstance(CLSID_SpObjectToken);
    
    if (SUCCEEDED(hr))
    {
        hr = cpToken->SetId(NULL, pszTokenId, fCreateIfNotExist);
    }
    
    if (SUCCEEDED(hr))
    {
        *ppToken = cpToken.Detach();
    }
    
    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

inline HRESULT SpGetCategoryFromId(
    const WCHAR * pszCategoryId,
    ISpObjectTokenCategory ** ppCategory,
    BOOL fCreateIfNotExist = FALSE)
{
    SPDBG_FUNC("SpGetCategoryFromId");
    HRESULT hr;
    
    CComPtr<ISpObjectTokenCategory> cpTokenCategory;
    hr = cpTokenCategory.CoCreateInstance(CLSID_SpObjectTokenCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpTokenCategory->SetId(pszCategoryId, fCreateIfNotExist);
    }
    
    if (SUCCEEDED(hr))
    {
        *ppCategory = cpTokenCategory.Detach();
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpGetDefaultTokenIdFromCategoryId(
    const WCHAR * pszCategoryId,
    WCHAR ** ppszTokenId)
{
    SPDBG_FUNC("SpGetDefaultTokenFromCategoryId");
    HRESULT hr;

    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->GetDefaultTokenId(ppszTokenId);
    }

    return hr;
}

inline HRESULT SpSetDefaultTokenIdForCategoryId(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenId)
{
    SPDBG_FUNC("SpSetDefaultTokenIdForCategoryId");
    HRESULT hr;

    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->SetDefaultTokenId(pszTokenId);
    }

    return hr;
}

inline HRESULT SpGetDefaultTokenFromCategoryId(
    const WCHAR * pszCategoryId,
    ISpObjectToken ** ppToken,
    BOOL fCreateCategoryIfNotExist = TRUE)
{
    SPDBG_FUNC("SpGetDefaultTokenFromCategoryId");
    HRESULT hr;

    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory, fCreateCategoryIfNotExist);

    if (SUCCEEDED(hr))
    {
        WCHAR * pszTokenId;
        hr = cpCategory->GetDefaultTokenId(&pszTokenId);
        if (SUCCEEDED(hr))
        {
            hr = SpGetTokenFromId(pszTokenId, ppToken);
            ::CoTaskMemFree(pszTokenId);
        }
    }

    return hr;
}

inline HRESULT SpSetDefaultTokenForCategoryId(
    const WCHAR * pszCategoryId,
    ISpObjectToken * pToken)
{
    SPDBG_FUNC("SpSetDefaultTokenForCategoryId");
    HRESULT hr;

    WCHAR * pszTokenId;
    hr = pToken->GetId(&pszTokenId);

    if (SUCCEEDED(hr))
    {
        hr = SpSetDefaultTokenIdForCategoryId(pszCategoryId, pszTokenId);
        ::CoTaskMemFree(pszTokenId);
    }

    return hr;
}

inline HRESULT SpSetCommonTokenData(
    ISpObjectToken * pToken,
    const CLSID * pclsid,
    const WCHAR * pszLangIndependentName,
    LANGID langid,
    const WCHAR * pszLangDependentName,
    ISpDataKey ** ppDataKeyAttribs)
{
    SPDBG_FUNC("SpSetCommonTokenData");
    HRESULT hr = S_OK;
    
    // Set the new token's CLSID (if specified)
    if (SUCCEEDED(hr) && pclsid)
    {
        CSpDynamicString dstrClsid;
        hr = StringFromCLSID(*pclsid, &dstrClsid);
    
        if (SUCCEEDED(hr))
        {
            hr = pToken->SetStringValue(SPTOKENVALUE_CLSID, dstrClsid);
        }
    }

    // Set the token's lang independent name
    if (SUCCEEDED(hr) && pszLangIndependentName)
    {
        hr = pToken->SetStringValue(NULL, pszLangIndependentName);
    }

    // Set the token's lang dependent name
    if (SUCCEEDED(hr) && pszLangDependentName)
    {
        USES_CONVERSION;
        
        TCHAR szLangId[10];
        wsprintf(szLangId, _T("%x"), langid);

        hr = pToken->SetStringValue(T2W(szLangId), pszLangDependentName);
    }

    // Open the attributes key if requested
    if (SUCCEEDED(hr) && ppDataKeyAttribs)
    {
        hr = pToken->CreateKey(L"Attributes", ppDataKeyAttribs);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpCreateNewToken(
    const WCHAR * pszTokenId,
    ISpObjectToken ** ppToken)
{
    SPDBG_FUNC("SpCreateNewToken");
    HRESULT hr;

    // Forcefully create the token
    hr = SpGetTokenFromId(pszTokenId, ppToken, TRUE);
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpCreateNewToken(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenKeyName,
    ISpObjectToken ** ppToken)
{
    SPDBG_FUNC("SpCreateNewToken");
    HRESULT hr;

    // Forcefully create the category
    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory, TRUE);

    // Come up with a token key name if one wasn't specified
    CSpDynamicString dstrTokenKeyName;
    if (SUCCEEDED(hr))
    {
        if (pszTokenKeyName == NULL)
        {
            GUID guidTokenKeyName;
            hr = CoCreateGuid(&guidTokenKeyName);

            if (SUCCEEDED(hr))
            {
                hr = StringFromCLSID(guidTokenKeyName, &dstrTokenKeyName);
            }

            if (SUCCEEDED(hr))
            {
                pszTokenKeyName = dstrTokenKeyName;
            }
        }
    }

    // Build the token id
    CSpDynamicString dstrTokenId;
    if (SUCCEEDED(hr))
    {
        dstrTokenId = pszCategoryId;
        dstrTokenId.Append2(L"\\Tokens\\", pszTokenKeyName);
    }

    // Forcefully create the token
    if (SUCCEEDED(hr))
    {
        hr = SpGetTokenFromId(dstrTokenId, ppToken, TRUE);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpCreateNewTokenEx(
    const WCHAR * pszCategoryId,
    const WCHAR * pszTokenKeyName,
    const CLSID * pclsid,
    const WCHAR * pszLangIndependentName,
    LANGID langid,
    const WCHAR * pszLangDependentName,
    ISpObjectToken ** ppToken,
    ISpDataKey ** ppDataKeyAttribs)
{
    SPDBG_FUNC("SpCreateNewTokenEx");
    HRESULT hr;

    // Create the new token
    hr = SpCreateNewToken(pszCategoryId, pszTokenKeyName, ppToken);

    // Now set the extra data
    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                    *ppToken, 
                    pclsid, 
                    pszLangIndependentName, 
                    langid, 
                    pszLangDependentName, 
                    ppDataKeyAttribs);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpCreateNewTokenEx(
    const WCHAR * pszTokenId,
    const CLSID * pclsid,
    const WCHAR * pszLangIndependentName,
    LANGID langid,
    const WCHAR * pszLangDependentName,
    ISpObjectToken ** ppToken,
    ISpDataKey ** ppDataKeyAttribs)
{
    SPDBG_FUNC("SpCreateNewTokenEx");
    HRESULT hr;

    // Create the new token
    hr = SpCreateNewToken(pszTokenId, ppToken);

    // Now set the extra data
    if (SUCCEEDED(hr))
    {
        hr = SpSetCommonTokenData(
                    *ppToken, 
                    pclsid, 
                    pszLangIndependentName, 
                    langid, 
                    pszLangDependentName, 
                    ppDataKeyAttribs);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpEnumTokens(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    IEnumSpObjectTokens ** ppEnum)
{
    SPDBG_FUNC("SpEnumTokens");
    HRESULT hr = S_OK;
    
    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(pszCategoryId, &cpCategory);
    
    if (SUCCEEDED(hr))
    {
        hr = cpCategory->EnumTokens(
                    pszReqAttribs,
                    pszOptAttribs,
                    ppEnum);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

inline HRESULT SpFindBestToken(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    ISpObjectToken **ppObjectToken)
{
    SPDBG_FUNC("SpFindBestToken");
    HRESULT hr = S_OK;
    
    const WCHAR *pszVendorPreferred = L"VendorPreferred";
    const ulLenVendorPreferred = wcslen(pszVendorPreferred);

    // append VendorPreferred to the end of pszOptAttribs to force this preference
    ULONG ulLen = pszOptAttribs ? wcslen(pszOptAttribs) + ulLenVendorPreferred + 1 : ulLenVendorPreferred;
    WCHAR *pszOptAttribsVendorPref = (WCHAR*)_alloca((ulLen+1)*sizeof(WCHAR));
    if (pszOptAttribsVendorPref)
    {
        if (pszOptAttribs)
        {
            wcscpy(pszOptAttribsVendorPref, pszOptAttribs);
            wcscat(pszOptAttribsVendorPref, L";");
            wcscat(pszOptAttribsVendorPref, pszVendorPreferred);
        }
        else
        {
            wcscpy(pszOptAttribsVendorPref, pszVendorPreferred);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    CComPtr<IEnumSpObjectTokens> cpEnum;
    if (SUCCEEDED(hr))
    {
        hr = SpEnumTokens(pszCategoryId, pszReqAttribs, pszOptAttribsVendorPref, &cpEnum);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpEnum->Next(1, ppObjectToken, NULL);
        if (hr == S_FALSE)
        {
            *ppObjectToken = NULL;
            hr = SPERR_NOT_FOUND;
        }
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }
    
    return hr;
}

template<class T>
HRESULT SpCreateObjectFromToken(ISpObjectToken * pToken, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
    SPDBG_FUNC("SpCreateObjectFromToken");
    HRESULT hr;

    hr = pToken->CreateInstance(pUnkOuter, dwClsCtxt, __uuidof(T), (void **)ppObject);
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

template<class T>
HRESULT SpCreateObjectFromTokenId(const WCHAR * pszTokenId, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
    SPDBG_FUNC("SpCreateObjectFromTokenId");
    
    ISpObjectToken * pToken;
    HRESULT hr = SpGetTokenFromId(pszTokenId, &pToken);
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(pToken, ppObject, pUnkOuter, dwClsCtxt);
        pToken->Release();
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

template<class T>
HRESULT SpCreateDefaultObjectFromCategoryId(const WCHAR * pszCategoryId, T ** ppObject,
                       IUnknown * pUnkOuter = NULL, DWORD dwClsCtxt = CLSCTX_ALL)
{
    SPDBG_FUNC("SpCreateObjectFromTokenId");
    
    ISpObjectToken * pToken;
    HRESULT hr = SpGetDefaultTokenFromCategoryId(pszCategoryId, &pToken);
    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(pToken, ppObject, pUnkOuter, dwClsCtxt);
        pToken->Release();
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

template<class T>
HRESULT SpCreateBestObject(
    const WCHAR * pszCategoryId, 
    const WCHAR * pszReqAttribs, 
    const WCHAR * pszOptAttribs, 
    T ** ppObject,
    IUnknown * pUnkOuter = NULL, 
    DWORD dwClsCtxt = CLSCTX_ALL)
{
    SPDBG_FUNC("SpCreateBestObject");
    HRESULT hr;
    
    CComPtr<ISpObjectToken> cpToken;
    hr = SpFindBestToken(pszCategoryId, pszReqAttribs, pszOptAttribs, &cpToken);

    if (SUCCEEDED(hr))
    {
        hr = SpCreateObjectFromToken(cpToken, ppObject, pUnkOuter, dwClsCtxt);
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

inline HRESULT SpCreatePhoneConverter(
    LANGID LangID,
    const WCHAR * pszReqAttribs,
    const WCHAR * pszOptAttribs,
    ISpPhoneConverter ** ppPhoneConverter)
{
    SPDBG_FUNC("SpCreatePhoneConverter");
    HRESULT hr;

    if (LangID == 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CSpDynamicString dstrReqAttribs;
        if (pszReqAttribs)
        {
            dstrReqAttribs = pszReqAttribs;
            dstrReqAttribs.Append(L";");
        }

        WCHAR szLang[MAX_PATH];

        SpHexFromUlong(szLang, LangID);

        WCHAR szLangCondition[MAX_PATH];
        wcscpy(szLangCondition, L"Language=");
        wcscat(szLangCondition, szLang);

        dstrReqAttribs.Append(szLangCondition);

        hr = SpCreateBestObject(SPCAT_PHONECONVERTERS, dstrReqAttribs, pszOptAttribs, ppPhoneConverter);
    }

    if (hr != SPERR_NOT_FOUND)
    {
        SPDBG_REPORT_ON_FAIL(hr);
    }

    return hr;
}

/****************************************************************************
* SpHrFromWin32 *
*---------------*
*   Description:
*       This inline function works around a basic problem with the macro
*   HRESULT_FROM_WIN32.  The macro forces the expresion in ( ) to be evaluated
*   two times.  By using this inline function, the expression will only be
*   evaluated once.
*
*   Returns:
*       HRESULT of converted Win32 error code
*
*****************************************************************************/

inline HRESULT SpHrFromWin32(DWORD dwErr)
{
    return HRESULT_FROM_WIN32(dwErr);
}


/****************************************************************************
* SpHrFromLastWin32Error *
*------------------------*
*   Description:
*       This simple inline function is used to return a converted HRESULT
*   from the Win32 function ::GetLastError.  Note that using HRESULT_FROM_WIN32
*   will evaluate the error code twice so we don't want to use:
*
*       HRESULT_FROM_WIN32(::GetLastError()) 
*
*   since that will call GetLastError twice.
*   On Win98 and WinMe ::GetLastError() returns 0 for some functions (see MSDN).
*   We therefore check for that and return E_FAIL. This function should only be
*   called in an error case since it will always return an error code!
*
*   Returns:
*       HRESULT for ::GetLastError()
*
*****************************************************************************/

inline HRESULT SpHrFromLastWin32Error()
{
    DWORD dw = ::GetLastError();
    return (dw == 0) ? E_FAIL : SpHrFromWin32(dw);
}


/****************************************************************************
* SpGetUserDefaultUILanguage *
*----------------------------*
*   Description:
*       Returns the default user interface language, using a method 
*       appropriate to the platform (Windows 9x, Windows NT, or Windows 2000)
*
*   Returns:
*       Default UI language
*
*****************************************************************************/

inline LANGID SpGetUserDefaultUILanguage(void) 
{
    HRESULT hr = S_OK;
    LANGID wUILang = 0;

    OSVERSIONINFO Osv ;
    Osv.dwOSVersionInfoSize = sizeof(Osv) ;
    if(!GetVersionEx(&Osv)) 
    {
        hr = SpHrFromLastWin32Error();
    }
    // Get the UI language by one of three methods, depending on the system
    else if(Osv.dwPlatformId != VER_PLATFORM_WIN32_NT) 
    {
        // Case 1: Running on Windows 9x. Get the system UI language from registry:
        CHAR szData[32];
        DWORD dwSize = sizeof(szData) ;
        HKEY hKey;

        long lRet = RegOpenKeyEx(
                        HKEY_USERS, 
                        _T(".Default\\Control Panel\\desktop\\ResourceLocale"), 
                        0, 
                        KEY_READ, 
                        &hKey);

#ifdef _WIN32_WCE_BUG_10655
        if (lRet == ERROR_INVALID_PARAMETER)
        {
            lRet = ERROR_FILE_NOT_FOUND;
        }
#endif // _WIN32_WCE_BUG_10655

        hr = SpHrFromWin32(lRet);

        if (SUCCEEDED(hr))
        {
            lRet = RegQueryValueEx(  
                        hKey, 
                        _T(""), 
                        NULL, 
                        NULL, 
                        (BYTE *)szData, 
                        &dwSize);

#ifdef _WIN32_WCE_BUG_10655
            if(lRet == ERROR_INVALID_PARAMETER)
            {
                lRet = ERROR_FILE_NOT_FOUND;
            }
#endif //_WIN32_WCE_BUG_10655

            hr = SpHrFromWin32(lRet); 
            ::RegCloseKey(hKey) ;
        }
        if (SUCCEEDED(hr))
        {
            // Convert string to number
            wUILang = (LANGID) strtol(szData, NULL, 16) ;
        }
    }
    else if (Osv.dwMajorVersion >= 5.0) 
    {
    // Case 2: Running on Windows 2000 or later. Use GetUserDefaultUILanguage to find 
    // the user's prefered UI language


        HMODULE hMKernel32 = ::LoadLibraryW(L"kernel32.dll") ;
        if (hMKernel32 == NULL)
        {
            hr = SpHrFromLastWin32Error();
        }
        else
        {

            LANGID (WINAPI *pfnGetUserDefaultUILanguage) () = 
                (LANGID (WINAPI *)(void)) 
#ifdef _WIN32_WCE
                    GetProcAddress(hMKernel32, L"GetUserDefaultUILanguage") ;
#else
                    GetProcAddress(hMKernel32, "GetUserDefaultUILanguage") ;
#endif

            if(NULL != pfnGetUserDefaultUILanguage) 
            {
                wUILang = pfnGetUserDefaultUILanguage() ;
            }
            else
            {   // GetProcAddress failed
                hr = SpHrFromLastWin32Error();
            }
            ::FreeLibrary(hMKernel32);
        }
    }
    else {
    // Case 3: Running on Windows NT 4.0 or earlier. Get UI language
    // from locale of .default user in registry:
    // HKEY_USERS\.DEFAULT\Control Panel\International\Locale
        
        WCHAR szData[32]   ;
        DWORD dwSize = sizeof(szData) ;
        HKEY hKey          ;

        LONG lRet = RegOpenKeyEx(HKEY_USERS, 
                                    _T(".DEFAULT\\Control Panel\\International"), 
                                    0, 
                                    KEY_READ, 
                                    &hKey);
#ifdef _WIN32_WCE_BUG_10655
            if(lRet == ERROR_INVALID_PARAMETER)
            {
                lRet = ERROR_FILE_NOT_FOUND;
            }
#endif //_WIN32_WCE_BUG_10655

        hr = SpHrFromWin32(lRet);

        if (SUCCEEDED(hr))
        {
            lRet = RegQueryValueEx(  
                        hKey, 
                        _T("Locale"),
                        NULL, 
                        NULL, 
                        (BYTE *)szData, 
                        &dwSize);

#ifdef _WIN32_WCE_BUG_10655
            if(lRet == ERROR_INVALID_PARAMETER)
            {
                lRet = ERROR_FILE_NOT_FOUND;
            }
#endif //_WIN32_WCE_BUG_10655

        hr = SpHrFromWin32(lRet);
            ::RegCloseKey(hKey);
        }

        if (SUCCEEDED(hr))
        {
            // Convert string to number
            wUILang = (LANGID) wcstol(szData, NULL, 16) ;

            if(0x0401 == wUILang || // Arabic
               0x040d == wUILang || // Hebrew
               0x041e == wUILang    // Thai
               )
            {
                // Special case these to the English UI.
                // These versions of Windows NT 4.0 were enabled only, i.e., the
                // UI was English. However, the registry setting 
                // HKEY_USERS\.DEFAULT\Control Panel\International\Locale was set  
                // to the respective locale for application compatibility.
                wUILang = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US) ;
            }
        }
    }

    return (wUILang ? wUILang : ::GetUserDefaultLangID());    // In failure case, try our best!
}


inline HRESULT SpGetDescription(ISpObjectToken * pObjToken, WCHAR ** ppszDescription, LANGID Language = SpGetUserDefaultUILanguage())
{
    WCHAR szLangId[10];
    SpHexFromUlong(szLangId, Language);
    HRESULT hr = pObjToken->GetStringValue(szLangId, ppszDescription);
    if (hr == SPERR_NOT_FOUND)
    {
        hr = pObjToken->GetStringValue(NULL, ppszDescription);
    }
    return hr;
}


inline HRESULT SpSetDescription(ISpObjectToken * pObjToken, const WCHAR * pszDescription, LANGID Language = SpGetUserDefaultUILanguage(), BOOL fSetLangIndependentId = TRUE)
{
    WCHAR szLangId[10];
    SpHexFromUlong(szLangId, Language);
    HRESULT hr = pObjToken->SetStringValue(szLangId, pszDescription);
    if (SUCCEEDED(hr) && fSetLangIndependentId)
    {
        hr = pObjToken->SetStringValue(NULL, pszDescription);
    }
    return hr;
}

/****************************************************************************
* SpConvertStreamFormatEnum *
*---------------------------*
*   Description:
*       This method converts the specified stream format into a wave format
*   structure.
*
*****************************************************************************/
inline HRESULT SpConvertStreamFormatEnum(SPSTREAMFORMAT eFormat, GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    HRESULT hr = S_OK;

    if(pFormatId==NULL || ::IsBadWritePtr(pFormatId, sizeof(*pFormatId))
        || ppCoMemWaveFormatEx==NULL || ::IsBadWritePtr(ppCoMemWaveFormatEx, sizeof(*ppCoMemWaveFormatEx)))
    {
        return E_INVALIDARG;
    }

    const GUID * pFmtGuid = &GUID_NULL;     // Assume failure case
    if( eFormat >= SPSF_8kHz8BitMono && eFormat <= SPSF_48kHz16BitStereo )
    {
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc(sizeof(WAVEFORMATEX));
        *ppCoMemWaveFormatEx = pwfex;
        if (pwfex)
        {
            DWORD dwIndex = eFormat - SPSF_8kHz8BitMono;
            BOOL bIsStereo = dwIndex & 0x1;
            BOOL bIs16 = dwIndex & 0x2;
            DWORD dwKHZ = (dwIndex & 0x3c) >> 2;
            static const DWORD adwKHZ[] = { 8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000 };
            pwfex->wFormatTag = WAVE_FORMAT_PCM;
            pwfex->nChannels = pwfex->nBlockAlign = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec = adwKHZ[dwKHZ];
            pwfex->wBitsPerSample = 8;
            if (bIs16)
            {
                pwfex->wBitsPerSample *= 2;
                pwfex->nBlockAlign *= 2;
            }
                pwfex->nAvgBytesPerSec = pwfex->nSamplesPerSec * pwfex->nBlockAlign;
            pwfex->cbSize = 0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( eFormat == SPSF_TrueSpeech_8kHz1BitMono )
    {
        int NumBytes = sizeof( WAVEFORMATEX ) + 32;
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( NumBytes );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            memset( pwfex, 0, NumBytes );
            pwfex->wFormatTag      = WAVE_FORMAT_DSPGROUP_TRUESPEECH;
            pwfex->nChannels       = 1;
            pwfex->nSamplesPerSec  = 8000;
            pwfex->nAvgBytesPerSec = 1067;
            pwfex->nBlockAlign     = 32;
            pwfex->wBitsPerSample  = 1;
            pwfex->cbSize          = 32;
            BYTE* pExtra = ((BYTE*)pwfex) + sizeof( WAVEFORMATEX );
            pExtra[0] = 1;
            pExtra[2] = 0xF0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( (eFormat >= SPSF_CCITT_ALaw_8kHzMono    ) &&
             (eFormat <= SPSF_CCITT_ALaw_44kHzStereo ) )
    {
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( sizeof(WAVEFORMATEX) );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            memset( pwfex, 0, sizeof(WAVEFORMATEX) );
            DWORD dwIndex = eFormat - SPSF_CCITT_ALaw_8kHzMono;
            DWORD dwKHZ = dwIndex / 2;
            static const DWORD adwKHZ[] = { 8000, 11025, 22050, 44100 };
            BOOL bIsStereo    = dwIndex & 0x1;
            pwfex->wFormatTag = WAVE_FORMAT_ALAW;
            pwfex->nChannels  = pwfex->nBlockAlign = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec  = adwKHZ[dwKHZ];
            pwfex->wBitsPerSample  = 8;
                pwfex->nAvgBytesPerSec = pwfex->nSamplesPerSec * pwfex->nBlockAlign;
            pwfex->cbSize          = 0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( (eFormat >= SPSF_CCITT_uLaw_8kHzMono    ) &&
             (eFormat <= SPSF_CCITT_uLaw_44kHzStereo ) )
    {
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( sizeof(WAVEFORMATEX) );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            memset( pwfex, 0, sizeof(WAVEFORMATEX) );
            DWORD dwIndex = eFormat - SPSF_CCITT_uLaw_8kHzMono;
            DWORD dwKHZ = dwIndex / 2;
            static const DWORD adwKHZ[] = { 8000, 11025, 22050, 44100 };
            BOOL bIsStereo    = dwIndex & 0x1;
            pwfex->wFormatTag = WAVE_FORMAT_MULAW;
            pwfex->nChannels  = pwfex->nBlockAlign = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec  = adwKHZ[dwKHZ];
            pwfex->wBitsPerSample  = 8;
                pwfex->nAvgBytesPerSec = pwfex->nSamplesPerSec * pwfex->nBlockAlign;
            pwfex->cbSize          = 0;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( (eFormat >= SPSF_ADPCM_8kHzMono    ) &&
             (eFormat <= SPSF_ADPCM_44kHzStereo ) )
    {
        int NumBytes = sizeof( WAVEFORMATEX ) + 32;
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( NumBytes );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            //--- Some of these values seem odd. We used what the codec told us.
            static const DWORD adwKHZ[] = { 8000, 11025, 22050, 44100 };
            static const DWORD BytesPerSec[] = { 4096, 8192, 5644, 11289, 11155, 22311, 22179, 44359 };
            static const DWORD BlockAlign[]  = { 256, 256, 512, 1024 };
            static const BYTE Extra811[32] =
            {
                0xF4, 0x01, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00,
                0x00, 0x02, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
                0xC0, 0x00, 0x40, 0x00, 0xF0, 0x00, 0x00, 0x00,
                0xCC, 0x01, 0x30, 0xFF, 0x88, 0x01, 0x18, 0xFF
            };

            static const BYTE Extra22[32] =
            {
                0xF4, 0x03, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00,
                0x00, 0x02, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
                0xC0, 0x00, 0x40, 0x00, 0xF0, 0x00, 0x00, 0x00,
                0xCC, 0x01, 0x30, 0xFF, 0x88, 0x01, 0x18, 0xFF
            };

            static const BYTE Extra44[32] =
            {
                0xF4, 0x07, 0x07, 0x00, 0x00, 0x01, 0x00, 0x00,
                0x00, 0x02, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
                0xC0, 0x00, 0x40, 0x00, 0xF0, 0x00, 0x00, 0x00,
                0xCC, 0x01, 0x30, 0xFF, 0x88, 0x01, 0x18, 0xFF
            };

            static const BYTE* Extra[4] = { Extra811, Extra811, Extra22, Extra44 };
            memset( pwfex, 0, NumBytes );
            DWORD dwIndex  = eFormat - SPSF_ADPCM_8kHzMono;
            DWORD dwKHZ    = dwIndex / 2;
            BOOL bIsStereo = dwIndex & 0x1;
            pwfex->wFormatTag      = WAVE_FORMAT_ADPCM;
            pwfex->nChannels       = (WORD)(bIsStereo ? 2 : 1);
            pwfex->nSamplesPerSec  = adwKHZ[dwKHZ];
            pwfex->nAvgBytesPerSec = BytesPerSec[dwIndex];
            pwfex->nBlockAlign     = (WORD)(BlockAlign[dwKHZ] * pwfex->nChannels);
            pwfex->wBitsPerSample  = 4;
            pwfex->cbSize          = 32;
            BYTE* pExtra = ((BYTE*)pwfex) + sizeof( WAVEFORMATEX );
            memcpy( pExtra, Extra[dwKHZ], 32 );
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if( (eFormat >= SPSF_GSM610_8kHzMono    ) &&
             (eFormat <= SPSF_GSM610_44kHzMono ) )
    {
        int NumBytes = sizeof( WAVEFORMATEX ) + 2;
        WAVEFORMATEX * pwfex = (WAVEFORMATEX *)::CoTaskMemAlloc( NumBytes );
        *ppCoMemWaveFormatEx = pwfex;
        if( pwfex )
        {
            //--- Some of these values seem odd. We used what the codec told us.
            static const DWORD adwKHZ[] = { 8000, 11025, 22050, 44100 };
            static const DWORD BytesPerSec[] = { 1625, 2239, 4478, 8957 };
            memset( pwfex, 0, NumBytes );
            DWORD dwIndex          = eFormat - SPSF_GSM610_8kHzMono;
            pwfex->wFormatTag      = WAVE_FORMAT_GSM610;
            pwfex->nChannels       = 1;
            pwfex->nSamplesPerSec  = adwKHZ[dwIndex];
            pwfex->nAvgBytesPerSec = BytesPerSec[dwIndex];
            pwfex->nBlockAlign     = 65;
            pwfex->wBitsPerSample  = 0;
            pwfex->cbSize          = 2;
            BYTE* pExtra = ((BYTE*)pwfex) + sizeof( WAVEFORMATEX );
            pExtra[0] = 0x40;
            pExtra[1] = 0x01;
            pFmtGuid = &SPDFID_WaveFormatEx;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppCoMemWaveFormatEx = NULL;
        switch (eFormat)
        {
        case SPSF_NoAssignedFormat:
            break;
        case SPSF_Text:
            pFmtGuid = &SPDFID_Text;
            break;
        default:
            hr = E_INVALIDARG;
            break;
        }
    }
    *pFormatId = *pFmtGuid;
    return hr;
}

class CSpStreamFormat
{
public:
    GUID            m_guidFormatId;
    WAVEFORMATEX  * m_pCoMemWaveFormatEx; 


    static CoMemCopyWFEX(const WAVEFORMATEX * pSrc, WAVEFORMATEX ** ppCoMemWFEX)
    {
        ULONG cb = sizeof(WAVEFORMATEX) + pSrc->cbSize;
        *ppCoMemWFEX = (WAVEFORMATEX *)::CoTaskMemAlloc(cb);
        if (*ppCoMemWFEX)
        {
            memcpy(*ppCoMemWFEX, pSrc, cb);
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }


    CSpStreamFormat()
    {
        m_guidFormatId = GUID_NULL;
        m_pCoMemWaveFormatEx = NULL;
    }

    CSpStreamFormat(SPSTREAMFORMAT eFormat, HRESULT * phr)
    {
        *phr = SpConvertStreamFormatEnum(eFormat, &m_guidFormatId, &m_pCoMemWaveFormatEx);
    }

    CSpStreamFormat(const WAVEFORMATEX * pWaveFormatEx, HRESULT * phr)
    {
        SPDBG_ASSERT(pWaveFormatEx);
        *phr = CoMemCopyWFEX(pWaveFormatEx, &m_pCoMemWaveFormatEx);
        m_guidFormatId = SUCCEEDED(*phr) ? SPDFID_WaveFormatEx : GUID_NULL;
    }

    ~CSpStreamFormat()
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
    }

    void Clear()
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;
        memset(&m_guidFormatId, 0, sizeof(m_guidFormatId));
    }

    const GUID & FormatId() const 
    {
        return m_guidFormatId;
    }

    const WAVEFORMATEX * WaveFormatExPtr() const
    {
        return m_pCoMemWaveFormatEx;
    }


    HRESULT AssignFormat(SPSTREAMFORMAT eFormat)
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);    
        return SpConvertStreamFormatEnum(eFormat, &m_guidFormatId, &m_pCoMemWaveFormatEx);
    }

    HRESULT AssignFormat(ISpStreamFormat * pStream)
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;
        return pStream->GetFormat(&m_guidFormatId, &m_pCoMemWaveFormatEx);
    }

    HRESULT AssignFormat(const WAVEFORMATEX * pWaveFormatEx)
    {
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        HRESULT hr = CoMemCopyWFEX(pWaveFormatEx, &m_pCoMemWaveFormatEx);
        m_guidFormatId = SUCCEEDED(hr) ? SPDFID_WaveFormatEx : GUID_NULL;
        return hr;
    }

    HRESULT AssignFormat(REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx)
    {
        HRESULT hr = S_OK;

        m_guidFormatId = rguidFormatId;
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;

        if (rguidFormatId == SPDFID_WaveFormatEx)
        {
            if (::IsBadReadPtr(pWaveFormatEx, sizeof(*pWaveFormatEx)))
            {
                hr = E_INVALIDARG;
            }
            else 
            {
                hr = CoMemCopyWFEX(pWaveFormatEx, &m_pCoMemWaveFormatEx);
            }

            if (FAILED(hr))
            {
                m_guidFormatId = GUID_NULL;
            }
        }

        return hr;
    }


    BOOL IsEqual(REFGUID rguidFormatId, const WAVEFORMATEX * pwfex) const
    {
        if (rguidFormatId == m_guidFormatId)
        {
            if (m_pCoMemWaveFormatEx)
            {
                if (pwfex &&
                    pwfex->cbSize == m_pCoMemWaveFormatEx->cbSize &&
                    memcmp(m_pCoMemWaveFormatEx, pwfex, sizeof(WAVEFORMATEX) + pwfex->cbSize) == 0)
                {
                    return TRUE;
                }
            }
            else
            {
                return (pwfex == NULL);
            }
        }
        return FALSE;
    }



    HRESULT ParamValidateAssignFormat(REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx, BOOL fRequireWaveFormat = FALSE)
    {
        if ((pWaveFormatEx && (::IsBadReadPtr(pWaveFormatEx, sizeof(*pWaveFormatEx)) || rguidFormatId != SPDFID_WaveFormatEx)) ||
            (fRequireWaveFormat && pWaveFormatEx == NULL))
        {
            return E_INVALIDARG;
        }
        return AssignFormat(rguidFormatId, pWaveFormatEx);
    }

    SPSTREAMFORMAT ComputeFormatEnum()
    {
        if (m_guidFormatId == GUID_NULL)
        {
            return SPSF_NoAssignedFormat;
        }
        if (m_guidFormatId == SPDFID_Text)
        {
            return SPSF_Text;
        }
        if (m_guidFormatId != SPDFID_WaveFormatEx)
        {
            return SPSF_NonStandardFormat;
        }
        //
        //  It is a WAVEFORMATEX.  Now determine which type it is and convert.
        //
        DWORD dwIndex = 0;
        switch (m_pCoMemWaveFormatEx->wFormatTag)
        {
          case WAVE_FORMAT_PCM:
          {
            switch (m_pCoMemWaveFormatEx->nChannels)
            {
              case 1:
                break;
              case 2:
                dwIndex |= 1;
                break;
              default:
                return SPSF_ExtendedAudioFormat;
            }

            switch (m_pCoMemWaveFormatEx->wBitsPerSample)
            {
              case 8:
                break;
              case 16:
                dwIndex |= 2;
                break;
              default:
                return SPSF_ExtendedAudioFormat;
            }

            switch (m_pCoMemWaveFormatEx->nSamplesPerSec)
            {
              case 48000:
                dwIndex += 4;   // Fall through
              case 44100:
                dwIndex += 4;   // Fall through
              case 32000:
                dwIndex += 4;   // Fall through
              case 24000:
                dwIndex += 4;   // Fall through
              case 22050:
                dwIndex += 4;   // Fall through
              case 16000:
                dwIndex += 4;   // Fall through
              case 12000:
                dwIndex += 4;   // Fall through
              case 11025:
                dwIndex += 4;   // Fall through
              case 8000:
                break;
              default:
                return SPSF_ExtendedAudioFormat;
            }

            return static_cast<SPSTREAMFORMAT>(SPSF_8kHz8BitMono + dwIndex);
          }

          case WAVE_FORMAT_DSPGROUP_TRUESPEECH:
          {
            return SPSF_TrueSpeech_8kHz1BitMono;
          }

          case WAVE_FORMAT_ALAW: // fall through
          case WAVE_FORMAT_MULAW:
          case WAVE_FORMAT_ADPCM:
          {
            switch (m_pCoMemWaveFormatEx->nChannels)
            {
              case 1:
                break;
              case 2:
                dwIndex |= 1;
                break;
              default:
                return SPSF_ExtendedAudioFormat;
            }

            if(m_pCoMemWaveFormatEx->wFormatTag == WAVE_FORMAT_ADPCM)
            {
                if(m_pCoMemWaveFormatEx->wBitsPerSample != 4)
                {
                    return SPSF_ExtendedAudioFormat;
                }
            }
            else if(m_pCoMemWaveFormatEx->wBitsPerSample != 8)
            {
                return SPSF_ExtendedAudioFormat;
            }

            switch (m_pCoMemWaveFormatEx->nSamplesPerSec)
            {
              case 44100:
                dwIndex += 2;   // Fall through
              case 22050:
                dwIndex += 2;   // Fall through
              case 11025:
                dwIndex += 2;   // Fall through
              case 8000:
                break;
              default:
                return SPSF_ExtendedAudioFormat;
            }

            switch( m_pCoMemWaveFormatEx->wFormatTag )
            {
              case WAVE_FORMAT_ALAW:
                return static_cast<SPSTREAMFORMAT>(SPSF_CCITT_ALaw_8kHzMono + dwIndex);
              case WAVE_FORMAT_MULAW:
                return static_cast<SPSTREAMFORMAT>(SPSF_CCITT_uLaw_8kHzMono + dwIndex);
              case WAVE_FORMAT_ADPCM:
                return static_cast<SPSTREAMFORMAT>(SPSF_ADPCM_8kHzMono + dwIndex);
            }
          }

          case WAVE_FORMAT_GSM610:
          {
            if( m_pCoMemWaveFormatEx->nChannels != 1 )
            {
                return SPSF_ExtendedAudioFormat;
            }

            switch (m_pCoMemWaveFormatEx->nSamplesPerSec)
            {
              case 44100:
                dwIndex = 3;
                break;
              case 22050:
                dwIndex = 2;
                break;
              case 11025:
                dwIndex = 1;
                break;
              case 8000:
                dwIndex = 0;
                break;
              default:
                return SPSF_ExtendedAudioFormat;
            }

            return static_cast<SPSTREAMFORMAT>(SPSF_GSM610_8kHzMono + dwIndex);
          }

          default:
            return SPSF_ExtendedAudioFormat;
            break;
        }
    }

    void DetachTo(CSpStreamFormat & Other)
    {
        ::CoTaskMemFree(Other.m_pCoMemWaveFormatEx);
        Other.m_guidFormatId = m_guidFormatId;
        Other.m_pCoMemWaveFormatEx = m_pCoMemWaveFormatEx;
        m_pCoMemWaveFormatEx = NULL;
        memset(&m_guidFormatId, 0, sizeof(m_guidFormatId));
    }

    void DetachTo(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
    {
        *pFormatId = m_guidFormatId;
        *ppCoMemWaveFormatEx = m_pCoMemWaveFormatEx;
        m_pCoMemWaveFormatEx = NULL;
        memset(&m_guidFormatId, 0, sizeof(m_guidFormatId));
    }

    HRESULT CopyTo(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWFEX) const
    {
        HRESULT hr = S_OK;
        *pFormatId = m_guidFormatId;
        if (m_pCoMemWaveFormatEx)
        {
            hr = CoMemCopyWFEX(m_pCoMemWaveFormatEx, ppCoMemWFEX);
            if (FAILED(hr))
            {
                memset(pFormatId, 0, sizeof(*pFormatId));
            }
        }
        else
        {
            *ppCoMemWFEX = NULL;
        }
        return hr;
    }

    HRESULT CopyTo(CSpStreamFormat & Other) const
    {
        ::CoTaskMemFree(Other.m_pCoMemWaveFormatEx);
        return CopyTo(&Other.m_guidFormatId, &Other.m_pCoMemWaveFormatEx);
    }
    
    HRESULT AssignFormat(const CSpStreamFormat & Src)
    {
        return Src.CopyTo(*this);
    }


    HRESULT ParamValidateCopyTo(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWFEX) const
    {
        if (::IsBadWritePtr(pFormatId, sizeof(*pFormatId)) ||
            ::IsBadWritePtr(ppCoMemWFEX, sizeof(*ppCoMemWFEX)))
        {
            return E_POINTER;
        }
        return CopyTo(pFormatId, ppCoMemWFEX);
    }

    BOOL operator==(const CSpStreamFormat & Other) const
    {
        return IsEqual(Other.m_guidFormatId, Other.m_pCoMemWaveFormatEx);
    }
    BOOL operator!=(const CSpStreamFormat & Other) const
    {
        return !IsEqual(Other.m_guidFormatId, Other.m_pCoMemWaveFormatEx);
    }

    ULONG SerializeSize() const
    {
        ULONG cb = sizeof(ULONG) + sizeof(m_guidFormatId);
        if (m_pCoMemWaveFormatEx)
        {
            cb += sizeof(WAVEFORMATEX) + m_pCoMemWaveFormatEx->cbSize + 3;  // Add 3 to round up
            cb -= cb % 4;                                                   // Round to DWORD
        }
        return cb;
    }

    ULONG Serialize(BYTE * pBuffer) const
    {
        ULONG cb = SerializeSize();
        *((UNALIGNED ULONG *)pBuffer) = cb;
        pBuffer += sizeof(ULONG);
        *((UNALIGNED GUID *)pBuffer) = m_guidFormatId;
        if (m_pCoMemWaveFormatEx)
        {
            pBuffer += sizeof(m_guidFormatId);
            memcpy(pBuffer, m_pCoMemWaveFormatEx, sizeof(WAVEFORMATEX) + m_pCoMemWaveFormatEx->cbSize);
        }
        return cb;
    }

    HRESULT Deserialize(const BYTE * pBuffer, ULONG * pcbUsed)
    {
        HRESULT hr = S_OK;
        ::CoTaskMemFree(m_pCoMemWaveFormatEx);
        m_pCoMemWaveFormatEx = NULL;
        *pcbUsed = *((UNALIGNED ULONG *)pBuffer);
        pBuffer += sizeof(ULONG);
        // Misaligment exception is generated for SHx platform.
        // Marking pointer as UNALIGNED does not help.
#ifndef _WIN32_WCE
        m_guidFormatId = *((UNALIGNED GUID *)pBuffer);
#else
        memcpy(&m_guidFormatId, pBuffer, sizeof(GUID));
#endif
        if (*pcbUsed > sizeof(GUID) + sizeof(ULONG))
        {
            pBuffer += sizeof(m_guidFormatId);
            hr = CoMemCopyWFEX((const WAVEFORMATEX *)pBuffer, &m_pCoMemWaveFormatEx);
            if (FAILED(hr))
            {
                m_guidFormatId = GUID_NULL;
            }
        }
        return hr;
    }

};



// Return the default codepage given a LCID.
// Note some of the newer locales do not have associated Windows codepages.  For these, we return UTF-8.

inline UINT SpCodePageFromLcid(LCID lcid)
{
    char achCodePage[6];

    return (0 != GetLocaleInfoA(lcid, LOCALE_IDEFAULTANSICODEPAGE, achCodePage, sizeof(achCodePage))) ? atoi(achCodePage) : 65001;
}


inline HRESULT SPBindToFile( LPCWSTR pFileName, SPFILEMODE eMode, ISpStream ** ppStream,
                            const GUID * pFormatId = NULL, const WAVEFORMATEX * pWaveFormatEx = NULL,
                            ULONGLONG ullEventInterest = SPFEI_ALL_EVENTS)
{
    HRESULT hr = ::CoCreateInstance(CLSID_SpStream, NULL, CLSCTX_ALL, __uuidof(*ppStream), (void **)ppStream);
    if (SUCCEEDED(hr))
    {
        hr = (*ppStream)->BindToFile(pFileName, eMode, pFormatId, pWaveFormatEx, ullEventInterest);
        if (FAILED(hr))
        {
            (*ppStream)->Release();
            *ppStream = NULL;
        }
    }
    return hr;
} /* SPBindToFile */

#ifndef _UNICODE
inline HRESULT SPBindToFile( const TCHAR * pFileName, SPFILEMODE eMode, ISpStream** ppStream, 
                             const GUID * pFormatId = NULL, const WAVEFORMATEX * pWaveFormatEx = NULL,
                             ULONGLONG ullEventInterest = SPFEI_ALL_EVENTS)
{
    WCHAR szWcharFileName[MAX_PATH];
    ::MultiByteToWideChar(CP_ACP, 0, pFileName, -1, szWcharFileName, sp_countof(szWcharFileName));
    return SPBindToFile(szWcharFileName, eMode, ppStream, pFormatId, pWaveFormatEx, ullEventInterest);
}
#endif

/****************************************************************************
* SpClearEvent *
*--------------*
*   Description:
*       Helper function that can be used by clients that do not use the CSpEvent
*   class.
*
*   Returns:
*
*****************************************************************************/

inline void SpClearEvent(SPEVENT * pe)
{
    if( pe->elParamType != SPEI_UNDEFINED)
    {
        if( pe->elParamType == SPET_LPARAM_IS_POINTER ||
            pe->elParamType == SPET_LPARAM_IS_STRING)
        {
            ::CoTaskMemFree((void *)pe->lParam);
        }
        else if (pe->elParamType == SPET_LPARAM_IS_TOKEN ||
               pe->elParamType == SPET_LPARAM_IS_OBJECT)
        {
            ((IUnknown*)pe->lParam)->Release();
        }
    }
    memset(pe, 0, sizeof(*pe));
}

/****************************************************************************
* SpInitEvent *
*-------------*
*   Description:
*
*   Returns:
*
*****************************************************************************/

inline void SpInitEvent(SPEVENT * pe)
{
    memset(pe, 0, sizeof(*pe));
}

/****************************************************************************
* SpEventSerializeSize *
*----------------------*
*   Description:
*       Computes the required size of a buffer to serialize an event.  The caller
*   must specify which type of serialized event is desired -- either SPSERIALIZEDEVENT
*   or SPSERIALIZEDEVENT64.    
*
*   Returns:
*       Size in bytes required to seriailze the event.
*
****************************************************************************/

// WCE compiler does not work propertly with template
#ifndef _WIN32_WCE
template <class T>
inline ULONG SpEventSerializeSize(const SPEVENT * pEvent)

{
    ULONG ulSize = sizeof(T);

#else

inline ULONG SpEventSerializeSize(const SPEVENT * pEvent, ULONG ulSize)
{
#endif //_WIN32_WCE

    if( ( pEvent->elParamType == SPET_LPARAM_IS_POINTER ) && pEvent->lParam )
    {
        ulSize += ULONG(pEvent->wParam);
    }
    else if ((pEvent->elParamType == SPET_LPARAM_IS_STRING) && pEvent->lParam != NULL)
    {
        ulSize += (wcslen((WCHAR*)pEvent->lParam) + 1) * sizeof( WCHAR );
    }
    else if( pEvent->elParamType == SPET_LPARAM_IS_TOKEN )
    {
        CSpDynamicString dstrObjectId;
        if( ((ISpObjectToken*)(pEvent->lParam))->GetId( &dstrObjectId ) == S_OK )
        {
            ulSize += (dstrObjectId.Length() + 1) * sizeof( WCHAR );
        }
    }
    // Round up to nearest DWORD
    ulSize += 3;
    ulSize -= ulSize % 4;
    return ulSize;
}

/****************************************************************************
* SpSerializedEventSize *
*-----------------------*
*   Description:
*       Returns the size, in bytes, used by a serialized event.  The caller can
*   pass a pointer to either a SPSERIAILZEDEVENT or SPSERIALIZEDEVENT64 structure.
*
*   Returns:
*       Number of bytes used by serizlied event
*
********************************************************************* RAL ***/

// WCE compiler does not work propertly with template
#ifndef _WIN32_WCE
template <class T>
inline ULONG SpSerializedEventSize(const T * pSerEvent)
{
    ULONG ulSize = sizeof(T);

    if( ( pSerEvent->elParamType == SPET_LPARAM_IS_POINTER ) && pSerEvent->SerializedlParam )
    {
        ulSize += ULONG(pSerEvent->SerializedwParam);
    }
    else if ((pSerEvent->elParamType == SPET_LPARAM_IS_STRING || pSerEvent->elParamType == SPET_LPARAM_IS_TOKEN) &&
             pSerEvent->SerializedlParam != NULL)
    {
        ulSize += (wcslen((WCHAR*)(pSerEvent + 1)) + 1) * sizeof( WCHAR );
    }
    // Round up to nearest DWORD
    ulSize += 3;
    ulSize -= ulSize % 4;
    return ulSize;
}

#else //_WIN32_WCE

inline ULONG SpSerializedEventSize(const SPSERIALIZEDEVENT * pSerEvent, ULONG ulSize)
{
    if( ( pSerEvent->elParamType == SPET_LPARAM_IS_POINTER ) && pSerEvent->SerializedlParam )
    {
        ulSize += ULONG(pSerEvent->SerializedwParam);
    }
    else if ((pSerEvent->elParamType == SPET_LPARAM_IS_STRING || pSerEvent->elParamType == SPET_LPARAM_IS_TOKEN) &&
             pSerEvent->SerializedlParam != NULL)
    {
        ulSize += (wcslen((WCHAR*)(pSerEvent + 1)) + 1) * sizeof( WCHAR );
    }
    // Round up to nearest DWORD
    ulSize += 3;
    ulSize -= ulSize % 4;
    return ulSize;
}

inline ULONG SpSerializedEventSize(const SPSERIALIZEDEVENT64 * pSerEvent, ULONG ulSize)
{
    if( ( pSerEvent->elParamType == SPET_LPARAM_IS_POINTER ) && pSerEvent->SerializedlParam )
    {
        ulSize += ULONG(pSerEvent->SerializedwParam);
    }
    else if ((pSerEvent->elParamType == SPET_LPARAM_IS_STRING || pSerEvent->elParamType == SPET_LPARAM_IS_TOKEN) &&
             pSerEvent->SerializedlParam != NULL)
    {
        ulSize += (wcslen((WCHAR*)(pSerEvent + 1)) + 1) * sizeof( WCHAR );
    }
    // Round up to nearest DWORD
    ulSize += 3;
    ulSize -= ulSize % 4;
    return ulSize;
}

#endif //_WIN32_WCE

/*** CSpEvent helper class
*
*/
class CSpEvent : public SPEVENT
{
public:
    CSpEvent()
    {
        SpInitEvent(this);
    }
    ~CSpEvent()
    {
        SpClearEvent(this);
    }
    // If you need to take the address of a CSpEvent that is not const, use the AddrOf() method
    // which will do debug checking of parameters.  If you encounter this problem when calling
    // GetEvents from an event source, you may want to use the GetFrom() method of this class.
    const SPEVENT * operator&()
        {
                return this;
        }
    CSpEvent * AddrOf()
    {
        // Note:  This method does not ASSERT since we assume the caller knows what they are doing.
        return this;
    }
    void Clear()
    {
        SpClearEvent(this);
    }
    HRESULT CopyTo(SPEVENT * pDestEvent) const
    {
        memcpy(pDestEvent, this, sizeof(*pDestEvent));
        if ((elParamType == SPET_LPARAM_IS_POINTER) && lParam)
        {
            SPDBG_ASSERT(wParam && (wParam < 0x100000));    // this is too big!
            pDestEvent->lParam = (LPARAM)::CoTaskMemAlloc(wParam);
            if (pDestEvent->lParam)
            {
                memcpy((void *)pDestEvent->lParam, (void *)lParam, wParam);
            }
            else
            {
                pDestEvent->eEventId = SPEI_UNDEFINED;
                return E_OUTOFMEMORY;
            }
        }
        else if (elParamType == SPET_LPARAM_IS_STRING && lParam != NULL)
        {
            pDestEvent->lParam = (LPARAM)::CoTaskMemAlloc((wcslen((WCHAR*)lParam) + 1) * sizeof(WCHAR));
            if (pDestEvent->lParam)
            {
                wcscpy((WCHAR*)pDestEvent->lParam, (WCHAR*)lParam);
            }
            else
            {
                pDestEvent->eEventId = SPEI_UNDEFINED;
                return E_OUTOFMEMORY;
            }
        }
        else if (elParamType == SPET_LPARAM_IS_TOKEN ||
               elParamType == SPET_LPARAM_IS_OBJECT)
        {
            ((IUnknown*)lParam)->AddRef();
        }
        return S_OK;
    }

    HRESULT GetFrom(ISpEventSource * pEventSrc)
    {
        SpClearEvent(this);
        return pEventSrc->GetEvents(1, this, NULL);
    }
    HRESULT CopyFrom(const SPEVENT * pSrcEvent)
    {
        SpClearEvent(this);
        return static_cast<const CSpEvent *>(pSrcEvent)->CopyTo(this);
    }
    void Detach(SPEVENT * pDestEvent = NULL)
    {
        if (pDestEvent)
        {
            memcpy(pDestEvent, this, sizeof(*pDestEvent));
        }
        memset(this, 0, sizeof(*this));
    }

    template <class T>
    ULONG SerializeSize() const
    {
        return SpEventSerializeSize<T>(this);
    }

    // Call this method with either SPSERIALIZEDEVENT or SPSERIALIZEDEVENT64
    template <class T>
    void Serialize(T * pSerEvent) const
    {
        SPDBG_ASSERT(elParamType != SPET_LPARAM_IS_OBJECT);
        pSerEvent->eEventId = this->eEventId;
        pSerEvent->elParamType = this->elParamType;
        pSerEvent->ulStreamNum = this->ulStreamNum;
        pSerEvent->ullAudioStreamOffset = this->ullAudioStreamOffset;
        pSerEvent->SerializedwParam = static_cast<ULONG>(this->wParam);
        pSerEvent->SerializedlParam = static_cast<LONG>(this->lParam);
        if (lParam)
        {
            switch(elParamType)
            {
            case SPET_LPARAM_IS_POINTER:
                memcpy(pSerEvent + 1, (void *)lParam, wParam);
                pSerEvent->SerializedlParam = sizeof(T);
                break;

            case SPET_LPARAM_IS_STRING:
                wcscpy((WCHAR *)(pSerEvent + 1), (WCHAR*)lParam);
                pSerEvent->SerializedlParam = sizeof(T);
                break;

            case SPET_LPARAM_IS_TOKEN:
                {
                    CSpDynamicString dstrObjectId;
                    if( SUCCEEDED( ((ISpObjectToken*)lParam)->GetId( &dstrObjectId ) ) )
                    {
                        pSerEvent->SerializedwParam = (dstrObjectId.Length() + 1) * sizeof( WCHAR );;
                        memcpy( pSerEvent + 1, (void *)dstrObjectId.m_psz, static_cast<ULONG>(pSerEvent->SerializedwParam) );
                    }
                    pSerEvent->SerializedlParam = sizeof(T);
                }
                break;

            default:
                break;
            }
        }
    }

    template <class T>
    HRESULT Serialize(T ** ppCoMemSerEvent, ULONG * pcbSerEvent) const 
    {
// WCE compiler does not work propertly with template
#ifndef _WIN32_WCE
        *pcbSerEvent = SpEventSerializeSize<T>(this);
#else
        *pcbSerEvent = SpEventSerializeSize(this, sizeof(** ppCoMemSerEvent));
#endif
        *ppCoMemSerEvent = (T *)::CoTaskMemAlloc(*pcbSerEvent);
        if (*ppCoMemSerEvent)
        {
            Serialize(*ppCoMemSerEvent);
            return S_OK;
        }
        else
        {
            *pcbSerEvent = 0;
            return E_OUTOFMEMORY;
        }
    }


    // Call this method with either SPSERIALIZEDEVENT or SPSERIALIZEDEVENT64
    template <class T>
    HRESULT Deserialize(const T * pSerEvent, ULONG * pcbUsed = NULL)
    {
        Clear();
        HRESULT hr = S_OK;
        const UNALIGNED T * pTemp = pSerEvent;
        this->eEventId = pTemp->eEventId;
        this->elParamType = pTemp->elParamType;
        this->ulStreamNum = pTemp->ulStreamNum;
        this->ullAudioStreamOffset = pTemp->ullAudioStreamOffset;
        this->wParam = static_cast<WPARAM>(pTemp->SerializedwParam);
        this->lParam = static_cast<LPARAM>(pTemp->SerializedlParam);
        if (pTemp->SerializedlParam)
        {
            ULONG cbAlloc = 0;
            switch (pTemp->elParamType)
            {
            case SPET_LPARAM_IS_POINTER:
                cbAlloc = static_cast<ULONG>(wParam);
                break;

            case SPET_LPARAM_IS_STRING:
                cbAlloc = sizeof(WCHAR) * (1 + wcslen((const WCHAR *)(pTemp + 1)));
                break;

            case SPET_LPARAM_IS_TOKEN:
                {
                    ULONG ulDataOffset = ULONG(lParam);
                    hr = SpGetTokenFromId( (const WCHAR*)(pTemp + 1),
                                                  (ISpObjectToken **)&lParam );
                    wParam = 0;
                }
                break;
            }
            if (cbAlloc)
            {
                void * pvBuff = ::CoTaskMemAlloc(cbAlloc);
                this->lParam = (LPARAM)pvBuff;
                if (pvBuff)
                {
                    memcpy(pvBuff, pTemp + 1, cbAlloc);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if( SUCCEEDED( hr ) && pcbUsed )
        {
// WCE compiler does not work propertly with template
#ifndef _WIN32_WCE
            *pcbUsed = SpEventSerializeSize<T>(this);
#else
            *pcbUsed = SpEventSerializeSize(this, sizeof(*pTemp));
#endif
        }
        return hr;
    }

    //
    //  Helpers for access to events.  Performs run-time checks in debug and casts
    //  data to the appropriate types
    //
    SPPHONEID Phoneme() const 
    {
        SPDBG_ASSERT(eEventId == SPEI_PHONEME);
        return (SPPHONEID)LOWORD(lParam);
    }
    SPVISEMES Viseme() const 
    {
        SPDBG_ASSERT(eEventId == SPEI_VISEME);
        return (SPVISEMES)LOWORD(lParam);
    }
    ULONG InputWordPos() const
    {
        SPDBG_ASSERT(eEventId == SPEI_WORD_BOUNDARY);
        return ULONG(lParam);
    }
    ULONG InputWordLen() const 
    {
        SPDBG_ASSERT(eEventId == SPEI_WORD_BOUNDARY);
        return ULONG(wParam);
    }
    ULONG InputSentPos() const
    {
        SPDBG_ASSERT(eEventId == SPEI_SENTENCE_BOUNDARY);
        return ULONG(lParam);
    }
    ULONG InputSentLen() const 
    {
        SPDBG_ASSERT(eEventId == SPEI_SENTENCE_BOUNDARY);
        return ULONG(wParam);
    }
    ISpObjectToken * ObjectToken() const
    {
        SPDBG_ASSERT(elParamType == SPET_LPARAM_IS_TOKEN);
        return (ISpObjectToken *)lParam;
    }
    ISpObjectToken * VoiceToken() const     // More explicit check than ObjectToken()
    {
        SPDBG_ASSERT(eEventId == SPEI_VOICE_CHANGE);
        return ObjectToken();
    }
    BOOL PersistVoiceChange() const
    {
        SPDBG_ASSERT(eEventId == SPEI_VOICE_CHANGE);
        return (BOOL)wParam;
    }
    IUnknown * Object() const
    {
        SPDBG_ASSERT(elParamType == SPET_LPARAM_IS_OBJECT);
        return (IUnknown*)lParam;
    }
    ISpRecoResult * RecoResult() const
    {
        SPDBG_ASSERT(eEventId == SPEI_RECOGNITION || eEventId == SPEI_FALSE_RECOGNITION || eEventId == SPEI_HYPOTHESIS);
        return (ISpRecoResult *)Object();
    }
    BOOL IsPaused()
    {
        SPDBG_ASSERT(eEventId == SPEI_RECOGNITION || eEventId == SPEI_SR_BOOKMARK);
        return (BOOL)(wParam & SPREF_AutoPause);
    }
    BOOL IsEmulated()
    {
        SPDBG_ASSERT(eEventId == SPEI_RECOGNITION);
        return (BOOL)(wParam & SPREF_Emulated);
    }
    const WCHAR * String() const
    {
        SPDBG_ASSERT(elParamType == SPET_LPARAM_IS_STRING);
        return (const WCHAR*)lParam;
    }
    const WCHAR * BookmarkName() const
    {
        SPDBG_ASSERT(eEventId == SPEI_TTS_BOOKMARK);
        return String();
    }
    const WCHAR * RequestTypeOfUI() const
    {
        SPDBG_ASSERT(eEventId == SPEI_REQUEST_UI);
        return String();
    }
    SPRECOSTATE RecoState() const
    {
        SPDBG_ASSERT(eEventId == SPEI_RECO_STATE_CHANGE);
        return static_cast<SPRECOSTATE>(wParam);
    }
    const WCHAR * PropertyName() const
    {
        SPDBG_ASSERT((eEventId == SPEI_PROPERTY_NUM_CHANGE && elParamType == SPET_LPARAM_IS_STRING) ||
                     (eEventId == SPEI_PROPERTY_STRING_CHANGE && elParamType == SPET_LPARAM_IS_POINTER));
        // Note: Don't use String() method here since in the case of string attributes, the elParamType
        // field specifies LPARAM_IS_POINTER, but the attribute name IS the first string in this buffer
        return (const WCHAR*)lParam;
    }
    const LONG PropertyNumValue() const 
    {
        SPDBG_ASSERT(eEventId == SPEI_PROPERTY_NUM_CHANGE);
        return static_cast<LONG>(wParam);
    }
    const WCHAR * PropertyStringValue() const
    {
        // Search for the first NULL and return pointer to the char past it.
        SPDBG_ASSERT(eEventId == SPEI_PROPERTY_STRING_CHANGE);
        for (const WCHAR * psz = (const WCHAR *)lParam; *psz; psz++) {}
        return psz + 1;
    }
    SPINTERFERENCE Interference() const
    {
        SPDBG_ASSERT(eEventId == SPEI_INTERFERENCE);
        return static_cast<SPINTERFERENCE>(lParam);
    }
    HRESULT EndStreamResult() const
    {
        SPDBG_ASSERT(eEventId == SPEI_END_SR_STREAM);
        return static_cast<HRESULT>(lParam);
    }
    BOOL InputStreamReleased() const
    {
        SPDBG_ASSERT(eEventId == SPEI_END_SR_STREAM);
        return (wParam & SPESF_STREAM_RELEASED) ? TRUE : FALSE;
    }
};

class CSpPhrasePtr
{
public:
    SPPHRASE    *   m_pPhrase;
    CSpPhrasePtr() : m_pPhrase(NULL) {}
    CSpPhrasePtr(ISpPhrase * pPhraseObj, HRESULT * phr)
    {
        *phr = pPhraseObj->GetPhrase(&m_pPhrase);
    }
    ~CSpPhrasePtr()
    {
        ::CoTaskMemFree(m_pPhrase);
    }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the m_pPhrase member explicitly.
        SPPHRASE ** operator&()
        {
            SPDBG_ASSERT(m_pPhrase == NULL);
            return &m_pPhrase;
        }
    operator SPPHRASE *() const
    {
        return m_pPhrase;
    }
        SPPHRASE & operator*() const
        {
                SPDBG_ASSERT(m_pPhrase);
                return *m_pPhrase;
        }
    SPPHRASE * operator->() const
    {
        return m_pPhrase;
    }
        bool operator!() const
        {
                return (m_pPhrase == NULL);
        }
    void Clear()
    {
        if (m_pPhrase)
        {
            ::CoTaskMemFree(m_pPhrase);
            m_pPhrase = NULL;
        }
    }
    HRESULT GetFrom(ISpPhrase * pPhraseObj)
    {
        Clear();
        return pPhraseObj->GetPhrase(&m_pPhrase);
    }
};


template <class T>
class CSpCoTaskMemPtr
{
public:
    T       * m_pT;
    CSpCoTaskMemPtr() : m_pT(NULL) {}
    CSpCoTaskMemPtr(void * pv) : m_pT((T *)pv) {}
    CSpCoTaskMemPtr(ULONG cElements, HRESULT * phr)
    {
        m_pT = (T *)::CoTaskMemAlloc(cElements * sizeof(T));
        *phr = m_pT ? S_OK : E_OUTOFMEMORY;
    }
    ~CSpCoTaskMemPtr()
    {
        ::CoTaskMemFree(m_pT);
    }
    void Clear()
    {
        if (m_pT)
        {
            ::CoTaskMemFree(m_pT);
            m_pT = NULL;
        }
    }
    HRESULT Alloc(ULONG cArrayElements = 1)
    {
        m_pT = (T *)::CoTaskMemRealloc(m_pT, sizeof(T) * cArrayElements);
        SPDBG_ASSERT(m_pT);
        return (m_pT ? S_OK : E_OUTOFMEMORY);
    }
    void Attach(void * pv)
    {
        Clear();
        m_pT = (T *)pv;
    }
    T * Detatch()
    {
        T * pT = m_pT;
        m_pT = NULL;
        return pT;
    }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the m_pT member explicitly.
        T ** operator&()
        {
        SPDBG_ASSERT(m_pT == NULL);
                return &m_pT;
        }
    T * operator->()
    {
        SPDBG_ASSERT(m_pT != NULL);
        return m_pT;
    }
    operator T *()
    {
        return m_pT;
    }
        bool operator!() const
        {
                return (m_pT == NULL);
        }
};

/**** Helper function used to create a new phrase object from an array of
    test words. Each word in the string is converted to a phrase element.
    This is useful to create a phrase to pass to the EmulateRecognition method.
    The method can convert standard words as well as words with the
    "/display_text/lexical_form/pronounciation;" word format.
    You can also specify the DisplayAttributes for each element if desired. 
    If prgDispAttribs is NULL then the DisplayAttribs for each element default to 
    SPAF_ONE_TRAILING_SPACE. ****/
inline HRESULT CreatePhraseFromWordArray(const WCHAR ** ppWords, ULONG cWords,
                             SPDISPLYATTRIBUTES * prgDispAttribs,
                             ISpPhraseBuilder **ppResultPhrase,
                             LANGID LangId = 0,
                             CComPtr<ISpPhoneConverter> cpPhoneConv = NULL)
{
    SPDBG_FUNC("CreatePhraseFromWordArray");
    HRESULT hr = S_OK;

    if ( cWords == 0 || ppWords == NULL || ::IsBadReadPtr(ppWords, sizeof(*ppWords) * cWords ) )
    {
        return E_INVALIDARG;
    }

    if ( prgDispAttribs != NULL && ::IsBadReadPtr(prgDispAttribs, sizeof(*prgDispAttribs) * cWords ) )
    {
        return E_INVALIDARG;
    }

    ULONG    cTotalChars = 0;
    ULONG    i;
    WCHAR** pStringPtrArray = (WCHAR**)::CoTaskMemAlloc( cWords * sizeof(WCHAR *));
    if ( !pStringPtrArray )
    {
        return E_OUTOFMEMORY;
    }
    for (i = 0; i < cWords; i++)
    {
        cTotalChars += wcslen(ppWords[i])+1;
    }

    CSpDynamicString dsText(cTotalChars);
    if(dsText.m_psz == NULL)
    {
        ::CoTaskMemFree(pStringPtrArray);
        return E_OUTOFMEMORY;
    }
    CSpDynamicString dsPhoneId(cTotalChars);
    if(dsPhoneId.m_psz == NULL)
    {
        ::CoTaskMemFree(pStringPtrArray);
        return E_OUTOFMEMORY;
    }
    SPPHONEID* pphoneId = dsPhoneId;

    SPPHRASE Phrase;
    memset(&Phrase, 0, sizeof(Phrase));
    Phrase.cbSize = sizeof(Phrase);

    if(LangId == 0)
    {
        LangId = SpGetUserDefaultUILanguage();
    }

    if(cpPhoneConv == NULL)
    {
        hr = SpCreatePhoneConverter(LangId, NULL, NULL, &cpPhoneConv);
        if(FAILED(hr))
        {
            ::CoTaskMemFree(pStringPtrArray);
            return hr;
        }
    }

    SPPHRASEELEMENT *pPhraseElement = new SPPHRASEELEMENT[cWords];
    if(pPhraseElement == NULL)
    {
        ::CoTaskMemFree(pStringPtrArray);
        return E_OUTOFMEMORY;
    }
    memset(pPhraseElement, 0, sizeof(SPPHRASEELEMENT) * cWords); // !!!
    
    WCHAR * pText = dsText;
    for (i = 0; SUCCEEDED(hr) && i < cWords; i++)
    {
        WCHAR *p = pText;
        pStringPtrArray[i] = pText;
        wcscpy( pText, ppWords[i] );
        pText += wcslen( p ) + 1;

        if (*p == L'/')
        {
            //This is a compound word
            WCHAR* pszFirstPart = ++p;
            WCHAR* pszSecondPart = NULL;
            WCHAR* pszThirdPart = NULL;

            while (*p && *p != L'/')
            {
                p++;
            }
            if (*p == L'/')
            {
                //It means we stop at the second '/'
                *p = L'\0';
                pszSecondPart = ++p;
                while (*p && *p != L'/')
                {
                    p++;
                }
                if (*p == L'/')
                {
                    //It means we stop at the third '/'
                    *p = L'\0';
                    pszThirdPart = ++p;
                }
            }

            pPhraseElement[i].pszDisplayText = pszFirstPart;
            pPhraseElement[i].pszLexicalForm = pszSecondPart ? pszSecondPart : pszFirstPart;

            if ( pszThirdPart)
            {
                hr = cpPhoneConv->PhoneToId(pszThirdPart, pphoneId);
                if (SUCCEEDED(hr))
                {
                    pPhraseElement[i].pszPronunciation = pphoneId;
                    pphoneId += wcslen(pphoneId) + 1;
                }
            }
        }
        else
        {
            //It is the simple format, only have one form, use it for everything.
            pPhraseElement[i].pszDisplayText = NULL;
            pPhraseElement[i].pszLexicalForm = p;
            pPhraseElement[i].pszPronunciation = NULL;
        }

        pPhraseElement[i].bDisplayAttributes = (BYTE)(prgDispAttribs ? prgDispAttribs[i] : SPAF_ONE_TRAILING_SPACE);
        pPhraseElement[i].RequiredConfidence = SP_NORMAL_CONFIDENCE;
        pPhraseElement[i].ActualConfidence =  SP_NORMAL_CONFIDENCE;
    }

    Phrase.Rule.ulCountOfElements = cWords;
    Phrase.pElements = pPhraseElement;
    Phrase.LangID = LangId;

    CComPtr<ISpPhraseBuilder> cpPhrase;
    if (SUCCEEDED(hr))
    {
        hr = cpPhrase.CoCreateInstance(CLSID_SpPhraseBuilder);
    }

    if (SUCCEEDED(hr))
    {
        hr = cpPhrase->InitFromPhrase(&Phrase);
    }
    if (SUCCEEDED(hr))
    {
        *ppResultPhrase = cpPhrase.Detach();
    }

    delete pPhraseElement;
    ::CoTaskMemFree(pStringPtrArray);

    return hr;
}

/**** Helper function used to create a new phrase object from a 
    test string. Each word in the string is converted to a phrase element.
    This is useful to create a phrase to pass to the EmulateRecognition method.
    The method can convert standard words as well as words with the
    "/display_text/lexical_form/pronounciation;" word format ****/
inline HRESULT CreatePhraseFromText(const WCHAR *pszOriginalText,
                             ISpPhraseBuilder **ppResultPhrase,
                             LANGID LangId = 0,
                             CComPtr<ISpPhoneConverter> cpPhoneConv = NULL)
{
    SPDBG_FUNC("CreatePhraseFromText");
    HRESULT hr = S_OK;

    //We first trim the input text
    CSpDynamicString dsText(pszOriginalText);
    if(dsText.m_psz == NULL)
    {
        return E_OUTOFMEMORY;
    }
    dsText.TrimBoth();

    ULONG cWords = 0;
    BOOL fInCompoundword = FALSE;

    // Set first array pointer (if *p).
    WCHAR *p = dsText;
    while (*p)
    {
        if( iswspace(*p) && !fInCompoundword)
        {
            cWords++;
            *p++ = L'\0';
            while (*p && iswspace(*p))
            {
                *p++ = L'\0';
            }
            // Add new array pointer.  Use vector.
        }
        else if (*p == L'/' && !fInCompoundword)
        {
            fInCompoundword = TRUE;
        }
        else if (*p == L';' && fInCompoundword)
        {
            fInCompoundword = FALSE;
            *p++ = L'\0';
            // Add new array element.
        }
        else
        {
            p++;
        }
    }

    cWords++;

    WCHAR** pStringPtrArray = (WCHAR**)::CoTaskMemAlloc( cWords * sizeof(WCHAR *));
    if ( !pStringPtrArray )
    {
        hr = E_OUTOFMEMORY;
    }

    if ( SUCCEEDED( hr ) )
    {
        p = dsText;
        for (ULONG i=0; i<cWords; i++)
        {
            pStringPtrArray[i] = p;
            p += wcslen(p)+1;
        }

        hr = CreatePhraseFromWordArray((const WCHAR **)pStringPtrArray, cWords, NULL, ppResultPhrase, LangId, cpPhoneConv);

        ::CoTaskMemFree(pStringPtrArray);
    }
    return hr;
}

#endif /* This must be the last line in the file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\chs\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by itngram_chs.rc
//
#define IDS_PROJNAME                    100
#define IDR_TESTITN_CHS                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\chs\makefile.inc ===
# Rules for compiling .cfgs from .xmls
# could these be moved into common.inc?
.SUFFIXES: .cfg .h .xml

$(O)\_common.ver: verconv.pl $(SDK_INC_PATH)\common.ver
    perl -n $** > $@

.xml{$(O)}.cfg:
    copy $** $(O)
	$(SPEECH_ROOT)\sapi\tools\bin\gc.exe -h $*.h $*.xml

!if defined(MAKEDLL)
# Self-register
itngram_chs.cpy: $(O)\itngram.dll
    regsvr32 /s $** > $@
!else
itngram_chs.cpy:
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\chs\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__42E0F13B_11FD_11D3_BB97_00C04F8EE6C0__INCLUDED_)
#define AFX_STDAFX_H__42E0F13B_11FD_11D3_BB97_00C04F8EE6C0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "sapi.h"
#include "sphelper.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__42E0F13B_11FD_11D3_BB97_00C04F8EE6C0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\chs\testitn_chs.h ===
// TestITN_CHS.h : Declaration of the CTestITN_CHS

#ifndef __TESTITN_CHS_H_
#define __TESTITN_CHS_H_

#include "resource.h"       // main symbols
#include <wchar.h>          // for swprintf()

/////////////////////////////////////////////////////////////////////////////
// CTestITN_CHS
class ATL_NO_VTABLE CTestITN_CHS : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CTestITN_CHS, &CLSID_TestITN_CHS>,
    public ISpCFGInterpreter
{
public:
    CTestITN_CHS() : m_pSite( NULL )
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_TESTITN_CHS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTestITN_CHS)
    COM_INTERFACE_ENTRY(ISpCFGInterpreter)
END_COM_MAP()

// ISpCFGInterptreter
public:
    STDMETHODIMP InitGrammar(const WCHAR * pszGrammarName, const void ** pvGrammarData);
    STDMETHODIMP Interpret(ISpPhraseBuilder * pInterpretRule, const ULONG ulFirstElement, const ULONG ulCountOfElements, ISpCFGInterpreterSite * pSite);

private:
    ISpCFGInterpreterSite *m_pSite;

    HRESULT AddPropertyAndReplacement( const WCHAR *szBuff,
                                const DOUBLE dblValue,
                                const ULONG ulMinPos,
                                const ULONG ulMaxPos,
                                const ULONG ulFirstElement,
                                const ULONG ulCountOfElements);

public:
    CComPtr<ISpPhraseBuilder> m_cpPhrase;   // Decalred as a member to prevent repeated construct/destroy
};

#endif //__TESTITN_CHS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\eng\itngramver.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif
#include <windows.h>
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Microsoft Speech Recognition ITN"
#define VER_INTERNALNAME_STR        "ITNGRAM"
#define VER_ORIGINALFILENAME_STR    "ITNGRAM.DLL"

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* this include file is generated by the build process to       */
/* reflect the current build number                             */
/*--------------------------------------------------------------*/

#include "currver.inc"

#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifdef _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft Speech Engine\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\eng\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\chs\testitn_chs.cpp ===
/////////////////////////////////////////////////////////
// TestITN_CHS.cpp : Implementation of CTestITN_CHS
//
// ITN Interpretor for Simplified Chinese:
//
//   Integer,
//   Decimal,
//   Percent,
//   Ratio,
//   Fraction,
//   Minus number,
//   Time
//
/////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Itngram_CHS.h"
#include "TestITN_CHS.h"
#include "sphelper.h"
#include "test_CHS.h"

/////////////////////////////////////////////////////////////////////////////
// CTestITN_CHS
/****************************************************************************
* CTestITN_CHS::InitGrammar *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CTestITN_CHS::InitGrammar(const WCHAR * pszGrammarName, const void ** pvGrammarData)
{
    HRESULT hr = S_OK;
    HRSRC hResInfo = ::FindResource(_Module.GetModuleInstance(), _T("TEST"), _T("ITNGRAMMAR"));
    if (hResInfo)
    {
        HGLOBAL hData = ::LoadResource(_Module.GetModuleInstance(), hResInfo);
        if (hData)
        {
            *pvGrammarData = ::LockResource(hData);
            if (*pvGrammarData == NULL)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    return hr;
}

/****************************************************************************
* CTestITN_CHS::Interpret *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

class CSpPhrasePtrTemp : public CSpPhrasePtr
{
public:

    const WCHAR *   TextValueOfId(ULONG IdProp);
    const double    DoubleValueOfId(ULONG IdProp);
    const ULONGLONG ULongLongValueOfId(ULONG IdProp);
    HRESULT ElementInfoOfId(ULONG IdProp, ULONG *pulFirstElement, ULONG *pulCountOfElements);

private:

    const SPPHRASEPROPERTY * FindPropertyById(ULONG IdProp);
    const SPPHRASEPROPERTY * FindPropertyByIdHelper(ULONG IdProp, const SPPHRASEPROPERTY *);
};

const WCHAR * CSpPhrasePtrTemp::TextValueOfId(ULONG IdProp)
{
    _ASSERT(m_pPhrase);
    SPDBG_ASSERT(m_pPhrase);

    const SPPHRASEPROPERTY * pProp = FindPropertyById(IdProp);

    return pProp ? pProp->pszValue : NULL;
}

const double CSpPhrasePtrTemp::DoubleValueOfId(ULONG IdProp)
{
    SPDBG_ASSERT(m_pPhrase);

    const SPPHRASEPROPERTY * pProp = FindPropertyById(IdProp);

    return pProp ? pProp->vValue.dblVal : 0;
}

const ULONGLONG CSpPhrasePtrTemp::ULongLongValueOfId(ULONG IdProp)
{
    SPDBG_ASSERT(m_pPhrase);

    const SPPHRASEPROPERTY * pProp = FindPropertyById(IdProp);

    return pProp ? pProp->vValue.ulVal : 0;
}

HRESULT CSpPhrasePtrTemp::ElementInfoOfId(ULONG IdProp, ULONG *pulFirstElement, ULONG *pulCountOfElements)
{
    _ASSERT(m_pPhrase);
    SPDBG_ASSERT(m_pPhrase);

    const SPPHRASEPROPERTY * pProp = FindPropertyById(IdProp);

    if (pProp)
    {
        *pulFirstElement = pProp->ulFirstElement;
        *pulCountOfElements = pProp->ulCountOfElements;
    }
    else
    {
        *pulFirstElement = *pulCountOfElements = 0;
    }

    return pProp ? S_OK : E_FAIL;
}

const SPPHRASEPROPERTY * CSpPhrasePtrTemp::FindPropertyById(const ULONG IdProp)
{
    return FindPropertyByIdHelper(IdProp, m_pPhrase->pProperties);
}

const SPPHRASEPROPERTY * CSpPhrasePtrTemp::FindPropertyByIdHelper(ULONG IdProp, const SPPHRASEPROPERTY * pProp)
{
    const SPPHRASEPROPERTY * pRet = NULL;
    
    if (pProp->ulId == IdProp)
    {
        pRet = pProp;
    }
    else
    {
        if (pProp->pFirstChild)
        {
            pRet = FindPropertyByIdHelper(IdProp, pProp->pFirstChild);
        }

        if (!pRet && pProp->pNextSibling)
        {
            pRet = FindPropertyByIdHelper(IdProp, pProp->pNextSibling);
        }
    }

    return pRet;
}

// assume that we have only THOUSANDS(qian), HUNDREDS(bai), TENS(shi), and ONES(ge) here!!
HRESULT ComputeNum9999(const SPPHRASEPROPERTY *pProperties, __int64 *pVal, ULONG *pulLength)
{
    ULONG ulVal = 0;

    if (pProperties->pFirstChild)
    {
        for (const SPPHRASEPROPERTY * pProp = pProperties; pProp; pProp = pProp->pNextSibling)
        {
            if ( 0 != pProp->ulId )
            {
                SPDBG_ASSERT( pProp->pFirstChild );
                SPDBG_ASSERT( VT_UI4 == pProp->vValue.vt );
                SPDBG_ASSERT( VT_UI4 == pProp->pFirstChild->vValue.vt );

                ulVal += pProp->pFirstChild->vValue.ulVal * pProp->vValue.ulVal;
            }
        }
    }

    *pVal = ulVal;
    return S_OK;
}

HRESULT ComputeNum10000(const SPPHRASEPROPERTY *pProperties, __int64 *pVal, ULONG *pulLength)
{
    HRESULT hr = S_OK;
    *pVal = 0;
    *pulLength = 0;

    WCHAR * pszStopped;
    ULONG v2 = wcstol(pProperties->pszValue, &pszStopped, 10);
    *pVal += v2;

    return hr;
}

/***********************************************************************
* GetMinAndMaxPos *
*-----------------*
*   Description:
*       Gets the minimum and maximum elements spanned by the 
*       set of properties
*************************************************************************/
void GetMinAndMaxPos( const SPPHRASEPROPERTY *pProperties, 
                     ULONG *pulMinPos, 
                     ULONG *pulMaxPos )
{
    if ( !pulMinPos || !pulMaxPos )
    {
        return;
    }
    ULONG ulMin = 9999999;
    ULONG ulMax = 0;

    for ( const SPPHRASEPROPERTY *pProp = pProperties; pProp; pProp = pProp->pNextSibling )
    {
        ulMin = __min( ulMin, pProp->ulFirstElement );
        ulMax = __max( ulMax, pProp->ulFirstElement + pProp->ulCountOfElements );
    }
    *pulMinPos = ulMin;
    *pulMaxPos = ulMax;
}   /* GetMinAndMaxPos */

HRESULT FormatOutput(WCHAR *pBuffer, __int64 Value)
{
    swprintf(pBuffer, L"%I64d", Value);
    if (Value < 0)
        pBuffer++; // keep the '-', replace the rest

    int l = wcslen(pBuffer);
    if (l<=3)
        return S_OK;

    int head = l%3;
    int block = l/3;

    WCHAR buf[100];
    wcscpy(buf, pBuffer);
    pBuffer[0] = 0;

    if (head)
    {
        wcsncat(pBuffer, buf, head);
        pBuffer[head] = 0;
        wcscat(pBuffer, L",");
    }

    for (int i=0; i<block; i++)
    {
        wcsncat(pBuffer, buf+i*3+head, 3);
        if (i<block-1)
            wcscat(pBuffer, L",");
    }

    return S_OK;
}

STDMETHODIMP CTestITN_CHS::Interpret(ISpPhraseBuilder * pPhrase, const ULONG ulFirstElement, const ULONG ulCountOfElements, ISpCFGInterpreterSite * pSite)
{
    HRESULT hr = S_OK;
    ULONG ulRuleId = 0;
    CSpPhrasePtrTemp cpPhrase;
    WCHAR szBuff[MAX_PATH], szBuff2[MAX_PATH]; /* pwch;*/
    szBuff[0] = 0;
    szBuff2[0] = 0;

    hr = pPhrase->GetPhrase(&cpPhrase);
    m_pSite = pSite;

    ULONG ulMinPos;
    ULONG ulMaxPos;
    GetMinAndMaxPos( cpPhrase->pProperties, &ulMinPos, &ulMaxPos );

    if (SUCCEEDED(hr))
    {
        switch (cpPhrase->Rule.ulId)
        {
            case GRID_NUMBER: // Number
                {
                    __int64 ulValue = 0;
                    ULONG ulLength = 0;
                    //ULONG ulMinPos = 999999999;
                    //ULONG ulMaxPos = 0;
                    for (const SPPHRASEPROPERTY * pProp = cpPhrase->pProperties; pProp; pProp ? pProp = pProp->pNextSibling : NULL)
                    {
                        switch(pProp->ulId)
                        {
                        case TENTHOUSANDS_:
                            {
                                __int64 v1 = 0;
                                _ASSERT(pProp);
                                SPDBG_ASSERT(pProp);
                                hr = ComputeNum10000(pProp, &v1, &ulLength);
                                if (SUCCEEDED(hr))
                                {
                                    ulValue += v1 * 10000;
                                }
                            }
                            break;
                        case TENTHOUSANDS:
                            {
                                __int64 v1 = 0;
                                _ASSERT(pProp->pFirstChild);
                                SPDBG_ASSERT(pProp->pFirstChild);
                                hr = ComputeNum9999(pProp->pFirstChild, &v1, &ulLength);
                                if (SUCCEEDED(hr))
                                {
                                    ulValue += v1 * 10000;
                                }
                            }
                            break;
                        case HUNDREDMILLIONS:
                            {
                                __int64 v1 = 0;
                                _ASSERT(pProp->pFirstChild);
                                SPDBG_ASSERT(pProp->pFirstChild);
                                hr = ComputeNum9999(pProp->pFirstChild, &v1, &ulLength);
                                if (SUCCEEDED(hr))
                                {
                                    ulValue += v1 * 100000000;
                                }
                            }
                            break;
                        case ONES:
                            {
                                __int64 v1 = 0;
                                SPDBG_ASSERT(pProp->pFirstChild);
                                hr = ComputeNum9999(pProp->pFirstChild, &v1, &ulLength);
                                if (SUCCEEDED(hr))
                                {
                                    ulValue += v1;
                                    pProp = NULL;
                                }
                            }
                            break;
                        case ONES_THOUSANDS:
                            {
                                SPDBG_ASSERT(pProp->pFirstChild);
                                ulValue += pProp->pFirstChild->vValue.ulVal;
                                pProp = NULL;
                            }
                            break;
                        case THOUSANDS:
                        case HUNDREDS:
                        default:
                            _ASSERT(false);
                            SPDBG_ASSERT(false);
                        }
                    }

                    ATLTRACE(L"GRID_NUMBER: %d\t(%d + %d)\n", ulValue, ulMinPos, ulMaxPos - ulMinPos);
                    FormatOutput(szBuff, ulValue);
                }
                break;

            case GRID_DECIMAL:
                {
                    szBuff2[0] = 0;
                    for (const SPPHRASEPROPERTY * pProp = cpPhrase->pProperties; pProp; pProp = pProp->pNextSibling)
                    {
                        switch (pProp->ulId)
                        {
                        case INTEGER:
                            {
                                wcscpy(szBuff, pProp->pszValue);
                                wcscat(szBuff, L".");
                            }
                            break;
                        default:
                            {
                                wcscat(szBuff2, pProp->pszValue);
                            }
                            break;
                        }
                    }

                    ATLTRACE(L"GRID_DECIMAL");
                    wcscat(szBuff, szBuff2);
                }
                break;

            case PERCENT:
                {
                    for (const SPPHRASEPROPERTY * pProp = cpPhrase->pProperties; pProp; pProp = pProp->pNextSibling)
                    {
                        switch (pProp->ulId)
                        {
                        case DECIMAL:
                        case INTEGER:
                            {
                                wcscpy(szBuff, pProp->pszValue);
                                wcscat(szBuff, L"%");
                            }
                            break;
                        default:
                            break;
                        }
                    }

                    ATLTRACE(L"PERCENT");
                }
                break;

            case PERCENT100:
                {
                    ATLTRACE(L"PERCENT100");
                    wcscpy(szBuff, L"100%");
                }
                break;

            case RATIO:
                {
                    for (const SPPHRASEPROPERTY * pProp = cpPhrase->pProperties; pProp; pProp = pProp->pNextSibling)
                    {
                        switch (pProp->ulId)
                        {
                        case RATIO1:
                            wcscpy(szBuff, pProp->pszValue);
                            break;
                        case RATIO2:
                            wcscpy(szBuff2, pProp->pszValue);
                            break;
                        default:
                            break;
                        }
                    }

                    ATLTRACE(L"RATIO");
                    wcscat(szBuff, L":");
                    wcscat(szBuff, szBuff2);
                }
                break;

            case FRACTION:
                {
                    for (const SPPHRASEPROPERTY * pProp = cpPhrase->pProperties; pProp; pProp = pProp->pNextSibling)
                    {
                        switch (pProp->ulId)
                        {
                        case DENOMINATOR:
                            wcscpy(szBuff2, pProp->pszValue);
                            break;
                        case NUMERATOR:
                            wcscpy(szBuff, pProp->pszValue);
                            break;
                        default:
                            break;
                        }
                    }

                    ATLTRACE(L"FRACTION");
                    wcscat(szBuff, L"/");
                    wcscat(szBuff, szBuff2);
                }
                break;

            case GRID_NUMBER_MINUS:
                {
                    for (const SPPHRASEPROPERTY * pProp = cpPhrase->pProperties; pProp; pProp = pProp->pNextSibling)
                    {
                        switch (pProp->ulId)
                        {
                        case POS_OF_MINUS:
                            wcscpy(szBuff2, pProp->pszValue);
                            break;
                        default:
                            break;
                        }
                    }

                    ATLTRACE(L"GRID_NUMBER_MINUS");
                    wcscpy(szBuff, L"-");
                    wcscat(szBuff, szBuff2);
                }
                break;

            case TIME:
                {
                    for (const SPPHRASEPROPERTY * pProp = cpPhrase->pProperties; pProp; pProp = pProp->pNextSibling)
                    {
                        switch (pProp->ulId)
                        {
                        case HOUR:
                            wcscpy(szBuff, pProp->pszValue);
                            break;
                        case MINUTE:
                            wcscpy(szBuff2, pProp->pszValue);
                            break;
                        default:
                            break;
                        }
                    }

                    ATLTRACE(L"TIME");
                    wcscat(szBuff, L":");
                    wcscat(szBuff, szBuff2);
                }
                break;


        default:
            _ASSERT(FALSE);
            break;
        }

        hr = AddPropertyAndReplacement( szBuff, 0, 
                ulMinPos, ulMaxPos, ulMinPos, ulMaxPos - ulMinPos );//ulFirstElement, ulCountOfElements );
    }

    return hr;
}

/***********************************************************************
* CTestITN_CHS::AddPropertyAndReplacement *
*---------------------------------------*
*   Description:
*       Takes all of the info that we want to pass into the 
*       engine site, forms the SPPHRASEPROPERTY and
*       SPPHRASERREPLACEMENT, and adds them to the engine site
*   Return:
*       Return values of ISpCFGInterpreterSite::AddProperty()
*           and ISpCFGInterpreterSite::AddTextReplacement()
*************************************************************************/
HRESULT CTestITN_CHS::AddPropertyAndReplacement( const WCHAR *szBuff,
                                    const DOUBLE dblValue,
                                    const ULONG ulMinPos,
                                    const ULONG ulMaxPos,
                                    const ULONG ulFirstElement,
                                    const ULONG ulCountOfElements )
{
    // Add the property 
    SPPHRASEPROPERTY prop;
    memset(&prop,0,sizeof(prop));
    prop.pszValue = szBuff;
    prop.vValue.vt = VT_R8;
    prop.vValue.dblVal = dblValue;
    prop.ulFirstElement = ulMinPos;
    prop.ulCountOfElements = ulMaxPos - ulMinPos;
    HRESULT hr = m_pSite->AddProperty(&prop);

    if (SUCCEEDED(hr))
    {
        SPPHRASEREPLACEMENT repl;
        memset(&repl,0, sizeof(repl));
        //repl.bDisplayAttributes = SPAF_ONE_TRAILING_SPACE;
        // No space after the ITNed string in Chinese
        repl.bDisplayAttributes = 0;
        repl.pszReplacementText = szBuff;
        repl.ulFirstElement = ulFirstElement;
        repl.ulCountOfElements = ulCountOfElements;
        hr = m_pSite->AddTextReplacement(&repl);
    }

    return hr;
}   /* CTestITN_CHS::AddPropertyAndReplacement */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\eng\itngram.cpp ===
// itngram.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f itngramps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "itngram.h"

#include "itngram_i.c"
#include "TestITN.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TestITN, CTestITN)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ITNGRAMLib);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\eng\makefile.inc ===
# Rules for compiling .cfgs from .xmls
# could these be moved into common.inc?
.SUFFIXES: .cfg .h .xml

.xml{$(O)}.cfg:
    copy $** $(O)
	$(SPEECH_ROOT)\sapi\tools\bin\gc.exe -h $*.h $*.xml

!if defined(MAKEDLL)
# Self-register
itngram.cpy: $(O)\itngram.dll
    regsvr32 /s $** > $@
!else
itngram.cpy:
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\eng\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__42E0F13B_11FD_11D3_BB97_00C04F8EE6C0__INCLUDED_)
#define AFX_STDAFX_H__42E0F13B_11FD_11D3_BB97_00C04F8EE6C0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "sapi.h"
#include "sapiddk.h"
#include "sphelper.h"
#include "spunicode.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__42E0F13B_11FD_11D3_BB97_00C04F8EE6C0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\jpn\itngramver.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif
#include <windows.h>
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Microsoft Speech Recognition ITN"
#define VER_INTERNALNAME_STR        "ITNGRAM"
#define VER_ORIGINALFILENAME_STR    "ITNGRAM.DLL"

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* this include file is generated by the build process to       */
/* reflect the current build number                             */
/*--------------------------------------------------------------*/

#include "currver.inc"

#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifdef _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft Speech Engine\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#include "_common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\eng\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by itngram.rc
//
#define IDS_PROJNAME                    100
#define IDR_TESTITN                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\jpn\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\jpn\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__42E0F13B_11FD_11D3_BB97_00C04F8EE6C0__INCLUDED_)
#define AFX_STDAFX_H__42E0F13B_11FD_11D3_BB97_00C04F8EE6C0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include "sapi.h"
#include "sphelper.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__42E0F13B_11FD_11D3_BB97_00C04F8EE6C0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\jpn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by itngram_J.rc
//
#define IDS_PROJNAME                    100
#define IDR_TESTITN_J                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\eng\testitn.cpp ===
// TestITN.cpp : Implementation of CTestITN
#include "stdafx.h"
#include <winnls.h>
#include "Itngram.h"
#include "TestITN.h"
#include "sphelper.h"
#include "spddkhlp.h"
#include "test.h"

#define MILLION         ((LONGLONG) 1000000)
#define BILLION         ((LONGLONG) 1000000000)
#define MILLION_STR     (L"million")
#define BILLION_STR     (L"billion")

#define DAYOFWEEK_STR_ABBR  (L"ddd")
#define DAYOFWEEK_STR       (L"dddd")

#define NUM_US_STATES   57
#define NUM_CAN_PROVINCES 10

BOOL CALLBACK EnumCalendarInfoProc( LPTSTR lpCalendarInfoString )
{
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CTestITN
/****************************************************************************
* CTestITN::InitGrammar *
*-----------------------*
*   Description:
*       Initialize a grammar that is loaded from an object (DLL).
*           - pszGrammarName        name of the grammar to be loaded (in case this
*                                   object supports multiple grammars)
*           - pvGrammarData         pointer to the serialized binary grammar
*   Returns:
*       S_OK
*       failure codes that are implementation specific
********************************************************************* RAL ***/

STDMETHODIMP CTestITN::InitGrammar(const WCHAR * pszGrammarName, const void ** pvGrammarData)
{
    HRESULT hr = S_OK;
    HRSRC hResInfo = ::FindResource(_Module.GetModuleInstance(), _T("TEST"), _T("ITNGRAMMAR"));
    if (hResInfo)
    {
        HGLOBAL hData = ::LoadResource(_Module.GetModuleInstance(), hResInfo);
        if (hData)
        {
            *pvGrammarData = ::LockResource(hData);
            if (*pvGrammarData == NULL)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    return hr;
}

/****************************************************************************
* CTestITN::Interpret *
*---------------------*
*   Description:
*       Given a phrase structure of the sub-tree spanned by this rule, given by
*       ulFristElement and ulCountOfElements and rule info (in pPhrase), examine
*       and generate new properties/text replacements which are set in the outer 
*       phrase using pSite.
*   Returns:
*       S_OK
*       S_FALSE     -- nothing was added/changed
********************************************************************* RAL ***/

STDMETHODIMP CTestITN::Interpret(ISpPhraseBuilder * pPhrase, 
                                 const ULONG ulFirstElement, 
                                 const ULONG ulCountOfElements, 
                                 ISpCFGInterpreterSite * pSite)
{
    HRESULT hr = S_OK;
    ULONG ulRuleId = 0;
    CSpPhrasePtr cpPhrase;
    
    hr = pPhrase->GetPhrase(&cpPhrase);

    m_pSite = pSite;

    // Get the minimum and maximum positions
    ULONG ulMinPos;
    ULONG ulMaxPos;
    //Just use ulFirstElement & ulCountOfElements
    //GetMinAndMaxPos( cpPhrase->pProperties, &ulMinPos, &ulMaxPos );
    ulMinPos = ulFirstElement;
    ulMaxPos = ulMinPos + ulCountOfElements; 

    // Unless otherwise specified, this is the display attributes
    BYTE bDisplayAttribs = SPAF_ONE_TRAILING_SPACE;

    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;

        WCHAR pszValueBuff[ MAX_PATH ]; // No ITN result should be longer than this
        DOUBLE dblValue;                // All ITN results will have a 64-bit value

        pszValueBuff[0] = 0;

        switch (cpPhrase->Rule.ulId)
        {
        case GRID_INTEGER_STANDALONE: // Fired as a toplevel rule
            hr = InterpretNumber( cpPhrase->pProperties, true,
                &dblValue, pszValueBuff, MAX_PATH, true );

            if (SUCCEEDED( hr ) 
                && ( dblValue >= 0 ) 
                && ( dblValue <= 20 )                 
                && ( GRID_DIGIT_NUMBER != cpPhrase->pProperties->ulId )
                && ( GRID_INTEGER_MILLBILL != cpPhrase->pProperties->ulId ))
            {
                // Throw this one out because numbers like "three"
                // shouldn't be ITNed by themselves
                hr = E_FAIL;
            }
            break;
        
        case GRID_INTEGER:  case GRID_INTEGER_NONNEG:
        case GRID_INTEGER_99: case GRID_INTEGER_999: 
        case GRID_ORDINAL: 
        case GRID_MINSEC: case GRID_CLOCK_MINSEC: // Number
            hr = InterpretNumber( cpPhrase->pProperties, true, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        // Number "spelled out" digit by digit
        case GRID_DIGIT_NUMBER: case GRID_YEAR: case GRID_CENTS:
            hr = InterpretDigitNumber( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_FP_NUMBER: case GRID_FP_NUMBER_NONNEG:
            hr = InterpretFPNumber( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_INTEGER_MILLBILL:
            hr = InterpretMillBill( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_DENOMINATOR: case GRID_DENOMINATOR_SINGULAR:
            hr = InterpretNumber( cpPhrase->pProperties, true, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_FRACTION:
            hr = InterpretFraction( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_DATE:
            hr = InterpretDate( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_TIME:
            hr = InterpretTime( cpPhrase->pProperties,
                &dblValue, pszValueBuff, MAX_PATH );
            break;
        
        case GRID_STATEZIP:
            hr = InterpretStateZip( cpPhrase->pProperties,
                pszValueBuff, MAX_PATH, &bDisplayAttribs );
            break;

        case GRID_ZIPCODE: case GRID_ZIP_PLUS_FOUR:
            hr = (MakeDigitString( cpPhrase->pProperties,
                pszValueBuff, MAX_PATH ) > 0) ? S_OK : E_FAIL;
            break;

        case GRID_CAN_ZIPCODE: 
            hr = InterpretCanadaZip( cpPhrase->pProperties,
                pszValueBuff, MAX_PATH );
            break;

        case GRID_PHONE_NUMBER:
            hr = InterpretPhoneNumber( cpPhrase->pProperties,
                pszValueBuff, MAX_PATH );
            break;

        case GRID_DEGREES:
            hr = InterpretDegrees( cpPhrase->pProperties,
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_MEASUREMENT:
            hr = InterpretMeasurement( cpPhrase->pProperties,
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_CURRENCY: // Currency
            hr = InterpretCurrency( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;
        
        default:
            _ASSERT(FALSE);
            break;
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = AddPropertyAndReplacement( pszValueBuff, dblValue, 
                ulMinPos, ulMaxPos, ulMinPos, ulMaxPos - ulMinPos, 
                bDisplayAttribs );

            return hr;
        }

    }
    
    // Nothing was ITNed
    return S_FALSE;
}

/***********************************************************************
* CTestITN::InterpretNumber *
*---------------------------*
*   Description:
*       Interprets a number in the range -999,999,999,999 to 
*       +999,999,999,999 and sends the properties and
*       replacements to the CFGInterpreterSite as appropriate.
*       The property will be added and the pszValue will be a string 
*       with the correct display number.
*       If fCardinal is set, makes the display a cardinal number;
*       otherwise makes it an ordinal number.
*       The number will be formatted only if it was a properly-formed
*       number (not given digit by digit).
*   Result:
*************************************************************************/
HRESULT CTestITN::InterpretNumber(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize,
                            const bool fFinalDisplayFmt)
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }

    *pszVal = 0;

    LONGLONG llValue = 0;
    int iPositive = 1; 

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    // Handle negatives
    if ( NEGATIVE == pFirstProp->ulId )
    {
        // There's no such thing as a negative ordinal
        SPDBG_ASSERT( fCardinal );

        // There had better be more stuff following
        SPDBG_ASSERT( pFirstProp->pNextSibling );

        iPositive = -1;

        pFirstProp = pFirstProp->pNextSibling;
    }

    // Handle the "2.6 million" case, in which case the number
    // has already been formatted
    if ( GRID_INTEGER_MILLBILL == pFirstProp->ulId )
    {
        if ( cSize < (wcslen( pFirstProp->pszValue ) + 1) )
        {
            return E_INVALIDARG;
        }
        *pdblVal = pFirstProp->vValue.dblVal * iPositive;
        if ( iPositive < 0 )
        {
            wcscpy( pszVal, m_pwszNeg );
        }
        wcscat( pszVal, pFirstProp->pszValue );

        return S_OK;
    }

    // Handle the digit-by-digit case
    if ( GRID_DIGIT_NUMBER == pFirstProp->ulId )
    {
        // There had better be nothing following this
        SPDBG_ASSERT( !pFirstProp->pNextSibling );
        
        SPDBG_ASSERT( VT_R8 == pFirstProp->vValue.vt );
        SPDBG_ASSERT( pFirstProp->pszValue );

        DOUBLE dblVal = pFirstProp->vValue.dblVal;
        *pdblVal = dblVal * iPositive;
        
        // Just get the string and make it negative if necessary
        if ( cSize < wcslen( pFirstProp->pszValue ) )
        {
            return E_INVALIDARG;
        }
        wcscpy( pszVal, pFirstProp->pszValue );
        if ( iPositive < 0 )
        {
            MakeNumberNegative( pszVal );
        }

        return S_OK;
    }

    for (const SPPHRASEPROPERTY * pProp = pFirstProp; pProp; pProp ? pProp = pProp->pNextSibling : NULL)
    {
        switch(pProp->ulId)
        {
        case ONES:
            {
                SPDBG_ASSERT(pProp->pFirstChild);
                llValue += ComputeNum999( pProp->pFirstChild );
            }
            break;
        case THOUSANDS:
            {
                llValue += ComputeNum999( pProp->pFirstChild ) * 1000;
            }
            break;
        case MILLIONS:
            {
                SPDBG_ASSERT(pProp->pFirstChild);
                llValue += ComputeNum999( pProp->pFirstChild ) * (LONGLONG) 1e6;
            }
            break;
        case BILLIONS:
            {
                SPDBG_ASSERT(pProp->pFirstChild);
                llValue += ComputeNum999( pProp->pFirstChild ) * (LONGLONG) 1e9;
            }
            break;
        case HUNDREDS:
            {
                SPDBG_ASSERT( pProp->pFirstChild );
                llValue += ComputeNum999( pProp->pFirstChild ) * 100;
            }
            break;

        case TENS:
        default:
            SPDBG_ASSERT(false);
        }
    }

    llValue *= iPositive;

    *pdblVal = (DOUBLE) llValue;

    DWORD dwDisplayFlags = DF_WHOLENUMBER 
                            | (fCardinal ? 0 : DF_ORDINAL)
                            | (fFinalDisplayFmt ? DF_MILLIONBILLION : 0 );
    return MakeDisplayNumber( *pdblVal, dwDisplayFlags, 0, 0, pszVal, cSize );

}   /* CTestITN::InterpretNumber */




/***********************************************************************
* CTestITN::InterpretDigitNumber *
*--------------------------------*
*   Description:
*       Interprets an integer in (-INF, +INF) that has been spelled
*       out digit by digit.
*       Also handles years.
*   Result:
*************************************************************************/
HRESULT CTestITN::InterpretDigitNumber( const SPPHRASEPROPERTY *pProperties,
                                        DOUBLE *pdblVal,
                                        WCHAR *pszVal,
                                        UINT cSize)
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }

    BOOL  fPositive = TRUE;
    ULONG ulLength = 0;
    *pszVal = 0;
    WCHAR *pwc = pszVal;
    UINT cLen = 0;
    for (const SPPHRASEPROPERTY * pProp = pProperties; 
        pProp && (cLen < cSize); 
        pProp ? pProp = pProp->pNextSibling : NULL)
    {
        switch(pProp->ulId)
        {
            /*
        case NEGATIVE:
            {
                SPDBG_ASSERT( pProp == pProperties );

                fPositive = FALSE;
                *pwc++ = L'-';
                cLen++;
                break;
            }
            */
        case DIGIT:
            {
                *pwc++ = pProp->pszValue[0];
                cLen++;
                break;
            }
        case TWODIGIT:
            {
                SPDBG_ASSERT( pProp->pFirstChild );
                
                ULONG ulTwoDigit = ComputeNum999( pProp->pFirstChild );
                SPDBG_ASSERT( ulTwoDigit < 100 );

                // Get each digit
                *pwc++ = L'0' + ((UINT) ulTwoDigit) / 10;
                *pwc++ = L'0' + ((UINT) ulTwoDigit) % 10;

                cLen += 2;

                break;
            }
        case ONEDIGIT:
            {
                SPDBG_ASSERT( pProp->pFirstChild);
                
                *pwc++ = pProp->pFirstChild->pszValue[0];
                cLen++;

                break;
            }
        case TWOTHOUSAND:
            {
                // Handles the "two thousand" in dates
                if ( pProp->pNextSibling )
                {
                    if ( TWODIGIT == pProp->pNextSibling->ulId )
                    {
                        wcscpy( pwc, L"20" );
                        pwc += 2;
                        cLen += 2;
                    }
                    else
                    {
                        SPDBG_ASSERT( ONEDIGIT == pProp->pNextSibling->ulId );
                        wcscpy( pwc, L"200" );
                        pwc += 3;
                        cLen += 3;
                    }
                }
                else
                {
                    wcscpy( pwc, L"2000" );
                    pwc += 4;
                    cLen += 4;
                }
                break;
            }
        case DATE_HUNDREDS:
            {
                SPDBG_ASSERT( pProp->pFirstChild );
                DOUBLE dblTwoDigit;
                HRESULT hr = InterpretDigitNumber( pProp->pFirstChild, &dblTwoDigit, pwc, cSize - cLen );
                if ( FAILED( hr ) )
                {
                    return hr;
                }

                pwc += 2;
                *pwc++ = L'0';
                *pwc++ = L'0';
                cLen += 4;

                break;
            }


        default:
            SPDBG_ASSERT(false);
        }
    }
    *pwc = 0;

    if ( cLen <= MAX_SIG_FIGS )
    {
        *pdblVal = (DOUBLE) _wtoi64( pszVal );
    }
    else
    {
        // Just make sure it's not zero so denominators don't fail
        *pdblVal = 1;
    }

    return S_OK;
}   /* CTestITN::InterpretDigitNumber */

/***********************************************************************
* CTestITN::InterpretFPNumber *
*-----------------------------*
*   Description:
*       Interprets a floating-point number of arbitrarily many
*       sig figs.  (The value in *pdblVal will be truncated
*       as necessary to fit into a DOUBLE.)
*       The properties will look like an optional NEGATIVE property
*       followed by an optional ONES property, 
*       which has already been appropriately ITNed,
*       followed by the stuff to the right of the decimal place
************************************************************************/
HRESULT CTestITN::InterpretFPNumber( const SPPHRASEPROPERTY *pProperties,
                                    DOUBLE *pdblVal,
                                    WCHAR *pszVal,
                                    UINT cSize )
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }
    SPDBG_ASSERT( pProperties );

    *pdblVal = 0;
    *pszVal = 0;

    
    bool fNonNegative = true;
    const SPPHRASEPROPERTY *pPropertiesFpPart = NULL;
    const SPPHRASEPROPERTY *pPropertiesPointZero = NULL;
    const SPPHRASEPROPERTY *pPropertiesOnes = NULL;
    const SPPHRASEPROPERTY *pPropertiesZero = NULL;
    const SPPHRASEPROPERTY *pPropertiesNegative = NULL;
    const SPPHRASEPROPERTY *pPropertiesPtr;

    for(pPropertiesPtr=pProperties; pPropertiesPtr; pPropertiesPtr=pPropertiesPtr->pNextSibling)
    {
        if (POINT_ZERO == pPropertiesPtr->ulId )
            pPropertiesPointZero = pPropertiesPtr;
        else if ( FP_PART == pPropertiesPtr->ulId )
            pPropertiesFpPart = pPropertiesPtr;
        else if (ONES == pPropertiesPtr->ulId )
            pPropertiesOnes = pPropertiesPtr;
        else if (ZERO == pPropertiesPtr->ulId )
            pPropertiesZero = pPropertiesPtr;
        else if (NEGATIVE == pPropertiesPtr->ulId )
            pPropertiesNegative = pPropertiesPtr;
    }

    // Get current number formatting defaults
    HRESULT hr = GetNumberFormatDefaults();
    if ( FAILED( hr ) )
    {
        return hr;
    }

    // Look for negative sign
    if ( pPropertiesNegative )
    {
        fNonNegative = false;
    }

    // Look for optional ONES (optional because you can say 
    // "point five"
    if ( pPropertiesOnes )
    {
        // This property has already been ITNed correctly,
        // so just copy in the text
        if ( (cSize - wcslen( pszVal )) < (wcslen( pPropertiesOnes->pszValue ) + 1) )
        {
            return E_INVALIDARG;
        }
        wcscpy( pszVal, pPropertiesOnes->pszValue );

        // Get the value
        *pdblVal = pPropertiesOnes->vValue.dblVal;

    }
    else if (pPropertiesZero || m_nmfmtDefault.LeadingZero )
    {
        // There should be a leading zero
        wcscpy( pszVal, L"0" );
    }

    SPDBG_ASSERT(pPropertiesFpPart || pPropertiesPointZero);

    // Put in a decimal separator
    if ( (cSize - wcslen( pszVal )) < (wcslen( m_nmfmtDefault.lpDecimalSep ) + 1) )
    {
        return E_INVALIDARG;
    }
    wcscat( pszVal, m_nmfmtDefault.lpDecimalSep );

    if ( pPropertiesFpPart )
    {
        // Deal with the FP part, which will also have been ITNed correctly
        if ( (cSize - wcslen( pszVal )) < (wcslen( pPropertiesFpPart->pszValue ) + 1) )
        {
            return E_INVALIDARG;
        }
        wcscat( pszVal, pPropertiesFpPart->pszValue );
        
        // Get the correct value
        DOUBLE dblFPPart = pPropertiesFpPart->vValue.dblVal;
        for ( UINT ui=0; ui < wcslen( pPropertiesFpPart->pszValue ); ui++ )
        {
            dblFPPart /= (DOUBLE) 10;
        }
        *pdblVal += dblFPPart;
    }
    else
    {
        // "point oh": The DOUBLE is already right, just add a "0"
        if ( (cSize - wcslen( pszVal )) < 2 )
        {
            return E_INVALIDARG;
        }
        wcscat( pszVal, L"0" );
    }

    // Handle the negative sign
    if ( !fNonNegative )
    {
        *pdblVal = -*pdblVal;

        if ( (cSize = wcslen( pszVal )) < 2 )
        {
            return E_INVALIDARG;
        }
        HRESULT hr = MakeNumberNegative( pszVal );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    return S_OK;
}   /* CTestITN::InterpretFPNumber */

/***********************************************************************
* CTestITN::InterpretMillBill *
*-----------------------------*
*   Description:
*       Interprets a number that needs to be displayed with 
*       the word "million" or "billion" in the display format.  
*************************************************************************/
HRESULT CTestITN::InterpretMillBill( const SPPHRASEPROPERTY *pProperties,
                                    DOUBLE *pdblVal,
                                    WCHAR *pszVal,
                                    UINT cSize )
{
    const SPPHRASEPROPERTY *pPropertiesPtr;
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }
    SPDBG_ASSERT( pProperties );
    
    HRESULT hr = GetNumberFormatDefaults();
    if ( FAILED( hr ) )
    {
        return hr;
    }

    *pszVal = 0;

    // Handle optional negative sign
    bool fNonNegative = true;
    if ( NEGATIVE == pProperties->ulId )
    {
        // Always do '-', regardless of control panel option settings
        if ( cSize < 2 )
        {
            return E_INVALIDARG;
        }
        wcscpy( pszVal, m_pwszNeg );

        cSize -= 1;
        pProperties = pProperties->pNextSibling;
    }

    // Handle the number part
    SPDBG_ASSERT( pProperties );
    for( pPropertiesPtr = pProperties; pPropertiesPtr && 
            ( GRID_INTEGER_99 != pPropertiesPtr->ulId ) && 
            ( GRID_FP_NUMBER_NONNEG != pPropertiesPtr->ulId );
         pPropertiesPtr = pPropertiesPtr->pNextSibling);
    SPDBG_ASSERT(( GRID_INTEGER_99 == pPropertiesPtr->ulId ) || 
        ( GRID_FP_NUMBER_NONNEG == pPropertiesPtr->ulId ));
    *pdblVal = pPropertiesPtr->vValue.dblVal;
    if ( cSize < (wcslen( pPropertiesPtr->pszValue ) + 1) )
    {
        return E_INVALIDARG;
    }
    wcscat( pszVal, pPropertiesPtr->pszValue );
    cSize -= wcslen( pPropertiesPtr->pszValue );
    

    // Handle the "millions" part
    SPDBG_ASSERT( pProperties );
    for( pPropertiesPtr = pProperties; pPropertiesPtr && 
            ( MILLBILL != pPropertiesPtr->ulId ); 
         pPropertiesPtr = pPropertiesPtr->pNextSibling);
    SPDBG_ASSERT( MILLBILL == pPropertiesPtr->ulId );
    *pdblVal *= ( (MILLIONS == pPropertiesPtr->vValue.uiVal) ? MILLION : BILLION );
    if ( cSize < (wcslen( pPropertiesPtr->pszValue ) + 2) )
    {
        return E_INVALIDARG;
    }
    wcscat( pszVal, L" " );
    wcscat( pszVal, pPropertiesPtr->pszValue );

    if ( !fNonNegative )
    {
        *pdblVal = -*pdblVal;
    }

    return S_OK;
}   /* CTestITN::InterpretMillBill */

/***********************************************************************
* CTestITN::InterpretFraction *
*-----------------------------*
*   Description:
*       Interprets a fraction.  
*       The DENOMINATOR property should be present.
*       If the NUMERATOR property is absent, it is assumed to be 1.
*       Divides the NUMERATOR by the DENOMINATOR and sets the value
*       accordingly.
*************************************************************************/
HRESULT CTestITN::InterpretFraction( const SPPHRASEPROPERTY *pProperties,
                                        DOUBLE *pdblVal,
                                        WCHAR *pszVal,
                                        UINT cSize)
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }
    SPDBG_ASSERT( pProperties );
    DOUBLE dblWholeValue = 0;
    DOUBLE dblFracValue = 1;

    const SPPHRASEPROPERTY *pProp = pProperties;
    *pszVal = 0;

    // Space to store whatever characters follow the digits 
    // in the numerator (like ")")
    WCHAR pszTemp[ 10 ];    // will never need this much
    pszTemp[0] = 0;

    // Whole part is optional, otherwise assumed to be 0
    if ( WHOLE == pProp->ulId )
    {
        SPDBG_ASSERT( VT_R8 == pProp->vValue.vt );
        dblWholeValue = pProp->vValue.dblVal;
        wcscpy( pszVal, pProp->pszValue );

        // Keep track of anything that follows the digits
        WCHAR *pwc;
        for ( pwc = pszVal + wcslen(pszVal) - 1; !iswdigit( *pwc ); pwc-- )
            ;
        wcscpy( pszTemp, pwc + 1 );
        *(pwc + 1) = 0;

        // Add a space between the whole part and the fractional part
        wcscat( pszVal, L" " );

        SPDBG_ASSERT( pProp->pNextSibling );
        pProp = pProp->pNextSibling;
    }

    // Numerator is optional, otherwise assumed to be 1
    if ( NUMERATOR == pProp->ulId )
    {
        SPDBG_ASSERT( VT_R8 == pProp->vValue.vt );
        dblFracValue = pProp->vValue.dblVal;
        wcscat( pszVal, pProp->pszValue );

        // Find the last digit and copy everything after it
        WCHAR *pwc;
        for ( pwc = pszVal + wcslen(pszVal) - 1; !iswdigit( *pwc ); pwc-- )
            ;
        wcscat( pszTemp, pwc + 1 );
        *(pwc + 1) = 0;

        SPDBG_ASSERT( pProp->pNextSibling );
        pProp = pProp->pNextSibling;
    }
    else if ( ZERO == pProp->ulId )
    {
        dblFracValue = 0;
        wcscat( pszVal, L"0" );

        SPDBG_ASSERT( pProp->pNextSibling );
        pProp = pProp->pNextSibling;
    }
    else
    {
        // No numerator, assume 1
        wcscat( pszVal, L"1" );
    }




    wcscat( pszVal, L"/" );

    SPDBG_ASSERT( DENOMINATOR == pProp->ulId );
    SPDBG_ASSERT( VT_R8 == pProp->vValue.vt );
    if ( 0 == pProp->vValue.dblVal )
    {
        // Will not ITN a fraction with a zero denominator
        return E_FAIL;
    }

    dblFracValue /= pProp->vValue.dblVal;
    wcscat( pszVal, pProp->pszValue );

    // In case the denominator was an ordinal, strip off the "th" at the end
    SPDBG_ASSERT( wcslen( pszVal ) );
    WCHAR *pwc = pszVal + wcslen( pszVal ) - 1;
    for ( ; (pwc >= pszVal) && !iswdigit( *pwc ); pwc-- )
        ;
    SPDBG_ASSERT( pwc > pszVal );
    *(pwc + 1) = 0;

    // Tack on the ")" or "-" from the end of the numerator
    wcscat( pszVal, pszTemp );

    *pdblVal = dblWholeValue + dblFracValue;
    
    return S_OK;
}   /* CTestITN::InterpretFraction */

/***********************************************************************
* CTestITN::InterpretDate *
*-------------------------*
*   Description:
*       Interprets a date.
*       Converts the date into a VT_DATE format, even though it
*       gets stored as a VT_R8 (both are 64-bit quantities).
*       In case the date is not a valid date ("May fortieth nineteen
*       ninety nine") will add the properties for any numbers in there
*       and return S_FALSE.
*************************************************************************/
HRESULT CTestITN::InterpretDate( const SPPHRASEPROPERTY *pProperties,
                                        DOUBLE *pdblVal,
                                        WCHAR *pszVal,
                                        UINT cSize)
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }

    *pszVal = 0;

    // Get the date formatting string to be used right now
    WCHAR pwszLongDateFormat[ MAX_DATE_FORMAT ];
    if ( 0 == m_Unicode.GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SLONGDATE, 
        pwszLongDateFormat, MAX_DATE_FORMAT ) )
    {
        return E_FAIL;
    }
    
    SYSTEMTIME stDate;
    memset( (void *) &stDate, 0, sizeof( stDate ) );

    // Arguments for FormatDate()
    WCHAR *pwszFormatArg = pwszLongDateFormat;
    WCHAR pwszFormat[ MAX_DATE_FORMAT ];
    *pwszFormat = 0;
    
    bool fYear = false;     // Necessary since year can be 0
    bool fClearlyIntentionalYear = false;   // "zero one"
    bool fMonthFirst = true;    // August 2000 as opposed to 2000 August
    const SPPHRASEPROPERTY *pProp;

    if (( MONTHYEAR == pProperties->ulId ) 
        || ( YEARMONTH == pProperties->ulId ))
    {
        fMonthFirst = ( MONTHYEAR == pProperties->ulId );
        
        // Look for the year and month properties underneath this one
        pProperties = pProperties->pFirstChild;
    }

    for ( pProp = pProperties; pProp; pProp = pProp->pNextSibling )
    {
        switch ( pProp->ulId )
        {
        case DAY_OF_WEEK:
            {
                SPDBG_ASSERT( VT_UI4 == pProp->vValue.vt );
                SPDBG_ASSERT( (0 < pProp->vValue.ulVal) && (7 >= pProp->vValue.ulVal) );
                if ( (pProp->vValue.ulVal <= 0) || (pProp->vValue.ulVal > 7) )
                {
                    return E_INVALIDARG;
                }
                stDate.wDayOfWeek = (WORD) pProp->vValue.ulVal;

                // Use the full long date format
                pwszFormatArg = pwszLongDateFormat;
            }
            break;

        case DAY_OF_MONTH:
            SPDBG_ASSERT( VT_UI4 == pProp->vValue.vt );
            SPDBG_ASSERT( (1 <= pProp->vValue.uiVal) && (31 >= pProp->vValue.uiVal) );
            stDate.wDay = pProp->vValue.uiVal;
            break;

        case MONTH:
            SPDBG_ASSERT( VT_UI4 == pProp->vValue.vt );
            SPDBG_ASSERT( (1 <= pProp->vValue.ulVal) && (12 >= pProp->vValue.ulVal) );
            if ( (pProp->vValue.ulVal < 1) || (pProp->vValue.ulVal > 12) )
            {
                return E_INVALIDARG;
            }
            stDate.wMonth = (WORD) pProp->vValue.ulVal;
            break;

        case YEAR:
            // Year will have been ITNed already
            SPDBG_ASSERT( VT_R8 == pProp->vValue.vt );
            stDate.wYear = (WORD) pProp->vValue.dblVal;

            fYear = true;
            if (( stDate.wYear < 10 ) && ( wcslen( pProp->pszValue ) >=2 ))
            {
                // Want to make sure "June zero one" does not 
                // become June 1 below
                fClearlyIntentionalYear = true;
            }

            break;

        default:
            SPDBG_ASSERT( false );
            break;
        }
    }

    // Make sure that grammar gave us something valid
    SPDBG_ASSERT( stDate.wMonth && 
        ( stDate.wDayOfWeek ? stDate.wDay : 1 ) );

    // Ambiguity workaround: Want to make sure that June 28 is June 28 and not June, '28
    if ( fYear && !fClearlyIntentionalYear && stDate.wMonth && !stDate.wDay && 
        (stDate.wYear >= 1) && (stDate.wYear <= 31) )
    {
        fYear = false;
        stDate.wDay = stDate.wYear;
        stDate.wYear = 0;
    }

    // Deal with the possible types of input
    if ( stDate.wDay )
    {
        if ( fYear )
        {
            if ( !stDate.wDayOfWeek )
            {
                // Remove the day of week from the current date format string.
                // This format picture can be DAYOFWEEK_STR or DAYOFWEEK_STR_ABBR.
                // This is in a loop since a pathological string could have 
                // more than one instance of the day of week...
                WCHAR *pwc = NULL;
                do
                {
                    pwc = wcsstr( pwszLongDateFormat, DAYOFWEEK_STR );
                    WCHAR pwszDayOfWeekStr[ MAX_LOCALE_DATA];
                    if ( pwc )
                    {
                        wcscpy( pwszDayOfWeekStr, DAYOFWEEK_STR );
                    }
                    else if ( NULL != (pwc = wcsstr( pwszLongDateFormat, DAYOFWEEK_STR_ABBR )) )
                    {
                        wcscpy( pwszDayOfWeekStr, DAYOFWEEK_STR_ABBR );
                    }

                    if ( pwc )
                    {
                        // A day-of-week string was found

                        // Copy over everything until this character info the format string
                        wcsncpy( pwszFormat, pwszLongDateFormat, (pwc - pwszLongDateFormat) );
                        pwszFormat[pwc - pwszLongDateFormat] = 0;
            
                        // Skip over the day of week until the next symbol
                        // (the way date format strings work, this is the first
                        // alphabetical symbol
                        pwc += wcslen( pwszDayOfWeekStr );
                        while ( *pwc && (!iswalpha( *pwc ) || (L'd' == *pwc)) )
                        {
                            pwc++;
                        }

                        // Copy over everything from here on out
                        wcscat( pwszFormat, pwc );

                        pwszFormatArg = pwszFormat;

                        // Copy over so that we can find the next day-of-week string
                        wcscpy( pwszLongDateFormat, pwszFormat );
                    }

                }   while ( pwc );
            }
            else
            {
                // The user did say the day of week
                if ( !wcsstr( pwszLongDateFormat, DAYOFWEEK_STR_ABBR ) )
                {
                    // The format string does not called for the day of week 
                    // being displayed anywhere
                    // In this case our best bet is to write out the day of week at 
                    // the beginning of the output
                    wcscpy( pwszFormat, L"dddd, " );
                    wcscat( pwszFormat, pwszLongDateFormat );

                    pwszFormatArg = pwszFormat;
                }
            }
        }
        else // fYear == 0
        {
            // Just a month and a day
            const SPPHRASEPROPERTY *pWhichComesFirst = pProperties;
            if ( stDate.wDayOfWeek )
            {
                wcscpy( pwszFormat, L"dddd, " );
                pWhichComesFirst = pWhichComesFirst->pNextSibling;
            }
            if ( MONTH == pWhichComesFirst->ulId )
            {
                wcscat( pwszFormat, L"MMMM d" );
            }
            else
            {
                wcscat( pwszFormat, L"d MMMM" );
            }

            pwszFormatArg = pwszFormat;
        }
    }
    else // stDate.wDay == 0
    {
        // Month, year format
        if ( fMonthFirst )
        {
            wcscpy( pwszFormat, L"MMMM, yyyy" );
        }
        else
        {
            wcscpy( pwszFormat, L"yyyy MMMM" );
        }

        pwszFormatArg = pwszFormat;
    }

    // Get the date in VariantTime form so we can set it as a semantic value
    int iRet = ::SystemTimeToVariantTime( &stDate, pdblVal );
    if ( 0 == iRet )
    {
        // Not serious, just the semantic value will be wrong
        *pdblVal = 0;
    }

    // Do the formatting
    iRet = FormatDate( stDate, pwszFormatArg, pszVal, cSize );
    if ( 0 == iRet )
    {
        return E_FAIL;
    }


    return S_OK;
}   /* CTestITN::InterpretDate */

/***********************************************************************
* CTestITN::InterpretTime *
*--------------------------*
*   Description:
*       Interprets time, which can be of the following forms:
*       *   Hour with qualifier ("half past three"), time marker optional
*       *   Hour with minutes, time marker mandatory
*       *   Military time "hundred hours"
*       *   Hour with "o'clock", time marker optional
*       *   Number of hours and number of minutes and optional number
*           of seconds
*   Return:
*       S_OK
*       E_POINTER if !pdblVal or !pszVal
*************************************************************************/
HRESULT CTestITN::InterpretTime( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal, 
                                WCHAR *pszVal, 
                                UINT cSize )
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }
    // Time marker and seconds should not be shown unless some
    // component of the time specifically requires it
    DWORD dwFlags = TIME_NOSECONDS | TIME_NOTIMEMARKER;
    SYSTEMTIME stTime;
    ::memset( (void *) &stTime, 0, sizeof( SYSTEMTIME ) );

    bool fQuarterTo = false;
    bool fClockTime = true;
    bool fAMPM = false;
    UINT uAMPM = AM; 

    const SPPHRASEPROPERTY *pProp;
    for ( pProp = pProperties; pProp; pProp = pProp->pNextSibling )
    {
        switch ( pProp->ulId )
        {
        case HOUR_CLOCK:
            {
                UINT uiHour = pProp->vValue.uiVal;
                SPDBG_ASSERT(( uiHour > 0 ) && ( uiHour <= 12));
                if ( fQuarterTo )
                {
                    // Push the hour back by one 
                    // (push back to 12 if it's one)
                    uiHour = (1 == uiHour) ? 12 : (uiHour - 1);
                }

                if ( 12 == uiHour )
                {
                    // The functions below are expecting "0" to indicate midnight
                    uiHour = 0;
                }

                stTime.wHour = (WORD) uiHour;
                break;
            }
        case HOUR_COUNT:
            // Just take the hour for what it is
            stTime.wHour = (WORD) pProp->vValue.dblVal;

            // This is not a clock time
            fClockTime = false;
            break;

        case MINUTE:
            {
                // Minutes are evaluted as numbers, so their values
                // are stored as doubles
                stTime.wMinute = (WORD) pProp->vValue.dblVal;
                break;
            }
        case SECOND:
            {
                stTime.wSecond = (WORD) pProp->vValue.dblVal;
                dwFlags &= ~TIME_NOSECONDS;
                break;
            }
        case CLOCKTIME_QUALIFIER:
            {
                switch( pProp->vValue.uiVal )
                {
                case QUARTER_TO:
                    {
                        fQuarterTo = true;
                        stTime.wMinute = 45;
                        break;
                    }
                case QUARTER_PAST:
                    {
                        stTime.wMinute = 15;
                        break;
                    }
                case HALF_PAST:
                    {
                        stTime.wMinute = 30;
                        break;
                    }
                default:
                    SPDBG_ASSERT( false );
                }

                break;
            }
        case AMPM:
            {
                // We don't know where it might arrive any more, so simple keep this information
                fAMPM = true;
                uAMPM = pProp->vValue.uiVal;
                break;
            }
        default:
            SPDBG_ASSERT( false );
        }
    }
	    
    if (fAMPM)
    {
		
        SPDBG_ASSERT(( stTime.wHour >= 0 ) && ( stTime.wHour <= 11 ));
        if ( PM == uAMPM )
        {
            stTime.wHour += 12;
        }
        dwFlags &= ~TIME_NOTIMEMARKER;
    }

    HRESULT hr = S_OK;
    if ( fClockTime )
    {
        // Get the time in VariantTime form so we can set it as a semantic value
        if ( 0 == ::SystemTimeToVariantTime( &stTime, pdblVal ) )
        {
            // Not serious, just the semantic value will be wrong
            *pdblVal = 0;
        }

        // Let the system format the time
        int iRet = m_Unicode.GetTimeFormat( LOCALE_USER_DEFAULT, dwFlags, &stTime, NULL, 
            pszVal, cSize );

        // NB: GetTimeFormat() will put an extra space at the end of the 
        // time if the default format has AM or PM but TIME_NOTIMEMARKER is
        // set
        if ( iRet && (TIME_NOTIMEMARKER & dwFlags) )
        {
            WCHAR *pwc = pszVal + wcslen( pszVal ) - 1;
            while ( iswspace( *pwc ) )
            {
                *pwc-- = 0;
            }
        }
        hr = iRet ? S_OK : E_FAIL;
    }
    else
    {
        // No need to go through the system's time formatter
        if ( cSize < 10 )    // Space for xxx:xx:xx\0
        {
            return E_INVALIDARG;
        }

        if ( dwFlags & TIME_NOSECONDS )
        {
            swprintf( pszVal, L"%d:%02d", stTime.wHour, stTime.wMinute );
        }
        else
        {
            swprintf( pszVal, L"%d:%02d:%02d", 
                stTime.wHour, stTime.wMinute, stTime.wSecond );
        }
    }

    return hr;
}   /* CTestITN::InterpretTime */

/***********************************************************************
* CTestITN::InterpretStateZip *
*-----------------------------*
*   Description:
*       A StateZip must be a state name followed by a ZIP code.
*       There is no reasonable semantic value to attach to this ITN.        
*   Return:
*       S_OK
*       E_POINTER if !pszVal
*       E_INVALIDARG if cSize is too small
*************************************************************************/
HRESULT CTestITN::InterpretStateZip( const SPPHRASEPROPERTY *pProperties,
                                    WCHAR *pszVal,
                                    UINT cSize,
                                    BYTE *pbAttribs )
{
    if ( !pszVal || !pProperties || !pbAttribs )
    {
        return E_POINTER;
    }
    if ( cSize < MAX_STATEZIP )
    {
        return E_INVALIDARG;
    }

    const SPPHRASEPROPERTY *pPropertiesComma = NULL;
    const SPPHRASEPROPERTY *pPropertiesState = NULL;
    const SPPHRASEPROPERTY *pPropertiesZipCode = NULL;
    const SPPHRASEPROPERTY *pPropertiesZipCodeExtra = NULL;
    const SPPHRASEPROPERTY *pPropertiesPtr;

    for(pPropertiesPtr=pProperties; pPropertiesPtr; pPropertiesPtr=pPropertiesPtr->pNextSibling)
    {
        if (COMMA == pPropertiesPtr->ulId )
            pPropertiesComma = pPropertiesPtr;
        else if ( (US_STATE == pPropertiesPtr->ulId ) || (CAN_PROVINCE == pPropertiesPtr->ulId ))
            pPropertiesState = pPropertiesPtr;
        else if (ZIPCODE == pPropertiesPtr->ulId )
            pPropertiesZipCode = pPropertiesPtr;
        else if (FOURDIGITS == pPropertiesPtr->ulId )
            pPropertiesZipCodeExtra = pPropertiesPtr;
    }

    // Comma after the city name if a comma was spoken
    if ( pPropertiesComma )
    {
        // Will want to consume leading spaces when this is displayed
        *pbAttribs |= SPAF_CONSUME_LEADING_SPACES;

        wcscpy( pszVal, L", " );
    }

    // Get the state name
    SPDBG_ASSERT( pPropertiesState );
    UINT uiState = pPropertiesState->vValue.uiVal;
    if ( US_STATE == pPropertiesState->ulId )
    {
        SPDBG_ASSERT( uiState < NUM_US_STATES );
        wcscat( pszVal, pPropertiesState->pszValue );
    }
    else if ( CAN_PROVINCE == pPropertiesState->ulId )
    {
        SPDBG_ASSERT( uiState < NUM_CAN_PROVINCES );
        wcscat( pszVal, pPropertiesState->pszValue );
    }
    else
    {
        SPDBG_ASSERT( false );
    }
    
    wcscat( pszVal, L" " );

    // Get the ZIP
    SPDBG_ASSERT( pPropertiesZipCode );
    wcscat( pszVal, pPropertiesZipCode->pszValue );

    // Get the ZIP+4 if it's there
    
    if ( pPropertiesZipCodeExtra )
    {
        wcscat( pszVal, L"-" );
        wcscat( pszVal, pPropertiesZipCodeExtra->pszValue );
    }

    return S_OK;
}   /* CTestITN::InterpretStateZip */

/***********************************************************************
* CTestITN::InterpretCanadaZip *
*------------------------------*
*   Description:
*       A CanadaZip must be Alpha/Num/Alpha Num/Alpha/Num
*       There is no reasonable semantic value to attach to this ITN.        
*   Return:
*       S_OK
*       E_POINTER if !pszVal
*       E_INVALIDARG if cSize is too small
*************************************************************************/
HRESULT CTestITN::InterpretCanadaZip( const SPPHRASEPROPERTY *pProperties,
                                    WCHAR *pszVal,
                                    UINT cSize )
{
    if ( !pszVal )
    {
        return E_POINTER;
    }
    if ( cSize < CANADIAN_ZIPSIZE )
    {
        return E_INVALIDARG;
    }

    int i;
    for ( i=0; i < 3; i++, pProperties = pProperties->pNextSibling )
    {
        SPDBG_ASSERT( pProperties );
        wcscat( pszVal, pProperties->pszValue );
    }
    wcscat( pszVal, L" " );
    for ( i=0; i < 3; i++, pProperties = pProperties->pNextSibling )
    {
        SPDBG_ASSERT( pProperties );
        wcscat( pszVal, pProperties->pszValue );
    }
    return S_OK;
}   /* CTestITN::InterpretStateZip */

/***********************************************************************
* CTestITN::InterpretPhoneNumber *
*--------------------------------*
*   Description:
*       Phone number      
*   Return:
*       S_OK
*       E_POINTER if !pszVal
*       E_INVALIDARG if cSize is too small
*************************************************************************/
HRESULT CTestITN::InterpretPhoneNumber( const SPPHRASEPROPERTY *pProperties,
                                       WCHAR *pszVal,
                                       UINT cSize )
{
    if ( !pProperties || !pszVal )
    {
        return E_POINTER;
    }

    if ( cSize < MAX_PHONE_NUMBER )
    {
        return E_INVALIDARG;
    }

    pszVal[0] = 0;

    if ( ONE_PLUS == pProperties->ulId )
    {
        SPDBG_ASSERT( pProperties->pNextSibling && 
            (AREA_CODE == pProperties->pNextSibling->ulId) );
        wcscat( pszVal, L"1-" );

        pProperties = pProperties->pNextSibling;
    }

    if ( AREA_CODE == pProperties->ulId )
    {
        SPDBG_ASSERT( pProperties->pNextSibling );

        wcscat( pszVal, L"(" );
        
        SPDBG_ASSERT( pProperties->pFirstChild );
        if ( DIGIT == pProperties->pFirstChild->ulId )
        {
            // Area code spelled out digit by digit
            if ( 4 != MakeDigitString( 
                pProperties->pFirstChild, pszVal + wcslen( pszVal ), 
                cSize - wcslen( pszVal ) ) )
            {
                return E_INVALIDARG;
            }
        }
        else
        {
            // 800 or 900
            SPDBG_ASSERT( AREA_CODE == pProperties->pFirstChild->ulId );
            wcscat( pszVal, pProperties->pFirstChild->pszValue );
        }

        wcscat( pszVal, L")-" );

        pProperties = pProperties->pNextSibling;
    }

    // Exchange
    SPDBG_ASSERT( PHONENUM_EXCHANGE == pProperties->ulId );
    SPDBG_ASSERT( pProperties->pFirstChild );
    if ( 4 != MakeDigitString( 
        pProperties->pFirstChild, pszVal + wcslen( pszVal ), 
        cSize - wcslen( pszVal ) ) )
    {
        return E_INVALIDARG;
    }
    wcscat( pszVal, L"-");
    SPDBG_ASSERT( pProperties->pNextSibling );
    pProperties = pProperties->pNextSibling;

    SPDBG_ASSERT( FOURDIGITS == pProperties->ulId );
    SPDBG_ASSERT( pProperties->pFirstChild );
    if ( 5 != MakeDigitString( 
        pProperties->pFirstChild, pszVal + wcslen( pszVal ), 
        cSize - wcslen( pszVal ) ) )
    {
        return E_INVALIDARG;
    }
    pProperties = pProperties->pNextSibling;

    if ( pProperties )
    {
        // extension
        SPDBG_ASSERT( EXTENSION == pProperties->ulId );
        SPDBG_ASSERT( pProperties->pFirstChild );
        wcscat( pszVal, L"x" );
        if ( 0 == MakeDigitString( 
            pProperties->pFirstChild, pszVal + wcslen( pszVal ), 
            cSize - wcslen( pszVal ) ) )
        {
            return E_INVALIDARG;
        }
        
        pProperties = pProperties->pNextSibling;
    }

    // Make sure there's nothing else here!
    SPDBG_ASSERT( !pProperties );

    return S_OK;
}   /* CTestITN::InterpretPhoneNumber */

/***********************************************************************
* CTestITN::InterpretDegrees *
*----------------------------*
*   Description:
*       Interprets degrees as a temperature, angle-measurement,
*       or direction, as appropriate.
*   Return:
*       S_OK
*       E_POINTER
*       E_INVALIDARG
*************************************************************************/
HRESULT CTestITN::InterpretDegrees( const SPPHRASEPROPERTY *pProperties,
                                   DOUBLE *pdblVal, 
                                   WCHAR *pszVal,
                                   UINT cSize )
{
    if ( !pProperties || !pdblVal || !pszVal )
    {
        return E_POINTER;
    }

    *pszVal = 0;

    const SPPHRASEPROPERTY *pPropertiesDegree = NULL;
    const SPPHRASEPROPERTY *pPropertiesMinute = NULL;
    const SPPHRASEPROPERTY *pPropertiesSecond = NULL;
    const SPPHRASEPROPERTY *pPropertiesDirection = NULL;
    const SPPHRASEPROPERTY *pPropertiesUnit = NULL;
    const SPPHRASEPROPERTY *pPropertiesPtr;
    // Get the number

    for(pPropertiesPtr=pProperties; pPropertiesPtr; pPropertiesPtr=pPropertiesPtr->pNextSibling)
    {
        if (TEMP_UNITS == pPropertiesPtr->ulId )
            pPropertiesUnit = pPropertiesPtr;
        else if ( (GRID_INTEGER_NONNEG == pPropertiesPtr->ulId ) || (NUMBER == pPropertiesPtr->ulId ))
            pPropertiesDegree = pPropertiesPtr;
        else if (MINUTE == pPropertiesPtr->ulId )
            pPropertiesMinute = pPropertiesPtr;
        else if (SECOND == pPropertiesPtr->ulId )
            pPropertiesSecond = pPropertiesPtr;
        else if (DIRECTION == pPropertiesPtr->ulId )
            pPropertiesDirection = pPropertiesPtr;
    }

    SPDBG_ASSERT( pPropertiesDegree );
    *pdblVal = pPropertiesDegree->vValue.dblVal;
    wcscat( pszVal, pPropertiesDegree->pszValue );
    wcscat( pszVal, L"" );  

    if ( pPropertiesUnit )
    { 
        wcscat( pszVal, pPropertiesUnit->pszValue );
    }
    if ( pPropertiesMinute || pPropertiesSecond)
    {
        SPDBG_ASSERT( *pdblVal >= 0 );
        
        if ( pPropertiesMinute )
        {
            DOUBLE dblMin = pPropertiesMinute->vValue.dblVal;
            *pdblVal += dblMin / (DOUBLE) 60;
            wcscat( pszVal, pPropertiesMinute->pszValue );
            wcscat( pszVal, L"'" );
        }

        if ( pPropertiesSecond )
        {
            DOUBLE dblSec = pPropertiesSecond->vValue.dblVal;
            *pdblVal += dblSec / (DOUBLE) 3600;
            wcscat( pszVal, pPropertiesSecond->pszValue );
            wcscat( pszVal, L"''" );
        }
    }

    if ( pPropertiesDirection )
    {
        wcscat( pszVal, pPropertiesDirection->pszValue );
    }
        


    return S_OK;
}   /* CTestITN::InterpretDegrees */

/***********************************************************************
* CTestITN::InterpretMeasurement *
*--------------------------------*
*   Description:
*       Interprets measurements, which is a number followed
*       by a units name
*   Return:
*       S_OK
*       E_POINTER
*       E_INVALIDARG
*************************************************************************/
HRESULT CTestITN::InterpretMeasurement( const SPPHRASEPROPERTY *pProperties,
                                       DOUBLE *pdblVal,
                                       WCHAR *pszVal, 
                                       UINT cSize )
{
    if ( !pProperties || !pdblVal || !pszVal )
    {
        return E_POINTER;
    }

    const SPPHRASEPROPERTY *pPropNumber = NULL;
    const SPPHRASEPROPERTY *pPropUnits = NULL;
    const SPPHRASEPROPERTY *pProp;
    for(pProp= pProperties; pProp; pProp = pProp->pNextSibling)
    {
        if (NUMBER == pProp->ulId )
            pPropNumber = pProp;
        else if ( UNITS == pProp->ulId )
            pPropUnits = pProp;
    }

    if (!pPropNumber || !pPropUnits)
    {
        SPDBG_ASSERT( FALSE );
        return E_INVALIDARG;
    }

    if ( cSize < (wcslen(pPropNumber->pszValue) + wcslen(pPropUnits->pszValue) + 1) )
    {
        // Not enough space
        return E_INVALIDARG;
    }

    wcscpy( pszVal, pPropNumber->pszValue );
    wcscat( pszVal, pPropUnits->pszValue );

    *pdblVal = pPropNumber->vValue.dblVal;

    return S_OK;
}   /* CTestITN::InterpretMeasurement */

/***********************************************************************
* CTestITN::InterpretCurrency *
*-----------------------------*
*   Description:
*       Interprets currency.
*   Return:
*       S_OK
*       E_POINTER if !pdblVal or !pszVal
*       E_INVALIDARG if the number of cents is not between 0 and 99 
*           inclusive
*************************************************************************/
HRESULT CTestITN::InterpretCurrency( const SPPHRASEPROPERTY *pProperties,
                                        DOUBLE *pdblVal,
                                        WCHAR *pszVal,
                                        UINT cSize)
{
    if ( !pdblVal || !pszVal || !pProperties )
    {
        return E_POINTER;
    }

    const SPPHRASEPROPERTY *pPropDollars = NULL;
    const SPPHRASEPROPERTY *pPropCents = NULL;
    const SPPHRASEPROPERTY *pPropType = NULL;
    const SPPHRASEPROPERTY *pPropSmallType = NULL;
    const SPPHRASEPROPERTY *pPropNegative = NULL;
    const SPPHRASEPROPERTY *pProp;
    for(pProp= pProperties; pProp; pProp = pProp->pNextSibling)
    {
        if (NEGATIVE == pProp->ulId )
            pPropNegative = pProp;
        else if ( DOLLARS == pProp->ulId )
            pPropDollars = pProp;
        else if ( CENTS == pProp->ulId )
            pPropCents = pProp;
        else if ( CURRENCY_TYPE == pProp->ulId )
            pPropType = pProp;
        else if ( CURRENCY_SMALL_TYPE == pProp->ulId )
            pPropSmallType = pProp;
    }

    *pszVal = 0;
    *pdblVal = 0;

    bool fNonNegative = true;
    if ( pPropNegative )
    {
        fNonNegative = false;
    }

    bool fUseDefaultCurrencySymbol = true;

    if ( pPropDollars )
    {
        // If "dollars" was said, override the default currency symbol
        if ( pPropType )
        {
            fUseDefaultCurrencySymbol = false;
        }
    }

    if ( pPropDollars )
    {
        // Dollars and possibly cents will be here, so we want to 
        // use regional format
        HRESULT hr = GetCurrencyFormatDefaults();
        if ( FAILED( hr ) )
        {
            return hr;
        }

        *pdblVal = pPropDollars->vValue.dblVal;

        // Handle the case of "$5 million".  If this should happen, there
        // will be some alphabetic string in the string value for the number,
        // and there will be no cents
        if ( !pPropCents )
        {
            WCHAR *pwc = wcsstr( pPropDollars->pszValue, MILLION_STR );
            if ( !pwc )
            {
                pwc = wcsstr( pPropDollars->pszValue, BILLION_STR );
            }

            if ( pwc )
            {
                // Either "million" or "billion" was in there

                // Just a dollar sign followed by the number string value
                if ( !fNonNegative )
                {
                    wcscpy( pszVal, m_pwszNeg );
                    *pdblVal = -*pdblVal;
                }
                wcscat( pszVal, pPropType->pszValue );
                wcscat( pszVal, pPropDollars->pszValue );
                return S_OK;
            }
        }

        // Use the associated currency symbol
        if ( !fUseDefaultCurrencySymbol )
        {
            wcscpy( m_pwszCurrencySym, pPropType->pszValue );
            m_cyfmtDefault.lpCurrencySymbol = m_pwszCurrencySym;
        }
        // else... use the currency symbol obtained in GetCurrencyFormatDefaults()

        if ( pPropCents )
        {
            SPDBG_ASSERT( (pPropCents->vValue.dblVal >= 0) && 
                (pPropCents->vValue.dblVal < 100) );
            DOUBLE dblCentsVal = pPropCents->vValue.dblVal / (DOUBLE) 100;
            if ( *pdblVal >= 0 )
            {
                *pdblVal += dblCentsVal;
            }
            else
            {
                *pdblVal -= dblCentsVal;
            }
        }
        else
        {
            // count up number of decimal places.
            // Need to use the original formatted number
            // in case someone explicitly gave some zeroes
            // as significant digits
            const WCHAR *pwszNum = pPropDollars->pszValue;
            WCHAR pwszNumDecimalSep[ MAX_LOCALE_DATA ];
            *pwszNumDecimalSep = 0;
            int iRet = m_Unicode.GetLocaleInfo( 
                ::GetUserDefaultLCID(), LOCALE_SDECIMAL, pwszNumDecimalSep, MAX_LOCALE_DATA );
            WCHAR *pwc = wcsstr( pwszNum, pwszNumDecimalSep );

            UINT cDigits = 0;
            if ( pwc && iRet )
            {
                for ( pwc = pwc + 1; *pwc && iswdigit( *pwc ); pwc++ )
                {
                    cDigits++;
                }
            }
            m_cyfmtDefault.NumDigits = __max( m_cyfmtDefault.NumDigits, cDigits );
        }

        // Handle the negative sign in the value
        if ( !fNonNegative )
        {
            *pdblVal = -*pdblVal;
        }
        
        // Write the unformatted number to a string
        WCHAR *pwszUnformatted = new WCHAR[ cSize ];
        if ( !pwszUnformatted )
        {
            return E_OUTOFMEMORY;
        }
        swprintf( pwszUnformatted, L"%f", *pdblVal );
    

        int iRet = m_Unicode.GetCurrencyFormat( LOCALE_USER_DEFAULT, 0, pwszUnformatted,
            &m_cyfmtDefault, pszVal, cSize );
        delete[] pwszUnformatted;

        if ( !iRet )
        {
            return E_FAIL;
        }
    }
    else
    {
        // Just cents: better have said "cents"
        SPDBG_ASSERT( pPropSmallType );

        *pdblVal = pPropCents->vValue.dblVal / (DOUBLE) 100;

        // Cents are always displayed as 5c, regardless of locale settings.

        // Copy over the formatted number
        wcscpy( pszVal, pPropCents->pszValue );

        // Add on the cents symbol
        wcscat( pszVal, pPropSmallType->pszValue );
    }

    return S_OK;
}   /* CTestITN::InterpretCurrency */

/***********************************************************************
* CTestITN::AddPropertyAndReplacement *
*-------------------------------------*
*   Description:
*       Takes all of the info that we want to pass into the 
*       engine site, forms the SPPHRASEPROPERTY and
*       SPPHRASERREPLACEMENT, and adds them to the engine site
*   Return:
*       Return values of ISpCFGInterpreterSite::AddProperty()
*           and ISpCFGInterpreterSite::AddTextReplacement()
*************************************************************************/
HRESULT CTestITN::AddPropertyAndReplacement( const WCHAR *szBuff,
                                    const DOUBLE dblValue,
                                    const ULONG ulMinPos,
                                    const ULONG ulMaxPos,
                                    const ULONG ulFirstElement,
                                    const ULONG ulCountOfElements,
                                    const BYTE bDisplayAttribs )
{
    // Add the property 
    SPPHRASEPROPERTY prop;
    memset(&prop,0,sizeof(prop));
    prop.pszValue = szBuff;
    prop.vValue.vt = VT_R8;
    prop.vValue.dblVal = dblValue;
    prop.ulFirstElement = ulMinPos;
    prop.ulCountOfElements = ulMaxPos - ulMinPos;
    HRESULT hr = m_pSite->AddProperty(&prop);

    if (SUCCEEDED(hr))
    {
        SPPHRASEREPLACEMENT repl;
        memset(&repl,0, sizeof(repl));
        repl.bDisplayAttributes = bDisplayAttribs;
        repl.pszReplacementText = szBuff;
        repl.ulFirstElement = ulFirstElement;
        repl.ulCountOfElements = ulCountOfElements;
        hr = m_pSite->AddTextReplacement(&repl);
    }

    return hr;
}   /* CTestITN::AddPropertyAndReplacement */

// Helper functions

 
/***********************************************************************
* CTestITN::MakeDisplayNumber *
*-----------------------------*
*   Description:
*       Converts a DOUBLE into a displayable
*       number in the range -999,999,999,999 to +999,999,999,999.
*       cSize is the number of chars for which pwszNum has space
*       allocated.
*       If DF_UNFORMATTED is set, all other flags are ignored,
*           and the number is passed back as an optional negative
*           followed by a string of digits
*       If DF_ORDINAL is set in dwDisplayFlags, displays an
*           ordinal number (i.e. tacks on "th" or the appropriate suffix.
*       If DF_WHOLENUMBER is set, lops off the decimal separator
*           and everything after it.  If DF_WHOLENUMBER is not set,
*           then uses the uiDecimalPlaces parameter to determine
*           how many decimal places to display
*       If DF_FIXEDWIDTH is set, will display at least uiFixedWidth
*           digits; otherwise uiFixedWidth is ignored.
*       If DF_NOTHOUSANDSGROUP is set, will not do thousands
*           grouping (commas)
*************************************************************************/
HRESULT CTestITN::MakeDisplayNumber( DOUBLE dblNum, 
                         DWORD dwDisplayFlags,
                         UINT uiFixedWidth,
                         UINT uiDecimalPlaces,
                         WCHAR *pwszNum,
                         UINT cSize )
{
    SPDBG_ASSERT( pwszNum );
    SPDBG_ASSERT( !SPIsBadWritePtr( pwszNum, cSize ) );
    *pwszNum = 0;

    // Get the default number formatting.
    // Note that this gets called every time, since otherwise there
    // is no way to pick up changes that the user has made since
    // this process has started.
    HRESULT hr = GetNumberFormatDefaults();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    // check for straight millions and straight billions
    // NB: This is a workaround for the fact that we can't resolve the ambiguity
    // and get "two million" to go through GRID_INTEGER_MILLBILL
    if (( dwDisplayFlags & DF_WHOLENUMBER ) && ( dwDisplayFlags & DF_MILLIONBILLION ) && (dblNum > 0))
    {
        HRESULT hr;
        if ( 0 == (( ((LONGLONG) dblNum) % BILLION )) )
        {
            // e.g. for "five billion" get the "5" and then 
            // tack on " billion"
            hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) BILLION) ), 
                dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize );
            if ( SUCCEEDED( hr ) )
            {
                wcscat( pwszNum, L" " );
                wcscat( pwszNum, BILLION_STR );
            }
            return hr;
        }
        else if (( ((LONGLONG) dblNum) < BILLION ) && 
                ( 0 == (( ((LONGLONG) dblNum) % MILLION )) ))
        {
            hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) MILLION) ), 
                dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize );
            if ( SUCCEEDED( hr ) )
            {
                wcscat( pwszNum, L" " );
                wcscat( pwszNum, MILLION_STR );
            }
                return hr;
        }
    }

    // Put in the negative sign if necessary
    if ( dblNum < 0 )
    {
        wcscat( pwszNum, L"-" );

        // From now on we want to deal with the magnitude of the number
        dblNum *= -1;
    }
    SPDBG_ASSERT( dblNum < 1e12 );

    WCHAR *pwszTemp = new WCHAR[ cSize ];
    if ( !pwszTemp )
    {
        return E_OUTOFMEMORY;
    }
    *pwszTemp = 0;

    LONGLONG llIntPart = (LONGLONG) dblNum;
    UINT64 uiDigitsLeftOfDecimal;
    if ( dwDisplayFlags & DF_WHOLENUMBER )
    {
        swprintf( pwszTemp, L"%I64d", llIntPart );
        uiDigitsLeftOfDecimal = wcslen( pwszTemp );
    }
    else
    {
        swprintf( pwszTemp, L"%.*f", uiDecimalPlaces, dblNum );
        WCHAR *pwc = wcschr( pwszTemp, L'.' );
        uiDigitsLeftOfDecimal = pwc - pwszTemp;
    }
    
    // The following handles the case where the user said something
    // like "zero zero zero three" and wants to see "0,003"
    BOOL fChangedFirstDigit = false;
    const WCHAR wcFakeFirstDigit = L'1';
    if ( !(dwDisplayFlags & DF_UNFORMATTED) && 
        (dwDisplayFlags & DF_FIXEDWIDTH) && (uiDigitsLeftOfDecimal < uiFixedWidth) )
    {
        // The following handles the case where the user wants leading 
        // zeroes displayed
        
        // Need to pad the front with zeroes
        for ( UINT ui = 0; ui < (uiFixedWidth - uiDigitsLeftOfDecimal); ui++ )
        {
            wcscat( pwszNum, L"0" );
        }
        
        // HACK
        // In order to force something like "zero zero zero three" 
        // into the form "0,003", we need to make GetNumberFormat() 
        // think that the first digit is 1.
        WCHAR *pwc = wcschr( pwszNum, L'0' );
        SPDBG_ASSERT( pwc );
        *pwc = wcFakeFirstDigit;
        fChangedFirstDigit = true;
    }

    // Copy over the unformatted number after the possible negative sign
    wcscat( pwszNum, pwszTemp );
    delete[] pwszTemp;

    // If we do not want to format the number, then bail here
    if ( dwDisplayFlags & DF_UNFORMATTED )
    {
        return S_OK;
    }

    // Make a copy so that we can change some fields according to the 
    // flags param
    NUMBERFMTW nmfmt = m_nmfmtDefault;

    // How many decimal places to display?
    if ( dwDisplayFlags & DF_WHOLENUMBER )
    {
        nmfmt.NumDigits = 0;
    }
    else
    {
        // Use the uiDecimalPlaces value to determine how
        // many to display
        nmfmt.NumDigits = uiDecimalPlaces;
    }
    
    // Leading zeroes?
    nmfmt.LeadingZero = (dwDisplayFlags & DF_LEADINGZERO) ? 1 : 0;

    // Thousands grouping?
    if ( dwDisplayFlags & DF_NOTHOUSANDSGROUP )
    {
        nmfmt.Grouping = 0;
    }

    // Format the number string
    WCHAR *pwszFormattedNum = new WCHAR[ cSize ];
    if ( !pwszFormattedNum )
    {
        return E_OUTOFMEMORY;
    }
    *pwszFormattedNum = 0;

    int iRet;
    do
    {
        iRet = m_Unicode.GetNumberFormat( LOCALE_USER_DEFAULT, 0, 
            pwszNum, &nmfmt, pwszFormattedNum, cSize );
        if ( !iRet && nmfmt.NumDigits )
        {
            // Try displaying fewer digits
            nmfmt.NumDigits--;
        }
    }   while ( !iRet && nmfmt.NumDigits );
    SPDBG_ASSERT( iRet );

    // Copy the formatted number into pwszNum
    wcscpy( pwszNum, pwszFormattedNum );
    delete[] pwszFormattedNum;

    // This undoes the hack of changing the first digit
    if ( fChangedFirstDigit )
    {
        // We need to find the first digit and change it back to zero
        WCHAR *pwc = wcschr( pwszNum, wcFakeFirstDigit );
        SPDBG_ASSERT( pwc );
        *pwc = L'0';
    }

    if ( dwDisplayFlags & DF_ORDINAL )
    {
        SPDBG_ASSERT( dwDisplayFlags & DF_WHOLENUMBER );    // sanity

        // This is an ordinal number, tack on the appropriate suffix
        
        // The "st", "nd", "rd" endings only happen when you
        // don't have something like "twelfth"
        if ( ((llIntPart % 100) < 10) || ((llIntPart % 100) > 20) )
        {
            switch ( llIntPart % 10 )
            {
            case 1:
                wcscat( pwszNum, L"st" );
                break;
            case 2:
                wcscat( pwszNum, L"nd" );
                break;
            case 3:
                wcscat( pwszNum, L"rd" );
                break;
            default:
                wcscat( pwszNum, L"th" );
                break;
            }
        }
        else
        {
            wcscat( pwszNum, L"th" );
        }
    }

    return S_OK;

}   /* CTestITN::MakeDisplayNumber */

/***********************************************************************
* CTestITN::MakeDigitString *
*---------------------------*
*   Description:
*       Called when we want to convert a string of DIGITs into
*       a string but don't care about its value
*   Return: 
*       Number of digits written to the string, including nul
*       character
*************************************************************************/
int CTestITN::MakeDigitString( const SPPHRASEPROPERTY *pProperties,
                              WCHAR *pwszDigitString,
                              UINT cSize )
{
    if ( !pProperties || !pwszDigitString )
    {
        return 0;
    }

    UINT cCount = 0;
    for ( ; pProperties; pProperties = pProperties->pNextSibling )
    {
        if ( DIGIT != pProperties->ulId )
        {
            return 0;
        }

        if ( cSize-- <= 0 )
        {
            // Not enough space
            return 0;
        }
        pwszDigitString[ cCount++ ] = pProperties->pszValue[0];
    }

    pwszDigitString[ cCount++ ] = 0;

    return cCount;
}   /* CTestITN::MakeDigitString */

/***********************************************************************
* CTestITN::GetNumberFormatDefaults *
*-----------------------------------*
*   Description:
*       This finds all of the defaults for formatting numbers for
*        this user.
*************************************************************************/
HRESULT CTestITN::GetNumberFormatDefaults()
{
    LCID lcid = ::GetUserDefaultLCID();
    WCHAR pwszLocaleData[ MAX_LOCALE_DATA ];
    
    int iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_IDIGITS, pwszLocaleData, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_nmfmtDefault.NumDigits = _wtoi( pwszLocaleData );    
    
    iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_ILZERO, pwszLocaleData, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    // It's always either 0 or 1
    m_nmfmtDefault.LeadingZero = _wtoi( pwszLocaleData );

    iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_SGROUPING, pwszLocaleData, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    // It will look like single_digit;0, or else it will look like
    // 3;2;0
    UINT uiGrouping = *pwszLocaleData - L'0';
    if ( (3 == uiGrouping) && (L';' == pwszLocaleData[1]) && (L'2' == pwszLocaleData[2]) )
    {
        uiGrouping = 32;   
    }
    m_nmfmtDefault.Grouping = uiGrouping;

    iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_SDECIMAL, m_pwszDecimalSep, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_nmfmtDefault.lpDecimalSep = m_pwszDecimalSep;

    iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_STHOUSAND, m_pwszThousandSep, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_nmfmtDefault.lpThousandSep = m_pwszThousandSep;

    iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_INEGNUMBER, pwszLocaleData, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_nmfmtDefault.NegativeOrder = _wtoi( pwszLocaleData );

    // Get the negative sign
    delete[] m_pwszNeg;
    iRet = m_Unicode.GetLocaleInfo( LOCALE_USER_DEFAULT, 
        LOCALE_SNEGATIVESIGN, NULL, 0);
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_pwszNeg = new WCHAR[ iRet ];
    if ( !m_pwszNeg )
    {
        return E_OUTOFMEMORY;
    }
    iRet = m_Unicode.GetLocaleInfo( LOCALE_USER_DEFAULT, 
        LOCALE_SNEGATIVESIGN, m_pwszNeg, iRet );

    return iRet ? S_OK : E_FAIL;
}   /* CTestITN::GetNumberFormatDefaults */

/***********************************************************************
* CTestITN::GetCurrencyFormatDefaults *
*-----------------------------------*
*   Description:
*       This finds all of the defaults for formatting numbers for
*        this user.
*************************************************************************/
HRESULT CTestITN::GetCurrencyFormatDefaults()
{
    LCID lcid = ::GetUserDefaultLCID();
    WCHAR pwszLocaleData[ MAX_LOCALE_DATA ];
    
    int iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_ICURRDIGITS, pwszLocaleData, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_cyfmtDefault.NumDigits = _wtoi( pwszLocaleData );    

    // NB: A value of zero is bogus for LOCALE_ILZERO, since
    // currency should always display leading zero
    m_cyfmtDefault.LeadingZero = 1;

    iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_SMONGROUPING, pwszLocaleData, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    // It will look like single_digit;0, or else it will look like
    // 3;2;0
    UINT uiGrouping = *pwszLocaleData - L'0';
    if ( (3 == uiGrouping) && (L';' == pwszLocaleData[1]) && (L'2' == pwszLocaleData[2]) )
    {
        uiGrouping = 32;   
    }
    m_cyfmtDefault.Grouping = uiGrouping;

    iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_SMONDECIMALSEP, m_pwszDecimalSep, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_cyfmtDefault.lpDecimalSep = m_pwszDecimalSep;

    iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_SMONTHOUSANDSEP, m_pwszThousandSep, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_cyfmtDefault.lpThousandSep = m_pwszThousandSep;

    iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_INEGCURR, pwszLocaleData, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_cyfmtDefault.NegativeOrder = _wtoi( pwszLocaleData );

    iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_ICURRENCY, pwszLocaleData, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_cyfmtDefault.PositiveOrder = _wtoi( pwszLocaleData );

    iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_SCURRENCY, m_pwszCurrencySym, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    m_cyfmtDefault.lpCurrencySymbol = m_pwszCurrencySym;


    return S_OK;
}   /* CTestITN::GetCurrencyFormatDefaults */

/***********************************************************************
* CTestITN::ComputeNum999 *
*-------------------------*
*   Description:
*       Converts a set of SPPHRASEPROPERTYs into a number in
*       [-999, 999].
*       The way these properties is structured is that the top-level 
*       properties contain the place of the number (100s, 10s, 1s)
*       by having the value 100, 10, or 1.
*       The child has the appropriate number value.
*   Return:
*       Value of the number
*************************************************************************/
ULONG CTestITN::ComputeNum999(const SPPHRASEPROPERTY *pProperties )//, ULONG *pVal)
{
    ULONG ulVal = 0;

    for (const SPPHRASEPROPERTY * pProp = pProperties; pProp; pProp = pProp->pNextSibling)
    {
        if ( ZERO != pProp->ulId )
        {
            SPDBG_ASSERT( pProp->pFirstChild );
            SPDBG_ASSERT( VT_UI4 == pProp->vValue.vt );
            SPDBG_ASSERT( VT_UI4 == pProp->pFirstChild->vValue.vt );

            ulVal += pProp->pFirstChild->vValue.ulVal * pProp->vValue.ulVal;
        }
    }
    return ulVal;
}   /* CTestITN::ComputeNum999 */

/***********************************************************************
* CTestITN::HandleDigitsAfterDecimal *
*------------------------------------*
*   Description:
*       If pwszRightOfDecimal is NULL, then cuts off all of the numbers
*       following the decimal separator.
*       Otherwise, copies pwszRightOfDecimal right after the decimal
*       separator in pwszFormattedNum.
*       Preserves the stuff after the digits in the pwszFormattedNum
*       (e.g. if pwszFormattedNum starts out "(3.00)" and 
*       pwszRightOfDecimal is NULL, then pwszFormattedNum will end
*       up as "(3)"  
*************************************************************************/
void CTestITN::HandleDigitsAfterDecimal( WCHAR *pwszFormattedNum, 
                              UINT cSizeOfFormattedNum, 
                              const WCHAR *pwszRightOfDecimal )
{
    SPDBG_ASSERT( pwszFormattedNum );
 
    // First need to find what the decimal string is
    LCID lcid = ::GetUserDefaultLCID();
    WCHAR pwszDecimalString[ MAX_LOCALE_DATA ];    // Guaranteed to be no longer than 4 long
    int iRet = m_Unicode.GetLocaleInfo( lcid, LOCALE_SDECIMAL, 
        pwszDecimalString, MAX_LOCALE_DATA );
    SPDBG_ASSERT( iRet );

    WCHAR *pwcDecimal = wcsstr( pwszFormattedNum, pwszDecimalString );
    SPDBG_ASSERT( pwcDecimal );

    // pwcAfterDecimal points to the first character after the decimal separator
    WCHAR *pwcAfterDecimal = pwcDecimal + wcslen( pwszDecimalString );

    // Remember what originally followed the digits
    WCHAR *pwszTemp = new WCHAR[ cSizeOfFormattedNum ];
    WCHAR *pwcAfterDigits;  // points to the first character after the end of the digits
    for ( pwcAfterDigits = pwcAfterDecimal; 
        *pwcAfterDigits && iswdigit( *pwcAfterDigits ); 
        pwcAfterDigits++ )
        ;
    wcscpy( pwszTemp, pwcAfterDigits ); // OK if *pwcAfterDigits == 0

    if ( pwszRightOfDecimal )
    {
        // This means that the caller wants the digits in pwszRightOfDecimal
        // copied after the decimal separator

        // Copy the decimal string after the decimal separater
        wcscpy( pwcAfterDecimal, pwszRightOfDecimal );

    }
    else
    {
        // This means that the caller wanted the decimal separator
        // and all text following it stripped off

        *pwcDecimal = 0;
    }

    // Add on the extra after-digit characters
    wcscat( pwszFormattedNum, pwszTemp );

    delete[] pwszTemp;

}   /* CTestITN::HandleDigitsAfterDecimal */


/***********************************************************************
* CTestITN::GetMinAndMaxPos *
*---------------------------*
*   Description:
*       Gets the minimum and maximum elements spanned by the 
*       set of properties
*************************************************************************/
void CTestITN::GetMinAndMaxPos( const SPPHRASEPROPERTY *pProperties, 
                     ULONG *pulMinPos, 
                     ULONG *pulMaxPos )
{
    if ( !pulMinPos || !pulMaxPos )
    {
        return;
    }
    ULONG ulMin = 9999999;
    ULONG ulMax = 0;

    for ( const SPPHRASEPROPERTY *pProp = pProperties; pProp; pProp = pProp->pNextSibling )
    {
        ulMin = __min( ulMin, pProp->ulFirstElement );
        ulMax = __max( ulMax, pProp->ulFirstElement + pProp->ulCountOfElements );
    }
    *pulMinPos = ulMin;
    *pulMaxPos = ulMax;
}   /* CTestITN::GetMinAndMaxPos */

/***********************************************************************
* CTestITN::GetMonthName *
*------------------------*
*   Description:
*       Gets the name of the month, abbreviated if desired
*   Return:
*       Number of characters written to pszMonth, 0 if failed
*************************************************************************/
int CTestITN::GetMonthName( int iMonth, WCHAR *pwszMonth, int cSize, bool fAbbrev )
{
    LCTYPE lctype;
    switch ( iMonth )
    {
    case 1:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME1 : LOCALE_SMONTHNAME1;
        break;
    case 2:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME2 : LOCALE_SMONTHNAME2;
        break;
    case 3:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME3 : LOCALE_SMONTHNAME3;
        break;
    case 4:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME4 : LOCALE_SMONTHNAME4;
        break;
    case 5:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME5 : LOCALE_SMONTHNAME5;
        break;
    case 6:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME6 : LOCALE_SMONTHNAME6;
        break;
    case 7:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME7 : LOCALE_SMONTHNAME7;
        break;
    case 8:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME8 : LOCALE_SMONTHNAME8;
        break;
    case 9:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME9 : LOCALE_SMONTHNAME9;
        break;
    case 10:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME10 : LOCALE_SMONTHNAME10;
        break;
    case 11:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME11 : LOCALE_SMONTHNAME11;
        break;
    case 12:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME12 : LOCALE_SMONTHNAME12;
        break;
    default:
        return 0;
    }

    int iRet = m_Unicode.GetLocaleInfo( LOCALE_USER_DEFAULT, lctype, pwszMonth, cSize );

    return iRet;
}   /* CTestITN::GetMonthName */

/***********************************************************************
* CTestITN::GetDayOfWeekName *
*----------------------------*
*   Description:
*       Gets the name of the day of week, abbreviated if desired
*   Return:
*       Number of characters written to pszDayOfWeek, 0 if failed
*************************************************************************/
int CTestITN::GetDayOfWeekName( int iDayOfWeek, 
                               WCHAR *pwszDayOfWeek, 
                               int cSize, 
                               bool fAbbrev )
{
    LCTYPE lctype;
    switch ( iDayOfWeek )
    {
    case 1:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME1 : LOCALE_SDAYNAME1;
        break;
    case 2:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME2 : LOCALE_SDAYNAME2;
        break;
    case 3:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME3 : LOCALE_SDAYNAME3;
        break;
    case 4:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME4 : LOCALE_SDAYNAME4;
        break;
    case 5:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME5 : LOCALE_SDAYNAME5;
        break;
    case 6:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME6 : LOCALE_SDAYNAME6;
        break;
    case 7:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME7 : LOCALE_SDAYNAME7;
        break;
    default:
        return 0;
    }

    int iRet = m_Unicode.GetLocaleInfo( LOCALE_USER_DEFAULT, lctype, 
        pwszDayOfWeek, cSize );

    return iRet;
}   /* CTestITN::GetMonthName */

/***********************************************************************
* CTestITN::FormatDate *
*----------------------*
*   Description:
*       Uses the format string to format a SYSTEMTIME date.
*       We are using this instead of GetDateFormat() since
*       we also want to format bogus dates and dates with 
*       years like 1492 that are not accepted by GetDateFormat()
*   Return:
*       Number of characters written to pszDate (including
*       null terminating character), 0 if failed
*************************************************************************/
int CTestITN::FormatDate( const SYSTEMTIME &stDate, 
               WCHAR *pwszFormat,
               WCHAR *pwszDate, 
               int cSize )
{
    if ( !pwszFormat || !pwszDate )
    {
        SPDBG_ASSERT( FALSE );
        return 0;
    }

    WCHAR * const pwszDateStart = pwszDate;

    WCHAR *pwc = pwszFormat;

    // Copy the format string to the date string character by 
    // character, replacing the string like "dddd" as appropriate
    while ( *pwc )
    {
        switch( *pwc )
        {
        case L'd':
            {
                // Count the number of d's
                int cNumDs = 0;
                int iRet;
                do
                {
                    pwc++;
                    cNumDs++;
                }   while ( L'd' == *pwc );
                switch ( cNumDs )
                {
                case 1: 
                    // Day with no leading zeroes
                    swprintf( pwszDate, L"%d", stDate.wDay );
                    iRet = wcslen( pwszDate );
                    break;
                case 2:
                    // Day with one fixed width of 2
                    swprintf( pwszDate, L"%02d", stDate.wDay );
                    iRet = wcslen( pwszDate );
                    break;
                case 3:
                    // Abbreviated day of week
                    iRet = GetDayOfWeekName( stDate.wDayOfWeek, pwszDate, cSize, true ) - 1;
                    break;
                default: // More than 4?  Treat it as 4
                    // Day of week
                    iRet = GetDayOfWeekName( stDate.wDayOfWeek, pwszDate, cSize, false ) - 1;
                    break;
                }

                if ( iRet <= 0 )
                {
                    return 0;
                }
                else
                {
                    pwszDate += iRet;
                }
                break;
            }

        case L'M':
            {
                // Count the number of M's
                int cNumMs = 0;
                int iRet;
                do
                {
                    pwc++;
                    cNumMs++;
                }   while ( L'M' == *pwc );
                switch ( cNumMs )
                {
                case 1: 
                    // Day with no leading zeroes
                    swprintf( pwszDate, L"%d", stDate.wMonth );
                    iRet = wcslen( pwszDate );
                    break;
                case 2:
                    // Day with one fixed width of 2
                    swprintf( pwszDate, L"%02d", stDate.wMonth );
                    iRet = wcslen( pwszDate );
                    break;
                case 3:
                    // Abbreviated month name
                    iRet = GetMonthName( stDate.wMonth, pwszDate, cSize, true ) - 1;
                    break;
                default: // More than 4?  Treat it as 4
                    // Month
                    iRet = GetMonthName( stDate.wMonth, pwszDate, cSize, false ) - 1;
                    break;
                }

                if ( iRet < 0 )
                {
                    return 0;
                }
                else
                {
                    pwszDate += iRet;
                }
                break;
            }
            
        case L'y':
            {
                // Count the number of y's
                int cNumYs = 0;
                do
                {
                    pwc++;
                    cNumYs++;
                }   while ( L'y' == *pwc );

                // More than 4 y's: consider it as 4 y's
                if ( cNumYs > 4 )
                {
                    cNumYs = 4;
                }

                if (( cNumYs >= 3 ) && ( stDate.wYear < 100 ))
                {
                    // "Ninety nine": Should display as "'99"
                    cNumYs = 2;

                    *pwszDate++ = L'\'';
                }

                switch ( cNumYs )
                {
                case 1: case 2: 
                    // Last two digits of year, width of 2
                    swprintf( pwszDate, (1 == cNumYs ) ? L"%d" : L"%02d", 
                        stDate.wYear % 100 );
                    pwszDate += 2;
                    break;
                case 3: case 4:
                    // All four digits of year, width of 4
                    // Last two digits of year, width of 2
                    swprintf( pwszDate, L"%04d", stDate.wYear % 10000 );
                    pwszDate += 4;
                    break;
                }
                break;
            }

        default:
            *pwszDate++ = *pwc++;
        }
    }
    
    *pwszDate++ = 0;

    return (int) (pwszDate - pwszDateStart);
}   /* CTestITN::FormatDate */

/***********************************************************************
* CTestITN::MakeNumberNegative *
*------------------------------*
*   Description:
*       Uses the current number format defaults to transform
*       pszNumber into a negative number
*   Return:
*       S_OK
*       E_OUTOFMEMORY
*************************************************************************/
HRESULT CTestITN::MakeNumberNegative( WCHAR *pwszNumber )
{
    HRESULT hr = GetNumberFormatDefaults();
    if ( FAILED( hr ) )
    {
        return hr;
    }

    // Create a temporary buffer with the non-negated number in it
    WCHAR *pwszTemp = wcsdup( pwszNumber );
    if ( !pwszTemp )
    {
        return E_OUTOFMEMORY;
    }

    switch ( m_nmfmtDefault.NegativeOrder )
    {
    case 0:
        // (1.1)
        wcscpy( pwszNumber, L"(" );
        wcscat( pwszNumber, pwszTemp );
        wcscat( pwszNumber, L")" );
        break;

    case 1: case 2:
        // 1: -1.1  2: - 1.1
        wcscpy( pwszNumber, m_pwszNeg );
        if ( 2 == m_nmfmtDefault.NegativeOrder )
        {
            wcscat( pwszNumber, L" " );
        }
        wcscat( pwszNumber, pwszTemp );
        break;

    case 3: case 4:
        // 3: 1.1-  4: 1.1 -
        wcscpy( pwszNumber, pwszTemp );
        if ( 4 == m_nmfmtDefault.NegativeOrder )
        {
            wcscat( pwszNumber, L" " );
        }
        wcscat( pwszNumber, m_pwszNeg );
        break;

    default:
        SPDBG_ASSERT( false );
        break;
    }

    free( pwszTemp );

    return S_OK;
}   /* CTestITN::MakeNumberNegative */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\jpn\itngram_j.cpp ===
// itngram_J.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f itngramps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "itngram_J.h"

#include "itngram_J_i.c"
#include "TestITN_J.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TestITN_J, CTestITN_J)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ITNGRAMLib);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\eng\testitn.h ===
// TestITN.h : Declaration of the CTestITN

#ifndef __TESTITN_H_
#define __TESTITN_H_

#include "resource.h"       // main symbols
#include <wchar.h>          // for swprintf()

#define MAX_LOCALE_DATA     5
#define MAX_DATE_FORMAT     30
#define MAX_SIG_FIGS        12
#define MAX_STATEZIP        12
#define CANADIAN_ZIPSIZE    8
#define MAX_PHONE_NUMBER    17  // 1-(425)-882-8080\0


// Flags for number display
typedef enum DISPLAYFLAGS
{
    DF_UNFORMATTED      = (1L << 0),// No formatting
    DF_ORDINAL          = (1L << 1),// Ordinal number
    DF_WHOLENUMBER      = (1L << 2),// Should be displayed without decimal
    DF_FIXEDWIDTH       = (1L << 3),// Requiring a certain width
    DF_LEADINGZERO      = (1L << 4),// Presence of leading 0 of the number is between 0 and 1
    DF_NOTHOUSANDSGROUP = (1L << 5),// Do not do any thousands grouping (commas)
    DF_MILLIONBILLION   = (1L << 6) // If the number is a flat "millions" or "billions"
                                    // then display as "3 million"
}   DISPLAYFLAGS;

/////////////////////////////////////////////////////////////////////////////
// CTestITN
class ATL_NO_VTABLE CTestITN : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTestITN, &CLSID_TestITN>,
	public ISpCFGInterpreter
{
public:
    CTestITN() : m_pSite( NULL ),
                    m_pwszNeg( NULL )
	{
	}

    ~CTestITN()
    {
        delete m_pwszNeg;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_TESTITN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTestITN)
	COM_INTERFACE_ENTRY(ISpCFGInterpreter)
END_COM_MAP()

private:
    HRESULT InterpretNumber( const SPPHRASEPROPERTY *pProperties, 
                                const bool fCardinal,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize,
                                const bool fFinalDisplayFmt = false );

    HRESULT InterpretDigitNumber( const SPPHRASEPROPERTY *pProperties, 
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);
    
    HRESULT InterpretFPNumber( const SPPHRASEPROPERTY *pProperties, 
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);

    HRESULT InterpretMillBill( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize );

    HRESULT InterpretFraction( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);

    HRESULT InterpretDate( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);

    HRESULT InterpretTime( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize );

    HRESULT InterpretStateZip( const SPPHRASEPROPERTY *pProperties,
                                WCHAR *pszVal,
                                UINT cSize,
                                BYTE *pbAttribs );

    HRESULT InterpretCanadaZip( const SPPHRASEPROPERTY *pProperties,
                                WCHAR *pszVal,
                                UINT cSize );

    HRESULT InterpretPhoneNumber( const SPPHRASEPROPERTY *pProperties,
                                WCHAR *pszVal,
                                UINT cSize );

    HRESULT InterpretDegrees( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize );

    HRESULT InterpretMeasurement( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize );

    HRESULT InterpretCurrency( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);
    
    HRESULT AddPropertyAndReplacement( const WCHAR *szBuff,
                                const DOUBLE dblValue,
                                const ULONG ulMinPos,
                                const ULONG ulMaxPos,
                                const ULONG ulFirstElement,
                                const ULONG ulCountOfElements,
                                const BYTE bDisplayAttrib = SPAF_ONE_TRAILING_SPACE);

    HRESULT MakeDisplayNumber( DOUBLE dblNum,
                            DWORD dwDisplayFlags,
                            UINT uiFixedWidth,
                            UINT uiDecimalPlaces,
                            WCHAR *pwszNum,
                            UINT cSize );

    int MakeDigitString( const SPPHRASEPROPERTY *pProperties,
                              WCHAR *pwszDigitString,
                              UINT cSize );
    
    HRESULT GetNumberFormatDefaults();
    HRESULT GetCurrencyFormatDefaults();
    ULONG ComputeNum999(const SPPHRASEPROPERTY *pProperties );
    void HandleDigitsAfterDecimal( WCHAR *pwszFormattedNum, 
                                UINT cSizeOfFormattedNum,
                                const WCHAR *pwszRightOfDecimal );

    void GetMinAndMaxPos( const SPPHRASEPROPERTY *pProperties, ULONG *pulMinPos, ULONG *pulMaxPos );

    int GetMonthName( int iMonth, WCHAR *pwszMonth, int cSize, bool fAbbrev );
    int GetDayOfWeekName( int iDayOfWeek, WCHAR *pwszDayOfWeek, int cSize, bool fAbbrev );
    int FormatDate( const SYSTEMTIME &stDate, WCHAR *pwszFormat, WCHAR *pwszDate, int cSize );

    HRESULT MakeNumberNegative( WCHAR *pwszNumber );
    HRESULT MakePositiveCurrency( WCHAR *pwszCurr, const WCHAR * const pwszCurrSym );
    HRESULT MakeNegativeCurrency( WCHAR *pwszCurr, const WCHAR * const pwszCurrSym );

private:
    // Data members
    CSpUnicodeSupport   m_Unicode;

    NUMBERFMTW      m_nmfmtDefault;
    CURRENCYFMTW    m_cyfmtDefault;
    WCHAR       m_pwszDecimalSep[ MAX_LOCALE_DATA];
    WCHAR       m_pwszThousandSep[MAX_LOCALE_DATA];
    WCHAR       m_pwszCurrencySym[MAX_LOCALE_DATA];
    WCHAR       *m_pwszNeg;

    ISpCFGInterpreterSite *m_pSite;

// ISpCFGInterptreter
public:
    STDMETHODIMP InitGrammar(const WCHAR * pszGrammarName, const void ** pvGrammarData);
    STDMETHODIMP Interpret(ISpPhraseBuilder * pInterpretRule, const ULONG ulFirstElement, const ULONG ulCountOfElements, ISpCFGInterpreterSite * pSite);
public:
    CComPtr<ISpPhraseBuilder> m_cpPhrase;   // Decalred as a member to prevent repeated construct/destroy
};

#endif //__TESTITN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\jpn\makefile.inc ===
# Rules for compiling .cfgs from .xmls
# could these be moved into common.inc?
.SUFFIXES: .cfg .h .xml

.xml{$(O)}.cfg:
    copy $** $(O)
	$(SPEECH_ROOT)\sapi\tools\bin\gc.exe -h $*.h $*.xml

$(O)\_common.ver: verconv.pl $(SDK_INC_PATH)\common.ver
    perl -n $** > $@

!if defined(MAKEDLL)
# Self-register
itngram.cpy: $(O)\itngram.dll
    regsvr32 /s $** > $@
!else
itngram.cpy:
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lib\makefile.inc ===
copylib :
	binplace $(O)\sapi.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lib\sapilib.c ===
#include <windows.h>
#include <objbase.h>
#include "sapi_i.c"
#include "sapiddk_i.c"
#include "sapiint_i.c"
#include "spguid.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\audiobufferqueue.h ===
/****************************************************************************
*   audiobufferqueue.h
*       Declaration of the CAudioBufferQueue template class used to
*       queue audio buffers for reading or writing asynchronously.
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

//--- Class, Struct and Union Definitions -----------------------------------

/****************************************************************************
*
* CAudioBufferQueue<CBuffer>
*
******************************************************************** robch */
template <class CBuffer>
class CAudioBufferQueue : public CSpBasicQueue<CBuffer>
{
//=== Public methods ===
public:

    ULONG MoveDoneBuffsToTailOf(CAudioBufferQueue & DestQueue);
    BOOL AreMinSamplesQueuedForWrite(ULONG cbSamples);
    BOOL AreMoreReadBuffersRequired(ULONG cbMinSamples);
    CBuffer * GetToProcessBuffer(void);
    ULONG GetQueuedDataSize(void);
};

//--- Inline Function Definitions -------------------------------------------

#include "audiobufferqueue.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\jpn\testitn_j.cpp ===
// TestITN_J.cpp : Implementation of CTestITN_J
#include "stdafx.h"
#include <winnls.h>
#include "Itngram_J.h"
#include "TestITN_J.h"
#include "sphelper.h"
#include "spddkhlp.h"
#include "test_j.h"

#define MAX_SIG_FIGS    12
#define MANN         ((LONGLONG) 10000)
#define OKU          ((LONGLONG) 100000000)
#define CHUU         ((LONGLONG) 1000000000000)
#define MANN_STR     (L"\x4E07")
#define OKU_STR      (L"\x5104")
#define CHUU_STR     (L"\x5146")

const WCHAR s_pwszDegree[] = { 0xb0, 0 };
const WCHAR s_pwszMinute[] = { 0x2032, 0 };
const WCHAR s_pwszSecond[] = { 0x2033, 0 };

#define DAYOFWEEK_STR_ABBR  ("ddd")
#define DAYOFWEEK_STR       ("dddd")

/////////////////////////////////////////////////////////////////////////////
// CTestITN_J
/****************************************************************************
* CTestITN_J::InitGrammar *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CTestITN_J::InitGrammar(const WCHAR * pszGrammarName, const void ** pvGrammarData)
{
    HRESULT hr = S_OK;
    HRSRC hResInfo = ::FindResource(_Module.GetModuleInstance(), _T("TEST"), _T("ITNGRAMMAR"));
    if (hResInfo)
    {
        HGLOBAL hData = ::LoadResource(_Module.GetModuleInstance(), hResInfo);
        if (hData)
        {
            *pvGrammarData = ::LockResource(hData);
            if (*pvGrammarData == NULL)
            {
                hr = HRESULT_FROM_WIN32(::GetLastError());
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    return hr;
}

/****************************************************************************
* CTestITN_J::Interpret *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CTestITN_J::Interpret(ISpPhraseBuilder * pPhrase, 
                                   const ULONG ulFirstElement,
                                   const ULONG ulCountOfElements, 
                                   ISpCFGInterpreterSite * pSite)
{
    HRESULT hr = S_OK;
    ULONG ulRuleId = 0;
    CSpPhrasePtr cpPhrase;
    
    hr = pPhrase->GetPhrase(&cpPhrase);

    m_pSite = pSite;

    //Just use ulFirstElement & ulCountOfElements
    // Get the minimum and maximum positions
    ULONG ulMinPos;
    ULONG ulMaxPos;
    //GetMinAndMaxPos( cpPhrase->pProperties, &ulMinPos, &ulMaxPos );
    ulMinPos = ulFirstElement;
    ulMaxPos = ulMinPos + ulCountOfElements;

    if (SUCCEEDED(hr))
    {
        hr = S_FALSE;

        WCHAR pszValueBuff[ MAX_PATH ]; // No ITN result should be longer than this
        DOUBLE dblValue;                // All ITN results will have a 64-bit value

        pszValueBuff[0] = 0;

        switch (cpPhrase->Rule.ulId)
        {
        case GRID_INTEGER_STANDALONE: // Fired as a toplevel rule
            hr = InterpretNumber( cpPhrase->pProperties, true,
                &dblValue, pszValueBuff, MAX_PATH );
            if (SUCCEEDED( hr ) && ( dblValue >= 0 ) && ( dblValue <= 20 ) 
                && ( GRID_DIGIT_NUMBER != cpPhrase->pProperties->ulId ))
            {
                // Throw this one out because numbers like "three"
                // shouldn't be ITNed by themselves
                hr = S_FALSE;
                goto Cleanup; // no replacement
            }
            break;
        
        case GRID_INTEGER: case GRID_INTEGER_9999: case GRID_ORDINAL:// Number
            hr = InterpretNumber( cpPhrase->pProperties, true, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_DIGIT_NUMBER: // Number "spelled out" digit by digit
            hr = InterpretDigitNumber( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_FP_NUMBER:
            hr = InterpretFPNumber( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_DENOMINATOR:
            hr = InterpretNumber( cpPhrase->pProperties, true, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_FRACTION:
            hr = InterpretFraction( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_DATE:
            hr = InterpretDate( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_CURRENCY: // Currency
            hr = InterpretCurrency( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;
        
        case GRID_TIME: 
            hr = InterpretTime( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;
        
        case GRID_DEGREES:
            hr = InterpretDegrees( cpPhrase->pProperties,
                &dblValue, pszValueBuff, MAX_PATH );
            break;

        case GRID_MEASUREMENT: 
            hr = InterpretMeasurement( cpPhrase->pProperties, 
                &dblValue, pszValueBuff, MAX_PATH );
            break;
        
        default:
            _ASSERT(FALSE);
            break;
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = AddPropertyAndReplacement( pszValueBuff, dblValue, 
                ulMinPos, ulMaxPos, ulMinPos, ulMaxPos - ulMinPos );//ulFirstElement, ulCountOfElements );

            return hr;
        }

    }

Cleanup:

    return S_FALSE;
}

/***********************************************************************
* CTestITN_J::InterpretNumber *
*-----------------------------*
*   Description:
*       Interprets a number in the range -999,999,999,999 to 
*       +999,999,999,999 and sends the properties and
*       replacements to the CFGInterpreterSite as appropriate.
*       The property will be added and the pszValue will be a string 
*       with the correct display number.
*       If fCardinal is set, makes the display a cardinal number;
*       otherwise makes it an ordinal number.
*       The number will be formatted only if it was a properly-formed
*       number (not given digit by digit).
*   Result:
*************************************************************************/
HRESULT CTestITN_J::InterpretNumber(const SPPHRASEPROPERTY *pProperties, 
                            const bool fCardinal,
                            DOUBLE *pdblVal,
                            WCHAR *pszVal,
                            UINT cSize)
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }

    LONGLONG llValue = 0;
    int iPositive = 1; 

    const SPPHRASEPROPERTY *pFirstProp = pProperties;

    // Handle negatives
    if ( NEGATIVE == pFirstProp->ulId )
    {
        // There's no such thing as a negative ordinal
        SPDBG_ASSERT( fCardinal );

        // There had better be more stuff following
        SPDBG_ASSERT( pFirstProp->pNextSibling );

        iPositive = -1;

        pFirstProp = pFirstProp->pNextSibling;
    }

    // Handle the digit-by-digit case
    if ( GRID_DIGIT_NUMBER == pFirstProp->ulId )
    {
        // There had better be nothing following this
        SPDBG_ASSERT( !pFirstProp->pNextSibling );
        
        SPDBG_ASSERT( VT_R8 == pFirstProp->vValue.vt );
        SPDBG_ASSERT( pFirstProp->pszValue );

        DOUBLE dblVal = pFirstProp->vValue.dblVal;
        UINT uiFixedWidth = wcslen( pFirstProp->pszValue );

        *pdblVal = dblVal * iPositive;

        DWORD dwDisplayFlags = DF_WHOLENUMBER | DF_FIXEDWIDTH | DF_NOTHOUSANDSGROUP;
        return MakeDisplayNumber( *pdblVal, dwDisplayFlags, 
            uiFixedWidth, 0, pszVal, MAX_PATH, FALSE );
    }

    for (const SPPHRASEPROPERTY * pProp = pFirstProp; pProp; pProp ? pProp = pProp->pNextSibling : NULL)
    {
        switch(pProp->ulId)
        {
        case ICHIs:
            {
                SPDBG_ASSERT(pProp->pFirstChild);
                llValue += ComputeNum9999( pProp->pFirstChild );
            }
            break;
        case MANNs:
            {
                llValue += ComputeNum9999( pProp->pFirstChild ) * 10000;
            }
            break;
        case OKUs:
            {
                SPDBG_ASSERT(pProp->pFirstChild);
                llValue += ComputeNum9999( pProp->pFirstChild ) * (LONGLONG) 1e8;
            }
            break;
        case CHOOs:
            {
                SPDBG_ASSERT(pProp->pFirstChild);
                llValue += ComputeNum9999( pProp->pFirstChild ) * (LONGLONG) 1e12;
            }
            break;
         default:
            SPDBG_ASSERT(false);
        }
    }

    llValue *= iPositive;

    *pdblVal = (DOUBLE) llValue;

#if 0
    if ( !pProperties->pNextSibling && ( (BILLIONS == pProperties->ulId) || (MILLIONS == pProperties->ulId) ) )
    {
        // This is something like "3 billion", which should be displayed that way
        return E_NOTIMPL;
    }
    else
#endif
    {
        DWORD dwDisplayFlags = DF_WHOLENUMBER | (fCardinal ? 0 : DF_ORDINAL);
        //Special code to handle minus 0.
        if ((iPositive == -1) && (*pdblVal == 0.0f))
        {
            *pszVal = L'-';
            *(pszVal+1) = 0;
            return MakeDisplayNumber( *pdblVal, dwDisplayFlags, 0, 0, pszVal+1, cSize-1, FALSE );
        }
        else
        {
            return MakeDisplayNumber( *pdblVal, dwDisplayFlags, 0, 0, pszVal, cSize, FALSE );
        }
    }

}   /* CTestITN_J::InterpretNumber */




/***********************************************************************
* CTestITN_J::InterpretDigitNumber *
*----------------------------------*
*   Description:
*       Interprets an integer in (-INF, +INF) that has been spelled
*       out digit by digit.
*   Result:
*************************************************************************/
HRESULT CTestITN_J::InterpretDigitNumber( const SPPHRASEPROPERTY *pProperties,
                                        DOUBLE *pdblVal,
                                        WCHAR *pszVal,
                                        UINT cSize)
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }

    BOOL  fPositive = TRUE;
    ULONG ulLength = 0;
    *pszVal = 0;
    WCHAR *pwc = pszVal;
    UINT cLen = 0;
    for (const SPPHRASEPROPERTY * pProp = pProperties; 
        pProp && (cLen < cSize); 
        pProp ? pProp = pProp->pNextSibling : NULL)
    {
        switch(pProp->ulId)
        {
        case NEGATIVE:
            {
                SPDBG_ASSERT( pProp == pProperties );

                fPositive = FALSE;
                *pwc++ = L'-';
                cLen++;
                break;
            }
        case DIGIT:
            {
                *pwc++ = L'0' + pProp->vValue.iVal;
                cLen++;
                break;
            }
        default:
            SPDBG_ASSERT(false);
        }
    }
    *pwc = 0;
    SPDBG_ASSERT( cLen <= MAX_SIG_FIGS );

    *pdblVal = (DOUBLE) _wtoi64( pszVal );

    return S_OK;
}   /* CTestITN_J::InterpretDigitNumber */

/***********************************************************************
* CTestITN_J::InterpretFPNumber *
*-------------------------------*
*   Description:
*       Interprets a floating-point number of up to MAX_SIG_FIGS sig
*       figs.  Truncates the floating-point part as necessary
*       The way the grammar is structured, there will be an optional 
*       ONES property, whose value will already have been interpreted,
*       as well as a mandatory FP_PART property, whose value will 
*       be divided by the appropriate multiple of 10.
*   Result:
*       Return value of CTestITN_J::AddPropertyAndReplacement()
*************************************************************************/
HRESULT CTestITN_J::InterpretFPNumber( const SPPHRASEPROPERTY *pProperties,
                                        DOUBLE *pdblVal,
                                        WCHAR *pszVal,
                                        UINT cSize)
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }
    SPDBG_ASSERT( pProperties );

    UINT uiSigFigs = 0;
    *pdblVal = 0;
    *pszVal = 0;
    DWORD dwDisplayFlags = 0;
    BOOL bOverWriteNOTHOUSANDSGROUP = FALSE;


    const SPPHRASEPROPERTY *pProp = pProperties;
    UINT uiFixedWidth = 0;

    TCHAR pwszLocaleData[ MAX_LOCALE_DATA ];
    int iRet = ::GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_ILZERO, pwszLocaleData, MAX_LOCALE_DATA );
    if ( !iRet )
    {
        return E_FAIL;
    }
    if (atoi( pwszLocaleData ))
    {
        dwDisplayFlags |= DF_LEADINGZERO;
    }
    
    // Minus sign?
    if (NEGATIVE == pProp->ulId )
    {
        uiSigFigs = 1;
        // Go to the next property
        pProp = pProp->pNextSibling;
    }
    // ONES is optional since "point five" should be ".5" if the user perfers
    if ( ICHIs == pProp->ulId )
    {
        // Get the value 
        SPDBG_ASSERT( VT_R8 == pProp->vValue.vt );
        *pdblVal = pProp->vValue.dblVal;
        uiSigFigs = (pProp->pszValue[0] == L'-');  // Have to take care of the case of -0.05
        if (uiSigFigs)
        {
            *pdblVal = -*pdblVal;
        }
        // Count up the width of the number and set the fixed width flag
        dwDisplayFlags |= DF_FIXEDWIDTH;
        const WCHAR *pwc;
        for ( uiFixedWidth = 0, pwc = pProp->pszValue; *pwc; pwc++ )
        {
            if ( iswdigit( *pwc ) )
            {
                uiFixedWidth++;
            }
        }
        if (!iswdigit( pProp->pszValue[wcslen(pProp->pszValue) - 1] ))
        {
            //Ends with Mann, Choo,..
            bOverWriteNOTHOUSANDSGROUP = TRUE;
        }

        // This needs to be here in case the user said "zero"
        dwDisplayFlags |= DF_LEADINGZERO;

        // If there is no thousands separator in its string value,
        // then leave out the thousands separator in the result
        USES_CONVERSION;
        TCHAR pszThousandSep[ MAX_LOCALE_DATA ];
        ::GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, 
            pszThousandSep, MAX_LOCALE_DATA );
        if ( NULL == wcsstr( pProp->pszValue, T2W( pszThousandSep ) )  && !bOverWriteNOTHOUSANDSGROUP)
        {
            dwDisplayFlags |= DF_NOTHOUSANDSGROUP;
        }

        // Go to the next property
        pProp = pProp->pNextSibling;
    }
    else if ( ZERO == pProp->ulId )
    {
        // "oh point..."
        // This will force a leading zero
        dwDisplayFlags |= DF_LEADINGZERO;
        pProp = pProp->pNextSibling;
    }

    UINT uiDecimalPlaces = 0;
    if ( pProp && (FP_PART == pProp->ulId) )
    {
        // Deal with the stuff to the right of the decimal point
        
        // Count up the number of decimal places, and for each 
        // decimal place divide the value by 10
        // (e.g. 83 gets divided by 100).
        SPDBG_ASSERT( VT_R8 == pProp->vValue.vt );
        DOUBLE dblRightOfDecimal = pProp->vValue.dblVal;
        const WCHAR *pwc;
        for ( uiDecimalPlaces = 0, pwc = pProp->pszValue; *pwc; pwc++ )
        {
            if ( iswdigit( *pwc ) )
            {
                dblRightOfDecimal /= (DOUBLE) 10;
                uiDecimalPlaces++;
            }
        }


        *pdblVal += dblRightOfDecimal;

    }
    else if ( pProp && (FP_PART_D == pProp->ulId) )
    {
        // The user said "point" and one digit
        SPDBG_ASSERT( VT_UI4 == pProp->pFirstChild->vValue.vt );
        uiDecimalPlaces = 1;
        if ( *pdblVal >= 0 )
        {
            *pdblVal += pProp->pFirstChild->vValue.iVal / 10.0;
        }
        else
        {
            *pdblVal -= pProp->pFirstChild->vValue.iVal / 10.0;
        }
    }

    if (uiSigFigs)
    {
        *pdblVal = -*pdblVal;
    }
    MakeDisplayNumber( *pdblVal, dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pszVal, cSize, FALSE );

    return S_OK;
}   /* CTestITN_J::InterpretFPNumber */

/***********************************************************************
* CTestITN_J::InterpretFraction *
*-------------------------------*
*   Description:
*       Interprets a fraction.  
*       The DENOMINATOR property should be present.
*       If the NUMERATOR property is absent, it is assumed to be 1.
*       Divides the NUMERATOR by the DENOMINATOR and sets the value
*       accordingly.
*************************************************************************/
HRESULT CTestITN_J::InterpretFraction( const SPPHRASEPROPERTY *pProperties,
                                        DOUBLE *pdblVal,
                                        WCHAR *pszVal,
                                        UINT cSize)
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }
    SPDBG_ASSERT( pProperties );
    DOUBLE dblWholeValue = 0;
    DOUBLE dblFracValue = 1;
    BOOL bNegativeDenominator = FALSE;
    WCHAR wszBuffer[MAX_PATH];

    const SPPHRASEPROPERTY *pProp = pProperties;
    *pszVal = 0;

    // Space to store whatever characters follow the digits 
    // in the numerator (like ")")
    WCHAR pszTemp[ 10 ];    // will never need this much
    pszTemp[0] = 0;

    // Whole part is optional, otherwise assumed to be 0
    if ( WHOLE == pProp->ulId )
    {
        SPDBG_ASSERT( VT_R8 == pProp->vValue.vt );
        dblWholeValue = pProp->vValue.dblVal;
        wcscpy( pszVal, pProp->pszValue );

        // Do we need to re-generate the numbers?
        if (!iswdigit( pszVal[wcslen(pszVal) - 1] ))
        {
            MakeDisplayNumber( dblWholeValue, DF_WHOLENUMBER, 0, 0, pszVal, MAX_PATH, TRUE );
        }
        // Add a space between the whole part and the fractional part
        wcscat( pszVal, L" " );

        SPDBG_ASSERT( pProp->pNextSibling );
        pProp = pProp->pNextSibling;
    }

    // Nothing is optional in Japanese, However, the order is different from English
    SPDBG_ASSERT( DENOMINATOR == pProp->ulId );
    // Look ahead to see if it is a nagative number
    bNegativeDenominator = (pProp->vValue.dblVal < 0);

    for( pProp = pProperties; NUMERATOR != pProp->ulId; pProp = pProp->pNextSibling );
    if( NUMERATOR == pProp->ulId)
    {
        SPDBG_ASSERT( VT_R8 == pProp->vValue.vt );
        dblFracValue = pProp->vValue.dblVal;
        if (bNegativeDenominator && (pProp->vValue.dblVal >= 0))
        {
            //put the minus sign here.
            wcscat( pszVal, L"-");
            bNegativeDenominator = FALSE;
        }
 
        // Do we need to re-generate the numbers?
        if (!iswdigit( pProp->pszValue[wcslen(pProp->pszValue) - 1] ))
        {
            MakeDisplayNumber( dblFracValue, DF_WHOLENUMBER, 0, 0, wszBuffer, MAX_PATH, TRUE );
            wcscat( pszVal, wszBuffer );
        }
        else
        {
            wcscat( pszVal, pProp->pszValue );
        }

    }
    else
    {
        // No numerator, assume 1
        wcscat( pszVal, L"1" );
    }

    wcscat( pszVal, L"/" );

    for( pProp = pProperties; DENOMINATOR != pProp->ulId; pProp = pProp->pNextSibling );

    SPDBG_ASSERT( DENOMINATOR == pProp->ulId );
    SPDBG_ASSERT( VT_R8 == pProp->vValue.vt );
    if ( 0 == pProp->vValue.dblVal )
    {
        // Will not ITN a fraction with a zero denominator
        return E_FAIL;
    }

    dblFracValue /= pProp->vValue.dblVal;
    if (!bNegativeDenominator && (pProp->vValue.dblVal<0))
    { 
        // Do we need to re-generate the numbers?
        if (!iswdigit( pProp->pszValue[wcslen(pProp->pszValue) - 1] ))
        {
            MakeDisplayNumber( -pProp->vValue.dblVal, DF_WHOLENUMBER, 0, 0, wszBuffer, MAX_PATH, TRUE );
            wcscat( pszVal, wszBuffer );
        }
        else
        {
            wcscat( pszVal, pProp->pszValue+1 );
        }
    }
    else
    {
        // Do we need to re-generate the numbers?
        if (!iswdigit( pProp->pszValue[wcslen(pProp->pszValue) - 1] ))
        {
            MakeDisplayNumber( pProp->vValue.dblVal, DF_WHOLENUMBER, 0, 0, wszBuffer, MAX_PATH, TRUE );
            wcscat( pszVal, wszBuffer );
        }
        else
        {
            wcscat( pszVal, pProp->pszValue );
        }

    }

    // Tack on the ")" or "-" from the end of the numerator
    wcscat( pszVal, pszTemp );

    *pdblVal = dblWholeValue + dblFracValue;
    
    return S_OK;
}   /* CTestITN_J::InterpretFraction */

/***********************************************************************
* CTestITN_J::InterpretDate *
*---------------------------*
*   Description:
*       Interprets a date.
*       Converts the date into a VT_DATE format, even though it
*       gets stored as a VT_R8 (both are 64-bit quantities).
*       The Japanese Grammar will not accept invalid date.
*************************************************************************/
HRESULT CTestITN_J::InterpretDate( const SPPHRASEPROPERTY *pProperties,
                                        DOUBLE *pdblVal,
                                        WCHAR *pszVal,
                                        UINT cSize)
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }

    *pszVal = 0;

    // Get the date formatting string to be used right now
    if ( 0 == ::GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SLONGDATE, 
        m_pszLongDateFormat, MAX_DATE_FORMAT ) )
    {
        return E_FAIL;
    }
    
    SYSTEMTIME stDate;
    memset( (void *) &stDate, 0, sizeof( stDate ) );

    // Arguments for ::GetDateFormat()
    TCHAR *pszFormatArg = NULL;
    TCHAR pszFormat[ MAX_DATE_FORMAT ];
    
    const SPPHRASEPROPERTY *pProp;
    const SPPHRASEPROPERTY *pPropChild;
    const WCHAR* pwszEmperor;
    
    // Get the month
    for ( pProp = pProperties; pProp && ( GATSU != pProp->ulId ); pProp = pProp->pNextSibling )
        ;
    SPDBG_ASSERT( pProp );     //There should be a month, and the grammar is forcing it
    SPDBG_ASSERT( pProp->pFirstChild );       
    pPropChild = pProp->pFirstChild;
    SPDBG_ASSERT( VT_UI4 == pPropChild->vValue.vt );
    SPDBG_ASSERT( (1 <= pPropChild->vValue.ulVal) && (12 >= pPropChild->vValue.ulVal) );
    if ( (pPropChild->vValue.ulVal < 1) || (pPropChild->vValue.ulVal > 12) )
    {
        return E_INVALIDARG;
    }
    stDate.wMonth = (WORD) pPropChild->vValue.ulVal;

    // Get the emperor's name
    for ( pProp = pProperties; pProp && ( IMPERIAL != pProp->ulId ); pProp = pProp->pNextSibling )
        ;
    if ( pProp )
    {
        SPDBG_ASSERT( pProp ); 
        pPropChild = pProp->pFirstChild;
        pwszEmperor = pPropChild->pszValue;
    }
    else
    {
        pwszEmperor = 0;
    }


    // Get the year
    for ( pProp = pProperties; pProp && ( NENN != pProp->ulId ); pProp = pProp->pNextSibling )
        ;
    const SPPHRASEPROPERTY * const pPropYear = pProp;
    if ( pProp )
    {
        SPDBG_ASSERT( pProp );      // There should be a year
        SPDBG_ASSERT( VT_R8 == pProp->vValue.vt );
        stDate.wYear = (WORD) pProp->vValue.dblVal;
    }


    // Attempt to get the day of month
    for ( pProp = pProperties; pProp && ( NICHI != pProp->ulId ); pProp = pProp->pNextSibling )
        ;
    const SPPHRASEPROPERTY * const pPropDayOfMonth = pProp;
    if ( pProp )
    {
        pPropChild = pProp->pFirstChild;
        SPDBG_ASSERT( VT_UI4 == pPropChild->vValue.vt );
        SPDBG_ASSERT( (1 <= pPropChild->vValue.ulVal) && (31 >= pPropChild->vValue.ulVal) );
        if ( (pPropChild->vValue.ulVal < 1) || (pPropChild->vValue.ulVal > 31) )
        {
            return E_INVALIDARG;
        }
        stDate.wDay = (WORD) pPropChild->vValue.ulVal;

        // Look for a day of week
        for ( pProp = pProperties; pProp && ( YOUBI != pProp->ulId ); pProp = pProp->pNextSibling )
            ;
        if ( pProp )
        {
            // Day of week present
            pPropChild = pProp->pFirstChild;
            SPDBG_ASSERT( VT_UI4 == pPropChild->vValue.vt );
            SPDBG_ASSERT( 6 >= pPropChild->vValue.ulVal );
            if ( pPropChild->vValue.ulVal > 6 )
            {
                return E_INVALIDARG;
            }
            stDate.wDayOfWeek = (WORD) pPropChild->vValue.ulVal;

            // Use the full long date format
            pszFormatArg = m_pszLongDateFormat;
            // If the user did say the day of week but the format string does 
            // not called for the day of week being displayed anywhere,
            // Write out the day of week at the END of the output.
            if ( !_tcsstr( m_pszLongDateFormat, DAYOFWEEK_STR_ABBR ) )
            {
                _tcscat( m_pszLongDateFormat, " dddd" );
            }
        }
        else
        {
            TCHAR pszDayOfWeekStr[ MAX_LOCALE_DATA];

            // Remove the day of week from the current date format string
            TCHAR *pc = _tcsstr( m_pszLongDateFormat, DAYOFWEEK_STR );
            if ( pc )
            {
                _tcscpy( pszDayOfWeekStr, DAYOFWEEK_STR );
            }
            else if ( NULL != (pc = _tcsstr( m_pszLongDateFormat, DAYOFWEEK_STR_ABBR )) )
            {
                _tcscpy( pszDayOfWeekStr, DAYOFWEEK_STR_ABBR );
            }

            if ( pc )
            {
                // Copy over everything until this character info the format string
                _tcsncpy( pszFormat, m_pszLongDateFormat, (pc - m_pszLongDateFormat) );
                pszFormat[(pc - m_pszLongDateFormat)] = 0;
                
                // Skip over the day of week until the next symbol
                // (the way date format strings work, this is the first
                // alphabetical symbol
                pc += _tcslen( pszDayOfWeekStr );
                while ( *pc && !_istalpha( *pc ) )
                {
                    pc++;
                }

                // Copy over everything from here on out
                _tcscat( pszFormat, pc );

                //dwFlags = 0;
                pszFormatArg = pszFormat;
            }
            else // We don't have DAY_OF_WEEK in either the display format nor the results. 
            {
                pszFormatArg = m_pszLongDateFormat;
            }
        }
    }
    else
    {
        _tcscpy( pszFormat, "MMMM, yyyy" );
        pszFormatArg = pszFormat;
    }

    // Get the date in VariantTime form so we can set it as a semantic value
    int iRet = ::SystemTimeToVariantTime( &stDate, pdblVal );
    if ( 0 == iRet )
    {
        // Not serious, just the semantic value will be wrong
        *pdblVal = 0;
    }

    // Do the formatting
    iRet = FormatDate( stDate, pszFormatArg, pszVal, cSize, pwszEmperor );
    if ( 0 == iRet )
    {
        return E_FAIL;
    }

    return S_OK;
}   /* CTestITN_J::InterpretDate */

/***********************************************************************
* CTestITN_J::InterpretTime *
*---------------------------*
*   Description:
*       Interprets time, which can be of the following forms:
*       *   Hour with qualifier ("half past three"), time marker optional
*       *   Hour with minutes, time marker mandatory
*       *   Military time "hundred hours"
*       *   Hour with "o'clock", time marker optional
*       *   Number of hours and number of minutes and optional number
*           of seconds
*   Return:
*       S_OK
*       E_POINTER if !pdblVal or !pszVal
*************************************************************************/
HRESULT CTestITN_J::InterpretTime( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal, 
                                WCHAR *pszVal, 
                                UINT cSize )
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }
    // Time marker and seconds should not be shown unless some
    // component of the time specifically requires it
    DWORD dwFlags = TIME_NOSECONDS | TIME_NOTIMEMARKER;
    SYSTEMTIME stTime;
    ::memset( (void *) &stTime, 0, sizeof( SYSTEMTIME ) );

    bool fPM = false;
    bool fClockTime = true;
    bool fMinuteMinus = false;

    const SPPHRASEPROPERTY *pProp;
    for ( pProp = pProperties; pProp; pProp = pProp->pNextSibling )
    {
#if 1
        switch ( pProp->ulId )
        {
        case GOZENN:  // If it is PM, add the hour by 12
            {
                if (pProp->pszValue[0] == L'P')
                {
                    fPM = TRUE;
                }
                dwFlags &= ~TIME_NOTIMEMARKER;
                break;
            }
        case JI:
            {
                UINT uiHour = pProp->pFirstChild->vValue.uiVal;
                stTime.wHour = (WORD) uiHour;
                if (fPM && (stTime.wHour < 12))
                {
                    stTime.wHour += 12;
                }

                break;
            }
        case HOUR_COUNT:
            {
                // Just take the hour for what it is
                stTime.wHour = (WORD) pProp->vValue.dblVal;

                // This is not a clock time
                fClockTime = false;
                break;
            }
        case MINUTE:
            {
                // Minutes are evaluted as numbers, so their values
                // are stored as doubles
                stTime.wMinute += (WORD) pProp->pFirstChild->vValue.uiVal;
                break;
            }
        case HUNN:
            {
                // Special case for :30 ()
                stTime.wMinute = 30;
                break;
            }
        case SECOND:
            {
                stTime.wSecond += (WORD) pProp->pFirstChild->vValue.uiVal;
                dwFlags &= ~TIME_NOSECONDS;
                break;
            }
        case MINUTE_TAG:
            {
                // We only need to deal with the case of O
                if( pProp->pszValue[0] == L'-' )
                {
                    fMinuteMinus = true;
                }

                break;
            }
        default:
            SPDBG_ASSERT( false );

        }
#endif
    }
    if (fMinuteMinus)
    {
        stTime.wMinute = 60 - stTime.wMinute;
        stTime.wHour--;
    }
   HRESULT hr = S_OK;
   if ( fClockTime )
   {
    // Get the time in VariantTime form so we can set it as a semantic value
    if ( 0 == ::SystemTimeToVariantTime( &stTime, pdblVal ) )
    {
        // Not serious, just the semantic value will be wrong
        *pdblVal = 0;
    }

    TCHAR *pszTime = new TCHAR[ cSize ];
    if ( !pszTime )
    {
        return E_OUTOFMEMORY;
    }
    if (stTime.wHour >= 24)
    {
        stTime.wHour -= 24; //To avoid problems in GetTimeFormat
    }
    if (stTime.wHour >= 12) // Enable the TimeMarker if the time is in the afternoon
    {
         dwFlags &= ~TIME_NOTIMEMARKER;
    }
    int iRet = ::GetTimeFormat( LOCALE_USER_DEFAULT, dwFlags, &stTime, NULL, 
        pszTime, cSize );
    USES_CONVERSION;
    wcscpy( pszVal, T2W(pszTime) );
    delete[] pszTime;

    // NB: GetTimeFormat() will put an extra space at the end of the 
    // time if the default format has AM or PM but TIME_NOTIMEMARKER is
    // set
    if ( iRet && (TIME_NOTIMEMARKER & dwFlags) )
    {
        WCHAR *pwc = pszVal + wcslen( pszVal ) - 1;
        while ( iswspace( *pwc ) )
        {
            *pwc-- = 0;
        }
    }
     hr = iRet ? S_OK : E_FAIL;
    }
    else
    {
        // No need to go through the system's time formatter
        if ( cSize < 10 )    // Space for xxx:xx:xx\0
        {
            return E_INVALIDARG;
        }

        if ( dwFlags & TIME_NOSECONDS )
        {
            swprintf( pszVal, L"%d:%02d", stTime.wHour, stTime.wMinute );
        }
        else
        {
            swprintf( pszVal, L"%d:%02d:%02d",
                stTime.wHour, stTime.wMinute, stTime.wSecond );
        }
    }

    return hr;
}   /* CTestITN_J::InterpretTime */

/***********************************************************************
* CTestITN_J::InterpretDegrees *
*------------------------------*
*   Description:
*       Interprets degrees as a angle-measurement or direction
*   Return:
*       S_OK
*       E_POINTER
*       E_INVALIDARG
*************************************************************************/
HRESULT CTestITN_J::InterpretDegrees( const SPPHRASEPROPERTY *pProperties,
                                   DOUBLE *pdblVal, 
                                   WCHAR *pszVal,
                                   UINT cSize )
{
    if ( !pProperties || !pdblVal || !pszVal )
    {
        return E_POINTER;
    }
    WCHAR *pwchDirection = 0;
    *pszVal = 0;

	//Do we have those direction tags
	if (DIRECTION_TAG == pProperties->ulId)
	{
		pwchDirection = (WCHAR*) pProperties->pszValue;
	    pProperties = pProperties->pNextSibling;
	}
    // Get the number
    
    *pdblVal = pProperties->vValue.dblVal;
    wcscat( pszVal, pProperties->pszValue );
    wcscat( pszVal, s_pwszDegree );
    pProperties = pProperties->pNextSibling;


    if ( pProperties && (MINUTE == pProperties->ulId ) )
		{
            SPDBG_ASSERT( *pdblVal >= 0 );
        
            DOUBLE dblMin = pProperties->vValue.dblVal;
            *pdblVal += dblMin / (DOUBLE) 60;
            wcscat( pszVal, pProperties->pszValue );
            wcscat( pszVal, s_pwszMinute  );
			pProperties = pProperties->pNextSibling;
		}

    if ( pProperties && (SECOND == pProperties->ulId) )
        {
            DOUBLE dblSec = pProperties->vValue.dblVal;
            *pdblVal += dblSec / (DOUBLE) 3600;
            wcscat( pszVal, pProperties->pszValue );
            wcscat( pszVal, s_pwszSecond  );
            pProperties = pProperties->pNextSibling;
        }


		if (pwchDirection)
		{
			wcscat( pszVal, pwchDirection );
		}
        SPDBG_ASSERT( !pProperties );


    return S_OK;
}   /* CTestITN_J::InterpretDegrees */


/***********************************************************************
* CTestITN_J::InterpretMeasurement *
*----------------------------------*
*   Description:
*       Interprets measurements, which is a number followed
*       by a units name
*   Return:
*       S_OK
*       E_POINTER
*       E_INVALIDARG
*************************************************************************/
HRESULT CTestITN_J::InterpretMeasurement( const SPPHRASEPROPERTY *pProperties,
                                       DOUBLE *pdblVal,
                                       WCHAR *pszVal, 
                                       UINT cSize )
{
    if ( !pProperties || !pdblVal || !pszVal )
    {
        return E_POINTER;
    }

    const SPPHRASEPROPERTY *pPropNumber = NULL;
    const SPPHRASEPROPERTY *pPropUnits = NULL;
    const SPPHRASEPROPERTY *pProp;
    for(pProp= pProperties; pProp; pProp = pProp->pNextSibling)
    {
        if (NUMBER == pProp->ulId )
            pPropNumber = pProp;
        else if ( UNITS == pProp->ulId )
            pPropUnits = pProp;
    }

    if (!pPropUnits || !pPropNumber )
    {
        SPDBG_ASSERT( FALSE );
        return E_INVALIDARG;
    }

    if ( cSize < (wcslen(pPropNumber->pszValue) + wcslen(pPropUnits->pszValue) + 1) )
    {
        // Not enough space
        return E_INVALIDARG;
    }


    // Do we need to re-generate the numbers?
    if (!iswdigit( pPropNumber->pszValue[wcslen(pPropNumber->pszValue) - 1] ))
    {
        MakeDisplayNumber( pPropNumber->vValue.dblVal, DF_WHOLENUMBER, 0, 0, pszVal, MAX_PATH, TRUE );
    }
	else
	{
		wcscpy(pszVal, pPropNumber->pszValue );
	}
    wcscat( pszVal, pPropUnits->pszValue );

    *pdblVal = pPropNumber->vValue.dblVal;

    return S_OK;
}   /* CTestITN_J::InterpretMeasurement */

/***********************************************************************
* CTestITN_J::InterpretCurrency *
*-------------------------------*
*   Description:
*       Interprets currency.
*   Return:
*       S_OK
*       E_POINTER if !pdblVal or !pszVal
*       E_INVALIDARG if the number of cents is not between 0 and 99 
*           inclusive
*************************************************************************/
HRESULT CTestITN_J::InterpretCurrency( const SPPHRASEPROPERTY *pProperties,
                                        DOUBLE *pdblVal,
                                        WCHAR *pszVal,
                                        UINT cSize)
{
    if ( !pdblVal || !pszVal )
    {
        return E_POINTER;
    }

    // Find the dollars and cents properties
    const SPPHRASEPROPERTY *pPropDollars;

    for ( pPropDollars = pProperties; 
        pPropDollars && ( YENs != pPropDollars->ulId ); 
        pPropDollars = pPropDollars->pNextSibling )
        ;

    SPDBG_ASSERT( pPropDollars );
    
    const WCHAR *pszDollars = NULL;
    DOUBLE dblDollars = 0;
    if ( pPropDollars )
    {
        SPDBG_ASSERT( VT_R8 == pPropDollars->vValue.vt );
        pszDollars = pPropDollars->pszValue;
        dblDollars = pPropDollars->vValue.dblVal;
    }

    if (pPropDollars)
    {
        //Japanese people don't like \1Million, for the case of whole numbers like MANN, OKU,
        //Simply write out the YEN at the end.
        if (iswdigit( pszDollars[wcslen(pszDollars) - 1] ))
        {
            wcscpy(pszVal + 1, pszDollars);
            pszVal[0] = L'\\';
        }
        else
        {
            wcscpy(pszVal, pszDollars);
            wcscat(pszVal, L"\x5186");
        }
    }

    *pdblVal = dblDollars;

    return S_OK;
}   /* CTestITN_J::InterpretCurrency */

/***********************************************************************
* CTestITN_J::AddPropertyAndReplacement *
*---------------------------------------*
*   Description:
*       Takes all of the info that we want to pass into the 
*       engine site, forms the SPPHRASEPROPERTY and
*       SPPHRASERREPLACEMENT, and adds them to the engine site
*   Return:
*       Return values of ISpCFGInterpreterSite::AddProperty()
*           and ISpCFGInterpreterSite::AddTextReplacement()
*************************************************************************/
HRESULT CTestITN_J::AddPropertyAndReplacement( const WCHAR *szBuff,
                                    const DOUBLE dblValue,
                                    const ULONG ulMinPos,
                                    const ULONG ulMaxPos,
                                    const ULONG ulFirstElement,
                                    const ULONG ulCountOfElements )
{
    // Add the property 
    SPPHRASEPROPERTY prop;
    memset(&prop,0,sizeof(prop));
    prop.pszValue = szBuff;
    prop.vValue.vt = VT_R8;
    prop.vValue.dblVal = dblValue;
    prop.ulFirstElement = ulMinPos;
    prop.ulCountOfElements = ulMaxPos - ulMinPos;
    HRESULT hr = m_pSite->AddProperty(&prop);

    if (SUCCEEDED(hr))
    {
        SPPHRASEREPLACEMENT repl;
        memset(&repl,0, sizeof(repl));
        repl.bDisplayAttributes = SPAF_ONE_TRAILING_SPACE;
        repl.pszReplacementText = szBuff;
        repl.ulFirstElement = ulFirstElement;
        repl.ulCountOfElements = ulCountOfElements;
        hr = m_pSite->AddTextReplacement(&repl);
    }

    return hr;
}   /* CTestITN_J::AddPropertyAndReplacement */

// Helper functions

 
/***********************************************************************
* CTestITN_J::MakeDisplayNumber *
*-------------------------------*
*   Description:
*       Converts a DOUBLE into a displayable
*       number in the range -999,999,999,999 to +999,999,999,999.
*       cSize is the number of chars for which pwszNum has space
*       allocated.
*       If DF_UNFORMATTED is set, all other flags are ignored,
*           and the number is passed back as an optional negative
*           followed by a string of digits
*       If DF_ORDINAL is set in dwDisplayFlags, displays an
*           ordinal number (i.e. tacks on "th" or the appropriate suffix.
*       If DF_WHOLENUMBER is set, lops off the decimal separator
*           and everything after it.  If DF_WHOLENUMBER is not set,
*           then uses the uiDecimalPlaces parameter to determine
*           how many decimal places to display
*       If DF_FIXEDWIDTH is set, will display at least uiFixedWidth
*           digits; otherwise uiFixedWidth is ignored.
*       If DF_NOTHOUSANDSGROUP is set, will not do thousands
*           grouping (commas)
*************************************************************************/
HRESULT CTestITN_J::MakeDisplayNumber( DOUBLE dblNum, 
                         DWORD dwDisplayFlags,
                         UINT uiFixedWidth,
                         UINT uiDecimalPlaces,
                         WCHAR *pwszNum,
                         UINT cSize,
                         BOOL bForced)
{
    SPDBG_ASSERT( pwszNum );
    SPDBG_ASSERT( !SPIsBadWritePtr( pwszNum, cSize ) );
    *pwszNum = 0;

    // check for straight millions and straight billions
    if (( dwDisplayFlags & DF_WHOLENUMBER ) && (dblNum > 0) && !bForced)
    {
        HRESULT hr;
        if ( 0 == (( ((LONGLONG) dblNum) % CHUU )) )
        {
            // e.g. for "five billion" get the "5" and then 
            // tack on " billion"
            hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) CHUU) ), 
                dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize, FALSE );
            if ( SUCCEEDED( hr ) )
            {
                //wcscat( pwszNum, L" " );
                wcscat( pwszNum, CHUU_STR );
            }
            return hr;
        }
        else if (( ((LONGLONG) dblNum) < CHUU ) && 
                ( 0 == (( ((LONGLONG) dblNum) % OKU )) ))
        {
            hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) OKU) ), 
                dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize, FALSE );
            if ( SUCCEEDED( hr ) )
            {
                //wcscat( pwszNum, L" " );
                wcscat( pwszNum, OKU_STR );
            }
                return hr;
        }
        else if (( ((LONGLONG) dblNum) < OKU ) && 
                ( 0 == (( ((LONGLONG) dblNum) % MANN )) ))
        {
            hr = MakeDisplayNumber( ( dblNum / ((DOUBLE) MANN) ), 
                dwDisplayFlags, uiFixedWidth, uiDecimalPlaces, pwszNum, cSize, FALSE );
            if ( SUCCEEDED( hr ) )
            {
                //wcscat( pwszNum, L" " );
                wcscat( pwszNum, MANN_STR );
            }
                return hr;
        }
    }


    // Put in the negative sign if necessary
    if ( dblNum < 0 )
    {
        wcscat( pwszNum, L"-" );

        // From now on we want to deal with the magnitude of the number
        dblNum *= -1;
    }
    SPDBG_ASSERT( dblNum < 1e16 );

    WCHAR *pwszTemp = new WCHAR[ cSize ];
    if ( !pwszTemp )
    {
        return E_OUTOFMEMORY;
    }
    *pwszTemp = 0;

    LONGLONG llIntPart = (LONGLONG) dblNum;
    UINT uiDigitsLeftOfDecimal;
    if ( dwDisplayFlags & DF_WHOLENUMBER )
    {
        swprintf( pwszTemp, L"%I64d", llIntPart );
        uiDigitsLeftOfDecimal = wcslen( pwszTemp );
    }
    else
    {
        swprintf( pwszTemp, L"%.*f", uiDecimalPlaces, dblNum );
        WCHAR *pwc = wcschr( pwszTemp, L'.' );
        uiDigitsLeftOfDecimal = pwc - pwszTemp;
    }
    
    // The following handles the case where the user said something
    // like "zero zero zero three" and wants to see "0,003"
    BOOL fChangedFirstDigit = false;
    const WCHAR wcFakeFirstDigit = L'1';
    if ( !(dwDisplayFlags & DF_UNFORMATTED) && 
        (dwDisplayFlags & DF_FIXEDWIDTH) && (uiDigitsLeftOfDecimal < uiFixedWidth) )
    {
        // The following handles the case where the user wants leading 
        // zeroes displayed
        
        // Need to pad the front with zeroes
        for ( UINT ui = 0; ui < (uiFixedWidth - uiDigitsLeftOfDecimal); ui++ )
        {
            wcscat( pwszNum, L"0" );
        }
        
        // HACK
        // In order to force something like "zero zero zero three" 
        // into the form "0,003", we need to make GetNumberFormat() 
        // think that the first digit is 1.
        WCHAR *pwc = wcschr( pwszNum, L'0' );
        SPDBG_ASSERT( pwc );
        *pwc = wcFakeFirstDigit;
        fChangedFirstDigit = true;
    }

    // Copy over the unformatted number after the possible negative sign
    wcscat( pwszNum, pwszTemp );
    delete[] pwszTemp;

    // If we do not want to format the number, then bail here
    if ( dwDisplayFlags & DF_UNFORMATTED )
    {
        return S_OK;
    }

    // Get the default number formatting.
    // Note that this gets called every time, since otherwise there
    // is no way to pick up changes that the user has made since
    // this process has started.
    GetNumberFormatDefaults();
    
    // Make a copy so that we can change some fields according to the 
    // flags param
    NUMBERFMT nmfmt = m_nmfmtDefault;

    // How many decimal places to display?
    if ( dwDisplayFlags & DF_WHOLENUMBER )
    {
        nmfmt.NumDigits = 0;
    }
    else
    {
        // Use the uiDecimalPlaces value to determine how
        // many to display
        nmfmt.NumDigits = uiDecimalPlaces;
    }
    
    // Leading zeroes?
    nmfmt.LeadingZero = (dwDisplayFlags & DF_LEADINGZERO) ? 1 : 0;

    // Thousands grouping?
    if ( dwDisplayFlags & DF_NOTHOUSANDSGROUP )
    {
        nmfmt.Grouping = 0;
    }

    // Format the number string
    TCHAR *pszFormattedNum = new TCHAR[ cSize ];
    if ( !pszFormattedNum )
    {
        return E_OUTOFMEMORY;
    }
    *pszFormattedNum = 0;
    USES_CONVERSION;
    int iRet;
    do
    {
        iRet = ::GetNumberFormat( LOCALE_USER_DEFAULT, 0, 
            W2T( pwszNum ), &nmfmt, pszFormattedNum, cSize );
        if ( !iRet && nmfmt.NumDigits )
        {
            // Try displaying fewer digits
            nmfmt.NumDigits--;
        }
    }   while ( !iRet && nmfmt.NumDigits );
    SPDBG_ASSERT( iRet );

    // Copy the formatted number into pwszNum
    wcscpy( pwszNum, T2W(pszFormattedNum) );
    delete[] pszFormattedNum;

    // This undoes the hack of changing the first digit
    if ( fChangedFirstDigit )
    {
        // We need to find the first digit and change it back to zero
        WCHAR *pwc = wcschr( pwszNum, wcFakeFirstDigit );
        SPDBG_ASSERT( pwc );
        *pwc = L'0';
    }

    if ( dwDisplayFlags & DF_ORDINAL )
    {
        SPDBG_ASSERT( dwDisplayFlags & DF_WHOLENUMBER );    // sanity

        // This is an ordinal number, tack on the appropriate suffix
        
        // The "st", "nd", "rd" endings only happen when you
        // don't have something like "twelfth"
        if ( ((llIntPart % 100) < 10) || ((llIntPart % 100) > 20) )
        {
            switch ( llIntPart % 10 )
            {
            case 1:
                wcscat( pwszNum, L"st" );
                break;
            case 2:
                wcscat( pwszNum, L"nd" );
                break;
            case 3:
                wcscat( pwszNum, L"rd" );
                break;
            default:
                wcscat( pwszNum, L"th" );
                break;
            }
        }
        else
        {
            wcscat( pwszNum, L"th" );
        }
    }

    return S_OK;

}   /* CTestITN_J::MakeDisplayNumber */

/***********************************************************************
* CTestITN_J::GetNumberFormatDefaults *
*-------------------------------------*
*   Description:
*       This finds all of the defaults for formatting numbers for
*        this user.
*************************************************************************/
void CTestITN_J::GetNumberFormatDefaults()
{
    LCID lcid = ::GetUserDefaultLCID();
    TCHAR pszLocaleData[ MAX_LOCALE_DATA ];
    
    ::GetLocaleInfo( lcid, LOCALE_IDIGITS, pszLocaleData, MAX_LOCALE_DATA );
    m_nmfmtDefault.NumDigits = _ttoi( pszLocaleData );    
    
    ::GetLocaleInfo( lcid, LOCALE_ILZERO, pszLocaleData, MAX_LOCALE_DATA );
    // It's always either 0 or 1
    m_nmfmtDefault.LeadingZero = _ttoi( pszLocaleData );

    ::GetLocaleInfo( lcid, LOCALE_SGROUPING, pszLocaleData, MAX_LOCALE_DATA );
    // It will look like single_digit;0, or else it will look like
    // 3;2;0
    UINT uiGrouping = *pszLocaleData - _T('0');
    if ( (3 == uiGrouping) && (_T(';') == pszLocaleData[1]) && (_T('2') == pszLocaleData[2]) )
    {
        uiGrouping = 32;   
    }
    m_nmfmtDefault.Grouping = uiGrouping;

    ::GetLocaleInfo( lcid, LOCALE_SDECIMAL, m_pszDecimalSep, MAX_LOCALE_DATA );
    m_nmfmtDefault.lpDecimalSep = m_pszDecimalSep;

    ::GetLocaleInfo( lcid, LOCALE_STHOUSAND, m_pszThousandSep, MAX_LOCALE_DATA );
    m_nmfmtDefault.lpThousandSep = m_pszThousandSep;

    ::GetLocaleInfo( lcid, LOCALE_INEGNUMBER, pszLocaleData, MAX_LOCALE_DATA );
    m_nmfmtDefault.NegativeOrder = _ttoi( pszLocaleData );
}   /* CTestITN_J::GetNumberFormatDefaults

/***********************************************************************
* HandleDigitsAfterDecimal *
*--------------------------*
*   Description:
*       If pwszRightOfDecimal is NULL, then cuts off all of the numbers
*       following the decimal separator.
*       Otherwise, copies pwszRightOfDecimal right after the decimal
*       separator in pwszFormattedNum.
*       Preserves the stuff after the digits in the pwszFormattedNum
*       (e.g. if pwszFormattedNum starts out "(3.00)" and 
*       pwszRightOfDecimal is NULL, then pwszFormattedNum will end
*       up as "(3)"  
*************************************************************************/
void HandleDigitsAfterDecimal( WCHAR *pwszFormattedNum, 
                              UINT cSizeOfFormattedNum, 
                              const WCHAR *pwszRightOfDecimal )
{
    SPDBG_ASSERT( pwszFormattedNum );
    
    // First need to find what the decimal string is
    LCID lcid = ::GetUserDefaultLCID();
    TCHAR pszDecimalString[ 5 ];    // Guaranteed to be no longer than 4 long
    int iRet = ::GetLocaleInfo( lcid, LOCALE_SDECIMAL, pszDecimalString, 4 );
    SPDBG_ASSERT( iRet );

    USES_CONVERSION;
    WCHAR *pwcDecimal = wcsstr( pwszFormattedNum, T2W(pszDecimalString) );
    SPDBG_ASSERT( pwcDecimal );

    // pwcAfterDecimal points to the first character after the decimal separator
    WCHAR *pwcAfterDecimal = pwcDecimal + _tcslen( pszDecimalString );

    // Remember what originally followed the digits
    WCHAR *pwszTemp = new WCHAR[ cSizeOfFormattedNum ];
    WCHAR *pwcAfterDigits;  // points to the first character after the end of the digits
    for ( pwcAfterDigits = pwcAfterDecimal; 
        *pwcAfterDigits && iswdigit( *pwcAfterDigits ); 
        pwcAfterDigits++ )
        ;
    wcscpy( pwszTemp, pwcAfterDigits ); // OK if *pwcAfterDigits == 0

    if ( pwszRightOfDecimal )
    {
        // This means that the caller wants the digits in pwszRightOfDecimal
        // copied after the decimal separator

        // Copy the decimal string after the decimal separater
        wcscpy( pwcAfterDecimal, pwszRightOfDecimal );

    }
    else
    {
        // This means that the caller wanted the decimal separator
        // and all text following it stripped off

        *pwcDecimal = 0;
    }

    // Add on the extra after-digit characters
    wcscat( pwszFormattedNum, pwszTemp );

    delete[] pwszTemp;

}   /* HandleDigitsAfterDecimal */


/***********************************************************************
* ComputeNum9999 *
*----------------*
*   Description:
*       Converts a set of SPPHRASEPROPERTYs into a number in
*       [-9999, 9999].
*       The way these properties is structured is that the top-level 
*       properties contain the place of the number (100s, 10s, 1s)
*       by having the value 100, 10, or 1.
*       The child has the appropriate number value.
*   Return:
*       Value of the number
*************************************************************************/
ULONG ComputeNum9999(const SPPHRASEPROPERTY *pProperties )//, ULONG *pVal)
{
    ULONG ulVal = 0;

    for (const SPPHRASEPROPERTY * pProp = pProperties; pProp; pProp = pProp->pNextSibling)
    {
        if ( ZERO != pProp->ulId )
        {
            SPDBG_ASSERT( VT_UI4 == pProp->vValue.vt );

            ulVal += pProp->vValue.ulVal;
        }
    }
    return ulVal;
}   /* ComputeNum9999 */

/***********************************************************************
* GetMinAndMaxPos *
*-----------------*
*   Description:
*       Gets the minimum and maximum elements spanned by the 
*       set of properties
*************************************************************************/
void GetMinAndMaxPos( const SPPHRASEPROPERTY *pProperties, 
                     ULONG *pulMinPos, 
                     ULONG *pulMaxPos )
{
    if ( !pulMinPos || !pulMaxPos )
    {
        return;
    }
    ULONG ulMin = 9999999;
    ULONG ulMax = 0;

    for ( const SPPHRASEPROPERTY *pProp = pProperties; pProp; pProp = pProp->pNextSibling )
    {
        ulMin = __min( ulMin, pProp->ulFirstElement );
        ulMax = __max( ulMax, pProp->ulFirstElement + pProp->ulCountOfElements );
    }
    *pulMinPos = ulMin;
    *pulMaxPos = ulMax;
}   /* GetMinAndMaxPos */

/***********************************************************************
* GetMonthName *
*--------------*
*   Description:
*       Gets the name of the month, abbreviated if desired
*   Return:
*       Number of characters written to pszMonth, 0 if failed
*************************************************************************/
int GetMonthName( int iMonth, WCHAR *pwszMonth, int cSize, bool fAbbrev )
{
    LCTYPE lctype;
    switch ( iMonth )
    {
    case 1:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME1 : LOCALE_SMONTHNAME1;
        break;
    case 2:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME2 : LOCALE_SMONTHNAME2;
        break;
    case 3:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME3 : LOCALE_SMONTHNAME3;
        break;
    case 4:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME4 : LOCALE_SMONTHNAME4;
        break;
    case 5:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME5 : LOCALE_SMONTHNAME5;
        break;
    case 6:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME6 : LOCALE_SMONTHNAME6;
        break;
    case 7:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME7 : LOCALE_SMONTHNAME7;
        break;
    case 8:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME8 : LOCALE_SMONTHNAME8;
        break;
    case 9:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME9 : LOCALE_SMONTHNAME9;
        break;
    case 10:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME10 : LOCALE_SMONTHNAME10;
        break;
    case 11:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME11 : LOCALE_SMONTHNAME11;
        break;
    case 12:
        lctype = fAbbrev ? LOCALE_SABBREVMONTHNAME12 : LOCALE_SMONTHNAME12;
        break;
    default:
        return 0;
    }

    TCHAR *pszMonth = new TCHAR[ cSize ];
    if ( !pszMonth )
    {
        return 0;
    }
    int iRet = ::GetLocaleInfo( LOCALE_USER_DEFAULT, lctype, pszMonth, cSize );
    iRet = _mbslen((const unsigned char*) pszMonth); //Jpn needs chars, not bytes
    USES_CONVERSION;
    wcscpy( pwszMonth, T2W(pszMonth) );
    delete[] pszMonth;

    return iRet;
}   /* GetMonthName */

/***********************************************************************
* GetDayOfWeekName *
*------------------*
*   Description:
*       Gets the name of the day of week, abbreviated if desired
*   Return:
*       Number of characters written to pszDayOfWeek, 0 if failed
*************************************************************************/
int GetDayOfWeekName( int iDayOfWeek, WCHAR *pwszDayOfWeek, int cSize, bool fAbbrev )
{
    LCTYPE lctype;
    switch ( iDayOfWeek )
    {
    case 0:
        // Sunday is day 7
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME7 : LOCALE_SDAYNAME7;
        break;
    case 1:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME1 : LOCALE_SDAYNAME1;
        break;
    case 2:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME2 : LOCALE_SDAYNAME2;
        break;
    case 3:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME3 : LOCALE_SDAYNAME3;
        break;
    case 4:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME4 : LOCALE_SDAYNAME4;
        break;
    case 5:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME5 : LOCALE_SDAYNAME5;
        break;
    case 6:
        lctype = fAbbrev ? LOCALE_SABBREVDAYNAME6 : LOCALE_SDAYNAME6;
        break;
    default:
        return 0;
    }

    TCHAR *pszDayOfWeek = new TCHAR[ cSize ];
    if ( !pszDayOfWeek )
    {
        return 0;
    }
    int iRet = ::GetLocaleInfo( LOCALE_USER_DEFAULT, lctype, pszDayOfWeek, cSize );
    USES_CONVERSION;
    wcscpy( pwszDayOfWeek, T2W(pszDayOfWeek) );
    iRet = wcslen(pwszDayOfWeek);
    delete[] pszDayOfWeek;

    return iRet;
}   /* GetMonthName */

/***********************************************************************
* FormatDate *
*------------*
*   Description:
*       Uses the format string to format a SYSTEMTIME date.
*       We are using this instead of GetDateFormat() since
*       we also want to format bogus dates and dates with 
*       years like 1492 that are not accepted by GetDateFormat()
*   Return:
*       Number of characters written to pszDate (including
*       null terminating character), 0 if failed
*************************************************************************/
int FormatDate( const SYSTEMTIME &stDate, 
               TCHAR *pszFormat,
               WCHAR *pwszDate, 
               int cSize,
               const WCHAR *pwszEmperor)
{
    if ( !pszFormat || !pwszDate )
    {
        SPDBG_ASSERT( FALSE );
        return 0;
    }

    WCHAR * const pwszDateStart = pwszDate;

    // Convert the format string to unicode
    WCHAR pwszFormat[ MAX_PATH ];
    USES_CONVERSION;
    wcscpy( pwszFormat, T2W(pszFormat) );

    WCHAR *pwc = pwszFormat;
    //Modify the format string to drop the fileds we don't have (Year, gg)
    while ( *pwc )
    {
        switch( *pwc )
        {
        case L'y':
            if (!stDate.wYear)
            {
                do
                {
                    *pwc++ = L'\'';                    
                }   while ( *pwc && (L'M' != *pwc) && (L'd' != *pwc));
            }
            else
            {
                pwc++;
            }
            break;
        case L'g':
            *pwc++ = L'\'';
            break;
        default:
            pwc ++;
            break;
        }
    }
    pwc = pwszFormat;

    // output the Emperor's name if there is one
    if (pwszEmperor)
    {
        wcscpy(pwszDate,pwszEmperor);
        pwszDate += wcslen(pwszEmperor);
    }
    // Copy the format string to the date string character by 
    // character, replacing the string like "dddd" as appropriate
    while ( *pwc )
    {
        switch( *pwc )
        {
        case L'\'':
            pwc++;  // Don't need '
            break;
        case L'd':
            {
                // Count the number of d's
                int cNumDs = 0;
                int iRet;
                do
                {
                    pwc++;
                    cNumDs++;
                }   while ( L'd' == *pwc );
                switch ( cNumDs )
                {
                case 1: 
                    // Day with no leading zeroes
                    swprintf( pwszDate, L"%d", stDate.wDay );
                    iRet = wcslen( pwszDate );
                    break;
                case 2:
                    // Day with one fixed width of 2
                    swprintf( pwszDate, L"%02d", stDate.wDay );
                    iRet = wcslen( pwszDate );
                    break;
                case 3:
                    // Abbreviated day of week
                    iRet = GetDayOfWeekName( stDate.wDayOfWeek, pwszDate, cSize, true );
                    break;
                default: // More than 4?  Treat it as 4
                    // Day of week
                    iRet = GetDayOfWeekName( stDate.wDayOfWeek, pwszDate, cSize, false );
                    break;
                }

                if ( iRet <= 0 )
                {
                    return 0;
                }
                else
                {
                    pwszDate += iRet;
                }
                break;
            }

        case L'M':
            {
                // Count the number of M's
                int cNumMs = 0;
                int iRet;
                do
                {
                    pwc++;
                    cNumMs++;
                }   while ( L'M' == *pwc );
                switch ( cNumMs )
                {
                case 1: 
                    // Day with no leading zeroes
                    swprintf( pwszDate, L"%d", stDate.wMonth );
                    iRet = wcslen( pwszDate );
                    break;
                case 2:
                    // Day with one fixed width of 2
                    swprintf( pwszDate, L"%02d", stDate.wMonth );
                    iRet = wcslen( pwszDate );
                    break;
                case 3:
                    // Abbreviated month name
                    iRet = GetMonthName( stDate.wMonth, pwszDate, cSize, true );
                    break;
                default: // More than 4?  Treat it as 4
                    // Month
                    iRet = GetMonthName( stDate.wMonth, pwszDate, cSize, false );
                    break;
                }

                if ( iRet < 0 )
                {
                    return 0;
                }
                else
                {
                    pwszDate += iRet;
                }
                break;
            }
            
        case L'y':
            {
                // Count the number of y's
                int cNumYs = 0;
                do
                {
                    pwc++;
                    cNumYs++;
                }   while ( L'y' == *pwc );
                switch ( cNumYs )
                {
                case 1:
                    // Last two digits of year, width of 2
                    if (stDate.wYear % 100 > 9)
                    {
                        swprintf( pwszDate, L"%02d", stDate.wYear % 100 );
                        pwszDate += 2;
                    }
                    else
                    {
                        swprintf( pwszDate, L"%01d", stDate.wYear % 100 );
                        pwszDate += 1;
                    }
                    break;
                case 2:
                    // Last two digits of year, width of 2
                    {
                        swprintf( pwszDate, L"%02d", stDate.wYear % 100 );
                        pwszDate += 2;
                    }
                    break;
                default:
                    // All four digits of year, width of 4
                    // Last two digits of year, width of 2
                    swprintf( pwszDate, L"%04d", stDate.wYear % 10000 );
                    pwszDate += 4;
                    break;
                }
                break;
            }

        case L'g':
            {
                // NB: GetCalendarInfo is supported on Win98 or Win2K, but not on NT4
                /*
                if ( L'g' == *(pwc + 1) )
                {
                    // Get the era string
                    TCHAR pszCalEra[ MAX_LOCALE_DATA ];
                    if ( 0 == GetCalendarInfo( LOCALE_USER_DEFAULT, 
                        CAL_GREGORIAN, CAL_SERASTRING, pszCalEra, MAX_LOCALE_DATA ) )
                    {
                        return 0;
                    }
                    USES_CONVERSION;
                    wcscpy( pwszDate, T2W(pszCalEra) );
                    pwc += 2;
                }
                else
                {
                    // It's just a 'g'
                    *pwszDate++ = *pwc++;
                }
                */
                *pwszDate++ = *pwc++;
                break;
            }
        default:
            *pwszDate++ = *pwc++;
        }
    }
    
    *pwszDate++ = 0;

    return (pwszDate - pwszDateStart);
}   /* FormatDate */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\lang\itn\jpn\testitn_j.h ===
// TestITN_J.h : Declaration of the CTestITN_J

#ifndef __TESTITN_J_H_
#define __TESTITN_J_H_

#include "resource.h"       // main symbols
#include <wchar.h>          // for swprintf()

#define MAX_LOCALE_DATA     5
#define MAX_DATE_FORMAT     30


// Flags for number display
typedef enum DISPLAYFLAGS
{
    DF_UNFORMATTED      = (1L << 0),// No formatting
    DF_ORDINAL          = (1L << 1),// Ordinal number
    DF_WHOLENUMBER      = (1L << 2),// Should be displayed without decimal
    DF_FIXEDWIDTH       = (1L << 3),// Requiring a certain width
    DF_LEADINGZERO      = (1L << 4),// Presence of leading 0 of the number is between 0 and 1
    DF_NOTHOUSANDSGROUP = (1L << 5) // Do not do any thousands grouping (commas)
}   DISPLAYFLAGS;


/////////////////////////////////////////////////////////////////////////////
// CTestITN_J
class ATL_NO_VTABLE CTestITN_J : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTestITN_J, &CLSID_TestITN_J>,
	public ISpCFGInterpreter
{
public:
    CTestITN_J() : m_pSite( NULL )
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TESTITN_J)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTestITN_J)
	COM_INTERFACE_ENTRY(ISpCFGInterpreter)
END_COM_MAP()

private:
    HRESULT InterpretNumber( const SPPHRASEPROPERTY *pProperties, 
                                const bool fCardinal,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);

    HRESULT InterpretDigitNumber( const SPPHRASEPROPERTY *pProperties, 
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);
    
    HRESULT InterpretFPNumber( const SPPHRASEPROPERTY *pProperties, 
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);

    HRESULT InterpretFraction( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);

    HRESULT InterpretDate( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);

    HRESULT InterpretTime( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);

    HRESULT InterpretDegrees( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);

    HRESULT InterpretMeasurement( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);

    HRESULT InterpretCurrency( const SPPHRASEPROPERTY *pProperties,
                                DOUBLE *pdblVal,
                                WCHAR *pszVal,
                                UINT cSize);
    
    HRESULT AddPropertyAndReplacement( const WCHAR *szBuff,
                                const DOUBLE dblValue,
                                const ULONG ulMinPos,
                                const ULONG ulMaxPos,
                                const ULONG ulFirstElement,
                                const ULONG ulCountOfElements );
                                //ISpCFGInterpreterSite *pSite );

    HRESULT MakeDisplayNumber( DOUBLE dblNum,
                            DWORD dwDisplayFlags,
                            UINT uiFixedWidth,
                            UINT uiDecimalPlaces,
                            WCHAR *pwszNum,
                            UINT cSize,
                            BOOL bForced );

    int MakeDigitStrig( const SPPHRASEPROPERTY *pProperties,
                             WCHAR *pwszDigitString,
                             UINT cSize );
    void GetNumberFormatDefaults();

private:
    // Data members
    NUMBERFMT   m_nmfmtDefault;
    TCHAR       m_pszDecimalSep[ MAX_LOCALE_DATA];
    TCHAR       m_pszThousandSep[MAX_LOCALE_DATA];
    TCHAR       m_pszLongDateFormat[ MAX_DATE_FORMAT ];

    ISpCFGInterpreterSite *m_pSite;

// ISpCFGInterptreter
public:
    STDMETHODIMP InitGrammar(const WCHAR * pszGrammarName, const void ** pvGrammarData);
    STDMETHODIMP Interpret(ISpPhraseBuilder * pInterpretRule, const ULONG ulFirstElement, const ULONG ulCountOfElements, ISpCFGInterpreterSite * pSite);
public:
    CComPtr<ISpPhraseBuilder> m_cpPhrase;   // Decalred as a member to prevent repeated construct/destroy
};

// Helper functions
ULONG ComputeNum9999(const SPPHRASEPROPERTY *pProperties );
void HandleDigitsAfterDecimal( WCHAR *pwszFormattedNum, 
                            UINT cSizeOfFormattedNum,
                            const WCHAR *pwszRightOfDecimal );
void FindDefaultNumberFormat( NUMBERFMT *pnfmt );
void GetMinAndMaxPos( const SPPHRASEPROPERTY *pProperties, ULONG *pulMinPos, ULONG *pulMaxPos );

int GetMonthName( int iMonth, WCHAR *pwszMonth, int cSize, bool fAbbrev );
int GetDayOfWeekName( int iDayOfWeek, WCHAR *pwszDayOfWeek, int cSize, bool fAbbrev );
int FormatDate( const SYSTEMTIME &stDate, TCHAR *pszFormat, WCHAR *pwszDate, int cSize, const WCHAR *pwszEmperor );

#endif //__TESTITN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\audiobufferqueue.inl ===
/****************************************************************************
*   audiobufferqueue.inl
*       Implementation of the CAudioBufferQueue template class used to
*       queue audio buffers for reading or writing asynchronously.
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#pragma once

/****************************************************************************
* CAudioBufferQueue<CBuffer>::MoveDoneBuffsToTailOf *
*---------------------------------------------------*
*   Description:  
*       Move buffers from this queue to the queue specified by DestQueue
*       if the are done with the async reading or writing.
*
*   Return:
*   The number of bytes moved to the DestQueue.
******************************************************************** robch */
template <class CBuffer>
ULONG CAudioBufferQueue<CBuffer>::MoveDoneBuffsToTailOf(CAudioBufferQueue<CBuffer> & DestQueue)
{
    ULONG cbMoved = 0;
    CBuffer * pPrev = NULL;
    for (CBuffer * pBuff = m_pHead; pBuff; )
    {
        CBuffer * pNext = pBuff->m_pNext;
        if (pBuff->IsAsyncDone())
        {
            cbMoved += pBuff->GetWriteOffset();
            if (pPrev)
            {
                pPrev->m_pNext = pBuff->m_pNext;
                if (pBuff->m_pNext == NULL)
                {
                    m_pTail = pPrev;
                }
            }
            else
            {
                m_pHead = pBuff->m_pNext;
            }
            DestQueue.InsertTail(pBuff);
        }
        else
        {
            pPrev = pBuff;
        }
        pBuff = pNext;
    }
    return cbMoved;
};

/****************************************************************************
* CAudioBufferQueue<CBuffer>::AreMinSamplesQueuedForWrite *
*---------------------------------------------------------*
*   Description:  
*       Determine if there are enough buffers queued for writing.
*
*   Return:
*   TRUE/FALSE if there are enoughs buffers queued for writing.
******************************************************************** robch */
template <class CBuffer>
BOOL CAudioBufferQueue<CBuffer>::AreMinSamplesQueuedForWrite(ULONG cbSamples)
{
    CBuffer * pBuff = m_pHead;
    while (pBuff)
    {
        if (pBuff->GetWriteOffset() >= cbSamples)
        {
            return TRUE;
        }
        cbSamples -= pBuff->GetWriteOffset();
        pBuff = pBuff->m_pNext;
    }
    return FALSE;
};

/****************************************************************************
* CAudioBufferQueue<CBuffer>::AreMoreReadBuffersRequired *
*--------------------------------------------------------*
*   Description:  
*       Determine if we need more buffers for reading.
*
*   Return:
*   TRUE/FALSE if we need more buffers for reading
******************************************************************** robch */
template <class CBuffer>
BOOL CAudioBufferQueue<CBuffer>::AreMoreReadBuffersRequired(ULONG cbMinSamples)
{
    CBuffer * pBuff = m_pHead;
    while (pBuff)
    {
        if (pBuff->GetDataSize() >= cbMinSamples)
        {
            return FALSE;
        }
        cbMinSamples -= pBuff->GetDataSize();
        pBuff = pBuff->m_pNext;
    }
    return TRUE;
};

/****************************************************************************
* CAudioBufferQueue<CBuffer>::GetToProcessBuffer *
*------------------------------------------------*
*   Description:  
*       Get the next buffer to process
*
*   Return:
*   buffer
******************************************************************* YUNUSM */
template <class CBuffer>
CBuffer * CAudioBufferQueue<CBuffer>::GetToProcessBuffer(void)
{
    for (CBuffer * pBuff = m_pHead; pBuff; pBuff = pBuff->m_pNext)
    {
        if (0 == pBuff->IsAsyncDone())
            return pBuff;
    }

    return NULL;
}


/****************************************************************************
* CAudioBufferQueue<CBuffer>::GetQueuedDataSize *
*-----------------------------------------------*
*   Description:  
*       Get the size of data in the queue
*
*   Return:
*   size of data
******************************************************************* YUNUSM */
template <class CBuffer>
ULONG CAudioBufferQueue<CBuffer>::GetQueuedDataSize(void)
{
    ULONG cbData = 0;
    for (CBuffer * pBuff = m_pHead; pBuff; pBuff = pBuff->m_pNext)
    {
        cbData += pBuff->GetWriteOffset();
    }

    return cbData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\audioui.cpp ===
/******************************************************************************
* AudioUI.cpp *
*-------------*
*  This is the implementation of CAudioUI.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 07/31/00
*  All Rights Reserved
*
****************************************************************** AGARSIDE ***/

#include "stdafx.h"
#include "..\cpl\resource.h"
#include "sapiint.h"
#include "AudioUI.h"

/****************************************************************************
* CAudioUI::IsUISupported *
*-------------------------*
*   Description:  Determines if the supplied standard UI component is 
*       supported by the audio.
*
*   Returns:
*       *pfSupported - set to TRUE if the specified standard UI component 
*                      is supported.
*       E_INVALIDARG - If one of the supplied arguments is invalid.
*
**************************************************************** AGARSIDE ***/

STDMETHODIMP CAudioUI::IsUISupported(const WCHAR * pszTypeOfUI, 
                                    void * pvExtraData,
                                    ULONG cbExtraData,
                                    IUnknown *punkObject, 
                                    BOOL *pfSupported)
{
    SPDBG_FUNC("CAudioUI::IsUISupported");
    HRESULT hr = S_OK;
    
    // Validate the params
    if (pvExtraData != NULL && SPIsBadReadPtr(pvExtraData, cbExtraData))
    {
        hr = E_INVALIDARG;
    }
    else if (SP_IS_BAD_WRITE_PTR(pfSupported) ||
             (punkObject!=NULL && SP_IS_BAD_INTERFACE_PTR(punkObject)))
    {
        hr = E_POINTER;
    }
    if (SUCCEEDED(hr))
    {
        *pfSupported = FALSE;
    }
    // Test to see if punkObject is a Recognition Instance or Context
    if (SUCCEEDED(hr) && punkObject != NULL)
    {
        CComPtr<ISpRecognizer>  cpRecognizer;
        CComPtr<ISpRecoContext> cpRecoCtxt;
        CComPtr<ISpMMSysAudio>  cpAudio;
        
        if (FAILED(punkObject->QueryInterface(&cpRecoCtxt)) &&
            FAILED(punkObject->QueryInterface(&cpRecognizer)) &&
            FAILED(punkObject->QueryInterface(&cpAudio)))
        {
            hr = E_INVALIDARG;
        }
    }
    
    // We support audio objects.
    if (SUCCEEDED(hr) && punkObject != NULL && 
        (wcscmp(pszTypeOfUI, SPDUI_AudioProperties) == 0 ||
         wcscmp(pszTypeOfUI, SPDUI_AudioVolume) == 0))
    {
        CComPtr<ISpMMSysAudioConfig> cpAudioConfig;
        if (SUCCEEDED(punkObject->QueryInterface(&cpAudioConfig)))
        {
            BOOL bHasMixer;
            if (SUCCEEDED(cpAudioConfig->HasMixer(&bHasMixer)))
            {
                if (bHasMixer)
                {
                    *pfSupported = TRUE;
                }
            }
        }
    }
    
    return S_OK;
}


/****************************************************************************
* CAudioUI::DisplayUI *
*---------------------*
*   Description:
*
*   Returns:
*
**************************************************************** AGARSIDE ***/

STDMETHODIMP CAudioUI::DisplayUI(HWND hwndParent, 
                                const WCHAR * pszTitle, 
                                const WCHAR * pszTypeOfUI, 
                                void * pvExtraData,
                                ULONG cbExtraData,
                                ISpObjectToken * pToken, 
                                IUnknown * punkObject)
{
    SPDBG_FUNC("CAudioUI::DisplayUI");
    HRESULT hr = S_OK;
    
    // Validate the params
    if (!IsWindow(hwndParent) ||
        SP_IS_BAD_READ_PTR(pszTitle))
    {
        hr = E_INVALIDARG;
    }
    else if (SP_IS_BAD_INTERFACE_PTR(pToken) ||
            (punkObject != NULL && SP_IS_BAD_INTERFACE_PTR(punkObject)))
    {
        hr = E_POINTER;
    }

    if (SUCCEEDED(hr) && wcscmp(pszTypeOfUI, SPDUI_AudioProperties) == 0)
    {
        const HWND hwndOldFocus = ::GetFocus();
        
        if (punkObject)
        {
            hr = punkObject->QueryInterface(&m_cpAudioConfig);
        }
        if (m_cpAudioConfig)
        {
            hr = SpLoadCpl(&m_hCpl);
            if (SUCCEEDED(hr))
            {
#ifndef _WIN32_WCE
                ::DialogBoxParam(   m_hCpl, 
                                    MAKEINTRESOURCE( IDD_AUDIO_PROPERTIES ),
                                    hwndParent, 
                                    (DLGPROC) AudioDlgProc,
                                    (LPARAM) this );
#else
                DialogBoxParam(   m_hCpl, 
                                    MAKEINTRESOURCE( IDD_AUDIO_PROPERTIES ),
                                    hwndParent, 
                                    (DLGPROC) AudioDlgProc,
                                    (LPARAM) this );
#endif
                ::FreeLibrary(m_hCpl);
                m_hCpl = NULL;
            }
        }

        // Restore the focus to whoever had the focus before
        ::SetFocus( hwndOldFocus );
    }

    if (SUCCEEDED(hr) && wcscmp(pszTypeOfUI, SPDUI_AudioVolume) == 0)
    {
        if (punkObject)
        {
            hr = punkObject->QueryInterface(&m_cpAudioConfig);
        }
        if (m_cpAudioConfig)
        {
            hr = m_cpAudioConfig->DisplayMixer();
        }
    }

    // ISSUE - What do we do if we've been asked to display something we don't support?
    
    return hr;
}

/*****************************************************************************
* CAudioDlg::OnInitDialog *
*-------------------------*
*   Description:
*       Dialog Initialization
****************************************************************** BECKYW ***/
void CAudioUI::OnInitDialog(HWND hWnd)
{
    USES_CONVERSION;
    SPDBG_FUNC( "CAudioDlg::OnInitDialog" );
    HRESULT hr = S_OK;
    SPDBG_ASSERT(IsWindow(hWnd));
    m_hDlg = hWnd;

    // Set the appropriate captions
    TCHAR pszString[ MAX_LOADSTRING ];

    // Main Window Caption
    ::LoadString( m_hCpl, 
        IDS_AUDIO_PROPERTIES,
        pszString, MAX_LOADSTRING );
    ::SendMessage( hWnd, WM_SETTEXT, 0, (LPARAM) pszString );

    // Group Box Caption
    ::LoadString( m_hCpl,
        IDS_ADVANCED_GROUPBOX,
        pszString, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_ADVANCED_GROUPBOX ), 
        WM_SETTEXT, 0, (LPARAM) pszString );

    // Automatic Caption
    ::LoadString( m_hCpl,
        IDS_AUTOMATIC_MM_LINE,
        pszString, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_AUTOMATIC_MM_LINE ), 
        WM_SETTEXT, 0, (LPARAM) pszString );

    // Specific Caption
    ::LoadString( m_hCpl,
        IDS_THIS_MM_LINE,
        pszString, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_THIS_MM_LINE ), 
        WM_SETTEXT, 0, (LPARAM) pszString );
    // MSAA Specific Caption
    ::LoadString( m_hCpl,
        IDS_THIS_MM_LINE2,
        pszString, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_THIS_MM_LINE2 ), 
        WM_SETTEXT, 0, (LPARAM) pszString );

    // Add device name.
    CComPtr<ISpObjectWithToken> cpObjectWithToken;
    CComPtr<ISpObjectToken>     cpObjectToken;
    CComPtr<ISpObjectToken>     cpDataKey;
    hr = m_cpAudioConfig.QueryInterface(&cpObjectWithToken);
    if (SUCCEEDED(hr))
    {
        hr = cpObjectWithToken->GetObjectToken(&cpObjectToken);
    }
    if (SUCCEEDED(hr))
    {
        hr = cpObjectToken->QueryInterface(&cpDataKey);
    }
    if (SUCCEEDED(hr))
    {
        CSpDynamicString dstrName;
        hr = cpDataKey->GetStringValue(L"", &dstrName);
        if (SUCCEEDED(hr))
        {
            ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_DEVICE_NAME ), 
                WM_SETTEXT, 0, (LPARAM) W2T(dstrName) );
        }
    }
    hr = S_OK;

    // This message will cause the check button to be correct.
    BOOL bAutomatic = FALSE;
    hr = m_cpAudioConfig->Get_UseAutomaticLine(&bAutomatic);
    ::SendMessage( ::GetDlgItem(m_hDlg, bAutomatic?IDC_AUTOMATIC_MM_LINE:IDC_THIS_MM_LINE), BM_SETCHECK, true, 0L );
    hr = S_OK;

    if (bAutomatic)
    {
        // This message will cause the combo box to be correctly accessible.
        ::SendMessage( m_hDlg, WM_COMMAND, MAKELONG( IDC_AUTOMATIC_MM_LINE, BN_CLICKED ),
            (LPARAM) ::GetDlgItem( m_hDlg, IDC_AUTOMATIC_MM_LINE ) );
    }

    WCHAR *szCoMemLineList = NULL;
    hr = m_cpAudioConfig->Get_LineNames(&szCoMemLineList);
    if (SUCCEEDED(hr))
    {
        WCHAR *szTmp = szCoMemLineList;
        while (szTmp[0] != 0)
        {
            ::SendMessage( ::GetDlgItem(m_hDlg, IDC_MM_LINE), CB_ADDSTRING, 0, (LPARAM)W2T(szTmp) );
            szTmp += wcslen(szTmp) + 1;
        }
        ::CoTaskMemFree(szCoMemLineList);
    }
    hr = S_OK;

    // Set selection to first item or item stored in registry.
    UINT dwLineIndex;
    if (SUCCEEDED(hr))
    {
        dwLineIndex = 0; // In case of failure - pick first line.
        hr = m_cpAudioConfig->Get_Line(&dwLineIndex);
        ::SendMessage( ::GetDlgItem(m_hDlg, IDC_MM_LINE), CB_SETCURSEL, (WPARAM)dwLineIndex, 0);
    }
    hr = S_OK;

    ::SetCursor( ::LoadCursor( NULL, IDC_ARROW ) );
} /* CAudioDlg::OnInitDialog */

/*****************************************************************************
* CAudioDlg::OnDestroy *
*----------------------*
*   Description:
*       Destruction
**************************************************************** AGARSIDE ***/
void CAudioUI::OnDestroy()
{
    SPDBG_FUNC( "CAudioDlg::OnDestroy" );

//    SpDestroyTokenComboBox( ::GetDlgItem( m_hDlg, IDC_DEFAULT_DEVICE ) );
} /* CAudioDlg::OnDestroy */

/*****************************************************************************
* CAudioDlg::SaveSettings *
*-------------------------*
*   Description:
*       Destruction
**************************************************************** AGARSIDE ***/
HRESULT CAudioUI::SaveSettings(void)
{
    SPDBG_FUNC("CAudioUI::SaveSettings");
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
    {
        // Save automatic state.
        BOOL bAutomatic;
        bAutomatic = (BOOL)::SendMessage( ::GetDlgItem(m_hDlg, IDC_AUTOMATIC_MM_LINE), BM_GETCHECK, 0, 0 );
        hr = m_cpAudioConfig->Set_UseAutomaticLine(bAutomatic);
    }
    if (SUCCEEDED(hr))
    {
        // Save line index - even if not used because automatic is set.
        UINT dwLineIndex;
        dwLineIndex = (UINT)::SendMessage( ::GetDlgItem(m_hDlg, IDC_MM_LINE), CB_GETCURSEL, 0, 0);
        if (dwLineIndex != static_cast<UINT>(-1))
        {
            hr = m_cpAudioConfig->Set_Line(dwLineIndex);
        }
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/*****************************************************************************
* AudioDlgProc *
*--------------*
*   Description:
*       DLGPROC for choosing the advanced audio properties
**************************************************************** AGARSIDE ***/
BOOL CALLBACK AudioDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAudioUI *pAudioUIDlg = (CAudioUI *) ::GetWindowLongPtr( hWnd, GWLP_USERDATA );
    SPDBG_FUNC( "AudioDlgProc" );

    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            // pAudioUIDlg comes in on the lParam
            pAudioUIDlg = (CAudioUI *) lParam;

            // Set pAudioUIDlg to the window long so we can get it later
            ::SetWindowLongPtr( hWnd, GWLP_USERDATA, lParam );

            pAudioUIDlg->OnInitDialog(hWnd);
            break;
        }

        case WM_DESTROY:
        {
            pAudioUIDlg->OnDestroy();
            break;
        }

        case WM_COMMAND:
        {
            if ( LOWORD( wParam ) == IDOK )
            {
                // Save any changes.
                pAudioUIDlg->SaveSettings();

                ::EndDialog( hWnd, true );
            }
        
            else if ( LOWORD( wParam ) == IDCANCEL )
            {
                // There are no changes to commit
                ::EndDialog( hWnd, false );
            }

            // Handle a selection change for the audio device
            else if (( IDC_MM_LINE == LOWORD( wParam ) ) &&
                     ( CBN_SELCHANGE == HIWORD( wParam ) ))
            {
                // Nothing to do here.
            }

            // Handle a click to either the preferred or 'this device' radio buttons
            else if (HIWORD(wParam) == BN_CLICKED)
            {
                bool bAutomatic = false;
                if( LOWORD(wParam) == IDC_AUTOMATIC_MM_LINE)
                {
                    bAutomatic = true;
                }
                else
                {
                    SPDBG_ASSERT(LOWORD(wParam) == IDC_THIS_MM_LINE);
                }

                ::EnableWindow( ::GetDlgItem(pAudioUIDlg->GetHDlg(), IDC_MM_LINE), !bAutomatic );
            }
            break;
       }
    }

    return FALSE;
} /* AudioDlgProc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_customstream.h ===
// CustomStream.h : Declaration of the CCustomStream

#ifndef __CUSTOMSTREAM_H_
#define __CUSTOMSTREAM_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCustomStream
class ATL_NO_VTABLE CCustomStream : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CCustomStream, &CLSID_SpCustomStream>
    //--- Automation
    #ifdef SAPI_AUTOMATION
	,public IDispatchImpl<ISpeechCustomStream, &IID_ISpeechCustomStream, &LIBID_SpeechLib, 5> 
    #endif
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTRY_RESOURCEID(IDR_SPCUSTOMSTREAM)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CCustomStream)
        #ifdef SAPI_AUTOMATION
	    COM_INTERFACE_ENTRY(ISpeechCustomStream)
	    COM_INTERFACE_ENTRY(ISpeechBaseStream)
	    COM_INTERFACE_ENTRY(IDispatch)
        #endif

	    COM_INTERFACE_ENTRY_AGGREGATE(IID_IStream, m_cpAgg.p)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_ISequentialStream, m_cpAgg.p)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_ISpStreamFormat, m_cpAgg.p)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_ISpStream, m_cpAgg.p)

        //--- Automation
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    CCustomStream(){}

	HRESULT FinalConstruct();
	void FinalRelease();

  /*=== Interfaces ====*/
  public:
#ifdef SAPI_AUTOMATION

    //--- ISpeechCustomStream -----------------------------------------------------------
    STDMETHODIMP putref_BaseStream(IUnknown *pUnkStream);
    STDMETHODIMP get_BaseStream(IUnknown **ppUnkStream);

    //--- ISpeechBaseStream -------------------------------------------------------
    STDMETHODIMP get_Format(ISpeechAudioFormat** StreamFormat);
    STDMETHODIMP putref_Format(ISpeechAudioFormat *pFormat);
    STDMETHODIMP Read(VARIANT* Buffer, long NumBytes, long* pRead);
    STDMETHODIMP Write(VARIANT Buffer, long* pWritten);
    STDMETHODIMP Seek(VARIANT Move, SpeechStreamSeekPositionType Origin, VARIANT* NewPosition);

    CComPtr<IUnknown> m_cpAgg;
    CComPtr<ISpStream> m_cpStream;
    CComPtr<ISpStreamAccess> m_cpAccess;

#endif // SAPI_AUTOMATION

  /*=== Member Data ===*/
  protected:
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_audio.h ===
/*******************************************************************************
* a_audio.h *
*-----------*
*   Description:
*       This is the header file for the CSpeechAudioStatus and the 
*       CSpeechAudioBufferInfo implementations.
*-------------------------------------------------------------------------------
*  Created By: TODDT                            Date: 1/3/2001
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef a_audio_h
#define a_audio_h

#ifdef SAPI_AUTOMATION

//--- Additional includes

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================

//=== Enumerated Set Definitions ===================================

typedef enum _AudioBufferInfoValidate
{
    abivEventBias = 1,
    abivMinNotification,
    abivBufferSize          
} AudioBufferInfoValidate;

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================


/*** CSpeechAudioStatus
*   This object is used to access the audio status info from
*   the associated audio object.
*/
class ATL_NO_VTABLE CSpeechAudioStatus : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechAudioStatus, &IID_ISpeechAudioStatus, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechAudioStatus)
	    COM_INTERFACE_ENTRY(ISpeechAudioStatus)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      CSpeechAudioStatus() { ZeroMemory( &m_AudioStatus, sizeof(m_AudioStatus) ); }
    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechAudioStatus ----------------------------------
    STDMETHOD(get_FreeBufferSpace)(long* pFreeBufferSpace);
    STDMETHOD(get_NonBlockingIO)(long* pNonBlockingIO);
    STDMETHOD(get_State)(SpeechAudioState* pState);
    STDMETHOD(get_CurrentSeekPosition)(VARIANT* pCurrentSeekPosition);
    STDMETHOD(get_CurrentDevicePosition)(VARIANT* pCurrentDevicePosition);

    /*=== Member Data ===*/
    SPAUDIOSTATUS           m_AudioStatus;
};

/*** CSpeechAudioBufferInfo
*   This object is used to access the Audio buffer info from
*   the associated audio object.
*/
class ATL_NO_VTABLE CSpeechAudioBufferInfo : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechAudioBufferInfo, &IID_ISpeechAudioBufferInfo, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechAudioBufferInfo)
	    COM_INTERFACE_ENTRY(ISpeechAudioBufferInfo)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/
    void FixupBufferInfo( SPAUDIOBUFFERINFO * pBufferInfo, AudioBufferInfoValidate abiv );
   
  /*=== Interfaces ====*/
  public:
    //--- ISpeechAudioBufferInfo ----------------------------------
    STDMETHOD(get_MinNotification)(long* MinNotification);
    STDMETHOD(put_MinNotification)(long MinNotification);
    STDMETHOD(get_BufferSize)(long* BufferSize);
    STDMETHOD(put_BufferSize)(long BufferSize);
    STDMETHOD(get_EventBias)(long* EventBias);
    STDMETHOD(put_EventBias)(long EventBias);

    /*=== Member Data ===*/
    CComPtr<ISpMMSysAudio>      m_pSpMMSysAudio;
};

#endif // SAPI_AUTOMATION

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_enums.cpp ===
/*******************************************************************************
* a_phenum.cpp *
*------------*
*   Description:
*       This module is the main implementation file for the CEnumElements, CEnumPhraseRules,
*       CEnumProperties, CEnumReplacements, and CEnumAlternates automation methods for 
*       the ISpeechPhraseInfo collections.
*-------------------------------------------------------------------------------
*  Created By: Leonro                                        Date: 12/18/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "a_enums.h"

#ifdef SAPI_AUTOMATION

//
//=== CEnumElements::IEnumVARIANT interface =================================================
//

/*****************************************************************************
* CEnumElements::Clone *
*--------------------*
*       
*   This method creates a copy of the current state of ISpeechPhraseElements enumeration.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumElements::Clone( IEnumVARIANT** ppEnum )
{
    SPDBG_FUNC( "CEnumElements::Clone" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppEnum ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
        CComObject<CEnumElements>* pEnum;

        hr = CComObject<CEnumElements>::CreateInstance( &pEnum );
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_CurrIndex  = m_CurrIndex;
            pEnum->m_cpElements = m_cpElements;
            *ppEnum = pEnum;
        }
    }
    return hr;
}  /* CEnumElements::Clone */

/*****************************************************************************
* CEnumElements::Next *
*-------------------*
*
*       This method gets the next items in the ISpeechPhraseElements enumeration 
*       sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumElements::Next( ULONG celt, VARIANT* rgelt, ULONG* pceltFetched )
{
    SPDBG_FUNC( "CEnumElements::Next" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    ULONG   i = 0;

    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pceltFetched ) || SP_IS_BAD_WRITE_PTR( rgelt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Get the number of total Elements in the collection
        hr = m_cpElements->get_Count( &NumElements );

        // Retrieve the next celt elements
        for( i=0; 
            SUCCEEDED( hr ) && m_CurrIndex<(ULONG)NumElements && i<celt; 
            m_CurrIndex++, i++ )
        {
            CComPtr<ISpeechPhraseElement> pElement;

            hr = m_cpElements->Item( m_CurrIndex, &pElement );
            
            if( SUCCEEDED( hr ) )
            {
                rgelt[i].vt = VT_DISPATCH;
                hr = pElement->QueryInterface( IID_IDispatch, (void**)&rgelt[i].pdispVal );
            }
        }

        if( pceltFetched )
        {
            *pceltFetched = i;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = ( i < celt ) ? S_FALSE : hr;        
    }
    else
    {
        for( i=0; i < celt; i++ )
        {
            VariantClear( &rgelt[i] );
        }
    }

    return hr;

}  /* CEnumElements::Next */


/*****************************************************************************
* CEnumElements::Skip *
*--------------------*
*       
*   This method Attempts to skip over the next celt elements in the ISpeechPhraseElements 
*   enumeration sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumElements::Skip( ULONG celt )
{
    SPDBG_FUNC( "CEnumElements::Skip" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    
    m_CurrIndex += celt; 

    hr = m_cpElements->get_Count( &NumElements );

    if( SUCCEEDED( hr ) && m_CurrIndex > (ULONG)NumElements )
    {
        m_CurrIndex = (ULONG)NumElements;
        hr = S_FALSE;
    }
   
    return hr;
}  /* CEnumElements::Skip */


//
//=== CEnumPhraseRules::IEnumVARIANT interface =================================================
//

/*****************************************************************************
* CEnumPhraseRules::Clone *
*--------------------*
*       
*   This method creates a copy of the current state of ISpeechPhraseRules enumeration.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumPhraseRules::Clone( IEnumVARIANT** ppEnum )
{
    SPDBG_FUNC( "CEnumPhraseRules::Clone" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppEnum ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
        CComObject<CEnumPhraseRules>* pEnum;

        hr = CComObject<CEnumPhraseRules>::CreateInstance( &pEnum );
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_CurrIndex  = m_CurrIndex;
            pEnum->m_cpRules = m_cpRules;
            *ppEnum = pEnum;
        }
    }
    return hr;
}  /* CEnumPhraseRules::Clone */

/*****************************************************************************
* CEnumPhraseRules::Next *
*-------------------*
*
*       This method gets the next items in the ISpeechPhraseRules enumeration 
*       sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumPhraseRules::Next( ULONG celt, VARIANT* rgelt, ULONG* pceltFetched )
{
    SPDBG_FUNC( "CEnumPhraseRules::Next" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    ULONG   i = 0;

    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pceltFetched ) || SP_IS_BAD_WRITE_PTR( rgelt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Get the number of total Elements in the collection
        hr = m_cpRules->get_Count( &NumElements );

        // Retrieve the next celt elements
        for( i=0; 
            SUCCEEDED( hr ) && m_CurrIndex<(ULONG)NumElements && i<celt; 
            m_CurrIndex++, i++ )
        {
            CComPtr<ISpeechPhraseRule> pRule;

            hr = m_cpRules->Item( m_CurrIndex, &pRule );
            
            if( SUCCEEDED( hr ) )
            {
                rgelt[i].vt = VT_DISPATCH;
                hr = pRule->QueryInterface( IID_IDispatch, (void**)&rgelt[i].pdispVal );
            }
        }

        if( pceltFetched )
        {
            *pceltFetched = i;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = ( i < celt ) ? S_FALSE : hr;        
    }
    else
    {
        for( i=0; i < celt; i++ )
        {
            VariantClear( &rgelt[i] );
        }
    }

    return hr;

}  /* CEnumPhraseRules::Next */


/*****************************************************************************
* CEnumPhraseRules::Skip *
*--------------------*
*       
*   This method Attempts to skip over the next celt elements in the ISpeechPhraseRules 
*   enumeration sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumPhraseRules::Skip( ULONG celt )
{
    SPDBG_FUNC( "CEnumPhraseRules::Skip" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    
    m_CurrIndex += celt; 

    hr = m_cpRules->get_Count( &NumElements );

    if( SUCCEEDED( hr ) && m_CurrIndex > (ULONG)NumElements )
    {
        m_CurrIndex = (ULONG)NumElements;
        hr = S_FALSE;
    }
   
    return hr;
}  /* CEnumPhraseRules::Skip */

//
//=== CEnumProperties::IEnumVARIANT interface =================================================
//

/*****************************************************************************
* CEnumProperties::Clone *
*--------------------*
*       
*   This method creates a copy of the current state of ISpeechPhraseProperties enumeration.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumProperties::Clone( IEnumVARIANT** ppEnum )
{
    SPDBG_FUNC( "CEnumProperties::Clone" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppEnum ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
        CComObject<CEnumProperties>* pEnum;

        hr = CComObject<CEnumProperties>::CreateInstance( &pEnum );
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_CurrIndex  = m_CurrIndex;
            pEnum->m_cpProperties = m_cpProperties;
            *ppEnum = pEnum;
        }
    }
    return hr;
}  /* CEnumProperties::Clone */

/*****************************************************************************
* CEnumProperties::Next *
*-------------------*
*
*       This method gets the next items in the ISpeechPhraseProperties enumeration 
*       sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumProperties::Next( ULONG celt, VARIANT* rgelt, ULONG* pceltFetched )
{
    SPDBG_FUNC( "CEnumProperties::Next" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    ULONG   i = 0;

    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pceltFetched ) || SP_IS_BAD_WRITE_PTR( rgelt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Get the number of total Elements in the collection
        hr = m_cpProperties->get_Count( &NumElements );

        // Retrieve the next celt elements
        for( i=0; 
            SUCCEEDED( hr ) && m_CurrIndex<(ULONG)NumElements && i<celt; 
            m_CurrIndex++, i++ )
        {
            CComPtr<ISpeechPhraseProperty> pProperty;

            hr = m_cpProperties->Item( m_CurrIndex, &pProperty );
            
            if( SUCCEEDED( hr ) )
            {
                rgelt[i].vt = VT_DISPATCH;
                hr = pProperty->QueryInterface( IID_IDispatch, (void**)&rgelt[i].pdispVal );
            }
        }

        if( pceltFetched )
        {
            *pceltFetched = i;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = ( i < celt ) ? S_FALSE : hr;        
    }
    else
    {
        for( i=0; i < celt; i++ )
        {
            VariantClear( &rgelt[i] );
        }
    }

    return hr;

}  /* CEnumProperties::Next */


/*****************************************************************************
* CEnumProperties::Skip *
*--------------------*
*       
*   This method Attempts to skip over the next celt elements in the ISpeechPhraseProperties 
*   enumeration sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumProperties::Skip( ULONG celt )
{
    SPDBG_FUNC( "CEnumProperties::Skip" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    
    m_CurrIndex += celt; 

    hr = m_cpProperties->get_Count( &NumElements );

    if( SUCCEEDED( hr ) && m_CurrIndex > (ULONG)NumElements )
    {
        m_CurrIndex = (ULONG)NumElements;
        hr = S_FALSE;
    }
   
    return hr;
}  /* CEnumProperties::Skip */


//
//=== CEnumReplacements::IEnumVARIANT interface =================================================
//

/*****************************************************************************
* CEnumReplacements::Clone *
*--------------------*
*       
*   This method creates a copy of the current state of ISpeechPhraseReplacements enumeration.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumReplacements::Clone( IEnumVARIANT** ppEnum )
{
    SPDBG_FUNC( "CEnumReplacements::Clone" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppEnum ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
        CComObject<CEnumReplacements>* pEnum;

        hr = CComObject<CEnumReplacements>::CreateInstance( &pEnum );
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_CurrIndex  = m_CurrIndex;
            pEnum->m_cpReplacements = m_cpReplacements;
            *ppEnum = pEnum;
        }
    }
    return hr;
}  /* CEnumReplacements::Clone */

/*****************************************************************************
* CEnumReplacements::Next *
*-------------------*
*
*       This method gets the next items in the ISpeechPhraseReplacements enumeration 
*       sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumReplacements::Next( ULONG celt, VARIANT* rgelt, ULONG* pceltFetched )
{
    SPDBG_FUNC( "CEnumReplacements::Next" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    ULONG   i = 0;

    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pceltFetched ) || SP_IS_BAD_WRITE_PTR( rgelt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Get the number of total Elements in the collection
        hr = m_cpReplacements->get_Count( &NumElements );

        // Retrieve the next celt elements
        for( i=0; 
            SUCCEEDED( hr ) && m_CurrIndex<(ULONG)NumElements && i<celt; 
            m_CurrIndex++, i++ )
        {
            CComPtr<ISpeechPhraseReplacement> pReplacement;

            hr = m_cpReplacements->Item( m_CurrIndex, &pReplacement );
            
            if( SUCCEEDED( hr ) )
            {
                rgelt[i].vt = VT_DISPATCH;
                hr = pReplacement->QueryInterface( IID_IDispatch, (void**)&rgelt[i].pdispVal );
            }
        }

        if( pceltFetched )
        {
            *pceltFetched = i;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = ( i < celt ) ? S_FALSE : hr;        
    }
    else
    {
        for( i=0; i < celt; i++ )
        {
            VariantClear( &rgelt[i] );
        }
    }

    return hr;

}  /* CEnumReplacements::Next */


/*****************************************************************************
* CEnumReplacements::Skip *
*--------------------*
*       
*   This method Attempts to skip over the next celt elements in the ISpeechPhraseReplacements 
*   enumeration sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumReplacements::Skip( ULONG celt )
{
    SPDBG_FUNC( "CEnumReplacements::Skip" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    
    m_CurrIndex += celt; 

    hr = m_cpReplacements->get_Count( &NumElements );

    if( SUCCEEDED( hr ) && m_CurrIndex > (ULONG)NumElements )
    {
        m_CurrIndex = (ULONG)NumElements;
        hr = S_FALSE;
    }
   
    return hr;
}  /* CEnumReplacements::Skip */

//
//=== CEnumAlternates::IEnumVARIANT interface =================================================
//

/*****************************************************************************
* CEnumAlternates::Clone *
*--------------------*
*       
*   This method creates a copy of the current state of ISpeechPhraseAlternates enumeration.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumAlternates::Clone( IEnumVARIANT** ppEnum )
{
    SPDBG_FUNC( "CEnumAlternates::Clone" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppEnum ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
        CComObject<CEnumAlternates>* pEnum;

        hr = CComObject<CEnumAlternates>::CreateInstance( &pEnum );
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_CurrIndex  = m_CurrIndex;
            pEnum->m_cpAlternates = m_cpAlternates;
            *ppEnum = pEnum;
        }
    }
    return hr;
}  /* CEnumAlternates::Clone */

/*****************************************************************************
* CEnumAlternates::Next *
*-------------------*
*
*       This method gets the next items in the ISpeechPhraseAlternates enumeration 
*       sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumAlternates::Next( ULONG celt, VARIANT* rgelt, ULONG* pceltFetched )
{
    SPDBG_FUNC( "CEnumAlternates::Next" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    ULONG   i = 0;

    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pceltFetched ) || SP_IS_BAD_WRITE_PTR( rgelt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Get the number of total Elements in the collection
        hr = m_cpAlternates->get_Count( &NumElements );

        // Retrieve the next celt elements
        for( i=0; 
            SUCCEEDED( hr ) && m_CurrIndex<(ULONG)NumElements && i<celt; 
            m_CurrIndex++, i++ )
        {
            CComPtr<ISpeechPhraseAlternate> pAlternate;

            hr = m_cpAlternates->Item( m_CurrIndex, &pAlternate );
            
            if( SUCCEEDED( hr ) )
            {
                rgelt[i].vt = VT_DISPATCH;
                hr = pAlternate->QueryInterface( IID_IDispatch, (void**)&rgelt[i].pdispVal );
            }
        }

        if( pceltFetched )
        {
            *pceltFetched = i;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = ( i < celt ) ? S_FALSE : hr;        
    }
    else
    {
        for( i=0; i < celt; i++ )
        {
            VariantClear( &rgelt[i] );
        }
    }

    return hr;

}  /* CEnumAlternates::Next */


/*****************************************************************************
* CEnumAlternates::Skip *
*--------------------*
*       
*   This method Attempts to skip over the next celt elements in the ISpeechPhraseAlternates 
*   enumeration sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumAlternates::Skip( ULONG celt )
{
    SPDBG_FUNC( "CEnumAlternates::Skip" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    
    m_CurrIndex += celt; 

    hr = m_cpAlternates->get_Count( &NumElements );

    if( SUCCEEDED( hr ) && m_CurrIndex > (ULONG)NumElements )
    {
        m_CurrIndex = (ULONG)NumElements;
        hr = S_FALSE;
    }
   
    return hr;
}  /* CEnumAlternates::Skip */

//
//=== CEnumGrammarRules::IEnumVARIANT interface =================================================
//

/*****************************************************************************
* CEnumGrammarRules::Clone *
*--------------------*
*       
*   This method creates a copy of the current state of ISpeechGrammarRules enumeration.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumGrammarRules::Clone( IEnumVARIANT** ppEnum )
{
    SPDBG_FUNC( "CEnumGrammarRules::Clone" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppEnum ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
        CComObject<CEnumGrammarRules>* pEnum;

        hr = CComObject<CEnumGrammarRules>::CreateInstance( &pEnum );
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_CurrIndex  = m_CurrIndex;
            pEnum->m_cpGramRules = m_cpGramRules;
            *ppEnum = pEnum;
        }
    }
    return hr;
}  /* CEnumGrammarRules::Clone */

/*****************************************************************************
* CEnumGrammarRules::Next *
*-------------------*
*
*       This method gets the next items in the ISpeechGrammarRules enumeration 
*       sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumGrammarRules::Next( ULONG celt, VARIANT* rgelt, ULONG* pceltFetched )
{
    SPDBG_FUNC( "CEnumGrammarRules::Next" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    ULONG   i = 0;

    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pceltFetched ) || SP_IS_BAD_WRITE_PTR( rgelt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Get the number of total Elements in the collection
        hr = m_cpGramRules->get_Count( &NumElements );

        // Retrieve the next celt elements
        for( i=0; 
            SUCCEEDED( hr ) && m_CurrIndex<(ULONG)NumElements && i<celt; 
            m_CurrIndex++, i++ )
        {
            CComPtr<ISpeechGrammarRule> pGramRule;

            hr = m_cpGramRules->Item( m_CurrIndex, &pGramRule );
            
            if( SUCCEEDED( hr ) )
            {
                rgelt[i].vt = VT_DISPATCH;
                hr = pGramRule->QueryInterface( IID_IDispatch, (void**)&rgelt[i].pdispVal );
            }
        }

        if( pceltFetched )
        {
            *pceltFetched = i;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = ( i < celt ) ? S_FALSE : hr;        
    }
    else
    {
        for( i=0; i < celt; i++ )
        {
            VariantClear( &rgelt[i] );
        }
    }

    return hr;

}  /* CEnumGrammarRules::Next */


/*****************************************************************************
* CEnumGrammarRules::Skip *
*--------------------*
*       
*   This method Attempts to skip over the next celt elements in the ISpeechGrammarRules 
*   enumeration sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumGrammarRules::Skip( ULONG celt )
{
    SPDBG_FUNC( "CEnumGrammarRules::Skip" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    
    m_CurrIndex += celt; 

    hr = m_cpGramRules->get_Count( &NumElements );

    if( SUCCEEDED( hr ) && m_CurrIndex > (ULONG)NumElements )
    {
        m_CurrIndex = (ULONG)NumElements;
        hr = S_FALSE;
    }
   
    return hr;
}  /* CEnumGrammarRules::Skip */

//
//=== CEnumTransitions::IEnumVARIANT interface =================================================
//

/*****************************************************************************
* CEnumTransitions::Clone *
*-------------------------*
*       
*   This method creates a copy of the current state of ISpeechGrammarRules enumeration.
*
*******************************************************************  PhilSch ***/
STDMETHODIMP CEnumTransitions::Clone( IEnumVARIANT** ppEnum )
{
    SPDBG_FUNC( "CEnumTransitions::Clone" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppEnum ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
        CComObject<CEnumTransitions>* pEnum;

        hr = CComObject<CEnumTransitions>::CreateInstance( &pEnum );
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_CurrIndex  = m_CurrIndex;
            pEnum->m_cpTransitions= m_cpTransitions;
            *ppEnum = pEnum;
        }
    }
    return hr;
}  /* CEnumTransitions::Clone */

/*****************************************************************************
* CEnumTransitions::Next *
*-------------------*
*
*       This method gets the next items in the ISpeechPhraseAlternates enumeration 
*       sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumTransitions::Next( ULONG celt, VARIANT* rgelt, ULONG* pceltFetched )
{
    SPDBG_FUNC( "CEnumTransitions::Next" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    ULONG   i = 0;

    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pceltFetched ) || SP_IS_BAD_WRITE_PTR( rgelt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Get the number of total Elements in the collection
        hr = m_cpTransitions->get_Count( &NumElements );

        // Retrieve the next celt elements
        for( i=0; 
            SUCCEEDED( hr ) && m_CurrIndex<(ULONG)NumElements && i<celt; 
            m_CurrIndex++, i++ )
        {
            CComPtr<ISpeechGrammarRuleStateTransition> cpTransition;

            hr = m_cpTransitions->Item( m_CurrIndex, &cpTransition );
            
            if( SUCCEEDED( hr ) )
            {
                rgelt[i].vt = VT_DISPATCH;
                hr = cpTransition->QueryInterface( IID_IDispatch, (void**)&rgelt[i].pdispVal );
            }
        }

        if( pceltFetched )
        {
            *pceltFetched = i;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = ( i < celt ) ? S_FALSE : hr;        
    }
    else
    {
        for( i=0; i < celt; i++ )
        {
            VariantClear( &rgelt[i] );
        }
    }

    return hr;

}  /* CEnumTransitions::Next */


/*****************************************************************************
* CEnumTransitions::Skip *
*--------------------*
*       
*   This method Attempts to skip over the next celt elements in the ISpeechPhraseAlternates 
*   enumeration sequence.
*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumTransitions::Skip( ULONG celt )
{
    SPDBG_FUNC( "CEnumTransitions::Skip" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    
    m_CurrIndex += celt; 

    hr = m_cpTransitions->get_Count( &NumElements );

    if( SUCCEEDED( hr ) && m_CurrIndex > (ULONG)NumElements )
    {
        m_CurrIndex = (ULONG)NumElements;
        hr = S_FALSE;
    }
   
    return hr;
}  /* CEnumTransitions::Skip */

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_audio.cpp ===
/*******************************************************************************
* a_audio.cpp *
*-------------*
*   Description:
*       This module is the main implementation file for the CSpeechAudioStatus 
*   and CSpeechAudioBufferInfo automation objects.
*-------------------------------------------------------------------------------
*  Created By: TODDT                                        Date: 01/04/01
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "a_audio.h"
#include "a_helpers.h"

#ifdef SAPI_AUTOMATION

//
//=== ISpeechAudioStatus =====================================================
//

/*****************************************************************************
* CSpeechAudioStatus::get_FreeBufferSpace *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioStatus::get_FreeBufferSpace( long* pFreeBufferSpace )
{
    SPDBG_FUNC( "CSpeechAudioStatus::get_FreeBufferSpace" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pFreeBufferSpace ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pFreeBufferSpace = m_AudioStatus.cbFreeBuffSpace;
    }
    
    return hr;
} /* CSpeechAudioStatus::get_FreeBufferSpace */

/*****************************************************************************
* CSpeechAudioStatus::get_NonBlockingIO *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioStatus::get_NonBlockingIO( long* pNonBlockingIO )
{
    SPDBG_FUNC( "CSpeechAudioStatus::get_NonBlockingIO" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pNonBlockingIO ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pNonBlockingIO = (long)m_AudioStatus.cbNonBlockingIO;
    }
    
    return hr;
} /* CSpeechAudioStatus::get_NonBlockingIO */

/*****************************************************************************
* CSpeechAudioStatus::get_State *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioStatus::get_State( SpeechAudioState * pState )
{
    SPDBG_FUNC( "CSpeechAudioStatus::get_State" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pState ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pState = (SpeechAudioState)m_AudioStatus.State;
    }
    
    return hr;
} /* CSpeechAudioStatus::get_State */

/*****************************************************************************
* CSpeechAudioStatus::get_CurrentSeekPosition *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioStatus::get_CurrentSeekPosition( VARIANT* pCurrentSeekPosition )
{
    SPDBG_FUNC( "CSpeechAudioStatus::get_CurrentSeekPosition" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pCurrentSeekPosition ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = ULongLongToVariant( m_AudioStatus.CurSeekPos, pCurrentSeekPosition );
    }
    
    return hr;
} /* CSpeechAudioStatus::get_CurrentSeekPosition */

/*****************************************************************************
* CSpeechAudioStatus::get_CurrentDevicePosition *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioStatus::get_CurrentDevicePosition( VARIANT* pCurrentDevicePosition )
{
    SPDBG_FUNC( "CSpeechAudioStatus::get_CurrentDevicePosition" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pCurrentDevicePosition ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = ULongLongToVariant( m_AudioStatus.CurDevicePos, pCurrentDevicePosition );
    }
    
    return hr;
} /* CSpeechAudioStatus::get_CurrentDevicePosition */


//
//=== ISpeechAudioBufferInfo =====================================================
//

/*****************************************************************************
* CSpeechAudioBufferInfo::FixupBufferInfo *
*--------------------------*
*       
********************************************************************* TODDT ***/
void CSpeechAudioBufferInfo::FixupBufferInfo( SPAUDIOBUFFERINFO * pBufferInfo, AudioBufferInfoValidate abiv )
{
    SPDBG_FUNC( "CSpeechAudioBufferInfo::FixupBufferInfo" );

    switch ( abiv )
    {
    case abivEventBias:
        pBufferInfo->ulMsBufferSize = max(pBufferInfo->ulMsEventBias, pBufferInfo->ulMsBufferSize );
        break;
    case abivMinNotification:
        pBufferInfo->ulMsBufferSize = max(pBufferInfo->ulMsMinNotification*4, pBufferInfo->ulMsBufferSize );
        break;
    case abivBufferSize:
        pBufferInfo->ulMsMinNotification = min(pBufferInfo->ulMsMinNotification, pBufferInfo->ulMsBufferSize/4 );
        pBufferInfo->ulMsEventBias = min(pBufferInfo->ulMsEventBias, pBufferInfo->ulMsBufferSize );
        break;
    }
}

/*****************************************************************************
* CSpeechAudioBufferInfo::get_MinNotification *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioBufferInfo::get_MinNotification( long* pMinNotification )
{
    SPDBG_FUNC( "CSpeechAudioBufferInfo::get_MinNotification" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pMinNotification ) )
    {
        hr = E_POINTER;
    }
    else
    {
        SPAUDIOBUFFERINFO   BufferInfo;
        hr = m_pSpMMSysAudio->GetBufferInfo( &BufferInfo );
        if (SUCCEEDED( hr ) )
        {
            *pMinNotification = (long)BufferInfo.ulMsMinNotification;
        }
    }
    
    return hr;
} /* CSpeechAudioBufferInfo::get_MinNotification */

/*****************************************************************************
* CSpeechAudioBufferInfo::put_MinNotification *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioBufferInfo::put_MinNotification( long MinNotification )
{
    SPDBG_FUNC( "CSpeechAudioBufferInfo::put_MinNotification" );
    HRESULT hr = S_OK;

    SPAUDIOBUFFERINFO   BufferInfo;
    hr = m_pSpMMSysAudio->GetBufferInfo( &BufferInfo );
    if (SUCCEEDED( hr ) )
    {
        BufferInfo.ulMsMinNotification = (ULONG)MinNotification;
        FixupBufferInfo( &BufferInfo, abivMinNotification );
        hr = m_pSpMMSysAudio->SetBufferInfo( &BufferInfo );
    }
    return hr;
} /* CSpeechAudioBufferInfo::put_MinNotification */

/*****************************************************************************
* CSpeechAudioBufferInfo::get_BufferSize *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioBufferInfo::get_BufferSize( long* pBufferSize )
{
    SPDBG_FUNC( "CSpeechAudioBufferInfo::get_BufferSize" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pBufferSize ) )
    {
        hr = E_POINTER;
    }
    else
    {
        SPAUDIOBUFFERINFO   BufferInfo;
        hr = m_pSpMMSysAudio->GetBufferInfo( &BufferInfo );
        if (SUCCEEDED( hr ) )
        {
            *pBufferSize = (long)BufferInfo.ulMsBufferSize;
        }
    }
    
    return hr;
} /* CSpeechAudioBufferInfo::get_BufferSize */

/*****************************************************************************
* CSpeechAudioBufferInfo::put_BufferSize *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioBufferInfo::put_BufferSize( long BufferSize )
{
    SPDBG_FUNC( "CSpeechAudioBufferInfo::put_BufferSize" );
    HRESULT hr = S_OK;

    SPAUDIOBUFFERINFO   BufferInfo;
    hr = m_pSpMMSysAudio->GetBufferInfo( &BufferInfo );
    if (SUCCEEDED( hr ) )
    {
        BufferInfo.ulMsBufferSize = (ULONG)BufferSize;
        FixupBufferInfo( &BufferInfo, abivBufferSize );
        hr = m_pSpMMSysAudio->SetBufferInfo( &BufferInfo );
    }
    return hr;
} /* CSpeechAudioBufferInfo::put_BufferSize */

/*****************************************************************************
* CSpeechAudioBufferInfo::get_EventBias *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioBufferInfo::get_EventBias( long* pEventBias )
{
    SPDBG_FUNC( "CSpeechAudioBufferInfo::get_EventBias" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pEventBias ) )
    {
        hr = E_POINTER;
    }
    else
    {
        SPAUDIOBUFFERINFO   BufferInfo;
        hr = m_pSpMMSysAudio->GetBufferInfo( &BufferInfo );
        if (SUCCEEDED( hr ) )
        {
            *pEventBias = (long)BufferInfo.ulMsEventBias;
        }
    }
    
    return hr;
} /* CSpeechAudioBufferInfo::get_EventBias */

/*****************************************************************************
* CSpeechAudioBufferInfo::put_EventBias *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioBufferInfo::put_EventBias( long EventBias )
{
    SPDBG_FUNC( "CSpeechAudioBufferInfo::put_EventBias" );
    HRESULT hr = S_OK;

    SPAUDIOBUFFERINFO   BufferInfo;
    hr = m_pSpMMSysAudio->GetBufferInfo( &BufferInfo );
    if (SUCCEEDED( hr ) )
    {
        BufferInfo.ulMsEventBias = (ULONG)EventBias;
        FixupBufferInfo( &BufferInfo, abivEventBias );
        hr = m_pSpMMSysAudio->SetBufferInfo( &BufferInfo );
    }
    return hr;
} /* CSpeechAudioBufferInfo::put_EventBias */

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\audioui.h ===
/******************************************************************************
* AudioUI.h *
*-----------*
*  This is the header file for the CAudioUI implementation.
*------------------------------------------------------------------------------
*  Copyright (C) 2000 Microsoft Corporation         Date: 07/31/00
*  All Rights Reserved
*
****************************************************************** AGARSIDE ***/

#ifndef __AudioUI_h__
#define __AudioUI_h__

#define MAX_LOADSTRING      256

class ATL_NO_VTABLE CAudioUI : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAudioUI, &CLSID_SpAudioUI>,
	public ISpTokenUI
{
public:
	CAudioUI()
	{
        m_hCpl = NULL;
        m_hDlg = NULL;
	}

    ~CAudioUI()
    {
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_SPAUDIOUI)

    BEGIN_COM_MAP(CAudioUI)
	    COM_INTERFACE_ENTRY(ISpTokenUI)
    END_COM_MAP()

public:
//-- ISpTokenUI -----------------------------------------------------------
	STDMETHODIMP    IsUISupported(
                                    const WCHAR * pszTypeOfUI, 
                                    void *pvExtraData,
                                    ULONG cbExtraData,
                                    IUnknown *punkObject, 
                                    BOOL *pfSupported);
    STDMETHODIMP    DisplayUI(
	                                HWND hwndParent,
                                    const WCHAR * pszTitle, 
                                    const WCHAR * pszTypeOfUI, 
                                    void * pvExtraData,
                                    ULONG cbExtraData,
                                    ISpObjectToken * pToken, 
                                    IUnknown * punkObject);

private:
    void            OnDestroy(void);
    void            OnInitDialog(HWND hWnd);
    HWND            GetHDlg(void) { return m_hDlg; };
    HRESULT         SaveSettings(void);    

    HMODULE         m_hCpl;
    HWND            m_hDlg;

    CComPtr<ISpMMSysAudioConfig> m_cpAudioConfig;

friend BOOL CALLBACK AudioDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

BOOL CALLBACK AudioDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif  // #ifndef __AudioUI_h__ - Keep as the last line of the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_enums.h ===
/*******************************************************************************
* a_enums.h *
*-----------*
*   Description:
*       This is the header file for CEnumElements. This object is used to enum 
*       the PhraseElements via variants.
*-------------------------------------------------------------------------------
*  Created By: Leonro                            Date: 12/18/00
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef a_enums_h
#define a_enums_h

#ifdef SAPI_AUTOMATION

//--- Additional includes
#include "resource.h"

//=== Constants ====================================================

class ATL_NO_VTABLE CEnumElements : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IEnumVARIANT
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CEnumElements)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      CEnumElements() : m_CurrIndex(0) {}

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- IEnumVARIANT ----------------------------------
    STDMETHOD(Clone)(IEnumVARIANT** ppEnum);
    STDMETHOD(Next)(ULONG celt, VARIANT* rgelt, ULONG* pceltFetched);
    STDMETHOD(Reset)(void) { m_CurrIndex = 0; return S_OK;}
    STDMETHOD(Skip)(ULONG celt); 
    
    

  /*=== Member Data ===*/
    CComPtr<ISpeechPhraseElements>      m_cpElements;
    ULONG                               m_CurrIndex;
};

class ATL_NO_VTABLE CEnumPhraseRules : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IEnumVARIANT
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CEnumPhraseRules)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      CEnumPhraseRules() : m_CurrIndex(0) {}

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- IEnumVARIANT ----------------------------------
    STDMETHOD(Clone)(IEnumVARIANT** ppEnum);
    STDMETHOD(Next)(ULONG celt, VARIANT* rgelt, ULONG* pceltFetched);
    STDMETHOD(Reset)(void) { m_CurrIndex = 0; return S_OK;}
    STDMETHOD(Skip)(ULONG celt); 
    
    

  /*=== Member Data ===*/
    CComPtr<ISpeechPhraseRules>         m_cpRules;
    ULONG                               m_CurrIndex;
};

class ATL_NO_VTABLE CEnumProperties : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IEnumVARIANT
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CEnumProperties)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      CEnumProperties() : m_CurrIndex(0) {}

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- IEnumVARIANT ----------------------------------
    STDMETHOD(Clone)(IEnumVARIANT** ppEnum);
    STDMETHOD(Next)(ULONG celt, VARIANT* rgelt, ULONG* pceltFetched);
    STDMETHOD(Reset)(void) { m_CurrIndex = 0; return S_OK;}
    STDMETHOD(Skip)(ULONG celt); 
    
    

  /*=== Member Data ===*/
    CComPtr<ISpeechPhraseProperties>    m_cpProperties;
    ULONG                               m_CurrIndex;
};


class ATL_NO_VTABLE CEnumReplacements : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IEnumVARIANT
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CEnumReplacements)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      CEnumReplacements() : m_CurrIndex(0) {}

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- IEnumVARIANT ----------------------------------
    STDMETHOD(Clone)(IEnumVARIANT** ppEnum);
    STDMETHOD(Next)(ULONG celt, VARIANT* rgelt, ULONG* pceltFetched);
    STDMETHOD(Reset)(void) { m_CurrIndex = 0; return S_OK;}
    STDMETHOD(Skip)(ULONG celt); 
    
    

  /*=== Member Data ===*/
    CComPtr<ISpeechPhraseReplacements>  m_cpReplacements;
    ULONG                               m_CurrIndex;
};

class ATL_NO_VTABLE CEnumAlternates : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IEnumVARIANT
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CEnumAlternates)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      CEnumAlternates() : m_CurrIndex(0) {}

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- IEnumVARIANT ----------------------------------
    STDMETHOD(Clone)(IEnumVARIANT** ppEnum);
    STDMETHOD(Next)(ULONG celt, VARIANT* rgelt, ULONG* pceltFetched);
    STDMETHOD(Reset)(void) { m_CurrIndex = 0; return S_OK;}
    STDMETHOD(Skip)(ULONG celt); 
    
    

  /*=== Member Data ===*/
    CComPtr<ISpeechPhraseAlternates>    m_cpAlternates;
    ULONG                               m_CurrIndex;
};


class ATL_NO_VTABLE CEnumGrammarRules : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IEnumVARIANT
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CEnumGrammarRules)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      CEnumGrammarRules() : m_CurrIndex(0) {}

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- IEnumVARIANT ----------------------------------
    STDMETHOD(Clone)(IEnumVARIANT** ppEnum);
    STDMETHOD(Next)(ULONG celt, VARIANT* rgelt, ULONG* pceltFetched);
    STDMETHOD(Reset)(void) { m_CurrIndex = 0; return S_OK;}
    STDMETHOD(Skip)(ULONG celt); 
    
    

  /*=== Member Data ===*/
    CComPtr<ISpeechGrammarRules>        m_cpGramRules;
    ULONG                               m_CurrIndex;
};


class ATL_NO_VTABLE CEnumTransitions : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IEnumVARIANT
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CEnumTransitions)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      CEnumTransitions() : m_CurrIndex(0) {}

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- IEnumVARIANT ----------------------------------
    STDMETHOD(Clone)(IEnumVARIANT** ppEnum);
    STDMETHOD(Next)(ULONG celt, VARIANT* rgelt, ULONG* pceltFetched);
    STDMETHOD(Reset)(void) { m_CurrIndex = 0; return S_OK;}
    STDMETHOD(Skip)(ULONG celt); 
    
    

  /*=== Member Data ===*/
    CComPtr<ISpeechGrammarRuleStateTransitions>     m_cpTransitions;
    ULONG                                           m_CurrIndex;
};

#endif // SAPI_AUTOMATION

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_customstream.cpp ===
// CustomStream.cpp : Implementation of CCustomStream
#include "stdafx.h"

#ifndef __sapi_h__
#include <sapi.h>
#endif

#include "a_CustomStream.h"
#include "wavstream.h"
#include "a_helpers.h"

/****************************************************************************
* CCustomStream::FinalConstruct *
*----------------------------*
*   Description:
*
*   Returns:
*       Success code if object should be created
*
********************************************************************* RAL ***/

HRESULT CCustomStream::FinalConstruct()
{
    SPDBG_FUNC("CCustomStream::FinalConstruct");
    HRESULT hr = S_OK;

    hr = ::CoCreateInstance( CLSID_SpStream, GetUnknown(), CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&m_cpAgg);

    if(SUCCEEDED(hr))
    {
        hr = m_cpAgg->QueryInterface(&m_cpStream);
    }

    if(SUCCEEDED(hr))
    {
        // We QI'd for an inner interface so we should release
        GetUnknown()->Release(); 
    }

    if(SUCCEEDED(hr))
    {
        hr = m_cpAgg->QueryInterface(&m_cpAccess);
    }

    if(SUCCEEDED(hr))
    {
        // We QI'd for an inner interface so we should release
        GetUnknown()->Release(); 
    }

    if(SUCCEEDED(hr))
    {
        GUID guid; WAVEFORMATEX *pWaveFormat;

        hr = SpConvertStreamFormatEnum(g_DefaultWaveFormat, &guid, &pWaveFormat);

        if(SUCCEEDED(hr))
        {
            hr = m_cpAccess->SetFormat(guid, pWaveFormat);
            ::CoTaskMemFree(pWaveFormat);
        }
    }

    return hr;
}

/****************************************************************************
* CCustomStream::FinalRelease *
*--------------------------*
*   Description:
*
*   Returns:
*       void
*
********************************************************************* RAL ***/

void CCustomStream::FinalRelease()
{
    SPDBG_FUNC("CCustomStream::FinalRelease");

    GetUnknown()->AddRef(); 
    m_cpStream.Release();

    GetUnknown()->AddRef(); 
    m_cpAccess.Release();

    m_cpAgg.Release();
}


//
//=== ISpeechBaseStream interface =================================================
//

/*****************************************************************************
* CCustomStream::get_Format *
*------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CCustomStream::get_Format( ISpeechAudioFormat** ppStreamFormat )
{
    SPDBG_FUNC( "CCustomStream::get_Format" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppStreamFormat ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Create new object.
        CComObject<CSpeechWavAudioFormat> *pFormat;
        hr = CComObject<CSpeechWavAudioFormat>::CreateInstance( &pFormat );
        if ( SUCCEEDED( hr ) )
        {
            pFormat->AddRef();
            pFormat->m_cpStreamAccess = m_cpAccess;
            *ppStreamFormat = pFormat;
        }
    }

    return hr;
} /* CCustomStream::get_Format */

/*****************************************************************************
* CCustomStream::Read *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CCustomStream::Read( VARIANT* pvtBuffer, long NumBytes, long* pRead )
{
    SPDBG_FUNC( "CCustomStream::Read" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pvtBuffer ) || SP_IS_BAD_WRITE_PTR( pRead ) )
    {
        hr = E_POINTER;
    }
    else
    {
        VariantClear(pvtBuffer);

        BYTE *pArray;
        SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, NumBytes );
        if( psa )
        {
            if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
            {
                hr = m_cpStream->Read(pArray, NumBytes, (ULONG*)pRead);
                SafeArrayUnaccessData( psa );
                pvtBuffer->vt     = VT_ARRAY | VT_UI1;
                pvtBuffer->parray = psa;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
} /* CCustomStream::Read */

/*****************************************************************************
* CCustomStream::Write *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CCustomStream::Write( VARIANT Buffer, long* pWritten )
{
    SPDBG_FUNC( "CCustomStream::Write" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pWritten ) )
    {
        hr = E_POINTER;
    }
    else
    {
        BYTE * pData = NULL;
        ULONG ulDataSize = 0;

        hr = AccessVariantData( &Buffer, &pData, &ulDataSize );

        if( SUCCEEDED( hr ) )
        {
            hr = m_cpStream->Write(pData, ulDataSize, (ULONG*)pWritten);
            UnaccessVariantData( &Buffer, pData );
        }
    }

    return hr;
} /* CCustomStream::Write */

/*****************************************************************************
* CCustomStream::Seek *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CCustomStream::Seek( VARIANT Pos, SpeechStreamSeekPositionType Origin, VARIANT *pNewPosition )
{
    SPDBG_FUNC( "CCustomStream::Seek" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pNewPosition ) )
    {
        hr = E_POINTER;
    }
    else
    {
        ULARGE_INTEGER uliNewPos;
        LARGE_INTEGER liPos;

        hr = VariantToLongLong( &Pos, &(liPos.QuadPart) );
        if (SUCCEEDED(hr))
        {
            hr = m_cpStream->Seek(liPos, (DWORD)Origin, &uliNewPos);

            if (SUCCEEDED( hr ))
            {
                hr = ULongLongToVariant( uliNewPos.QuadPart, pNewPosition );
            }
        }
    }

    return hr;
} /* CCustomStream::Seek */


/*****************************************************************************
* CCustomStream::putref_Format *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CCustomStream::putref_Format(ISpeechAudioFormat *pFormat)
{
    SPDBG_FUNC( "CCustomStream::putref_Format" );
    HRESULT hr;

    GUID Guid; WAVEFORMATEX *pWaveFormatEx;
    BSTR bstrGuid;
    hr = pFormat->get_Guid(&bstrGuid);

    if(SUCCEEDED(hr))
    {
        hr = IIDFromString(bstrGuid, &Guid);
    }

    CComPtr<ISpeechWaveFormatEx> cpWaveEx;
    if(SUCCEEDED(hr))
    {
        hr = pFormat->GetWaveFormatEx(&cpWaveEx);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaveFormatExFromInterface(cpWaveEx, &pWaveFormatEx);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_cpAccess->SetFormat(Guid, pWaveFormatEx);
        ::CoTaskMemFree(pWaveFormatEx);
    }
    
    return hr;
}


/*****************************************************************************
* CCustomStream::putref_BaseStream *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CCustomStream::putref_BaseStream(IUnknown *pUnkStream)
{
    SPDBG_FUNC( "CCustomStream::putref_BaseStream" );
    HRESULT hr;

    CComPtr<IStream> cpStream;
    hr = pUnkStream->QueryInterface(IID_IStream, (void**)&cpStream);
    if(SUCCEEDED(hr))
    {
        GUID guid; WAVEFORMATEX *pWaveFormat;
        hr = m_cpAccess->_GetFormat(&guid, &pWaveFormat);

        if(SUCCEEDED(hr))
        {
            hr = m_cpStream->SetBaseStream(cpStream, guid, pWaveFormat);
            ::CoTaskMemFree(pWaveFormat);
        }
    }
    return hr;
}

/*****************************************************************************
* CCustomStream::get_BaseStream *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CCustomStream::get_BaseStream(IUnknown **ppUnkStream)
{
    HRESULT hr;

    CComPtr<IStream> cpStream;
    hr = m_cpStream->GetBaseStream(&cpStream);
    if(hr == S_OK)
    {
        hr = cpStream->QueryInterface(IID_IUnknown, (void**)ppUnkStream);
        if(SUCCEEDED(hr))
        {
            (*ppUnkStream)->AddRef();
        }
    }
    else if(hr == S_FALSE)
    {
        *ppUnkStream = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_filestream.cpp ===
// FileStream.cpp : Implementation of CFileStream
#include "stdafx.h"

#ifndef __sapi_h__
#include <sapi.h>
#endif

#include "a_FileStream.h"
#include "wavstream.h"
#include "a_helpers.h"

/****************************************************************************
* CFileStream::FinalConstruct *
*----------------------------*
*   Description:
*
*   Returns:
*       Success code if object should be created
*
********************************************************************* RAL ***/

HRESULT CFileStream::FinalConstruct()
{
    SPDBG_FUNC("CFileStream::FinalConstruct");
    HRESULT hr = S_OK;

    hr = ::CoCreateInstance( CLSID_SpStream, GetUnknown(), CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&m_cpAgg);

    if(SUCCEEDED(hr))
    {
        hr = m_cpAgg->QueryInterface(&m_cpStream);
    }

    if(SUCCEEDED(hr))
    {
        // We QI'd for an inner interface so we should release
        GetUnknown()->Release(); 
    }

    if(SUCCEEDED(hr))
    {
        hr = m_cpAgg->QueryInterface(&m_cpAccess);
    }

    if(SUCCEEDED(hr))
    {
        // We QI'd for an inner interface so we should release
        GetUnknown()->Release(); 
    }

    if(SUCCEEDED(hr))
    {
        GUID guid; WAVEFORMATEX *pWaveFormat;

        hr = SpConvertStreamFormatEnum(g_DefaultWaveFormat, &guid, &pWaveFormat);

        if(SUCCEEDED(hr))
        {
            hr = m_cpAccess->SetFormat(guid, pWaveFormat);
            ::CoTaskMemFree(pWaveFormat);
        }
    }

    return hr;
}

/****************************************************************************
* CFileStream::FinalRelease *
*--------------------------*
*   Description:
*
*   Returns:
*       void
*
********************************************************************* RAL ***/

void CFileStream::FinalRelease()
{
    SPDBG_FUNC("CFileStream::FinalRelease");

    GetUnknown()->AddRef(); 
    m_cpStream.Release();

    GetUnknown()->AddRef(); 
    m_cpAccess.Release();

    m_cpAgg.Release();
}

//
//=== ISpeechBaseStream interface =================================================
//

/*****************************************************************************
* CFileStream::get_Format *
*------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CFileStream::get_Format( ISpeechAudioFormat** ppStreamFormat )
{
    SPDBG_FUNC( "CFileStream::get_Format" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppStreamFormat ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Create new object.
        CComObject<CSpeechWavAudioFormat> *pFormat;
        hr = CComObject<CSpeechWavAudioFormat>::CreateInstance( &pFormat );
        if ( SUCCEEDED( hr ) )
        {
            pFormat->AddRef();
            pFormat->m_cpStreamAccess = m_cpAccess;
            *ppStreamFormat = pFormat;
        }
    }

    return hr;
} /* CFileStream::get_Format */

/*****************************************************************************
* CFileStream::Read *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CFileStream::Read( VARIANT* pvtBuffer, long NumBytes, long* pRead )
{
    SPDBG_FUNC( "CFileStream::Read" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pvtBuffer ) || SP_IS_BAD_WRITE_PTR( pRead ) )
    {
        hr = E_POINTER;
    }
    else
    {
        VariantClear(pvtBuffer);

        BYTE *pArray;
        SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, NumBytes );
        if( psa )
        {
            if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
            {
                hr = m_cpStream->Read(pArray, NumBytes, (ULONG*)pRead);
                SafeArrayUnaccessData( psa );
                pvtBuffer->vt     = VT_ARRAY | VT_UI1;
                pvtBuffer->parray = psa;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
} /* CFileStream::Read */

/*****************************************************************************
* CFileStream::Write *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CFileStream::Write( VARIANT Buffer, long* pWritten )
{
    SPDBG_FUNC( "CFileStream::Write" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pWritten ) )
    {
        hr = E_POINTER;
    }
    else
    {
        BYTE * pData = NULL;
        ULONG ulDataSize = 0;

        hr = AccessVariantData( &Buffer, &pData, &ulDataSize );

        if( SUCCEEDED( hr ) )
        {
            hr = m_cpStream->Write(pData, ulDataSize, (ULONG*)pWritten);
            UnaccessVariantData( &Buffer, pData );
        }
    }

    return hr;
} /* CFileStream::Write */

/*****************************************************************************
* CFileStream::Seek *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CFileStream::Seek( VARIANT Pos, SpeechStreamSeekPositionType Origin, VARIANT *pNewPosition )
{
    SPDBG_FUNC( "CFileStream::Seek" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pNewPosition ) )
    {
        hr = E_POINTER;
    }
    else
    {
        ULARGE_INTEGER uliNewPos;
        LARGE_INTEGER liPos;

        hr = VariantToLongLong( &Pos, &(liPos.QuadPart) );
        if (SUCCEEDED(hr))
        {
            hr = m_cpStream->Seek(liPos, (DWORD)Origin, &uliNewPos);

            if (SUCCEEDED( hr ))
            {
                hr = ULongLongToVariant( uliNewPos.QuadPart, pNewPosition );
            }
        }
    }

    return hr;
} /* CFileStream::Seek */


/*****************************************************************************
* CFileStream::putref_Format *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CFileStream::putref_Format(ISpeechAudioFormat *pFormat)
{
    SPDBG_FUNC( "CFileStream::putref_Format" );
    HRESULT hr;

    GUID Guid; WAVEFORMATEX *pWaveFormatEx;
    BSTR bstrGuid;
    hr = pFormat->get_Guid(&bstrGuid);

    if(SUCCEEDED(hr))
    {
        hr = IIDFromString(bstrGuid, &Guid);
    }

    CComPtr<ISpeechWaveFormatEx> cpWaveEx;
    if(SUCCEEDED(hr))
    {
        hr = pFormat->GetWaveFormatEx(&cpWaveEx);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaveFormatExFromInterface(cpWaveEx, &pWaveFormatEx);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_cpAccess->SetFormat(Guid, pWaveFormatEx);
        ::CoTaskMemFree(pWaveFormatEx);
    }
    
    return hr;
}

/*****************************************************************************
* CFileStream::Open *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CFileStream::Open(BSTR FileName, SpeechStreamFileMode FileMode, VARIANT_BOOL DoEvents)
{
    SPDBG_FUNC( "CFileStream::Open" );
    HRESULT hr;

    GUID guid; WAVEFORMATEX *pWaveFormat;
    hr = m_cpAccess->_GetFormat(&guid, &pWaveFormat);

    if(SUCCEEDED(hr))
    {
        hr = m_cpStream->BindToFile(FileName, (SPFILEMODE)FileMode, &guid, pWaveFormat, DoEvents ? SPFEI_ALL_TTS_EVENTS : 0);
        ::CoTaskMemFree(pWaveFormat);
    }
    
    return hr;
}

/*****************************************************************************
* CFileStream::Close *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CFileStream::Close(void)
{
    HRESULT hr;

    hr = m_cpStream->Close();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_filestream.h ===
// FileStream.h : Declaration of the CFileStream

#ifndef __FILESTREAM_H_
#define __FILESTREAM_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CFileStream
class ATL_NO_VTABLE CFileStream : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CFileStream, &CLSID_SpFileStream>
    //--- Automation
    #ifdef SAPI_AUTOMATION
	,public IDispatchImpl<ISpeechFileStream, &IID_ISpeechFileStream, &LIBID_SpeechLib, 5>
    #endif
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTRY_RESOURCEID(IDR_SPFILESTREAM)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CFileStream)
        #ifdef SAPI_AUTOMATION
	    COM_INTERFACE_ENTRY(ISpeechFileStream)
	    COM_INTERFACE_ENTRY(ISpeechBaseStream)
	    COM_INTERFACE_ENTRY(IDispatch)
        #endif

        // Support these interfaces on the underlying ISpStream object
	    COM_INTERFACE_ENTRY_AGGREGATE(IID_IStream, m_cpAgg.p)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_ISequentialStream, m_cpAgg.p)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_ISpStreamFormat, m_cpAgg.p)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_ISpStream, m_cpAgg.p)

        // These interfaces may be on the underlying ISpStream object
        COM_INTERFACE_ENTRY_AGGREGATE(IID_ISpEventSource, m_cpAgg.p)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_ISpEventSink, m_cpAgg.p)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_ISpTranscript, m_cpAgg.p)

        //--- Automation
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    CFileStream(){}

	HRESULT FinalConstruct();
	void FinalRelease();

  /*=== Interfaces ====*/
  public:
#ifdef SAPI_AUTOMATION

    //--- ISpeechFileStream -----------------------------------------------------------
    STDMETHODIMP Open(BSTR FileName, SpeechStreamFileMode FileMode, VARIANT_BOOL DoEvents);
    STDMETHODIMP Close(void);

    //--- ISpeechBaseStream -------------------------------------------------------
    STDMETHODIMP get_Format(ISpeechAudioFormat** StreamFormat);
    STDMETHODIMP putref_Format(ISpeechAudioFormat *pFormat);
    STDMETHODIMP Read(VARIANT* Buffer, long NumBytes, long* pRead);
    STDMETHODIMP Write(VARIANT Buffer, long* pWritten);
    STDMETHODIMP Seek(VARIANT Move, SpeechStreamSeekPositionType Origin, VARIANT* NewPosition);

    CComPtr<IUnknown> m_cpAgg;
    CComPtr<ISpStream> m_cpStream;
    CComPtr<ISpStreamAccess> m_cpAccess;

#endif // SAPI_AUTOMATION

  /*=== Member Data ===*/
  protected:
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_lexicon.cpp ===
/*******************************************************************************
* a_lexicon.cpp *
*-------------*
*   Description:
*       This module is the implementation file for the the CSpeechLexicon
*   automation object and related objects.
*-------------------------------------------------------------------------------
*  Created By: davewood                                    Date: 11/20/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "CommonLx.h"
#include "lexicon.h"
#include "dict.h"
#include "a_lexicon.h"
#include "a_helpers.h"


/*****************************************************************************
* CSpLexicon::get_GenerationId *
*--------------------------------------*
*       
**************************************************************** davewood ***/
STDMETHODIMP CSpLexicon::get_GenerationId( long* GenerationId )
{
    SPDBG_FUNC("CSpLexicon::get_GenerationId");
    HRESULT hr;
    DWORD dwGenerationId;

    hr = GetGeneration(&dwGenerationId);
    if(SUCCEEDED(hr))
    {
        *GenerationId = dwGenerationId;
    }
    return hr;
}

/*****************************************************************************
* CSpLexicon::AddPronunciation *
*--------------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpLexicon::AddPronunciation(BSTR bstrWord,
                         SpeechLanguageId LangId,
                         SpeechPartOfSpeech PartOfSpeech,
                         BSTR bstrPronunciation)
{
    SPDBG_FUNC("CSpLexicon::AddPronunciation");
    HRESULT hr = S_OK;

    // Note that bad pointer for bstrWord is caught by AddPronunciation call below.
    if ( SP_IS_BAD_OPTIONAL_STRING_PTR( bstrPronunciation ) )
    {
        return E_INVALIDARG;
    }

    bstrPronunciation = EmptyStringToNull(bstrPronunciation);

    if ( bstrPronunciation )
    {
        CComPtr<ISpPhoneConverter> cpPhoneConv;
        hr = SpCreatePhoneConverter((LANGID)LangId, NULL, NULL, &cpPhoneConv);

        if(SUCCEEDED(hr))
        {
            WCHAR sz[SP_MAX_PRON_LENGTH + 1];
            hr = cpPhoneConv->PhoneToId(bstrPronunciation, sz);
            
            if(SUCCEEDED(hr))
            {
                hr = AddPronunciation(bstrWord, (LANGID)LangId, (SPPARTOFSPEECH)PartOfSpeech, sz);
            }
        }
    }
    else
    {
        hr = AddPronunciation(bstrWord, (LANGID)LangId, (SPPARTOFSPEECH)PartOfSpeech, bstrPronunciation);
    }

    return hr;
}

/*****************************************************************************
* CSpLexicon::AddPronunciationByPhoneIds *
*--------------------------------------*
*       
****************************************************************** Leonro ***/
STDMETHODIMP CSpLexicon::AddPronunciationByPhoneIds(BSTR bstrWord,
                         SpeechLanguageId LangId,
                         SpeechPartOfSpeech PartOfSpeech,
                         VARIANT* PhoneIds)
{
    SPDBG_FUNC("CSpLexicon::AddPronunciationByPhoneIds");
    HRESULT             hr = S_OK;
    SPPHONEID           *pIds = NULL;

    if ( PhoneIds && SP_IS_BAD_VARIANT_PTR(PhoneIds) )
    {
        return E_INVALIDARG;
    }

    if(PhoneIds)
    {
        hr = VariantToPhoneIds(PhoneIds, &pIds);
    }

    if(SUCCEEDED(hr))
    {
        hr = AddPronunciation( bstrWord, (LANGID)LangId, (SPPARTOFSPEECH)PartOfSpeech, pIds );
        delete pIds;
    }

    return hr;
}

/*****************************************************************************
* CSpLexicon::RemovePronunciation *
*--------------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpLexicon::RemovePronunciation(BSTR bstrWord,
                            SpeechLanguageId LangId,
                            SpeechPartOfSpeech PartOfSpeech,
                            BSTR bstrPronunciation)
{
    SPDBG_FUNC("CSpLexicon::RemovePronunciation");
    HRESULT hr;

    // Note that bad pointer for bstrWord is caught by AddPronunciation call below.
    if ( SP_IS_BAD_OPTIONAL_STRING_PTR( bstrPronunciation ) )
    {
        return E_INVALIDARG;
    }

    bstrPronunciation = EmptyStringToNull(bstrPronunciation);

    if( bstrPronunciation )
    {
        CComPtr<ISpPhoneConverter> cpPhoneConv;
        hr = SpCreatePhoneConverter((LANGID)LangId, NULL, NULL, &cpPhoneConv);

        if(SUCCEEDED(hr))
        {
            WCHAR sz[SP_MAX_PRON_LENGTH + 1];
            hr = cpPhoneConv->PhoneToId(bstrPronunciation, sz);
            
            if(SUCCEEDED(hr))
            {
                hr = RemovePronunciation(bstrWord, (LANGID)LangId, (SPPARTOFSPEECH)PartOfSpeech, sz);
            }
        }
    }
    else
    {
        hr = RemovePronunciation(bstrWord, (LANGID)LangId, (SPPARTOFSPEECH)PartOfSpeech, bstrPronunciation);
    }

    return hr;
}

/*****************************************************************************
* CSpLexicon::RemovePronunciationByPhoneIds *
*--------------------------------------*
*       
****************************************************************** Leonro ***/
STDMETHODIMP CSpLexicon::RemovePronunciationByPhoneIds(BSTR bstrWord,
                            SpeechLanguageId LangId,
                            SpeechPartOfSpeech PartOfSpeech,
                            VARIANT* PhoneIds)
{
    SPDBG_FUNC("CSpLexicon::RemovePronunciationByPhoneIds");
    HRESULT             hr = S_OK;
    SPPHONEID           *pIds = NULL;

    if ( PhoneIds && SP_IS_BAD_VARIANT_PTR(PhoneIds) )
    {
        return E_INVALIDARG;
    }

    if(PhoneIds)
    {
        hr = VariantToPhoneIds(PhoneIds, &pIds);
    }

    if( SUCCEEDED( hr ) )
    {
        hr = RemovePronunciation( bstrWord, (LANGID)LangId, (SPPARTOFSPEECH)PartOfSpeech, pIds );
        delete pIds;
    }

    return hr;
}

/*****************************************************************************
* CSpLexicon::GetWords *
*--------------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpLexicon::GetWords(SpeechLexiconType TypeFlags,
                 long* GenerationID,
                 ISpeechLexiconWords** ppWords )
{

    SPDBG_FUNC("CSpLexicon::GetWords");
    HRESULT hr;

    CComObject<CSpeechLexiconWords> *pLexiconWords;
    hr = CComObject<CSpeechLexiconWords>::CreateInstance( &pLexiconWords );
    if( SUCCEEDED( hr ) )
    {
        pLexiconWords->AddRef();

        // Removed cookie from interface;
        DWORD Cookie = 0;
        DWORD Generation = 0;
        if(GenerationID == NULL)
        {
            GenerationID = (long*)&Generation;
        }

        SPWORDSETENTRY *pWordSet;
        do
        {
            hr = pLexiconWords->m_WordSet.CreateNode(&pWordSet);

            if(SUCCEEDED(hr))
            {
                hr = GetWords((DWORD)TypeFlags, (DWORD*)GenerationID, &Cookie, &pWordSet->WordList);
            }

            if(SUCCEEDED(hr))
            {
                pLexiconWords->m_WordSet.InsertHead(pWordSet);
            }
        }
        while(hr == S_FALSE);


        if( SUCCEEDED( hr ) )
        {
            *ppWords = pLexiconWords;

            // Count words
            for(pWordSet = pLexiconWords->m_WordSet.GetHead(); pWordSet != NULL; pWordSet = pLexiconWords->m_WordSet.GetNext(pWordSet))
            {
                for(SPWORD *pWord = pWordSet->WordList.pFirstWord; pWord != NULL; pWord = pWord->pNextWord)
                {
                    pLexiconWords->m_ulWords++;
                }
            }
        }
        else
        {
            pLexiconWords->Release();
        }
    }


    return hr;
}

/*****************************************************************************
* CSpLexicon::GetPronunciations *
*--------------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpLexicon::GetPronunciations(BSTR bstrWord,
                          SpeechLanguageId LangId,
                          SpeechLexiconType TypeFlags,
                          ISpeechLexiconPronunciations** ppPronunciations )
{
    SPDBG_FUNC( "CSpLexicon::GetPronunciations" );
    HRESULT hr;

    CComObject<CSpeechLexiconProns> *pLexiconProns;
    hr = CComObject<CSpeechLexiconProns>::CreateInstance( &pLexiconProns );
    if( SUCCEEDED( hr ) )
    {
        pLexiconProns->AddRef();
        SPWORDPRONUNCIATIONLIST PronList = {0, 0, 0};
        hr = GetPronunciations((const WCHAR *)bstrWord, (LANGID)LangId, (DWORD)TypeFlags, &PronList);

        if(SUCCEEDED(hr))
        {
            pLexiconProns->m_PronList = PronList;

            // Count prons
            for(SPWORDPRONUNCIATION *pPron = PronList.pFirstWordPronunciation; pPron != NULL; pPron = pPron->pNextWordPronunciation)
            {
                pLexiconProns->m_ulProns++;
            }
            // Note if we get SP_WORD_EXISTS_WITHOUT_PRONUNCIATION then we will
            // return a collection with one entry and empty pron string
            *ppPronunciations = pLexiconProns;
        }
        else if(hr == SPERR_NOT_IN_LEX)
        {
            // Do we need to release existing inteface pointer??
            *ppPronunciations = NULL;
            pLexiconProns->Release();
            hr = S_FALSE;
        }
    }

    return hr;
}


/*****************************************************************************
* CSpLexicon::GetGenerationChange *
*--------------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpLexicon::GetGenerationChange(long* GenerationID,
                                             ISpeechLexiconWords** ppWords)
{
    SPDBG_FUNC( "CSpLexicon::GetGenerationChange" );
    HRESULT hr;

    CComObject<CSpeechLexiconWords> *pLexiconWords;
    hr = CComObject<CSpeechLexiconWords>::CreateInstance( &pLexiconWords );
    if( SUCCEEDED( hr ) )
    {
        pLexiconWords->AddRef();
        SPWORDSETENTRY *pWordSet;
        hr = pLexiconWords->m_WordSet.CreateNode(&pWordSet);

        if(SUCCEEDED(hr))
        {
            hr = GetGenerationChange((DWORD)0, (DWORD*)GenerationID, &pWordSet->WordList);
        }

        if(SUCCEEDED(hr))
        {
            // if SP_LEX_NOTHING_TO_SYNC then produce a collection with no words

            pLexiconWords->m_WordSet.InsertHead(pWordSet);

            // Count words
            for(SPWORD *pWord = pWordSet->WordList.pFirstWord; pWord != NULL; pWord = pWord->pNextWord)
            {
                pLexiconWords->m_ulWords++;
            }

            *ppWords = pLexiconWords;
        }
        else
        {
            pLexiconWords->Release();
        }
    }

    // if SPERR_LEX_VERY_OUT_OF_SYNC we return and calling app must trap error code

    return hr;
}




/*****************************************************************************
* CSpUnCompressedLexicon::get_GenerationId *
*--------------------------------------*
*       
**************************************************************** davewood ***/
STDMETHODIMP CSpUnCompressedLexicon::get_GenerationId( long* GenerationId )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::get_GenerationId");
    HRESULT hr;
    DWORD dwGenerationId;

    hr = GetGeneration(&dwGenerationId);
    if(SUCCEEDED(hr))
    {
        *GenerationId = dwGenerationId;
    }
    return hr;
}


/*****************************************************************************
* CSpUnCompressedLexicon::AddPronunciation *
*--------------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpUnCompressedLexicon::AddPronunciation(BSTR bstrWord,
                         SpeechLanguageId LangId,
                         SpeechPartOfSpeech PartOfSpeech,
                         BSTR bstrPronunciation)
{
    SPDBG_FUNC("CSpUnCompressedLexicon::AddPronunciation");
    HRESULT hr;

    // Note that bad pointer for bstrWord is caught by AddPronunciation call below.
    if ( SP_IS_BAD_OPTIONAL_STRING_PTR( bstrPronunciation ) )
    {
        return E_INVALIDARG;
    }

    bstrPronunciation = EmptyStringToNull(bstrPronunciation);

    if( bstrPronunciation )
    {
        CComPtr<ISpPhoneConverter> cpPhoneConv;
        hr = SpCreatePhoneConverter((LANGID)LangId, NULL, NULL, &cpPhoneConv);

        if(SUCCEEDED(hr))
        {
            WCHAR sz[SP_MAX_PRON_LENGTH + 1];
            hr = cpPhoneConv->PhoneToId(bstrPronunciation, sz);
            
            if(SUCCEEDED(hr))
            {
                hr = AddPronunciation(bstrWord, (LANGID)LangId, (SPPARTOFSPEECH)PartOfSpeech, sz);
            }
        }
    }
    else
    {
        hr = AddPronunciation(bstrWord, (LANGID)LangId, (SPPARTOFSPEECH)PartOfSpeech, bstrPronunciation);
    }

    return hr;
}

/*****************************************************************************
* CSpUnCompressedLexicon::AddPronunciationByPhoneIds *
*--------------------------------------*
*       
****************************************************************** Leonro ***/
STDMETHODIMP CSpUnCompressedLexicon::AddPronunciationByPhoneIds(BSTR bstrWord,
                         SpeechLanguageId LangId,
                         SpeechPartOfSpeech PartOfSpeech,
                         VARIANT* PhoneIds)
{
    SPDBG_FUNC("CSpUnCompressedLexicon::AddPronunciationByPhoneIds");
    HRESULT             hr = S_OK;
    SPPHONEID*          pIds = NULL;

    if ( PhoneIds && SP_IS_BAD_VARIANT_PTR(PhoneIds) )
    {
        return E_INVALIDARG;
    }

    if(PhoneIds)
    {
        hr = VariantToPhoneIds(PhoneIds, &pIds);
    }

    if( SUCCEEDED( hr ) )
    {
        hr = AddPronunciation( bstrWord, (LANGID)LangId, (SPPARTOFSPEECH)PartOfSpeech, pIds );
        delete pIds;
    }

    return hr;
}

/*****************************************************************************
* CSpUnCompressedLexicon::RemovePronunciation *
*--------------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpUnCompressedLexicon::RemovePronunciation(BSTR bstrWord,
                            SpeechLanguageId LangId,
                            SpeechPartOfSpeech PartOfSpeech,
                            BSTR bstrPronunciation)
{
    SPDBG_FUNC("CSpUnCompressedLexicon::RemovePronunciation");
    HRESULT hr;

    // Note that bad pointer for bstrWord is caught by RemovePronunciation call below.
    if ( SP_IS_BAD_OPTIONAL_STRING_PTR( bstrPronunciation ) )
    {
        return E_INVALIDARG;
    }

    bstrPronunciation = EmptyStringToNull(bstrPronunciation);

    if( bstrPronunciation )
    {
        CComPtr<ISpPhoneConverter> cpPhoneConv;
        hr = SpCreatePhoneConverter((LANGID)LangId, NULL, NULL, &cpPhoneConv);

        if(SUCCEEDED(hr))
        {
            WCHAR sz[SP_MAX_PRON_LENGTH + 1];
            hr = cpPhoneConv->PhoneToId(bstrPronunciation, sz);
            
            if(SUCCEEDED(hr))
            {
                hr = RemovePronunciation(bstrWord, (LANGID)LangId, (SPPARTOFSPEECH)PartOfSpeech, sz);
            }
        }
    }
    else
    {
        hr = RemovePronunciation(bstrWord, (LANGID)LangId, (SPPARTOFSPEECH)PartOfSpeech, bstrPronunciation);
    }

    return hr;
}

/*****************************************************************************
* CSpUnCompressedLexicon::RemovePronunciationByPhoneIds *
*--------------------------------------*
*       
****************************************************************** Leonro ***/
STDMETHODIMP CSpUnCompressedLexicon::RemovePronunciationByPhoneIds(BSTR bstrWord,
                            SpeechLanguageId LangId,
                            SpeechPartOfSpeech PartOfSpeech,
                            VARIANT* PhoneIds)
{
    SPDBG_FUNC("CSpUnCompressedLexicon::RemovePronunciationByPhoneIds");
    HRESULT             hr = S_OK;
    SPPHONEID*          pIds = NULL;

    if ( PhoneIds && SP_IS_BAD_VARIANT_PTR(PhoneIds) )
    {
        return E_INVALIDARG;
    }

    if(PhoneIds)
    {
        hr = VariantToPhoneIds(PhoneIds, &pIds);
    }

    if( SUCCEEDED( hr ) )
    {
        hr = RemovePronunciation( bstrWord, (LANGID)LangId, (SPPARTOFSPEECH)PartOfSpeech, pIds );
        delete pIds;
    }

    return hr;
}

/*****************************************************************************
* CSpUnCompressedLexicon::GetWords *
*--------------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpUnCompressedLexicon::GetWords(SpeechLexiconType TypeFlags,
                 long* GenerationID,
                 ISpeechLexiconWords** ppWords )
{

    SPDBG_FUNC("CSpUnCompressedLexicon::GetWords");
    HRESULT hr;

    CComObject<CSpeechLexiconWords> *pLexiconWords;
    hr = CComObject<CSpeechLexiconWords>::CreateInstance( &pLexiconWords );
    if( SUCCEEDED( hr ) )
    {
        pLexiconWords->AddRef();

        // Removed cookie from interface;
        DWORD Cookie = 0;
        DWORD Generation = 0;
        if(GenerationID == NULL)
        {
            GenerationID = (long*)&Generation;
        }

        SPWORDSETENTRY *pWordSet;
        do
        {
            hr = pLexiconWords->m_WordSet.CreateNode(&pWordSet);

            if(SUCCEEDED(hr))
            {
                hr = GetWords((DWORD)TypeFlags, (DWORD*)GenerationID, &Cookie, &pWordSet->WordList);
            }

            if(SUCCEEDED(hr))
            {
                pLexiconWords->m_WordSet.InsertHead(pWordSet);
            }
        }
        while(hr == S_FALSE);


        if( SUCCEEDED( hr ) )
        {
            *ppWords = pLexiconWords;

            // Count words
            for(pWordSet = pLexiconWords->m_WordSet.GetHead(); pWordSet != NULL; pWordSet = pLexiconWords->m_WordSet.GetNext(pWordSet))
            {
                for(SPWORD *pWord = pWordSet->WordList.pFirstWord; pWord != NULL; pWord = pWord->pNextWord)
                {
                    pLexiconWords->m_ulWords++;
                }
            }
        }
        else
        {
            pLexiconWords->Release();
        }
    }


    return hr;
}

/*****************************************************************************
* CSpUnCompressedLexicon::GetPronunciations *
*--------------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpUnCompressedLexicon::GetPronunciations(BSTR bstrWord,
                          SpeechLanguageId LangId,
                          SpeechLexiconType TypeFlags,
                          ISpeechLexiconPronunciations** ppPronunciations )
{
    SPDBG_FUNC( "CSpUnCompressedLexicon::GetPronunciations" );
    HRESULT hr;

    CComObject<CSpeechLexiconProns> *pLexiconProns;
    hr = CComObject<CSpeechLexiconProns>::CreateInstance( &pLexiconProns );
    if( SUCCEEDED( hr ) )
    {
        pLexiconProns->AddRef();
        SPWORDPRONUNCIATIONLIST PronList = {0, 0, 0};
        hr = GetPronunciations((const WCHAR *)bstrWord, (LANGID)LangId, (DWORD)TypeFlags, &PronList);

        if(SUCCEEDED(hr))
        {
            pLexiconProns->m_PronList = PronList;

            // Count prons
            for(SPWORDPRONUNCIATION *pPron = PronList.pFirstWordPronunciation; pPron != NULL; pPron = pPron->pNextWordPronunciation)
            {
                pLexiconProns->m_ulProns++;
            }
            // Note if we get SP_WORD_EXISTS_WITHOUT_PRONUNCIATION then we will
            // return a collection with one entry and empty pron string
            *ppPronunciations = pLexiconProns;
        }
        else if(hr == SPERR_NOT_IN_LEX)
        {
            // Do we need to release existing inteface pointer??
            *ppPronunciations = NULL;
            pLexiconProns->Release();
            hr = S_FALSE;
        }
    }

    return hr;
}


/*****************************************************************************
* CSpUnCompressedLexicon::GetGenerationChange *
*--------------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpUnCompressedLexicon::GetGenerationChange(long* GenerationID,
                                                         ISpeechLexiconWords** ppWords)
{
    SPDBG_FUNC( "CSpUnCompressedLexicon::GetGenerationChange" );
    HRESULT hr;

    CComObject<CSpeechLexiconWords> *pLexiconWords;
    hr = CComObject<CSpeechLexiconWords>::CreateInstance( &pLexiconWords );
    if( SUCCEEDED( hr ) )
    {
        pLexiconWords->AddRef();
        SPWORDSETENTRY *pWordSet;
        hr = pLexiconWords->m_WordSet.CreateNode(&pWordSet);

        if(SUCCEEDED(hr))
        {
            hr = GetGenerationChange((DWORD)m_eLexType, (DWORD*)GenerationID, &pWordSet->WordList);
        }

        if(SUCCEEDED(hr))
        {
            // if SP_LEX_NOTHING_TO_SYNC then produce a collection with no words

            pLexiconWords->m_WordSet.InsertHead(pWordSet);

            // Count words
            for(SPWORD *pWord = pWordSet->WordList.pFirstWord; pWord != NULL; pWord = pWord->pNextWord)
            {
                pLexiconWords->m_ulWords++;
            }

            *ppWords = pLexiconWords;
        }
        else
        {
            pLexiconWords->Release();
        }
    }

    // if SPERR_LEX_VERY_OUT_OF_SYNC we return and calling app must trap error code

    return hr;
}


/*****************************************************************************
* CSpeechLexiconWords::Item *
*---------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechLexiconWords::Item( long Index, ISpeechLexiconWord** ppWord )
{
    SPDBG_FUNC( "CSpeechLexiconWords::Item" );
    HRESULT hr = S_OK;

    if(Index < 0 || (ULONG)Index >= m_ulWords)
    {
        hr = E_INVALIDARG;
    }

    //--- Create the CSpeechLexiconWord object
    CComObject<CSpeechLexiconWord> *pWord;

    if ( SUCCEEDED( hr ) )
    {
        hr = CComObject<CSpeechLexiconWord>::CreateInstance( &pWord );
    }

    if ( SUCCEEDED( hr ) )
    {
        pWord->AddRef();

        // Find pWord. This is an inefficient linear look-up ??
        ULONG ul = 0;
        SPWORDSETENTRY *pWordSet = m_WordSet.GetHead();
        SPWORD *pWordEntry = pWordSet->WordList.pFirstWord;
        for(; pWordSet != NULL && ul < (ULONG)Index; pWordSet = m_WordSet.GetNext(pWordSet))
        {
            for(pWordEntry = pWordSet->WordList.pFirstWord; pWordEntry != NULL && ul < (ULONG)Index; pWordEntry = pWordEntry->pNextWord)
            {
                ul++;
            }
        }

        // Set pWord structure
        if(pWordEntry)
        {
            pWord->m_pWord = pWordEntry;
            pWord->m_cpWords = this; // AddRef words as it holds memory
            *ppWord = pWord;
        }
        else
        {
            SPDBG_ASSERT(pWordEntry);
            pWord->Release();
            hr = E_UNEXPECTED;
        }
    }

    return hr;
} /* CSpeechLexiconWords::Item */

/*****************************************************************************
* CSpeechLexiconWords::get_Count *
*--------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechLexiconWords::get_Count( long* pVal )
{
    SPDBG_FUNC( "CSpeechLexiconWords::get_Count" );
    *pVal = m_ulWords;
    return S_OK;
} /* CSpeechLexiconWords::get_Count */

/*****************************************************************************
* CSpeechLexiconWords::get__NewEnum *
*-----------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechLexiconWords::get__NewEnum( IUnknown** ppEnumVARIANT )
{
    SPDBG_FUNC( "CSpeechLexiconWords::get__NewEnum" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppEnumVARIANT ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComObject<CEnumWords>* pEnum;
        if( SUCCEEDED( hr = CComObject<CEnumWords>::CreateInstance( &pEnum ) ) )
        {
            pEnum->AddRef();
            pEnum->m_cpWords = this;
            *ppEnumVARIANT = pEnum;
        }
    }
    return hr;
} /* CSpeechLexiconWords::get__NewEnum */




//
//=== CEnumWords::IEnumVARIANT interface =================================================
//

/*****************************************************************************
* CEnumWords::Clone *
*-------------------------*
*******************************************************************  PhilSch ***/
STDMETHODIMP CEnumWords::Clone( IEnumVARIANT** ppEnum )
{
    SPDBG_FUNC( "CEnumWords::Clone" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppEnum ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
        CComObject<CEnumWords>* pEnum;

        hr = CComObject<CEnumWords>::CreateInstance( &pEnum );
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_CurrIndex = m_CurrIndex;
            pEnum->m_cpWords = m_cpWords;
            *ppEnum = pEnum;
        }
    }
    return hr;
}  /* CEnumWords::Clone */

/*****************************************************************************
* CEnumWords::Next *
*-------------------*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumWords::Next( ULONG celt, VARIANT* rgelt, ULONG* pceltFetched )
{
    SPDBG_FUNC( "CEnumWords::Next" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    ULONG   i = 0;

    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pceltFetched ) || SP_IS_BAD_WRITE_PTR( rgelt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Get the number of total Elements in the collection
        hr = m_cpWords->get_Count( &NumElements );

        // Retrieve the next celt elements
        for( i=0; 
            SUCCEEDED( hr ) && m_CurrIndex<(ULONG)NumElements && i<celt; 
            m_CurrIndex++, i++ )
        {
            CComPtr<ISpeechLexiconWord> cpWord;

            hr = m_cpWords->Item( m_CurrIndex, &cpWord );
            
            if( SUCCEEDED( hr ) )
            {
                rgelt[i].vt = VT_DISPATCH;
                hr = cpWord->QueryInterface( IID_IDispatch, (void**)&rgelt[i].pdispVal );
            }
        }

        if( pceltFetched )
        {
            *pceltFetched = i;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = ( i < celt ) ? S_FALSE : hr;        
    }
    else
    {
        for( i=0; i < celt; i++ )
        {
            VariantClear( &rgelt[i] );
        }
    }

    return hr;

}  /* CEnumWords::Next */


/*****************************************************************************
* CEnumWords::Skip *
*--------------------*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumWords::Skip( ULONG celt )
{
    SPDBG_FUNC( "CEnumWords::Skip" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    
    m_CurrIndex += celt; 

    hr = m_cpWords->get_Count( &NumElements );

    if( SUCCEEDED( hr ) && m_CurrIndex > (ULONG)NumElements )
    {
        m_CurrIndex = (ULONG)NumElements;
        hr = S_FALSE;
    }
   
    return hr;
}  /* CEnumWords::Skip */



/*****************************************************************************
* CSpeechLexiconWord::get_LangId *
*-----------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpeechLexiconWord::get_LangId(SpeechLanguageId* LangId)
{
    SPDBG_FUNC( "CSpeechLexiconWord::get_LangId" );
    *LangId = m_pWord->LangID;
    return S_OK;
}

/*****************************************************************************
* CSpeechLexiconWord::get_Type *
*-----------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpeechLexiconWord::get_Type(SpeechWordType* WordType)
{
    SPDBG_FUNC( "CSpeechLexiconWord::get_Type" );
    *WordType = (SpeechWordType)m_pWord->eWordType;
    return S_OK;
}

/*****************************************************************************
* CSpeechLexiconWord::get_Word *
*-----------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpeechLexiconWord::get_Word(BSTR* bstrWord)
{
    SPDBG_FUNC( "CSpeechLexiconWord::get_Word" );
    HRESULT hr = S_OK;

    *bstrWord = ::SysAllocString(m_pWord->pszWord);
    if (*bstrWord == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

/*****************************************************************************
* CSpeechLexiconWord::get_Pronunciations *
*-----------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpeechLexiconWord::get_Pronunciations(ISpeechLexiconPronunciations** ppPronunciations)
{
    SPDBG_FUNC( "CSpeechLexiconWord::get_Pronunciations" );
    HRESULT hr;

    CComObject<CSpeechLexiconProns> *pLexiconProns;
    hr = CComObject<CSpeechLexiconProns>::CreateInstance( &pLexiconProns );
    if( SUCCEEDED( hr ) )
    {
        pLexiconProns->m_PronList.pFirstWordPronunciation = m_pWord->pFirstWordPronunciation;
        pLexiconProns->AddRef();
        pLexiconProns->m_cpWord = this;

        // Count prons
        for(SPWORDPRONUNCIATION *pPron = pLexiconProns->m_PronList.pFirstWordPronunciation; pPron != NULL; pPron = pPron->pNextWordPronunciation)
        {
            pLexiconProns->m_ulProns++;
        }

        *ppPronunciations = pLexiconProns;
    }

    return hr;
}




/*****************************************************************************
* CSpeechLexiconProns::Item *
*---------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechLexiconProns::Item( long Index, ISpeechLexiconPronunciation** ppPron )
{
    SPDBG_FUNC( "CSpeechLexiconProns::Item" );
    HRESULT hr = S_OK;

    if(Index < 0 || (ULONG)Index >= m_ulProns)
    {
        hr = E_INVALIDARG;
    }

    //--- Create the CSpeechLexiconPron object
    CComObject<CSpeechLexiconPron> *pPron;

    if ( SUCCEEDED( hr ) )
    {
        hr = CComObject<CSpeechLexiconPron>::CreateInstance( &pPron );
    }

    if ( SUCCEEDED( hr ) )
    {
        pPron->AddRef();

        // Find pPron. This is an inefficient linear look-up ??
        SPWORDPRONUNCIATION *pPronEntry = m_PronList.pFirstWordPronunciation;
        for(ULONG ul = 0; pPronEntry != NULL && ul < (ULONG)Index; pPronEntry = pPronEntry->pNextWordPronunciation)
        {
            ul++;
        }

        // Set pPron structure
        if(pPronEntry)
        {
            pPron->m_pPron = pPronEntry;
            pPron->m_cpProns = this; // AddRef words as it holds memory
            *ppPron = pPron;
        }
        else
        {
            SPDBG_ASSERT(pPronEntry);
            pPron->Release();
            hr = E_UNEXPECTED;
        }


    }

    return hr;
} /* CSpeechLexiconProns::Item */

/*****************************************************************************
* CSpeechLexiconProns::get_Count *
*--------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechLexiconProns::get_Count( long* pVal )
{
    SPDBG_FUNC( "CSpeechLexiconProns::get_Count" );
    *pVal = m_ulProns;
    return S_OK;
} /* CSpeechLexiconProns::get_Count */

/*****************************************************************************
* CSpeechLexiconProns::get__NewEnum *
*-----------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechLexiconProns::get__NewEnum( IUnknown** ppEnumVARIANT )
{
    SPDBG_FUNC( "CSpeechLexiconProns::get__NewEnum" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppEnumVARIANT ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComObject<CEnumProns>* pEnum;
        if( SUCCEEDED( hr = CComObject<CEnumProns>::CreateInstance( &pEnum ) ) )
        {
            pEnum->AddRef();
            pEnum->m_cpProns = this;
            *ppEnumVARIANT = pEnum;
        }
    }
    return hr;
} /* CSpeechLexiconProns::get__NewEnum */




//
//=== CEnumProns::IEnumVARIANT interface =================================================
//

/*****************************************************************************
* CEnumProns::Clone *
*-------------------------*
*******************************************************************  PhilSch ***/
STDMETHODIMP CEnumProns::Clone( IEnumVARIANT** ppEnum )
{
    SPDBG_FUNC( "CEnumProns::Clone" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppEnum ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
        CComObject<CEnumProns>* pEnum;

        hr = CComObject<CEnumProns>::CreateInstance( &pEnum );
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_CurrIndex = m_CurrIndex;
            pEnum->m_cpProns = m_cpProns;
            *ppEnum = pEnum;
        }
    }
    return hr;
}  /* CEnumProns::Clone */

/*****************************************************************************
* CEnumProns::Next *
*-------------------*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumProns::Next( ULONG celt, VARIANT* rgelt, ULONG* pceltFetched )
{
    SPDBG_FUNC( "CEnumProns::Next" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    ULONG   i = 0;

    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pceltFetched ) || SP_IS_BAD_WRITE_PTR( rgelt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Get the number of total Elements in the collection
        hr = m_cpProns->get_Count( &NumElements );

        // Retrieve the next celt elements
        for( i=0; 
            SUCCEEDED( hr ) && m_CurrIndex<(ULONG)NumElements && i<celt; 
            m_CurrIndex++, i++ )
        {
            CComPtr<ISpeechLexiconPronunciation> cpPron;

            hr = m_cpProns->Item( m_CurrIndex, &cpPron );
            
            if( SUCCEEDED( hr ) )
            {
                rgelt[i].vt = VT_DISPATCH;
                hr = cpPron->QueryInterface( IID_IDispatch, (void**)&rgelt[i].pdispVal );
            }
        }

        if( pceltFetched )
        {
            *pceltFetched = i;
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = ( i < celt ) ? S_FALSE : hr;        
    }
    else
    {
        for( i=0; i < celt; i++ )
        {
            VariantClear( &rgelt[i] );
        }
    }

    return hr;

}  /* CEnumProns::Next */


/*****************************************************************************
* CEnumProns::Skip *
*--------------------*
********************************************************************* Leonro ***/
STDMETHODIMP CEnumProns::Skip( ULONG celt )
{
    SPDBG_FUNC( "CEnumProns::Skip" );
    HRESULT hr = S_OK;
    long    NumElements = 0;
    
    m_CurrIndex += celt; 

    hr = m_cpProns->get_Count( &NumElements );

    if( SUCCEEDED( hr ) && m_CurrIndex > (ULONG)NumElements )
    {
        m_CurrIndex = (ULONG)NumElements;
        hr = S_FALSE;
    }
   
    return hr;
}  /* CEnumProns::Skip */



/*****************************************************************************
* CSpeechLexiconPron::get_Type *
*-----------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpeechLexiconPron::get_Type(SpeechLexiconType* pLexiconType)
{
    SPDBG_FUNC( "CSpeechLexiconPron::get_Type" );
    *pLexiconType = (SpeechLexiconType)m_pPron->eLexiconType;
    return S_OK;
}

/*****************************************************************************
* CSpeechLexiconPron::get_LangId *
*-----------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpeechLexiconPron::get_LangId(SpeechLanguageId* LangId)
{
    SPDBG_FUNC( "CSpeechLexiconPron::get_LangId" );
    *LangId = m_pPron->LangID;
    return S_OK;
}

/*****************************************************************************
* CSpeechLexiconPron::get_PartOfSpeech *
*-----------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpeechLexiconPron::get_PartOfSpeech(SpeechPartOfSpeech* pPartOfSpeech)
{
    SPDBG_FUNC( "CSpeechLexiconPron::get_PartOfSpeech" );
    *pPartOfSpeech = (SpeechPartOfSpeech)m_pPron->ePartOfSpeech;
    return S_OK;
}

/*****************************************************************************
* CSpeechLexiconPron::get_PhoneIds *
*-----------------------------------*
*       
****************************************************************** leonro ***/
STDMETHODIMP CSpeechLexiconPron::get_PhoneIds(VARIANT* PhoneIds)
{
    SPDBG_FUNC( "CSpeechLexiconPron::get_PhoneIds" );
    HRESULT hr = S_OK;
    int     numPhonemes = 0;

    if( SP_IS_BAD_WRITE_PTR( PhoneIds ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if( m_pPron->szPronunciation )
        {
            BYTE *pArray;
            numPhonemes = wcslen( m_pPron->szPronunciation );
            SAFEARRAY* psa = SafeArrayCreateVector( VT_I2, 0, numPhonemes );
            if( psa )
            {
                if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
                {
                    memcpy(pArray, m_pPron->szPronunciation, numPhonemes*sizeof(SPPHONEID) );
                    SafeArrayUnaccessData( psa );
                    VariantClear(PhoneIds);
                    PhoneIds->vt     = VT_ARRAY | VT_I2;
                    PhoneIds->parray = psa;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

/*****************************************************************************
* CSpeechLexiconPron::get_Symbolic *
*-----------------------------------*
*       
****************************************************************** davewood ***/
STDMETHODIMP CSpeechLexiconPron::get_Symbolic(BSTR* bstrSymbolic)
{
    SPDBG_FUNC( "CSpeechLexiconPron::get_Symbolic" );
    HRESULT hr;

    CComPtr<ISpPhoneConverter> cpPhoneConv;
    hr = SpCreatePhoneConverter(m_pPron->LangID, NULL, NULL, &cpPhoneConv);

    *bstrSymbolic = NULL; // Default

    if(SUCCEEDED(hr) && m_pPron->szPronunciation && m_pPron->szPronunciation[0] != L'\0')
    {
        CSpDynamicString dstr(wcslen(m_pPron->szPronunciation) * (g_dwMaxLenPhone + 1) + 1);
        hr = cpPhoneConv->IdToPhone(m_pPron->szPronunciation, dstr);

        if(SUCCEEDED(hr))
        {
            hr = dstr.CopyToBSTR(bstrSymbolic);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_memorystream.cpp ===
// MemoryStream.cpp : Implementation of CMemoryStream
#include "stdafx.h"

#ifndef __sapi_h__
#include <sapi.h>
#endif

#include "a_MemoryStream.h"
#include "wavstream.h"
#include "a_helpers.h"

/****************************************************************************
* CMemoryStream::FinalConstruct *
*----------------------------*
*   Description:
*
*   Returns:
*       Success code if object should be created
*
********************************************************************* RAL ***/

HRESULT CMemoryStream::FinalConstruct()
{
    SPDBG_FUNC("CMemoryStream::FinalConstruct");
    HRESULT hr = S_OK;

    hr = ::CoCreateInstance( CLSID_SpStream, GetUnknown(), CLSCTX_INPROC_SERVER, IID_IUnknown, (void**)&m_cpAgg);

    if(SUCCEEDED(hr))
    {
        hr = m_cpAgg->QueryInterface(&m_cpStream);
    }

    if(SUCCEEDED(hr))
    {
        // We QI'd for an inner interface so we should release
        GetUnknown()->Release(); 
    }

    if(SUCCEEDED(hr))
    {
        hr = m_cpAgg->QueryInterface(&m_cpAccess);
    }

    if(SUCCEEDED(hr))
    {
        // We QI'd for an inner interface so we should release
        GetUnknown()->Release(); 
    }

    CComPtr<IStream> cpStream;
    if(SUCCEEDED(hr))
    {
        hr = ::CreateStreamOnHGlobal( NULL, true, &cpStream );
    }        

    if(SUCCEEDED(hr))
    {
        GUID guid; WAVEFORMATEX *pWaveFormat;
        hr = SpConvertStreamFormatEnum(g_DefaultWaveFormat, &guid, &pWaveFormat);

        if(SUCCEEDED(hr))
        {
            hr = m_cpStream->SetBaseStream(cpStream, guid, pWaveFormat);
            ::CoTaskMemFree(pWaveFormat);
        }
    }

    return hr;
}

/****************************************************************************
* CMemoryStream::FinalRelease *
*--------------------------*
*   Description:
*
*   Returns:
*       void
*
********************************************************************* RAL ***/

void CMemoryStream::FinalRelease()
{
    SPDBG_FUNC("CMemoryStream::FinalRelease");

    GetUnknown()->AddRef(); 
    m_cpStream.Release();

    GetUnknown()->AddRef(); 
    m_cpAccess.Release();

    m_cpAgg.Release();
}


//
//=== ISpeechBaseStream interface =================================================
//

/*****************************************************************************
* CMemoryStream::get_Format *
*------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CMemoryStream::get_Format( ISpeechAudioFormat** ppStreamFormat )
{
    SPDBG_FUNC( "CMemoryStream::get_Format" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppStreamFormat ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Create new object.
        CComObject<CSpeechWavAudioFormat> *pFormat;
        hr = CComObject<CSpeechWavAudioFormat>::CreateInstance( &pFormat );
        if ( SUCCEEDED( hr ) )
        {
            pFormat->AddRef();
            pFormat->m_cpStreamAccess = m_cpAccess;
            *ppStreamFormat = pFormat;
        }
    }

    return hr;
} /* CMemoryStream::get_Format */

/*****************************************************************************
* CMemoryStream::Read *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CMemoryStream::Read( VARIANT* pvtBuffer, long NumBytes, long* pRead )
{
    SPDBG_FUNC( "CMemoryStream::Read" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pvtBuffer ) || SP_IS_BAD_WRITE_PTR( pRead ) )
    {
        hr = E_POINTER;
    }
    else
    {
        VariantClear(pvtBuffer);

        BYTE *pArray;
        SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, NumBytes );
        if( psa )
        {
            if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
            {
                hr = m_cpStream->Read(pArray, NumBytes, (ULONG*)pRead);
                SafeArrayUnaccessData( psa );
                pvtBuffer->vt     = VT_ARRAY | VT_UI1;
                pvtBuffer->parray = psa;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
} /* CMemoryStream::Read */

/*****************************************************************************
* CMemoryStream::Write *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CMemoryStream::Write( VARIANT Buffer, long* pWritten )
{
    SPDBG_FUNC( "CMemoryStream::Write" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pWritten ) )
    {
        hr = E_POINTER;
    }
    else
    {
        BYTE * pData = NULL;
        ULONG ulDataSize = 0;

        hr = AccessVariantData( &Buffer, &pData, &ulDataSize );

        if( SUCCEEDED( hr ) )
        {
            hr = m_cpStream->Write(pData, ulDataSize, (ULONG*)pWritten);
            UnaccessVariantData( &Buffer, pData );
        }
    }

    return hr;
} /* CMemoryStream::Write */

/*****************************************************************************
* CMemoryStream::Seek *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CMemoryStream::Seek( VARIANT Pos, SpeechStreamSeekPositionType Origin, VARIANT *pNewPosition )
{
    SPDBG_FUNC( "CMemoryStream::Seek" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pNewPosition ) )
    {
        hr = E_POINTER;
    }
    else
    {
        ULARGE_INTEGER uliNewPos;
        LARGE_INTEGER liPos;

        hr = VariantToLongLong( &Pos, &(liPos.QuadPart) );
        if (SUCCEEDED(hr))
        {
            hr = m_cpStream->Seek(liPos, (DWORD)Origin, &uliNewPos);

            if (SUCCEEDED( hr ))
            {
                hr = ULongLongToVariant( uliNewPos.QuadPart, pNewPosition );
            }
        }
    }

    return hr;
} /* CMemoryStream::Seek */


/*****************************************************************************
* CMemoryStream::putref_Format *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CMemoryStream::putref_Format(ISpeechAudioFormat *pFormat)
{
    SPDBG_FUNC( "CMemoryStream::putref_Format" );
    HRESULT hr;

    GUID Guid; WAVEFORMATEX *pWaveFormatEx;
    BSTR bstrGuid;
    hr = pFormat->get_Guid(&bstrGuid);

    if(SUCCEEDED(hr))
    {
        hr = IIDFromString(bstrGuid, &Guid);
    }

    CComPtr<ISpeechWaveFormatEx> cpWaveEx;
    if(SUCCEEDED(hr))
    {
        hr = pFormat->GetWaveFormatEx(&cpWaveEx);
    }

    if(SUCCEEDED(hr))
    {
        hr = WaveFormatExFromInterface(cpWaveEx, &pWaveFormatEx);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_cpAccess->SetFormat(Guid, pWaveFormatEx);
        ::CoTaskMemFree(pWaveFormatEx);
    }
    
    return hr;
}


/*****************************************************************************
* CMemoryStream::SetData *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CMemoryStream::SetData(VARIANT Data)
{
    SPDBG_FUNC( "CMemoryStream::SetData" );
    HRESULT hr;

    BYTE * pData = NULL;
    ULONG ulDataSize = 0;

    hr = AccessVariantData( &Data, &pData, &ulDataSize );

    LARGE_INTEGER li; li.QuadPart = 0;
    if( SUCCEEDED( hr ) )
    {
        hr = m_cpStream->Seek( li, STREAM_SEEK_SET, NULL );
    }

    if( SUCCEEDED( hr ) )
    {
        hr = m_cpStream->Write(pData, ulDataSize, NULL);
        UnaccessVariantData( &Data, pData );

        if( SUCCEEDED( hr ) )
        {
            hr = m_cpStream->Seek( li, STREAM_SEEK_SET, NULL );
        }        
    }

    return hr;
}

/*****************************************************************************
* CMemoryStream::GetData *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CMemoryStream::GetData(VARIANT *pData)
{
    SPDBG_FUNC( "CMemoryStream::GetData" );

    HRESULT hr;
    STATSTG Stat;
    LARGE_INTEGER li; 
    ULARGE_INTEGER uliInitialSeekPosition;

    // Find the current seek position
    li.QuadPart = 0;
    hr = m_cpStream->Seek( li, STREAM_SEEK_CUR, &uliInitialSeekPosition );

    // Seek to beginning of stream
    if(SUCCEEDED(hr))
    {
        li.QuadPart = 0;
        hr = m_cpStream->Seek( li, STREAM_SEEK_SET, NULL );
    }

    // Get the Stream size
    if( SUCCEEDED( hr ) )
    {
        hr = m_cpStream->Stat( &Stat, STATFLAG_NONAME );
    }

    // Create a SafeArray to read the stream into and assign it to the VARIANT SaveStream
    if( SUCCEEDED( hr ) )
    {
        BYTE *pArray;
        SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, Stat.cbSize.LowPart );
        if( psa )
        {
            if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
            {
                hr = m_cpStream->Read( pArray, Stat.cbSize.LowPart, NULL );
                SafeArrayUnaccessData( psa );
                VariantClear( pData );
                pData->vt     = VT_ARRAY | VT_UI1;
                pData->parray = psa;

                // Free our memory if we failed.
                if( FAILED( hr ) )
                {
                    VariantClear( pData );    
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Move back to the original seek position
    if(SUCCEEDED(hr))
    {
        li.QuadPart = (LONGLONG)uliInitialSeekPosition.QuadPart;
        hr = m_cpStream->Seek( li, STREAM_SEEK_SET, NULL );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_helpers.cpp ===
/*******************************************************************************
* a_helpers.cpp *
*-------------*
*   Description:
*       This module contains various helper routines and classes used for 
*	automation.
*-------------------------------------------------------------------------------
*  Created By: TODDT                                        Date: 01/11/01
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "a_helpers.h"

#ifdef SAPI_AUTOMATION


/*****************************************************************************
* LongLongToVariant *
*--------------------------*
*       
********************************************************************* TODDT ***/
HRESULT LongLongToVariant( LONGLONG ll, VARIANT* pVar )
{
    SPDBG_FUNC( "LongLongToVariant" );
    HRESULT hr = S_OK;
    
    bool fNeg = false;
    
    if ( ll < 0 )
    {
        fNeg = true;
        ll *= -1;
    }
    
    hr = VariantClear( pVar );
    if ( SUCCEEDED( hr ) )
    {
        DECIMAL dec = {0};
        dec.Lo64 = (ULONGLONG)ll;
        dec.sign = fNeg;
        pVar->decVal = dec;
        pVar->vt = VT_DECIMAL;
    }
    
    return hr;
}

/*****************************************************************************
* VariantToLongLong *
*--------------------------*
*       
********************************************************************* TODDT ***/
HRESULT VariantToLongLong( VARIANT* pVar, LONGLONG * pll )
{
    SPDBG_FUNC( "VariantToLongLong" );
    HRESULT hr = S_OK;
    CComVariant vResult;
    
    hr = VariantChangeType( &vResult, pVar, 0, VT_DECIMAL );
    if ( SUCCEEDED( hr ) )
    {
        // Round to int.
        hr = VarDecRound( &(vResult.decVal), 0, &(vResult.decVal) );
        
        if ( SUCCEEDED( hr ) )
        {
            // Make sure that the high 32 bits of the 96 bit decimal is not used as well as the
            // scale and make sure we don't overflow a signed value.
            if ( !vResult.decVal.Hi32 && !vResult.decVal.scale && ((LONGLONG)vResult.decVal.Lo64 >= 0) )
            {
                // Now correct for the sign.
                *pll = (LONGLONG)(vResult.decVal.Lo64) * (vResult.decVal.sign ? -1 : 1);
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
    }
    
    return hr;
}

/*****************************************************************************
* ULongLongToVariant *
*--------------------------*
*       
********************************************************************* TODDT ***/
HRESULT ULongLongToVariant( ULONGLONG ull, VARIANT* pVar )
{
    SPDBG_FUNC( "ULongLongToVariant" );
    HRESULT hr = S_OK;
    
    hr = VariantClear( pVar );
    if ( SUCCEEDED( hr ) )
    {
        DECIMAL dec = {0};
        dec.Lo64 = ull;
        pVar->decVal = dec;
        pVar->vt = VT_DECIMAL;
    }
    
    return hr;
}

/*****************************************************************************
* VariantToULongLong *
*--------------------------*
*       
********************************************************************* TODDT ***/
HRESULT VariantToULongLong( VARIANT* pVar, ULONGLONG * pull )
{
    SPDBG_FUNC( "VariantToULongLong" );
    HRESULT hr = S_OK;
    CComVariant vResult;
    
    hr = VariantChangeType( &vResult, pVar, 0, VT_DECIMAL );
    if ( SUCCEEDED( hr ) )
    {
        // Round to int.
        hr = VarDecRound( &(vResult.decVal), 0, &(vResult.decVal) );
        
        if ( SUCCEEDED( hr ) )
        {
            // Make sure that the high 32 bits of the 96 bit decimal is not used as well as the
            // scale and the sign is position.
            if ( !vResult.decVal.Hi32 && !vResult.decVal.scale && !vResult.decVal.sign )
            {
                *pull = vResult.decVal.Lo64;
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
    }
    
    return hr;
}


/*****************************************************************************
* AccessVariantData *
*-------------------*
*       
********************************************************************* TODDT ***/
HRESULT AccessVariantData( const VARIANT* pVar, BYTE ** ppData, ULONG * pSize, ULONG * pDataTypeSize, bool * pfIsString )
{
    SPDBG_FUNC( "AccessVariantData" );
    HRESULT hr = S_OK;
    BYTE * pData = NULL;
    bool  fByRef = false;
    ULONG ulDataSize = 0;
    ULONG ulTypeSize = 0;   // Also used to signal whether pData is SafeArray or not (is 0 if not safearray).
    ULONG ulTypeSizeReturn = 0;
    
    // Init ppData and pSize appropriately to start with.
    *ppData = NULL;
    if ( pSize )
    {
        *pSize = 0;
    }
    if ( pDataTypeSize )
    {
        *pDataTypeSize = 0;
    }
    if ( pfIsString )
    {
        *pfIsString = false;
    }
    
    // If we have a Variant by ref then just move to that.
    if ( pVar && (pVar->vt == (VT_BYREF | VT_VARIANT)) )
    {
        pVar = pVar->pvarVal;
    }

    if ( pVar )
    {
        switch( pVar->vt )
        {
            // array of byte or char
        case (VT_ARRAY | VT_BYREF | VT_UI1):
        case (VT_ARRAY | VT_BYREF | VT_I1):
            fByRef = true;
            // fall through...
        case (VT_ARRAY | VT_UI1):
        case (VT_ARRAY | VT_I1):
            ulTypeSizeReturn = ulTypeSize = 1;  // One byte data types
            break;
            
            // array of unsigned short or short
        case (VT_ARRAY | VT_BYREF | VT_UI2):
        case (VT_ARRAY | VT_BYREF | VT_I2): 
            fByRef = true;
            // fall through...
        case (VT_ARRAY | VT_UI2):
        case (VT_ARRAY | VT_I2): 
            ulTypeSizeReturn = ulTypeSize = 2; // Two byte data types
            break;
            
            // array of int or unsigned int or long or unsigned long
        case (VT_ARRAY | VT_BYREF | VT_INT):
        case (VT_ARRAY | VT_BYREF | VT_UINT):
        case (VT_ARRAY | VT_BYREF | VT_I4):
        case (VT_ARRAY | VT_BYREF | VT_UI4):
            fByRef = true;
            // fall through...
        case (VT_ARRAY | VT_INT):
        case (VT_ARRAY | VT_UINT):
        case (VT_ARRAY | VT_I4):
        case (VT_ARRAY | VT_UI4):
            ulTypeSizeReturn = ulTypeSize = 4;   // Four byte data types
            break;
            
        case (VT_BYREF | VT_UI1):
        case (VT_BYREF | VT_I1):
            fByRef = true;
            // fall through...
        case VT_UI1:
        case VT_I1:
            ulTypeSizeReturn = ulDataSize = 1;  // One byte data types
            pData = (BYTE*)( fByRef ? pVar->pcVal : &pVar->cVal );
            break;
            
            // unsigned short or short
        case (VT_BYREF | VT_UI2):
        case (VT_BYREF | VT_I2): 
            fByRef = true;
            // fall through...
        case VT_UI2:
        case VT_I2: 
            ulTypeSizeReturn = ulDataSize = 2; // Two byte data types
            pData = (BYTE*)( fByRef ? pVar->piVal : &pVar->iVal );
            break;
            
            // int or unsigned int or long or unsigned long
        case (VT_BYREF | VT_INT):
        case (VT_BYREF | VT_UINT):
        case (VT_BYREF | VT_I4):
        case (VT_BYREF | VT_UI4):
            fByRef = true;
            // fall through...
        case VT_INT:
        case VT_UINT:
        case VT_I4:
        case VT_UI4:
            ulTypeSizeReturn = ulDataSize = 4; // Four byte data types
            pData = (BYTE*)( fByRef ? pVar->plVal : &pVar->lVal );
            break;
            
            // bstr by ref or bstr
        case (VT_BYREF | VT_BSTR):
            fByRef = true;
            // fall through...
        case VT_BSTR:
            if ( pfIsString )
            {
                *pfIsString = true;
            }
            if( fByRef ? (pVar->pbstrVal!=NULL && *(pVar->pbstrVal)!=NULL) : pVar->bstrVal!=NULL )
            {
                ulDataSize = sizeof(WCHAR) * (wcslen( fByRef ? *(pVar->pbstrVal) : pVar->bstrVal ) + 1);
                
                // Due to not being able to default paramaters to NULL using defaultvalue we are making
                // 0 length stings (2 bytes for zero term only) the same as a NULL string.
                if ( ulDataSize > 2 )
                {
                    pData = (BYTE*)( fByRef ? *(pVar->pbstrVal) : pVar->bstrVal );
                }
                else
                {
                    ulDataSize = 0;
                }
                
                ulTypeSizeReturn = sizeof(WCHAR);
            }
            break;
            
        case (VT_ARRAY | VT_BYREF | VT_VARIANT): 
            fByRef = true;
            // fall through...
        case (VT_ARRAY | VT_VARIANT): 
            // Special handling for array of variants.
            // The individual variant elements must be simple numeric types and all the same size

            BYTE * pVarData;
            hr = SafeArrayAccessData( fByRef ? *pVar->pparray : pVar->parray,
                (void **)&pVarData );
            if( SUCCEEDED( hr ) )
            {
                ULONG cElements = ( fByRef ? 
                    (*pVar->pparray)->rgsabound[0].cElements : 
                pVar->parray->rgsabound[0].cElements );
                
                // Look at each variant element
                for(ULONG ul = 0; SUCCEEDED(hr) && ul < cElements; ul++)
                {
                    VARIANT *v = ((VARIANT*)pVarData) + ul;
                    switch(v->vt)
                    {
                        case VT_UI1:
                        case VT_I1:
                            if(ul > 0 && ulTypeSizeReturn != 1) // Can't mix variant types in array
                            {
                                hr = E_INVALIDARG;
                                break;
                            }
                            ulTypeSizeReturn = 1;  // One byte data types
                            break;
            
                            // unsigned short or short
                        case VT_UI2:
                        case VT_I2: 
                            if(ul > 0 && ulTypeSizeReturn != 2)
                            {
                                hr = E_INVALIDARG;
                                break;
                            }
                            ulTypeSizeReturn = 2; // Two byte data types
                            break;
            
                            // int or unsigned int or long or unsigned long
                        case VT_INT:
                        case VT_UINT:
                        case VT_I4:
                        case VT_UI4:
                            if(ul > 0 && ulTypeSizeReturn != 4)
                            {
                                hr = E_INVALIDARG;
                                break;
                            }
                            ulTypeSizeReturn = 4; // Four byte data types
                            break;

                        default:
                            hr = E_INVALIDARG;
                            break;

                    }

                    if(SUCCEEDED(hr) && ul == 0)
                    {
                        // If we are at the first element then allocate the memory we need
                        pData = new BYTE[ulTypeSizeReturn * cElements];
                        if(!pData)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if(SUCCEEDED(hr))
                    {
                        if(ulTypeSizeReturn == 1)
                        {
                            *(BYTE *)(pData + (ulTypeSizeReturn * ul)) = v->cVal;
                        }
                        else if(ulTypeSizeReturn == 2)
                        {
                            *(SHORT *)(pData + (ulTypeSizeReturn * ul)) = v->iVal;
                        }
                        else
                        {
                            *(LONG *)(pData + (ulTypeSizeReturn * ul)) = v->lVal;
                        }
                    }
                }

                if(SUCCEEDED(hr))
                {
                    ulDataSize = cElements * ulTypeSizeReturn;
                }
                else
                {
                    SafeArrayUnaccessData( fByRef ? *pVar->pparray : pVar->parray );
                    delete pData;
                }

            }
            break;

        case VT_NULL:
        case VT_EMPTY:
            break; // No pData to pass.

        default:
            hr = E_INVALIDARG;
            break;

        }
        
        // access the data through safearray if it's not a bstr
        if( SUCCEEDED( hr ) && ulTypeSize )
        {
            hr = SafeArrayAccessData( fByRef ? *pVar->pparray : pVar->parray,
                (void **)&pData );
            if( SUCCEEDED( hr ) )
            {
                ulDataSize = ( fByRef ? 
                    (*pVar->pparray)->rgsabound[0].cElements : 
                pVar->parray->rgsabound[0].cElements ) * ulTypeSize;
            }
        }
        
        if ( SUCCEEDED( hr ) )
        {
            *ppData = pData;
            if ( pSize )
            {
                *pSize = ulDataSize;
            }
            if ( pDataTypeSize )
            {
                *pDataTypeSize = ulTypeSizeReturn;
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    
    return hr;
}

/*****************************************************************************
* UnaccessVariantData *
*-------------------*
*       
********************************************************************* TODDT ***/
void UnaccessVariantData( const VARIANT* pVar, BYTE *pData )
{
    SPDBG_FUNC( "UnaccessVariantData" );
    
    // If we have a Variant by ref then just move to that.
    if ( pVar && (pVar->vt == (VT_BYREF | VT_VARIANT)) )
    {
        pVar = pVar->pvarVal;
    }

    if( pVar )
    {
        switch( pVar->vt )
        {
        case (VT_ARRAY | VT_BYREF | VT_UI1):
        case (VT_ARRAY | VT_BYREF | VT_I1): 
        case (VT_ARRAY | VT_BYREF | VT_UI2):
        case (VT_ARRAY | VT_BYREF | VT_I2): 
        case (VT_ARRAY | VT_BYREF | VT_INT):
        case (VT_ARRAY | VT_BYREF | VT_UINT):
        case (VT_ARRAY | VT_BYREF | VT_I4):
        case (VT_ARRAY | VT_BYREF | VT_UI4):
            SafeArrayUnaccessData( *pVar->pparray );
            break;
            
        case (VT_ARRAY | VT_BYREF | VT_VARIANT):
            delete pData;
            SafeArrayUnaccessData( *pVar->pparray );
            break;
            
        case (VT_ARRAY | VT_UI1):
        case (VT_ARRAY | VT_I1): 
        case (VT_ARRAY | VT_UI2):
        case (VT_ARRAY | VT_I2): 
        case (VT_ARRAY | VT_INT):
        case (VT_ARRAY | VT_UINT):
        case (VT_ARRAY | VT_I4):
        case (VT_ARRAY | VT_UI4):
            SafeArrayUnaccessData( pVar->parray );
            break;
            
        case (VT_ARRAY | VT_VARIANT):
            delete pData;
            SafeArrayUnaccessData( pVar->parray );
            break;

        default:
            break;
        }
    }
}


/*****************************************************************************
* VariantToPhoneIds *
*-------------------*
*   Takes a variant and converts to an array of phone ids. This uses AccessVariantData
*   but then sensibly converts 8- and 32-bit values into 16-bit PHONEIDs.
*   Note that the caller has to delete the *ppPhoneId array after calling this if it succeeds
*
********************************************************************* davewood ***/
HRESULT VariantToPhoneIds(const VARIANT *pVar, SPPHONEID **ppPhoneId)
{
    SPDBG_FUNC( "VariantToPhoneIds" );
    HRESULT hr = S_OK;
    ULONG ulSize;
    ULONG ulDataTypeSize;
    BYTE * pVarArray;

    hr = AccessVariantData( pVar, &pVarArray, &ulSize, &ulDataTypeSize );

    if( SUCCEEDED(hr))
    {
        if(pVarArray)
        {
            // This assumes that all types coming from AccessVariantData are standard numeric
            // types (either CHAR/BYTE/WCHAR/SHORT/USHORT/LONG/ULONG). This is currently true
            // but if AccessVariantData supports new things this may have to.
            ULONG ulPhones = ulSize / ulDataTypeSize;
            *ppPhoneId = new SPPHONEID[ulPhones + 1]; // + 1 for the NULL termination
            (*ppPhoneId)[ulPhones] = L'\0';
            if(ulDataTypeSize != sizeof(SPPHONEID))
            {
                if(ulDataTypeSize == 1)
                {
                    for(ULONG ul = 0; ul < ulPhones; ul++)
                    {
                        // Cast unsigned BYTE to USHORT values 0 - 255 map okay.
                        (*ppPhoneId)[ul] = (SPPHONEID)(pVarArray[ul]);
                    }
                }
                else if(ulDataTypeSize == 4)
                {
                    ULONG* pul = (ULONG*)pVarArray;
                    for(ULONG ul = 0; ul < ulPhones; ul++, pul++)
                    {
                        // Cast ULONG to USHORT values 0 - 32768 will map okay.
                        if(*pul > 32767)
                        {
                            hr = E_INVALIDARG;
                            delete *ppPhoneId;
                            break;
                        }
                        (*ppPhoneId)[ul] = (SPPHONEID)(*pul);
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                memcpy( *ppPhoneId, pVarArray, ulSize );
            }
        }
        else
        {
            *ppPhoneId = NULL; // Initialize in case empty variant
        }

        UnaccessVariantData(pVar, pVarArray);
    }

    return hr;
}


/*****************************************************************************
* FormatPrivateEventData *
*-------------------*
*       
********************************************************************* TODDT ***/
HRESULT FormatPrivateEventData( CSpEvent * pEvent, VARIANT * pVariant )
{
    SPDBG_FUNC( "FormatPrivateEventData" );
    HRESULT hr = S_OK;
    CComVariant varLParam;
    
    switch( pEvent->elParamType )
    {
    case SPET_LPARAM_IS_UNDEFINED:
#ifdef _WIN64
        hr = ULongLongToVariant( pEvent->lParam, &varLParam );
#else
        varLParam = pEvent->lParam;
#endif
        break;
        
    case SPET_LPARAM_IS_TOKEN:
        {
            CComQIPtr<ISpeechObjectToken> cpToken(pEvent->ObjectToken());
            varLParam = (IDispatch*)cpToken;
        }
        break;
        
    case SPET_LPARAM_IS_OBJECT:
        varLParam = (IUnknown*)pEvent->Object();
        break;
        
    case SPET_LPARAM_IS_POINTER:
        {
            BYTE *pArray;
            SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, (ULONG)pEvent->wParam );
            if( psa )
            {
                if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
                {
                    memcpy( pArray, (void*)(pEvent->lParam), pEvent->wParam );
                    SafeArrayUnaccessData( psa );
                    varLParam.vt     = VT_ARRAY | VT_UI1;
                    varLParam.parray = psa;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        break;
        
    case SPET_LPARAM_IS_STRING:
        varLParam = CComBSTR(pEvent->String());
        break;
    }
    
    hr = varLParam.Detach( pVariant );
    
    return hr;
}


/*****************************************************************************
* WaveFormatExFromInterface *
*-------------------*
*       
********************************************************************* TODDT ***/
HRESULT WaveFormatExFromInterface( ISpeechWaveFormatEx * pWaveFormatEx, WAVEFORMATEX** ppWaveFormatExStruct )
{
    SPDBG_FUNC( "WaveFormatExFromInterface" );
    HRESULT hr = S_OK;
    CComVariant vExtra;
    
    hr = pWaveFormatEx->get_ExtraData( &vExtra );
    
    if ( SUCCEEDED( hr ) )
    {
        BYTE * pData = NULL;
        ULONG ulDataSize = 0;
        
        hr = AccessVariantData( &vExtra, &pData, &ulDataSize );
        
        if( SUCCEEDED( hr ) )
        {
            WAVEFORMATEX * pWFStruct = (WAVEFORMATEX*)CoTaskMemAlloc( ulDataSize + sizeof(WAVEFORMATEX) );
            
            if ( pWFStruct )
            {
                // Now fill in the WaveFromatEx struct.
                hr = pWaveFormatEx->get_FormatTag( (short*)&pWFStruct->wFormatTag );
                if ( SUCCEEDED( hr ) )
                {
                    hr = pWaveFormatEx->get_Channels( (short*)&pWFStruct->nChannels );
                }
                if ( SUCCEEDED( hr ) )
                {
                    hr = pWaveFormatEx->get_SamplesPerSec( (long*)&pWFStruct->nSamplesPerSec );
                }
                if ( SUCCEEDED( hr ) )
                {
                    hr = pWaveFormatEx->get_AvgBytesPerSec( (long*)&pWFStruct->nAvgBytesPerSec );
                }
                if ( SUCCEEDED( hr ) )
                {
                    hr = pWaveFormatEx->get_BlockAlign( (short*)&pWFStruct->nBlockAlign );
                }
                if ( SUCCEEDED( hr ) )
                {
                    hr = pWaveFormatEx->get_BitsPerSample( (short*)&pWFStruct->wBitsPerSample );
                }
                if ( SUCCEEDED( hr ) )
                {
                    pWFStruct->cbSize = (WORD)ulDataSize;
                    if ( ulDataSize )
                    {
                        memcpy((BYTE*)pWFStruct + sizeof(WAVEFORMATEX), pData, ulDataSize);
                    }
                }
                if ( SUCCEEDED( hr ) )
                {
                    *ppWaveFormatExStruct = pWFStruct;  // SUCCESS!
                }
                else
                {
                    ::CoTaskMemFree( pWFStruct );
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            
            UnaccessVariantData( &vExtra, pData );
        }
    }
    
    return hr;
}


//
//=== ISpeechAudioFormat =====================================================
//

/*****************************************************************************
* CSpeechAudioFormat::GetFormat *
*--------------------------*
*       
********************************************************************* TODDT ***/
HRESULT CSpeechAudioFormat::GetFormat( SpeechAudioFormatType* pStreamFormatType,
                                      GUID *          pGuid,
                                      WAVEFORMATEX ** ppWFExPtr )
{
    SPDBG_FUNC( "CSpeechAudioFormat::GetFormat" );
    HRESULT hr = S_OK;
    
    // If we've got live data then update it.
    if ( m_pSpStreamFormat )
    {
        hr = m_StreamFormat.AssignFormat( m_pSpStreamFormat );
    }
    else if ( m_pSpRecoContext )
    {
        SPAUDIOOPTIONS  Options;
        GUID            AudioFormatId;
        WAVEFORMATEX    *pCoMemWFE;
        
        hr = m_pSpRecoContext->GetAudioOptions(&Options, &AudioFormatId, &pCoMemWFE);
        if ( SUCCEEDED( hr ) )
        {
            hr = m_StreamFormat.AssignFormat( AudioFormatId, pCoMemWFE );
            
            if ( pCoMemWFE )
            {
                ::CoTaskMemFree( pCoMemWFE );
            }
        }
    }
    else if ( m_pCSpResult )
    {
        if( m_pCSpResult->m_pResultHeader->ulPhraseDataSize == 0 ||
            m_pCSpResult->m_pResultHeader->ulRetainedOffset    == 0 ||
            m_pCSpResult->m_pResultHeader->ulRetainedDataSize  == 0 )
        {
            return SPERR_NO_AUDIO_DATA;
        }
        
        // Get the audio format of the audio currently in the result object
        ULONG cbFormatHeader;
        CSpStreamFormat cpStreamFormat;
        hr = cpStreamFormat.Deserialize(((BYTE*)m_pCSpResult->m_pResultHeader) + m_pCSpResult->m_pResultHeader->ulRetainedOffset, &cbFormatHeader);
        
        if ( SUCCEEDED( hr ) )
        {
            hr = m_StreamFormat.AssignFormat( cpStreamFormat );
        }
    }
    
    if ( SUCCEEDED( hr ) )
    {
        if ( pStreamFormatType )
        {
            *pStreamFormatType = (SpeechAudioFormatType)m_StreamFormat.ComputeFormatEnum();
        }
        if ( pGuid )
        {
            *pGuid = m_StreamFormat.FormatId(); 
        }
        if ( ppWFExPtr )
        {
            *ppWFExPtr = (WAVEFORMATEX*)m_StreamFormat.WaveFormatExPtr();
        }
    }
    
    return hr;
}

/*****************************************************************************
* CSpeechAudioFormat::SetFormat *
*--------------------------*
*       
********************************************************************* TODDT ***/
HRESULT CSpeechAudioFormat::SetFormat( SpeechAudioFormatType* pStreamFormatType,
                                      GUID *          pGuid,
                                      WAVEFORMATEX *  pWFExPtr )
{
    SPDBG_FUNC( "CSpeechAudioFormat::SetFormat" );
    HRESULT hr = S_OK;
    
    CSpStreamFormat sf;
    
    // First set up sf so we can deal with the format easier.
    if ( pStreamFormatType )
    {
        hr = sf.AssignFormat( (SPSTREAMFORMAT)*pStreamFormatType );
    }
    else if ( pGuid )
    {
        hr = sf.AssignFormat( *pGuid, NULL );
    }
    else
    {
        hr = sf.AssignFormat( SPDFID_WaveFormatEx, pWFExPtr );
    }
    
    if ( SUCCEEDED( hr ) )
    {
        if ( m_pSpRecoContext )
        {
            SPAUDIOOPTIONS  Options;
            
            hr = m_pSpRecoContext->GetAudioOptions( &Options, NULL, NULL );
            if ( SUCCEEDED( hr ) )
            {
                hr = m_pSpRecoContext->SetAudioOptions(Options, &(sf.FormatId()), sf.WaveFormatExPtr());
            }
        }
        else if ( m_pCSpResult )
        {
            hr = m_pCSpResult->ScaleAudio( &(sf.FormatId()), sf.WaveFormatExPtr() );
            
        }
        else if ( m_pSpAudio )
        {
            hr = m_pSpAudio->SetFormat( sf.FormatId(), sf.WaveFormatExPtr() );
        }
    }
    
    if ( SUCCEEDED( hr ) )
    {
        hr = m_StreamFormat.AssignFormat( sf.FormatId(), sf.WaveFormatExPtr() );
    }
    
    return hr;
}

/*****************************************************************************
* CSpeechAudioFormat::get_Type *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioFormat::get_Type( SpeechAudioFormatType* pStreamFormatType )
{
    SPDBG_FUNC( "CSpeechAudioFormat::get_Type" );
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_WRITE_PTR( pStreamFormatType ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetFormat( pStreamFormatType, NULL, NULL );
    }
    
    return hr;
} /* CSpeechAudioFormat::get_Type */

  /*****************************************************************************
  * CSpeechAudioFormat::put_Type *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioFormat::put_Type( SpeechAudioFormatType StreamFormatType )
{
    SPDBG_FUNC( "CSpeechAudioFormat::put_Type" );
    HRESULT hr = S_OK;
    
    if ( !m_fReadOnly )
    {
        hr = SetFormat( &StreamFormatType, NULL, NULL );
    }
    else
    {
        hr = E_FAIL;
    }
    
    return hr;
} /* CSpeechAudioFormat::put_Type */

  /*****************************************************************************
  * CSpeechAudioFormat::get_Guid *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioFormat::get_Guid( BSTR* pGuid )
{
    SPDBG_FUNC( "CSpeechAudioFormat::get_Guid" );
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_WRITE_PTR( pGuid ) )
    {
        hr = E_POINTER;
    }
    else
    {
        GUID    Guid;
        
        hr = GetFormat( NULL, &Guid, NULL );
        
        if ( SUCCEEDED( hr ) )
        {
            CSpDynamicString szGuid;
            
            hr = StringFromIID(Guid, &szGuid);
            if ( SUCCEEDED( hr ) )
            {
                hr = szGuid.CopyToBSTR(pGuid);
            }
        }
    }
    
    return hr;
} /* CSpeechAudioFormat::get_Guid */

  /*****************************************************************************
  * CSpeechAudioFormat::put_Guid *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioFormat::put_Guid( BSTR szGuid )
{
    SPDBG_FUNC( "CSpeechAudioFormat::put_Guid" );
    HRESULT hr = S_OK;
    
    if ( !m_fReadOnly )
    {
        // Note we only support the formats in the format enum here and 
        // you can only set the GUID to the waveformatex GUID.
        GUID g;
        hr = IIDFromString(szGuid, &g);
        
        if ( SUCCEEDED( hr ) )
        {
            hr = SetFormat( NULL, &g, NULL );
        }
    }
    else
    {
        hr = E_FAIL;
    }
    
    return hr;
} /* CSpeechAudioFormat::put_Guid */

  /*****************************************************************************
  * CSpeechAudioFormat::GetWaveFormatEx *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioFormat::GetWaveFormatEx( ISpeechWaveFormatEx** ppWaveFormatEx )
{
    SPDBG_FUNC( "CSpeechAudioFormat::GetWaveFormatEx" );
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_WRITE_PTR( ppWaveFormatEx ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Create new object.
        CComObject<CSpeechWaveFormatEx> *pWaveFormatEx;
        hr = CComObject<CSpeechWaveFormatEx>::CreateInstance( &pWaveFormatEx );
        if ( SUCCEEDED( hr ) )
        {
            pWaveFormatEx->AddRef();
            hr = GetFormat( NULL, NULL, NULL ); // This will force a format update.
            
            if ( SUCCEEDED( hr ) )
            {
                hr = pWaveFormatEx->InitFormat(m_StreamFormat.WaveFormatExPtr());
                if ( SUCCEEDED( hr ) )
                {
                    *ppWaveFormatEx = pWaveFormatEx;
                }
            }
            if ( FAILED( hr ))
            {
                *ppWaveFormatEx = NULL;
                pWaveFormatEx->Release();
            }
        }
    }
    
    return hr;
} /* CSpeechAudioFormat::GetWaveFormatEx */

  /*****************************************************************************
  * CSpeechAudioFormat::SetWaveFormatEx *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechAudioFormat::SetWaveFormatEx( ISpeechWaveFormatEx* pWaveFormatEx )
{
    SPDBG_FUNC( "CSpeechAudioFormat::SetWaveFormatEx" );
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_INTERFACE_PTR( pWaveFormatEx ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if ( !m_fReadOnly )
        {
            WAVEFORMATEX * pWFStruct =  NULL;
            
            hr = WaveFormatExFromInterface( pWaveFormatEx, &pWFStruct );
            
            if ( SUCCEEDED( hr ) )
            {
                hr = SetFormat( NULL, NULL, pWFStruct );
                ::CoTaskMemFree( pWFStruct );
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    
    return hr;
} /* CSpeechAudioFormat::SetWaveFormatEx */



//
//=== ISpeechWaveFormatEx =====================================================
//

/*****************************************************************************
* CSpeechWaveFormatEx::InitFormat *
*--------------------------*
*       
********************************************************************* TODDT ***/
HRESULT CSpeechWaveFormatEx::InitFormat(const WAVEFORMATEX *pWaveFormat)
{
    HRESULT hr = S_OK;
    
    // See if we have a WaveFormatEx struct.
    if ( pWaveFormat )
    {
        WORD cbSize = pWaveFormat->cbSize;
        m_wFormatTag = pWaveFormat->wFormatTag;
        m_nChannels = pWaveFormat->nChannels;
        m_nSamplesPerSec = pWaveFormat->nSamplesPerSec;
        m_nAvgBytesPerSec = pWaveFormat->nAvgBytesPerSec;
        m_nBlockAlign = pWaveFormat->nBlockAlign;
        m_wBitsPerSample = pWaveFormat->wBitsPerSample;
        if ( cbSize )
        {
            BYTE *pArray;
            SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, cbSize );
            if( psa )
            {
                if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
                {
                    memcpy(pArray, (BYTE*)pWaveFormat + sizeof(WAVEFORMATEX), cbSize );
                    SafeArrayUnaccessData( psa );
                    VariantClear(&m_varExtraData);
                    m_varExtraData.vt     = VT_ARRAY | VT_UI1;
                    m_varExtraData.parray = psa;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            
        }
    }
    return hr;
}


/*****************************************************************************
* CSpeechWaveFormatEx::get_FormatTag *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::get_FormatTag( short* pFormatTag )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::get_FormatTag" );
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_WRITE_PTR( pFormatTag ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pFormatTag = m_wFormatTag;
    }
    return hr;
} /* CSpeechWaveFormatEx::get_FormatTag */

  /*****************************************************************************
  * CSpeechWaveFormatEx::put_FormatTag *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::put_FormatTag( short FormatTag )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::put_FormatTag" );
    
    m_wFormatTag = FormatTag;
    return S_OK;
} /* CSpeechWaveFormatEx::put_FormatTag */

  /*****************************************************************************
  * CSpeechWaveFormatEx::get_Channels *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::get_Channels(short* pChannels )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::get_Channels" );
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_WRITE_PTR( pChannels ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pChannels = m_nChannels;
    }
    return hr;
} /* CSpeechWaveFormatEx::get_Channels */

  /*****************************************************************************
  * CSpeechWaveFormatEx::put_Channels *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::put_Channels( short Channels )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::put_Channels" );
    m_nChannels = Channels;
    return S_OK;
} /* CSpeechWaveFormatEx::put_Channels */

  /*****************************************************************************
  * CSpeechWaveFormatEx::get_SamplesPerSec *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::get_SamplesPerSec( long* pSamplesPerSec )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::get_SamplesPerSec" );
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_WRITE_PTR( pSamplesPerSec ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pSamplesPerSec = m_nSamplesPerSec;
    }
    return hr;
} /* CSpeechWaveFormatEx::get_SamplesPerSec */

  /*****************************************************************************
  * CSpeechWaveFormatEx::put_SamplesPerSec *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::put_SamplesPerSec( long SamplesPerSec )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::put_SamplesPerSec" );
    m_nSamplesPerSec = SamplesPerSec;
    return S_OK;
} /* CSpeechWaveFormatEx::put_SamplesPerSec */

  /*****************************************************************************
  * CSpeechWaveFormatEx::get_AvgBytesPerSec *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::get_AvgBytesPerSec( long* pAvgBytesPerSec )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::get_AvgBytesPerSec" );
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_WRITE_PTR( pAvgBytesPerSec ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pAvgBytesPerSec = m_nAvgBytesPerSec;
    }
    return hr;
} /* CSpeechWaveFormatEx::get_AvgBytesPerSec */

  /*****************************************************************************
  * CSpeechWaveFormatEx::put_AvgBytesPerSec *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::put_AvgBytesPerSec( long AvgBytesPerSec )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::put_AvgBytesPerSec" );
    m_nAvgBytesPerSec = AvgBytesPerSec;
    return S_OK;
} /* CSpeechWaveFormatEx::put_AvgBytesPerSec */

  /*****************************************************************************
  * CSpeechWaveFormatEx::get_BlockAlign *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::get_BlockAlign( short* pBlockAlign )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::get_BlockAlign" );
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_WRITE_PTR( pBlockAlign ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pBlockAlign = m_nBlockAlign;
    }
    return hr;
} /* CSpeechWaveFormatEx::get_BlockAlign */

  /*****************************************************************************
  * CSpeechWaveFormatEx::put_BlockAlign *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::put_BlockAlign( short BlockAlign )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::put_BlockAlign" );
    m_nBlockAlign = BlockAlign;
    return S_OK;
} /* CSpeechWaveFormatEx::put_BlockAlign */

  /*****************************************************************************
  * CSpeechWaveFormatEx::get_BitsPerSample *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::get_BitsPerSample( short* pBitsPerSample )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::get_BitsPerSample" );
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_WRITE_PTR( pBitsPerSample ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pBitsPerSample = m_wBitsPerSample;
    }
    return hr;
} /* CSpeechWaveFormatEx::get_BitsPerSample */

  /*****************************************************************************
  * CSpeechWaveFormatEx::put_BitsPerSample *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::put_BitsPerSample( short BitsPerSample )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::put_BitsPerSample" );
    m_wBitsPerSample = BitsPerSample;
    return S_OK;
} /* CSpeechWaveFormatEx::put_BitsPerSample */

  /*****************************************************************************
  * CSpeechWaveFormatEx::get_ExtraData *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::get_ExtraData( VARIANT* pExtraData )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::get_ExtraData" );
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_WRITE_PTR( pExtraData ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = VariantCopy( pExtraData, &m_varExtraData );
    }
    
    return hr;
} /* CSpeechWaveFormatEx::get_ExtraData */

  /*****************************************************************************
  * CSpeechWaveFormatEx::put_ExtraData *
  *--------------------------*
  *       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWaveFormatEx::put_ExtraData( VARIANT ExtraData )
{
    SPDBG_FUNC( "CSpeechWaveFormatEx::put_ExtraData" );
    HRESULT hr = S_OK;
    
    BYTE * pData = NULL;
    
    // Call AccessVariantData to verify we support the format.
    hr = AccessVariantData( &ExtraData, &pData, NULL );
    
    if ( SUCCEEDED( hr ) )
    {
        UnaccessVariantData( &ExtraData, pData );
        hr = VariantCopy( &m_varExtraData, &ExtraData );
    }
    
    return hr;
} /* CSpeechWaveFormatEx::put_ExtraData */


#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_helpers.h ===
/*******************************************************************************
* a_helpers.h *
*-----------*
*   Description:
*       This is the header file that declares the various automation helper
*       routines and classes.
*-------------------------------------------------------------------------------
*  Created By: TODDT                            Date: 1/11/2001
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/

#pragma once

#ifdef SAPI_AUTOMATION

//--- Additional includes
#include "spresult.h"

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

inline BSTR EmptyStringToNull( BSTR pString )
{
    if ( pString && !SP_IS_BAD_OPTIONAL_STRING_PTR(pString) && (wcslen(pString) == 0) )
    {
        return NULL;
    }
    else
    {
        return pString;
    }
}

HRESULT LongLongToVariant( LONGLONG ll, VARIANT* pVar );
HRESULT VariantToLongLong( VARIANT* pVar, LONGLONG * pll );
HRESULT ULongLongToVariant( ULONGLONG ull, VARIANT* pVar );
HRESULT VariantToULongLong( VARIANT* pVar, ULONGLONG * pull );

HRESULT AccessVariantData( const VARIANT* pVar, BYTE ** ppData, ULONG * pSize = NULL, ULONG * pDataTypeSize = NULL, bool * pfIsString = NULL );
void    UnaccessVariantData( const VARIANT* pVar, BYTE *pData );
HRESULT VariantToPhoneIds(const VARIANT *pVar, SPPHONEID **ppPhoneId);

HRESULT FormatPrivateEventData( CSpEvent * pEvent, VARIANT * pVariant );

HRESULT WaveFormatExFromInterface( ISpeechWaveFormatEx * pWaveFormatEx, WAVEFORMATEX** ppWaveFormatExStruct );

//=== Class, Struct and Union Definitions ==========================

/*** CSpeechAudioFormat
*   This object is used to access the Format info for 
*   the associated stream.
*/
class ATL_NO_VTABLE CSpeechAudioFormat : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSpeechAudioFormat, &CLSID_SpAudioFormat>,
	public IDispatchImpl<ISpeechAudioFormat, &IID_ISpeechAudioFormat, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTRY_RESOURCEID(IDR_SPAUDIOFORMAT)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechAudioFormat)
	    COM_INTERFACE_ENTRY(ISpeechAudioFormat)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  public:
    CSpeechAudioFormat()
    { 
        m_fReadOnly = false;
        m_pCSpResult = NULL;
        // TODDT: Should we default a format?
    };

    ~CSpeechAudioFormat()
    { 
        if ( m_pCSpResult )
        {
            m_pCSpResult->Release();
        }
    };

    // Helpers
    HRESULT InitAudio( ISpAudio* pAudio, bool fReadOnly = false )
    {
        m_fReadOnly = fReadOnly;
        m_pSpAudio = pAudio;
        m_pSpStreamFormat = pAudio;
        return m_StreamFormat.AssignFormat( pAudio );
    }

    HRESULT InitStreamFormat( ISpStreamFormat * pSpStreamFormat = NULL, bool fReadOnly = false )
    {
        HRESULT hr = S_OK;
        m_fReadOnly = fReadOnly;
        if ( pSpStreamFormat )
        {
            m_pSpStreamFormat = pSpStreamFormat;
            hr = m_StreamFormat.AssignFormat( pSpStreamFormat );
        }
        return hr;
    }

    HRESULT InitFormat( GUID guid, WAVEFORMATEX * pWFEx, bool fReadOnly = false )
    {
        // This just sets up the format with no real object reference.
        m_fReadOnly = fReadOnly;
        return m_StreamFormat.AssignFormat(guid, pWFEx);
    }

    HRESULT InitRetainedAudio( ISpRecoContext * pRecoContext, bool fReadOnly = false )
    {
        m_pSpRecoContext = pRecoContext;
        m_fReadOnly = fReadOnly;
        return GetFormat( NULL, NULL, NULL ); // This will force a format update.
    }

    HRESULT InitResultAudio( CSpResult * pCSpResult, bool fReadOnly = false )
    {
        m_pCSpResult = pCSpResult;
        if ( m_pCSpResult )
        {
            m_pCSpResult->AddRef();
        }
        m_fReadOnly = fReadOnly;
        return GetFormat( NULL, NULL, NULL ); // This will force a format update.
    }

    HRESULT GetFormat( SpeechAudioFormatType* pStreamFormatType,
                                            GUID *          pGuid,
                                            WAVEFORMATEX ** ppWFExPtr );
    HRESULT SetFormat( SpeechAudioFormatType* pStreamFormatType,
                                            GUID *          pGuid,
                                            WAVEFORMATEX *  pWFExPtr );

    //--- ISpeechAudioFormat ----------------------------------
    STDMETHOD(get_Type)(SpeechAudioFormatType* FormatType);
    STDMETHOD(put_Type)(SpeechAudioFormatType  FormatType);
    STDMETHOD(get_Guid)(BSTR* Guid);
    STDMETHOD(put_Guid)(BSTR Guid);
    STDMETHOD(GetWaveFormatEx)(ISpeechWaveFormatEx** WaveFormatEx);
    STDMETHOD(SetWaveFormatEx)(ISpeechWaveFormatEx* WaveFormatEx);

    /*=== Member Data ===*/
    CComPtr<ISpAudio>           m_pSpAudio;
    CComPtr<ISpStreamFormat>    m_pSpStreamFormat;
    CComPtr<ISpRecoContext>     m_pSpRecoContext;
    CSpResult *                 m_pCSpResult;
    CSpStreamFormat             m_StreamFormat;
    bool                        m_fReadOnly;
};

/*** CSpeechWaveFormatEx
*   This object is used to access the WaveFormatEx data from the 
*   associated stream format.
*/
class ATL_NO_VTABLE CSpeechWaveFormatEx : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpeechWaveFormatEx, &CLSID_SpWaveFormatEx>,
	public IDispatchImpl<ISpeechWaveFormatEx, &IID_ISpeechWaveFormatEx, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTRY_RESOURCEID(IDR_SPWAVEFORMATEX)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechWaveFormatEx)
	    COM_INTERFACE_ENTRY(ISpeechWaveFormatEx)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    CSpeechWaveFormatEx()
    { 
        m_wFormatTag = 0; 
        m_nChannels = 0;
        m_nSamplesPerSec = 0;
        m_nAvgBytesPerSec = 0; 
        m_nBlockAlign = 0; 
        m_wBitsPerSample = 0;
        VariantInit( &m_varExtraData );
    };

    /*--- Non interface methods ---*/

    HRESULT InitFormat(const WAVEFORMATEX *pWaveFormat);

  /*=== Interfaces ====*/
  public:
    //--- ISpeechWaveFormatEx ----------------------------------
    STDMETHOD(get_FormatTag)(short* FormatTag);
    STDMETHOD(put_FormatTag)(short FormatTag);
    STDMETHOD(get_Channels)(short* Channels);
    STDMETHOD(put_Channels)(short Channels);
    STDMETHOD(get_SamplesPerSec)(long* SamplesPerSec);
    STDMETHOD(put_SamplesPerSec)(long SamplesPerSec);
    STDMETHOD(get_AvgBytesPerSec)(long* AvgBytesPerSec);
    STDMETHOD(put_AvgBytesPerSec)(long AvgBytesPerSec);
    STDMETHOD(get_BlockAlign)(short* BlockAlign);
    STDMETHOD(put_BlockAlign)(short BlockAlign);
    STDMETHOD(get_BitsPerSample)(short* BitsPerSample);
    STDMETHOD(put_BitsPerSample)(short BitsPerSample);
    STDMETHOD(get_ExtraData)(VARIANT* ExtraData);
    STDMETHOD(put_ExtraData)(VARIANT ExtraData);

    /*=== Member Data ===*/
    WORD        m_wFormatTag; 
    WORD        m_nChannels; 
    DWORD       m_nSamplesPerSec; 
    DWORD       m_nAvgBytesPerSec; 
    WORD        m_nBlockAlign; 
    WORD        m_wBitsPerSample;
    VARIANT     m_varExtraData;
};

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_memorystream.h ===
// MemoryStream.h : Declaration of the CMemoryStream

#ifndef __MEMORYSTREAM_H_
#define __MEMORYSTREAM_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMemoryStream
class ATL_NO_VTABLE CMemoryStream : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMemoryStream, &CLSID_SpMemoryStream>
    //--- Automation
    #ifdef SAPI_AUTOMATION
	,public IDispatchImpl<ISpeechMemoryStream, &IID_ISpeechMemoryStream, &LIBID_SpeechLib, 5>
    #endif
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_REGISTRY_RESOURCEID(IDR_SPMEMORYSTREAM)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CMemoryStream)
        #ifdef SAPI_AUTOMATION
	    COM_INTERFACE_ENTRY(ISpeechMemoryStream)
	    COM_INTERFACE_ENTRY(ISpeechBaseStream)
	    COM_INTERFACE_ENTRY(IDispatch)
        #endif

	    COM_INTERFACE_ENTRY_AGGREGATE(IID_IStream, m_cpAgg.p)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_ISequentialStream, m_cpAgg.p)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_ISpStreamFormat, m_cpAgg.p)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_ISpStream, m_cpAgg.p)

        //--- Automation
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
    CMemoryStream(){}

	HRESULT FinalConstruct();
	void FinalRelease();

  /*=== Interfaces ====*/
  public:
#ifdef SAPI_AUTOMATION

    //--- ISpeechMemoryStream -----------------------------------------------------------
    STDMETHODIMP SetData(VARIANT Data);
    STDMETHODIMP GetData(VARIANT *pData);

    //--- ISpeechBaseStream -------------------------------------------------------
    STDMETHODIMP get_Format(ISpeechAudioFormat** StreamFormat);
    STDMETHODIMP putref_Format(ISpeechAudioFormat *pFormat);
    STDMETHODIMP Read(VARIANT* Buffer, long NumBytes, long* pRead);
    STDMETHODIMP Write(VARIANT Buffer, long* pWritten);
    STDMETHODIMP Seek(VARIANT Move, SpeechStreamSeekPositionType Origin, VARIANT* NewPosition);

    CComPtr<IUnknown> m_cpAgg;
    CComPtr<ISpStream> m_cpStream;
    CComPtr<ISpStreamAccess> m_cpAccess;

#endif // SAPI_AUTOMATION

  /*=== Member Data ===*/
  protected:
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_lexicon.h ===
/*******************************************************************************
* a_lexicon.h *
*-----------*
*   Description:
*-------------------------------------------------------------------------------
*  Created By: davewood                          Date: 01/01/2001
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef a_lexicon_h
#define a_lexicon_h

#ifdef SAPI_AUTOMATION

//--- Additional includes

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

class SPWORDSETENTRY
{
public:
    SPWORDSETENTRY()
    {
        WordList.ulSize = 0;
        WordList.pvBuffer = NULL;
        WordList.pFirstWord = 0;
        m_pNext = NULL;
    }
    ~SPWORDSETENTRY()
    {
        ::CoTaskMemFree(WordList.pvBuffer);
    }
    SPWORDLIST WordList;
    SPWORDSETENTRY *m_pNext;
};


/*** CSpeechLexiconWords */
class ATL_NO_VTABLE CSpeechLexiconWords : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechLexiconWords, &IID_ISpeechLexiconWords, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechLexiconWords)
	    COM_INTERFACE_ENTRY(ISpeechLexiconWords)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  public:

    CSpeechLexiconWords() : m_ulWords(0){}

    //--- ISpeechLexiconWords ----------------------------------
    STDMETHOD(get_Count)(long* pVal);
    STDMETHOD(Item)(long Index, ISpeechLexiconWord **ppWords );
    STDMETHOD(get__NewEnum)(IUnknown** ppEnumVARIANT);

    /*=== Member Data ===*/
    CSpBasicQueue<SPWORDSETENTRY> m_WordSet;
    ULONG m_ulWords;
};


class ATL_NO_VTABLE CEnumWords : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IEnumVARIANT
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CEnumWords)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      CEnumWords() : m_CurrIndex(0) {}

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- IEnumVARIANT ----------------------------------
    STDMETHOD(Clone)(IEnumVARIANT** ppEnum);
    STDMETHOD(Next)(ULONG celt, VARIANT* rgelt, ULONG* pceltFetched);
    STDMETHOD(Reset)(void) { m_CurrIndex = 0; return S_OK;}
    STDMETHOD(Skip)(ULONG celt); 

  /*=== Member Data ===*/
    CComPtr<ISpeechLexiconWords>     m_cpWords;
    ULONG                            m_CurrIndex;
};


/*** CSpeechLexiconWord */
class ATL_NO_VTABLE CSpeechLexiconWord : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechLexiconWord, &IID_ISpeechLexiconWord, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechLexiconWord)
	    COM_INTERFACE_ENTRY(ISpeechLexiconWord)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  public:

    //--- ISpeechLexiconWord ----------------------------------
    STDMETHODIMP get_LangId(SpeechLanguageId* LangId);
    STDMETHODIMP get_Type(SpeechWordType* WordType);
    STDMETHODIMP get_Word(BSTR* Word);
    STDMETHODIMP get_Pronunciations(ISpeechLexiconPronunciations** Pronunciations);

    /*=== Member Data ===*/
    CComPtr<ISpeechLexiconWords> m_cpWords;
    SPWORD *m_pWord;
};





/*** CSpeechLexiconProns */
class ATL_NO_VTABLE CSpeechLexiconProns : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechLexiconPronunciations, &IID_ISpeechLexiconPronunciations, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechLexiconProns)
	    COM_INTERFACE_ENTRY(ISpeechLexiconPronunciations)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  public:

    CSpeechLexiconProns()
    {
        m_PronList.ulSize = 0;
        m_PronList.pvBuffer = NULL;
        m_PronList.pFirstWordPronunciation = NULL;
        m_ulProns = 0;
    }

    ~CSpeechLexiconProns()
    {
        if(m_cpWord == NULL)
        {
            ::CoTaskMemFree(m_PronList.pvBuffer);
        }
    }

    //--- ISpeechLexiconPronunciations ----------------------------------
    STDMETHOD(get_Count)(long* pVal);
    STDMETHOD(Item)(long Index, ISpeechLexiconPronunciation **ppPron );
    STDMETHOD(get__NewEnum)(IUnknown** ppEnumVARIANT);

    /*=== Member Data ===*/
    ULONG m_ulProns;
    SPWORDPRONUNCIATIONLIST m_PronList;
    CComPtr<ISpeechLexiconWord> m_cpWord; // From a GetWords, else from GetProns
};


class ATL_NO_VTABLE CEnumProns : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IEnumVARIANT
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CEnumProns)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      CEnumProns() : m_CurrIndex(0) {}

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- IEnumVARIANT ----------------------------------
    STDMETHOD(Clone)(IEnumVARIANT** ppEnum);
    STDMETHOD(Next)(ULONG celt, VARIANT* rgelt, ULONG* pceltFetched);
    STDMETHOD(Reset)(void) { m_CurrIndex = 0; return S_OK;}
    STDMETHOD(Skip)(ULONG celt); 

  /*=== Member Data ===*/
    CComPtr<ISpeechLexiconPronunciations>     m_cpProns;
    ULONG                            m_CurrIndex;
};


/*** CSpeechLexiconPron */
class ATL_NO_VTABLE CSpeechLexiconPron : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechLexiconPronunciation, &IID_ISpeechLexiconPronunciation, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechLexiconPron)
	    COM_INTERFACE_ENTRY(ISpeechLexiconPronunciation)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  public:

    //--- ISpeechLexiconPronunciation ----------------------------------
    STDMETHODIMP get_Type(SpeechLexiconType* LexiconType);
    STDMETHODIMP get_LangId(SpeechLanguageId* LangId);
    STDMETHODIMP get_PartOfSpeech(SpeechPartOfSpeech* PartOfSpeech);
    STDMETHODIMP get_PhoneIds(VARIANT* PhoneIds);
    STDMETHODIMP get_Symbolic(BSTR* Symbolic);

    /*=== Member Data ===*/
    SPWORDPRONUNCIATION *m_pPron;
    CComPtr<ISpeechLexiconPronunciations> m_cpProns;
};




#endif // SAPI_AUTOMATION

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_phbuilder.cpp ===
/*******************************************************************************
* a_phbuilder.cpp *
*-------------*
*   Description:
*       This module is the main implementation file for the CSpPhraseInfoBuilder
*   automation methods.
*-------------------------------------------------------------------------------
*  Created By: Leonro                                        Date: 1/16/01
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "a_phbuilder.h"
#include "a_reco.h"
#include "a_helpers.h"

#ifdef SAPI_AUTOMATION



//
//=== ISpeechPhraseInfoBuilder interface ==================================================
// 

/*****************************************************************************
* CSpPhraseInfoBuilder::RestorePhraseFromMemory *
*----------------------------------*
*
*   This method restores a previously saved reco result that was saved to memory via
*   the ISpeechRecoResult::SavePhraseToMemory method. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpPhraseInfoBuilder::RestorePhraseFromMemory( VARIANT* PhraseInMemory, ISpeechPhraseInfo **PhraseInfo )
{
    SPDBG_FUNC( "CSpPhraseBuilder::RestorePhraseFromMemory" );
    HRESULT		hr = S_OK;

    if( SP_IS_BAD_READ_PTR( PhraseInMemory ) )
    {
        hr = E_INVALIDARG;
    }
    else if( SP_IS_BAD_WRITE_PTR( PhraseInfo ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Create the CSpPhraseBuilder object
        CComPtr<ISpPhraseBuilder> cpPhraseBuilder;
        hr = cpPhraseBuilder.CoCreateInstance( CLSID_SpPhraseBuilder );
        
        if( SUCCEEDED( hr ) )
        {
            BYTE *        pSafeArray;
            SPSERIALIZEDPHRASE* pSerializedPhrase;

            hr = AccessVariantData( PhraseInMemory, (BYTE**)&pSerializedPhrase );

            if( SUCCEEDED( hr ) )
            {
                hr = cpPhraseBuilder->InitFromSerializedPhrase( pSerializedPhrase );
                UnaccessVariantData( PhraseInMemory, (BYTE *)pSerializedPhrase );
            }

            if ( SUCCEEDED( hr ) )
            {
                CComObject<CSpeechPhraseInfo> *cpPhraseInfo;

                hr = CComObject<CSpeechPhraseInfo>::CreateInstance( &cpPhraseInfo );

                if ( SUCCEEDED( hr ) )
                {
                    cpPhraseInfo->AddRef();
                    cpPhraseInfo->m_cpISpPhrase = cpPhraseBuilder;

                    // Use CSpPhraseBuilder to fill in the SPPHRASE
                    hr = cpPhraseBuilder->GetPhrase( &cpPhraseInfo->m_pPhraseStruct );

                    if( SUCCEEDED( hr ) )
                    {
                        *PhraseInfo = cpPhraseInfo;
                    }
                    else
                    {
                        *PhraseInfo = NULL;
                        cpPhraseInfo->Release();
                    }
                }
            }
        }
    }

	return hr;
} /* CSpPhraseInfoBuilder::RestorePhraseFromMemory */

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_reco.h ===
/*******************************************************************************
* a_reco.h *
*-----------*
*   Description:
*       This is the header file for the CSpeechRecognizerStatus implementation.
*-------------------------------------------------------------------------------
*  Created By: TODDT                            Date: 10/11/2000
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef a_reco_h
#define a_reco_h

#ifdef SAPI_AUTOMATION

//--- Additional includes
#include "resource.h"
#include "a_recoCP.h"

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================
class CSpeechRecognizerStatus;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CSpeechRecognizerStatus
*   This object is used to access the status of
*   the associated reco instance.
*/
class ATL_NO_VTABLE CSpeechRecognizerStatus : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechRecognizerStatus, &IID_ISpeechRecognizerStatus, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechRecognizerStatus)
	    COM_INTERFACE_ENTRY(ISpeechRecognizerStatus)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  public:
    //--- ISpeechRecognizerStatus ----------------------------------
    STDMETHOD(get_AudioStatus)( ISpeechAudioStatus** AudioStatus );
	STDMETHOD(get_CurrentStreamPosition)( VARIANT* pCurrentStreamPos );
    STDMETHOD(get_CurrentStreamNumber)( long* pCurrentStreamNumber );
	STDMETHOD(get_NumberOfActiveRules)( long* pNumActiveRules );
	STDMETHOD(get_ClsidEngine)( BSTR* pbstrClsidEngine );
	STDMETHOD(get_SupportedLanguages)( VARIANT* pSupportedLangs );

  /*=== Member Data ===*/
    SPRECOGNIZERSTATUS      m_Status;
};

/*** CSpeechRecoResultTimes
*   This object is used to access the results times of
*   the associated speech reco result.
*/
class ATL_NO_VTABLE CSpeechRecoResultTimes : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechRecoResultTimes, &IID_ISpeechRecoResultTimes, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechRecoResultTimes)
	    COM_INTERFACE_ENTRY(ISpeechRecoResultTimes)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechRecoResultTimes ----------------------------------
    STDMETHOD(get_StreamTime)(VARIANT* pTime );
    STDMETHOD(get_Length)(VARIANT* pLength );
    STDMETHOD(get_TickCount)(long* pTickCount );
    STDMETHOD(get_OffsetFromStart)(VARIANT* pStart );

    /*=== Member Data ===*/
    SPRECORESULTTIMES   m_ResultTimes;
};


/*** CSpeechPhraseInfo
*   This object is used to access the result phrase info from
*   the associated speech reco result.
*/
class ATL_NO_VTABLE CSpeechPhraseInfo : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechPhraseInfo, &IID_ISpeechPhraseInfo, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechPhraseInfo)
	    COM_INTERFACE_ENTRY(ISpeechPhraseInfo)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      ~CSpeechPhraseInfo()
        {
            if ( m_pPhraseStruct )
            {
                CoTaskMemFree( m_pPhraseStruct );
                m_pPhraseStruct = NULL;
            }
        };

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechPhraseInfo ----------------------------------
    STDMETHOD(get_LanguageId)( long* pLanguageId );
    STDMETHOD(get_GrammarId)( VARIANT* pGrammarId );
    STDMETHOD(get_StartTime)( VARIANT* pStartTime );
    STDMETHOD(get_AudioStreamPosition)( VARIANT* pAudioStreamPosition );
    STDMETHOD(get_AudioSizeBytes)( long* pAudioSizeBytes );
    STDMETHOD(get_RetainedSizeBytes)( long* pRetainedSizeBytes );
    STDMETHOD(get_AudioSizeTime)( long* pAudioSizeTime );
    STDMETHOD(get_Rule)( ISpeechPhraseRule** ppRule );
    STDMETHOD(get_Properties)( ISpeechPhraseProperties** ppProperties );
    STDMETHOD(get_Elements)( ISpeechPhraseElements** ppElements );
    STDMETHOD(get_Replacements)( ISpeechPhraseReplacements** ppReplacements );
    STDMETHOD(get_EngineId)( BSTR* EngineIdGuid );
    STDMETHOD(get_EnginePrivateData)( VARIANT *PrivateData );
    STDMETHOD(SaveToMemory)( VARIANT* ResultBlock );
    STDMETHOD(GetText)( long StartElement, long Elements,
                        VARIANT_BOOL UseTextReplacements, BSTR* Text );
    STDMETHOD(GetDisplayAttributes)( long StartElement, 
                                     long Elements,
                                     VARIANT_BOOL UseReplacements, 
                                     SpeechDisplayAttributes* DisplayAttributes );

    /*=== Member Data ===*/
    CComPtr<ISpPhrase>     m_cpISpPhrase;
    SPPHRASE *             m_pPhraseStruct;
};

/*** CSpeechPhraseElements
*   This object is used to access the result phrase Elements from
*   the associated speech reco result.
*/
class ATL_NO_VTABLE CSpeechPhraseElements : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechPhraseElements, &IID_ISpeechPhraseElements, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechPhraseElements)
	    COM_INTERFACE_ENTRY(ISpeechPhraseElements)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      ~CSpeechPhraseElements()
        {
            if ( m_pCPhraseInfo )
            {
                m_pCPhraseInfo->Release();
                m_pCPhraseInfo = NULL;
            }
        };

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechPhraseElements ----------------------------------
    STDMETHOD(get_Count)(long* pVal);
    STDMETHOD(Item)(long Index, ISpeechPhraseElement** ppElts );
    STDMETHOD(get__NewEnum)(IUnknown** ppEnumVARIANT);

    /*=== Member Data ===*/
    CSpeechPhraseInfo *  m_pCPhraseInfo;
};

/*** CSpeechPhraseElement
*   This object is used to access a result phrase Element from
*   the associated speech reco result.
*/
class ATL_NO_VTABLE CSpeechPhraseElement : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechPhraseElement, &IID_ISpeechPhraseElement, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechPhraseElement)
	    COM_INTERFACE_ENTRY(ISpeechPhraseElement)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechPhraseElement ----------------------------------
    STDMETHOD(get_AudioStreamOffset)( long* pAudioStreamOffset );
    STDMETHOD(get_AudioTimeOffset)( long* pAudioTimeOffset );
    STDMETHOD(get_AudioSizeBytes)( long* pAudioSizeBytes );
    STDMETHOD(get_AudioSizeTime)( long* pAudioSizeTime );
    STDMETHOD(get_RetainedStreamOffset)( long* pRetainedStreamOffset );
    STDMETHOD(get_RetainedSizeBytes)( long* pRetainedSizeBytes );
    STDMETHOD(get_DisplayText)( BSTR* pDisplayText );
    STDMETHOD(get_LexicalForm)( BSTR* pLexicalForm );
    STDMETHOD(get_Pronunciation)( VARIANT* pPronunciation );
    STDMETHOD(get_DisplayAttributes)( SpeechDisplayAttributes* pDisplayAttributes );
    STDMETHOD(get_RequiredConfidence)( SpeechEngineConfidence* pRequiredConfidence );
    STDMETHOD(get_ActualConfidence)( SpeechEngineConfidence* pActualConfidence );
    STDMETHOD(get_EngineConfidence)( float* pEngineConfidence );

    /*=== Member Data ===*/
    const SPPHRASEELEMENT *     m_pPhraseElement;
    CComPtr<ISpeechPhraseInfo>  m_pIPhraseInfo;
};


/*** CSpeechPhraseRule
*   This object is used to access a result phrase rule from
*   the associated speech reco result.
*/
class ATL_NO_VTABLE CSpeechPhraseRule : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechPhraseRule, &IID_ISpeechPhraseRule, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechPhraseRule)
	    COM_INTERFACE_ENTRY(ISpeechPhraseRule)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechPhraseRule ----------------------------------
    STDMETHOD(get_Name)( BSTR* pName );
    STDMETHOD(get_Id)( long* pId );
    STDMETHOD(get_FirstElement)( long* pFirstElement );
    STDMETHOD(get_NumberOfElements)( long* pNumElements );
    STDMETHOD(get_Parent)( ISpeechPhraseRule** ppParent );
    STDMETHOD(get_Children)( ISpeechPhraseRules** ppChildren );
    STDMETHOD(get_Confidence)( SpeechEngineConfidence* ActualConfidence );
    STDMETHOD(get_EngineConfidence)( float* EngineConfidence );


    /*=== Member Data ===*/
    const SPPHRASERULE *        m_pPhraseRuleData;
    CComPtr<ISpeechPhraseInfo>  m_pIPhraseInfo; // NOTE: only top rule sets this!!
    CComPtr<ISpeechPhraseRule>  m_pIPhraseRuleParent;
};

/*** CSpeechPhraseRules
*   This object is used to access a result phrase rules colloection from
*   the associated speech reco result rule object.
*/
class ATL_NO_VTABLE CSpeechPhraseRules : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechPhraseRules, &IID_ISpeechPhraseRules, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechPhraseRules)
	    COM_INTERFACE_ENTRY(ISpeechPhraseRules)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechPhraseRules ----------------------------------
    STDMETHOD(get_Count)(long* pVal);
    STDMETHOD(Item)(long Index, ISpeechPhraseRule **Rule );
    STDMETHOD(get__NewEnum)(IUnknown** ppEnumVARIANT);

    /*=== Member Data ===*/
    const SPPHRASERULE *        m_pPhraseRuleFirstChildData;
    CComPtr<ISpeechPhraseRule>  m_pIPhraseRuleParent;
};

//********************************************

/*** CSpeechPhraseProperty
*   This object is used to access a result phrase property data from
*   the associated speech reco result.
*/
class ATL_NO_VTABLE CSpeechPhraseProperty : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechPhraseProperty, &IID_ISpeechPhraseProperty, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechPhraseProperty)
	    COM_INTERFACE_ENTRY(ISpeechPhraseProperty)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechPhraseProperty ----------------------------------
    STDMETHOD(get_Name)( BSTR* Name );
    STDMETHOD(get_Id)( long* Id );
    STDMETHOD(get_Value)( VARIANT* pValue );
    STDMETHOD(get_FirstElement)( long* FirstElement );
    STDMETHOD(get_NumberOfElements)( long* NumberOfElements );
    STDMETHOD(get_EngineConfidence)( float* Confidence );
    STDMETHOD(get_Confidence)( SpeechEngineConfidence* Confidence );
    STDMETHOD(get_Parent)( ISpeechPhraseProperty** ppParentProperty );
    STDMETHOD(get_Children)( ISpeechPhraseProperties** ppChildren );

    /*=== Member Data ===*/
    const SPPHRASEPROPERTY *        m_pPhrasePropertyData;
    CComPtr<ISpeechPhraseProperty>  m_pIPhrasePropertyParent;
};

/*** CSpeechPhraseProperties
*   This object is used to access a result phrase properties colloection from
*   the associated speech reco result object.
*/
class ATL_NO_VTABLE CSpeechPhraseProperties : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechPhraseProperties, &IID_ISpeechPhraseProperties, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechPhraseProperties)
	    COM_INTERFACE_ENTRY(ISpeechPhraseProperties)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechPhraseProperties ----------------------------------
    STDMETHOD(get_Count)(long* pVal);
    STDMETHOD(Item)(long Index, ISpeechPhraseProperty **pProperty );
    STDMETHOD(get__NewEnum)(IUnknown** ppEnumVARIANT);

    /*=== Member Data ===*/
    const SPPHRASEPROPERTY *        m_pPhrasePropertyFirstChildData;
    CComPtr<ISpeechPhraseInfo>      m_pIPhraseInfo; // NOTE: only top properties object sets this!!
    CComPtr<ISpeechPhraseProperty>  m_pIPhrasePropertyParent;
};


// *******************************************************************************************************************

/*** CSpeechPhraseReplacements
*   This object is used to access the result phrase replacements from
*   the associated speech reco result.
*/
class ATL_NO_VTABLE CSpeechPhraseReplacements : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechPhraseReplacements, &IID_ISpeechPhraseReplacements, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechPhraseReplacements)
	    COM_INTERFACE_ENTRY(ISpeechPhraseReplacements)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      ~CSpeechPhraseReplacements()
        {
            if ( m_pCPhraseInfo )
            {
                m_pCPhraseInfo->Release();
                m_pCPhraseInfo = NULL;
            }
        };

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechPhraseReplacements ----------------------------------
    STDMETHOD(get_Count)(long* pVal);
    STDMETHOD(Item)(long Index, ISpeechPhraseReplacement** ppReplacement);
    STDMETHOD(get__NewEnum)(IUnknown** ppEnumVARIANT);

    /*=== Member Data ===*/
    CSpeechPhraseInfo *  m_pCPhraseInfo;
};

/*** CSpeechPhraseReplacement
*   This object is used to access a result phrase replacement from
*   the associated speech reco result.
*/
class ATL_NO_VTABLE CSpeechPhraseReplacement : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechPhraseReplacement, &IID_ISpeechPhraseReplacement, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechPhraseReplacement)
	    COM_INTERFACE_ENTRY(ISpeechPhraseReplacement)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechPhraseReplacement ----------------------------------
    STDMETHOD(get_DisplayAttributes)( SpeechDisplayAttributes* DisplayAttributes );
    STDMETHOD(get_Text)( BSTR* Text );
    STDMETHOD(get_FirstElement)( long* FirstElement );
    STDMETHOD(get_NumberOfElements)( long* NumElements );

    /*=== Member Data ===*/
    const SPPHRASEREPLACEMENT * m_pPhraseReplacement;
    CComPtr<ISpeechPhraseInfo>  m_pIPhraseInfo;
};


/*** CSpeechPhraseAlternates
*   This object is used to access the result phrase alternates from
*   the associated speech reco result.
*/
class ATL_NO_VTABLE CSpeechPhraseAlternates : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechPhraseAlternates, &IID_ISpeechPhraseAlternates, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechPhraseAlternates)
	    COM_INTERFACE_ENTRY(ISpeechPhraseAlternates)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/
      ~CSpeechPhraseAlternates()
        {
            if ( m_rgIPhraseAlts )
            {
                ULONG i;

                for ( i = 0; i < m_lPhraseAltsCount; i++ )
                {
                    (m_rgIPhraseAlts[i])->Release();
                }

                CoTaskMemFree( m_rgIPhraseAlts );
                m_rgIPhraseAlts = NULL;
                m_lPhraseAltsCount = 0;
            }
        };

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechPhraseAlternates ----------------------------------
    STDMETHOD(get_Count)(long* pVal);
    STDMETHOD(Item)(long Index, ISpeechPhraseAlternate** ppAlts );
    STDMETHOD(get__NewEnum)(IUnknown** ppEnumVARIANT);

    /*=== Member Data ===*/
    CComPtr<ISpeechRecoResult>  m_cpResult;
    ISpPhraseAlt **             m_rgIPhraseAlts;
    ULONG                       m_lPhraseAltsCount;
};



#endif // SAPI_AUTOMATION

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_recoei.cpp ===
/*******************************************************************************
* a_recoei.cpp *
*-------------*
*   Description:
*       This module is the main implementation file for the CSpeechRecoEventInterests
*   automation methods.
*-------------------------------------------------------------------------------
*  Created By: Leonro                                        Date: 11/20/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "a_recoei.h"

#ifdef SAPI_AUTOMATION

/*****************************************************************************
* CSpeechRecoEventInterests::FinalRelease *
*------------------------*
*   Description:
*       destructor
********************************************************************* Leonro ***/
void CSpeechRecoEventInterests::FinalRelease()
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::FinalRelease" );

    if( m_pCRecoCtxt )
    {
        m_pCRecoCtxt->Release();
        m_pCRecoCtxt = NULL;
    }

} /* CSpeechRecoEventInterests::FinalRelease */

//
//=== ICSpeechRecoEventInterests interface ==================================================
// 

/*****************************************************************************
* CSpeechRecoEventInterests::put_StreamEnd *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_END_SR_STREAM event on 
*   the Reco Context.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_StreamEnd( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_StreamEnd" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    ULONGLONG test = SPFEI_ALL_SR_EVENTS;

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_END_SR_STREAM);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_END_SR_STREAM);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_StreamEnd */

/*****************************************************************************
* CSpeechRecoEventInterests::get_StreamEnd *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_END_SR_STREAM interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_StreamEnd( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_StreamEnd" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_END_SR_STREAM) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_StreamEnd */

/*****************************************************************************
* CSpeechRecoEventInterests::put_SoundStart *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_SOUND_START event on 
*   the Reco Context.       
*
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_SoundStart( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_SoundStart" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_SOUND_START);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_SOUND_START);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_SoundStart */

/*****************************************************************************
* CSpeechRecoEventInterests::get_SoundStart *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_SOUND_START interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_SoundStart( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_SoundStart" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_SOUND_START) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_SoundStart */

/*****************************************************************************
* CSpeechRecoEventInterests::put_SoundEnd *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_SOUND_END event on 
*   the Reco Context.  
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_SoundEnd( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_SoundEnd" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_SOUND_END);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_SOUND_END);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_SoundEnd */

/*****************************************************************************
* CSpeechRecoEventInterests::get_SoundEnd *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_SOUND_END interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_SoundEnd( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_SoundEnd" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_SOUND_END) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_SoundEnd */

/*****************************************************************************
* CSpeechRecoEventInterests::put_PhraseStart *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_PHRASE_START event on 
*   the Reco Context.  
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_PhraseStart( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_PhraseStart" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_PHRASE_START);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_PHRASE_START);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_PhraseStart */

/*****************************************************************************
* CSpeechRecoEventInterests::get_PhraseStart *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_PHRASE_START interest is 
*   enabled on the Reco Context object.
*    
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_PhraseStart( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_PhraseStart" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_PHRASE_START) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_PhraseStart */

/*****************************************************************************
* CSpeechRecoEventInterests::put_Recognition *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_RECOGNITION event on 
*   the Reco Context.  
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_Recognition( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_Recognition" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_RECOGNITION);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_RECOGNITION);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_Recognition */

/*****************************************************************************
* CSpeechRecoEventInterests::get_Recognition *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_RECOGNITION interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_Recognition( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_Recognition" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_RECOGNITION) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_Recognition */

/*****************************************************************************
* CSpeechRecoEventInterests::put_Hypothesis *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_HYPOTHESIS event on 
*   the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_Hypothesis( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_Hypothesis" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_HYPOTHESIS);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_HYPOTHESIS);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_Hypothesis */

/*****************************************************************************
* CSpeechRecoEventInterests::get_Hypothesis *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_HYPOTHESIS interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_Hypothesis( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_Hypothesis" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_HYPOTHESIS) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_Hypothesis */

/*****************************************************************************
* CSpeechRecoEventInterests::put_Bookmark *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_SR_BOOKMARK event on 
*   the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_Bookmark( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_Bookmark" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_SR_BOOKMARK);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_SR_BOOKMARK);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_Bookmark */

/*****************************************************************************
* CSpeechRecoEventInterests::get_Bookmark *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_SR_BOOKMARK interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_Bookmark( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_Bookmark" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_SR_BOOKMARK) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_Bookmark */

/*****************************************************************************
* CSpeechRecoEventInterests::put_PropertyNumChange *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_PROPERTY_NUM_CHANGE event on 
*   the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_PropertyNumChange( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_PropertyNumChange" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_PROPERTY_NUM_CHANGE);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_PROPERTY_NUM_CHANGE);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_PropertyNumChange */

/*****************************************************************************
* CSpeechRecoEventInterests::get_PropertyNumChange *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_PROPERTY_NUM_CHANGE interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_PropertyNumChange( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_PropertyNumChange" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_PROPERTY_NUM_CHANGE) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_PropertyNumChange */

/*****************************************************************************
* CSpeechRecoEventInterests::put_PropertyStringChange *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_PROPERTY_STRING_CHANGE event on 
*   the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_PropertyStringChange( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_PropertyStringChange" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_PROPERTY_STRING_CHANGE);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_PROPERTY_STRING_CHANGE);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_PropertyStringChange */

/*****************************************************************************
* CSpeechRecoEventInterests::get_PropertyStringChange *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_PROPERTY_STRING_CHANGE interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_PropertyStringChange( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_PropertyStringChange" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_PROPERTY_STRING_CHANGE) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_PropertyStringChange */

/*****************************************************************************
* CSpeechRecoEventInterests::put_FalseRecognition *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_FALSE_RECOGNITION event on 
*   the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_FalseRecognition( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_FalseRecognition" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_FALSE_RECOGNITION);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_FALSE_RECOGNITION);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_FalseRecognition */

/*****************************************************************************
* CSpeechRecoEventInterests::get_FalseRecognition *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_FALSE_RECOGNITION interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_FalseRecognition( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_FalseRecognition" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_FALSE_RECOGNITION) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_FalseRecognition */

/*****************************************************************************
* CSpeechRecoEventInterests::put_Interference *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_INTERFERENCE event on 
*   the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_Interference( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_Interference" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_INTERFERENCE);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_INTERFERENCE);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_Interference */

/*****************************************************************************
* CSpeechRecoEventInterests::get_Interference *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_INTERFERENCE interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_Interference( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_Interference" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_INTERFERENCE) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_Interference */

/*****************************************************************************
* CSpeechRecoEventInterests::put_RequestUI *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_REQUEST_UI event on 
*   the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_RequestUI( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_RequestUI" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_REQUEST_UI);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_REQUEST_UI);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_RequestUI */

/*****************************************************************************
* CSpeechRecoEventInterests::get_RequestUI *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_REQUEST_UI interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_RequestUI( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_RequestUI" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_REQUEST_UI) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_RequestUI */

/*****************************************************************************
* CSpeechRecoEventInterests::put_StateChange *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_RECO_STATE_CHANGE event on 
*   the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_StateChange( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_StateChange" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_RECO_STATE_CHANGE);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_RECO_STATE_CHANGE);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_StateChange */

/*****************************************************************************
* CSpeechRecoEventInterests::get_StateChange *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_RECO_STATE_CHANGE interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_StateChange( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_StateChange" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_RECO_STATE_CHANGE) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_StateChange */

/*****************************************************************************
* CSpeechRecoEventInterests::put_Adaptation *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_ADAPTATION event on 
*   the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_Adaptation( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_Adaptation" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_ADAPTATION);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_ADAPTATION);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_Adaptation */

/*****************************************************************************
* CSpeechRecoEventInterests::get_Adaptation *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_ADAPTATION interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_Adaptation( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_Adaptation" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_ADAPTATION) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_Adaptation */

/*****************************************************************************
* CSpeechRecoEventInterests::put_StreamStart *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_START_SR_STREAM event on 
*   the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_StreamStart( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_StreamStart" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_START_SR_STREAM);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_START_SR_STREAM);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_StreamStart */

/*****************************************************************************
* CSpeechRecoEventInterests::get_StreamStart *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_START_SR_STREAM interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_StreamStart( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_StreamStart" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_START_SR_STREAM) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_StreamStart */

/*****************************************************************************
* CSpeechRecoEventInterests::put_OtherContext *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_RECO_OTHER_CONTEXT event on 
*   the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_OtherContext( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_OtherContext" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_RECO_OTHER_CONTEXT);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_RECO_OTHER_CONTEXT);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_OtherContext */

/*****************************************************************************
* CSpeechRecoEventInterests::get_OtherContext *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_RECO_OTHER_CONTEXT interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_OtherContext( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_OtherContext" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_RECO_OTHER_CONTEXT) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_OtherContext */

/*****************************************************************************
* CSpeechRecoEventInterests::put_AudioLevel *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_SR_AUDIO_LEVEL event on 
*   the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::put_AudioLevel( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::put_AudioLevel" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_SR_AUDIO_LEVEL);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_SR_AUDIO_LEVEL);
        }

        hr = m_pCRecoCtxt->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechRecoEventInterests::put_AudioLevel */

/*****************************************************************************
* CSpeechRecoEventInterests::get_AudioLevel *
*----------------------------------*
*      
*   This method determines whether or not the SPFEI(SPEI_SR_AUDIO_LEVEL interest is 
*   enabled on the Reco Context object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::get_AudioLevel( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::get_AudioLevel" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoCtxt->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_SR_AUDIO_LEVEL) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechRecoEventInterests::get_AudioLevel */

/*****************************************************************************
* CSpeechRecoEventInterests::SetAll *
*----------------------------------*
*
*   This method sets all the interests on the Reco Context. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::SetAll()
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::SetAll" );
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->SetInterest( SPFEI_ALL_SR_EVENTS, SPFEI_ALL_SR_EVENTS );

	return hr;
} /* CSpeechRecoEventInterests::SetAll */

/*****************************************************************************
* CSpeechRecoEventInterests::ClearAll *
*----------------------------------*
*       
*   This method clears all the interests on the Reco Context. 
*
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecoEventInterests::ClearAll()
{
    SPDBG_FUNC( "CSpeechRecoEventInterests::ClearAll" );
    HRESULT		hr = S_OK;

    hr = m_pCRecoCtxt->SetInterest( 0, 0 );

	return hr;
} /* CSpeechRecoEventInterests::ClearAll */

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_phbuilder.h ===
/*******************************************************************************
* a_phbuilder.h *
*-----------*
*   Description:
*       This is the header file for the CSpPhraseInfoBuilder implementation.
*-------------------------------------------------------------------------------
*  Created By: Leonro                            Date: 1/16/01
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef A_PHBUILDER_H
#define A_PHBUILDER_H

#ifdef SAPI_AUTOMATION

//--- Additional includes
#include "resource.h"

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================
class CSpPhraseInfoBuilder;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CSpPhraseInfoBuilder
*   This object is used to access the Event interests on
*   the associated speech voice.
*/
class ATL_NO_VTABLE CSpPhraseInfoBuilder : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpPhraseInfoBuilder, &CLSID_SpPhraseInfoBuilder>,
    public IDispatchImpl<ISpeechPhraseInfoBuilder, &IID_ISpeechPhraseInfoBuilder, &LIBID_SpeechLib, 5>

{
    
  /*=== ATL Setup ===*/
  public:

    DECLARE_REGISTRY_RESOURCEID(IDR_SPPHRASEINFOBUILDER)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CSpPhraseInfoBuilder)
	    COM_INTERFACE_ENTRY(ISpeechPhraseInfoBuilder)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()
  
  /*=== Interfaces ====*/
  public:
    //--- Constructors/Destructors ----------------------------
    CSpPhraseInfoBuilder() {}

    //--- ISpeechPhraseInfoBuilder ----------------------------------
    STDMETHOD(RestorePhraseFromMemory)( VARIANT* PhraseInMemory, ISpeechPhraseInfo **PhraseInfo );
    
    /*=== Member Data ===*/
    
};

#endif // SAPI_AUTOMATION

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_reco.cpp ===
/*******************************************************************************
* a_reco.cpp *
*------------*
*   Description:
*       This module is the main implementation file for the CRecognizer
*   automation methods.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 02/01/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"

#include "RecoCtxt.h"
#include "sphelper.h"
#include "resultheader.h"
#include "a_audio.h"
#include "a_helpers.h"

//
//=== CRecognizer::ISpeechRecognizer interface ==============================
//

/*****************************************************************************
* CRecognizer::Invoke *
*----------------------*
*   IDispatch::Invoke method override
********************************************************************* TODDT ***/
HRESULT CRecognizer::Invoke(DISPID dispidMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
            EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
        // JScript cannot pass NULL VT_DISPATCH parameters and OLE doesn't convert them propertly so we
        // need to convert them here if we need to.
        if ( (dispidMember == DISPID_SRRecognizer) && 
             ((wFlags & DISPATCH_PROPERTYPUT) || (wFlags & DISPATCH_PROPERTYPUTREF)) &&
              pdispparams && (pdispparams->cArgs > 0) )
        {
            VARIANTARG * pvarg = &(pdispparams->rgvarg[pdispparams->cArgs-1]);

            // See if we need to tweak a param.
            // JScript syntax for VT_NULL is "null" for the parameter
            // JScript syntax for VT_EMPTY is "void(0)" for the parameter
            if ( (pvarg->vt == VT_NULL) || (pvarg->vt == VT_EMPTY) )
            {
                pvarg->vt = VT_DISPATCH;
                pvarg->pdispVal = NULL;

                // We have to tweak this flag for the invoke to go through properly.
                if (wFlags == DISPATCH_PROPERTYPUT)
                {
                    wFlags = DISPATCH_PROPERTYPUTREF;
                }
            }
        }

        // Let ATL and OLE handle it now.
        return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
                    wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}


/*****************************************************************************
* CRecognizer::putref_Recognizer *
*-----------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CRecognizer::putref_Recognizer( ISpeechObjectToken* pRecognizer )
{
    SPDBG_FUNC( "CRecognizer::putref_Recognizer" );
    HRESULT hr;

    if( SP_IS_BAD_OPTIONAL_INTERFACE_PTR( pRecognizer ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComQIPtr<ISpObjectToken> cpTok( pRecognizer );
        hr = SetRecognizer(cpTok);
    }

    return hr;
} /* CRecognizer::putref_Recognizer */

/*****************************************************************************
* CRecognizer::get_Recognizer *
*-----------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CRecognizer::get_Recognizer( ISpeechObjectToken** ppRecognizer )
{
    SPDBG_FUNC( "CRecognizer::get_Recognizer" );
    HRESULT hr;

    if( SP_IS_BAD_WRITE_PTR( ppRecognizer ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComQIPtr<ISpObjectToken> pTok;
		hr = GetRecognizer( &pTok );
		if ( SUCCEEDED( hr ) )
        {
			hr = pTok.QueryInterface( ppRecognizer );
        }
    }

    return hr;
} /* CRecognizer::get_Recognizer */

/*****************************************************************************
* CRecognizer::put_AllowAudioInputFormatChangesOnNextSet *
*---------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CRecognizer::put_AllowAudioInputFormatChangesOnNextSet( VARIANT_BOOL fAllow )
{
    SPDBG_FUNC( "CRecognizer::put_AllowAudioInputFormatChangesOnNextSet" );

    // NOTE that this does not take effect till the next time you set the input.
    if( fAllow == VARIANT_TRUE )
    {
        m_fAllowFormatChanges = true;
    }
    else
    {
        m_fAllowFormatChanges = false;
    }

    return S_OK;
} /* CRecognizer::put_AllowAudioInputFormatChangesOnNextSet */

/*****************************************************************************
* CRecognizer::get_AllowAudioInputFormatChangesOnNextSet *
*---------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CRecognizer::get_AllowAudioInputFormatChangesOnNextSet( VARIANT_BOOL* pfAllow )
{
    SPDBG_FUNC( "CRecognizer::get_AllowAudioInputFormatChangesOnNextSet" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pfAllow ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pfAllow = m_fAllowFormatChanges ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return hr;
} /* CRecognizer::get_AllowAudioInputFormatChangesOnNextSet */

/*****************************************************************************
* CRecognizer::putref_AudioInputStream *
*------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecognizer::putref_AudioInputStream( ISpeechBaseStream* pInput )
{
    SPDBG_FUNC( "CRecognizer::putref_AudioInputStream" );
    HRESULT hr;

    if( SP_IS_BAD_OPTIONAL_INTERFACE_PTR( pInput ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
		hr = SetInput( pInput, m_fAllowFormatChanges );
    }

    return hr;
} /* CRecognizer::putref_AudioInputStream */

/*****************************************************************************
* CRecognizer::get_AudioInputStream *
*------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecognizer::get_AudioInputStream( ISpeechBaseStream** ppInput )
{
    SPDBG_FUNC( "CRecognizer::get_AudioInputStream" );
    HRESULT hr;

    if( SP_IS_BAD_WRITE_PTR( ppInput ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpStreamFormat> cpStream;
        hr = GetInputStream( &cpStream );

        if( SUCCEEDED(hr) )
        {
            if ( cpStream  )
            {
        		hr = cpStream.QueryInterface( ppInput );
            }
            else
            {
                *ppInput = NULL;
            }
        }
    }

    return hr;
} /* CRecognizer::get_AudioInputStream */

/*****************************************************************************
* CRecognizer::putref_AudioInput *
*-----------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecognizer::putref_AudioInput( ISpeechObjectToken* pInput )
{
    SPDBG_FUNC( "CRecognizer::putref_AudioInput" );
    HRESULT hr;

    if( SP_IS_BAD_OPTIONAL_INTERFACE_PTR( pInput ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
		hr = SetInput( pInput, m_fAllowFormatChanges );
    }

    return hr;
} /* CRecognizer::putref_AudioInput */

/*****************************************************************************
* CRecognizer::get_AudioInput *
*------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecognizer::get_AudioInput( ISpeechObjectToken** ppInput )
{
    SPDBG_FUNC( "CRecognizer::get_AudioInput" );
    HRESULT hr;

    if( SP_IS_BAD_WRITE_PTR( ppInput ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpObjectToken> cpTok;
        hr = GetInputObjectToken( &cpTok );
        
        if(hr == S_OK)
        {
			hr = cpTok.QueryInterface( ppInput );
        }
        else if(hr == S_FALSE)
        {
            *ppInput = NULL;
        }
    }

    return hr;
} /* CRecognizer::get_AudioInput */

/*****************************************************************************
* CRecognizer::get_IsShared *
*---------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CRecognizer::get_IsShared( VARIANT_BOOL* pIsShared )
{
    SPDBG_FUNC( "CRecognizer::get_IsShared" );
    HRESULT hr = IsSharedInstance();

    if( SP_IS_BAD_WRITE_PTR( pIsShared ) )
    {
        hr = E_POINTER;
    }
    else
    {
		*pIsShared = (hr == S_OK) ? VARIANT_TRUE : VARIANT_FALSE;
		hr = S_OK;
    }

    return hr;
} /* CRecognizer::get_IsShared */

/*****************************************************************************
* CRecognizer::put_State *
*-----------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecognizer::put_State( SpeechRecognizerState eNewState )
{
    SPDBG_FUNC( "CRecognizer::put_State" );

    return SetRecoState( (SPRECOSTATE)eNewState );
} /* CRecognizer::put_State */

/*****************************************************************************
* CRecognizer::get_State *
*-----------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecognizer::get_State( SpeechRecognizerState* peState )
{
    SPDBG_FUNC( "CRecognizer::get_State" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( peState ) )
    {
        hr = E_POINTER;
    }
    else
    {
		hr = GetRecoState( (SPRECOSTATE*)peState );
    }

    return hr;
} /* CRecognizer::get_State */

/*****************************************************************************
* CRecognizer::get_Status *
*-------------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CRecognizer::get_Status( ISpeechRecognizerStatus** ppStatus )
{
    SPDBG_FUNC( "CRecognizer::get_Status" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppStatus ) )
    {
        hr = E_POINTER;
    }
    else
    {
		//--- Create the status object
        CComObject<CSpeechRecognizerStatus> *pClsStatus;
        hr = CComObject<CSpeechRecognizerStatus>::CreateInstance( &pClsStatus );
        if( SUCCEEDED( hr ) )
        {
            pClsStatus->AddRef();
            hr = GetStatus( &pClsStatus->m_Status );

            if( SUCCEEDED( hr ) )
            {
                *ppStatus = pClsStatus;
            }
            else
            {
                pClsStatus->Release();
            }
        }
    }

    return hr;
} /* CRecognizer::get_Status */

/*****************************************************************************
* CRecognizer::CreateRecoContext *
*------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CRecognizer::CreateRecoContext( ISpeechRecoContext** ppNewCtxt )
{
    SPDBG_FUNC( "CRecognizer::get_RecoContext" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppNewCtxt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpRecoContext> cpRC;
        hr = CreateRecoContext(&cpRC);
        if( SUCCEEDED( hr ) )
        {
            // Set automation interests (all except SPEI_SR_AUDIO_LEVEL)
            hr = cpRC->SetInterest( ((ULONGLONG)(SREAllEvents & ~SREAudioLevel) << 34) | SPFEI_FLAGCHECK,
                                    ((ULONGLONG)(SREAllEvents & ~SREAudioLevel) << 34) | SPFEI_FLAGCHECK );
        }
        if ( SUCCEEDED( hr ) )
        {
            hr = cpRC.QueryInterface( ppNewCtxt );
        }
    }

    return hr;
} /* CRecognizer::CreateRecoContext */

/*****************************************************************************
* CRecognizer::GetFormat *
*--------------------------*
*       
******************************************************************** TODDT ***/
STDMETHODIMP CRecognizer::GetFormat( SpeechFormatType Type, ISpeechAudioFormat** ppFormat )
{
    SPDBG_FUNC( "CRecognizer::GetFormat" );
    HRESULT hr;

    if( SP_IS_BAD_WRITE_PTR( ppFormat ) )
    {
        hr = E_POINTER;
    }
    else
    {
        GUID            guid;
        WAVEFORMATEX *  pWFEx = NULL;

        hr = GetFormat( (SPSTREAMFORMATTYPE)Type, &guid, &pWFEx );

        if ( SUCCEEDED( hr ) )
        {
            // Create new object.
            CComObject<CSpeechAudioFormat> *pFormat;
            hr = CComObject<CSpeechAudioFormat>::CreateInstance( &pFormat );
            if ( SUCCEEDED( hr ) )
            {
                pFormat->AddRef();

                hr = pFormat->InitFormat(guid, pWFEx, true);

                if ( SUCCEEDED( hr ) )
                {
                    *ppFormat = pFormat;
                }
                else
                {
                    *ppFormat = NULL;
                    pFormat->Release();
                }
            }

            if ( pWFEx )
            {
                ::CoTaskMemFree( pWFEx );
            }
        }
    }

    return hr;
} /* CRecognizer::GetFormat */

/*****************************************************************************
* CRecognizer::putref_Profile *
*--------------------------*
*       
******************************************************************** TODDT ***/
STDMETHODIMP CRecognizer::putref_Profile( ISpeechObjectToken* pProfile )
{
    SPDBG_FUNC( "CRecognizer::putref_Profile" );
    HRESULT hr;

    if( SP_IS_BAD_INTERFACE_PTR( pProfile ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComQIPtr<ISpObjectToken> cpTok( pProfile );
        hr = SetRecoProfile(cpTok);
    }

    return hr;
} /* CRecognizer::putref_Profile */

/*****************************************************************************
* CRecognizer::get_Profile *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecognizer::get_Profile( ISpeechObjectToken** ppProfile )
{
    SPDBG_FUNC( "CRecognizer::get_Profile" );
    HRESULT hr;

    if( SP_IS_BAD_WRITE_PTR( ppProfile ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpObjectToken> cpTok;
        if( SUCCEEDED( hr = GetRecoProfile( &cpTok ) ) )
        {
			hr = cpTok.QueryInterface( ppProfile );
        }
    }

    return hr;
} /* CRecognizer::get_Profile */


/*****************************************************************************
* CRecognizer::EmulateRecognition *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecognizer::EmulateRecognition( VARIANT Words, VARIANT* pDisplayAttributes, long LanguageId )
{
    SPDBG_FUNC( "CRecognizer::EmulateRecognition" );
    HRESULT hr = S_OK;

    WCHAR **                  ppWords = NULL;
    WCHAR *                   pWords = NULL;
    ULONG                     cWords = 0;
    SPDISPLYATTRIBUTES *      prgDispAttribs = NULL;
    bool                      fByRefString = false;
    bool                      fFreeStringArray = false;
    CComPtr<ISpPhraseBuilder> cpResultPhrase;

    switch( Words.vt )
    {
    case (VT_ARRAY | VT_BYREF | VT_BSTR):
        fByRefString = true;
        // fall through...
    case (VT_ARRAY | VT_BSTR):
        hr = SafeArrayAccessData( fByRefString ? *Words.pparray : Words.parray,
                                  (void **)&ppWords );
        if ( SUCCEEDED( hr ) )
        {
            fFreeStringArray = true;
            cWords = (fByRefString ? (*Words.pparray)->rgsabound[0].cElements : 
                                Words.parray->rgsabound[0].cElements);
        }

        // Figure out the word breaks (DisplayAttributes).
        if ( SUCCEEDED( hr ) && pDisplayAttributes )
        {
            SPDISPLYATTRIBUTES  DefaultAttrib = (SPDISPLYATTRIBUTES)0;
            bool                fBuildAttribArray = !(pDisplayAttributes->vt & VT_ARRAY);

            if ( (pDisplayAttributes->vt == (VT_BYREF | VT_BSTR)) || (pDisplayAttributes->vt == VT_BSTR) )
            {
                WCHAR * pString = ((pDisplayAttributes->vt & VT_BYREF) ? 
                                     (pDisplayAttributes->pbstrVal ? *(pDisplayAttributes->pbstrVal) : NULL) : 
                                      pDisplayAttributes->bstrVal );

                if ( !pString || wcscmp( pString, L"" ) == 0 )
                {
                    DefaultAttrib = (SPDISPLYATTRIBUTES)0;
                }
                else if ( wcscmp( pString, L" " ) == 0 )
                {
                    DefaultAttrib = SPAF_ONE_TRAILING_SPACE;
                }
                else if ( wcscmp( pString, L"  " ) == 0 )
                {
                    DefaultAttrib = SPAF_TWO_TRAILING_SPACES;
                }
                else
                {
                    hr = E_INVALIDARG;
                }
            }
            else if ( pDisplayAttributes->vt & VT_ARRAY )
            {
                BYTE* pData;
                ULONG ulSize;
                ULONG ulDataSize;

                hr = AccessVariantData( pDisplayAttributes, &pData, &ulSize, &ulDataSize );

                if ( SUCCEEDED( hr ) )
                {
                    if ( ulSize / ulDataSize != cWords )
                    {
                        hr = E_INVALIDARG;
                    }
                    else
                    {
                        prgDispAttribs = new SPDISPLYATTRIBUTES[cWords];
                        if ( prgDispAttribs )
                        {
                            for (UINT i=0; i<cWords; i++)
                            {
                                switch ( ulDataSize )
                                {
                                    case 1:
                                        prgDispAttribs[i] = (SPDISPLYATTRIBUTES)*(BYTE*)pData;
                                        break;
                                    case 2:
                                        prgDispAttribs[i] = (SPDISPLYATTRIBUTES)*(WORD*)pData;
                                        break;
                                    case 4:
                                        prgDispAttribs[i] = (SPDISPLYATTRIBUTES)*(DWORD*)pData;
                                        break;
                                    default:
                                        hr = E_INVALIDARG;
                                        break;
                                }
                                pData += ulDataSize;
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    UnaccessVariantData( pDisplayAttributes, pData );
                }
            }
            else 
            {
                ULONGLONG ull;
                hr = VariantToULongLong( pDisplayAttributes, &ull );
                if ( SUCCEEDED( hr ) )
                {
                    DefaultAttrib = (SPDISPLYATTRIBUTES)ull;
                    if ( ull > SPAF_ALL )
                    {
                        hr = E_INVALIDARG;
                    }
                }
            }

            if ( SUCCEEDED(hr) && fBuildAttribArray )
            {
                prgDispAttribs = new SPDISPLYATTRIBUTES[cWords];
                if ( prgDispAttribs )
                {
                    for (UINT i=0; i<cWords; i++)
                    {
                        prgDispAttribs[i] = DefaultAttrib;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if( SUCCEEDED( hr ) )
        {
            hr = CreatePhraseFromWordArray((const WCHAR**)ppWords, cWords,
                                 prgDispAttribs,
                                 &cpResultPhrase,
                                 (LANGID)LanguageId,
                                 NULL);
        }

        if ( prgDispAttribs )
        {
            delete prgDispAttribs;
        }

        break;

    // bstr by ref or bstr
    case (VT_BYREF | VT_BSTR):
        fByRefString = true;
        // fall through...
    case VT_BSTR:
        // We ignore pDisplayAttributes in this case!!
        if( fByRefString ? (Words.pbstrVal!=NULL && *(Words.pbstrVal)!=NULL) : Words.bstrVal!=NULL )
        {
            if ( wcslen( fByRefString ? *(Words.pbstrVal) : Words.bstrVal ) )
            {
                hr = CreatePhraseFromText((const WCHAR*)( fByRefString ? *(Words.pbstrVal) : Words.bstrVal ),
                                     &cpResultPhrase,
                                     (LANGID)LanguageId,
                                     NULL);
            }
        }
        break;

    case VT_NULL:
    case VT_EMPTY:
        return S_OK;

    default:
        hr = E_INVALIDARG;
        break;
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = EmulateRecognition(cpResultPhrase);
    }

    if ( fFreeStringArray )
    {
        SafeArrayUnaccessData( fByRefString ? *Words.pparray : Words.parray );
    }

    return hr;
} /* CRecognizer::EmulateRecognition */


/*****************************************************************************
* CRecognizer::SetPropertyNumber *
*--------------------------*
*       
******************************************************************** TODDT ***/
STDMETHODIMP CRecognizer::SetPropertyNumber( const BSTR bstrName, long Value, VARIANT_BOOL * pfSupported )
{
    SPDBG_FUNC( "CRecognizer::SetPropertyNumber" );
    HRESULT hr;

    if( SP_IS_BAD_WRITE_PTR( pfSupported ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = SetPropertyNum(bstrName, Value);
        *pfSupported = (hr == S_OK) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    return (hr == S_FALSE) ? S_OK : hr; // Map S_FALSE to S_OK since we've set *pfSupported
} /* CRecognizer::SetPropertyNumber */


/*****************************************************************************
* CRecognizer::GetPropertyNumber *
*--------------------------*
*       
******************************************************************** TODDT ***/
STDMETHODIMP CRecognizer::GetPropertyNumber( const BSTR bstrName, long* pValue, VARIANT_BOOL * pfSupported )
{
    SPDBG_FUNC( "CRecognizer::GetPropertyNumber" );
    HRESULT hr;

    if( SP_IS_BAD_WRITE_PTR( pfSupported ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetPropertyNum(bstrName, pValue);
        *pfSupported = (hr == S_OK) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return (hr == S_FALSE) ? S_OK : hr; // Map S_FALSE to S_OK since we've set *pfSupported
} /* CRecognizer::GetPropertyNumber */

/*****************************************************************************
* CRecognizer::SetPropertyString *
*--------------------------*
*       
******************************************************************** TODDT ***/
STDMETHODIMP CRecognizer::SetPropertyString( const BSTR bstrName, const BSTR bstrValue, VARIANT_BOOL * pfSupported )
{
    SPDBG_FUNC( "CRecognizer::SetPropertyString" );
    HRESULT hr;

    if( SP_IS_BAD_WRITE_PTR( pfSupported ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = SetPropertyString((const WCHAR*)bstrName, (const WCHAR*)bstrValue);
        *pfSupported = (hr == S_OK) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    return (hr == S_FALSE) ? S_OK : hr; // Map S_FALSE to S_OK since we've set *pfSupported
} /* CRecognizer::SetPropertyString */


/*****************************************************************************
* CRecognizer::GetPropertyString *
*--------------------------*
*       
******************************************************************** TODDT ***/
STDMETHODIMP CRecognizer::GetPropertyString( const BSTR Name, BSTR* pbstrValue, VARIANT_BOOL * pfSupported )
{
    SPDBG_FUNC( "CRecognizer::GetPropertyString (automation)" );
    HRESULT hr;

    if( SP_IS_BAD_WRITE_PTR( pfSupported ) )
    {
        hr = E_POINTER;
    }
    else if( SP_IS_BAD_WRITE_PTR( pbstrValue ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
	    CSpDynamicString szValue;

        hr = GetPropertyString( (const WCHAR *) Name, (WCHAR **)&szValue );
        if ( SUCCEEDED( hr ) )
        {
            *pfSupported = (hr == S_OK) ? VARIANT_TRUE : VARIANT_FALSE;
            // Note that we want S_FALSE to go to S_OK and the next line does this for us.
		    hr = szValue.CopyToBSTR(pbstrValue);
        }
    }
    return hr;
} /* CRecognizer::GetPropertyString */

/*****************************************************************************
* CRecognizer::IsUISupported *
*--------------------*
*   Checks to see if the specified type of UI is supported.
********************************************************************* Leonro ***/
STDMETHODIMP CRecognizer::IsUISupported( const BSTR TypeOfUI, const VARIANT* ExtraData, VARIANT_BOOL* Supported )
{
    SPDBG_FUNC( "CRecognizer::IsUISupported" );
    HRESULT     hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_READ_PTR( ExtraData ) || SP_IS_BAD_WRITE_PTR( Supported ) )
    {
        hr = E_POINTER;
    }
    else if( SP_IS_BAD_STRING_PTR( TypeOfUI ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        BYTE * pData = NULL;
        ULONG ulDataSize = 0;

        hr = AccessVariantData( ExtraData, &pData, &ulDataSize );

        if ( SUCCEEDED( hr ) )
        {
            BOOL fSupported;
            hr = IsUISupported( TypeOfUI, pData, ulDataSize, &fSupported );
            if ( SUCCEEDED( hr ) && Supported )
            {
                 *Supported = !fSupported ? VARIANT_FALSE : VARIANT_TRUE;
            }

            UnaccessVariantData( ExtraData, pData );
        }
    }
    
    return hr; 
} /* CRecognizer::IsUISupported */

/*****************************************************************************
* CRecognizer::DisplayUI *
*--------------------*
*   Displays the requested UI.
********************************************************************* Leonro ***/
STDMETHODIMP CRecognizer::DisplayUI( long hWndParent, BSTR Title, const BSTR TypeOfUI, const VARIANT* ExtraData )
{
    SPDBG_FUNC( "CRecognizer::DisplayUI" );
    HRESULT     hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_READ_PTR( ExtraData ) )
    {
        hr = E_POINTER;
    }
    else if( SP_IS_BAD_STRING_PTR( Title ) || SP_IS_BAD_STRING_PTR( TypeOfUI ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        BYTE * pData = NULL;
        ULONG ulDataSize = 0;

        hr = AccessVariantData( ExtraData, &pData, &ulDataSize );

        if( SUCCEEDED( hr ) )
        {
            hr = DisplayUI( (HWND)LongToHandle(hWndParent), Title, TypeOfUI, pData, ulDataSize );
            UnaccessVariantData( ExtraData, pData );
        }
    }
    return hr;
} /* CRecognizer::DisplayUI */


/*****************************************************************************
* CRecognizer::GetRecognizers *
*----------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CRecognizer::GetRecognizers( BSTR RequiredAttributes, BSTR OptionalAttributes, ISpeechObjectTokens** ObjectTokens )
{
    SPDBG_FUNC( "CRecognizer::GetRecognizers" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ObjectTokens ) )
    {
        hr = E_POINTER;
    }
    else if( SP_IS_BAD_OPTIONAL_STRING_PTR( RequiredAttributes ) || 
             SP_IS_BAD_OPTIONAL_STRING_PTR( OptionalAttributes ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComPtr<IEnumSpObjectTokens> cpEnum;

        if(SpEnumTokens(SPCAT_RECOGNIZERS, 
                        EmptyStringToNull(RequiredAttributes), 
                        EmptyStringToNull(OptionalAttributes),
                        &cpEnum ) == S_OK)
        {
            hr = cpEnum.QueryInterface( ObjectTokens );
        }
        else
        {
            hr = SPERR_NO_MORE_ITEMS;
        }
    }

    return hr;
} /* CRecognizer::GetRecognizers */

/*****************************************************************************
* CRecognizer::GetAudioInputs *
*----------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CRecognizer::GetAudioInputs( BSTR RequiredAttributes, BSTR OptionalAttributes, ISpeechObjectTokens** ObjectTokens )
{
    SPDBG_FUNC( "CRecognizer::GetAudioInputs" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ObjectTokens ) )
    {
        hr = E_POINTER;
    }
    else if( SP_IS_BAD_OPTIONAL_STRING_PTR( RequiredAttributes ) || 
             SP_IS_BAD_OPTIONAL_STRING_PTR( OptionalAttributes ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComPtr<IEnumSpObjectTokens> cpEnum;

        if(SpEnumTokens(SPCAT_AUDIOIN, 
                        EmptyStringToNull(RequiredAttributes), 
                        EmptyStringToNull(OptionalAttributes),
                        &cpEnum ) == S_OK)
        {
            hr = cpEnum.QueryInterface( ObjectTokens );
        }
        else
        {
            hr = SPERR_NO_MORE_ITEMS;
        }
    }

    return hr;
} /* CRecognizer::GetAudioInputs */

/*****************************************************************************
* CRecognizer::GetProfiles *
*----------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CRecognizer::GetProfiles( BSTR RequiredAttributes, BSTR OptionalAttributes, ISpeechObjectTokens** ObjectTokens )
{
    SPDBG_FUNC( "CRecognizer::GetProfiles" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ObjectTokens ) )
    {
        hr = E_POINTER;
    }
    else if( SP_IS_BAD_OPTIONAL_STRING_PTR( RequiredAttributes ) || 
             SP_IS_BAD_OPTIONAL_STRING_PTR( OptionalAttributes ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComPtr<IEnumSpObjectTokens> cpEnum;

        if(SpEnumTokens(SPCAT_RECOPROFILES, 
                        EmptyStringToNull(RequiredAttributes), 
                        EmptyStringToNull(OptionalAttributes),
                        &cpEnum ) == S_OK)
        {
            hr = cpEnum.QueryInterface( ObjectTokens );
        }
        else
        {
            hr = SPERR_NO_MORE_ITEMS;
        }
    }

    return hr;
} /* CRecognizer::GetProfiles */


//
//=== CRecoCtxt::ISpeechRecoContext ===========================================
//

/*****************************************************************************
* CRecoCtxt::Invoke *
*----------------------*
*   IDispatch::Invoke method override
********************************************************************* TODDT ***/
HRESULT CRecoCtxt::Invoke(DISPID dispidMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
            EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
        // JScript cannot pass NULL VT_DISPATCH parameters and OLE doesn't convert them propertly so we
        // need to convert them here if we need to.
        if ( (dispidMember == DISPID_SRCRetainedAudioFormat) && 
             ((wFlags & DISPATCH_PROPERTYPUT) || (wFlags & DISPATCH_PROPERTYPUTREF)) &&
              pdispparams && (pdispparams->cArgs > 0) )
        {
            VARIANTARG * pvarg = &(pdispparams->rgvarg[pdispparams->cArgs-1]);

            // See if we need to tweak a param.
            // JScript syntax for VT_NULL is "null" for the parameter
            // JScript syntax for VT_EMPTY is "void(0)" for the parameter
            if ( (pvarg->vt == VT_NULL) || (pvarg->vt == VT_EMPTY) )
            {
                pvarg->vt = VT_DISPATCH;
                pvarg->pdispVal = NULL;

                // We have to tweak this flag for the invoke to go through properly.
                if (wFlags == DISPATCH_PROPERTYPUT)
                {
                    wFlags = DISPATCH_PROPERTYPUTREF;
                }
            }
        }

        // Let ATL and OLE handle it now.
        return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
                    wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}


/*****************************************************************************
* CRecoCtxt::get_Recognizer *
*-------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CRecoCtxt::get_Recognizer( ISpeechRecognizer** ppRecognizer )
{
    SPDBG_FUNC( "CRecoCtxt::get_Recognizer" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppRecognizer ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpRecognizer> cpReco;
		hr = GetRecognizer(&cpReco);
		if ( SUCCEEDED( hr ) )
        {
			hr = cpReco.QueryInterface( ppRecognizer );
        }
    }

    return hr;
} /* CRecoCtxt::get_Recognizer */


/*****************************************************************************
* CRecoCtxt::get_AudioInputInterferenceStatus *
*---------------------------------------*
*
*	This method returns possible causes of interference or poor recognition 
*	with the input stream.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CRecoCtxt::get_AudioInputInterferenceStatus( SpeechInterference* pInterference )
{
    SPDBG_FUNC( "CRecoCtxt::get_AudioInputInterferenceStatus" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pInterference ) )
    {
        hr = E_POINTER;
    }
    else
    {
		*pInterference = (SpeechInterference)m_Stat.eInterference;
    }

    return hr;
} /* CRecoCtxt::get_AudioInputInterferenceStatus */

/*****************************************************************************
* CRecoCtxt::get_RequestedUIType *
*---------------------------------------*
*
*	This method returns the type of UI requested. It will return NULL if no UI
*	is requested.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CRecoCtxt::get_RequestedUIType( BSTR* pbstrUIType )
{
    SPDBG_FUNC( "CRecoCtxt::get_RequestedUIType" );
    HRESULT hr = S_OK;
	CSpDynamicString szType(m_Stat.szRequestTypeOfUI);

    if( SP_IS_BAD_WRITE_PTR( pbstrUIType ) )
    {
        hr = E_POINTER;
    }
    else
    {
		hr = szType.CopyToBSTR(pbstrUIType);
    }

    return hr;
} /* CRecoCtxt::get_RequestedUIType */


/*****************************************************************************
* CRecoCtxt::putref_Voice *
*------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::putref_Voice( ISpeechVoice *pVoice )
{
    SPDBG_FUNC( "CRecoCtxt::putref_Voice" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_INTERFACE_PTR( pVoice ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComQIPtr<ISpVoice> cpSpVoice(pVoice);
		hr = SetVoice(cpSpVoice, m_fAllowVoiceFormatChanges);
    }

    return hr;
} /* CRecoCtxt::putref_Voice */

/*****************************************************************************
* CRecoCtxt::get_Voice *
*------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CRecoCtxt::get_Voice( ISpeechVoice **ppVoice )
{
    SPDBG_FUNC( "CRecoCtxt::get_Voice" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppVoice ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpVoice> cpSpVoice;
		hr = GetVoice(&cpSpVoice);
		if ( SUCCEEDED( hr ) )
        {
			hr = cpSpVoice.QueryInterface( ppVoice );
        }
    }

    return hr;
} /* CRecoCtxt::get_Voice */


/*****************************************************************************
* CRecoCtxt::get_AllowVoiceFormatMatchingOnNextSet *
*----------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::put_AllowVoiceFormatMatchingOnNextSet( VARIANT_BOOL Allow )
{
    SPDBG_FUNC( "CRecoCtxt::put_AllowVoiceFormatMatchingOnNextSet" );
    // NOTE that this does not take effect till the next time you set the voice.
    if( Allow == VARIANT_TRUE )
    {
        m_fAllowVoiceFormatChanges = TRUE;
    }
    else
    {
        m_fAllowVoiceFormatChanges = FALSE;
    }

    return S_OK;
}


/*****************************************************************************
* CRecoCtxt::get_AllowVoiceFormatMatchingOnNextSet *
*----------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::get_AllowVoiceFormatMatchingOnNextSet( VARIANT_BOOL* pAllow )
{
    SPDBG_FUNC( "CRecoCtxt::get_AllowVoiceFormatMatchingOnNextSet" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pAllow ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pAllow = m_fAllowVoiceFormatChanges ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return hr;
}


/*****************************************************************************
* CRecoCtxt::put_VoicePurgeEvent *
*----------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::put_VoicePurgeEvent( SpeechRecoEvents VoicePurgeEvents )
{
    SPDBG_FUNC( "CRecoCtxt::put_VoicePurgeEvent" );
    HRESULT hr = S_OK;
    ULONGLONG   ullInterests = 0;

    ullInterests = (ULONGLONG)VoicePurgeEvents;
    ullInterests <<= 34;
    ullInterests |= SPFEI_FLAGCHECK;
    
    hr = SetVoicePurgeEvent( ullInterests );

    return hr;
} /* CRecoCtxt::put_VoicePurgeEvent */

/*****************************************************************************
* CRecoCtxt::get_VoicePurgeEvent *
*----------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::get_VoicePurgeEvent( SpeechRecoEvents* pVoicePurgeEvents )
{
    SPDBG_FUNC( "CRecoCtxt::get_VoicePurgeEvent" );
    HRESULT     hr = S_OK;
    ULONGLONG   ullInterests = 0;

    if ( SP_IS_BAD_WRITE_PTR( pVoicePurgeEvents ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetVoicePurgeEvent( &ullInterests );

        if ( SUCCEEDED( hr ) )
        {
            // Make sure reserved bit is not used
            ullInterests &= ~(1ui64 << SPEI_RESERVED3);

            ullInterests >>= 34;
            *pVoicePurgeEvents = (SpeechRecoEvents)ullInterests;
        }
    }

    return hr;
} /* CRecoCtxt::get_VoicePurgeEvent */


/*****************************************************************************
* CRecoCtxt::put_EventInterests *
*-------------------------------*
*       
********************************************************************* leonro ***/
STDMETHODIMP CRecoCtxt::put_EventInterests( SpeechRecoEvents RecoEventInterest )
{
    SPDBG_FUNC( "CRecoCtxt::put_EventInterests" );
    HRESULT hr = S_OK;
    ULONGLONG   ullInterests = 0;

    ullInterests = (ULONGLONG)RecoEventInterest;
    ullInterests <<= 34;

    ullInterests |= SPFEI_FLAGCHECK;
    
    hr = SetInterest( ullInterests, ullInterests );

    return hr;
} /* CRecoCtxt::put_EventInterests */


/*****************************************************************************
* CRecoCtxt::get_EventInterests *
*-------------------------------*
*       
*   Gets the event interests that are currently set on RecoContext. 
*
********************************************************************* Leonro ***/
STDMETHODIMP CRecoCtxt::get_EventInterests( SpeechRecoEvents* pRecoEventInterest )
{
    SPDBG_FUNC( "CRecoCtxt::get_EventInterests" );
    HRESULT hr = S_OK;
    ULONGLONG   ullInterests = 0;

    if( SP_IS_BAD_WRITE_PTR( pRecoEventInterest ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetInterests( &ullInterests, 0 );

        if( SUCCEEDED( hr ) )
        {
            // Make sure we removed the flag check bits.
            ullInterests &= ~SPFEI_FLAGCHECK;

            ullInterests >>= 34;
            *pRecoEventInterest = (SpeechRecoEvents)ullInterests;
        }
    }
    return hr;
} /* CRecoCtxt::get_EventInterests */


  
/*****************************************************************************
* CRecoCtxt::CreateGrammar *
*----------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CRecoCtxt::CreateGrammar( VARIANT GrammarId, ISpeechRecoGrammar** ppGrammar )
{
    SPDBG_FUNC( "CRecoCtxt::CreateGrammar" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppGrammar ) )
    {
        hr = E_POINTER;
    }
    else
    {
        ULONGLONG pull;
        hr = VariantToULongLong(&GrammarId, &pull);
        if(SUCCEEDED(hr))
        {
            CComPtr<ISpRecoGrammar> cpGrammar;
		    hr = CreateGrammar(pull, &cpGrammar);
		    if ( SUCCEEDED( hr ) )
		    {
			    hr = cpGrammar.QueryInterface( ppGrammar );
		    }
        }
    }

    return hr;
} /* CRecoCtxt::CreateGrammar */

/*****************************************************************************
* CRecoCtxt::CreateResultFromMemory *
*---------------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CRecoCtxt::CreateResultFromMemory( VARIANT* ResultBlock, ISpeechRecoResult **Result )
{
    SPDBG_FUNC( "CRecoCtxt::CreateResult" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_READ_PTR( ResultBlock ) )
    {
        hr = E_INVALIDARG;
    }
    else if( SP_IS_BAD_WRITE_PTR( Result ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpRecoResult>      cpSpRecoResult;
        SPSERIALIZEDRESULT*         pSerializedResult;

        hr = AccessVariantData( ResultBlock, (BYTE**)&pSerializedResult );

        if( SUCCEEDED( hr ) )
        {
            hr = DeserializeResult( pSerializedResult, &cpSpRecoResult );
            UnaccessVariantData( ResultBlock, (BYTE *)pSerializedResult );
        }

        if( SUCCEEDED( hr ) )
        {
            cpSpRecoResult.QueryInterface( Result );
        }
    }

    return hr;
} /* CRecoCtxt::CreateResult */

/*****************************************************************************
* CRecoCtxt::Pause *
*--------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CRecoCtxt::Pause( void )
{
    SPDBG_FUNC( "CRecoCtxt::Pause (Automation)" );

    return Pause( 0 );
} /* CRecoCtxt::Pause */

/*****************************************************************************
* CRecoCtxt::Resume *
*--------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CRecoCtxt::Resume( void )
{
    SPDBG_FUNC( "CRecoCtxt::Resume (Automation)" );

    return Resume( 0 );
} /* CRecoCtxt::Resume */

/*****************************************************************************
* CRecoCtxt::get_CmdMaxAlternates *
*--------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::get_CmdMaxAlternates( long * plMaxAlternates)
{
    SPDBG_FUNC( "CRecoCtxt::get_CmdMaxAlternates" );

	return GetMaxAlternates((ULONG*)plMaxAlternates);
} /* CRecoCtxt::get_CmdMaxAlternates */

/*****************************************************************************
* CRecoCtxt::put_CmdMaxAlternates *
*--------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::put_CmdMaxAlternates( long lMaxAlternates )
{
    SPDBG_FUNC( "CRecoCtxt::put_CmdMaxAlternates" );

    if (lMaxAlternates < 0)
    {
        return E_INVALIDARG;
    }
    else
    {
    	return SetMaxAlternates(lMaxAlternates);
    }
} /* CRecoCtxt::put_CmdMaxAlternates */


/*****************************************************************************
* CRecoCtxt::get_State *
*--------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::get_State( SpeechRecoContextState* pState)
{
    SPDBG_FUNC( "CRecoCtxt::get_State" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pState ) )
    {
        hr = E_POINTER;
    }
    else
    {
		hr = GetContextState((SPCONTEXTSTATE*)pState);
    }

    return hr;
} /* CRecoCtxt::get_State */

/*****************************************************************************
* CRecoCtxt::put_State *
*--------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::put_State( SpeechRecoContextState State )
{
    SPDBG_FUNC( "CRecoCtxt::put_State" );
    SPCONTEXTSTATE scs;

    return SetContextState( (SPCONTEXTSTATE)State );
} /* CRecoCtxt::put_State */

/*****************************************************************************
* CRecoCtxt::put_RetainedAudio *
*---------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::put_RetainedAudio( SpeechRetainedAudioOptions Option)
{
    SPDBG_FUNC( "CRecoCtxt::put_RetainedAudio" );
    HRESULT hr = S_OK;

    hr = SetAudioOptions( (SPAUDIOOPTIONS)Option, NULL, NULL );

    return hr;
} /* CRecoCtxt::put_RetainedAudio */

/*****************************************************************************
* CRecoCtxt::get_RetainedAudio *
*---------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::get_RetainedAudio( SpeechRetainedAudioOptions* pOption)
{
    SPDBG_FUNC( "CRecoCtxt::get_RetainedAudio" );
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pOption))
    {
        hr = E_POINTER;
    }
    else
    {
        *pOption = (SpeechRetainedAudioOptions)(m_fRetainAudio ? SPAO_RETAIN_AUDIO : SPAO_NONE);
    }

    return hr;
} /* CRecoCtxt::get_RetainedAudio */

/*****************************************************************************
* CRecoCtxt::putref_RetainedAudioFormat *
*---------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::putref_RetainedAudioFormat( ISpeechAudioFormat* pFormat )
{
    SPDBG_FUNC( "CRecoCtxt::putref_RetainedAudioFormat" );
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pFormat))
    {
        hr = E_INVALIDARG;
    }
    else if(pFormat == NULL)
    {
        hr = SetAudioOptions( (m_fRetainAudio ? SPAO_RETAIN_AUDIO : SPAO_NONE), &GUID_NULL, NULL );
    }
    else
    {
        GUID            g;
        CComBSTR        szGuid;

        hr = pFormat->get_Guid( &szGuid );

        if ( SUCCEEDED( hr ) )
        {
            hr = IIDFromString(szGuid, &g);
        }

        if ( SUCCEEDED( hr ) )
        {
            CComPtr<ISpeechWaveFormatEx> pWFEx;
            WAVEFORMATEX *  pWFExStruct = NULL;

            hr = pFormat->GetWaveFormatEx( &pWFEx );

            if ( SUCCEEDED( hr ) )
            {
                hr = WaveFormatExFromInterface( pWFEx, &pWFExStruct );

                if ( SUCCEEDED( hr ) )
                {
                    hr = SetAudioOptions( (m_fRetainAudio ? SPAO_RETAIN_AUDIO : SPAO_NONE), &g, pWFExStruct );
                }

                ::CoTaskMemFree( pWFExStruct );
            }
        }
    }

    return hr;
} /* CRecoCtxt::putref_RetainedAudioFormat */

/*****************************************************************************
* CRecoCtxt::get_RetainedAudioFormat *
*---------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::get_RetainedAudioFormat( ISpeechAudioFormat** ppFormat )
{
    SPDBG_FUNC( "CRecoCtxt::get_RetainedAudioFormat" );
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppFormat))
    {
        hr = E_POINTER;
    }
    else
    {
        // Create new object.
        CComObject<CSpeechAudioFormat> *pFormat;
        hr = CComObject<CSpeechAudioFormat>::CreateInstance( &pFormat );
        if ( SUCCEEDED( hr ) )
        {
            pFormat->AddRef();

            hr = pFormat->InitRetainedAudio(this);

            if ( SUCCEEDED( hr ) )
            {
                *ppFormat = pFormat;
            }
            else
            {
                *ppFormat = NULL;
                pFormat->Release();
            }
        }
    }

    return hr;
} /* CRecoCtxt::get_RetainedAudioFormat */

/*****************************************************************************
* CRecoCtxt::Bookmark *
*---------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::Bookmark( SpeechBookmarkOptions Options, VARIANT StreamPos, VARIANT EventData )
{
    SPDBG_FUNC( "CRecoCtxt::Bookmark" );
    HRESULT hr = S_OK;

    ULONGLONG ullStreamPos;

    //We allow -1 as the bookmark pos, this is used in SAPI COM object. Using VariantToULongLong won't work as -1 is negative.
    hr = VariantToLongLong( &StreamPos, ((LONGLONG *)&ullStreamPos) );

    if ( SUCCEEDED( hr ) ) 
    {
        LPARAM lParam = 0;

#ifdef _WIN64
        hr = VariantToULongLong( &EventData, (ULONGLONG*)&lParam );
#else
        ULONGLONG ull;
        hr = VariantToULongLong( &EventData, &ull );

        if ( SUCCEEDED( hr ) )
        {
            // Now see if we overflowed a 32 bit value.
            if ( ull & 0xFFFFFFFF00000000 )
            {
                hr = E_INVALIDARG;
            }
            else
            {
                lParam = (LPARAM)ull;
            }
        }
#endif

        if ( SUCCEEDED( hr ) )
        {
            hr = Bookmark( (SPBOOKMARKOPTIONS)Options, ullStreamPos, lParam);
        }
    }
    return hr;
} /* CRecoCtxt::Bookmark */


/*****************************************************************************
* CRecoCtxt::SetAdaptationData *
*--------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CRecoCtxt::SetAdaptationData( BSTR bstrAdaptationString )
{
    SPDBG_FUNC( "CRecoCtxt::SetAdaptationData" );

    if( SP_IS_BAD_OPTIONAL_STRING_PTR( bstrAdaptationString ) )
    {
        return E_INVALIDARG;
    }

    bstrAdaptationString = EmptyStringToNull(bstrAdaptationString);
    return SetAdaptationData( bstrAdaptationString, bstrAdaptationString ? lstrlenW(bstrAdaptationString) : 0 );
} /* CRecoCtxt::SetAdaptationData */


//
//=== ISpeechRecognizerStatus interface =============================================
//

/*****************************************************************************
* CSpeechRecognizerStatus::get_AudioStatus *
*---------------------------------------*
*
*	This method returns the ISpeechAudioStatus automation object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecognizerStatus::get_AudioStatus( ISpeechAudioStatus** AudioStatus )
{
    SPDBG_FUNC( "CSpeechRecognizerStatus::get_AudioStatus" );
    HRESULT hr = S_OK;
    
    if( SP_IS_BAD_WRITE_PTR( AudioStatus ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Create new CSpeechAudioStatus object.
        CComObject<CSpeechAudioStatus> *pStatus;
        hr = CComObject<CSpeechAudioStatus>::CreateInstance( &pStatus );
        if ( SUCCEEDED( hr ) )
        {
            pStatus->AddRef();
            pStatus->m_AudioStatus = m_Status.AudioStatus;
            *AudioStatus = pStatus;
        }
    }
    return hr;
} /* CSpeechRecognizerStatus::get_AudioStatus */

/*****************************************************************************
* CSpeechRecognizerStatus::get_CurrentStreamPosition *
*---------------------------------------*
*
*   This method returns the stream position the engine has currently recognized up 
*   to. Stream positions are measured in bytes. This value can be used to see how 
*   the engine is progressing through the audio data.
* 
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecognizerStatus::get_CurrentStreamPosition( VARIANT* pCurrentStreamPos )
{
    SPDBG_FUNC( "CSpeechRecognizerStatus::get_CurrentStreamPosition" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pCurrentStreamPos ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = ULongLongToVariant( m_Status.ullRecognitionStreamPos, pCurrentStreamPos );
    }
    return hr;
} /* CSpeechRecognizerStatus::get_CurrentStreamPosition */

/*****************************************************************************
* CSpeechRecognizerStatus::get_CurrentStreamNumber *
*---------------------------------------*
*       
*   This method returns the current stream. This value is incremented every time SAPI 
*   starts or stops recognition on an engine. Each time this happens the 
*   pCurrentStream gets reset to zero. Events fired from the engine have equivalent 
*   stream number and position information also. 
*
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecognizerStatus::get_CurrentStreamNumber( long* pCurrentStream )
{
    SPDBG_FUNC( "CSpeechRecognizerStatus::get_CurrentStreamNumber" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pCurrentStream ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pCurrentStream = m_Status.ulStreamNumber;
    }
    return hr;
} /* CSpeechRecognizerStatus::get_CurrentStreamNumber */

/*****************************************************************************
* CSpeechRecognizerStatus::get_NumberOfActiveRules *
*---------------------------------------*
*       
*   This method returns the current engine's number of active rules. 
*
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecognizerStatus::get_NumberOfActiveRules( long* pNumActiveRules )
{
    SPDBG_FUNC( "CSpeechRecognizerStatus::get_NumberOfActiveRules" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pNumActiveRules ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pNumActiveRules = m_Status.ulNumActive;
    }
    return hr;
} /* CSpeechRecognizerStatus::get_NumberOfActiveRules */

/*****************************************************************************
* CSpeechRecognizerStatus::get_ClsidEngine *
*---------------------------------------*
*       
*   This method returns the CSLID of the engine. 
*
********************************************************************* ToddT ***/
STDMETHODIMP CSpeechRecognizerStatus::get_ClsidEngine( BSTR* pbstrClsidEngine )
{
    SPDBG_FUNC( "CSpeechRecognizerStatus::get_ClsidEngine" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pbstrClsidEngine ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CSpDynamicString szGuid;

        hr = StringFromIID(m_Status.clsidEngine, &szGuid);
        if ( SUCCEEDED( hr ) )
        {
            hr = szGuid.CopyToBSTR(pbstrClsidEngine);
        }
    }
    return hr;
} /* CSpeechRecognizerStatus::get_ClsidEngine */

/*****************************************************************************
* CSpeechRecognizerStatus::get_SupportedLanguages *
*---------------------------------------*
*       
*   This method returns an array containing the languages the current engine supports. 
*
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechRecognizerStatus::get_SupportedLanguages( VARIANT* pSupportedLangs )
{
    SPDBG_FUNC( "CSpeechRecognizerStatus::get_SupportedLanguages" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pSupportedLangs ) )
    {
        hr = E_POINTER;
    }
    else
    {
		SAFEARRAY* psa = SafeArrayCreateVector( VT_I4, 0, m_Status.cLangIDs );
		
		if( psa )
        {
			long*		pArray;
			hr = SafeArrayAccessData( psa, (void**)&pArray);
            if( SUCCEEDED( hr ) )
            {
				// copy the LANGID's into the SAFEARRAY 
                for( LANGID i=0; i<m_Status.cLangIDs; i++ )
				{
					pArray[i] = (long)m_Status.aLangID[i];
				}
                SafeArrayUnaccessData( psa );
        		VariantClear( pSupportedLangs );
                pSupportedLangs->parray = psa;
        		pSupportedLangs->vt = VT_ARRAY | VT_I4;
            }
        }
		else
		{
			hr = E_OUTOFMEMORY;
		}
    }
    return hr;
} /* CSpeechRecognizerStatus::get_SupportedLanguages */


//
//=== CSpeechRecoResultTimes::ISpeechRecoResultTimes interface ===============================
//

/*****************************************************************************
* CSpeechRecoResultTimes::get_StreamTime *
*---------------------------------------*
*       
*   This method returns the current reco result stream time. 
*
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechRecoResultTimes::get_StreamTime( VARIANT* pTime )
{
    SPDBG_FUNC( "CSpeechRecoResultTimes::get_StreamTime" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pTime ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = ULongLongToVariant( FT64(m_ResultTimes.ftStreamTime), pTime );
    }
    return hr;
} /* CSpeechRecoResultTimes::get_NumActiveRules */

/*****************************************************************************
* CSpeechRecoResultTimes::get_Length *
*---------------------------------------*
*       
*   This method returns the current reco result stream length. 
*
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechRecoResultTimes::get_Length( VARIANT* pLength )
{
    SPDBG_FUNC( "CSpeechRecoResultTimes::get_Length" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pLength ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = ULongLongToVariant( m_ResultTimes.ullLength, pLength );
    }
    return hr;
} /* CSpeechRecoResultTimes::get_Length */

/*****************************************************************************
* CSpeechRecoResultTimes::get_TickCount *
*---------------------------------------*
*       
*   This method returns the current reco result stream tick count start. 
*
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechRecoResultTimes::get_TickCount( long* pTickCount )
{
    SPDBG_FUNC( "CSpeechRecoResultTimes::get_TickCount" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pTickCount ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pTickCount = m_ResultTimes.dwTickCount;
    }
    return hr;
} /* CSpeechRecoResultTimes::get_TickCount */

/*****************************************************************************
* CSpeechRecoResultTimes::get_OffsetFromStart *
*---------------------------------------*
*       
*   This method returns the current reco result stream tick count for the 
*   phrase start. 
*
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechRecoResultTimes::get_OffsetFromStart( VARIANT* pOffset )
{
    SPDBG_FUNC( "CSpeechRecoResultTimes::get_OffsetFromStart" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pOffset ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = ULongLongToVariant( m_ResultTimes.ullStart, pOffset );
    }
    return hr;
} /* CSpeechRecoResultTimes::get_OffsetFromStart */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_recocp.h ===
#ifndef _A_RECOCP_H_
#define _A_RECOCP_H_


template <class T>
class CProxy_ISpeechRecoContextEvents : public IConnectionPointImpl<T, &DIID__ISpeechRecoContextEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_StartStream(long StreamNumber, VARIANT StreamPosition)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[1] = StreamNumber;
                vars[0] = StreamPosition;
				DISPPARAMS disp = { &vars[0], NULL, 2, 0 };
				pDispatch->Invoke(DISPID_SRCEStartStream, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_EndStream(long StreamNumber, VARIANT StreamPosition, VARIANT_BOOL fStreamReleased)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[2] = StreamNumber;
                vars[1] = StreamPosition;
                vars[0] = fStreamReleased;
				DISPPARAMS disp = { &vars[0], NULL, 3, 0 };
				pDispatch->Invoke(DISPID_SRCEEndStream, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_Bookmark(long StreamNumber, VARIANT StreamPosition, VARIANT EventData, SpeechBookmarkOptions BookmarkOptions)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[3] = StreamNumber;
                vars[2] = StreamPosition;
				vars[1] = EventData;
                vars[0] = BookmarkOptions;
				DISPPARAMS disp = { &vars[0], NULL, 4, 0 };
				pDispatch->Invoke(DISPID_SRCEBookmark, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_SoundStart(long StreamNumber, VARIANT StreamPosition)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[1] = StreamNumber;
                vars[0] = StreamPosition;
				DISPPARAMS disp = { &vars[0], NULL, 2, 0 };
				pDispatch->Invoke(DISPID_SRCESoundStart, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_SoundEnd(long StreamNumber, VARIANT StreamPosition)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[1] = StreamNumber;
                vars[0] = StreamPosition;
				DISPPARAMS disp = { &vars[0], NULL, 2, 0 };
				pDispatch->Invoke(DISPID_SRCESoundEnd, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_PhraseStart(long StreamNumber, VARIANT StreamPosition)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[1] = StreamNumber;
                vars[0] = StreamPosition;
				DISPPARAMS disp = { &vars[0], NULL, 2, 0 };
				pDispatch->Invoke(DISPID_SRCEPhraseStart, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_Recognition(long StreamNumber, VARIANT StreamPosition, SpeechRecognitionType RecognitionType, ISpeechRecoResult * pResult)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[3] = StreamNumber;
                vars[2] = StreamPosition;
                vars[1] = RecognitionType;
				vars[0] = pResult;
				DISPPARAMS disp = { &vars[0], NULL, 4, 0 };
				pDispatch->Invoke(DISPID_SRCERecognition, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_Hypothesis(long StreamNumber, VARIANT StreamPosition, ISpeechRecoResult * pResult)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[2] = StreamNumber;
                vars[1] = StreamPosition;
				vars[0] = pResult;
				DISPPARAMS disp = { &vars[0], NULL, 3, 0 };
				pDispatch->Invoke(DISPID_SRCEHypothesis, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_PropertyNumberChange(long StreamNumber, VARIANT StreamPosition, BSTR PropertyName, long NewNumberValue)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[3] = StreamNumber;
                vars[2] = StreamPosition;
                vars[1] = PropertyName;
                vars[0] = NewNumberValue;
				DISPPARAMS disp = { &vars[0], NULL, 4, 0 };
				pDispatch->Invoke(DISPID_SRCEPropertyNumberChange, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_PropertyStringChange(long StreamNumber, VARIANT StreamPosition, BSTR PropertyName, BSTR NewStringValue)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
                vars[3] = StreamNumber;
                vars[2] = StreamPosition;
                vars[1] = PropertyName;
				vars[0] = NewStringValue;
				DISPPARAMS disp = { &vars[0], NULL, 4, 0 };
				pDispatch->Invoke(DISPID_SRCEPropertyStringChange, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_FalseRecognition(long StreamNumber, VARIANT StreamPosition, ISpeechRecoResult * pResult)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[2] = StreamNumber;
                vars[1] = StreamPosition;
				vars[0] = pResult;
				DISPPARAMS disp = { &vars[0], NULL, 3, 0 };
				pDispatch->Invoke(DISPID_SRCEFalseRecognition, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_Interference(long StreamNumber, VARIANT StreamPosition, SpeechInterference eType)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[2] = StreamNumber;
                vars[1] = StreamPosition;
				vars[0] = eType;
				DISPPARAMS disp = { &vars[0], NULL, 3, 0 };
				pDispatch->Invoke(DISPID_SRCEInterference, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_RequestUI(long StreamNumber, VARIANT StreamPosition, BSTR bstrType)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[2] = StreamNumber;
                vars[1] = StreamPosition;
				vars[0] = bstrType;
				DISPPARAMS disp = { &vars[0], NULL, 3, 0 };
				pDispatch->Invoke(DISPID_SRCERequestUI, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_RecognizerStateChange(long StreamNumber, VARIANT StreamPosition, SpeechRecognizerState NewState)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
                vars[2] = StreamNumber;
                vars[1] = StreamPosition;
				vars[0] = NewState;
				DISPPARAMS disp = { &vars[0], NULL, 3, 0 };
				pDispatch->Invoke(DISPID_SRCERecognizerStateChange, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_Adaptation(long StreamNumber, VARIANT StreamPosition)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[1] = StreamNumber;
                vars[0] = StreamPosition;
				DISPPARAMS disp = { &vars[0], NULL, 2, 0 };
				pDispatch->Invoke(DISPID_SRCEAdaptation, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_RecognitionForOtherContext(long StreamNumber, VARIANT StreamPosition)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[1] = StreamNumber;
                vars[0] = StreamPosition;
				DISPPARAMS disp = { &vars[0], NULL, 2, 0 };
				pDispatch->Invoke(DISPID_SRCERecognitionForOtherContext, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_AudioLevel(long StreamNumber, VARIANT StreamPosition, long AudioLevel)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[2] = StreamNumber;
                vars[1] = StreamPosition;
                vars[0] = AudioLevel;
				DISPPARAMS disp = { &vars[0], NULL, 3, 0 };
				pDispatch->Invoke(DISPID_SRCEAudioLevel, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_EnginePrivate(long StreamNumber, VARIANT StreamPosition, VARIANT lParam)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[2] = StreamNumber;
                vars[1] = StreamPosition;
                vars[0] = lParam;
				DISPPARAMS disp = { &vars[0], NULL, 3, 0 };
				pDispatch->Invoke(DISPID_SRCEEnginePrivate, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_recoei.h ===
/*******************************************************************************
* a_recoei.h *
*-----------*
*   Description:
*       This is the header file for the CSpeechRecoEventInterests implementation.
*-------------------------------------------------------------------------------
*  Created By: Leonro                            Date: 11/20/00
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef a_recoei_h
#define a_recoei_h

#ifdef SAPI_AUTOMATION

//--- Additional includes
#include "resource.h"
#include "RecoCtxt.h"

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================
class CSpeechRecoEventInterests;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CSpeechRecoEventInterests
*   This object is used to access the Event interests on
*   the associated Reco Context.
*/
class ATL_NO_VTABLE CSpeechRecoEventInterests : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ISpeechRecoEventInterests, &IID_ISpeechRecoEventInterests, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechRecoEventInterests)
	    COM_INTERFACE_ENTRY(ISpeechRecoEventInterests)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()
  
  /*=== Interfaces ====*/
  public:
    //--- Constructors/Destructors ----------------------------
    CSpeechRecoEventInterests() :
        m_pCRecoCtxt(0){}

    void FinalRelease();

    //--- ISpeechRecoEventInterests ----------------------------------
    STDMETHOD(put_StreamEnd)( VARIANT_BOOL Enabled );
    STDMETHOD(get_StreamEnd)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_SoundStart)( VARIANT_BOOL Enabled );
    STDMETHOD(get_SoundStart)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_SoundEnd)( VARIANT_BOOL Enabled );
    STDMETHOD(get_SoundEnd)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_PhraseStart)( VARIANT_BOOL Enabled );
    STDMETHOD(get_PhraseStart)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_Recognition)( VARIANT_BOOL Enabled );
    STDMETHOD(get_Recognition)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_Hypothesis)( VARIANT_BOOL Enabled );
    STDMETHOD(get_Hypothesis)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_Bookmark)( VARIANT_BOOL Enabled );
    STDMETHOD(get_Bookmark)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_PropertyNumChange)( VARIANT_BOOL Enabled );
    STDMETHOD(get_PropertyNumChange)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_PropertyStringChange)( VARIANT_BOOL Enabled );
    STDMETHOD(get_PropertyStringChange)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_FalseRecognition)( VARIANT_BOOL Enabled );
    STDMETHOD(get_FalseRecognition)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_Interference)( VARIANT_BOOL Enabled );
    STDMETHOD(get_Interference)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_RequestUI)( VARIANT_BOOL Enabled );
    STDMETHOD(get_RequestUI)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_StateChange)( VARIANT_BOOL Enabled );
    STDMETHOD(get_StateChange)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_Adaptation)( VARIANT_BOOL Enabled );
    STDMETHOD(get_Adaptation)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_StreamStart)( VARIANT_BOOL Enabled );
    STDMETHOD(get_StreamStart)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_OtherContext)( VARIANT_BOOL Enabled );
    STDMETHOD(get_OtherContext)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_AudioLevel)( VARIANT_BOOL Enabled );
    STDMETHOD(get_AudioLevel)( VARIANT_BOOL* Enabled );
    STDMETHOD(SetAll)();
    STDMETHOD(ClearAll)();

  /*=== Member Data ===*/
    CRecoCtxt*             m_pCRecoCtxt;
};

#endif // SAPI_AUTOMATION

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_regdatakey.cpp ===
/*******************************************************************************
* a_regdatakey.cpp *
*-------------*
*   Description:
*       This module is the main implementation file for the CSpObjectTokenEnumBuilder
*   and CSpRegistryObjectToken automation methods.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 01/07/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
//#include "ObjectToken.h"
//#include "ObjectTokenEnumBuilder.h"
#include "RegDataKey.h"
#include "a_helpers.h"

#ifdef SAPI_AUTOMATION

//
//=== ISpeechDataKey interface ===============================================
//

/*****************************************************************************
* CSpRegDataKey::SetBinaryValue *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpRegDataKey::SetBinaryValue( const BSTR bstrValueName, VARIANT pvtData )
{
    SPDBG_FUNC( "CSpRegDataKey::SetValue" );
    HRESULT     hr = S_OK;
    BYTE *      pArray;
    ULONG       ulCount;
    bool        fIsString = false;

    hr = AccessVariantData( &pvtData, &pArray, &ulCount, NULL, &fIsString );

    if ( SUCCEEDED( hr ) )
    {
        if ( !fIsString )
        {
            hr = SetData( EmptyStringToNull(bstrValueName), ulCount, pArray );
        }
        else
        {
            hr = E_INVALIDARG; // We don't allow strings.  Use SetStringValue for those.
        }
        UnaccessVariantData( &pvtData, pArray );
    }
    
    return hr;
} /* CSpRegDataKey::SetBinaryValue */

/*****************************************************************************
* CSpRegDataKey::GetBinaryValue *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpRegDataKey::GetBinaryValue( const BSTR bstrValueName, VARIANT* pvtData )
{
    SPDBG_FUNC( "CSpRegDataKey::GetBinaryValue" );
    HRESULT hr = S_OK;

    DWORD dwSize = 0;
    hr = GetData( EmptyStringToNull(bstrValueName), &dwSize, NULL );

    if( SUCCEEDED( hr ) )
    {
        BYTE *pArray;
        SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, dwSize );
        if( psa )
        {
            if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
            {
                hr = GetData( bstrValueName, &dwSize, pArray );
                SafeArrayUnaccessData( psa );
                VariantClear(pvtData);
                pvtData->vt     = VT_ARRAY | VT_UI1;
                pvtData->parray = psa;

                if ( !SUCCEEDED( hr ) )
                {
                    VariantClear( pvtData );
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
} /* CSpRegDataKey::GetBinaryValue */

/*****************************************************************************
* CSpRegDataKey::SetStringValue *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpRegDataKey::SetStringValue( const BSTR bstrValueName, const BSTR szString )
{
    SPDBG_FUNC( "CSpRegDataKey::SetStringValue" );

    return SetStringValue( (const WCHAR *)EmptyStringToNull(bstrValueName), (const WCHAR *)szString );
} /* CSpRegDataKey::SetStringValue */

/*****************************************************************************
* CSpRegDataKey::GetStringValue *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpRegDataKey::GetStringValue( const BSTR bstrValueName,  BSTR * szString )
{
    SPDBG_FUNC( "CSpRegDataKey::GetStringValue" );
    HRESULT hr = S_OK;

    CSpDynamicString pStr;
    hr = GetStringValue( (const WCHAR *)EmptyStringToNull(bstrValueName), (WCHAR**)&pStr );

    if( SUCCEEDED( hr ) )
    {
        hr = pStr.CopyToBSTR(szString);
    }

    return hr;
} /* CSpRegDataKey::GetStringValue */

/*****************************************************************************
* CSpRegDataKey::SetLongValue *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpRegDataKey::SetLongValue( const BSTR bstrValueName, long Long )
{
    SPDBG_FUNC( "CSpRegDataKey::SetLongValue" );
   
    return SetDWORD( EmptyStringToNull(bstrValueName), (DWORD)Long );
} /* CSpRegDataKey::SetLongValue */

/*****************************************************************************
* CSpRegDataKey::GetLongValue *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpRegDataKey::GetLongValue( const BSTR bstrValueName, long* pLong )
{
    SPDBG_FUNC( "CSpRegDataKey::GetLongValue" );

    return GetDWORD( EmptyStringToNull(bstrValueName), (DWORD*)pLong );
} /* CSpRegDataKey::GetLongValue */


/*****************************************************************************
* CSpRegDataKey::OpenKey *
*-------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpRegDataKey::OpenKey( const BSTR bstrSubKeyName, ISpeechDataKey** ppSubKey )
{
    SPDBG_FUNC( "CSpRegDataKey::OpenKey" );
    CComPtr<ISpDataKey> cpKey;
    HRESULT hr = OpenKey( bstrSubKeyName, &cpKey );
    if( SUCCEEDED( hr ) )
    {
        cpKey.QueryInterface( ppSubKey );
    }
    return hr;
} /* CSpRegDataKey::OpenKey */

/*****************************************************************************
* CSpRegDataKey::CreateKey *
*---------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpRegDataKey::CreateKey( const BSTR bstrSubKeyName, ISpeechDataKey** ppSubKey )
{
    SPDBG_FUNC( "CSpRegDataKey::CreateKey" );
    CComPtr<ISpDataKey> cpKey;
    HRESULT hr = CreateKey( bstrSubKeyName, &cpKey );
    if( SUCCEEDED( hr ) )
    {
        cpKey.QueryInterface( ppSubKey );
    }
    return hr;
} /* CSpRegDataKey::CreateKey */

/*****************************************************************************
* CSpRegDataKey::DeleteKey *
*---------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpRegDataKey::DeleteKey( const BSTR bstrSubKeyName )
{
    SPDBG_FUNC( "CSpRegDataKey::DeleteKey" );
    return DeleteKey( (const WCHAR*)bstrSubKeyName );
} /* CSpRegDataKey::DeleteKey */

/*****************************************************************************
* CSpRegDataKey::DeleteValue *
*-----------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpRegDataKey::DeleteValue( const BSTR bstrValueName )
{
    SPDBG_FUNC( "CSpRegDataKey::DeleteValue" );
    return DeleteValue( (const WCHAR*)EmptyStringToNull(bstrValueName) );
} /* CSpRegDataKey::DeleteValue */

/*****************************************************************************
* CSpRegDataKey::EnumKeys *
*--------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpRegDataKey::EnumKeys( long Index, BSTR* pbstrSubKeyName )
{
    SPDBG_FUNC( "CSpRegDataKey::EnumKeys (automation)" );
    CSpDynamicString szName;
    HRESULT hr = EnumKeys( (ULONG)Index, &szName );
    if( hr == S_OK )
    {
        hr = szName.CopyToBSTR(pbstrSubKeyName);
    }

    return hr;
} /* CSpRegDataKey::EnumKeys */

/*****************************************************************************
* CSpRegDataKey::EnumValues *
*----------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpRegDataKey::EnumValues( long Index, BSTR* pbstrValueName )
{
    SPDBG_FUNC( "CSpRegDataKey::EnumValues (automation)" );
    CSpDynamicString szName;
    HRESULT hr = EnumValues( (ULONG)Index, &szName );
    if( hr == S_OK )
    {
        hr = szName.CopyToBSTR(pbstrValueName);
    }

    return hr;
} /* CSpRegDataKey::EnumValues */

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_resmgr.cpp ===
/*******************************************************************************
* a_resmgr.cpp *
*--------------*
*   Description:
*       This module is the main implementation file for the CSpObjectTokenCategory.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 01/12/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "objecttokencategory.h"

#ifdef SAPI_AUTOMATION


//
//=== ISpeechObjectTokenCategory interface ========================================
//

/*****************************************************************************
* CSpObjectTokenCategory::EnumumerateTokens *
*--------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectTokenCategory::EnumerateTokens( BSTR bstrReqAttrs,
												 BSTR bstrOptAttrs,
												 ISpeechObjectTokens** ppColl )
{
    SPDBG_FUNC( "CSpObjectTokenCategory::EnumerateTokens" );
    CComPtr<IEnumSpObjectTokens> cpEnum;
    HRESULT hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_STRING_PTR( bstrReqAttrs ) ||
        SP_IS_BAD_OPTIONAL_STRING_PTR( bstrOptAttrs ) )
    {
        hr = E_INVALIDARG;
    }
    else if( SP_IS_BAD_WRITE_PTR( ppColl ) )
    {
        hr = E_POINTER;
    }
    else
    {
		hr = EnumTokens( (bstrReqAttrs && (*bstrReqAttrs))?(bstrReqAttrs):(NULL),
									 (bstrOptAttrs && (*bstrOptAttrs))?(bstrOptAttrs):(NULL),
									  &cpEnum );

        if( SUCCEEDED( hr ) )
        {
            hr = cpEnum.QueryInterface( ppColl );
        }
    }

    return hr;
} /* CSpObjectTokenCategory::EnumerateTokens */

/*****************************************************************************
* CSpObjectTokenCategory::SetId *
*------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectTokenCategory::SetId( const BSTR bstrCategoryId, VARIANT_BOOL fCreateIfNotExist )
{
    SPDBG_FUNC( "CSpObjectTokenCategory::SetId" );
    return SetId( (WCHAR *)bstrCategoryId, (BOOL)(!fCreateIfNotExist ? false : true) );
} /* CSpObjectTokenCategory::SetId */


/*****************************************************************************
* CSpObjectTokenCategory::get_Id *
*------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectTokenCategory::get_Id( BSTR * pbstrCategoryId )
{
    SPDBG_FUNC( "CSpObjectTokenCategory::get_Id" );
    CSpDynamicString szCategory;
    HRESULT hr = GetId( &szCategory );
    if( hr == S_OK )
    {
        hr = szCategory.CopyToBSTR(pbstrCategoryId);
    }
	return hr;
} /* CSpObjectTokenCategory::get_Id */


/*****************************************************************************
* CSpObjectTokenCategory::GetDataKey *
*------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectTokenCategory::GetDataKey( SpeechDataKeyLocation Location, ISpeechDataKey ** ppDataKey )
{
    SPDBG_FUNC( "CSpObjectTokenCategory::GetDataKey" );
    CComPtr<ISpDataKey> cpKey;
    HRESULT hr = GetDataKey( (SPDATAKEYLOCATION)Location, &cpKey );
    if( SUCCEEDED( hr ) )
    {
        cpKey.QueryInterface( ppDataKey );
    }
	return hr;
} /* CSpObjectTokenCategory::GetDataKey */

/*****************************************************************************
* CSpObjectTokenCategory::put_DefaultTokenId *
*--------------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectTokenCategory::put_Default( const BSTR bstrTokenId )
{
    SPDBG_FUNC( "CSpObjectTokenCategory::put_Default" );
    return SetDefaultTokenId( (WCHAR *)bstrTokenId );
} /* CSpObjectTokenCategory::put_Default */

/*****************************************************************************
* CSpObjectTokenCategory::get_Default *
*--------------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectTokenCategory::get_Default( BSTR * pbstrTokenId )
{
    SPDBG_FUNC( "CSpObjectTokenCategory::get_Default" );
    CSpDynamicString szTokenId;
    HRESULT hr = GetDefaultTokenId( &szTokenId );
    if( hr == S_OK )
    {
        hr = szTokenId.CopyToBSTR(pbstrTokenId);
    }
	return hr;

} /* CSpObjectTokenCategory::get_Default */

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_txtsel.cpp ===
/*******************************************************************************
* a_txtsel.cpp *
*-------------*
*   Description:
*       This module is the main implementation file for the CSpTextSelectionInformation
*   automation methods.
*-------------------------------------------------------------------------------
*  Created By: Leonro                                        Date: 1/16/01
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "a_txtsel.h"

#ifdef SAPI_AUTOMATION
 


//
//=== ICSpTextSelectionInformation interface ==================================================
// 

/*****************************************************************************
* CSpTextSelectionInformation::put_ActiveOffset *
*----------------------------------*
*
*   This method sets the count of characters from the start of the WordSequenceData 
*   buffer. The word containing the character pointed to is the first word of the 
*   active text selection buffer. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpTextSelectionInformation::put_ActiveOffset( long ActiveOffset )
{
    SPDBG_FUNC( "CSpTextSelectionInformation::put_ActiveOffset" );
    HRESULT		hr = S_OK;

    m_ulStartActiveOffset = ActiveOffset;

	return hr;
} /* CSpTextSelectionInformation::put_ActiveOffset */

/*****************************************************************************
* CSpTextSelectionInformation::get_ActiveOffset *
*----------------------------------*
*      
*   This method gets the count of characters from the start of the WordSequenceData 
*   buffer. The word containing the character pointed to is the first word of the 
*   active text selection buffer. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpTextSelectionInformation::get_ActiveOffset( long* ActiveOffset )
{
    SPDBG_FUNC( "CSpTextSelectionInformation::get_ActiveOffset" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( ActiveOffset ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ActiveOffset = m_ulStartActiveOffset;
    }

    return hr;
} /* CSpTextSelectionInformation::get_ActiveOffset */

/*****************************************************************************
* CSpTextSelectionInformation::put_ActiveLength *
*----------------------------------*
*
*   This method sets the count of characters for the active range 
*   of the text selection buffer. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpTextSelectionInformation::put_ActiveLength( long ActiveLength )
{
    SPDBG_FUNC( "CSpTextSelectionInformation::put_ActiveLength" );
    HRESULT		hr = S_OK;

    m_cchActiveChars = ActiveLength;

	return hr;
} /* CSpTextSelectionInformation::put_ActiveLength */

/*****************************************************************************
* CSpTextSelectionInformation::get_ActiveLength *
*----------------------------------*
*      
*   This method gets the count of characters for the active range 
*   of the text selection buffer. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpTextSelectionInformation::get_ActiveLength( long* ActiveLength )
{
    SPDBG_FUNC( "CSpTextSelectionInformation::get_ActiveLength" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( ActiveLength ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ActiveLength = m_cchActiveChars;
    }

    return hr;
} /* CSpTextSelectionInformation::get_ActiveLength */

/*****************************************************************************
* CSpTextSelectionInformation::put_SelectionOffset *
*----------------------------------*
*
*   This method sets the start of the selected text (e.g., the user is selecting 
*   part of the previously dictated text that he/she is going to edit or correct).
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpTextSelectionInformation::put_SelectionOffset( long SelectionOffset )
{
    SPDBG_FUNC( "CSpTextSelectionInformation::put_SelectionOffset" );
    HRESULT		hr = S_OK;

    m_ulStartSelection = SelectionOffset;

	return hr;
} /* CSpTextSelectionInformation::put_SelectionOffset */

/*****************************************************************************
* CSpTextSelectionInformation::get_SelectionOffset *
*----------------------------------*
*      
*   This method gets the start of the selected text (e.g., the user is selecting 
*   part of the previously dictated text that he/she is going to edit or correct).
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpTextSelectionInformation::get_SelectionOffset( long* SelectionOffset )
{
    SPDBG_FUNC( "CSpTextSelectionInformation::get_SelectionOffset" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( SelectionOffset ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *SelectionOffset = m_ulStartSelection;
    }

    return hr;
} /* CSpTextSelectionInformation::get_SelectionOffset */

/*****************************************************************************
* CSpTextSelectionInformation::put_SelectionLength *
*----------------------------------*
*
*   This method sets the count of characters of the user selection. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpTextSelectionInformation::put_SelectionLength( long SelectionLength )
{
    SPDBG_FUNC( "CSpTextSelectionInformation::put_SelectionLength" );
    HRESULT		hr = S_OK;

    m_cchSelection = SelectionLength;

	return hr;
} /* CSpTextSelectionInformation::put_SelectionLength */

/*****************************************************************************
* CSpTextSelectionInformation::get_SelectionLength *
*----------------------------------*
*      
*   This method gets the count of characters of the user selection. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpTextSelectionInformation::get_SelectionLength( long* SelectionLength )
{
    SPDBG_FUNC( "CSpTextSelectionInformation::get_SelectionLength" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( SelectionLength ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *SelectionLength = m_cchSelection;
    }

    return hr;
} /* CSpTextSelectionInformation::get_SelectionLength */

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_stream.cpp ===
/*******************************************************************************
* a_stream.cpp *
*--------------*
*   Description:
*       This module is the main implementation file for the CWavStream class.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 09/30/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "wavstream.h"
#include "a_helpers.h"

#ifdef SAPI_AUTOMATION


//
//=== ISpeechAudioFormat =====================================================
//

/*****************************************************************************
* CSpeechWavAudioFormat::get_Type *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWavAudioFormat::get_Type( SpeechAudioFormatType* pAudioFormatType )
{
    SPDBG_FUNC( "CSpeechWavAudioFormat::get_Type" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pAudioFormatType ) )
    {
        hr = E_POINTER;
    }
    else
    {
        GUID guid;
        WAVEFORMATEX *pWaveFormat;
        hr = m_cpStreamAccess->_GetFormat(&guid, &pWaveFormat);

        if(SUCCEEDED(hr))
        {
            CSpStreamFormat Format;
            hr = Format.AssignFormat(guid, pWaveFormat);
            if(SUCCEEDED(hr))
            {
                ::CoTaskMemFree(pWaveFormat);
                *pAudioFormatType = (SpeechAudioFormatType)Format.ComputeFormatEnum();
            }
        }
    }
    
    return hr;
} /* CSpeechWavAudioFormat::get_Type */

/*****************************************************************************
* CSpeechWavAudioFormat::put_Type *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWavAudioFormat::put_Type( SpeechAudioFormatType AudioFormatType )
{
    SPDBG_FUNC( "CSpeechWavAudioFormat::put_Type" );
    HRESULT hr = S_OK;

    CSpStreamFormat Format((SPSTREAMFORMAT)AudioFormatType, &hr);

    if(SUCCEEDED(hr))
    {
        hr = m_cpStreamAccess->SetFormat(Format.FormatId(), Format.WaveFormatExPtr());
    }

    return hr;
} /* CSpeechWavAudioFormat::put_Type */

/*****************************************************************************
* CSpeechWavAudioFormat::get_Guid *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWavAudioFormat::get_Guid( BSTR* pGuid )
{
    SPDBG_FUNC( "CSpeechWavAudioFormat::get_Guid" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pGuid ) )
    {
        hr = E_POINTER;
    }
    else
    {
        GUID guid;
        WAVEFORMATEX *pWaveFormat;
        hr = m_cpStreamAccess->_GetFormat(&guid, &pWaveFormat);

        CSpDynamicString szGuid;
        if ( SUCCEEDED( hr ) )
        {
            hr = StringFromIID(guid, &szGuid);
            ::CoTaskMemFree(pWaveFormat);
        }

        if ( SUCCEEDED( hr ) )
        {
            hr = szGuid.CopyToBSTR(pGuid);
        }
    }
    
    return hr;
} /* CSpeechWavAudioFormat::get_Guid */

/*****************************************************************************
* CSpeechWavAudioFormat::put_Guid *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWavAudioFormat::put_Guid( BSTR szGuid )
{
    SPDBG_FUNC( "CSpeechWavAudioFormat::put_Guid" );
    HRESULT hr = S_OK;

    GUID oldGuid, newGuid;
    WAVEFORMATEX *pWaveFormat;
    hr = m_cpStreamAccess->_GetFormat(&oldGuid, &pWaveFormat);

    if(SUCCEEDED(hr))
    {
        hr = IIDFromString(szGuid, &newGuid);
    }

    if ( SUCCEEDED( hr ) )
    {
        // Don't change anything if the same in case both wav format
        if(oldGuid != newGuid)
        {
            hr = m_cpStreamAccess->SetFormat(newGuid, NULL);
        }
    }

    return hr;
} /* CSpeechWavAudioFormat::put_Guid */

/*****************************************************************************
* CSpeechWavAudioFormat::GetWaveFormatEx *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWavAudioFormat::GetWaveFormatEx( ISpeechWaveFormatEx** ppWaveFormatEx )
{
    SPDBG_FUNC( "CSpeechWavAudioFormat::GetWaveFormatEx" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppWaveFormatEx ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Create new object.
        CComObject<CSpeechWaveFormatEx> *pWaveFormatEx;
        hr = CComObject<CSpeechWaveFormatEx>::CreateInstance( &pWaveFormatEx );
        if ( SUCCEEDED( hr ) )
        {
            pWaveFormatEx->AddRef();

            GUID guid;
            WAVEFORMATEX *pWaveFormat;

            hr = m_cpStreamAccess->_GetFormat(&guid, &pWaveFormat);

            if(SUCCEEDED(hr))
            {
                hr = pWaveFormatEx->InitFormat(pWaveFormat);
                ::CoTaskMemFree(pWaveFormat);
            }

            if ( SUCCEEDED( hr ) )
            {
                *ppWaveFormatEx = pWaveFormatEx;
            }
            else
            {
                *ppWaveFormatEx = NULL;
                pWaveFormatEx->Release();
            }
        }
    }
    
    return hr;
} /* CSpeechWavAudioFormat::GetWaveFormatEx */

/*****************************************************************************
* CSpeechWavAudioFormat::SetWaveFormatEx *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechWavAudioFormat::SetWaveFormatEx( ISpeechWaveFormatEx* pWaveFormatEx )
{
    SPDBG_FUNC( "CSpeechWavAudioFormat::SetWaveFormatEx" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_INTERFACE_PTR( pWaveFormatEx ) )
    {
        hr = E_POINTER;
    }
    else
    {
        WAVEFORMATEX * pWFStruct =  NULL;
        hr = WaveFormatExFromInterface( pWaveFormatEx, &pWFStruct );

        if ( SUCCEEDED( hr ) )
        {
            hr = m_cpStreamAccess->SetFormat(SPDFID_WaveFormatEx, pWFStruct);
            ::CoTaskMemFree( pWFStruct );
        }
    }
    
    return hr;
} /* CSpeechWavAudioFormat::SetWaveFormatEx */


#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_spresult.cpp ===
/*******************************************************************************
* a_spresult.cpp *
*-------------*
*   Description:
*       This module is the implementation file for the the CSpResult
*   automation methods.
*-------------------------------------------------------------------------------
*  Created By: TODDT                                        Date: 11/09/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "spresult.h"
#include "a_reco.h"
#include "a_enums.h"
#include "SpPhraseAlt.h"
#include "a_helpers.h"

#ifdef SAPI_AUTOMATION

//
//=== ISpeechRecoResult interface ==================================================
//

/*****************************************************************************
* CSpResult::get_RecoContext *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpResult::get_RecoContext( ISpeechRecoContext** ppRecoContext )
{
    SPDBG_FUNC( "CSpResult::get_RecoContext" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppRecoContext ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComQIPtr<ISpRecoContext> cpRecoContext;
		hr = GetRecoContext( &cpRecoContext );
		if ( SUCCEEDED( hr ) )
		{
            hr = cpRecoContext.QueryInterface( ppRecoContext );
		}
    }

    return hr;
} /* CSpResult::get_RecoContext */


/*****************************************************************************
* CSpResult::get_Times *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpResult::get_Times( ISpeechRecoResultTimes** ppTimes )
{
    SPDBG_FUNC( "CSpResult::get_Times" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppTimes ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Create the ResultTimes object
        CComObject<CSpeechRecoResultTimes> *pResultTimes;
        hr = CComObject<CSpeechRecoResultTimes>::CreateInstance( &pResultTimes );
        if( SUCCEEDED( hr ) )
        {
            pResultTimes->AddRef();
            hr = GetResultTimes( &pResultTimes->m_ResultTimes );

            if( SUCCEEDED( hr ) )
            {
                *ppTimes = pResultTimes;
            }
            else
            {
                pResultTimes->Release();
            }
        }
    }

    return hr;
} /* CSpResult::get_Times */

/*****************************************************************************
* CSpResult::putref_AudioFormat *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpResult::putref_AudioFormat( ISpeechAudioFormat* pFormat )
{
    SPDBG_FUNC( "CSpResult::putref_AudioFormat" );
    HRESULT hr = S_OK;

    if (SP_IS_BAD_INTERFACE_PTR(pFormat))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        GUID            g;
        CComBSTR        szGuid;

        hr = pFormat->get_Guid( &szGuid );

        if ( SUCCEEDED( hr ) )
        {
            hr = IIDFromString(szGuid, &g);
        }

        if ( SUCCEEDED( hr ) )
        {
            CComPtr<ISpeechWaveFormatEx> pWFEx;
            WAVEFORMATEX *  pWFExStruct = NULL;

            hr = pFormat->GetWaveFormatEx( &pWFEx );

            if ( SUCCEEDED( hr ) )
            {
                hr = WaveFormatExFromInterface( pWFEx, &pWFExStruct );

                if ( SUCCEEDED( hr ) )
                {
                    hr = ScaleAudio(&g, pWFExStruct);
                }

                ::CoTaskMemFree( pWFExStruct );
            }
        }
    }

    return hr;
} /* CSpResult::putref_AudioFormat */

/*****************************************************************************
* CSpResult::get_AudioFormat *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpResult::get_AudioFormat( ISpeechAudioFormat** ppFormat )
{
    SPDBG_FUNC( "CSpResult::get_AudioFormat" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppFormat ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Create new object.
        CComObject<CSpeechAudioFormat> *pFormat;
        hr = CComObject<CSpeechAudioFormat>::CreateInstance( &pFormat );
        if ( SUCCEEDED( hr ) )
        {
            pFormat->AddRef();
            hr = pFormat->InitResultAudio(this);

            if ( SUCCEEDED( hr ) )
            {
                *ppFormat = pFormat;
            }
            else
            {
                *ppFormat = NULL;
                pFormat->Release();
            }
        }
    }

    return hr;
} /* CSpResult::get_AudioFormat */

/*****************************************************************************
* CSpResult::Alternates *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpResult::Alternates( long lRequestCount, long lStartElement, 
                                    long cElements, ISpeechPhraseAlternates** ppAlternates )
{
    SPDBG_FUNC( "CSpResult::Alternates" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppAlternates ) )
    {
        hr = E_POINTER;
    }
    else if( lRequestCount < 0 || 
        lStartElement < SPPR_ALL_ELEMENTS || 
        cElements < SPPR_ALL_ELEMENTS)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        ISpPhraseAlt **  rgIPhraseAlts;
        ULONG            cAltsReturned;

        *ppAlternates = NULL;
         
        rgIPhraseAlts = (ISpPhraseAlt**)CoTaskMemAlloc( lRequestCount * sizeof(ISpeechPhraseAlternate*) );

        if ( rgIPhraseAlts )
        {
            hr = GetAlternates( lStartElement, cElements, lRequestCount, rgIPhraseAlts, &cAltsReturned );

            if ( SUCCEEDED( hr ) && (cAltsReturned > 0) )
            {
                //--- Create the PhraseAlternates object
                CComObject<CSpeechPhraseAlternates> *pPhraseAlts;
                hr = CComObject<CSpeechPhraseAlternates>::CreateInstance( &pPhraseAlts );
                if ( SUCCEEDED( hr ) )
                {
                    pPhraseAlts->AddRef();
                    pPhraseAlts->m_cpResult = (ISpeechRecoResult*)this;
                    pPhraseAlts->m_rgIPhraseAlts = rgIPhraseAlts;
                    pPhraseAlts->m_lPhraseAltsCount = cAltsReturned;
                    *ppAlternates = pPhraseAlts;
                }
            }

            // Free up the memory if we failed in here.
            if ( hr != S_OK )
            {
                CoTaskMemFree( rgIPhraseAlts );
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
} /* CSpResult::Alternates */

/*****************************************************************************
* CSpResult::Audio *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpResult::Audio( long lStartElement, long cElements, ISpeechMemoryStream **ppStream )
{
    SPDBG_FUNC( "CSpResult::Audio" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppStream ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpStreamFormat> cpStream;
        hr = GetAudio(lStartElement, cElements, &cpStream);
        if ( SUCCEEDED( hr ) )
        {
            hr = cpStream.QueryInterface( ppStream );
        }
        else if ( hr == SPERR_NO_AUDIO_DATA )
        {
            // Return NULL stream pointer in the case of no audio data.
            *ppStream = NULL;
            hr = S_OK;
        }
    }

    return hr;
} /* CSpResult::Audio */

/*****************************************************************************
* CSpResult::SpeakAudio *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpResult::SpeakAudio( long lStartElement, long cElements, SpeechVoiceSpeakFlags eFlags, long* pStreamNumber )
{
    SPDBG_FUNC( "CSpResult::SpeakAudio" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pStreamNumber ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = SpeakAudio((ULONG)lStartElement, (ULONG)cElements, (DWORD)eFlags, (ULONG*)pStreamNumber);
    }

    return hr;
} /* CSpResult::SpeakAudio */

/*****************************************************************************
* CSpResult::SaveToMemory *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpResult::SaveToMemory( VARIANT* pResultBlock )
{
    SPDBG_FUNC( "CSpResult::SaveToMemory" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pResultBlock ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Call Serialize to serialize the result to memory
        SPSERIALIZEDRESULT* pCoMemSerializedResult;

        hr = Serialize( &pCoMemSerializedResult );

        // Copy the serialized memory into a safe array
        if( SUCCEEDED( hr ) )
        {
            BYTE *pArray;
            SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, pCoMemSerializedResult->ulSerializedSize );
            if( psa )
            {
                if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
                {
                    memcpy( pArray, pCoMemSerializedResult, pCoMemSerializedResult->ulSerializedSize );
                    SafeArrayUnaccessData( psa );
                    VariantClear(pResultBlock);
                    pResultBlock->vt     = VT_ARRAY | VT_UI1;
                    pResultBlock->parray = psa;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            ::CoTaskMemFree( pCoMemSerializedResult );

        }
    }

    return hr;
} /* CSpResult::SaveToMemory */

/*****************************************************************************
* CSpResult::get_PhraseInfo *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpResult::get_PhraseInfo( ISpeechPhraseInfo** ppPhraseInfo )
{
    SPDBG_FUNC( "CSpResult::get_PhraseInfo" );
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( ppPhraseInfo ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Create the ResultTimes object
        CComObject<CSpeechPhraseInfo> *pPhraseInfo;
        hr = CComObject<CSpeechPhraseInfo>::CreateInstance( &pPhraseInfo );
        if ( SUCCEEDED( hr ) )
        {
            pPhraseInfo->AddRef();
            pPhraseInfo->m_cpISpPhrase = this; // Keep ref on ISpPhrase
            hr = GetPhrase( &pPhraseInfo->m_pPhraseStruct );

            if ( SUCCEEDED( hr ) )
            {
                *ppPhraseInfo = pPhraseInfo;
            }
            else
            {
                pPhraseInfo->Release();
            }
        }
    }

    return hr;
} /* CSpResult::get_PhraseInfo */

/*****************************************************************************
* CSpResult::DiscardResultInfo *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpResult::DiscardResultInfo( SpeechDiscardType DiscardType )
{
    SPDBG_FUNC( "CSpResult::DiscardResultInfo" );

    return Discard( DiscardType );
} /* CSpResult::DiscardResultInfo */


//
//=== ISpeechPhraseInfo interface ==================================================
//

/*****************************************************************************
* CSpeechPhraseInfo::get_LanguageId *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_LanguageId( long* pLanguageId )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::get_LanguageId" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pLanguageId ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pLanguageId = (long)m_pPhraseStruct->LangID;
    }

    return hr;
} /* CSpeechPhraseInfo::get_LanguageId */

/*****************************************************************************
* CSpeechPhraseInfo::get_GrammarId *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_GrammarId( VARIANT* pGrammarId )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::get_GrammarId" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pGrammarId ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = ULongLongToVariant( m_pPhraseStruct->ullGrammarID, pGrammarId );
    }

    return hr;
} /* CSpeechPhraseInfo::get_GrammarId */


/*****************************************************************************
* CSpeechPhraseInfo::get_StartTime *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_StartTime( VARIANT* pStartTime )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::get_StartTime" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pStartTime ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = ULongLongToVariant( m_pPhraseStruct->ftStartTime, pStartTime );
    }

    return hr;
} /* CSpeechPhraseInfo::get_StartTime */

/*****************************************************************************
* CSpeechPhraseInfo::get_AudioStreamPosition *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_AudioStreamPosition( VARIANT* pAudioStreamPosition )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::pAudioStreamPosition" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pAudioStreamPosition ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = ULongLongToVariant( m_pPhraseStruct->ullAudioStreamPosition, pAudioStreamPosition );
    }

    return hr;
} /* CSpeechPhraseInfo::get_AudioStreamPosition */

/*****************************************************************************
* CSpeechPhraseInfo::get_AudioSizeBytes *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_AudioSizeBytes( long* pAudioSizeBytes )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::get_AudioSizeBytes" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pAudioSizeBytes ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pAudioSizeBytes = m_pPhraseStruct->ulAudioSizeBytes;
    }

    return hr;
} /* CSpeechPhraseInfo::get_AudioSizeBytes */

/*****************************************************************************
* CSpeechPhraseInfo::get_RetainedSizeBytes *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_RetainedSizeBytes( long* pRetainedSizeBytes )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::get_RetainedSizeBytes" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pRetainedSizeBytes ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pRetainedSizeBytes = m_pPhraseStruct->ulRetainedSizeBytes;
    }

    return hr;
} /* CSpeechPhraseInfo::get_RetainedSizeBytes */

/*****************************************************************************
* CSpeechPhraseInfo::get_AudioSizeTime *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_AudioSizeTime( long* pAudioSizeTime )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::get_AudioSizeTime" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pAudioSizeTime ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pAudioSizeTime = m_pPhraseStruct->ulAudioSizeTime;
    }

    return hr;
} /* CSpeechPhraseInfo::get_AudioSizeTime */

/*****************************************************************************
* CSpeechPhraseInfo::get_Rule *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_Rule( ISpeechPhraseRule** ppRule )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::get_Rule" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppRule ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Create the CSpeechPhraseRule object
        CComObject<CSpeechPhraseRule> *pPhraseRule;
        hr = CComObject<CSpeechPhraseRule>::CreateInstance( &pPhraseRule );
        if ( SUCCEEDED( hr ) )
        {
            pPhraseRule->AddRef();
            pPhraseRule->m_pPhraseRuleData = &m_pPhraseStruct->Rule;
            pPhraseRule->m_pIPhraseInfo = this; // need to keep ref on PhraseInfo.
            pPhraseRule->m_pIPhraseRuleParent = NULL; // Top rule so no parent.
            *ppRule = pPhraseRule;
        }
    }

    return hr;
} /* CSpeechPhraseInfo::get_Rule */

/*****************************************************************************
* CSpeechPhraseInfo::get_Properties *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_Properties( ISpeechPhraseProperties** ppProperties )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::get_Properties" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppProperties ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppProperties = NULL;  // make sure its NULL in case we have no properties.

        if ( m_pPhraseStruct->pProperties )
        {
            //--- Create the CSpeechPhraseProperties object
            CComObject<CSpeechPhraseProperties> *pPhraseProperties;
            hr = CComObject<CSpeechPhraseProperties>::CreateInstance( &pPhraseProperties );
            if ( SUCCEEDED( hr ) )
            {
                pPhraseProperties->AddRef();
                pPhraseProperties->m_pIPhraseInfo = this;  // need to keep ref on PhraseInfo.
                pPhraseProperties->m_pIPhrasePropertyParent = NULL;
                pPhraseProperties->m_pPhrasePropertyFirstChildData = m_pPhraseStruct->pProperties;
                *ppProperties = pPhraseProperties;
            }
        }
    }

    return hr;
} /* CSpeechPhraseInfo::get_Properties */

/*****************************************************************************
* CSpeechPhraseInfo::get_Elements *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_Elements( ISpeechPhraseElements** ppElements )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::get_Elements" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppElements ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Create the CSpeechPhraseElements object
        CComObject<CSpeechPhraseElements> *pPhraseElements;
        hr = CComObject<CSpeechPhraseElements>::CreateInstance( &pPhraseElements );
        if ( SUCCEEDED( hr ) )
        {
            pPhraseElements->AddRef();
            pPhraseElements->m_pCPhraseInfo = this;
            pPhraseElements->m_pCPhraseInfo->AddRef(); // need to keep ref on PhraseInfo.
            *ppElements = pPhraseElements;
        }
    }

    return hr;
} /* CSpeechPhraseInfo::get_Elements */

/*****************************************************************************
* CSpeechPhraseInfo::get_Replacements *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_Replacements( ISpeechPhraseReplacements** ppReplacements )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::get_Replacements" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppReplacements ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppReplacements = NULL;  // make sure its NULL in case we have no replacements.

        if ( m_pPhraseStruct->cReplacements && m_pPhraseStruct->pReplacements )
        {
            //--- Create the CSpeechPhraseRule object
            CComObject<CSpeechPhraseReplacements> *pPhraseReplacements;
            hr = CComObject<CSpeechPhraseReplacements>::CreateInstance( &pPhraseReplacements );
            if ( SUCCEEDED( hr ) )
            {
                pPhraseReplacements->AddRef();
                pPhraseReplacements->m_pCPhraseInfo = this;
                pPhraseReplacements->m_pCPhraseInfo->AddRef(); // need to keep ref on PhraseInfo.
                *ppReplacements = pPhraseReplacements;
            }
        }
    }

    return hr;
} /* CSpeechPhraseInfo::get_Replacements */

/*****************************************************************************
* CSpeechPhraseInfo::get_EngineId *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_EngineId( BSTR* pEngineIdGuid )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::get_EngineId" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pEngineIdGuid ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CSpDynamicString szGuid;

        hr = StringFromIID(m_pPhraseStruct->SREngineID, &szGuid);
        if ( SUCCEEDED( hr ) )
        {
            hr = szGuid.CopyToBSTR(pEngineIdGuid);
        }
    }

    return hr;
} /* CSpeechPhraseInfo::get_EngineId */

/*****************************************************************************
* CSpeechPhraseInfo::get_EnginePrivateData *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::get_EnginePrivateData( VARIANT *pPrivateData )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::get_EnginePrivateData" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pPrivateData ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if ( m_pPhraseStruct->ulSREnginePrivateDataSize )
        {
            BYTE *pArray;
            SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, m_pPhraseStruct->ulSREnginePrivateDataSize );
            if( psa )
            {
                if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
                {
                    memcpy( pArray, m_pPhraseStruct->pSREnginePrivateData, m_pPhraseStruct->ulSREnginePrivateDataSize );
                    SafeArrayUnaccessData( psa );
                    VariantClear(pPrivateData);
                    pPrivateData->vt     = VT_ARRAY | VT_UI1;
                    pPrivateData->parray = psa;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
} /* CSpeechPhraseInfo::get_EnginePrivateData */

/*****************************************************************************
* CSpeechPhraseInfo::SaveToMemory *
*----------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechPhraseInfo::SaveToMemory( VARIANT* pvtPhrase )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::SaveToMemory" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pvtPhrase ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Call GetSerializedPhrase to serialize the phrase to memory
        SPSERIALIZEDPHRASE* pCoMemSerializedPhrase;
        hr = m_cpISpPhrase->GetSerializedPhrase( &pCoMemSerializedPhrase );
       
        // Copy the serialized memory into a safe array
        if( SUCCEEDED( hr ) )
        {
            BYTE *pArray;
            SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, pCoMemSerializedPhrase->ulSerializedSize );
            if( psa )
            {
                if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
                {
                    memcpy( pArray, pCoMemSerializedPhrase, pCoMemSerializedPhrase->ulSerializedSize );
                    SafeArrayUnaccessData( psa );
                    VariantClear(pvtPhrase);
                    pvtPhrase->vt     = VT_ARRAY | VT_UI1;
                    pvtPhrase->parray = psa;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            ::CoTaskMemFree( pCoMemSerializedPhrase );
        }
    }

    return hr;
} /* CSpeechPhraseInfo::SaveToMemory */

/*****************************************************************************
* CSpeechPhraseInfo::GetText *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::GetText( long StartElement, long Elements,
                                         VARIANT_BOOL UseTextReplacements, BSTR* pbstrText )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::GetText" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pbstrText ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CSpDynamicString szText;
        hr = m_cpISpPhrase->GetText(StartElement, Elements, !!UseTextReplacements, &szText, NULL );
        if( hr == S_OK )
        {
            hr = szText.CopyToBSTR(pbstrText);
        }
    }

    return hr;
} /* CSpeechPhraseInfo::GetText */

/*****************************************************************************
* CSpeechPhraseInfo::GetDisplayAttributes *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseInfo::GetDisplayAttributes( long StartElement, 
                                              long Elements,
                                              VARIANT_BOOL UseTextReplacements, 
                                              SpeechDisplayAttributes* pDisplayAttributes )
{
    SPDBG_FUNC( "CSpeechPhraseInfo::GetDisplayAttributes" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pDisplayAttributes ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CSpDynamicString szText;
        BYTE da;
        hr = m_cpISpPhrase->GetText(StartElement, Elements, !!UseTextReplacements, &szText, &da );
        *pDisplayAttributes = (SpeechDisplayAttributes)da;
    }

    return hr;
} /* CSpeechPhraseInfo::GetDisplayAttributes */


//
//=== ISpeechPhraseElements interface ==================================================
//

/*****************************************************************************
* CSpeechPhraseElements::get_Count *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElements::get_Count( long* pVal )
{
    SPDBG_FUNC( "CSpeechPhraseElements::get_Count" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pVal ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_pCPhraseInfo->m_pPhraseStruct->Rule.ulCountOfElements;
    }

    return hr;
} /* CSpeechPhraseElements::get_Count */

/*****************************************************************************
* CSpeechPhraseElements::Item *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElements::Item( long Index, ISpeechPhraseElement** ppElem )
{
    SPDBG_FUNC( "CSpeechPhraseElements::Item" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppElem ))
    {
        hr = E_POINTER;
    }
    else
    {
        // Make sure we've got valid index.
        if ( Index < 0 || (ULONG)Index >= m_pCPhraseInfo->m_pPhraseStruct->Rule.ulCountOfElements )
        {
            return E_INVALIDARG;
        }

        //--- Create the CSpeechPhraseElement object
        CComObject<CSpeechPhraseElement> *pPhraseElement;
        hr = CComObject<CSpeechPhraseElement>::CreateInstance( &pPhraseElement );
        if ( SUCCEEDED( hr ) )
        {
            pPhraseElement->AddRef();
            pPhraseElement->m_pPhraseElement = m_pCPhraseInfo->m_pPhraseStruct->pElements + Index;
            pPhraseElement->m_pIPhraseInfo = m_pCPhraseInfo;    // need to keep ref on PhraseInfo.
            *ppElem = pPhraseElement;
        }
    }

    return hr;
} /* CSpeechPhraseElements::Item */

/*****************************************************************************
* CSpeechPhraseElements::get__NewEnum *
*----------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechPhraseElements::get__NewEnum( IUnknown** ppEnumVARIANT )
{
    SPDBG_FUNC( "CSpeechPhraseElements::get__NewEnum" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppEnumVARIANT ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComObject<CEnumElements>* pEnum;
        hr = CComObject<CEnumElements>::CreateInstance( &pEnum );
        
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_cpElements = this;
            *ppEnumVARIANT = pEnum;
        }
    }
    return hr;
} /* CSpeechPhraseElements::get__NewEnum */


//
//=== ISpeechPhraseElement interface ==================================================
//

/*****************************************************************************
* CSpeechPhraseElement::get_AudioStreamOffset *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_AudioStreamOffset( long* pAudioStreamOffset )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_AudioStreamOffset" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pAudioStreamOffset ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pAudioStreamOffset = m_pPhraseElement->ulAudioStreamOffset;
    }

    return hr;
} /* CSpeechPhraseElement::get_AudioStreamOffset */

/*****************************************************************************
* CSpeechPhraseElement::get_AudioTimeOffset *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_AudioTimeOffset( long* pAudioTimeOffset )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_AudioTimeOffset" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pAudioTimeOffset ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pAudioTimeOffset = m_pPhraseElement->ulAudioTimeOffset;
    }

    return hr;
} /* CSpeechPhraseElement::get_AudioTimeOffset */

/*****************************************************************************
* CSpeechPhraseElement::get_AudioSizeBytes*
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_AudioSizeBytes( long* pAudioSizeBytes )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_AudioSizeBytes" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pAudioSizeBytes ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pAudioSizeBytes = m_pPhraseElement->ulAudioSizeBytes;
    }

    return hr;
} /* CSpeechPhraseElement::get_AudioSizeBytes */

/*****************************************************************************
* CSpeechPhraseElement::get_AudioSizeTime *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_AudioSizeTime( long* pAudioSizeTime )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_AudioSizeTime" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pAudioSizeTime ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pAudioSizeTime = m_pPhraseElement->ulAudioSizeTime;
    }

    return hr;
} /* CSpeechPhraseElement::get_AudioSizeTime */

/*****************************************************************************
* CSpeechPhraseElement::get_RetainedStreamOffset *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_RetainedStreamOffset( long* pRetainedStreamOffset )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_RetainedStreamOffset" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pRetainedStreamOffset ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pRetainedStreamOffset = m_pPhraseElement->ulRetainedStreamOffset;
    }

    return hr;
} /* CSpeechPhraseElement::get_RetainedStreamOffset */

/*****************************************************************************
* CSpeechPhraseElement::get_RetainedSizeBytes *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_RetainedSizeBytes( long* pRetainedSizeBytes )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_RetainedSizeBytes" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pRetainedSizeBytes ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pRetainedSizeBytes = m_pPhraseElement->ulRetainedSizeBytes;
    }

    return hr;
} /* CSpeechPhraseElement::get_RetainedSizeBytes */

/*****************************************************************************
* CSpeechPhraseElement::get_DisplayText *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_DisplayText( BSTR* pDisplayText )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_DisplayText" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pDisplayText ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComBSTR bstr(m_pPhraseElement->pszDisplayText);
        *pDisplayText = bstr.Detach();
    }

    return hr;
} /* CSpeechPhraseElement::get_DisplayText */

/*****************************************************************************
* CSpeechPhraseElement::get_LexicalForm *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_LexicalForm( BSTR* pLexicalForm )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_LexicalForm" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pLexicalForm ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComBSTR bstr(m_pPhraseElement->pszLexicalForm);
        *pLexicalForm = bstr.Detach();
    }

    return hr;
} /* CSpeechPhraseElement::get_LexicalForm */

/*****************************************************************************
* CSpeechPhraseElement::get_Pronunciation *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_Pronunciation( VARIANT* pPronunciation )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_Pronunciation" );
    HRESULT hr = S_OK;
    int     numPhonemes = 0;

    if( SP_IS_BAD_WRITE_PTR( pPronunciation ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if( m_pPhraseElement->pszPronunciation )
        {
            BYTE *pArray;
            numPhonemes = wcslen( m_pPhraseElement->pszPronunciation );
            SAFEARRAY* psa = SafeArrayCreateVector( VT_I2, 0, numPhonemes );
            if( psa )
            {
                if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
                {
                    memcpy(pArray, m_pPhraseElement->pszPronunciation, numPhonemes*sizeof(SPPHONEID) );
                    SafeArrayUnaccessData( psa );
                    VariantClear(pPronunciation);
                    pPronunciation->vt     = VT_ARRAY | VT_I2;
                    pPronunciation->parray = psa;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            // Set the pronunciation to Empty.
            pPronunciation->vt = VT_EMPTY;
        }
   }

    return hr;
} /* CSpeechPhraseElement::get_Pronunciation */

/*****************************************************************************
* CSpeechPhraseElement::get_DisplayAttributes *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_DisplayAttributes( SpeechDisplayAttributes* pDisplayAttributes )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_DisplayAttributes" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pDisplayAttributes ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pDisplayAttributes = (SpeechDisplayAttributes)m_pPhraseElement->bDisplayAttributes;
    }

    return hr;
} /* CSpeechPhraseElement::get_DisplayAttributes */

/*****************************************************************************
* CSpeechPhraseElement::get_RequiredConfidence *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_RequiredConfidence( SpeechEngineConfidence* pRequiredConfidence )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_RequiredConfidence" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pRequiredConfidence ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pRequiredConfidence = (SpeechEngineConfidence)m_pPhraseElement->RequiredConfidence;
    }

    return hr;
} /* CSpeechPhraseElement::get_RequiredConfidence */

/*****************************************************************************
* CSpeechPhraseElement::get_ActualConfidence *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_ActualConfidence( SpeechEngineConfidence* pActualConfidence )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_ActualConfidence" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pActualConfidence ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pActualConfidence = (SpeechEngineConfidence)m_pPhraseElement->ActualConfidence;
    }

    return hr;
} /* CSpeechPhraseElement::get_ActualConfidence */

/*****************************************************************************
* CSpeechPhraseElement::get_EngineConfidence *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseElement::get_EngineConfidence( float* pEngineConfidence )
{
    SPDBG_FUNC( "CSpeechPhraseElement::get_EngineConfidence" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pEngineConfidence ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pEngineConfidence = m_pPhraseElement->SREngineConfidence;
    }

    return hr;
} /* CSpeechPhraseElement::get_EngineConfidence */


//
//=== ISpeechPhraseRule interface ==================================================
//

/*****************************************************************************
* CSpeechPhraseRule::get_Name *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseRule::get_Name( BSTR* pName )
{
    SPDBG_FUNC( "CSpeechPhraseRule::get_Name" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pName ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComBSTR bstr(m_pPhraseRuleData->pszName);
        *pName = bstr.Detach();
    }

    return hr;
} /* CSpeechPhraseRule::get_Name */

/*****************************************************************************
* CSpeechPhraseRule::get_Id *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseRule::get_Id( long* pId )
{
    SPDBG_FUNC( "CSpeechPhraseRule::get_Id" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pId ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pId = m_pPhraseRuleData->ulId;
    }

    return hr;
} /* CSpeechPhraseRule::get_Id */

/*****************************************************************************
* CSpeechPhraseRule::get_FirstElement *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseRule::get_FirstElement( long* pFirstElement )
{
    SPDBG_FUNC( "CSpeechPhraseRule::get_FirstElement" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pFirstElement ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pFirstElement = m_pPhraseRuleData->ulFirstElement;
    }

    return hr;
} /* CSpeechPhraseRule::get_FirstElement */

/*****************************************************************************
* CSpeechPhraseRule::get_NumberOfElements *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseRule::get_NumberOfElements( long* pNumElements )
{
    SPDBG_FUNC( "CSpeechPhraseRule::get_NumberOfElements" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pNumElements ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pNumElements = m_pPhraseRuleData->ulCountOfElements;
    }

    return hr;
} /* CSpeechPhraseRule::get_NumberOfElements */

/*****************************************************************************
* CSpeechPhraseRule::get_Parent *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseRule::get_Parent( ISpeechPhraseRule** ppParent )
{
    SPDBG_FUNC( "CSpeechPhraseRule::get_Parent" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppParent ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if ( m_pIPhraseRuleParent )
        {
            *ppParent = m_pIPhraseRuleParent;
            (*ppParent)->AddRef();
        }
        else
        {
            *ppParent = NULL;
        }

    }

    return hr;
} /* CSpeechPhraseRule::get_Parent */

/*****************************************************************************
* CSpeechPhraseRule::get_Children *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseRule::get_Children( ISpeechPhraseRules** ppChildren )
{
    SPDBG_FUNC( "CSpeechPhraseRule::get_Children" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppChildren ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Set to NULL for the case we don't have any children and return NULL.
        *ppChildren = NULL;

        // See if we have any children first.
        if ( m_pPhraseRuleData->pFirstChild )
        {
            //--- Create the CSpeechPhraseRules object
            CComObject<CSpeechPhraseRules> *pPhraseRules;
            hr = CComObject<CSpeechPhraseRules>::CreateInstance( &pPhraseRules );
            if ( SUCCEEDED( hr ) )
            {
                pPhraseRules->AddRef();
                pPhraseRules->m_pPhraseRuleFirstChildData = m_pPhraseRuleData->pFirstChild;
                pPhraseRules->m_pIPhraseRuleParent = this; // This does an addref.
                *ppChildren = pPhraseRules;
            }
        }
    }

    return hr;
} /* CSpeechPhraseRule::get_Children */

/*****************************************************************************
* CSpeechPhraseRule::get_Confidence *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseRule::get_Confidence( SpeechEngineConfidence* pConfidence )
{
    SPDBG_FUNC( "CSpeechPhraseRule::get_Confidence" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pConfidence ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pConfidence = (SpeechEngineConfidence)m_pPhraseRuleData->Confidence;
    }

    return hr;
} /* CSpeechPhraseRule::get_Confidence */

/*****************************************************************************
* CSpeechPhraseRule::get_EngineConfidence *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseRule::get_EngineConfidence( float* pEngineConfidence )
{
    SPDBG_FUNC( "CSpeechPhraseRule::get_EngineConfidence" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pEngineConfidence ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pEngineConfidence = m_pPhraseRuleData->SREngineConfidence;
    }

    return hr;
} /* CSpeechPhraseRule::get_EngineConfidence */

//
//=== ISpeechPhraseRules interface ==================================================
//

/*****************************************************************************
* CSpeechPhraseRules::get_Count *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseRules::get_Count( long* pVal )
{
    SPDBG_FUNC( "CSpeechPhraseRules::get_Count" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pVal ) )
    {
        hr = E_POINTER;
    }
    else
    {
        long i = 0;
        const SPPHRASERULE * pRule = m_pPhraseRuleFirstChildData;

        // Count the number of rules in the collection.
        while ( pRule )
        {
            i++;
            pRule = pRule->pNextSibling;
        }
        *pVal = i;
    }

    return hr;
} /* CSpeechPhraseRules::get_Count */


/*****************************************************************************
* CSpeechPhraseRules::Item *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseRules::Item( long Index, ISpeechPhraseRule **ppRule )
{
    SPDBG_FUNC( "CSpeechPhraseRules::Item" );
    HRESULT hr = S_OK;

    if(SP_IS_BAD_WRITE_PTR( ppRule ) )
    {
        hr = E_POINTER;
    }
    else
    {
        long i = 0;
        const SPPHRASERULE * pRule = m_pPhraseRuleFirstChildData;

        // Make sure we've got valid index and find the child rule to create.
        while ( pRule && (i++ != Index) )
        {
            pRule = pRule->pNextSibling;
        }

        // If we failed to find the rule at that index then we've got a bad index.
        if ( Index < 0 || !pRule )
        {
            return E_INVALIDARG;
        }

        //--- Create the CSpeechPhraseElement object
        CComObject<CSpeechPhraseRule> *pPhraseRule;
        hr = CComObject<CSpeechPhraseRule>::CreateInstance( &pPhraseRule );
        if ( SUCCEEDED( hr ) )
        {
            pPhraseRule->AddRef();
            pPhraseRule->m_pPhraseRuleData = pRule;
            pPhraseRule->m_pIPhraseRuleParent = m_pIPhraseRuleParent;  // need to keep ref on Parent Phrase rule.
            *ppRule = pPhraseRule;
        }
    }

    return hr;
} /* CSpeechPhraseRules::Item */

/*****************************************************************************
* CSpeechPhraseRules::get__NewEnum *
*----------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechPhraseRules::get__NewEnum( IUnknown** ppEnumVARIANT )
{
    SPDBG_FUNC( "CSpeechPhraseRules::get__NewEnum" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppEnumVARIANT ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComObject<CEnumPhraseRules>* pEnum;
        hr = CComObject<CEnumPhraseRules>::CreateInstance( &pEnum );
        
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_cpRules = this;
            *ppEnumVARIANT = pEnum;
        }
    }
    return hr;
} /* CSpeechPhraseRules::get__NewEnum */


//
//=== ISpeechPhraseProperty interface ==================================================
//

/*****************************************************************************
* CSpeechPhraseProperty::get_Name *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseProperty::get_Name( BSTR* pName )
{
    SPDBG_FUNC( "CSpeechPhraseProperty::get_Name" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pName ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComBSTR bstr(m_pPhrasePropertyData->pszName);
        *pName = bstr.Detach();
    }

    return hr;
} /* CSpeechPhraseProperty::get_Name */

/*****************************************************************************
* CSpeechPhraseProperty::get_Id *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseProperty::get_Id( long* pId )
{
    SPDBG_FUNC( "CSpeechPhraseProperty::get_Id" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pId ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pId = m_pPhrasePropertyData->ulId;
    }

    return hr;
} /* CSpeechPhraseProperty::get_Id */

/*****************************************************************************
* CSpeechPhraseProperty::get_Value *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseProperty::get_Value( VARIANT* pValue )
{
    SPDBG_FUNC( "CSpeechPhraseProperty::get_Value" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pValue ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if(m_pPhrasePropertyData->pszValue && m_pPhrasePropertyData->pszValue[0] != L'\0')
        {
            BSTR bstr = ::SysAllocString(m_pPhrasePropertyData->pszValue);
            if(bstr)
            {
                VariantClear(pValue);
                pValue->vt = VT_BSTR;
                pValue->bstrVal = bstr;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            *pValue = m_pPhrasePropertyData->vValue;

            // Since VB can't handle unsigned types we convert the VT_UI4 that the XML compiler 
            // will generate here.  
            // Note that we just change the type so that we don't have to worry about overflow.
            // This means the numbers will just go negative.  We don't worry about VT_UI2 or VT_UINT 
            // currently since only a user can generate those dynamically and if they do they should 
            // be able to handle them (like if using C#).
            if ( pValue->vt == VT_UI4 )
            {
                pValue->vt = VT_I4;
            }
        }
    }

    return hr;
} /* CSpeechPhraseProperty::get_Value */

/*****************************************************************************
* CSpeechPhraseProperty::get_FirstElement *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseProperty::get_FirstElement( long* pFirstElement )
{
    SPDBG_FUNC( "CSpeechPhraseProperty::get_FirstElement" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pFirstElement ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pFirstElement = m_pPhrasePropertyData->ulFirstElement;
    }

    return hr;
} /* CSpeechPhraseProperty::get_FirstElement */

/*****************************************************************************
* CSpeechPhraseProperty::get_NumberOfElements *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseProperty::get_NumberOfElements( long* pNumElements )
{
    SPDBG_FUNC( "CSpeechPhraseProperty::get_NumberOfElements" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pNumElements ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pNumElements = m_pPhrasePropertyData->ulCountOfElements;
    }

    return hr;
} /* CSpeechPhraseProperty::get_NumberOfElements */

/*****************************************************************************
* CSpeechPhraseProperty::get_EngineConfidence *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseProperty::get_EngineConfidence( float* pConfidence )
{
    SPDBG_FUNC( "CSpeechPhraseProperty::get_EngineConfidence" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pConfidence ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pConfidence = m_pPhrasePropertyData->SREngineConfidence;
    }

    return hr;
} /* CSpeechPhraseProperty::get_EngineConfidence */

/*****************************************************************************
* CSpeechPhraseProperty::get_Confidence *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseProperty::get_Confidence( SpeechEngineConfidence* pConfidence )
{
    SPDBG_FUNC( "CSpeechPhraseProperty::get_Confidence" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pConfidence ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pConfidence = (SpeechEngineConfidence)m_pPhrasePropertyData->Confidence;
    }

    return hr;
} /* CSpeechPhraseProperty::get_Confidence */

/*****************************************************************************
* CSpeechPhraseProperty::get_Parent *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseProperty::get_Parent( ISpeechPhraseProperty** ppParent )
{
    SPDBG_FUNC( "CSpeechPhraseProperty::get_Parent" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppParent ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if ( m_pIPhrasePropertyParent )
        {
            *ppParent = m_pIPhrasePropertyParent;
            (*ppParent)->AddRef();
        }
        else
        {
            *ppParent = NULL;
        }

    }

    return hr;
} /* CSpeechPhraseProperty::get_Parent */

/*****************************************************************************
* CSpeechPhraseProperty::get_Children *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseProperty::get_Children( ISpeechPhraseProperties** ppChildren )
{
    SPDBG_FUNC( "CSpeechPhraseProperty::get_Children" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppChildren ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Set to NULL for the case we don't have any children and return NULL.
        *ppChildren = NULL;

        // See if we have any children first.
        if ( m_pPhrasePropertyData->pFirstChild )
        {
            //--- Create the CSpeechPhrasePropertys object
            CComObject<CSpeechPhraseProperties> *pPhraseProperties;
            hr = CComObject<CSpeechPhraseProperties>::CreateInstance( &pPhraseProperties );
            if ( SUCCEEDED( hr ) )
            {
                pPhraseProperties->AddRef();
                pPhraseProperties->m_pPhrasePropertyFirstChildData = m_pPhrasePropertyData->pFirstChild;
                pPhraseProperties->m_pIPhrasePropertyParent = this; // This does an addref.
                *ppChildren = pPhraseProperties;
            }
        }
    }

    return hr;
} /* CSpeechPhraseProperty::get_Children */


//
//=== ISpeechPhraseProperties interface ==================================================
//

/*****************************************************************************
* CSpeechPhraseProperties::get_Count *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseProperties::get_Count( long* pVal )
{
    SPDBG_FUNC( "CSpeechPhraseProperties::get_Count" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pVal ) )
    {
        hr = E_POINTER;
    }
    else
    {
        long i = 0;
        const SPPHRASEPROPERTY * pProperty = m_pPhrasePropertyFirstChildData;

        // Count the number of rules in the collection.
        while ( pProperty )
        {
            i++;
            pProperty = pProperty->pNextSibling;
        }
        *pVal = i;
    }

    return hr;
} /* CSpeechPhraseProperties::get_Count */


/*****************************************************************************
* CSpeechPhraseProperties::Item *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseProperties::Item( long Index, ISpeechPhraseProperty **ppProperty )
{
    SPDBG_FUNC( "CSpeechPhraseProperties::Item" );
    HRESULT hr = S_OK;

    if(SP_IS_BAD_WRITE_PTR( ppProperty ) )
    {
        hr = E_POINTER;
    }
    else
    {
        long i = 0;
        const SPPHRASEPROPERTY * pProperty = m_pPhrasePropertyFirstChildData;

        // Make sure we've got valid index and find the child rule to create.
        while ( pProperty && (i++ != Index) )
        {
            pProperty = pProperty->pNextSibling;
        }

        // If we failed to find the rule at that index then we've got a bad index.
        if ( Index <0 || !pProperty )
        {
            return E_INVALIDARG;
        }

        //--- Create the CSpeechPhraseProperty object
        CComObject<CSpeechPhraseProperty> *pPhraseProperty;
        hr = CComObject<CSpeechPhraseProperty>::CreateInstance( &pPhraseProperty );
        if ( SUCCEEDED( hr ) )
        {
            pPhraseProperty->AddRef();
            pPhraseProperty->m_pPhrasePropertyData = pProperty;
            // need to keep ref on Parent Phrase Property.
            pPhraseProperty->m_pIPhrasePropertyParent = m_pIPhrasePropertyParent;
            *ppProperty = pPhraseProperty;
        }
    }

    return hr;
} /* CSpeechPhraseProperties::Item */

/*****************************************************************************
* CSpeechPhraseProperties::get__NewEnum *
*----------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechPhraseProperties::get__NewEnum( IUnknown** ppEnumVARIANT )
{
    SPDBG_FUNC( "CSpeechPhraseProperties::get__NewEnum" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppEnumVARIANT ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComObject<CEnumProperties>* pEnum;
        hr = CComObject<CEnumProperties>::CreateInstance( &pEnum );
        
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_cpProperties = this;
            *ppEnumVARIANT = pEnum;
        }
    }
    return hr;
} /* CSpeechPhraseProperties::get__NewEnum */


//
//=== ISpeechPhraseReplacements interface ==================================================
//

/*****************************************************************************
* CSpeechPhraseReplacements::get_Count *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseReplacements::get_Count( long* pVal )
{
    SPDBG_FUNC( "CSpeechPhraseReplacements::get_Count" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pVal ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_pCPhraseInfo->m_pPhraseStruct->cReplacements;
    }

    return hr;
} /* CSpeechPhraseReplacements::get_Count */

/*****************************************************************************
* CSpeechPhraseReplacements::Item *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseReplacements::Item( long Index, ISpeechPhraseReplacement** ppElem )
{
    SPDBG_FUNC( "CSpeechPhraseReplacements::Item" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppElem ))
    {
        hr = E_POINTER;
    }
    else
    {
        // Make sure we've got valid index.
        if ( Index < 0 || (ULONG)Index >= m_pCPhraseInfo->m_pPhraseStruct->cReplacements )
        {
            return E_INVALIDARG;
        }

        //--- Create the CSpeechPhraseElement object
        CComObject<CSpeechPhraseReplacement> *pPhraseReplacement;
        hr = CComObject<CSpeechPhraseReplacement>::CreateInstance( &pPhraseReplacement );
        if ( SUCCEEDED( hr ) )
        {
            pPhraseReplacement->AddRef();
            pPhraseReplacement->m_pPhraseReplacement = m_pCPhraseInfo->m_pPhraseStruct->pReplacements + Index;
            pPhraseReplacement->m_pIPhraseInfo = m_pCPhraseInfo;    // need to keep ref on PhraseInfo.
            *ppElem = pPhraseReplacement;
        }
    }

    return hr;
} /* CSpeechPhraseReplacements::Item */

/*****************************************************************************
* CSpeechPhraseReplacements::get__NewEnum *
*----------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechPhraseReplacements::get__NewEnum( IUnknown** ppEnumVARIANT )
{
    SPDBG_FUNC( "CSpeechPhraseReplacements::get__NewEnum" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppEnumVARIANT ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComObject<CEnumReplacements>* pEnum;
        hr = CComObject<CEnumReplacements>::CreateInstance( &pEnum );
        
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_cpReplacements = this;
            *ppEnumVARIANT = pEnum;
        }
    }
    return hr;
} /* CSpeechPhraseReplacements::get__NewEnum */


//
//=== ISpeechPhraseReplacement interface ==================================================
//

/*****************************************************************************
* CSpeechPhraseReplacement::get_DisplayAttributes *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseReplacement::get_DisplayAttributes( SpeechDisplayAttributes* pDisplayAttributes )
{
    SPDBG_FUNC( "CSpeechPhraseReplacement::get_DisplayAttributes" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pDisplayAttributes ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pDisplayAttributes = (SpeechDisplayAttributes)m_pPhraseReplacement->bDisplayAttributes;
    }

    return hr;
} /* CSpeechPhraseReplacement::get_DisplayAttributes */

/*****************************************************************************
* CSpeechPhraseReplacement::get_Text *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseReplacement::get_Text( BSTR* pText )
{
    SPDBG_FUNC( "CSpeechPhraseReplacement::get_Text" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pText ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComBSTR bstr(m_pPhraseReplacement->pszReplacementText);
        *pText = bstr.Detach();
    }

    return hr;
} /* CSpeechPhraseReplacement::get_Text */

/*****************************************************************************
* CSpeechPhraseReplacement::get_FirstElement *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseReplacement::get_FirstElement( long* pFirstElement )
{
    SPDBG_FUNC( "CSpeechPhraseReplacement::get_FirstElement" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pFirstElement ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pFirstElement = m_pPhraseReplacement->ulFirstElement;
    }

    return hr;
} /* CSpeechPhraseReplacement::get_FirstElement */

/*****************************************************************************
* CSpeechPhraseReplacement::get_NumberOfElements *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseReplacement::get_NumberOfElements( long* pNumElements )
{
    SPDBG_FUNC( "CSpeechPhraseReplacement::get_NumberOfElements" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pNumElements ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pNumElements = m_pPhraseReplacement->ulCountOfElements;
    }

    return hr;
} /* CSpeechPhraseReplacement::get_NumberOfElements */


//
//=== ISpeechPhraseAlternates interface ==================================================
//

/*****************************************************************************
* CSpeechPhraseAlternates::get_Count *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseAlternates::get_Count( long* pVal )
{
    SPDBG_FUNC( "CSpeechPhraseAlternates::get_Count" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pVal ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_lPhraseAltsCount;
    }

    return hr;
} /* CSpeechPhraseAlternates::get_Count */

/*****************************************************************************
* CSpeechPhraseAlternates::Item *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechPhraseAlternates::Item( long Index, ISpeechPhraseAlternate** ppAlt )
{
    SPDBG_FUNC( "CSpeechPhraseAlternates::Item" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppAlt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Make sure we've got valid index.
        if ( Index < 0 || (ULONG)Index >= m_lPhraseAltsCount )
        {
            return E_INVALIDARG;
        }
        
        // OK Now return the SpeechPhaseAlt interface.
        CComQIPtr<ISpeechPhraseAlternate> cpAlt( m_rgIPhraseAlts[Index] );
        hr = cpAlt.CopyTo( ppAlt );
    }

    return hr;
} /* CSpeechPhraseAlternates::Item */

/*****************************************************************************
* CSpeechPhraseAlternates::get__NewEnum *
*----------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechPhraseAlternates::get__NewEnum( IUnknown** ppEnumVARIANT )
{
    SPDBG_FUNC( "CSpeechPhraseAlternates::get__NewEnum" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppEnumVARIANT ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComObject<CEnumAlternates>* pEnum;
        hr = CComObject<CEnumAlternates>::CreateInstance( &pEnum );
        
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_cpAlternates = this;
            *ppEnumVARIANT = pEnum;
        }
    }
    return hr;
} /* CSpeechPhraseAlternates::get__NewEnum */


//
//=== ISpeechPhraseAlternate interface ==================================================
//

/*****************************************************************************
* CSpPhraseAlt::get_RecoResult *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpPhraseAlt::get_RecoResult( ISpeechRecoResult** ppRecoResult )
{
    SPDBG_FUNC( "CSpPhraseAlt::get_RecoResult" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppRecoResult ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // TODDT: Make sure we don't have ref problem here with m_pResultWEAK.
        CComQIPtr<ISpRecoResult> cpRecoResult(m_pResultWEAK);
        hr = cpRecoResult.QueryInterface( ppRecoResult );
    }

    return hr;
} /* CSpPhraseAlt::get_RecoResult */


/*****************************************************************************
* CSpPhraseAlt::get_StartElementInResult *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpPhraseAlt::get_StartElementInResult( long* pParentStartElt )
{
    SPDBG_FUNC( "CSpPhraseAlt::get_StartElementInResult" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pParentStartElt ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetAltInfo( NULL, (ULONG *)pParentStartElt, NULL, NULL);
    }

    return hr;
} /* CSpPhraseAlt::get_StartElementInResult */


/*****************************************************************************
* CSpPhraseAlt::get_NumberOfElementsInResult *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpPhraseAlt::get_NumberOfElementsInResult( long* pNumParentElts )
{
    SPDBG_FUNC( "CSpPhraseAlt::get_NumberOfElementsInResult" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pNumParentElts ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetAltInfo( NULL, NULL, (ULONG *)pNumParentElts, NULL);
    }

    return hr;
} /* CSpPhraseAlt::get_NumberOfElementsInResult */



/*****************************************************************************
* CSpPhraseAlt::get_PhraseInfo *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpPhraseAlt::get_PhraseInfo( ISpeechPhraseInfo** ppPhraseInfo )
{
    SPDBG_FUNC( "CSpPhraseAlt::get_PhraseInfo" );
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( ppPhraseInfo ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Create the ResultTimes object
        CComObject<CSpeechPhraseInfo> *pPhraseInfo;
        hr = CComObject<CSpeechPhraseInfo>::CreateInstance( &pPhraseInfo );
        if ( SUCCEEDED( hr ) )
        {
            pPhraseInfo->AddRef();
            pPhraseInfo->m_cpISpPhrase = this;
            hr = GetPhrase( &pPhraseInfo->m_pPhraseStruct );

            if ( SUCCEEDED( hr ) )
            {
                *ppPhraseInfo = pPhraseInfo;
            }
            else
            {
                pPhraseInfo->Release();
            }
        }
    }

    return hr;
} /* CSpPhraseAlt::get_PhraseInfo */


//
//=== ISpeechBaseStream interface =================================================
//

/*****************************************************************************
* CSpResultAudioStream::get_Format *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpResultAudioStream::get_Format( ISpeechAudioFormat** ppStreamFormat )
{
    SPDBG_FUNC( "CSpResultAudioStream::get_Format" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppStreamFormat ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Create new object.
        CComObject<CSpeechAudioFormat> *pFormat;
        hr = CComObject<CSpeechAudioFormat>::CreateInstance( &pFormat );
        if ( SUCCEEDED( hr ) )
        {
            pFormat->AddRef();

            hr = pFormat->InitStreamFormat( this, true );
            if ( SUCCEEDED( hr ) )
            {
                *ppStreamFormat = pFormat;
            }
            else
            {
                *ppStreamFormat = NULL;
                pFormat->Release();
            }
        }
    }

    return hr;
} /* CSpResultAudioStream::get_Format */

/*****************************************************************************
* CSpResultAudioStream::Read *
*------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpResultAudioStream::Read( VARIANT* pvtBuffer, long NumBytes, long* pRead )
{
    SPDBG_FUNC( "CSpResultAudioStream::Read" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pvtBuffer ) || SP_IS_BAD_WRITE_PTR( pRead ) )
    {
        hr = E_POINTER;
    }
    else
    {
        BYTE *pArray;
        SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, NumBytes );
        if( psa )
        {
            if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
            {
                hr = Read(pArray, NumBytes, (ULONG*)pRead);
                SafeArrayUnaccessData( psa );
                VariantClear(pvtBuffer);
                pvtBuffer->vt     = VT_ARRAY | VT_UI1;
                pvtBuffer->parray = psa;

                if ( !SUCCEEDED( hr ) )
                {
                    VariantClear(pvtBuffer);    // Free our memory if we failed.
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
} /* CSpResultAudioStream::Read */

/*****************************************************************************
* CSpResultAudioStream::Seek *
*------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpResultAudioStream::Seek( VARIANT Pos, SpeechStreamSeekPositionType Origin, VARIANT *pNewPosition )
{
    SPDBG_FUNC( "CSpResultAudioStream::Seek" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pNewPosition ) )
    {
        hr = E_POINTER;
    }
    else
    {
        ULARGE_INTEGER uliNewPos;
        LARGE_INTEGER liPos;

        hr = VariantToLongLong( &Pos, &(liPos.QuadPart) );
        if (SUCCEEDED(hr))
        {
            hr = Seek(liPos, (DWORD)Origin, &uliNewPos);

            if (SUCCEEDED( hr ))
            {
                hr = ULongLongToVariant( uliNewPos.QuadPart, pNewPosition );
            }
        }
    }

    return hr;
} /* CSpResultAudioStream::Seek */


/*****************************************************************************
* CSpResultAudioStream::GetData *
*------------------*
*       
********************************************************************* davewood ***/
STDMETHODIMP CSpResultAudioStream::GetData( VARIANT* pData)
{
    SPDBG_FUNC( "CSpResultAudioStream::GetData" );

    HRESULT hr;
    STATSTG StreamStat;
    LARGE_INTEGER li; 
    ULARGE_INTEGER uliInitialSeekPosition;

    // Find the current seek position
    li.QuadPart = 0;
    hr = Seek( li, STREAM_SEEK_CUR, &uliInitialSeekPosition );

    // Seek to beginning of stream
    if(SUCCEEDED(hr))
    {
        li.QuadPart = 0;
        hr = Seek( li, STREAM_SEEK_SET, NULL );
    }

    // Get the Stream size
    if( SUCCEEDED( hr ) )
    {
        hr = Stat( &StreamStat, STATFLAG_NONAME );
    }

    // Create a SafeArray to read the stream into and assign it to the VARIANT SaveStream
    if( SUCCEEDED( hr ) )
    {
        BYTE *pArray;
        SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, StreamStat.cbSize.LowPart );
        if( psa )
        {
            if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
            {
                hr = Read( pArray, StreamStat.cbSize.LowPart, NULL );
                SafeArrayUnaccessData( psa );
                VariantClear( pData );
                pData->vt     = VT_ARRAY | VT_UI1;
                pData->parray = psa;

                // Free our memory if we failed.
                if( FAILED( hr ) )
                {
                    VariantClear( pData );    
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Move back to the original seek position
    if(SUCCEEDED(hr))
    {
        li.QuadPart = (LONGLONG)uliInitialSeekPosition.QuadPart;
        hr = Seek( li, STREAM_SEEK_SET, NULL );
    }

    return hr;
} /* CSpResultAudioStream::GetData */



#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_srgrammar.h ===
/*******************************************************************************
* a_srgrammar.h *
*-----------*
*   Description:
*       This is the header file for CSpeechGrammarRules, CSpeechGrammarRule,
*		and CSpeechGrammarRuleState implementations.
*-------------------------------------------------------------------------------
*  Created By: TODDT                            Date: 11/20/2000
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef a_srgrammar_h
#define a_srgrammar_h

#ifdef SAPI_AUTOMATION

class ATL_NO_VTABLE CRecoGrammar;

class ATL_NO_VTABLE CSpeechGrammarRules;
class ATL_NO_VTABLE CSpeechGrammarRule;
class ATL_NO_VTABLE CSpeechGrammarRuleState;
class ATL_NO_VTABLE CSpeechGrammarRuleStateTransitions;
class ATL_NO_VTABLE CSpeechGrammarRuleStateTransition;

//--- Additional includes

/*** CSpeechGrammarRules
*   This object is used to access the Grammar Rules in the 
*   associated speech reco context.
*/
class ATL_NO_VTABLE CSpeechGrammarRules : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechGrammarRules, &IID_ISpeechGrammarRules, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechGrammarRules)
	    COM_INTERFACE_ENTRY(ISpeechGrammarRules)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    CSpeechGrammarRules()
    {
        m_pCRecoGrammar = NULL;
    }

    ~CSpeechGrammarRules()
    {
        SPDBG_ASSERT( m_RuleObjList.GetHead() == NULL );  // Should have no outstanding rule objects at this point.
        if ( m_pCRecoGrammar )
        {
            m_pCRecoGrammar->m_pCRulesWeak = NULL;
            m_pCRecoGrammar->Release();
            m_pCRecoGrammar = NULL;
        }
    }

    /*--- Non interface methods ---*/

    // We just have to mark the initial rule as invalid since have ref 
    // to rule we check to make sure our objects are still valid.
    void InvalidateRules(void);
    void InvalidateRuleStates(SPSTATEHANDLE hState);

    /*=== Interfaces ====*/

    //--- ISpeechGrammarRules ----------------------------------
    STDMETHOD(get_Count)(long* pCount);
    STDMETHOD(get_Dynamic)(VARIANT_BOOL *Dynamic);
    STDMETHOD(FindRule)(VARIANT RuleNameOrId, ISpeechGrammarRule** ppRule );
    STDMETHOD(Item)(long Index, ISpeechGrammarRule** ppRule );
    STDMETHOD(get__NewEnum)(IUnknown** ppEnumVARIANT);
    STDMETHOD(Add)(BSTR RuleName, SpeechRuleAttributes Attributes, long RuleId, ISpeechGrammarRule** ppRule);
    STDMETHOD(Commit)(void);
    STDMETHOD(CommitAndSave)(BSTR* ErrorText, VARIANT* SaveStream);

    /*=== Member Data ===*/
    CRecoGrammar    *                               m_pCRecoGrammar;
    CSpBasicQueue<CSpeechGrammarRule, FALSE, FALSE> m_RuleObjList;
};

/*** CSpeechGrammarRule
*   This object is used to access a result phrase Element from
*   the associated speech reco result.
*/
class ATL_NO_VTABLE CSpeechGrammarRule : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechGrammarRule, &IID_ISpeechGrammarRule, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechGrammarRule)
	    COM_INTERFACE_ENTRY(ISpeechGrammarRule)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/

    /*--- Constructors/Destructors ---*/

    CSpeechGrammarRule()
    {
        m_pCGRules = NULL;
        m_HState = 0;
    }

    ~CSpeechGrammarRule()
    {
        m_HState = 0;
        if ( m_pCGRules )
        {
            m_pCGRules->m_RuleObjList.Remove( this );
            m_pCGRules->Release();
            m_pCGRules = NULL;
        }
    }

    /*--- Non interface methods ---*/

    void InvalidateStates(bool fInvalidateInitialState = false);

  /*=== Interfaces ====*/
  public:
    //--- ISpeechGrammarRule ----------------------------------
    STDMETHOD(get_Attributes)( SpeechRuleAttributes *pAttributes );
    STDMETHOD(get_InitialState)( ISpeechGrammarRuleState **ppState );
    STDMETHOD(get_Name)(BSTR *pName);
    STDMETHOD(get_Id)(long *pId);

    // Methods
    STDMETHOD(Clear)(void);
    STDMETHOD(AddResource)(const BSTR ResourceName, const BSTR ResourceValue);
    STDMETHOD(AddState)(ISpeechGrammarRuleState **ppState);

    /*=== Member Data ===*/
    SPSTATEHANDLE           m_HState;
    CSpeechGrammarRules *   m_pCGRules; // ref counted.
    CSpBasicQueue<CSpeechGrammarRuleState, FALSE, FALSE> m_StateObjList;

    // Used by CSpBasicQueue.
    CSpeechGrammarRule  *   m_pNext;    // Used by list implementation
    operator ==(const SPSTATEHANDLE h)
    {
        return h == m_HState;
    }
};


/*** CSpeechGrammarRuleState
*   This object is used to add new state changes on a Grammar.
*/
class ATL_NO_VTABLE CSpeechGrammarRuleState : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechGrammarRuleState, &IID_ISpeechGrammarRuleState, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechGrammarRuleState)
	    COM_INTERFACE_ENTRY(ISpeechGrammarRuleState)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

    // Override this to fix the jscript problem passing NULL objects.
    STDMETHOD(Invoke) ( DISPID          dispidMember,
                        REFIID          riid,
                        LCID            lcid,
                        WORD            wFlags,
                        DISPPARAMS 		*pdispparams,
                        VARIANT 		*pvarResult,
                        EXCEPINFO 		*pexcepinfo,
                        UINT 			*puArgErr);

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    CSpeechGrammarRuleState()
    {
        m_pCGRule = NULL;
        m_HState = 0;
        m_pCGRSTransWeak = NULL;
    }

    ~CSpeechGrammarRuleState()
    {
        SPDBG_ASSERT( m_pCGRSTransWeak == NULL );  // Should have no outstanding transition object at this point.
        m_HState = 0;
        if ( m_pCGRule )
        {
            m_pCGRule->m_StateObjList.Remove( this );
            m_pCGRule->Release();
            m_pCGRule = NULL;
        }
    }

    /*--- Non interface methods ---*/

    void InvalidateState();

  /*=== Interfaces ====*/
  public:
    //--- ISpeechGrammarRuleState ----------------------------------
    // Properties
    STDMETHOD(get_Rule)(ISpeechGrammarRule **ppRule);
    STDMETHOD(get_Transitions)(ISpeechGrammarRuleStateTransitions **ppTransitions);

    // Methods
    STDMETHOD(AddWordTransition)(ISpeechGrammarRuleState * pDestState, 
                                 const BSTR Words, 
                                 const BSTR Separators, 
                                 SpeechGrammarWordType Type,
                                 const BSTR PropertyName, 
                                 long PropertyId, 
                                 VARIANT* PropertyVarVal, 
                                 float Weight );
    STDMETHOD(AddRuleTransition)(ISpeechGrammarRuleState * pDestState, 
                                 ISpeechGrammarRule * pRule, 
                                 const BSTR PropertyName, 
                                 long PropertyId, 
                                 VARIANT* PropertyVarValue,
                                 float Weight );
    STDMETHOD(AddSpecialTransition)(ISpeechGrammarRuleState * pDestState, 
                                 SpeechSpecialTransitionType Type, 
                                 const BSTR PropertyName, 
                                 long PropertyId, 
                                 VARIANT* PropertyVarValue,
                                 float Weight );

    /*=== Member Data ===*/
    SPSTATEHANDLE                           m_HState;
    CSpeechGrammarRule *                    m_pCGRule; // Ref'd.
    CSpeechGrammarRuleStateTransitions *    m_pCGRSTransWeak;

    // Used by CSpBasicQueue.
    CSpeechGrammarRuleState  *   m_pNext;    // Used by list implementation
    operator ==(const SPSTATEHANDLE h)
    {
        return h == m_HState;
    }
};


/*** CSpeechGrammarRuleStateTransitions
*   This object is used to access the transitions out of a grammar state.
*/
class ATL_NO_VTABLE CSpeechGrammarRuleStateTransitions : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechGrammarRuleStateTransitions, &IID_ISpeechGrammarRuleStateTransitions, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechGrammarRuleStateTransitions)
	    COM_INTERFACE_ENTRY(ISpeechGrammarRuleStateTransitions)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    CSpeechGrammarRuleStateTransitions()
    {
        m_pCRuleState = NULL;
    }

    ~CSpeechGrammarRuleStateTransitions()
    {
        SPDBG_ASSERT( m_TransitionObjList.GetHead() == NULL );  // Should have no outstanding transition objects at this point.
        if ( m_pCRuleState )
        {
            m_pCRuleState->m_pCGRSTransWeak = NULL;
            m_pCRuleState->Release();
            m_pCRuleState = NULL;
        }
    }

    /*--- Non interface methods ---*/

    void InvalidateTransitions();

  /*=== Interfaces ====*/
  public:
    //--- ISpeechGrammarRuleStateTransitions ----------------------------------
    STDMETHOD(get_Count)(long* pVal);
    STDMETHOD(Item)(long Index, ISpeechGrammarRuleStateTransition ** ppTransition );
    STDMETHOD(get__NewEnum)(IUnknown** ppEnumVARIANT);

    /*=== Member Data ===*/
    CSpeechGrammarRuleState *   m_pCRuleState; // Ref'd
    CSpBasicQueue<CSpeechGrammarRuleStateTransition, FALSE, FALSE>  m_TransitionObjList;
};


/*** CSpeechGrammarRuleStateTransition
*   This object is used to represent an arc (transition) in the grammar.
*/
class ATL_NO_VTABLE CSpeechGrammarRuleStateTransition : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechGrammarRuleStateTransition, &IID_ISpeechGrammarRuleStateTransition, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechGrammarRuleStateTransition)
	    COM_INTERFACE_ENTRY(ISpeechGrammarRuleStateTransition)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    CSpeechGrammarRuleStateTransition()
    {
        m_pCRSTransitions = NULL;
        m_pCGRuleWeak = NULL;
        m_HStateFrom = 0;
        m_HStateTo = 0;
        m_Cookie = 0;
    }

    ~CSpeechGrammarRuleStateTransition()
    {
        m_pCGRuleWeak = NULL;
        m_HStateFrom = 0;
        m_HStateTo = 0;
        m_Cookie = 0;
        if ( m_pCRSTransitions )
        {
            m_pCRSTransitions->m_TransitionObjList.Remove( this );
            m_pCRSTransitions->Release();
            m_pCRSTransitions = NULL;
        }
    }

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechGrammarRuleStateTransition ----------------------------------
    // Properties
    STDMETHOD(get_Type)(SpeechGrammarRuleStateTransitionType * Type);
    STDMETHOD(get_Text)(BSTR * Text);
    STDMETHOD(get_Rule)(ISpeechGrammarRule ** ppRule);
    STDMETHOD(get_Weight)(VARIANT * Weight);
    STDMETHOD(get_PropertyName)(BSTR * Text);
    STDMETHOD(get_PropertyId)(long * Id);
    STDMETHOD(get_PropertyValue)(VARIANT * VariantValue);
    STDMETHOD(get_NextState)(ISpeechGrammarRuleState ** ppNextState);

    /*=== Member Data ===*/
    CSpeechGrammarRuleStateTransitions *    m_pCRSTransitions;  //Ref'd
    CSpeechGrammarRule *                    m_pCGRuleWeak;
    SPSTATEHANDLE                           m_HStateFrom;
    SPSTATEHANDLE                           m_HStateTo;
    VOID *                                  m_Cookie;   // We use this to identify a particular
                                                        // transition off of a state.  (really pArc).

    // Used by CSpBasicQueue.
    CSpeechGrammarRuleStateTransition  *   m_pNext;    // Used by list implementation
    operator ==(const VOID * cookie)
    {
        return cookie == m_Cookie;
    }
};
#endif // SAPI_AUTOMATION

#endif // a_srgrammar_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_srgrammar.cpp ===
/*******************************************************************************
* a_srgrammar.cpp *
*-------------*
*   Description:
*       This module is the implementation file for the the CSpeechGrammarRules
*   automation object and related objects.
*-------------------------------------------------------------------------------
*  Created By: TODDT                                        Date: 11/20/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "RecoCtxt.h"
#include "SrGrammar.h"
#include "a_enums.h"
#include "a_srgrammar.h"
#include "backend.h"
#include "a_helpers.h"

//
//=== ISpeechGrammarRules interface ==================================================
//

/*****************************************************************************
* CSpeechGrammarRules::InvalidateRules *
*----------------------*
*   Non-interface method
********************************************************************* TODDT ***/
void CSpeechGrammarRules::InvalidateRules(void)
{
    CSpeechGrammarRule * pRule;
    while( (pRule = m_RuleObjList.GetHead()) != NULL )
    {
        pRule->InvalidateStates(true); // Make sure we invalidate the intial state object.
        pRule->m_HState = NULL;
        m_RuleObjList.Remove(pRule);
    }
}

/*****************************************************************************
* CSpeechGrammarRules::InvalidateRuleStates *
*----------------------*
*   Non-interface method
********************************************************************* TODDT ***/
void CSpeechGrammarRules::InvalidateRuleStates(SPSTATEHANDLE hState)
{
    CSpeechGrammarRule * pRule = m_RuleObjList.Find(hState);

    if ( pRule )
    {
        pRule->InvalidateStates(); // This doesn't invalidate the initial state object.
    }
}

/*****************************************************************************
* CSpeechGrammarRules::get_Count *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRules::get_Count( long* pVal )
{
    SPDBG_FUNC( "CSpeechGrammarRules::get_Count" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pVal ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoGrammar->DefaultToDynamicGrammar();
    }

    if ( SUCCEEDED( hr ) )
    {
        if ( !m_pCRecoGrammar->m_cpCompiler )
        {
            *pVal = 0;
            //hr = m_pCRecoGrammar->m_fCmdLoaded ? SPERR_NOT_DYNAMIC_GRAMMAR : E_UNEXPECTED;
        }
        else
        {
            hr = m_pCRecoGrammar->m_cpCompiler->GetRuleCount( pVal );
        }
    }

    return hr;
} /* CSpeechGrammarRules::get_Count */

/*****************************************************************************
* CSpeechGrammarRules::get_Dynamic *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRules::get_Dynamic( VARIANT_BOOL *pDynamic )
{
    SPDBG_FUNC( "CSpeechGrammarRules::get_Dynamic" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pDynamic ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoGrammar->DefaultToDynamicGrammar();
    }

    if ( SUCCEEDED( hr ) )
    {
        *pDynamic = m_pCRecoGrammar->m_cpCompiler ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return hr;
} /* CSpeechGrammarRules::get_Dynamic */

/*****************************************************************************
* CSpeechGrammarRules::FindRule *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRules::FindRule( VARIANT varRuleNameOrId, ISpeechGrammarRule** ppRule )
{
    SPDBG_FUNC( "CSpeechGrammarRules::FindRule" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppRule ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoGrammar->DefaultToDynamicGrammar();
    }

    if ( SUCCEEDED( hr ) )
    {
        *ppRule = NULL;  //Default to returning NULL rule.

        // See if its a dynamic grammar
        if ( m_pCRecoGrammar->m_cpCompiler )
        {
            WCHAR *         pRuleName = NULL;
            DWORD           dwRuleId = 0;
            SPSTATEHANDLE   HState;

            // Figure out what to call GetRule with (rule name or Id).
            if ( (varRuleNameOrId.vt == VT_BSTR) || (varRuleNameOrId.vt == (VT_BSTR | VT_BYREF)) )
            {
                // Since we know this is a BSTR and not an array we don't have to worry about calling
                // UnaccessVariantData on the variant to unaccess a potential variant array.
                hr = AccessVariantData( &varRuleNameOrId, (BYTE**)&pRuleName, NULL );
            }
            else // This is the RuleId case.
            {
                ULONGLONG ull;

                hr = VariantToULongLong( &varRuleNameOrId, &ull );
                if ( SUCCEEDED( hr ) )
                {
                    // Now see if we overflowed a 32 bit value.
                    if ( ull & 0xFFFFFFFF00000000 )
                    {
                        hr = E_INVALIDARG;
                    }
                    else
                    {
                        dwRuleId = (DWORD)ull;
                    }
                }
            }

            if ( SUCCEEDED( hr ) )
            {
                hr = m_pCRecoGrammar->GetRule( pRuleName, dwRuleId, 0, false, &HState );
            }

            if ( SUCCEEDED( hr ) )
            {
                // See if we already have the rule object in our list first.
                *ppRule = m_RuleObjList.Find( HState );

                if ( *ppRule )
                {
                    (*ppRule)->AddRef();
                }
                else
                {
                    //--- Create the CSpeechGrammarRule object
                    CComObject<CSpeechGrammarRule> *pRule;
                    hr = CComObject<CSpeechGrammarRule>::CreateInstance( &pRule );
                    if ( SUCCEEDED( hr ) )
                    {
                        pRule->AddRef();
                        pRule->m_HState = HState;
                        pRule->m_pCGRules = this;
                        pRule->m_pCGRules->AddRef();  // keep ref
                        m_RuleObjList.InsertHead( pRule );  // Add to object list.
                        *ppRule = pRule;
                    }
                }
            }

            if ( hr == SPERR_RULE_NOT_FOUND)
            {
                hr = S_OK; // Didn't find rule OK, just return NULL rule.
            }
        }
    }

    return hr;
} /* CSpeechGrammarRules::FindRule */


/*****************************************************************************
* CSpeechGrammarRules::Item *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRules::Item( long Index, ISpeechGrammarRule** ppRule )
{
    SPDBG_FUNC( "CSpeechGrammarRules::Item" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppRule ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoGrammar->DefaultToDynamicGrammar();
    }

    if ( SUCCEEDED( hr ) )
    {
        if ( !m_pCRecoGrammar->m_cpCompiler )
        {
            hr = m_pCRecoGrammar->m_fCmdLoaded ? SPERR_NOT_DYNAMIC_GRAMMAR : E_UNEXPECTED;
        }
        else
        {
            SPSTATEHANDLE   HState;

            hr = m_pCRecoGrammar->m_cpCompiler->GetHRuleFromIndex( Index, &HState );

            if ( SUCCEEDED( hr ) )
            {
                // See if we already have the rule object in our list first.
                *ppRule = m_RuleObjList.Find( HState );

                if ( *ppRule )
                {
                    (*ppRule)->AddRef();
                }
                else
                {
                    //--- Create the CSpeechGrammarRule object
                    CComObject<CSpeechGrammarRule> *pRule;
                    hr = CComObject<CSpeechGrammarRule>::CreateInstance( &pRule );
                    if ( SUCCEEDED( hr ) )
                    {
                        pRule->AddRef();
                        pRule->m_HState = HState;
                        pRule->m_pCGRules = this;
                        pRule->m_pCGRules->AddRef();  // keep ref
                        m_RuleObjList.InsertHead( pRule );  // Add to object list.
                        *ppRule = pRule;
                    }
                }
            }
        }
    }

    return hr;
} /* CSpeechGrammarRules::Item */

/*****************************************************************************
* CSpeechGrammarRules::get__NewEnum *
*----------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechGrammarRules::get__NewEnum( IUnknown** ppEnumVARIANT )
{
    SPDBG_FUNC( "CSpeechGrammarRules::get__NewEnum" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppEnumVARIANT ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCRecoGrammar->DefaultToDynamicGrammar();
    }

    if ( SUCCEEDED( hr ) )
    {
        CComObject<CEnumGrammarRules>* pEnum;
        hr = CComObject<CEnumGrammarRules>::CreateInstance( &pEnum );
    
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_cpGramRules = this;
            *ppEnumVARIANT = pEnum;
        }
    }
    return hr;
} /* CSpeechGrammarRules::get__NewEnum */

/*****************************************************************************
* CSpeechGrammarRules::Add *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRules::Add( BSTR RuleName, SpeechRuleAttributes Attributes, long RuleId, ISpeechGrammarRule** ppRule )
{
    SPDBG_FUNC( "CSpeechGrammarRules::Add" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppRule ) )
    {
        hr = E_POINTER;
    }
    else if ( SP_IS_BAD_OPTIONAL_STRING_PTR( RuleName ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = m_pCRecoGrammar->DefaultToDynamicGrammar();
    }

    if ( SUCCEEDED( hr ) )
    {
        if ( !m_pCRecoGrammar->m_cpCompiler )
        {
            hr = m_pCRecoGrammar->m_fCmdLoaded ? SPERR_NOT_DYNAMIC_GRAMMAR : E_UNEXPECTED;
        }
        else
        {
            RuleName = EmptyStringToNull( RuleName );

            // First see if the rule already exists.  If it does then fail.
            hr = m_pCRecoGrammar->GetRule( RuleName, RuleId, (SPCFGRULEATTRIBUTES)Attributes, false, NULL );

            if ( hr == SPERR_RULE_NOT_FOUND )
            {
                //--- Create the CSpeechGrammarRule object
                CComObject<CSpeechGrammarRule> *pRule;
                hr = CComObject<CSpeechGrammarRule>::CreateInstance( &pRule );
                if ( SUCCEEDED( hr ) )
                {
                    pRule->AddRef();

                    hr = m_pCRecoGrammar->GetRule( RuleName, RuleId, (SPCFGRULEATTRIBUTES)Attributes, true, &(pRule->m_HState) );

                    if ( SUCCEEDED(hr) )
                    {
                        *ppRule = pRule;
                        pRule->m_pCGRules = this;
                        pRule->m_pCGRules->AddRef();    // keep ref
                        m_RuleObjList.InsertHead( pRule );  // Add to object list.
                    }
                    else
                    {
                        *ppRule = NULL;
                        pRule->Release();
                    }
                }
            }
            else if ( hr == S_OK )  // We found the rule so return a failure.
            {
                hr = SPERR_DUPLICATE_RULE_NAME;
            }
        }
    }

    return hr;
} /* CSpeechGrammarRules::Add */

/*****************************************************************************
* CSpeechGrammarRules::Commit *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRules::Commit( void )
{
    SPDBG_FUNC( "CSpeechGrammarRules::Commit" );
    HRESULT hr = S_OK;

    hr = m_pCRecoGrammar->DefaultToDynamicGrammar();

    if ( SUCCEEDED( hr ) )
    {
        if ( !m_pCRecoGrammar->m_cpCompiler )
        {
            hr = m_pCRecoGrammar->m_fCmdLoaded ? SPERR_NOT_DYNAMIC_GRAMMAR : E_UNEXPECTED;
        }
        else
        {
            hr = m_pCRecoGrammar->Commit(0);
        }
    }

    return hr;
} /* CSpeechGrammarRules::Commit */

/*****************************************************************************
* CSpeechGrammarRules::CommitAndSave *
*----------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechGrammarRules::CommitAndSave( BSTR* ErrorText, VARIANT* SaveStream )
{
    SPDBG_FUNC( "CSpeechGrammarRules::CommitAndSave" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ErrorText ) || SP_IS_BAD_WRITE_PTR( SaveStream ) )
    {
        hr = E_POINTER;
    }
    else if( !ErrorText )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = m_pCRecoGrammar->DefaultToDynamicGrammar();
    }

    if ( SUCCEEDED( hr ) )
    {
        if ( !m_pCRecoGrammar->m_cpCompiler )
        {
            hr = m_pCRecoGrammar->m_fCmdLoaded ? SPERR_NOT_DYNAMIC_GRAMMAR : E_UNEXPECTED;
        }
        else
        {
            CComPtr<IStream>    cpHStream;
            STATSTG             Stat;

            // Create a Win32 global stream
            hr = ::CreateStreamOnHGlobal( NULL, true, &cpHStream );
        
            // Save the current grammar to the global stream
            if( SUCCEEDED( hr ) )
            {
                CSpDynamicString dstrError;
                HRESULT hr2;
                hr = m_pCRecoGrammar->SaveCmd( cpHStream, &dstrError);
                hr2 = dstrError.CopyToBSTR(ErrorText);
                if ( SUCCEEDED( hr ) )
                {
                    hr = hr2;
                }
            }

            // Seek to beginning of stream
            if( SUCCEEDED( hr ) )
            {
                LARGE_INTEGER li; li.QuadPart = 0;
                hr = cpHStream->Seek( li, STREAM_SEEK_SET, NULL );
            }

            // Get the Stream size
            if( SUCCEEDED( hr ) )
            {
                hr = cpHStream->Stat( &Stat, STATFLAG_NONAME );
            }

            // Create a SafeArray to read the stream into and assign it to the VARIANT SaveStream
            if( SUCCEEDED( hr ) )
            {
                BYTE *pArray;
                SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, Stat.cbSize.LowPart );
                if( psa )
                {
                    if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
                    {
                        hr = cpHStream->Read( pArray, Stat.cbSize.LowPart, NULL );
                        SafeArrayUnaccessData( psa );
                        VariantClear( SaveStream );
                        SaveStream->vt     = VT_ARRAY | VT_UI1;
                        SaveStream->parray = psa;

                        // Free our memory if we failed.
                        if( FAILED( hr ) )
                        {
                            VariantClear( SaveStream );    
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            // Now we need to do the commit if everything is OK so far.
            if ( SUCCEEDED( hr ) )
            {
                hr = m_pCRecoGrammar->Commit(0);

                // Free our memory if we failed.
                if( FAILED( hr ) )
                {
                    VariantClear( SaveStream );    
                }
            }

        }
    }
    return hr;
} /* CSpeechGrammarRules::CommitAndSave */

//
//=== ISpeechGrammarRule interface ==================================================
//

/*****************************************************************************
* CSpeechGrammarRule::InvalidateStates *
*----------------------*
*   Non-interface method
********************************************************************* TODDT ***/
void CSpeechGrammarRule::InvalidateStates(bool fInvalidateInitialState)
{
    CSpeechGrammarRuleState * pState = m_StateObjList.GetHead();
    while ( pState != NULL )
    {
        if ( (pState->m_HState != m_HState) || fInvalidateInitialState )
        {
            pState->InvalidateState();
            m_StateObjList.Remove( pState );
        }
        pState = pState->m_pNext;
    }
}

/*****************************************************************************
* CSpeechGrammarRule::get_Attributes *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRule::get_Attributes( SpeechRuleAttributes *pAttributes )
{
    SPDBG_FUNC( "CSpeechGrammarRule::get_Attributes" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pAttributes ) )
    {
        hr = E_POINTER;
    }
    else if ( m_HState == 0 ) // Rules's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        hr = m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetAttributesFromHRule( m_HState, pAttributes );
    }

    return hr;
} /* CSpeechGrammarRule::get_Attributes */


/*****************************************************************************
* CSpeechGrammarRule::get_InitialState *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRule::get_InitialState( ISpeechGrammarRuleState **ppState )
{
    SPDBG_FUNC( "CSpeechGrammarRule::get_InitialState" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppState ) )
    {
        hr = E_POINTER;
    }
    else if ( m_HState == 0 ) // Rule's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        *ppState = m_StateObjList.Find( m_HState );

        if ( *ppState )
        {
            (*ppState)->AddRef();
        }
        else
        {
            //--- Create the CSpeechGrammarRuleState object
            CComObject<CSpeechGrammarRuleState> *pState;
            hr = CComObject<CSpeechGrammarRuleState>::CreateInstance( &pState );
            if ( SUCCEEDED( hr ) )
            {
                pState->AddRef();
                pState->m_HState = m_HState;
                pState->m_pCGRule = this;
                pState->m_pCGRule->AddRef();   // keep ref
                m_StateObjList.InsertHead( pState );
                *ppState = pState;
            }
        }
    }

    return hr;
} /* CSpeechGrammarRule::get_InitialState */

/*****************************************************************************
* CSpeechGrammarRule::get_Name *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRule::get_Name( BSTR *pName )
{
    SPDBG_FUNC( "CSpeechGrammarRule::get_Name" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pName ) )
    {
        hr = E_POINTER;
    }
    else if ( m_HState == 0 ) // Rules's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        WCHAR * pszName;
        hr = m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetNameFromHRule( m_HState, &pszName );

        if ( SUCCEEDED( hr ) )
        {
            CSpDynamicString szName(pszName);
            hr = szName.CopyToBSTR(pName);
        }
    }

    return hr;
} /* CSpeechGrammarRule::get_Name */

/*****************************************************************************
* CSpeechGrammarRule::get_Id *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRule::get_Id( long *pId )
{
    SPDBG_FUNC( "CSpeechGrammarRule::get_Id" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pId ) )
    {
        hr = E_POINTER;
    }
    else if ( m_HState == 0 ) // Rules's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        hr = m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetIdFromHRule( m_HState, pId );
    }

    return hr;
} /* CSpeechGrammarRule::get_Id */

/*****************************************************************************
* CSpeechGrammarRule::Clear *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRule::Clear( void )
{
    SPDBG_FUNC( "CSpeechGrammarRule::Clear" );

    if ( m_HState == 0 ) // Rule's been nuked in grammar.
    {
        return SPERR_ALREADY_DELETED;
    }

    // The ClearRule call does the work to mark all the various automation objects 
    // off the rule as invalid. 
    return m_pCGRules->m_pCRecoGrammar->ClearRule( m_HState );

} /* CSpeechGrammarRule::Clear */

/*****************************************************************************
* CSpeechGrammarRule::AddResource *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRule::AddResource( const BSTR ResourceName, const BSTR ResourceValue )
{
    SPDBG_FUNC( "CSpeechGrammarRule::AddResource" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_STRING_PTR( ResourceName ) || SP_IS_BAD_STRING_PTR( ResourceValue ) )
    {
        hr = E_POINTER;
    }
    else if ( m_HState == 0 ) // Rule's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        hr = m_pCGRules->m_pCRecoGrammar->AddResource( m_HState, ResourceName, ResourceValue );
    }

    return hr;
} /* CSpeechGrammarRule::AddResource */

/*****************************************************************************
* CSpeechGrammarRule::AddState *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRule::AddState( ISpeechGrammarRuleState **ppState )
{
    SPDBG_FUNC( "CSpeechGrammarRule::AddState" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppState ) )
    {
        hr = E_POINTER;
    }
    else if ( m_HState == 0 ) // Rule's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        //--- Create the CSpeechGrammarRuleState object
        CComObject<CSpeechGrammarRuleState> *pState;
        hr = CComObject<CSpeechGrammarRuleState>::CreateInstance( &pState );
        if ( SUCCEEDED( hr ) )
        {
            pState->AddRef();

            // Now create the new state
            SPSTATEHANDLE   hState;
            hr = m_pCGRules->m_pCRecoGrammar->CreateNewState( m_HState, &hState );

            if ( SUCCEEDED( hr ) )
            {
                pState->m_HState = hState;
                pState->m_pCGRule = this;
                pState->m_pCGRule->AddRef();   // keep ref
                m_StateObjList.InsertHead( pState );
                *ppState = pState;
            }
            else
            {
                *ppState = NULL;
                pState->Release();
            }
        }
    }

    return hr;
} /* CSpeechGrammarRule::AddState */


//
//=== ISpeechGrammarRuleState interface ==================================================
//

/*****************************************************************************
* CSpeechGrammarRuleState::Invoke *
*----------------------*
*   IDispatch::Invoke method override
********************************************************************* TODDT ***/
HRESULT CSpeechGrammarRuleState::Invoke(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
        // JScript cannot pass NULL VT_DISPATCH parameters and OLE doesn't convert them propertly so we
        // need to convert them here if we need to.
        if ( ((dispidMember == DISPID_SGRSAddWordTransition) || (dispidMember == DISPID_SGRSAddRuleTransition) || 
             (dispidMember == DISPID_SGRSAddSpecialTransition)) && (wFlags & DISPATCH_METHOD) && 
             pdispparams && (pdispparams->cArgs > 0) )
        {
            VARIANTARG * pvarg = &(pdispparams->rgvarg[pdispparams->cArgs-1]);

            if ( (pvarg->vt == VT_NULL) || (pvarg->vt == VT_EMPTY) )
            {
                pvarg->vt = VT_DISPATCH;
                pvarg->pdispVal = NULL;
            }
        }

        // Let ATL and OLE handle it now.
        return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
                    wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}

/*****************************************************************************
* CSpeechGrammarRuleState::InvalidateState *
*----------------------*
*   Non-interface method
********************************************************************* TODDT ***/
void CSpeechGrammarRuleState::InvalidateState()
{
    m_HState = 0;
    if ( m_pCGRSTransWeak )
    {
        m_pCGRSTransWeak->InvalidateTransitions();
    }
}

/*****************************************************************************
* CSpeechGrammarRuleState::get_Rule *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRuleState::get_Rule( ISpeechGrammarRule **ppRule )
{
    SPDBG_FUNC( "CSpeechGrammarRuleState::get_Rule" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppRule ) )
    {
        hr = E_POINTER;
    }
    else if ( m_HState == 0 ) // State's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        *ppRule = m_pCGRule;
        (*ppRule)->AddRef();
    }

    return hr;
} /* CSpeechGrammarRuleState::get_Rule */


/*****************************************************************************
* CSpeechGrammarRuleState::get_Transitions *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRuleState::get_Transitions( ISpeechGrammarRuleStateTransitions **ppTransitions )
{
    SPDBG_FUNC( "CSpeechGrammarRuleState::get_Transitions" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppTransitions ) )
    {
        hr = E_POINTER;
    }
    else if ( m_HState == 0 ) // State's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        if ( m_pCGRSTransWeak )
        {
            *ppTransitions = m_pCGRSTransWeak;
            (*ppTransitions)->AddRef();
        }
        else
        {
            // allocate CSpeechGrammarRuleStateTransitions object and remember the state it is associated with
            CComObject<CSpeechGrammarRuleStateTransitions> *pTransitions;
            hr = CComObject<CSpeechGrammarRuleStateTransitions>::CreateInstance( &pTransitions );
            if ( SUCCEEDED( hr ) )
            {
                pTransitions->AddRef();
                pTransitions->m_pCRuleState = this;    // need to keep ref on rule state
                pTransitions->m_pCRuleState->AddRef();
                m_pCGRSTransWeak = pTransitions;
                *ppTransitions = pTransitions;
            }
        }
    }

    return hr;
} /* CSpeechGrammarRuleState::get_Transitions */

/*****************************************************************************
* InitPropInfo *
*----------------------*
*       
********************************************************************* TODDT ***/
bool InitPropInfo( const BSTR bstrPropertyName, long PropertyId, VARIANT* pPropertyVarVal, SPPROPERTYINFO * pPropInfo )
{
    SPDBG_FUNC( "InitPropInfo" );

    memset( pPropInfo, 0, sizeof(*pPropInfo));  // Zero out.

    pPropInfo->ulId = PropertyId;
    pPropInfo->pszName = bstrPropertyName;

    if ( pPropertyVarVal )
    {
        bool fByRef = false;

        switch ( pPropertyVarVal->vt )
        {
            case (VT_BSTR | VT_BYREF):
                fByRef = true;
                // fall through...
            case VT_BSTR:
                pPropInfo->vValue.vt = VT_EMPTY; // Unused in string case.
                if ( fByRef )
                {
                    if ( pPropertyVarVal->pbstrVal )
                    {
                        pPropInfo->pszValue = *(pPropertyVarVal->pbstrVal);
                    }  // else leave pszValue as NULL.
                }
                else
                {
                    pPropInfo->pszValue = pPropertyVarVal->bstrVal;
                }

                // See if string is zero length, if so then zero it out.
                if ( !pPropInfo->pszValue || (wcslen(pPropInfo->pszValue) == 0) )
                {
                    pPropInfo->pszValue = NULL;
                    pPropertyVarVal = NULL; // Signal its the default variant.
                }
                break;

            case VT_NULL:
            case VT_EMPTY:
                pPropInfo->vValue = *pPropertyVarVal;
                pPropertyVarVal = NULL; // Signal its the default variant.
                break;

            default:
                pPropInfo->vValue = *pPropertyVarVal;
                break;
        }
    }

    // Return whether we have the PropertyInfo defaults.
    return ((pPropInfo->ulId == 0) && (pPropInfo->pszName == NULL) && !pPropertyVarVal);

} /* InitPropInfo */


/*****************************************************************************
* CSpeechGrammarRuleState::AddWordTransition *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRuleState::AddWordTransition( ISpeechGrammarRuleState * pDestState, 
                                                         const BSTR Words, 
                                                         const BSTR Separators,
                                                         SpeechGrammarWordType Type,
                                                         const BSTR bstrPropertyName, 
                                                         long PropertyId, 
                                                         VARIANT* pPropertyVarVal,
                                                         float Weight)
{
    SPDBG_FUNC( "CSpeechGrammarRuleState::AddWordTransition" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_INTERFACE_PTR( pDestState ) || SP_IS_BAD_OPTIONAL_STRING_PTR( Words ) ||
        SP_IS_BAD_OPTIONAL_STRING_PTR( Separators ) || SP_IS_BAD_OPTIONAL_STRING_PTR( bstrPropertyName ) ||
        (pPropertyVarVal && SP_IS_BAD_VARIANT_PTR( pPropertyVarVal )) ||
        (pDestState && ((CSpeechGrammarRuleState*)pDestState)->m_HState == 0) )
    {
        hr = E_INVALIDARG;
    }
    else if ( m_HState == 0 ) // State's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        SPSTATEHANDLE   hDestState = NULL;
        SPPROPERTYINFO PropInfo;

        // Make sure we convert our strings to NULL if they are empty.
        (BSTR)Words = EmptyStringToNull(Words);
        (BSTR)Separators = EmptyStringToNull(Separators);
        (BSTR)bstrPropertyName = EmptyStringToNull(bstrPropertyName);

        bool fDefaultValues = InitPropInfo(bstrPropertyName, PropertyId, pPropertyVarVal, &PropInfo);

        if ( pDestState )
        {
            hDestState = ((CSpeechGrammarRuleState*)pDestState)->m_HState;
        }

        hr = m_pCGRule->m_pCGRules->m_pCRecoGrammar->AddWordTransition( m_HState, 
                                                             hDestState, 
                                                             Words, 
                                                             Separators, 
                                                             (SPGRAMMARWORDTYPE)Type,
                                                             Weight, 
                                                             fDefaultValues ? NULL : &PropInfo );
    }

    return hr;
} /* CSpeechGrammarRuleState::AddWordTransition */

/*****************************************************************************
* CSpeechGrammarRuleState::AddRuleTransition *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRuleState::AddRuleTransition( ISpeechGrammarRuleState * pDestState, 
                                                        ISpeechGrammarRule * pRule, 
                                                        const BSTR bstrPropertyName, 
                                                        long PropertyId, 
                                                        VARIANT* pPropertyVarVal,
                                                        float Weight )
{
    SPDBG_FUNC( "CSpeechGrammarRuleState::AddRuleTransition" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_INTERFACE_PTR( pDestState ) || SP_IS_BAD_INTERFACE_PTR( pRule ) || 
        (((CSpeechGrammarRule*)pRule)->m_HState == 0) || SP_IS_BAD_OPTIONAL_STRING_PTR( bstrPropertyName ) ||
        (pPropertyVarVal && SP_IS_BAD_VARIANT_PTR( pPropertyVarVal )) ||
        (pDestState && ((CSpeechGrammarRuleState*)pDestState)->m_HState == 0) )
    {
        hr = E_INVALIDARG;
    }
    else if ( m_HState == 0 ) // State's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        SPSTATEHANDLE   hDestState = NULL;
        SPSTATEHANDLE   hRuleRef = NULL;
        SPPROPERTYINFO PropInfo;

        (BSTR)bstrPropertyName = EmptyStringToNull(bstrPropertyName);

        bool fDefaultValues = InitPropInfo(bstrPropertyName, PropertyId, pPropertyVarVal, &PropInfo);

        if ( pDestState )
        {
            hDestState = ((CSpeechGrammarRuleState*)pDestState)->m_HState;
        }
        if ( pRule )
        {
            hRuleRef = ((CSpeechGrammarRule*)pRule)->m_HState;
        }

        hr = m_pCGRule->m_pCGRules->m_pCRecoGrammar->AddRuleTransition( m_HState, 
                                                             hDestState, 
                                                             hRuleRef, 
                                                             Weight, 
                                                             fDefaultValues ? NULL : &PropInfo );
    }

    return hr;
} /* CSpeechGrammarRuleState::AddRuleTransition */

/*****************************************************************************
* CSpeechGrammarRuleState::AddSpecialTransition *
*----------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechGrammarRuleState::AddSpecialTransition( ISpeechGrammarRuleState * pDestState, 
                                                        SpeechSpecialTransitionType Type, 
                                                        const BSTR bstrPropertyName, 
                                                        long PropertyId,
                                                        VARIANT* pPropertyVarVal,
                                                        float Weight )
{
    SPDBG_FUNC( "CSpeechGrammarRuleState::AddSpecialTransition" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_INTERFACE_PTR( pDestState ) || SP_IS_BAD_OPTIONAL_STRING_PTR( bstrPropertyName ) ||
        (pPropertyVarVal && SP_IS_BAD_VARIANT_PTR(pPropertyVarVal))  ||
        (pDestState && ((CSpeechGrammarRuleState*)pDestState)->m_HState == 0) )
    {
        hr = E_INVALIDARG;
    }
    else if ( m_HState == 0 ) // State's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        SPSTATEHANDLE   hDestState = NULL;
        SPSTATEHANDLE   hRuleRef = NULL;

        if ( pDestState )
        {
            hDestState = ((CSpeechGrammarRuleState*)pDestState)->m_HState;
        }
        switch( Type )
        {
            case SSTTWildcard:
                hRuleRef = SPRULETRANS_WILDCARD;
                break;
            case SSTTDictation:
                hRuleRef = SPRULETRANS_DICTATION;
                break;
            case SSTTTextBuffer:
                hRuleRef = SPRULETRANS_TEXTBUFFER;
                break;
            default:
                hr = E_INVALIDARG;
                break;
        }
        if ( SUCCEEDED( hr ) )
        {
            SPPROPERTYINFO PropInfo;

            (BSTR)bstrPropertyName = EmptyStringToNull(bstrPropertyName);

            bool fDefaultValues = InitPropInfo(bstrPropertyName, PropertyId, pPropertyVarVal, &PropInfo);

            hr = m_pCGRule->m_pCGRules->m_pCRecoGrammar->AddRuleTransition( m_HState, 
                                                                 hDestState, 
                                                                 hRuleRef, 
                                                                 Weight, 
                                                                 fDefaultValues ? NULL : &PropInfo );
        }
    }

    return hr;
} /* CSpeechGrammarRuleState::AddSpecialTransition */


//
//=== ISpeechGrammarRuleStateTransitions interface ==================================================
//

/*****************************************************************************
* CSpeechGrammarRuleStateTransitions::InvalidateTransitions *
*----------------------*
*   Non-interface method
********************************************************************* TODDT ***/
void CSpeechGrammarRuleStateTransitions::InvalidateTransitions(void)
{
    CSpeechGrammarRuleStateTransition * pTrans = NULL;
    while ( (pTrans = m_TransitionObjList.GetHead()) != NULL )
    {
        pTrans->m_Cookie = NULL;
        pTrans->m_HStateFrom = 0;
        pTrans->m_HStateTo = 0;
        m_TransitionObjList.Remove( pTrans );
    }
}

/****************************************************************************
* CSpeechGrammarRuleStateTransitions::get_Count *
*-----------------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
HRESULT CSpeechGrammarRuleStateTransitions::get_Count(long * pVal)
{
    SPDBG_FUNC("CSpeechGrammarRuleStateTransitions::get_Count");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( pVal ) )
    {
        hr = E_POINTER;
    }
    else if ( m_pCRuleState->m_HState == 0 ) // Rules's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        hr = m_pCRuleState->m_pCGRule->m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetTransitionCount( m_pCRuleState->m_HState, pVal );
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpeechGrammarRuleStateTransitions::Item *
*------------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
STDMETHODIMP CSpeechGrammarRuleStateTransitions::Item(long Index, ISpeechGrammarRuleStateTransition **ppTransition)
{
    SPDBG_FUNC("CSpeechGrammarRuleStateTransitions::Item");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( ppTransition ) )
    {
        hr = E_POINTER;
    }
    else if ( m_pCRuleState->m_HState == 0 ) // Rules's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        VOID * Cookie = 0;

        hr = m_pCRuleState->m_pCGRule->m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetTransitionCookie( m_pCRuleState->m_HState, Index, &Cookie );

        if( SUCCEEDED(hr) )
        {
            *ppTransition = m_TransitionObjList.Find( Cookie );
            if ( *ppTransition )
            {
                (*ppTransition)->AddRef();
            }
            else
            {
                // allocate new CSpeechGramamrRuleStateTransition and store necessary info to identify the arc
                CComObject<CSpeechGrammarRuleStateTransition> *pTransition;
                hr = CComObject<CSpeechGrammarRuleStateTransition>::CreateInstance( &pTransition );
                if ( SUCCEEDED( hr ) )
                {
                    pTransition->AddRef();
                    pTransition->m_pCGRuleWeak = m_pCRuleState->m_pCGRule;
                    pTransition->m_Cookie = Cookie;
                    pTransition->m_HStateFrom = m_pCRuleState->m_HState;
                    pTransition->m_pCRSTransitions = this;
                    pTransition->m_pCRSTransitions->AddRef();  //Ref'd
                    *ppTransition = pTransition;
                    m_TransitionObjList.InsertHead( pTransition );
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpeechGrammarRuleStateTransitions::get__NewEnum *
*--------------------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
STDMETHODIMP CSpeechGrammarRuleStateTransitions::get__NewEnum(IUnknown **ppEnumVARIANT)
{
    SPDBG_FUNC("CSpeechGrammarRuleStateTransitions::get__NewEnum");
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppEnumVARIANT ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComObject<CEnumTransitions>* pEnum;
        hr = CComObject<CEnumTransitions>::CreateInstance( &pEnum );
        
        if( SUCCEEDED( hr ) )
        {
            pEnum->AddRef();
            pEnum->m_cpTransitions = this;
            *ppEnumVARIANT = pEnum;
        }
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


//
//=== ISpeechGrammarRuleStateTransition interface ==================================================
//

/****************************************************************************
* CSpeechGrammarRuleStateTransition::get_Type *
*---------------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
STDMETHODIMP CSpeechGrammarRuleStateTransition::get_Type(SpeechGrammarRuleStateTransitionType* pType)
{
    SPDBG_FUNC("CSpeechGrammarRuleStateTransition::get_Type");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( pType ) )
    {
        hr = E_POINTER;
    }
    else if ( (m_HStateFrom == 0) || (m_Cookie == 0) ) // state's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        VARIANT_BOOL fIsWord;
        ULONG ulSpecialTransition = 0;
        hr = m_pCGRuleWeak->m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetTransitionType( m_HStateFrom, m_Cookie,
                                                                                          &fIsWord, &ulSpecialTransition);
        if (fIsWord == VARIANT_TRUE)
        {
            *pType = (ulSpecialTransition) ? SGRSTTWord : SGRSTTEpsilon; // ulSpecialTransition == index of word --> 0 = epsilon
        }
        else if (ulSpecialTransition != 0)
        {
            *pType = (ulSpecialTransition == SPDICTATIONTRANSITION) ? SGRSTTDictation :
                    (ulSpecialTransition == SPWILDCARDTRANSITION) ? SGRSTTWildcard : SGRSTTTextBuffer;
        }
        else
        {
            *pType = SGRSTTRule;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpeechGrammarRuleStateTransition::get_Text *
*---------------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
STDMETHODIMP CSpeechGrammarRuleStateTransition::get_Text(BSTR * pText)
{
    SPDBG_FUNC("CSpeechGrammarRuleStateTransition::get_Text");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( pText ) )
    {
        hr = E_POINTER;
    }
    else if ( (m_HStateFrom == 0) || (m_Cookie == 0) ) // state's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        hr = m_pCGRuleWeak->m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetTransitionText( m_HStateFrom, m_Cookie, pText);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CSpeechGrammarRuleStateTransition::get_Rule *
*---------------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
STDMETHODIMP CSpeechGrammarRuleStateTransition::get_Rule(ISpeechGrammarRule ** ppRule)
{
    SPDBG_FUNC("CSpeechGrammarRuleStateTransition::get_Rule");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( ppRule ) )
    {
        hr = E_POINTER;
    }
    else if ( (m_HStateFrom == 0) || (m_Cookie == 0) ) // state's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        SPSTATEHANDLE hRule;
        hr = m_pCGRuleWeak->m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetTransitionRule(m_HStateFrom, m_Cookie, &hRule);
        if (SUCCEEDED(hr) && hRule )
        {
            // First see if rule is in rule the cache.
            *ppRule = m_pCGRuleWeak->m_pCGRules->m_RuleObjList.Find( hRule );

            if ( *ppRule )
            {
                (*ppRule)->AddRef();
            }
            else
            {
                //--- Create the CSpeechGrammarRule object
                CComObject<CSpeechGrammarRule> *pRule;
                hr = CComObject<CSpeechGrammarRule>::CreateInstance( &pRule );
                if ( SUCCEEDED( hr ) )
                {
                    pRule->AddRef();
                    pRule->m_HState = hRule;
                    pRule->m_pCGRules = m_pCGRuleWeak->m_pCGRules;
                    pRule->m_pCGRules->AddRef();    // keep ref
                    *ppRule = pRule;
                }
            }
        }
        else
        {
            // Either got an error or we don't have a rule.  Return the HR but 
            // make sure we return a NULL *ppRule for the S_OK case (not a rule ref).
            *ppRule = NULL;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpeechGrammarRuleStateTransition::get_Weight *
*-----------------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
STDMETHODIMP CSpeechGrammarRuleStateTransition::get_Weight(VARIANT * pWeight)
{
    SPDBG_FUNC("CSpeechGrammarRuleStateTransition::get_Weight");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( pWeight ) )
    {
        hr = E_POINTER;
    }
    else if ( (m_HStateFrom == 0) || (m_Cookie == 0) ) // state's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        hr = m_pCGRuleWeak->m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetTransitionWeight( m_HStateFrom, m_Cookie, pWeight);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CSpeechGrammarRuleStateTransition::get_PropertyName *
*-----------------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
STDMETHODIMP CSpeechGrammarRuleStateTransition::get_PropertyName(BSTR * pText)
{
    SPDBG_FUNC("CSpeechGrammarRuleStateTransition::get_PropertyName");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( pText ) )
    {
        hr = E_POINTER;
    }
    else if ( (m_HStateFrom == 0) || (m_Cookie == 0) ) // state's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        SPTRANSITIONPROPERTY prop;
        hr = m_pCGRuleWeak->m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetTransitionProperty(m_HStateFrom, m_Cookie, &prop);
        if (SUCCEEDED(hr))
        {
            CComBSTR bstr(prop.pszName);
            hr = bstr.CopyTo(pText);
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpeechGrammarRuleStateTransition::get_PropertyId *
*-----------------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
STDMETHODIMP CSpeechGrammarRuleStateTransition::get_PropertyId(long * pId)
{
    SPDBG_FUNC("CSpeechGrammarRuleStateTransition::get_PropertyId");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( pId ) )
    {
        hr = E_POINTER;
    }
    else if ( (m_HStateFrom == 0) || (m_Cookie == 0) ) // state's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        SPTRANSITIONPROPERTY prop;
        hr = m_pCGRuleWeak->m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetTransitionProperty(m_HStateFrom, m_Cookie, &prop);
        if (SUCCEEDED(hr))
        {
            *pId = prop.ulId;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpeechGrammarRuleStateTransition::get_PropertyValue *
*-----------------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
STDMETHODIMP CSpeechGrammarRuleStateTransition::get_PropertyValue(VARIANT * pVarVal)
{
    SPDBG_FUNC("CSpeechGrammarRuleStateTransition::get_PropertyValue");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( pVarVal ) )
    {
        hr = E_POINTER;
    }
    else if ( (m_HStateFrom == 0) || (m_Cookie == 0) ) // state's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        SPTRANSITIONPROPERTY prop;
        hr = m_pCGRuleWeak->m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetTransitionProperty(m_HStateFrom, m_Cookie, &prop);
        if (SUCCEEDED(hr))
        {
            if(prop.pszValue && prop.pszValue[0] != L'\0')
            {
                BSTR bstr = ::SysAllocString(prop.pszValue);
                if(bstr)
                {
                    VariantClear(pVarVal);
                    pVarVal->vt = VT_BSTR;
                    pVarVal->bstrVal = bstr;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                VariantClear(pVarVal);
                hr = VariantCopy(pVarVal, &prop.vValue);
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CSpeechGrammarRuleStateTransition::get_NextState *
*--------------------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
STDMETHODIMP CSpeechGrammarRuleStateTransition::get_NextState(ISpeechGrammarRuleState ** ppNextState)
{
    SPDBG_FUNC("CSpeechGrammarRuleStateTransition::get_NextState");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( ppNextState ) )
    {
        hr = E_POINTER;
    }
    else if ( (m_HStateFrom == 0) || (m_Cookie == 0) ) // state's been nuked in grammar.
    {
        hr = SPERR_ALREADY_DELETED;
    }
    else
    {
        *ppNextState = NULL;

        if ( m_HStateTo == 0 )
        {
            hr = m_pCGRuleWeak->m_pCGRules->m_pCRecoGrammar->m_cpCompiler->GetTransitionNextState( m_HStateFrom, m_Cookie, &m_HStateTo);
        }

        if (SUCCEEDED(hr) && (m_HStateTo != 0))
        {
            *ppNextState = m_pCGRuleWeak->m_StateObjList.Find( m_HStateTo );
            if ( *ppNextState )
            {
                (*ppNextState)->AddRef();
            }
            else
            {
                //--- Create the CSpeechGrammarRuleState object
                CComObject<CSpeechGrammarRuleState> *pState;
                hr = CComObject<CSpeechGrammarRuleState>::CreateInstance( &pState );
                if ( SUCCEEDED( hr ) )
                {
                    pState->AddRef();
                    pState->m_HState = m_HStateTo;
                    pState->m_pCGRule = m_pCGRuleWeak;
                    pState->m_pCGRule->AddRef();   // keep ref
                    m_pCGRuleWeak->m_StateObjList.InsertHead( pState );
                    *ppNextState = pState;
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_token.cpp ===
/*******************************************************************************
* a_tokens.cpp *
*-------------*
*   Description:
*       This module is the main implementation file for the CSpObjectTokenEnumBuilder,
*   CEnumTokens and CSpRegistryObjectToken automation methods.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 01/07/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "ObjectToken.h"
#include "ObjectTokenEnumBuilder.h"
//#include "RegDataKey.h"
#include "a_helpers.h"

#ifdef SAPI_AUTOMATION

/*** CEnumTokens
*   This object is used to enum the tokens via variants
*/
class ATL_NO_VTABLE CEnumTokens : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IEnumVARIANT
{
  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CEnumTokens)
		COM_INTERFACE_ENTRY(IEnumVARIANT)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- IEnumVARIANT ----------------------------------
	STDMETHOD(Next)(ULONG celt, VARIANT* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt) { return m_cpTokenEnum->Skip( celt ); }
	STDMETHOD(Reset)(void) { return m_cpTokenEnum->Reset(); }
	STDMETHOD(Clone)(IEnumVARIANT** ppEnum);

  /*=== Member Data ===*/
    CComPtr<IEnumSpObjectTokens>    m_cpTokenEnum;
};

//

/*****************************************************************************
* CSpObjectTokenEnumBuilder::Item *
*---------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectTokenEnumBuilder::Item( long Index, ISpeechObjectToken** ppToken )
{
    SPDBG_FUNC( "CSpObjectTokenEnumBuilder::Item" );
    HRESULT hr = S_OK;

    if(Index < 0)
    {
        hr = E_INVALIDARG;
    }

    CComPtr<ISpObjectToken> cpToken;
    if( SUCCEEDED( hr ) )
    {
        hr = Item( Index, &cpToken );
    }

    if( hr == S_FALSE )
    {
        hr = SPERR_NO_MORE_ITEMS;
    }
    else if( SUCCEEDED( hr ) )
    {
        hr = cpToken.QueryInterface( ppToken );
    }

    return hr;
} /* CSpObjectTokenEnumBuilder::Item */

/*****************************************************************************
* CSpObjectTokenEnumBuilder::get_Count *
*--------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectTokenEnumBuilder::get_Count( long* pVal )
{
    SPDBG_FUNC( "CSpObjectTokenEnumBuilder::get_Count" );
    return GetCount( (ULONG*)pVal );
} /* CSpObjectTokenEnumBuilder::get_Count */

/*****************************************************************************
* CSpObjectTokenEnumBuilder::get__NewEnum *
*-----------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectTokenEnumBuilder::get__NewEnum( IUnknown** ppEnumVARIANT )
{
    SPDBG_FUNC( "CSpObjectTokenEnumBuilder::get__NewEnum" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppEnumVARIANT ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComObject<CEnumTokens>* pEnum;
        if( SUCCEEDED( hr = CComObject<CEnumTokens>::CreateInstance( &pEnum ) ) )
        {
            pEnum->AddRef();
            if( SUCCEEDED( hr = Clone( &pEnum->m_cpTokenEnum ) ) )
            {
                pEnum->m_cpTokenEnum->Reset();
                *ppEnumVARIANT = pEnum;
            }
            else
            {
                pEnum->Release();
            }
        }
    }
    return hr;
} /* CSpObjectTokenEnumBuilder::get__NewEnum */

//
//=== IEnumVARIANT interface =================================================
//

/*****************************************************************************
* CEnumTokens::Next *
*-------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CEnumTokens::Next(ULONG celt, VARIANT* rgelt, ULONG* pceltFetched)
{
    SPDBG_FUNC( "CEnumTokens::Next" );
    HRESULT hr = S_OK;
    ULONG i;

    for( i = 0; SUCCEEDED(hr) && i < celt; ++i )
    {
        ISpObjectToken* pToken;
        if( hr = m_cpTokenEnum->Next( 1, &pToken, NULL ) != S_OK )
        {
            break;
        }
        rgelt[i].vt = VT_DISPATCH;
        pToken->QueryInterface( IID_IDispatch, (void**)&rgelt[i].pdispVal );
        pToken->Release();
    }

    if( pceltFetched )
    {
        *pceltFetched = i;
    }
    return hr;
} /* CEnumTokens::Next */

/*****************************************************************************
* CEnumTokens::Clone *
*--------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CEnumTokens::Clone( IEnumVARIANT** ppEnum )
{
    SPDBG_FUNC( "CEnumTokens::Clone" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppEnum ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *ppEnum = NULL;
        CComObject<CEnumTokens>* pEnum;
        if( SUCCEEDED( hr = CComObject<CEnumTokens>::CreateInstance( &pEnum ) ) )
        {
            pEnum->AddRef();
            if( SUCCEEDED( hr = m_cpTokenEnum->Clone( &pEnum->m_cpTokenEnum ) ) )
            {
                *ppEnum = pEnum;
            }
            else
            {
                pEnum->Release();
            }
        }
    }
    return hr;
} /* CEnumTokens::Clone */


//
//=== ISpeechDataKey ============================================================
//

/*****************************************************************************
* CSpeechDataKey::SetBinaryValue *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechDataKey::SetBinaryValue( const BSTR bstrValueName, VARIANT pvtData )
{
    SPDBG_FUNC( "CSpeechDataKey::SetValue" );
    HRESULT hr = S_OK;

    BYTE * pData = NULL;
    ULONG ulDataSize = 0;
    bool fIsString = false;

    hr = AccessVariantData( &pvtData, &pData, &ulDataSize, NULL, &fIsString );

    if( SUCCEEDED( hr ) )
    {
        if ( !fIsString )
        {
            hr = m_cpDataKey->SetData( EmptyStringToNull(bstrValueName), ulDataSize, pData );
        }
        else
        {
            hr = E_INVALIDARG;  // We don't allow strings.  Use SetStringValue for those.
        }
        UnaccessVariantData( &pvtData, pData );
    }
    
    return hr;
} /* CSpeechDataKey::SetBinaryValue */

/*****************************************************************************
* CSpeechDataKey::GetBinaryValue *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechDataKey::GetBinaryValue( const BSTR bstrValueName, VARIANT* pvtData )
{
    SPDBG_FUNC( "CSpeechDataKey::GetBinaryValue" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pvtData ) )
    {
        hr = E_POINTER;
    }
    else if ( SP_IS_BAD_OPTIONAL_STRING_PTR( bstrValueName ) )
    {
        hr = E_INVALIDARG;
    }
    {
        DWORD dwSize;

        (BSTR)bstrValueName = EmptyStringToNull( bstrValueName );

        hr = m_cpDataKey->GetData( bstrValueName, &dwSize, NULL );

        if( SUCCEEDED( hr ) )
        {
            BYTE *pArray;
            SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, dwSize );
            if( psa )
            {
                if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
                {
                    hr = m_cpDataKey->GetData( bstrValueName, &dwSize, pArray );
                    SafeArrayUnaccessData( psa );
                    VariantClear(pvtData);
                    pvtData->vt     = VT_ARRAY | VT_UI1;
                    pvtData->parray = psa;

                    if ( !SUCCEEDED( hr ) )
                    {
                        VariantClear(pvtData);    // Free our memory if we failed.
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
} /* CSpeechDataKey::GetBinaryValue */

/*****************************************************************************
* CSpeechDataKey::SetStringValue *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechDataKey::SetStringValue( const BSTR bstrValueName, const BSTR szString )
{
    SPDBG_FUNC( "CSpeechDataKey::SetStringValue" );
  
    return m_cpDataKey->SetStringValue( (const WCHAR *)EmptyStringToNull(bstrValueName), (const WCHAR *)szString );
} /* CSpeechDataKey::SetStringValue */

/*****************************************************************************
* CSpeechDataKey::GetStringValue *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechDataKey::GetStringValue( const BSTR bstrValueName,  BSTR * ppszString )
{
    SPDBG_FUNC( "CSpeechDataKey::GetStringValue" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppszString ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CSpDynamicString pStr;
        hr = m_cpDataKey->GetStringValue( (const WCHAR *)EmptyStringToNull(bstrValueName), (WCHAR **)&pStr );
        if( SUCCEEDED( hr ) )
        {
            hr = pStr.CopyToBSTR(ppszString);
        }
    }

    return hr;
} /* CSpeechDataKey::GetStringValue */

/*****************************************************************************
* CSpeechDataKey::SetLongValue *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechDataKey::SetLongValue( const BSTR bstrValueName, long Long )
{
    SPDBG_FUNC( "CSpeechDataKey::SetLongValue" );
   
    return m_cpDataKey->SetDWORD( EmptyStringToNull(bstrValueName), Long );
} /* CSpeechDataKey::SetLongValue */

/*****************************************************************************
* CSpeechDataKey::GetLongValue *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechDataKey::GetLongValue( const BSTR bstrValueName, long* pLong )
{
    SPDBG_FUNC( "CSpeechDataKey::GetLongValue" );

    return m_cpDataKey->GetDWORD( EmptyStringToNull(bstrValueName), (DWORD*)pLong );
} /* CSpeechDataKey::GetLongValue */

/*****************************************************************************
* CSpeechDataKey::OpenKey *
*-------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechDataKey::OpenKey( const BSTR bstrSubKeyName, ISpeechDataKey** ppSubKey )
{
    SPDBG_FUNC( "CSpeechDataKey::OpenKey" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppSubKey ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpDataKey> cpKey;
        hr = m_cpDataKey->OpenKey( bstrSubKeyName, &cpKey );
        if( SUCCEEDED( hr ) )
        {
            *ppSubKey = NULL;
            CComObject<CSpeechDataKey>* pSubKey;

            hr = CComObject<CSpeechDataKey>::CreateInstance( &pSubKey );
            if( SUCCEEDED( hr ) )
            {
                pSubKey->AddRef();
                pSubKey->m_cpDataKey = cpKey;
                *ppSubKey = pSubKey;
            }
        }
    }

    return hr;
} /* CSpeechDataKey::OpenKey */

/*****************************************************************************
* CSpeechDataKey::CreateKey *
*---------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechDataKey::CreateKey( const BSTR bstrSubKeyName, ISpeechDataKey** ppSubKey )
{
    SPDBG_FUNC( "CSpeechDataKey::CreateKey" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppSubKey ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpDataKey> cpKey;
        hr = m_cpDataKey->CreateKey( bstrSubKeyName, &cpKey );
        if( SUCCEEDED( hr ) )
        {
            *ppSubKey = NULL;
            CComObject<CSpeechDataKey>* pSubKey;

            hr = CComObject<CSpeechDataKey>::CreateInstance( &pSubKey );
            if( SUCCEEDED( hr ) )
            {
                pSubKey->AddRef();
                pSubKey->m_cpDataKey = cpKey;
                *ppSubKey = pSubKey;
            }
        }
    }

    return hr;
} /* CSpeechDataKey::CreateKey */

/*****************************************************************************
* CSpeechDataKey::DeleteKey *
*---------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechDataKey::DeleteKey( const BSTR bstrSubKeyName )
{
    SPDBG_FUNC( "CSpeechDataKey::DeleteKey" );
    return m_cpDataKey->DeleteKey( (WCHAR*)bstrSubKeyName );
} /* CSpeechDataKey::DeleteKey */

/*****************************************************************************
* CSpeechDataKey::DeleteValue *
*-----------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechDataKey::DeleteValue( const BSTR bstrValueName )
{
    SPDBG_FUNC( "CSpeechDataKey::DeleteValue" );
    return m_cpDataKey->DeleteValue( (WCHAR*)EmptyStringToNull(bstrValueName) );
} /* CSpeechDataKey::DeleteValue */

/*****************************************************************************
* CSpeechDataKey::EnumKeys *
*--------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechDataKey::EnumKeys( long Index, BSTR* pbstrSubKeyName )
{
    SPDBG_FUNC( "CSpeechDataKey::EnumKeys" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pbstrSubKeyName ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CSpDynamicString szName;
        hr = m_cpDataKey->EnumKeys( (ULONG)Index, &szName );
        if( hr == S_OK )
        {
            hr = szName.CopyToBSTR(pbstrSubKeyName);
        }
    }

    return hr;
} /* CSpeechDataKey::EnumKeys */

/*****************************************************************************
* CSpeechDataKey::EnumValues *
*----------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpeechDataKey::EnumValues( long Index, BSTR* pbstrValueName )
{
    SPDBG_FUNC( "CSpeechDataKey::EnumValues (automation)" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pbstrValueName ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CSpDynamicString szName;
        hr = m_cpDataKey->EnumValues( (ULONG)Index, &szName );
        if( hr == S_OK )
        {
            hr = szName.CopyToBSTR(pbstrValueName);
        }
    }

    return hr;
} /* CSpeechDataKey::EnumValues */


//
//=== ISpeechObjectToken ============================================================
//

/*****************************************************************************
* CSpObjectToken::get_Id *
*--------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectToken::get_Id( BSTR* pObjectId )
{
    SPDBG_FUNC( "CSpObjectToken::get_Id" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( pObjectId ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CSpDynamicString szId;
        if( (hr = GetId( &szId )) == S_OK )
        {
            hr = szId.CopyToBSTR( pObjectId );
        }
    }		
	return hr;
} /* CSpObjectToken::get_Id */

/*****************************************************************************
* CSpObjectToken::get_DataKey *
*-----------------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpObjectToken::get_DataKey( ISpeechDataKey** ppDataKey )
{
    SPDBG_FUNC( "CSpObjectToken::get_DataKey" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( ppDataKey ) )
    {
        hr = E_POINTER;
    }
    else
    {
        if (m_dstrTokenId == NULL)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else if (m_fKeyDeleted)
        {
            hr = SPERR_TOKEN_DELETED;
        }
        else
        {
            *ppDataKey = NULL;
            CComObject<CSpeechDataKey>* pDataKey;

            hr = CComObject<CSpeechDataKey>::CreateInstance( &pDataKey );
            if( SUCCEEDED( hr ) )
            {
                pDataKey->AddRef();
                pDataKey->m_cpDataKey = this;
                *ppDataKey = pDataKey;
            }
        }
    }		
	return hr;
} /* CSpObjectToken::get_DataKey */


/*****************************************************************************
* CSpObjectToken::get_Category *
*-----------------------------------------*
*       
********************************************************************* TODDT **/
STDMETHODIMP CSpObjectToken::get_Category( ISpeechObjectTokenCategory** ppCategory )
{
    SPDBG_FUNC( "CSpObjectToken::get_Category" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppCategory ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpObjectTokenCategory> cpTokenCategory;
        hr = GetCategory( &cpTokenCategory );

        if( SUCCEEDED( hr ) )
        {
            hr = cpTokenCategory.QueryInterface( ppCategory );
        }
    }

	return hr;
} /* CSpObjectToken::get_Category */


/*****************************************************************************
* CSpObjectToken::GetDescription *
*-----------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectToken::GetDescription( long LocaleId, BSTR* pDescription )
{
    SPDBG_FUNC( "CSpObjectToken::GetDescription" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pDescription ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CSpDynamicString szName;
        hr = SpGetDescription( this, &szName, LANGIDFROMLCID(LocaleId) );
        if (hr == S_OK)
        {
            hr = szName.CopyToBSTR(pDescription);
        }
    }		
	return hr;
} /* CSpObjectToken::GetDescription */

/*****************************************************************************
* CSpObjectToken::SetId *
*----------------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpObjectToken::SetId(BSTR TokenId, BSTR CategoryId, VARIANT_BOOL CreateIfNotExist)
{
    SPDBG_FUNC( "CSpObjectToken::SetId" );
    return SetId( (const WCHAR*)EmptyStringToNull(CategoryId), (const WCHAR*)TokenId, !CreateIfNotExist ? false : true );
} /* CSpObjectToken::SetId */

/*****************************************************************************
* CSpObjectToken::GetAttribute *
*----------------------------------------*
*       
********************************************************************* TODDT ***/
STDMETHODIMP CSpObjectToken::GetAttribute(BSTR AttributeName, BSTR* pAttributeValue)
{
    SPDBG_FUNC( "CSpObjectToken::GetAttribute" );
    HRESULT hr = S_OK;
        
    if( SP_IS_BAD_WRITE_PTR( pAttributeValue ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComPtr<ISpDataKey> cpAttribKey;
        hr = OpenKey(SPTOKENKEY_ATTRIBUTES, &cpAttribKey);

        if(SUCCEEDED(hr))
        {
            CSpDynamicString szAttribute;
            hr = cpAttribKey->GetStringValue((const WCHAR*)EmptyStringToNull(AttributeName), &szAttribute);

            if (SUCCEEDED(hr))
            {
                hr = szAttribute.CopyToBSTR(pAttributeValue);
            }
        }
    }

    return hr;
} /* CSpObjectToken::GetAttribute */


/*****************************************************************************
* CSpObjectToken::CreateInstance *
*----------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectToken::
    CreateInstance( IUnknown *pUnkOuter, SpeechTokenContext ClsContext, IUnknown ** ppObject )
{
    SPDBG_FUNC( "CSpObjectToken::CreateInstance" );
    return CreateInstance( pUnkOuter, (CLSCTX)ClsContext, IID_IUnknown, (void**)ppObject );
} /* CSpObjectToken::CreateInstance */

/*****************************************************************************
* CSpObjectToken::Remove *
*--------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectToken::Remove( BSTR ObjectStgCLSID )
{
    SPDBG_FUNC( "CSpObjectToken::Remove" );
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_OPTIONAL_STRING_PTR( ObjectStgCLSID ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        GUID g = GUID_NULL;
        ObjectStgCLSID = EmptyStringToNull(ObjectStgCLSID);

        if ( ObjectStgCLSID )
        {
            hr = IIDFromString(ObjectStgCLSID, &g);
        }
        if ( SUCCEEDED( hr ) )
        {
            hr = Remove( (g == GUID_NULL) ? NULL : &g );
        }
    }

    return hr;
} /* CSpObjectToken::Remove */

/*****************************************************************************
* CSpObjectToken::GetStorageFileName *
*--------------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectToken::
    GetStorageFileName(BSTR clsidCaller, BSTR KeyName, BSTR FileName, SpeechTokenShellFolder Folder, BSTR* pFilePath)
{
    SPDBG_FUNC( "CSpObjectToken::GetStorageFileName" );
    HRESULT hr = S_OK;

    GUID g;
    hr = IIDFromString(clsidCaller, &g);
    if ( SUCCEEDED( hr ) )
    {
        CSpDynamicString szPath;
        hr = GetStorageFileName( g, (WCHAR*)KeyName, (WCHAR*)FileName, (ULONG)Folder, &szPath );
        if( SUCCEEDED(hr) )
        {
            hr = szPath.CopyToBSTR( pFilePath );
        }
    }

	return hr;
} /* CSpObjectToken::GetStorageFileName */

/*****************************************************************************
* CSpObjectToken::RemoveStorageFileName *
*-----------------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectToken::
    RemoveStorageFileName( BSTR clsidCaller, BSTR KeyName, VARIANT_BOOL fDeleteFile )
{
    SPDBG_FUNC( "CSpObjectToken::RemoveStorageFileName" );
    HRESULT hr = S_OK;

    GUID g;
    hr = IIDFromString(clsidCaller, &g);
    if ( SUCCEEDED( hr ) )
    {
        hr = RemoveStorageFileName( g, KeyName, !fDeleteFile ? false : true  );
    }

    return hr;
} /* CSpObjectToken::RemoveStorageFileName */

/*****************************************************************************
* CSpObjectToken::IsUISupported *
*---------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectToken::IsUISupported( const BSTR TypeOfUI, const VARIANT* ExtraData, 
                                           IUnknown* pObject, VARIANT_BOOL *Supported )
{
    SPDBG_FUNC( "CSpObjectToken::IsUISupported" );
    HRESULT     hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_READ_PTR( ExtraData ) || SP_IS_BAD_WRITE_PTR( Supported ) )
    {
        hr = E_POINTER;
    }
    else if( SP_IS_BAD_STRING_PTR( TypeOfUI ) || SP_IS_BAD_OPTIONAL_INTERFACE_PTR( pObject ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        BYTE * pData = NULL;
        ULONG ulDataSize = 0;

        hr = AccessVariantData( ExtraData, &pData, &ulDataSize );
        
        if( SUCCEEDED( hr ) )
        {
            BOOL fSupported;
            hr = IsUISupported( TypeOfUI, pData, ulDataSize, pObject, &fSupported );

            if ( SUCCEEDED( hr ) && Supported )
            {
                 *Supported = !fSupported ? VARIANT_FALSE : VARIANT_TRUE;
            }

            UnaccessVariantData( ExtraData, pData );
        }
    }
    
    return hr; 
} /* CSpObjectToken::IsUISupported */

/*****************************************************************************
* CSpObjectToken::DisplayUI *
*-----------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectToken::DisplayUI( long hWnd, BSTR Title,
                                        const BSTR TypeOfUI,
                                        const VARIANT* ExtraData,
                                        IUnknown* pObject )
{
    SPDBG_FUNC( "CSpObjectToken::DisplayUI" );
    HRESULT     hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_READ_PTR( ExtraData ) )
    {
        hr = E_POINTER;
    }
    else if( SP_IS_BAD_OPTIONAL_STRING_PTR( Title ) || SP_IS_BAD_STRING_PTR( TypeOfUI ) ||
             SP_IS_BAD_OPTIONAL_INTERFACE_PTR( pObject ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        BYTE * pData = NULL;
        ULONG ulDataSize = 0;

        hr = AccessVariantData( ExtraData, &pData, &ulDataSize );
        
        if( SUCCEEDED( hr ) )
        {
            hr = DisplayUI( (HWND)LongToHandle(hWnd), Title, TypeOfUI, pData, ulDataSize, pObject );
            UnaccessVariantData( ExtraData, pData );
        }
    }
    return hr;
} /* CSpObjectToken::DisplayUI */


/*****************************************************************************
* CSpObjectToken::MatchesAttributes *
*-----------------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpObjectToken::MatchesAttributes( BSTR Attributes, VARIANT_BOOL* pMatches )
{
    SPDBG_FUNC( "CSpObjectToken::MatchesAttributes" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pMatches ) )
    {
        hr = E_POINTER;
    }
    else
    {
        BOOL fMatches;

        hr = MatchesAttributes((const WCHAR*)EmptyStringToNull(Attributes), &fMatches);
        if (SUCCEEDED( hr ))
        {
            *pMatches = fMatches ? VARIANT_TRUE : VARIANT_FALSE;
        }
    }

    return hr;
} /* CSpObjectToken::MatchesAttributes */

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_txtsel.h ===
/*******************************************************************************
* a_txtsel.h *
*-----------*
*   Description:
*       This is the header file for the CSpTextSelectionInformation implementation.
*-------------------------------------------------------------------------------
*  Created By: Leonro                            Date: 1/16/01
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef A_TXTSEL_H
#define A_TXTSEL_H

#ifdef SAPI_AUTOMATION

//--- Additional includes
#include "resource.h"

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================
class CSpTextSelectionInformation;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CSpTextSelectionInformation
*   This object is used to access the Event interests on
*   the associated speech voice.
*/
class ATL_NO_VTABLE CSpTextSelectionInformation : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpTextSelectionInformation, &CLSID_SpTextSelectionInformation>,
    public IDispatchImpl<ISpeechTextSelectionInformation, &IID_ISpeechTextSelectionInformation, &LIBID_SpeechLib, 5>

{
    
  /*=== ATL Setup ===*/
  public:

    DECLARE_REGISTRY_RESOURCEID(IDR_SPTEXTSELECTIONINFORMATION)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CSpTextSelectionInformation)
	    COM_INTERFACE_ENTRY(ISpeechTextSelectionInformation)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()
  
  /*=== Interfaces ====*/
  public:
    //--- Constructors/Destructors ----------------------------
    CSpTextSelectionInformation() :
        m_ulStartActiveOffset(0),
        m_cchActiveChars(0),
        m_ulStartSelection(0),
        m_cchSelection(0){}

    //--- ISpeechTextSelectionInformation ----------------------------------
    STDMETHOD(put_ActiveOffset)( long ActiveOffset );
    STDMETHOD(get_ActiveOffset)( long* ActiveOffset );
    STDMETHOD(put_ActiveLength)( long ActiveLength );
    STDMETHOD(get_ActiveLength)( long* ActiveLength );
    STDMETHOD(put_SelectionOffset)( long SelectionOffset );
    STDMETHOD(get_SelectionOffset)( long* SelectionOffset );
    STDMETHOD(put_SelectionLength)( long SelectionLength );
    STDMETHOD(get_SelectionLength)( long* SelectionLength );

    /*=== Member Data ===*/
    ULONG       m_ulStartActiveOffset;
    ULONG       m_cchActiveChars;
    ULONG       m_ulStartSelection;
    ULONG       m_cchSelection;
};

#endif // SAPI_AUTOMATION

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_voice.cpp ===
/*******************************************************************************
* a_voice.cpp *
*-------------*
*   Description:
*       This module is the main implementation file for the SpVoice
*   automation methods.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 01/07/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "spvoice.h"
#include "a_helpers.h"


#ifdef SAPI_AUTOMATION

//
//=== ISpeechVoice interface ==================================================
//

/*****************************************************************************
* CSpVoice::Invoke *
*----------------------*
*   IDispatch::Invoke method override
********************************************************************* TODDT ***/
HRESULT CSpVoice::Invoke(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
        // JScript cannot pass NULL VT_DISPATCH parameters and OLE doesn't convert them propertly so we
        // need to convert them here if we need to.
        if ( pdispparams )
        {
            VARIANTARG * pvarg = NULL;

            switch (dispidMember)
            {
            case DISPID_SVAudioOutput:
            case DISPID_SVAudioOutputStream:
            case DISPID_SVVoice:
                if (((wFlags & DISPATCH_PROPERTYPUT) || (wFlags & DISPATCH_PROPERTYPUTREF)) && 
                    (pdispparams->cArgs > 0))
                {
                    pvarg = &(pdispparams->rgvarg[pdispparams->cArgs-1]);

                    // See if we need to tweak a param.
                    // JScript syntax for VT_NULL is "null" for the parameter
                    // JScript syntax for VT_EMPTY is "void(0)" for the parameter
                    if ( pvarg && ((pvarg->vt == VT_NULL) || (pvarg->vt == VT_EMPTY)) )
                    {
                        pvarg->vt = VT_DISPATCH;
                        pvarg->pdispVal = NULL;

                        // We have to tweak this flag for the invoke to go through properly.
                        if (wFlags == DISPATCH_PROPERTYPUT)
                        {
                            wFlags = DISPATCH_PROPERTYPUTREF;
                        }
                    }
                }
                break;
            case DISPID_SVSpeakStream:
                if ((wFlags == DISPATCH_METHOD) && (pdispparams->cArgs > 0))
                {
                    pvarg = &(pdispparams->rgvarg[pdispparams->cArgs-1]);

                    // See if we need to tweak a param.
                    // JScript syntax for VT_NULL is "null" for the parameter
                    // JScript syntax for VT_EMPTY is "void(0)" for the parameter
                    if ( pvarg && ((pvarg->vt == VT_NULL) || (pvarg->vt == VT_EMPTY)) )
                    {
                        pvarg->vt = VT_DISPATCH;
                        pvarg->pdispVal = NULL;
                    }
                }
                break;
            }
        }

        // Let ATL and OLE handle it now.
        return IDispatchImpl<ISpeechVoice, &IID_ISpeechVoice, &LIBID_SpeechLib, 5>::_tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
                    wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}


/*****************************************************************************
* CSpVoice::get_Status *
*----------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::get_Status( ISpeechVoiceStatus** Status )
{
    SPDBG_FUNC( "CSpVoice::get_Status" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( Status ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Create the status object
        CComObject<CSpeechVoiceStatus> *pClsStatus;
        hr = CComObject<CSpeechVoiceStatus>::CreateInstance( &pClsStatus );
        if( SUCCEEDED( hr ) )
        {
            pClsStatus->AddRef();
            hr = GetStatus( &pClsStatus->m_Status, &pClsStatus->m_dstrBookmark );

            if( SUCCEEDED( hr ) )
            {
                *Status = pClsStatus;
            }
            else
            {
                pClsStatus->Release();
            }
        }
    }

    return hr;
} /* CSpVoice::get_Status */

/*****************************************************************************
* CSpVoice::Voices *
*----------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::GetVoices( BSTR RequiredAttributes, BSTR OptionalAttributes, ISpeechObjectTokens** ObjectTokens )
{
    SPDBG_FUNC( "CSpVoice::GetVoices" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ObjectTokens ) )
    {
        hr = E_POINTER;
    }
    else if( SP_IS_BAD_OPTIONAL_STRING_PTR( RequiredAttributes ) || 
             SP_IS_BAD_OPTIONAL_STRING_PTR( OptionalAttributes ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComPtr<IEnumSpObjectTokens> cpEnum;

        if(SpEnumTokens(SPCAT_VOICES, 
                        EmptyStringToNull(RequiredAttributes), 
                        EmptyStringToNull(OptionalAttributes),
                        &cpEnum ) == S_OK)
        {
            hr = cpEnum.QueryInterface( ObjectTokens );
        }
        else
        {
            hr = SPERR_NO_MORE_ITEMS;
        }
    }

    return hr;
} /* CSpVoice::GetVoices */

/*****************************************************************************
* CSpVoice::get_Voice *
*-----------------------*
*  This method returns the CLSID of the driver voice being used by this object.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::get_Voice( ISpeechObjectToken ** Voice )
{
    SPDBG_FUNC( "CSpVoice::get_Voice" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( Voice ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CComQIPtr<ISpObjectToken> pTok;
        hr = GetVoice( &pTok );
		if ( SUCCEEDED( hr ) )
		{
            hr = pTok.QueryInterface( Voice );
		}
    }

    return hr;
} /* CSpVoice::get_Voice */

/*****************************************************************************
* CSpVoice::put_Voice *
*-----------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::putref_Voice( ISpeechObjectToken* Voice )
{
    SPDBG_FUNC( "CSpVoice::put_Voice" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_INTERFACE_PTR( Voice ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComQIPtr<ISpObjectToken> cpTok( Voice );
        hr = SetVoice( cpTok );
    }
    return hr;
} /* CSpVoice::put_Voice */

/*****************************************************************************
* CSpVoice::get_AudioOutput *
*----------------------*
*   This method returns the current output token
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::get_AudioOutput( ISpeechObjectToken** AudioOutput )
{
    SPDBG_FUNC( "CSpVoice::get_AudioOutput" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( AudioOutput ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComPtr<ISpObjectToken> cpTok;

        hr = GetOutputObjectToken( &cpTok );
        if( hr == S_OK )
        {
            hr = cpTok.QueryInterface( AudioOutput );
        }
        else if( hr == S_FALSE )
        {
            *AudioOutput = NULL;
        }
    }

    return hr;
} /* CSpVoice::get_AudioOutput */

/*****************************************************************************
* CSpVoice::putref_AudioOutput *
*----------------------*
*   This method sets the current output token. NULL indicates the
*   system wav out device. 
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::putref_AudioOutput( ISpeechObjectToken* AudioOutput )
{
    SPDBG_FUNC( "CSpVoice::putref_AudioOutput" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_INTERFACE_PTR( AudioOutput ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComQIPtr<ISpObjectToken> cpTok(AudioOutput);
        
        //--- Set the stream/token on the SAPI voice
        hr = SetOutput( cpTok, m_fAutoPropAllowOutFmtChanges );
    }

    return hr;
} /* CSpVoice::putref_AudioOutput */

/*****************************************************************************
* CSpVoice::get_AudioOutputStream *
*----------------------*
*   This method returns the current output stream object.
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::get_AudioOutputStream( ISpeechBaseStream** AudioOutputStream )
{
    SPDBG_FUNC( "CSpVoice::get_AudioOutputStream" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( AudioOutputStream ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComPtr<ISpStreamFormat> cpStream;
        
        hr = GetOutputStream( &cpStream );

        if( SUCCEEDED(hr) )
        {
            if ( cpStream )
            {
                hr = cpStream.QueryInterface( AudioOutputStream );
            }
            else
            {
                *AudioOutputStream = NULL;
            }
        }
    }

    return hr;
} /* CSpVoice::get_AudioOutputStream */

/*****************************************************************************
* CSpVoice::putref_AudioOutputStream *
*----------------------*
*   This method sets the current output stream object. NULL indicates the
*   system wav out device.
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::putref_AudioOutputStream( ISpeechBaseStream* AudioOutputStream )
{
    SPDBG_FUNC( "CSpVoice::putref_AudioOutputStream" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_INTERFACE_PTR( AudioOutputStream ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //--- Set the stream/token on the SAPI voice
        hr = SetOutput( AudioOutputStream, m_fAutoPropAllowOutFmtChanges );
    }

    return hr;
} /* CSpVoice::putref_AudioOutputStream */

/*****************************************************************************
* CSpVoice::put_AllowAudioOutputFormatChangesOnNextSet *
*---------------------*
*   Sets the flag used for allowing input changes.  Used by put_Output.
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::put_AllowAudioOutputFormatChangesOnNextSet( VARIANT_BOOL Allow )
{
    SPDBG_FUNC( "CSpVoice::put_AllowAudioOutputFormatChangesOnNextSet" );

    if( Allow == VARIANT_TRUE )
    {
        m_fAutoPropAllowOutFmtChanges = TRUE;
    }
    else
    {
        m_fAutoPropAllowOutFmtChanges = FALSE;
    }

    return S_OK;
}

/*****************************************************************************
* CSpVoice::get_AllowAudioOutputFormatChangesOnNextSet *
*---------------------*
*   Gets the driver's current spoken text units per minute rate.
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::get_AllowAudioOutputFormatChangesOnNextSet( VARIANT_BOOL* Allow )
{
    SPDBG_FUNC( "CSpVoice::get_AllowAudioOutputFormatChangesOnNextSet" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( Allow ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *Allow = m_fAutoPropAllowOutFmtChanges? VARIANT_TRUE : VARIANT_FALSE;
    }
    return hr;
}

/*****************************************************************************
* CSpVoice::put_EventInterests *
*-------------------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::put_EventInterests( SpeechVoiceEvents EventInterestFlags )
{
    SPDBG_FUNC( "CSpVoice::put_EventInterests" );
    HRESULT     hr = S_OK;
    ULONGLONG   ullInterests = (ULONGLONG)EventInterestFlags;

    ullInterests |= SPFEI_FLAGCHECK;
    
    hr = SetInterest( ullInterests, ullInterests );

    return hr;
} /* CRecoCtxt::put_EventInterests */

/*****************************************************************************
* CSpVoice::get_EventInterests *
*------------------------*
*
*   Gets the event interests that are currently set on CSpVoice.
*
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::get_EventInterests( SpeechVoiceEvents* EventInterestFlags )
{
    SPDBG_FUNC( "CSpVoice::get_EventInterests" );
    HRESULT hr = S_OK;
    ULONGLONG   ullInterests = 0;

    if( SP_IS_BAD_WRITE_PTR( EventInterestFlags ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetInterests( &ullInterests, 0 );

        if( SUCCEEDED( hr ) )
        {
            // Make sure reserved bits are not used
            ullInterests &= ~SPFEI_FLAGCHECK;

            *EventInterestFlags = (SpeechVoiceEvents)ullInterests;
        }
    }
    return hr;
}

/*****************************************************************************
* CSpVoice::get_Rate *
*--------------------*
*   Gets the driver's current spoken text units per minute rate.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::get_Rate( long* Rate )
{
    SPDBG_FUNC( "CSpVoice::get_Rate" );
    return GetRate( Rate );
} /* CSpVoice::get_Rate */

/*****************************************************************************
* CSpVoice::put_Rate *
*--------------------*
*   Sets the driver's current spoken text units per minute rate.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::put_Rate( long Rate )
{
    SPDBG_FUNC( "CSpVoice::put_Rate" );
    return SetRate( Rate );
} /* CSpVoice::put_Rate */

/*****************************************************************************
* CSpVoice::get_Volume *
*----------------------*
*   Gets the driver's current voice volume.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::get_Volume( long* Volume )
{
    SPDBG_FUNC( "CSpVoice::get_Volume" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( Volume ) )
    {
        hr = E_POINTER;
    }
    else
    {
        USHORT Vol;
        hr = GetVolume( &Vol );
        *Volume = Vol;
    }

    return hr;
} /* CSpVoice::get_Volume */

/*****************************************************************************
* CSpVoice::put_Volume *
*----------------------*
*   Sets the driver's current voice volume.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::put_Volume( long Volume )
{
    SPDBG_FUNC( "CSpVoice::put_Volume" );
    HRESULT hr = S_OK;

    if( Volume > SPMAX_VOLUME )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SetVolume( (USHORT)Volume );
    }

    return hr;
} /* CSpVoice::put_Volume */

/*****************************************************************************
* CSpVoice::Speak *
*-----------------*
*    Input = What to speak. This may be one of the following:
*               - A string
*               - A URL or UNC file name
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::Speak( BSTR Input, SpeechVoiceSpeakFlags Flags, long* StreamNumber )
{
    SPDBG_FUNC( "CSpVoice::Speak" );

    return Speak( Input, (DWORD)Flags, (ULONG*)StreamNumber );
} /* CSpVoice::Speak */

/*****************************************************************************
* CSpVoice::SpeakStream *
*-----------------*
*   Input = What to speak. This may be one of the following:
*               - A stream object
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::SpeakStream( ISpeechBaseStream * pStream, SpeechVoiceSpeakFlags Flags, long* pStreamNumber )
{
    SPDBG_FUNC( "CSpVoice::SpeakStream" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_INTERFACE_PTR( pStream ) )
    {
        hr = E_INVALIDARG;
    }
    else if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pStreamNumber ) )
    {
        hr = E_POINTER;
    }
    else
    {
        //--- Create a stream from the source
        CComQIPtr<ISpStreamFormat> cpStream( pStream );

        //Either the input stream in NULL, which is useful for speakwithpurge, or the input stream supports ISpStreamFormat
        if( cpStream  || !pStream)
        {
            hr = SpeakStream( cpStream, Flags, (ULONG*)pStreamNumber );
        }
        else
        {
            //--- The output object did not support the stream interface??
            hr = E_INVALIDARG;
        }
    }

    return hr;
}  //CSpVoice::SpeakStream 

/*****************************************************************************
* CSpVoice::put_Priority *
*------------------------*
*   Sets the voices speak priority
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::put_Priority( SpeechVoicePriority Priority )
{
    SPDBG_FUNC( "CSpVoice::put_Priority" );
    return SetPriority( (SPVPRIORITY)Priority );
} /* CSpVoice::put_Priority */

/*****************************************************************************
* CSpVoice::get_Priority *
*------------------------*
*   Gets the voices current speak priority
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::get_Priority( SpeechVoicePriority* Priority )
{
    SPDBG_FUNC( "CSpVoice::get_Priority" );
    HRESULT         hr = S_OK;

    SPVPRIORITY     Prior;

    hr = GetPriority( &Prior );

    if( SUCCEEDED( hr ) )
    {
        *Priority = (SpeechVoicePriority)Prior;
    }

    return hr;
} /* CSpVoice::get_Priority */

/*****************************************************************************
* CSpVoice::put_AlertBoundary *
*-----------------------------*
*   Sets which event is to be used for the alert boundary insertion point.
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::put_AlertBoundary( SpeechVoiceEvents Boundary )
{
    SPDBG_FUNC( "CSpVoice::put_AlertBoundary" );
    
    SPEVENTENUM EventEnum;

    switch ( Boundary )
    {
    case SVEStartInputStream:
        EventEnum = SPEI_START_INPUT_STREAM;
        break;
    case SVEEndInputStream:
        EventEnum = SPEI_END_INPUT_STREAM;
        break;
    case SVEVoiceChange:
        EventEnum = SPEI_VOICE_CHANGE;
        break;
    case SVEBookmark:
        EventEnum = SPEI_TTS_BOOKMARK;
        break;
    case SVEWordBoundary:
        EventEnum = SPEI_WORD_BOUNDARY;
        break;
    case SVEPhoneme:
        EventEnum = SPEI_PHONEME;
        break;
    case SVESentenceBoundary:
        EventEnum = SPEI_SENTENCE_BOUNDARY;
        break;
    case SVEViseme:
        EventEnum = SPEI_VISEME;
        break;
    case SVEAudioLevel:
        EventEnum = SPEI_TTS_AUDIO_LEVEL;
        break;
    case SVEPrivate:
        EventEnum = SPEI_TTS_PRIVATE;
        break;
    default:
        return E_INVALIDARG;
        break;
    }

    return SetAlertBoundary( EventEnum );
} /* CSpVoice::put_AlertBoundary */

/*****************************************************************************
* CSpVoice::get_AlertBoundary *
*-----------------------------*
*   Gets which event is used as the alert insertion boundary.
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::get_AlertBoundary( SpeechVoiceEvents* Boundary )
{
    SPDBG_FUNC( "CSpVoice::get_AlertBoundary" );
    HRESULT         hr = S_OK;
    SPEVENTENUM     eEvent;

    hr = GetAlertBoundary( &eEvent );

    if( SUCCEEDED( hr ) )
    {
        *Boundary = (SpeechVoiceEvents)(1L << eEvent);
    }

    return hr;
} /* CSpVoice::get_AlertBoundary */

/*****************************************************************************
* CSpVoice::put_SynchronousSpeakTimeout *
*--------------------------------*
*   Sets the timeout period used during a synchronous speak call.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::put_SynchronousSpeakTimeout( long msTimeout )
{
    SPDBG_FUNC( "CSpVoice::put_SynchronousSpeakTimeout" );
    return SetSyncSpeakTimeout( msTimeout );
} /* CSpVoice::put_SynchronousSpeakTimeout */

/*****************************************************************************
* CSpVoice::get_SynchronousSpeakTimeout *
*--------------------------------*
*   Gets the timeout period used during a synchronous speak call.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::get_SynchronousSpeakTimeout( long* msTimeout )
{
    SPDBG_FUNC( "CSpVoice::get_SynchronousSpeakTimeout" );
    return GetSyncSpeakTimeout( (ULONG*)msTimeout );
} /* CSpVoice::get_SynchronousSpeakTimeout */

/*****************************************************************************
* CSpVoice::Skip *
*----------------*
*   Tells the engine to skip the specified number of items.
********************************************************************* EDC ***/
STDMETHODIMP CSpVoice::Skip( const BSTR Type, long NumItems, long* NumSkipped )
{
    SPDBG_FUNC( "CSpVoice::Skip (Automation)" );
    return Skip( (WCHAR*)Type, NumItems, (ULONG*)NumSkipped );
} /* CSpVoice::Skip */

//
//=== ISpeechVoiceStatus interface =============================================
//

/*****************************************************************************
* CSpeechVoiceStatus::get_CurrentStreamNumber *
*---------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechVoiceStatus::get_CurrentStreamNumber( long* StreamNumber )
{
    SPDBG_FUNC( "CSpeechVoiceStatus::get_CurrentStream" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( StreamNumber ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *StreamNumber = m_Status.ulCurrentStream;
    }
    return hr;
} /* CSpeechVoiceStatus::get_CurrentStreamNumber */

/*****************************************************************************
* CSpeechVoiceStatus::get_LastStreamNumberQueued *
*------------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechVoiceStatus::get_LastStreamNumberQueued( long* StreamNumber )
{
    SPDBG_FUNC( "CSpeechVoiceStatus::get_LastStreamNumberQueued" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( StreamNumber ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *StreamNumber = m_Status.ulLastStreamQueued;
    }
    return hr;
} /* CSpeechVoiceStatus::get_LastStreamNumberQueued */

/*****************************************************************************
* CSpeechVoiceStatus::get_LastHResult *
*------------------------------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceStatus::get_LastHResult( long* HResult )
{
    SPDBG_FUNC( "CSpeechVoiceStatus::get_LastHResult" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( HResult ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *HResult = (long)m_Status.hrLastResult;
    }
    return hr;
} /* CSpeechVoiceStatus::get_LastHResult */

/*****************************************************************************
* CSpeechVoiceStatus::get_RunningState *
*--------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechVoiceStatus::get_RunningState( SpeechRunState* State )
{
    SPDBG_FUNC( "CSpeechVoiceStatus::get_RunningState" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( State ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *State = (SpeechRunState)m_Status.dwRunningState;
    }
    return hr;
} /* CSpeechVoiceStatus::get_RunningState */

/*****************************************************************************
* CSpeechVoiceStatus::get_InputWordPosition *
*--------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechVoiceStatus::get_InputWordPosition( long* WordOffset )
{
    SPDBG_FUNC( "CSpeechVoiceStatus::get_InputWordCharacterOffset" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( WordOffset ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *WordOffset = m_Status.ulInputWordPos;
    }
    return hr;
} /* CSpeechVoiceStatus::get_InputWordPosition */

/*****************************************************************************
* CSpeechVoiceStatus::get_InputWordLength *
*--------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechVoiceStatus::get_InputWordLength( long* Length )
{
    SPDBG_FUNC( "CSpeechVoiceStatus::get_InputWordLength" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( Length ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *Length = m_Status.ulInputWordLen;
    }
    return hr;
} /* CSpeechVoiceStatus::get_InputWordLength */

/*****************************************************************************
* CSpeechVoiceStatus::get_InputSentencePosition *
*------------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechVoiceStatus::get_InputSentencePosition( long* Position )
{
    SPDBG_FUNC( "CSpeechVoiceStatus::get_InputSentencePosition" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( Position ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *Position = m_Status.ulInputSentPos;
    }
    return hr;
} /* CSpeechVoiceStatus::get_InputSentencePosition */

/*****************************************************************************
* CSpeechVoiceStatus::get_InputSentenceLength *
*------------------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechVoiceStatus::get_InputSentenceLength( long* Length )
{
    SPDBG_FUNC( "CSpeechVoiceStatus::get_InputSentenceLength" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( Length ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *Length = m_Status.ulInputSentLen;
    }
    return hr;
} /* CSpeechVoiceStatus::get_InputSentenceLength */

/*****************************************************************************
* CSpeechVoiceStatus::get_LastBookmark *
*----------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechVoiceStatus::get_LastBookmark( BSTR* BookmarkString )
{
    SPDBG_FUNC( "CSpeechVoiceStatus::get_Bookmark" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( BookmarkString ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_dstrBookmark.CopyToBSTR( BookmarkString );
    }
    return hr;
} /* CSpeechVoiceStatus::get_LastBookmark */

/*****************************************************************************
* CSpeechVoiceStatus::get_LastBookmarkId *
*----------------------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceStatus::get_LastBookmarkId( long* BookmarkId )
{
    SPDBG_FUNC( "CSpeechVoiceStatus::get_LastBookmarkId" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( BookmarkId ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *BookmarkId = m_Status.lBookmarkId;
    }
    return hr;
} /* CSpeechVoiceStatus::get_LastBookmarkId */

/*****************************************************************************
* CSpeechVoiceStatus::get_PhonemeId *
*-----------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechVoiceStatus::get_PhonemeId( short* PhoneId )
{
    SPDBG_FUNC( "CSpeechVoiceStatus::get_PhonemeId" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( PhoneId ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *PhoneId = m_Status.PhonemeId;
    }
    return hr;
} /* CSpeechVoiceStatus::get_PhonemeId */

/*****************************************************************************
* CSpeechVoiceStatus::get_VisemeId *
*----------------------------------*
*       
********************************************************************* EDC ***/
STDMETHODIMP CSpeechVoiceStatus::get_VisemeId( short* VisemeId )
{
    SPDBG_FUNC( "CSpeechVoiceStatus::get_VisemeId" );
    HRESULT hr = S_OK;
    if( SP_IS_BAD_WRITE_PTR( VisemeId ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *VisemeId = m_Status.VisemeId;
    }
    return hr;
} /* CSpeechVoiceStatus::get_VisemeId */

/*****************************************************************************
* CSpVoice::GetAudioOutputs *
*----------------------*
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::GetAudioOutputs( BSTR RequiredAttributes, BSTR OptionalAttributes, ISpeechObjectTokens** ObjectTokens )
{
    SPDBG_FUNC( "CSpVoice::GetAudioOutputs" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ObjectTokens ) )
    {
        hr = E_POINTER;
    }
    else if( SP_IS_BAD_OPTIONAL_STRING_PTR( RequiredAttributes ) || 
             SP_IS_BAD_OPTIONAL_STRING_PTR( OptionalAttributes ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CComPtr<IEnumSpObjectTokens> cpEnum;

        if(SpEnumTokens(SPCAT_AUDIOOUT, 
                        EmptyStringToNull(RequiredAttributes), 
                        EmptyStringToNull(OptionalAttributes),
                        &cpEnum ) == S_OK)
        {
            hr = cpEnum.QueryInterface( ObjectTokens );
        }
        else
        {
            hr = SPERR_NO_MORE_ITEMS;
        }
    }

    return hr;
} /* CSpVoice::GetAudioOutputs */

/*****************************************************************************
* CSpVoice::WaitUntilDone *
*--------------------*
*   Waits for the specified time limit or until the speech queue is empty.
*   If the speech queue empties or times out then this function returns S_OK.
*   If the speech queue is empty then pDone will be VARIANT_TRUE.
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::WaitUntilDone( long msTimeout, VARIANT_BOOL * pDone )
{
    SPDBG_FUNC( "CSpVoice::WaitUntilDone" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pDone ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = WaitUntilDone( (ULONG)msTimeout );

        *pDone = (hr == S_OK) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return hr;
} /* CSpVoice::WaitUntilDone */

/*****************************************************************************
* CSpVoice::SpeakCompleteEvent *
*--------------------*
*   Returns an event handle that the caller can use to wait until the voice
*   has completed speaking.
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::SpeakCompleteEvent( long* Handle )
{
    SPDBG_FUNC( "CSpVoice::SpeakCompleteEvent" );
    HANDLE      Hdl;
    HRESULT     hr = S_OK;

    Hdl = SpeakCompleteEvent();

    *Handle = HandleToULong( Hdl );

    return hr;
} /* CSpVoice::SpeakCompleteEvent */

/*****************************************************************************
* CSpVoice::IsUISupported *
*--------------------*
*   Checks to see if the specified type of UI is supported.
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::IsUISupported( const BSTR TypeOfUI, const VARIANT* ExtraData, VARIANT_BOOL* Supported )
{
    SPDBG_FUNC( "CSpVoice::IsUISupported" );
    HRESULT     hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_READ_PTR( ExtraData ) || SP_IS_BAD_WRITE_PTR( Supported ) )
    {
        hr = E_POINTER;
    }
    else if( SP_IS_BAD_STRING_PTR( TypeOfUI ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        BYTE * pData = NULL;
        ULONG ulDataSize = 0;

        hr = AccessVariantData( ExtraData, &pData, &ulDataSize );
        
        if( SUCCEEDED( hr ) )
        {
            BOOL fSupported;
            hr = IsUISupported( TypeOfUI, pData, ulDataSize, &fSupported );
            if ( SUCCEEDED( hr ) && Supported )
            {
                 *Supported = !fSupported ? VARIANT_FALSE : VARIANT_TRUE;
            }

            UnaccessVariantData( ExtraData, pData );
        }
    }
    
    return hr; 
} /* CSpVoice::IsUISupported */

/*****************************************************************************
* CSpVoice::DisplayUI *
*--------------------*
*   Displays the requested UI.
********************************************************************* Leonro ***/
STDMETHODIMP CSpVoice::DisplayUI( long hWndParent, BSTR Title, const BSTR TypeOfUI, const VARIANT* ExtraData )
{
    SPDBG_FUNC( "CSpVoice::DisplayUI" );
    HRESULT     hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_READ_PTR( ExtraData ) )
    {
        hr = E_POINTER;
    }
    else if( SP_IS_BAD_OPTIONAL_STRING_PTR( Title ) || SP_IS_BAD_STRING_PTR( TypeOfUI ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        BYTE * pData = NULL;
        ULONG ulDataSize = 0;

        hr = AccessVariantData( ExtraData, &pData, &ulDataSize );
        
        if( SUCCEEDED( hr ) )
        {
            hr = DisplayUI( (HWND)LongToHandle(hWndParent), Title, TypeOfUI, pData, ulDataSize );
            UnaccessVariantData( ExtraData, pData );
        }
    }
    return hr;
} /* CSpVoice::DisplayUI */

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_voiceei.cpp ===
/*******************************************************************************
* a_voiceei.cpp *
*-------------*
*   Description:
*       This module is the main implementation file for the CSpeechVoiceEventInterests
*   automation methods.
*-------------------------------------------------------------------------------
*  Created By: Leonro                                        Date: 11/17/00
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "a_voiceei.h"

#ifdef SAPI_AUTOMATION


/*****************************************************************************
* CSpeechVoiceEventInterests::FinalRelease *
*------------------------*
*   Description:
*       destructor
********************************************************************* Leonro ***/
void CSpeechVoiceEventInterests::FinalRelease()
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::FinalRelease" );

    if( m_pCSpVoice )
    {
        m_pCSpVoice->Release();
        m_pCSpVoice = NULL;
    }

} /* CSpeechVoiceEventInterests::FinalRelease */

//
//=== ICSpeechVoiceEventInterests interface ==================================================
// 

/*****************************************************************************
* CSpeechVoiceEventInterests::put_StreamStart *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_START_INPUT_STREAM event on 
*   the SpeechVoice.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::put_StreamStart( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::put_StreamStart" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_START_INPUT_STREAM);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_START_INPUT_STREAM);
        }

        hr = m_pCSpVoice->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechVoiceEventInterests::put_StreamStart */

/*****************************************************************************
* CSpeechVoiceEventInterests::get_StreamStart *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_START_INPUT_STREAM interest is 
*   enabled on the SpeechVoice object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::get_StreamStart( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::get_StreamStart" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_START_INPUT_STREAM) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechVoiceEventInterests::get_StreamStart */

/*****************************************************************************
* CSpeechVoiceEventInterests::put_StreamEnd *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_END_INPUT_STREAM event on 
*   the SpeechVoice.       
*
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::put_StreamEnd( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::put_StreamEnd" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_END_INPUT_STREAM);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_END_INPUT_STREAM);
        }

        hr = m_pCSpVoice->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechVoiceEventInterests::put_StreamEnd */

/*****************************************************************************
* CSpeechVoiceEventInterests::get_StreamEnd *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_END_INPUT_STREAM interest is 
*   enabled on the SpeechVoice object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::get_StreamEnd( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::get_StreamEnd" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_END_INPUT_STREAM) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechVoiceEventInterests::get_StreamEnd */

/*****************************************************************************
* CSpeechVoiceEventInterests::put_VoiceChange *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_VOICE_CHANGE event on 
*   the SpeechVoice.  
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::put_VoiceChange( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::put_VoiceChange" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_VOICE_CHANGE);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_VOICE_CHANGE);
        }

        hr = m_pCSpVoice->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechVoiceEventInterests::put_VoiceChange */

/*****************************************************************************
* CSpeechVoiceEventInterests::get_VoiceChange *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_VOICE_CHANGE interest is 
*   enabled on the SpeechVoice object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::get_VoiceChange( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::get_VoiceChange" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_VOICE_CHANGE) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechVoiceEventInterests::get_VoiceChange */

/*****************************************************************************
* CSpeechVoiceEventInterests::put_Bookmark *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_TTS_BOOKMARK event on 
*   the SpeechVoice.  
*        
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::put_Bookmark( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::put_Bookmark" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_TTS_BOOKMARK);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_TTS_BOOKMARK);
        }

        hr = m_pCSpVoice->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechVoiceEventInterests::put_Bookmark */

/*****************************************************************************
* CSpeechVoiceEventInterests::get_Bookmark *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_TTS_BOOKMARK interest is 
*   enabled on the SpeechVoice object.
*    
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::get_Bookmark( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::get_Bookmark" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_TTS_BOOKMARK) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechVoiceEventInterests::get_Bookmark */

/*****************************************************************************
* CSpeechVoiceEventInterests::put_WordBoundary *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_WORD_BOUNDARY event on 
*   the SpeechVoice.  
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::put_WordBoundary( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::put_WordBoundary" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_WORD_BOUNDARY);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_WORD_BOUNDARY);
        }

        hr = m_pCSpVoice->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechVoiceEventInterests::put_WordBoundary */

/*****************************************************************************
* CSpeechVoiceEventInterests::get_WordBoundary *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_WORD_BOUNDARY interest is 
*   enabled on the SpeechVoice object.
*    
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::get_WordBoundary( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::get_WordBoundary" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_WORD_BOUNDARY) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechVoiceEventInterests::get_WordBoundary */

/*****************************************************************************
* CSpeechVoiceEventInterests::put_Phoneme *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_PHONEME event on 
*   the SpeechVoice.  
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::put_Phoneme( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::put_Phoneme" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_PHONEME);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_PHONEME);
        }

        hr = m_pCSpVoice->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechVoiceEventInterests::put_Phoneme */

/*****************************************************************************
* CSpeechVoiceEventInterests::get_Phoneme *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_PHONEME interest is 
*   enabled on the SpeechVoice object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::get_Phoneme( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::get_Phoneme" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_PHONEME) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechVoiceEventInterests::get_Phoneme */

/*****************************************************************************
* CSpeechVoiceEventInterests::put_SentenceBoundary *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_SENTENCE_BOUNDARY event on 
*   the SpeechVoice. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::put_SentenceBoundary( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::put_SentenceBoundary" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_SENTENCE_BOUNDARY);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_SENTENCE_BOUNDARY);
        }

        hr = m_pCSpVoice->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechVoiceEventInterests::put_SentenceBoundary */

/*****************************************************************************
* CSpeechVoiceEventInterests::get_SentenceBoundary *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_SENTENCE_BOUNDARY interest is 
*   enabled on the SpeechVoice object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::get_SentenceBoundary( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::get_SentenceBoundary" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_SENTENCE_BOUNDARY) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechVoiceEventInterests::get_SentenceBoundary */

/*****************************************************************************
* CSpeechVoiceEventInterests::put_Viseme *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_VISEME event on 
*   the SpeechVoice. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::put_Viseme( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::put_Viseme" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_VISEME);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_VISEME);
        }

        hr = m_pCSpVoice->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechVoiceEventInterests::put_Viseme */

/*****************************************************************************
* CSpeechVoiceEventInterests::get_Viseme *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_VISEME interest is 
*   enabled on the SpeechVoice object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::get_Viseme( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::get_Viseme" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_VISEME) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechVoiceEventInterests::get_Viseme */

/*****************************************************************************
* CSpeechVoiceEventInterests::put_AudioLevel *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_TTS_AUDIO_LEVEL event on 
*   the SpeechVoice. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::put_AudioLevel( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::put_AudioLevel" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_TTS_AUDIO_LEVEL);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_TTS_AUDIO_LEVEL);
        }

        hr = m_pCSpVoice->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechVoiceEventInterests::put_AudioLevel */

/*****************************************************************************
* CSpeechVoiceEventInterests::get_AudioLevel *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_TTS_AUDIO_LEVEL interest is 
*   enabled on the SpeechVoice object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::get_AudioLevel( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::get_AudioLevel" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_TTS_AUDIO_LEVEL) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechVoiceEventInterests::get_AudioLevel */

/*****************************************************************************
* CSpeechVoiceEventInterests::put_EnginePrivate *
*----------------------------------*
*
*   This method enables and disables the interest in the SPEI_TTS_PRIVATE event on 
*   the SpeechVoice. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::put_EnginePrivate( VARIANT_BOOL Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::put_EnginePrivate" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

    hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );

    if( SUCCEEDED( hr ) )
    {
        if( Enabled )
        {
            ullInterest |= (1ui64 << SPEI_TTS_PRIVATE);
        }
        else
        {
            ullInterest &= ~(1ui64 << SPEI_TTS_PRIVATE);
        }

        hr = m_pCSpVoice->SetInterest( ullInterest, ullInterest );
    }

	return hr;
} /* CSpeechVoiceEventInterests::put_EnginePrivate */

/*****************************************************************************
* CSpeechVoiceEventInterests::get_EnginePrivate *
*----------------------------------*
*      
*   This method determines whether or not the SPEI_TTS_PRIVATE interest is 
*   enabled on the SpeechVoice object.
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::get_EnginePrivate( VARIANT_BOOL* Enabled )
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::get_EnginePrivate" );
    ULONGLONG   ullInterest = 0;
    HRESULT		hr = S_OK;

	if( SP_IS_BAD_WRITE_PTR( Enabled ) )
    {
        hr = E_POINTER;
    }
    else
    {
        hr = m_pCSpVoice->GetInterests( &ullInterest, NULL );
        if( SUCCEEDED( hr ) )
        {
            if( ullInterest & (1ui64 << SPEI_TTS_PRIVATE) )
            {
		        *Enabled = VARIANT_TRUE;
            }
            else
            {
                *Enabled = VARIANT_FALSE;
            }
        }
    }

    return hr;
} /* CSpeechVoiceEventInterests::get_EnginePrivate */

/*****************************************************************************
* CSpeechVoiceEventInterests::SetAll *
*----------------------------------*
*
*   This method sets all the interests on the SpeechVoice. 
*       
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::SetAll()
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::SetAll" );
    HRESULT		hr = S_OK;

    hr = m_pCSpVoice->SetInterest( SPFEI_ALL_TTS_EVENTS, SPFEI_ALL_TTS_EVENTS );

	return hr;
} /* CSpeechVoiceEventInterests::SetAll */

/*****************************************************************************
* CSpeechVoiceEventInterests::ClearAll *
*----------------------------------*
*       
*   This method clears all the interests on the SpeechVoice. 
*
********************************************************************* Leonro ***/
STDMETHODIMP CSpeechVoiceEventInterests::ClearAll()
{
    SPDBG_FUNC( "CSpeechVoiceEventInterests::ClearAll" );
    HRESULT		hr = S_OK;

    hr = m_pCSpVoice->SetInterest( 0, 0 );

	return hr;
} /* CSpeechVoiceEventInterests::ClearAll */

#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\backend.h ===
// Backend.h : Declaration of the CGramBackEnd

#ifndef __BACKEND_H__
#define __BACKEND_H__

#include "resource.h"       // main symbols
#include "HandleTable.h"

class CGramBackEnd;
class CRule;
class CArc;
class CGramNode;
class CSemanticTag;

/////////////////////////////////////////////////////////////////////////////
// CGramBackEnd
class ATL_NO_VTABLE CGramBackEnd : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CGramBackEnd, &CLSID_SpGramCompBackend>,
//    public ISpGramCompBackend,
    public ISpGramCompBackendPrivate
{
public:
    ~CGramBackEnd()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_BACKEND)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CGramBackEnd)
    COM_INTERFACE_ENTRY(ISpGramCompBackendPrivate)
    COM_INTERFACE_ENTRY(ISpGramCompBackend)
    COM_INTERFACE_ENTRY(ISpGrammarBuilder)
END_COM_MAP()

    HRESULT _InternalCreateRule(DWORD dwRuleId, const WCHAR * pszRuleName, BOOL fImport, CRule ** ppRule);
    HRESULT FindRule(DWORD dwRuleId, const WCHAR * pszName, CRule ** ppRule);
    HRESULT FinalConstruct();
    void FinalRelease();
    HRESULT ValidateAndTagRules();
    HRESULT Reset();
    HRESULT DynamicSave(DWORD dwReserved);
    HRESULT AddSingleWordTransition(
                        SPSTATEHANDLE hFromState,
                        CGramNode * pSrcNode,
                        CGramNode * pDestNode,
                        const WCHAR * pszWord,
                        float flWeight,
                        CSemanticTag * pSemanticTag,
                        BOOL fUseDestNode,
                        CGramNode **ppActualDestNode,
                        CArc **ppArcUsed,
                        BOOL *pfPropertyMatched);
    HRESULT PushProperty(CArc *pArc);
    HRESULT GetNextWord(WCHAR *psz, const WCHAR * pszSep, WCHAR **ppszNextWord, ULONG *pulOffset );
    HRESULT ConvertPronToId(WCHAR **ppStr);

// ISpGramCompBackendPrivate
public:
    STDMETHODIMP GetRuleCount( long * pCount );
    STDMETHODIMP GetHRuleFromIndex( ULONG index, SPSTATEHANDLE * pHRule );
    STDMETHODIMP GetNameFromHRule( SPSTATEHANDLE HRule, WCHAR ** ppszRuleName );
    STDMETHODIMP GetIdFromHRule( SPSTATEHANDLE HRule, long * pId );
    STDMETHODIMP GetAttributesFromHRule( SPSTATEHANDLE HRule, SpeechRuleAttributes* pAttributes );
    STDMETHODIMP GetTransitionCount( SPSTATEHANDLE hState, long * pCount);
    STDMETHODIMP GetTransitionType( SPSTATEHANDLE hState, void * Cookie, VARIANT_BOOL *pfIsWord, ULONG * pulSpecialTransitions);
    STDMETHODIMP GetTransitionText( SPSTATEHANDLE hState, void * Cookie, BSTR * Text);
    STDMETHODIMP GetTransitionRule( SPSTATEHANDLE hState, void * Cookie, SPSTATEHANDLE * phRuleInitialState);
    STDMETHODIMP GetTransitionWeight( SPSTATEHANDLE hState, void * Cookie, VARIANT * Weight);
    STDMETHODIMP GetTransitionProperty( SPSTATEHANDLE hState, void * Cookie, SPTRANSITIONPROPERTY * pProperty);
    STDMETHODIMP GetTransitionNextState( SPSTATEHANDLE hState, void * Cookie, SPSTATEHANDLE * phNextState);
    STDMETHODIMP GetTransitionCookie( SPSTATEHANDLE hState, ULONG Index, void ** pCookie );


// ISpGramCompBackend
public:
    STDMETHODIMP SetSaveObjects(IStream * pStream, ISpErrorLog * pErrorLog);
    STDMETHODIMP InitFromBinaryGrammar(const SPBINARYGRAMMAR *pBinaryData);

// ISpBrammarBuilder
public:
    STDMETHODIMP ResetGrammar(LANGID NewLanguage);
    STDMETHODIMP GetRule(
                        const WCHAR * pszName, DWORD dwRuleId, DWORD dwAttributes,
                        BOOL fCreateIfNotExist, SPSTATEHANDLE * phInitialState);
    STDMETHODIMP ClearRule(
                        SPSTATEHANDLE hState);
    STDMETHODIMP CreateNewState(
                        SPSTATEHANDLE hExitingState, SPSTATEHANDLE * phNewState);
    STDMETHODIMP AddWordTransition(
                        SPSTATEHANDLE hFromState,
                        SPSTATEHANDLE hToState,
                        const WCHAR * psz,           // if NULL then SPEPSILONTRANS
                        const WCHAR * pszSeparators, // if NULL then psz contains single word
                        SPGRAMMARWORDTYPE eWordType,
                        float flWeight,
                        const SPPROPERTYINFO * pPropInfo);
    STDMETHODIMP AddRuleTransition(
                        SPSTATEHANDLE hFromState,
                        SPSTATEHANDLE hToState,
                        SPSTATEHANDLE hRule,        // must be initial state of rule
                        float flWeight,
                        const SPPROPERTYINFO * pPropInfo);
    STDMETHODIMP AddResource(
                        SPSTATEHANDLE hRuleState,
                        const WCHAR * pszResourceName,
                        const WCHAR * pszResourceValue);

    STDMETHODIMP Commit(DWORD dwReserved);

    inline HRESULT LogError(HRESULT hr, UINT uID, const WCHAR * pszInsertString = NULL)
    {
        if (m_cpErrorLog)
        {
            USES_CONVERSION;
            TCHAR sz[MAX_PATH]; // 260 chars max for error string.
            if (::LoadString(_Module.GetModuleInstance(), uID, sz, sp_countof(sz)))
            {
                TCHAR szFormatted[MAX_PATH];
                TCHAR * pszErrorText = sz;
                if (pszInsertString)
                {
                    ::wsprintf(szFormatted, sz, W2T(LPWSTR(pszInsertString)));
                    pszErrorText = szFormatted;
                }
                m_cpErrorLog->AddError(0, hr, T2W(pszErrorText), NULL, 0);
            }
        }
        return hr;
    }



    inline HRESULT LogError(HRESULT hr, UINT uID, const CRule * pRule);

    inline HRESULT WriteStream(const void * pv, ULONG cb)
    {
        HRESULT hr = m_cpStream->Write(pv, cb, NULL);
        if (FAILED(hr))
        {
            LogError(hr, IDS_WRITE_ERROR);
        }
        return hr;
    }

    inline bool isSeparator( WCHAR wch, const WCHAR *pszSep )
    {
        while( pszSep && *pszSep )
        {
            if( wch == *pszSep )
                return true;
            ++pszSep;
        }
        return false;
    }

    inline bool fIsSpecialChar(WCHAR w)
    {
        return ((w == L'+') || (w == L'-') || (w == L'?'));
    }

    inline HRESULT RuleFromHandle(SPSTATEHANDLE hState, CRule ** ppRule);

    template <class T>
    HRESULT WriteStream(const T & obj)
    {
        return WriteStream(&obj, sizeof(obj));
    }

public:
    CStringBlob         m_Words;
    CStringBlob         m_Symbols;
    SPCFGHEADER       * m_pInitHeader;
    ULONG               m_cResources;
    GUID                m_guid;
    LANGID              m_LangID;
    float             * m_pWeights;
    BOOL                m_fNeedWeightTable;
    ULONG               m_ulSpecialTransitions;
    ULONG               m_cImportedRules;
    CSpHandleTable<CGramNode, SPSTATEHANDLE>    m_StateHandleTable;
    CSpBasicQueue<CRule, TRUE, TRUE>            m_RuleList;
    CComPtr<ISpErrorLog>                        m_cpErrorLog;
    CComPtr<IStream>                            m_cpStream;
    CComPtr<ISpPhoneConverter>                  m_cpPhoneConverter;
};


class CResource : public SPCFGRESOURCE
{
public:
    CResource       * m_pNext;
    CGramBackEnd    * m_pParent;
    CResource(CGramBackEnd * pParent) : m_pParent(pParent) {}
    HRESULT Init(const SPCFGHEADER * pHeader, const SPCFGRESOURCE * pResource)
    {
        HRESULT hr = S_OK;
        if (pResource && m_pParent)
        {
            memcpy(this, pResource, sizeof(*pResource));
            hr = m_pParent->m_Symbols.Add(&pHeader->pszSymbols[pResource->ResourceNameSymbolOffset], &ResourceNameSymbolOffset);
            if (SUCCEEDED(hr))
            {
                hr = m_pParent->m_Symbols.Add(&pHeader->pszSymbols[pResource->ResourceValueSymbolOffset], &ResourceValueSymbolOffset);
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }
        return hr;
    }
    const WCHAR * Name() const
    {
        return m_pParent->m_Symbols.String(ResourceNameSymbolOffset);
    }
    operator ==(const WCHAR * psz) const
    {
        return (wcscmp(Name(), psz) == 0);
    }
    static LONG Compare(const CResource * pElem1, const CResource * pElem2)
    {
        return wcscmp(pElem1->Name(), pElem2->Name());
    }
};

typedef struct SPRULEREFLIST
{
    CRule *pRule;
    struct SPRULEREFLIST *m_pNext;
} SPRULEREFLIST;

typedef struct SPRULEIDENTIFIER
{
    DWORD           RuleId;
    const WCHAR   * pszRuleName;
} SPRULEIDENTIFIER;

class CRule : public SPCFGRULE
{
public:
    // NOTE:  Do *NOT* delete this member on destruction.  It will be cleaned up
    //        by the compiler since the node will be inserted into the node handle table
    //        of the CGramBackEnd object when it is created.
    CGramNode   * m_pFirstNode;
    SPSTATEHANDLE m_hInitialState;
    CRule       * m_pNext;
    bool        m_fHasExitPath;
    bool        m_fCheckingForExitPath;
    bool        m_fHasDynamicRef;
    ULONG       m_ulSerializeIndex;
    ULONG       m_ulOriginalBinarySerialIndex;
    ULONG       m_cNodes;
    ULONG       m_ulSpecialTransitions;

    CSpBasicQueue<SPRULEREFLIST> m_ListOfReferencedRules;
    bool        m_fCheckedAllRuleReferences;
    bool        m_fStaticRule;      // this is used to refer to a static rule from a dynamic rule

    CGramBackEnd    * m_pParent;
    CSpBasicQueue<CResource> m_ResourceList;
    CRule(CGramBackEnd * pParent, const WCHAR * pszRuleName, DWORD dwRuleId, DWORD dwAttributes, HRESULT * phr);
    HRESULT CheckForExitPath();

    // Structure used by CheckForDynmaicRef
    struct CHECKDYNRULESTACK
    {
        CHECKDYNRULESTACK   * m_pNext;
        CRule               * m_pRule;
        SPRULEREFLIST       * m_pNextRuleRef;
    };

    bool CheckForDynamicRef(CHECKDYNRULESTACK * pStack = NULL);
    const WCHAR * Name() const 
    {
        return m_pParent->m_Symbols.String(NameSymbolOffset);
    }
    operator ==(const WCHAR * pszRuleName)
    {
        const WCHAR * pszThisName = Name();
        return (pszThisName && (wcscmp(pszThisName, pszRuleName) == 0));
    }
    operator ==(DWORD dw)
    {
        return (RuleId && (RuleId == dw));
    }
    operator ==(SPRULEIDENTIFIER ri)
    {
        const WCHAR * pszThisName = Name();
        return ((ri.RuleId && (ri.RuleId == RuleId)) || (pszThisName && ri.pszRuleName && wcscmp(pszThisName, ri.pszRuleName) == 0));
    }
    //
    //  Place all imports at the start of the rule table and dynamic rules at the end
    //
    static LONG Compare(const CRule * pElem1, const CRule * pElem2)
    {
        if (pElem1->fImport)
        {
            return (pElem2->fImport) ? 0 : -1;
        }
        else if (pElem1->fDynamic)
        {
            return (pElem2->fDynamic) ? 0 : 1;
        }
        else
        {
            return (pElem2->fImport) ? 1 : (pElem2->fDynamic) ? -1 : 0;
        }
    }
    HRESULT Serialize();
    HRESULT SerializeResources();
    HRESULT Validate();
};

class CSemanticTag : public SPCFGSEMANTICTAG
{
public:
    CSemanticTag() : m_pStartArc(NULL), m_pEndArc(NULL) {};
    CSemanticTag(CSemanticTag *pTag) : m_pStartArc(NULL), m_pEndArc(NULL)
    {
        if (pTag)
        {
            memcpy(this, pTag, sizeof(CSemanticTag));
        }
    }
public:
    HRESULT Init(CGramBackEnd * pBackEnd, const SPPROPERTYINFO * pPropInfo);
    HRESULT Init(CGramBackEnd * pBackEnd, const SPCFGHEADER * pHeader, CArc ** apArcTable, const SPCFGSEMANTICTAG *pSemTag);
    BOOL operator==(CSemanticTag pTag)
    {
        return (memcmp(static_cast<SPCFGSEMANTICTAG*>(this), static_cast<SPCFGSEMANTICTAG*>(&pTag), sizeof(SPCFGSEMANTICTAG)) == 0);
    }
public:
    CArc            * m_pStartArc;
    CArc            * m_pEndArc;
};

class CArc
{
public:
    CArc            * m_pNext;
    CSemanticTag    * m_pSemanticTag;        // If non-null then has semantic tag associated with this
    CArc            * m_pNextArcForSemanticTag; // If non-null then semantic tag can move to here
    CGramNode       * m_pNextState;
    ULONG           m_ulIndexOfWord;      // Either word index or pRule but not both
    ULONG           m_ulCharOffsetOfWord; // Offset into string blob  
    bool            m_fOptional;         
    float           m_flWeight;
    char            m_RequiredConfidence;
    CRule           *   m_pRuleRef;
    ULONG           m_SpecialTransitionIndex;   // If != 0 then transition to dictation, text buffer, or wildcard
    ULONG           m_ulSerializationIndex;

    CArc();
    ~CArc();
    HRESULT Init(CGramNode * pSrcNode, CGramNode * pDestNode,
                 const WCHAR * pszWord, CRule * pRuleRef,
                 CSemanticTag * pSemanticTag,
                 float flWeight, 
                 bool fOptional,
                 char ConfRequired,
                 SPSTATEHANDLE hSpecialRuleRef);
    HRESULT Init2(CGramNode * pSrcNode, CGramNode * pDestNode,
                  const ULONG ulCharOffsetOfWord, 
                  const ULONG ulIndexOfWord,
                  CSemanticTag * pSemanticTag,
                  float flWeight, 
                  bool fOptional,
                  char ConfRequired,
                  const ULONG hSpecialTransitionIndex);

    HRESULT SerializeArcData(CGramBackEnd * pBackend, BOOL fIsEpsilon, ULONG ulArcIndex, float *pWeight);
    HRESULT SerializeSemanticData(CGramBackEnd * pBackend, ULONG ArcDataIndex);
    LONG SortRank() const
    {
        if (m_pRuleRef) return 1;      // It's a rule - Place 2nd in list
        if (m_ulIndexOfWord) return 2;// It's a word - Place last in list
        if (m_SpecialTransitionIndex) return 3; // It's a special transition (dictation, text buffer, or wildcard)
        return 0;                   // It's an epsilon -- We're first
    }
    static LONG Compare(const CArc * pElem1, const CArc * pElem2)
    {
        return pElem1->SortRank() - pElem2->SortRank();
    }
    bool HasSemanticTag()
    {
        return (m_pSemanticTag != NULL);
    }
};

class CGramNode
{
    enum RecurFlag  // Flags used for recurive validation methods
    {
        RF_CHECKED_EPSILON = (1 << 0),
        RF_CHECKED_EXIT_PATH  = (1 << 1),
        RF_CHECKED_LEFT_RECURSION = (1 << 2),
        RF_IN_LEFT_RECUR_CHECK = (1 << 3)
    };

public:
    CGramNode(CRule * pRule) 
    {
        m_pRule = pRule;
        m_pParent = pRule->m_pParent;
        m_RecurTestFlags = 0;
        m_ulSerializeIndex= 0;
        m_cArcs = 0;
        m_cEpsilonArcs = 0;
        m_hState = 0;
    }

    operator ==(const CRule * pRule)
    {
        return (pRule == m_pRule);
    }

    ULONG NumArcs()
    {
        return m_cArcs;
    }

    ULONG NumSemanticTags()
    {
        ULONG c = 0;
        for (CArc * pArc = m_ArcList.GetHead(); pArc; pArc = pArc->m_pNext)
        {
            if (pArc->HasSemanticTag())
            {
                c += (pArc->m_fOptional == TRUE) ? 2 : 1;
            }
        }
        return c;
    }

    HRESULT SerializeNodeEntries(float *pWeights, ULONG *pArcOffset, ULONG *pOffset)
    {
        HRESULT hr = S_OK;
        ULONG i = 0;
        CArc *pEpsArc = m_ArcList.GetHead();
        for (; SUCCEEDED(hr) && (i < m_cEpsilonArcs); i++)
        {
            while(!pEpsArc->m_fOptional)
            {
                pEpsArc = pEpsArc->m_pNext;
                SPDBG_ASSERT(pEpsArc != NULL);      // we can't run out of arcs before we've found all espilons!
            }
            hr = pEpsArc->SerializeArcData(m_pParent, TRUE, (*pArcOffset)++, pWeights ? &pWeights[(*pOffset)++] : NULL);
            pEpsArc = pEpsArc->m_pNext;
        }
        for (CArc * pArc = m_ArcList.GetHead(); pArc && SUCCEEDED(hr); pArc = pArc->m_pNext)
        {
            hr = pArc->SerializeArcData(m_pParent, FALSE, (*pArcOffset)++, pWeights ? &pWeights[(*pOffset)++] : NULL);
        }
        return hr;
    }

    HRESULT AddSingleWordTransition(const WCHAR * pszWord, const WCHAR * pszPropName, DWORD dwPropId,
                                    const WCHAR * pszPropValue, ULONGLONG ullPropValue, BOOL fHasValue,
                                    float flWeight, CGramNode * pDestState, 
                                    bool fOptional, BOOL fLowConfRequired, BOOL fHighConfRequired);

    CArc * CGramNode::FindEqualWordPropertyTransition(
                                    const WCHAR * psz,
                                    const WCHAR * pszPropName,
                                    DWORD dwPropId,
                                    const WCHAR * pszPropStringValue,
                                    ULONGLONG ullPropValue,
                                    BOOL fHasValue,
                                    float flWeight,
                                    bool fOptional);

    CArc * CGramNode::FindEqualRuleTransition(
                    const CGramNode * pDestNode,
                    const CRule * pRuleToTransitionTo,
                    SPSTATEHANDLE hSpecialRuleTrans,
                    float flWeight);

    CArc * CGramNode::FindEqualWordTransition(
                                    const WCHAR * psz,
                                    float flWeight,
                                    bool fOptional);

    CArc * CGramNode::FindEqualEpsilonArc();

    HRESULT SerializeSemanticTags()
    {
        HRESULT hr = S_OK;
        ULONG i = m_ulSerializeIndex;
        for (CArc * pArc = m_ArcList.GetHead(); pArc && SUCCEEDED(hr); pArc = pArc->m_pNext)
        {
            if (pArc->m_fOptional)
            {
                hr = pArc->SerializeSemanticData(m_pParent, i);
                i++;
            }
        }
        for (pArc = m_ArcList.GetHead(); pArc && SUCCEEDED(hr); pArc = pArc->m_pNext, i++)
        {
            hr = pArc->SerializeSemanticData(m_pParent, i);
        }
        return hr;
    }

    HRESULT CheckDynamicRefs(bool * pfHasDynamicRefs)
    {
        *pfHasDynamicRefs = TRUE;
        return S_OK;
    }

    HRESULT CheckEpsilonRule()
    {
        HRESULT hr = S_OK;
        if ((m_RecurTestFlags & RF_CHECKED_EPSILON) == 0)
        {
            m_RecurTestFlags |= RF_CHECKED_EPSILON;
            for (CArc * pArc = m_ArcList.GetHead();
                 pArc && SUCCEEDED(hr) && pArc->m_pRuleRef == NULL && 
                 !pArc->m_SpecialTransitionIndex &&
                 (pArc->m_ulIndexOfWord == 0 || pArc->m_fOptional);
                 pArc = pArc->m_pNext)
            {
                if (pArc->m_pNextState)
                {
                    hr = pArc->m_pNextState->CheckEpsilonRule();
                }
                else
                {
                    hr = m_pParent->LogError(SPERR_ALL_WORDS_OPTIONAL, IDS_EPSILON_RULE, m_pRule);
                }
            }
        }
        return hr;
    }

    HRESULT CheckExitPath(ULONG cWords)
    {
        HRESULT hr = S_OK;
        if (((m_RecurTestFlags & RF_CHECKED_EXIT_PATH) == 0) && (cWords < 256))
        {
            m_RecurTestFlags |= RF_CHECKED_EXIT_PATH;
            for (CArc * pArc = m_ArcList.GetHead();
                 pArc && SUCCEEDED(hr) && (!m_pRule->m_fHasExitPath);
                 pArc = pArc->m_pNext)
            {
                if (pArc->m_pRuleRef)
                {
                    hr = pArc->m_pRuleRef->CheckForExitPath();
                    if (SUCCEEDED(hr) && pArc->m_pRuleRef->m_fHasExitPath)
                    {
                        if (pArc->m_pNextState == NULL)
                        {
                            m_pRule->m_fHasExitPath = true;
                        }
                        else
                        {
                            hr = pArc->m_pNextState->CheckExitPath(pArc->m_pRuleRef ? cWords : ++cWords);
                        }
                    }
                }
                else
                {
                    if (pArc->m_pNextState == NULL)
                    {
                        m_pRule->m_fHasExitPath = true;
                    }
                    else
                    {
                        hr = pArc->m_pNextState->CheckExitPath(pArc->m_pRuleRef ? cWords : ++cWords);
                    }
                }
            }
        }
        return hr;
    }

    HRESULT CheckLeftRecursion()
    {
        HRESULT hr = S_OK;
        if (m_RecurTestFlags & RF_IN_LEFT_RECUR_CHECK)
        {
            hr = m_pParent->LogError(SPERR_CIRCULAR_RULE_REF, IDS_CIRCULAR_REF, m_pRule);
        }
        else
        {
            if ((m_RecurTestFlags & RF_CHECKED_LEFT_RECURSION) == 0)
            {
                m_RecurTestFlags |= RF_CHECKED_LEFT_RECURSION | RF_IN_LEFT_RECUR_CHECK;
                // Only need to look at epsilon and rule references
                for (CArc * pArc = m_ArcList.GetHead();
                     pArc && SUCCEEDED(hr) && pArc->m_ulIndexOfWord == 0;
                     pArc = pArc->m_pNext)
                {
                    if (pArc->m_pRuleRef)
                    {
                        hr = pArc->m_pRuleRef->m_pFirstNode->CheckLeftRecursion();
                    }
                    else    // It's a epsilon
                    {
                        if (pArc->m_pNextState && !pArc->m_SpecialTransitionIndex)
                        {
                            hr = pArc->m_pNextState->CheckLeftRecursion();
                        }
                    }
                }
                m_RecurTestFlags &= (~RF_IN_LEFT_RECUR_CHECK);
            }
        }
        return hr;
    }

    void Reset()
    {
        m_ArcList.Purge();
        m_cArcs = 0;
        m_cEpsilonArcs = 0;
    }

    static LONG Compare(const CGramNode * pNode1, const CGramNode * pNode2)
    {
        return (pNode1->m_pRule->m_ulSerializeIndex - pNode2->m_pRule->m_ulSerializeIndex);
    }


public:
    CGramBackEnd        *   m_pParent;
    CRule               *   m_pRule;
    CGramNode           *   m_pNext;
    CSpBasicQueue<CArc, TRUE, TRUE>   m_ArcList;
    ULONG               m_ulSerializeIndex;
    DWORD               m_RecurTestFlags;   // Flags used by recursive algorithms
    ULONG               m_cEpsilonArcs;
    ULONG               m_cArcs;
    SPSTATEHANDLE       m_hState;
};


inline HRESULT CGramBackEnd::LogError(HRESULT hr, UINT uID, const CRule * pRule)
{
    if (m_cpErrorLog)
    {
        if (pRule->Name())
        {
            LogError(hr, uID, pRule->Name());
        }
        else
        {
            USES_CONVERSION;
            TCHAR sz[40];
            wsprintf(sz, _T("ID = %ld"), pRule->RuleId);
            LogError(hr, uID, T2W(sz));
        }
    }
    return hr;
}

/****************************************************************************
* ValidateSemanticVariantType *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT ValidateSemanticVariantType(VARTYPE Type)
{
    switch (Type)
    {
    case VT_EMPTY:
    case VT_I2:
    case VT_I4:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_BOOL:
    case VT_I1:
    case VT_UI2:
    case VT_UI4:
    case VT_INT:
    case VT_UINT:

    case VT_BYREF | VT_I2:
    case VT_BYREF | VT_I4:
    case VT_BYREF | VT_R4:
    case VT_BYREF | VT_R8:
    case VT_BYREF | VT_CY:
    case VT_BYREF | VT_DATE:
    case VT_BYREF | VT_BOOL:
    case VT_BYREF | VT_I1:
    case VT_BYREF | VT_UI2:
    case VT_BYREF | VT_UI4:
    case VT_BYREF | VT_INT:
    case VT_BYREF | VT_UINT:

    case VT_BYREF | VT_VOID:
        return S_OK;

    default:
        SPDBG_REPORT_ON_FAIL( E_INVALIDARG );
        return E_INVALIDARG;
    }
}

#endif //__GRAMMAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_voicecp.h ===
#ifndef _A_VOICECP_H_
#define _A_VOICECP_H_

#ifdef SAPI_AUTOMATION

template <class T>
class CProxy_ISpeechVoiceEvents : public IConnectionPointImpl<T, &DIID__ISpeechVoiceEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_StartStream(long StreamNumber, VARIANT StreamPosition)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
                vars[1] = StreamNumber;
                vars[0] = StreamPosition;
				DISPPARAMS disp = { &vars[0], NULL, 2, 0 };
				pDispatch->Invoke(DISPID_SVEStreamStart, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_EndStream(long StreamNumber, VARIANT StreamPosition)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[1] = StreamNumber;
                vars[0] = StreamPosition;
				DISPPARAMS disp = { &vars[0], NULL, 2, 0 };
				pDispatch->Invoke(DISPID_SVEStreamEnd, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

    VOID Fire_VoiceChange(long StreamNumber, VARIANT StreamPosition, ISpeechObjectToken* VoiceObjectToken)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[2] = StreamNumber;
                vars[1] = StreamPosition;
                vars[0] = VoiceObjectToken;
				DISPPARAMS disp = { &vars[0], NULL, 3, 0 };
				pDispatch->Invoke(DISPID_SVEVoiceChange, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}
                             
	VOID Fire_Bookmark(long StreamNumber, VARIANT StreamPosition, BSTR Bookmark, long BookmarkId)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[3] = StreamNumber;
                vars[2] = StreamPosition;
				vars[1] = Bookmark;
                vars[0] = BookmarkId;
				DISPPARAMS disp = { &vars[0], NULL, 4, 0 };
				pDispatch->Invoke(DISPID_SVEBookmark, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

    VOID Fire_Word(long StreamNumber, VARIANT StreamPosition, long CharacterPosition, long Length)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[3] = StreamNumber;
				vars[2] = StreamPosition;
                vars[1] = CharacterPosition;
				vars[0] = Length;
				DISPPARAMS disp = { &vars[0], NULL, 4, 0 };
				pDispatch->Invoke(DISPID_SVEWord, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

    VOID Fire_Sentence(long StreamNumber, VARIANT StreamPosition, long CharacterPosition, long Length)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[4];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[3] = StreamNumber;
				vars[2] = StreamPosition;
                vars[1] = CharacterPosition;
				vars[0] = Length;
				DISPPARAMS disp = { &vars[0], NULL, 4, 0 };
				pDispatch->Invoke(DISPID_SVESentenceBoundary, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_Phoneme(long StreamNumber, VARIANT StreamPosition, long Duration, short NextPhoneId, SpeechVisemeFeature Feature, short CurrentPhoneId)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[6];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[5] = StreamNumber;
                vars[4] = StreamPosition;
                vars[3] = Duration;
                vars[2] = NextPhoneId;
                vars[1] = Feature;
				vars[0] = CurrentPhoneId;
				DISPPARAMS disp = { &vars[0], NULL, 6, 0 };
				pDispatch->Invoke(DISPID_SVEPhoneme, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_Viseme(long StreamNumber, VARIANT StreamPosition, long Duration, SpeechVisemeType NextVisemeId, SpeechVisemeFeature Feature, SpeechVisemeType CurrentVisemeId)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[6];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[5] = StreamNumber;
                vars[4] = StreamPosition;
                vars[3] = Duration;
                vars[2] = NextVisemeId;
                vars[1] = Feature;
				vars[0] = CurrentVisemeId;
				DISPPARAMS disp = { &vars[0], NULL, 6, 0 };
				pDispatch->Invoke(DISPID_SVEViseme, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_AudioLevel(long StreamNumber, VARIANT StreamPosition, long AudioLevel)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[2] = StreamNumber;
                vars[1] = StreamPosition;
                vars[0] = AudioLevel;
				DISPPARAMS disp = { &vars[0], NULL, 3, 0 };
				pDispatch->Invoke(DISPID_SVEAudioLevel, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}

	VOID Fire_EnginePrivate(long StreamNumber, VARIANT StreamPosition, VARIANT lParam)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant vars[3];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				vars[2] = StreamNumber;
                vars[1] = StreamPosition;
                vars[0] = lParam;
				DISPPARAMS disp = { &vars[0], NULL, 3, 0 };
				pDispatch->Invoke(DISPID_SVEEnginePrivate, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
	}
};

#endif // SAPI_AUTOMATION

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_voice.h ===
/*******************************************************************************
* a_voice.h *
*-----------*
*   Description:
*       This is the header file for the CSpeechVoice implementation.
*-------------------------------------------------------------------------------
*  Created By: EDC                            Date: 09/30/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef a_voice_h
#define a_voice_h

#ifdef SAPI_AUTOMATION

//--- Additional includes
#include "resource.h"
#include "a_voiceCP.h"

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================
class CSpeechVoice;
class CVoices;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CSpeechVoiceStatus
*   This object is used to access the status of
*   the associated speech voice.
*/
class ATL_NO_VTABLE CSpeechVoiceStatus : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IDispatchImpl<ISpeechVoiceStatus, &IID_ISpeechVoiceStatus, &LIBID_SpeechLib, 5>
{
  /*=== ATL Setup ===*/
  public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSpeechVoiceStatus)
	    COM_INTERFACE_ENTRY(ISpeechVoiceStatus)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

  /*=== Methods =======*/
  public:
    /*--- Constructors/Destructors ---*/

    /*--- Non interface methods ---*/

  /*=== Interfaces ====*/
  public:
    //--- ISpeechVoiceStatus ----------------------------------
	STDMETHOD(get_CurrentStreamNumber)( long* StreamNumber );
    STDMETHOD(get_LastStreamNumberQueued)( long* StreamNumber );
    STDMETHOD(get_LastHResult)( long* HResult );
  	STDMETHOD(get_RunningState)( SpeechRunState* State );
  	STDMETHOD(get_InputWordPosition)( long* Position );
  	STDMETHOD(get_InputWordLength)( long* Length );
  	STDMETHOD(get_InputSentencePosition)( long* Position );
  	STDMETHOD(get_InputSentenceLength)( long* Length );
  	STDMETHOD(get_LastBookmark)( BSTR* BookmarkString );
    STDMETHOD(get_LastBookmarkId)( long* BookmarkId );
	STDMETHOD(get_PhonemeId)( short* PhoneId );
    STDMETHOD(get_VisemeId)( short* VisemeId );

  /*=== Member Data ===*/
    SPVOICESTATUS       m_Status;
    CSpDynamicString    m_dstrBookmark;
};

#endif // SAPI_AUTOMATION

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\a_voiceei.h ===
/*******************************************************************************
* a_voiceei.h *
*-----------*
*   Description:
*       This is the header file for the CSpeechVoiceEventInterests implementation.
*-------------------------------------------------------------------------------
*  Created By: Leonro                            Date: 11/16/00
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef a_voiceei_h
#define a_voiceei_h

#ifdef SAPI_AUTOMATION

//--- Additional includes
#include "resource.h"
#include "spvoice.h"

//=== Constants ====================================================

//=== Class, Enum, Struct and Union Declarations ===================
class CSpeechVoice;
class CSpeechVoiceEventInterests;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================

//=== Class, Struct and Union Definitions ==========================

/*** CSpeechVoiceEventInterests
*   This object is used to access the Event interests on
*   the associated speech voice.
*/
class ATL_NO_VTABLE CSpeechVoiceEventInterests : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<ISpeechVoiceEventInterests, &IID_ISpeechVoiceEventInterests, &LIBID_SpeechLib, 5>
{
    friend CSpVoice;

  /*=== ATL Setup ===*/
  public:
    BEGIN_COM_MAP(CSpeechVoiceEventInterests)
	    COM_INTERFACE_ENTRY(ISpeechVoiceEventInterests)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()
  
  /*=== Interfaces ====*/
  public:
    //--- Constructors/Destructors ----------------------------
    CSpeechVoiceEventInterests() :
        m_pCSpVoice(0){}

    void FinalRelease();

    //--- ISpeechVoiceEventInterests ----------------------------------
    STDMETHOD(put_StreamStart)( VARIANT_BOOL Enabled );
    STDMETHOD(get_StreamStart)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_StreamEnd)( VARIANT_BOOL Enabled );
    STDMETHOD(get_StreamEnd)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_VoiceChange)( VARIANT_BOOL Enabled );
    STDMETHOD(get_VoiceChange)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_Bookmark)( VARIANT_BOOL Enabled );
    STDMETHOD(get_Bookmark)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_WordBoundary)( VARIANT_BOOL Enabled );
    STDMETHOD(get_WordBoundary)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_Phoneme)( VARIANT_BOOL Enabled );
    STDMETHOD(get_Phoneme)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_SentenceBoundary)( VARIANT_BOOL Enabled );
    STDMETHOD(get_SentenceBoundary)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_Viseme)( VARIANT_BOOL Enabled );
    STDMETHOD(get_Viseme)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_AudioLevel)( VARIANT_BOOL Enabled );
    STDMETHOD(get_AudioLevel)( VARIANT_BOOL* Enabled );
    STDMETHOD(put_EnginePrivate)( VARIANT_BOOL Enabled );
    STDMETHOD(get_EnginePrivate)( VARIANT_BOOL* Enabled );
    STDMETHOD(SetAll)();
    STDMETHOD(ClearAll)();

  /*=== Member Data ===*/
    CSpVoice*                               m_pCSpVoice;
};

#endif // SAPI_AUTOMATION

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\backend.cpp ===
// Grammar.cpp : Implementation of CGramBackEnd
#include "stdafx.h"
#include <math.h>
#include "cfggrammar.h"
#include "BackEnd.h"

/////////////////////////////////////////////////////////////////////////////
// CGramBackEnd

inline HRESULT CGramBackEnd::RuleFromHandle(SPSTATEHANDLE hState, CRule ** ppRule)
{
    CGramNode * pNode;
    HRESULT hr = m_StateHandleTable.GetHandleObject(hState, &pNode);
    *ppRule = SUCCEEDED(hr) ? pNode->m_pRule : NULL;
    return hr;
}


HRESULT CGramBackEnd::FinalConstruct()
{
    m_pInitHeader = NULL;
    m_pWeights = NULL;
    m_fNeedWeightTable = FALSE;
    m_cResources = 0;
    m_ulSpecialTransitions = 0;
    m_cImportedRules = 0;
    m_LangID = ::SpGetUserDefaultUILanguage();
    return S_OK;
}

/****************************************************************************
* CGramBackEnd::FinalRelease *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CGramBackEnd::FinalRelease()
{
    SPDBG_FUNC("CGramBackEnd::FinalRelease");
    Reset();
}

/****************************************************************************
* CGramBackEnd::FindRule *
*------------------------*
*   Description:
*       Internal method for finding rule in rule list
*   Returns:
*       S_OK 
*       SPERR_RULE_NOT_FOUND        -- no rule found
*       SPERR_RULE_NAME_ID_CONFLICT -- rule name and id don't match
********************************************************************* RAL ***/

HRESULT CGramBackEnd::FindRule(DWORD dwRuleId, const WCHAR * pszRuleName, CRule ** ppRule)
{
    SPDBG_FUNC("CGramBackEnd::FindRule");
    HRESULT hr = S_OK;

    CRule * pRule = NULL;
    if (!SP_IS_BAD_OPTIONAL_STRING_PTR(pszRuleName))
    {
        SPRULEIDENTIFIER ri;
        ri.pszRuleName = pszRuleName;
        ri.RuleId = dwRuleId;
        pRule = m_RuleList.Find(ri);
        if (pRule)
        {
            const WCHAR * pszFoundName = pRule->Name();
            // at least one of the 2 arguments matched
            // names either match or they are both NULL!
            if (((dwRuleId == 0) || (pRule->RuleId == dwRuleId)) && 
                (!pszRuleName || (pszRuleName && pszFoundName && !wcscmp(pszFoundName, pszRuleName))))
            {
                hr = S_OK;
            }
            else
            {
                pRule = NULL;
                hr = SPERR_RULE_NAME_ID_CONFLICT;
            }
        }
    }
    *ppRule = pRule;
    if (SUCCEEDED(hr) && (pRule == NULL))
    {
        hr = SPERR_RULE_NOT_FOUND;
    }

    if (SPERR_RULE_NOT_FOUND != hr)
    {
        SPDBG_REPORT_ON_FAIL( hr );
    }
    return hr;
}

/****************************************************************************
* CGramBackEnd::ResetGrammar *
*----------------------------*
*   Description:
*       Clears the grammar completely and sets LANGID
*   Returns:
*       S_OK
********************************************************************* RAL ***/

STDMETHODIMP CGramBackEnd::ResetGrammar(LANGID LangID)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CGramBackEnd::ResetGrammar");
    HRESULT hr = Reset();
    m_LangID = LangID;
    return hr;
}


/****************************************************************************
* CGramBackEnd::GetRule *
*-----------------------*
*   Description:
*       Tries to find the rule's initial state handle. If both a name and an id
*       are provided, then both have to match in order for this call to succeed.
*       If the rule doesn't already exist then we define it if fCreateIfNotExists, 
*       otherwise we return an error ().
*
*           - pszRuleName   name of rule to find/define     (NULL: don't care)
*           - dwRuleId      id of rule to find/define       (0: don't care)
*           - dwAttribute   rule attribute for defining the rule
*           - fCreateIfNotExists    creates the rule using name, id, and attributes
*                                   in case the rule doesn't already exist
*
*   Returns:
*       S_OK, E_INVALIDARG, E_OUTOFMEMORY
*       SPERR_RULE_NOT_FOUND        -- no rule found and we don't create a new one
*       SPERR_RULE_NAME_ID_CONFLICT -- rule name and id don't match
********************************************************************* RAL ***/

STDMETHODIMP CGramBackEnd::GetRule(const WCHAR * pszRuleName, 
                                   DWORD dwRuleId, 
                                   DWORD dwAttributes,
                                   BOOL fCreateIfNotExist,
                                   SPSTATEHANDLE *phInitialState)
{
    SPDBG_FUNC("CGramBackEnd::GetRule");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_READ_PTR(pszRuleName) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR(phInitialState) ||
        (!pszRuleName && (dwRuleId == 0)))
    {
        return E_INVALIDARG;
    }

    DWORD allFlags = SPRAF_TopLevel | SPRAF_TopLevel | SPRAF_Active | 
                     SPRAF_Export | SPRAF_Import | SPRAF_Interpreter |
                     SPRAF_Dynamic;

    if (dwAttributes && ((dwAttributes & ~allFlags) || ((dwAttributes & SPRAF_Import) && (dwAttributes & SPRAF_Export))))
    {
        SPDBG_REPORT_ON_FAIL( hr );
        return E_INVALIDARG;
    }

    CRule * pRule;
    hr = FindRule(dwRuleId, pszRuleName, &pRule);
    if (hr == SPERR_RULE_NOT_FOUND && fCreateIfNotExist)
    {
        hr = S_OK;
        if (m_pInitHeader)
        {
            // Scan all non-dynamic names and prevent a duplicate...
            for (ULONG i = 0; SUCCEEDED(hr) && i < m_pInitHeader->cRules; i++)
            {
                if ((pszRuleName && wcscmp(pszRuleName, m_pInitHeader->pszSymbols + m_pInitHeader->pRules[i].NameSymbolOffset) == 0) ||
                    (dwRuleId && m_pInitHeader->pRules[i].RuleId == dwRuleId))
                {
                    hr = SPERR_RULE_NOT_DYNAMIC;
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            pRule = new CRule(this, pszRuleName, dwRuleId, dwAttributes, &hr);
            if (pRule && SUCCEEDED(hr))
            {
                if (SUCCEEDED(hr))
                {
                    //
                    //  It is important to insert this at the tail for dynamic rules to 
                    //  retain their slot number.
                    //
                    m_RuleList.InsertSorted(pRule);
                }
                else
                {
                    delete pRule;
                    pRule = NULL;   // So we return a null to the caller...
                }
            }
            else
            {
                if (pRule)
                {
                    delete pRule;
                    pRule = NULL;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    if (phInitialState)
    {
        if (SUCCEEDED(hr))
        {
            //*phInitialState = pRule->fImport ? NULL : pRule->m_hInitialState;
            *phInitialState = pRule->m_hInitialState;
        }
        else
        {
            *phInitialState = NULL;
        }
    }
    return hr;
}


/****************************************************************************
* CGramBackEnd::ClearRule *
*-------------------------*
*   Description:
*       Remove all rule information except for the rule's initial state handle.
*   Returns:
*       S_OK
*       E_INVALIDARG    -- if hState is not valid
********************************************************************* RAL ***/

STDMETHODIMP CGramBackEnd::ClearRule(SPSTATEHANDLE hClearState)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CGramBackEnd::ClearRule");
    HRESULT hr = S_OK;

    CRule * pRule;
    hr = RuleFromHandle(hClearState, &pRule);
    if (SUCCEEDED(hr) && pRule->m_fStaticRule)
    {   
        hr = SPERR_RULE_NOT_DYNAMIC;
    }
    if (SUCCEEDED(hr) && pRule->m_pFirstNode)
    {
        pRule->m_pFirstNode->Reset();
        SPSTATEHANDLE hState = 0;
        pRule->fDirtyRule = TRUE;

        CGramNode * pNode;
        while (m_StateHandleTable.Next(hState, &hState, &pNode))
        {
            if ((pNode->m_pRule == pRule) && (hState != pRule->m_pFirstNode->m_hState))
            {
                m_StateHandleTable.Delete(hState);
            }
        }
        SPDBG_ASSERT(m_ulSpecialTransitions >= pRule->m_ulSpecialTransitions);
        m_ulSpecialTransitions -= pRule->m_ulSpecialTransitions;
        pRule->m_ulSpecialTransitions = 0;
        pRule->m_cNodes = 1;
        pRule->m_fHasDynamicRef = false;
        pRule->m_fCheckedAllRuleReferences = false;
        pRule->m_fHasExitPath = false;
        pRule->m_fCheckingForExitPath = false;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramBackEnd::CreateNewState *
*------------------------------*
*   Description:
*       Creates a new state handle in the same rule as hExistingState
*   Returns:
*       S_OK
*       E_POINTER   -- if phNewState is not valid
*       E_OUTOFMEMORY
*       E_INVALIDARG    -- if hExistingState is not valid
********************************************************************* RAL ***/

STDMETHODIMP CGramBackEnd::CreateNewState(SPSTATEHANDLE hExistingState, SPSTATEHANDLE * phNewState)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CGramBackEnd::CreateNewState");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(phNewState))
    {
        hr = E_POINTER;
    }
    else
    {
        *phNewState = NULL;
        CRule * pRule;
        hr = RuleFromHandle(hExistingState, &pRule);
        if (SUCCEEDED(hr))
        {
            if (pRule->m_fStaticRule)
            {
                hr = SPERR_RULE_NOT_DYNAMIC;
            }
            else
            {
                CGramNode * pNewNode = new CGramNode(pRule);
                if (pNewNode)
                {
                    hr = m_StateHandleTable.Add(pNewNode, phNewState);
                    if (FAILED(hr))
                    {
                        delete pNewNode;
                    }
                    else
                    {
                        pNewNode->m_hState = *phNewState;
                        pRule->m_cNodes++;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramBackEnd::AddResource *
*---------------------------*
*   Description:
*       Adds a resource (name and string value) to the rule specified in hRuleState.
*   Returns:
*       S_OK
*       E_OUTOFMEMORY
*       E_INVALIDARG                    -- for name and value or invalid rule handle
*       SPERR_DUPLICATE_RESOURCE_NAME   -- if resource already exists
********************************************************************* RAL ***/

HRESULT CGramBackEnd::AddResource(SPSTATEHANDLE hRuleState, const WCHAR * pszResourceName, const WCHAR * pszResourceValue)
{
    SPDBG_FUNC("CGramBackEnd::AddResource");
    HRESULT hr = S_OK;
    
    if (SP_IS_BAD_STRING_PTR(pszResourceName) ||
        SP_IS_BAD_OPTIONAL_STRING_PTR(pszResourceValue))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        CRule * pRule;
        hr = RuleFromHandle(hRuleState, &pRule);
        if (SUCCEEDED(hr) && pRule->m_fStaticRule)
        {
            hr = SPERR_RULE_NOT_DYNAMIC;
        }
        if (SUCCEEDED(hr))
        {
            if (pRule->m_ResourceList.Find(pszResourceName))
            {
                hr = SPERR_DUPLICATE_RESOURCE_NAME;
            }
            else
            {
                CResource * pRes = new CResource(this);
                if (pRes)
                {
                    hr = m_Symbols.Add(pszResourceName, &pRes->ResourceNameSymbolOffset);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_Symbols.Add(pszResourceValue, &pRes->ResourceValueSymbolOffset);
                    }
                    if (SUCCEEDED(hr))
                    {
                        pRule->m_ResourceList.InsertSorted(pRes);
                        pRule->fHasResources = true;
                        m_cResources++;
                        pRule->fDirtyRule = TRUE;
                    }
                    else
                    {
                        delete pRes;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CGramBackEnd::Reset *
*---------------------*
*   Description:
*       Internal method for clearing out the grammar info.
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CGramBackEnd::Reset()
{
    SPDBG_FUNC("CGramBackEnd::Reset");

    delete m_pInitHeader;
    m_pInitHeader = NULL;

    delete m_pWeights;
    m_pWeights = NULL;
    m_fNeedWeightTable = FALSE;

    m_cResources = 0;
    LANGID LangID = ::SpGetUserDefaultUILanguage();
    if (LangID != m_LangID)
    {
        m_LangID = LangID;
        m_cpPhoneConverter.Release();
    }

    m_Words.Clear();
    m_Symbols.Clear();

    m_RuleList.Purge();
    m_StateHandleTable.Purge();

    return S_OK;
}


/****************************************************************************
* CGramBackEnd::InitFromBinaryGrammar *
*-------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CGramBackEnd::InitFromBinaryGrammar(const SPBINARYGRAMMAR * pBinaryData)
{
    SPDBG_FUNC("CGramBackEnd::InitFromBinaryGrammar");
    HRESULT hr = S_OK;

    SPCFGHEADER * pHeader = NULL;
    if (SP_IS_BAD_READ_PTR(pBinaryData))
    {
        hr = E_POINTER;
    }
    else
    {
        pHeader = new SPCFGHEADER;
        if (pHeader)
        {
            hr = Reset();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = SpConvertCFGHeader(pBinaryData, pHeader);
    }
    if (SUCCEEDED(hr))
    {
        hr = m_Words.InitFrom(pHeader->pszWords, pHeader->cchWords);        
    }
    if (SUCCEEDED(hr))
    {
        hr = m_Symbols.InitFrom(pHeader->pszSymbols, pHeader->cchSymbols);
    }

    //
    // Build up the internal representation
    //
    CGramNode ** apNodeTable = NULL;
    if (SUCCEEDED(hr))
    {
        apNodeTable = new CGramNode * [pHeader->cArcs];
        if (!apNodeTable)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memset(apNodeTable, 0, pHeader->cArcs * sizeof (CGramNode*));
        }
    }
    CArc ** apArcTable = NULL;
    if (SUCCEEDED(hr))
    {
        apArcTable = new CArc * [pHeader->cArcs];
        if (!apArcTable)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memset(apArcTable, 0, pHeader->cArcs * sizeof (CArc*));
        }
    }
    //
    // Initialize the rules
    //
    SPCFGRESOURCE * pResource = (SUCCEEDED(hr) && pHeader) ? pHeader->pResources : NULL;
    for (ULONG i = 0; SUCCEEDED(hr) && i < pHeader->cRules; i++)
    {
        CRule * pRule = new CRule(this, m_Symbols.String(pHeader->pRules[i].NameSymbolOffset), pHeader->pRules[i].RuleId, SPRAF_Dynamic, &hr);
        if (pRule)
        {
            memcpy(static_cast<SPCFGRULE *>(pRule), pHeader->pRules + i, sizeof(SPCFGRULE));
            pRule->m_ulOriginalBinarySerialIndex = i;
            m_RuleList.InsertTail(pRule);
            pRule->m_fStaticRule = (pHeader->pRules[i].fDynamic) ? false : true;
            pRule->fDirtyRule = FALSE;
            pRule->m_fHasExitPath = (pRule->m_fStaticRule) ? TRUE : FALSE;  // by default loaded static rules have an exist 
                                                                            // or they wouldn't be there in the first place
            if (pHeader->pRules[i].FirstArcIndex != 0)
            {
                SPDBG_ASSERT(apNodeTable[pHeader->pRules[i].FirstArcIndex] == NULL);
                apNodeTable[pHeader->pRules[i].FirstArcIndex] = pRule->m_pFirstNode;
            }
            if (pRule->fHasResources)
            {
                SPDBG_ASSERT(pResource->RuleIndex == i);
                while(SUCCEEDED(hr) && (pResource->RuleIndex == i))
                {
                    CResource * pRes = new CResource(this);
                    if (!pRes)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        hr = pRes->Init(pHeader, pResource);
                    }
                    if (SUCCEEDED(hr))
                    {
                        pRule->m_ResourceList.InsertSorted(pRes);
                        pRule->fHasResources = true;
                        m_cResources++;
                        pRule->fDirtyRule = TRUE;
                    }
                    else
                    {
                        delete pRes;
                    }
                    pResource++;
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    //  Initialize the arcs
    //
    SPCFGARC * pLastArc = NULL;
    SPCFGARC * pArc = (SUCCEEDED(hr) && pHeader) ? pHeader->pArcs + 1 : NULL;
    SPCFGSEMANTICTAG *pSemTag = (SUCCEEDED(hr) && pHeader) ? pHeader->pSemanticTags : NULL;
    CGramNode * pCurrentNode = NULL;
    CRule * pCurrentRule = (SUCCEEDED(hr)) ? m_RuleList.GetHead() : NULL;
    CRule * pNextRule = (SUCCEEDED(hr) && pCurrentRule) ? m_RuleList.GetNext(pCurrentRule) : NULL;
    //
    //  We repersist the static and dynamic parts for now. A more efficient way would be to 
    //  only re-create the dynamic parts. Note that pSemTag and pResource need to be computed
    //
    for (ULONG k = 1 /* ulFirstDynamicArc */; SUCCEEDED(hr) && (k < pHeader->cArcs); pArc++, k++)
    {
        if (pNextRule && pNextRule->FirstArcIndex == k)
        {
            // we are entering a new rule now
            pCurrentRule = pNextRule;
            pNextRule = m_RuleList.GetNext(pNextRule);
        }

        // new pCurrentNode?
        if (!pLastArc || pLastArc->fLastArc)
        {
            if (apNodeTable[k] == NULL)
            {
                SPDBG_ASSERT(pCurrentRule != NULL);
                apNodeTable[k] = new CGramNode(pCurrentRule);
                if (apNodeTable[k] == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    SPSTATEHANDLE hIgnore;
                    hr = m_StateHandleTable.Add(apNodeTable[k], &hIgnore);
                    if (FAILED(hr))
                    {
                        delete apNodeTable[k];
                    }
                    else
                    {
                        apNodeTable[k]->m_hState = hIgnore; // ????
                    }
                }
            }
            pCurrentNode = apNodeTable[k];
        }

        //
        // now get the arc
        //
        CArc * pNewArc = NULL;
        if (SUCCEEDED(hr))
        {
            if (apArcTable[k] == NULL)
            {
                apArcTable[k] = new CArc;
                if (apArcTable[k] == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            pNewArc = apArcTable[k];
        }

        CGramNode * pTargetNode = NULL;
        if (SUCCEEDED(hr) && pNewArc && pCurrentNode && pArc->NextStartArcIndex)
        {
            if (!apNodeTable[pArc->NextStartArcIndex])
            {
                apNodeTable[pArc->NextStartArcIndex] = new CGramNode(pCurrentRule);
                if (apNodeTable[pArc->NextStartArcIndex] == NULL)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    SPSTATEHANDLE hIgnore;
                    hr = m_StateHandleTable.Add(apNodeTable[pArc->NextStartArcIndex], &hIgnore);
                    if (FAILED(hr))
                    {
                        delete apNodeTable[pArc->NextStartArcIndex];
                    }
                    else
                    {
                        apNodeTable[pArc->NextStartArcIndex]->m_hState = hIgnore; // ????
                    }
                }
            }
            pTargetNode = apNodeTable[pArc->NextStartArcIndex];
        }

        // 
        //  Add the semantic tags
        //
        CSemanticTag *pSemanticTag = NULL;
        if (SUCCEEDED(hr) && pArc->fHasSemanticTag)
        {
            // we should already point to the tag
            SPDBG_ASSERT(pSemTag->ArcIndex == k);
            pSemanticTag = new CSemanticTag();
            if (pSemanticTag)
            {
                pSemanticTag->Init(this, pHeader, apArcTable, pSemTag);
                pSemTag++;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (SUCCEEDED(hr))
        {
            float flWeight = (pHeader->pWeights) ? pHeader->pWeights[k] : DEFAULT_WEIGHT;
            // determine properties of the arc now ...
            if (pArc->fRuleRef)
            {
                CRule * pRuleToTransitionTo = m_RuleList.Item(pArc->TransitionIndex);
                if (pRuleToTransitionTo)
                {
                    hr = pNewArc->Init(pCurrentNode, pTargetNode, NULL, pRuleToTransitionTo, pSemanticTag,
                                       flWeight, FALSE, SP_NORMAL_CONFIDENCE, 0);
                }
                else
                {
                    hr = E_UNEXPECTED;
                }
            }
            else
            {
                ULONG ulSpecialTransitionIndex = (pArc->TransitionIndex == SPWILDCARDTRANSITION ||
                                                 pArc->TransitionIndex == SPDICTATIONTRANSITION ||
                                                 pArc->TransitionIndex == SPTEXTBUFFERTRANSITION) ? pArc->TransitionIndex : 0;
                ULONG ulOffset = (ulSpecialTransitionIndex != 0) ? 0 : m_Words.IndexFromId(pArc->TransitionIndex);
                hr = pNewArc->Init2(pCurrentNode, pTargetNode, ulOffset,  (ulSpecialTransitionIndex != 0) ? 0 : pArc->TransitionIndex, pSemanticTag, 
                                    flWeight, FALSE /*fOptional = false always because eps arc was already added*/, 
                                    pArc->fLowConfRequired ? SP_LOW_CONFIDENCE : 
                                    pArc->fHighConfRequired ? SP_HIGH_CONFIDENCE : SP_NORMAL_CONFIDENCE,
                                    ulSpecialTransitionIndex);
            }
            if (SUCCEEDED(hr))
            {
                pCurrentNode->m_ArcList.InsertSorted(pNewArc);
                apArcTable[k] = pNewArc;
                pCurrentNode->m_cArcs++;
            }
            else
            {
                delete pNewArc;
            }
        }
        else
        {
            delete pNewArc;
            hr = (S_OK == hr) ? E_OUTOFMEMORY : hr;
        }
        pLastArc = pArc;
    }

    delete [] apNodeTable;
    delete [] apArcTable;

    if (SUCCEEDED(hr))
    {
        m_guid = pHeader->GrammarGUID;
        if (pHeader->LangID != m_LangID)
        {
            m_LangID = pHeader->LangID;
            m_cpPhoneConverter.Release();
        }
        m_pInitHeader = pHeader;
    }
    else
    {
        delete pHeader;
        Reset();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramBackEnd::SetSaveObjects *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CGramBackEnd::SetSaveObjects(IStream * pStream, ISpErrorLog * pErrorLog)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CGramBackEnd::SetSaveObjects");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pStream) ||
        SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pErrorLog))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_cpStream = pStream;
        m_cpErrorLog = pErrorLog;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


//
//=== ISpGramCompBackendPrivate interface ==================================================
//

/****************************************************************************
* CGramBackEnd::GetRuleCount *
*------------------------------*
*   Description:
*
*   Returns:
*
******************************************************************* TODDT ***/
STDMETHODIMP CGramBackEnd::GetRuleCount(long * pCount)
{
    SPDBG_FUNC("CGramBackEnd::GetRuleCount");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pCount))
    {
        hr = E_POINTER;
    }
    else
    {
        *pCount = m_RuleList.GetCount();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramBackEnd::GetHRuleFromIndex *
*------------------------------*
*   Description:
*
*   Returns:
*
******************************************************************* TODDT ***/
STDMETHODIMP CGramBackEnd::GetHRuleFromIndex( ULONG Index, SPSTATEHANDLE * phRule )
{
    SPDBG_FUNC("CGramBackEnd::GetHRuleFromIndex");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(phRule))
    {
        hr = E_POINTER;
    }
    else
    {
        if ( Index >= m_RuleList.GetCount() )
            return E_INVALIDARG;

        // Now find the Rule
        ULONG ulIndex = 0;
        CRule * pCRule;
        for (   pCRule = m_RuleList.GetHead(); 
                pCRule && ulIndex < Index; 
                ulIndex++, pCRule = pCRule->m_pNext )
        {
            ;  // don't need to do anything till we find the rule
        }

        if ( pCRule && ulIndex == Index )
        {
            *phRule = pCRule->m_hInitialState;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramBackEnd::GetNameFromHRule *
*------------------------------*
*   Description:
*
*   Returns:
*
******************************************************************* TODDT ***/
STDMETHODIMP CGramBackEnd::GetNameFromHRule( SPSTATEHANDLE hRule, WCHAR ** ppszRuleName )
{
    SPDBG_FUNC("CGramBackEnd::GetNameFromHRule");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppszRuleName))
    {
        hr = E_POINTER;
    }
    else
    {
        CRule * pCRule;
        hr = RuleFromHandle(hRule, &pCRule);
        if ( SUCCEEDED( hr ) )
        {
            *ppszRuleName = (WCHAR *)pCRule->Name();
        }
        else
        {
            hr = SPERR_ALREADY_DELETED;  // We map E_INVALIDARG to this.
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramBackEnd::GetIdFromHRule *
*------------------------------*
*   Description:
*
*   Returns:
*
******************************************************************* TODDT ***/
STDMETHODIMP CGramBackEnd::GetIdFromHRule( SPSTATEHANDLE hRule, long * pId )
{
    SPDBG_FUNC("CGramBackEnd::GetIdFromHRule");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pId))
    {
        hr = E_POINTER;
    }
    else
    {
        CRule * pCRule;
        hr = RuleFromHandle(hRule, &pCRule);
        if ( SUCCEEDED( hr ) )
        {
            *pId = pCRule->RuleId;
        }
        else
        {
            hr = SPERR_ALREADY_DELETED;  // We map E_INVALIDARG to this.
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramBackEnd::GetAttributesFromHRule *
*------------------------------*
*   Description:
*
*   Returns:
*
******************************************************************* TODDT ***/
STDMETHODIMP CGramBackEnd::GetAttributesFromHRule( SPSTATEHANDLE hRule, SpeechRuleAttributes* pAttributes )
{
    SPDBG_FUNC("CGramBackEnd::GetAttributesFromHRule");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pAttributes))
    {
        hr = E_POINTER;
    }
    else
    {
        CRule * pCRule;
        hr = RuleFromHandle(hRule, &pCRule);
        if ( SUCCEEDED( hr ) )
        {
            *pAttributes = (SpeechRuleAttributes)( (pCRule->fDynamic ? SRADynamic : 0) |
                                                   (pCRule->fExport ? SRAExport : 0) |
                                                   (pCRule->fTopLevel ? SRATopLevel : 0) |
                                                   (pCRule->fPropRule ? SRAInterpreter : 0) |
                                                   (pCRule->fDefaultActive ? SRADefaultToActive : 0) |
                                                   (pCRule->fImport ? SRAImport : 0) );
        }
        else
        {
            hr = SPERR_ALREADY_DELETED;  // We map E_INVALIDARG to this.
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CGramBackEnd::GetTransitionCount *
*----------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
HRESULT CGramBackEnd::GetTransitionCount( SPSTATEHANDLE hState, long * pCount)
{
    SPDBG_FUNC("CGramBackEnd::GetTransitionCount");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR ( pCount ))
    {
        hr = E_POINTER;
    }
    else
    {
        CGramNode * pNode = NULL;
        hr = m_StateHandleTable.GetHandleObject(hState, &pNode);
        if (SUCCEEDED(hr))
        {
            *pCount = pNode->m_ArcList.GetCount();
        }
        else
        {
            hr = SPERR_ALREADY_DELETED;  // We map E_INVALIDARG to this.
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* HRESULT CGramBackEnd::GetTransitionType *
*-----------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
HRESULT CGramBackEnd::GetTransitionType( SPSTATEHANDLE hState, VOID * Cookie, VARIANT_BOOL *pfIsWord, ULONG * pulSpecialTransitions)
{
    SPDBG_FUNC("HRESULT CGramBackEnd::GetTransitionType");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR ( pfIsWord ) || SP_IS_BAD_WRITE_PTR( pulSpecialTransitions) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pulSpecialTransitions = 0;
        CGramNode * pNode = NULL;
        hr = m_StateHandleTable.GetHandleObject(hState, &pNode);
        if ( SUCCEEDED(hr) )
        {
            // We can just use the cookie as the pArc since in automation we
            // deal with transitions getting nuked appropriately.
            CArc * pArc = (CArc*)Cookie;
#if 0
            CArc * pArc = NULL;
            // Validate the arc.
            for (pArc = pNode->m_ArcList.GetHead(); pArc; pArc = pArc->m_pNext)
            {
                if (pArc == Cookie)
                {
                    break;
                }
            }
#endif // 0
            if (pArc)
            {
                if (pArc->m_pRuleRef != NULL)
                {
                    *pfIsWord = VARIANT_FALSE;
                }
                else if (pArc->m_SpecialTransitionIndex != 0)
                {
                    *pfIsWord = VARIANT_FALSE;
                    *pulSpecialTransitions = pArc->m_SpecialTransitionIndex;
                }
                else
                {
                    *pfIsWord = VARIANT_TRUE;
                    *pulSpecialTransitions = pArc->m_ulIndexOfWord;
                }
            }
            else
            {
                hr = SPERR_ALREADY_DELETED;
            }
        }
        else
        {
            hr = SPERR_ALREADY_DELETED;  // We map E_INVALIDARG to this.
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* HRESULT CGramBackEnd::GetTransitionText *
*-----------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
HRESULT CGramBackEnd::GetTransitionText( SPSTATEHANDLE hState, VOID * Cookie, BSTR * Text)
{
    SPDBG_FUNC("HRESULT CGramBackEnd::GetTransitionText");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( Text ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CGramNode * pNode = NULL;
        hr = m_StateHandleTable.GetHandleObject(hState, &pNode);
        if (SUCCEEDED(hr))
        {
            // We can just use the cookie as the pArc since in automation we
            // deal with transitions getting nuked appropriately.
            CArc * pArc = (CArc*)Cookie;
            if (pArc)
            {
                if (pArc->m_pRuleRef == NULL && pArc->m_SpecialTransitionIndex == 0)
                {
                    CComBSTR bstr(m_Words.Item(pArc->m_ulIndexOfWord));
                    hr = bstr.CopyTo(Text);
                }
                else
                {
                    // this is not a word so return NULL string!
                    *Text = NULL;
                }
            }
            else
            {
                hr = SPERR_ALREADY_DELETED;
            }
        }
        else
        {
            hr = SPERR_ALREADY_DELETED;  // We map E_INVALIDARG to this.
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* HRESULT CGramBackEnd::GetTransitionRule *
*-----------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
HRESULT CGramBackEnd::GetTransitionRule( SPSTATEHANDLE hState, VOID * Cookie, SPSTATEHANDLE * phRuleInitialState)
{
    SPDBG_FUNC("HRESULT CGramBackEnd::GetTransitionRule");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( phRuleInitialState ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CGramNode * pNode = NULL;
        hr = m_StateHandleTable.GetHandleObject(hState, &pNode);
        if (SUCCEEDED(hr))
        {
            if ( pNode )
            {
                // We can just use the cookie as the pArc since in automation we
                // deal with transitions getting nuked appropriately.
                CArc * pArc = (CArc*)Cookie;
                if (pArc)
                {
                    if (pArc->m_pRuleRef != NULL)
                    {
                        *phRuleInitialState = pArc->m_pRuleRef->m_hInitialState;
                    }
                    else
                    {
                        // this is not a rule so return a NULL hState and S_OK!
                        *phRuleInitialState = 0;
                    }
                }
                else
                {
                    hr = SPERR_ALREADY_DELETED;
                }
            }
            else
            {
                hr = SPERR_ALREADY_DELETED;
            }
        }
        else
        {
            hr = SPERR_ALREADY_DELETED;  // We map E_INVALIDARG to this.
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* HRESULT CGramBackEnd::GetTransitionWeight *
*-------------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
HRESULT CGramBackEnd::GetTransitionWeight( SPSTATEHANDLE hState, VOID * Cookie, VARIANT * Weight)
{
    SPDBG_FUNC("HRESULT CGramBackEnd::GetTransitionText");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR ( Weight ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CGramNode * pNode = NULL;
        hr = m_StateHandleTable.GetHandleObject(hState, &pNode);
        if (SUCCEEDED(hr))
        {
            // We can just use the cookie as the pArc since in automation we
            // deal with transitions getting nuked appropriately.
            CArc * pArc = (CArc*)Cookie;
            if (pArc)
            {
                Weight->vt = VT_R4;
                Weight->fltVal = pArc->m_flWeight;
            }
            else
            {
                hr = SPERR_ALREADY_DELETED;
            }
        }
        else
        {
            hr = SPERR_ALREADY_DELETED;  // We map E_INVALIDARG to this.
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramBackEnd::GetTransitionProperty *
*-------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
HRESULT CGramBackEnd::GetTransitionProperty(SPSTATEHANDLE hState, VOID * Cookie, SPTRANSITIONPROPERTY * pProperty)
{
    SPDBG_FUNC("CGramBackEnd::GetTransitionProperty");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR ( pProperty ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CGramNode * pNode = NULL;
        hr = m_StateHandleTable.GetHandleObject(hState, &pNode);
        if (SUCCEEDED(hr))
        {
            // We can just use the cookie as the pArc since in automation we
            // deal with transitions getting nuked appropriately.
            CArc * pArc = (CArc*)Cookie;
            if (pArc)
            {
                if (pArc->m_pSemanticTag)
                {
                    pProperty->pszName = m_Symbols.String(pArc->m_pSemanticTag->PropNameSymbolOffset);
                    pProperty->ulId = pArc->m_pSemanticTag->PropId;
                    pProperty->pszValue = m_Symbols.String(pArc->m_pSemanticTag->PropValueSymbolOffset);
                    hr = AssignSemanticValue(pArc->m_pSemanticTag, &pProperty->vValue);
                }
                else
                {
                    // Zero out pProperty since we don't have any and return S_OK
                    pProperty->pszName = NULL;
                    pProperty->ulId = 0;
                    pProperty->pszValue = NULL;
                    pProperty->vValue.vt = VT_EMPTY;
                }
            }
            else
            {
                hr = SPERR_ALREADY_DELETED;
            }
        }
        else
        {
            hr = SPERR_ALREADY_DELETED;  // We map E_INVALIDARG to this.
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramBackEnd::GetTransitionNextState *
*--------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/
HRESULT CGramBackEnd::GetTransitionNextState( SPSTATEHANDLE hState, VOID * Cookie, SPSTATEHANDLE * phNextState)
{
    SPDBG_FUNC("CGramBackEnd::GetTransitionNextState");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR ( phNextState ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CGramNode * pNode = NULL;
        hr = m_StateHandleTable.GetHandleObject(hState, &pNode);
        if (SUCCEEDED(hr))
        {
            // We can just use the cookie as the pArc since in automation we
            // deal with transitions getting nuked appropriately.
            CArc * pArc = (CArc*)Cookie;
            if (pArc)
            {
                *phNextState = (pArc->m_pNextState) ? pArc->m_pNextState->m_hState : (SPSTATEHANDLE) 0x0;
            }
            else
            {
                hr = SPERR_ALREADY_DELETED;
            }
        }
        else
        {
            hr = SPERR_ALREADY_DELETED;  // We map E_INVALIDARG to this.
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramBackEnd::GetTransitionCookie *
*--------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** ToddT ***/
HRESULT CGramBackEnd::GetTransitionCookie( SPSTATEHANDLE hState, ULONG Index, void ** pCookie )
{
    SPDBG_FUNC("CGramBackEnd::GetTransitionCookie");
    HRESULT hr = S_OK;

    if ( SP_IS_BAD_WRITE_PTR( pCookie ) )
    {
        hr = E_POINTER;
    }
    else
    {
        CGramNode * pNode = NULL;
        hr = m_StateHandleTable.GetHandleObject(hState, &pNode);
        if (SUCCEEDED(hr))
        {
            CArc * pArc = NULL;
            int i = 0;
            // Find the arc at the specified index.
            for (pArc = pNode->m_ArcList.GetHead(); pArc && (i != Index); i++, pArc = pArc->m_pNext)
            {
            }
            if (pArc)
            {
                // Return the pArc as the cookie.
                *pCookie = (void*)pArc;
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            hr = SPERR_ALREADY_DELETED;  // We map E_INVALIDARG to this.
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* ValidatePropInfo *
*------------------*
*   Description:
*       Helper used by AddWordTransition and AddRuleTransition to validate
*   a SPPROPERTYINFO structure.
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT ValidatePropInfo(const SPPROPERTYINFO * pPropInfo)
{
    SPDBG_FUNC("ValidatePropInfo");
    HRESULT hr = S_OK;

    if (pPropInfo)
    {
        if (SP_IS_BAD_READ_PTR(pPropInfo) ||
            SP_IS_BAD_OPTIONAL_STRING_PTR(pPropInfo->pszName) ||
            SP_IS_BAD_OPTIONAL_STRING_PTR(pPropInfo->pszValue))
        {
            hr = E_INVALIDARG;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramNode::FindEqualWordTransition *
*------------------------------------*
*   Description:
*       This returns a transition with exactly matching word information.
*       I.e. same, word, optionality and weight. Grammar end words are
*       again ignored.
*
*   Returns:
*       CArc * -- A transition matching the specified details with any
*                 properties (null or otherwise).
*
**************************************************************** AGARSIDE ***/

CArc * CGramNode::FindEqualWordTransition(
                const WCHAR * psz,
                float flWeight,
                bool fOptional)
{
    SPDBG_FUNC("CGramNode::FindEqualWordTransition");
    for (CArc * pArc = m_ArcList.GetHead(); pArc; pArc = pArc->m_pNext)
    {
        if (pArc->m_pRuleRef == NULL &&
            pArc->m_SpecialTransitionIndex == 0 &&
            pArc->m_fOptional == fOptional &&
            pArc->m_flWeight == flWeight &&
            m_pParent->m_Words.IsEqual(pArc->m_ulCharOffsetOfWord, psz))
        {
            return pArc;
        }
    }
    return NULL;
}

/****************************************************************************
* CGramNode::FindEqualWordTransition *
*------------------------------------*
*   Description:
*       This returns a transition with exactly matching word information.
*       I.e. same, word, optionality and weight. Grammar end words are
*       again ignored.
*
*   Returns:
*       CArc * -- A transition matching the specified details with any
*                 properties (null or otherwise).
*
**************************************************************** AGARSIDE ***/

CArc * CGramNode::FindEqualRuleTransition(
                const CGramNode * pDestNode,
                const CRule * pRuleToTransitionTo,
                SPSTATEHANDLE hSpecialRuleTrans,
                float flWeight)
{
    SPDBG_FUNC("CGramNode::FindEqualRuleTransition");
    for (CArc * pArc = m_ArcList.GetHead(); pArc; pArc = pArc->m_pNext)
    {
        if (pArc->m_pRuleRef && 
            (pArc->m_pNextState == pDestNode) &&
            (pArc->m_pRuleRef == pRuleToTransitionTo) &&
            (pArc->m_flWeight == flWeight))
        {
            return pArc;
        }
    }
    return NULL;
}

/****************************************************************************
* CGramNode::FindEqualEpsilonArc *
*--------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

CArc * CGramNode::FindEqualEpsilonArc()
{
    SPDBG_FUNC("CGramNode::FindEqualEsilonArc");
    for (CArc * pArc = m_ArcList.GetHead(); pArc; pArc = pArc->m_pNext)
    {
        if ((pArc->m_pRuleRef == NULL) &&
            (pArc->m_ulCharOffsetOfWord == 0))
        {
            return pArc;
        }
    }
    return NULL;
}

/****************************************************************************
* CGramBackEnd::PushProperty *
*----------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

HRESULT CGramBackEnd::PushProperty(CArc *pArc)
{
    SPDBG_FUNC("CGramBackEnd::PushProperty");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_READ_PTR(pArc))
    {
        hr = E_INVALIDARG;
        SPDBG_REPORT_ON_FAIL( hr );
        return hr;
    }

    if (pArc->m_pNextState == NULL)
    {
        hr = SPERR_AMBIGUOUS_PROPERTY;
        // Not necessarily true but we cannot handle this situation in here and
        // need to return an error message to kick off later handling.
    }
    else if (pArc->m_pNextArcForSemanticTag == NULL)
    {
        // We are not allowed to push the property off this node.
        // What we do need to do is insert an epsilon to hold the property to allow the word to be shared.
        SPSTATEHANDLE hTempState;
        CGramNode *pTempNode = NULL;
        hr = CreateNewState(pArc->m_pNextState->m_pRule->m_hInitialState, &hTempState);
        if (SUCCEEDED(hr))
        {
            hr = m_StateHandleTable.GetHandleObject(hTempState, &pTempNode);
        }
        if (SUCCEEDED(hr))
        {
            CArc *pEpsilonArc = new CArc;
            if (pEpsilonArc)
            {
                hr = pEpsilonArc->Init(pTempNode, pArc->m_pNextState, NULL, NULL, pArc->m_pSemanticTag, 1.0F, FALSE, 0, NULL);
                if (SUCCEEDED(hr))
                {
                    pTempNode->m_ArcList.InsertSorted(pEpsilonArc);
                    pTempNode->m_cArcs++;
                    pArc->m_pNextState = pTempNode;
                    pArc->m_pSemanticTag = NULL;
                    pArc->m_pNextArcForSemanticTag = NULL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        // push it to all outgoing arcs of pArc->m_pNextState
        CGramNode *pNode = pArc->m_pNextState;
        for (CArc *pTempArc = pNode->m_ArcList.GetHead(); pTempArc != NULL; pTempArc = pTempArc->m_pNext)
        {
            CSemanticTag *pSemTag = new CSemanticTag(pArc->m_pSemanticTag);
            if (pSemTag)
            {
                if ((pTempArc->m_pSemanticTag == NULL) || (*pTempArc->m_pSemanticTag == *pSemTag))
                {
                    // move it!
                    pTempArc->m_pSemanticTag = pSemTag;
                }
                else
                {
                    // Cannot move it since it already has a property!
                    // This should not happen.
                    SPDBG_ASSERT(FALSE);
                    hr = SPERR_AMBIGUOUS_PROPERTY;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        delete pArc->m_pSemanticTag;
        pArc->m_pSemanticTag = NULL;
        pArc->m_pNextArcForSemanticTag = NULL;  // break the chain now
    }

    if (SPERR_AMBIGUOUS_PROPERTY != hr)
    {
        SPDBG_REPORT_ON_FAIL( hr );
    }
    return hr;
}



/****************************************************************************
* CGramComp::AddSingleWordTransition *
*------------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

HRESULT CGramBackEnd::AddSingleWordTransition(
                        SPSTATEHANDLE hFromState,
                        CGramNode * pSrcNode,
                        CGramNode * pDestNode,
                        const WCHAR * psz,
                        float flWeight,
                        CSemanticTag * pSemanticTag,
                        BOOL fUseDestNode,                  // use pDestNode even if it is NULL
                        CGramNode **ppActualDestNode,       // this is the dest node we've actually used
                                                            // (either an existing node or a new one)
                        CArc **ppArcUsed,
                        BOOL *pfPropertyMatched)            // did we find a matching property?
{
    SPDBG_FUNC("CGramComp::AddSingleWordTransition");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pfPropertyMatched) || 
        SP_IS_BAD_WRITE_PTR(ppActualDestNode) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR(ppArcUsed))
    {
        return E_INVALIDARG;
    }

    *ppActualDestNode = NULL;
    *pfPropertyMatched = FALSE;   
    BOOL fReusedArc = FALSE;

    CArc * pArc = new CArc();
    if (pArc == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        bool fOptional = false;
        char RequiredConfidence = SP_NORMAL_CONFIDENCE;

        /// Extract attributes
        if (psz != NULL && (wcslen(psz) > 1))
        {
            ULONG ulAdvance = 0;
            ULONG ulLoop = (psz[2] == 0) ? 1 : 2;
            for (ULONG k = 0; k < ulLoop; k++)
            {
                switch (psz[k])
                {
                case L'-':
                    if (RequiredConfidence == SP_NORMAL_CONFIDENCE)
                    {
                        RequiredConfidence = SP_LOW_CONFIDENCE;
                        ulAdvance++;
                    }
                    break;
                case L'+':
                    if (RequiredConfidence == SP_NORMAL_CONFIDENCE)
                    {
                        RequiredConfidence = SP_HIGH_CONFIDENCE;
                        ulAdvance++;
                    }
                    break;
                case L'?':
                    if (!fOptional)
                    {
                        fOptional = true;
                        ulAdvance++;
                    }
                    break;
                default:
                    k = ulLoop;
                    break;
                }
            }
            psz += ulAdvance;
        }

        CArc *pEqualArc = pSrcNode->FindEqualWordTransition(psz, flWeight, fOptional);

        if (pEqualArc)
        {
            if (fUseDestNode && pEqualArc->m_pNextState != pDestNode && psz == NULL)
            {
                // We can't use this arc as we are an epsilon being specifically added to point to a 
                // different node than the existing 'equal' epsilon we have found. Allowing multiple
                // epsilon arcs in this scenario is legal.
                pEqualArc = NULL;
            }
        }
        if (pEqualArc)
        {
            if (pSemanticTag && pEqualArc->m_pSemanticTag && (*pSemanticTag == *(pEqualArc->m_pSemanticTag)))
            {
                // The matching arc has an exactly matching semantic tag.
                if ( (!fUseDestNode && pEqualArc->m_pNextState != NULL) || 
                      (fUseDestNode && pDestNode == pEqualArc->m_pNextState) )
                {
                    // Either:
                    // 1. We aren't the end arc in our path and the matching arc doesn't go to NULL.
                    // 2. We are the end arc and the matching arc goes to the supplied end state (can be NULL).
                    // In either case, we can reuse the matching arc exactly.
                    *ppActualDestNode = pEqualArc->m_pNextState;
                    *pfPropertyMatched = TRUE;
                    fReusedArc = TRUE;
                    if (ppArcUsed)
                    {
                        *ppArcUsed = pEqualArc;
                    }
                }
                else
                {
                    // We cannot reuse the arc as is because either:
                    // 1. It goes to NULL and we aren't the last arc in our path.
                    // 2. It goes to our supplied end state and we aren't the last arc in our path.
                    // 3. We are the last arc in our path and it doesn't go to our end state.

                    if (fUseDestNode)
                    {
                        // We are the last arc in our path.
                        // Add an epsilon to our destnode.
                        CArc *pEpsilonArc = new CArc;
                        if (pEpsilonArc)
                        {
                            // Create an epsilon to the original destination.
                            hr = pEpsilonArc->Init(pEqualArc->m_pNextState, pDestNode, NULL, NULL, NULL, 1.0F, FALSE, 0, NULL);
                            if (SUCCEEDED(hr))
                            {
                                pEqualArc->m_pNextState->m_ArcList.InsertSorted(pEpsilonArc);
                                pEqualArc->m_pNextState->m_cArcs++;

                                *ppActualDestNode = pDestNode;
                                fReusedArc = TRUE;
                                *pfPropertyMatched = TRUE;
                                if (ppArcUsed)
                                {
                                    *ppArcUsed = pEqualArc;
                                }
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    else
                    {
                        // We are not the last arc in our path.
                        // Hence we create new node and make pEqualArc go to that new node.
                        // Then add an epsilon from there to the original destination.
                        SPSTATEHANDLE hTempState;
                        CGramNode *pTempNode = NULL;
                        hr = CreateNewState(hFromState, &hTempState);
                        if (SUCCEEDED(hr))
                        {
                            hr = m_StateHandleTable.GetHandleObject(hTempState, &pTempNode);
                        }
                        if (SUCCEEDED(hr))
                        {
                            CArc *pEpsilonArc = new CArc;
                            if (pEpsilonArc)
                            {
                                // Create an epsilon to the original destination.
                                hr = pEpsilonArc->Init(pTempNode, pEqualArc->m_pNextState, NULL, NULL, NULL, 1.0F, FALSE, 0, NULL);
                                // Make the equal arc point to the new node.
                                pEqualArc->m_pNextState = pTempNode;
                                if (SUCCEEDED(hr))
                                {
                                    pTempNode->m_ArcList.InsertSorted(pEpsilonArc);
                                    pTempNode->m_cArcs++;

                                    *ppActualDestNode = pTempNode;
                                    fReusedArc = TRUE;
                                    *pfPropertyMatched = TRUE;
                                    if (ppArcUsed)
                                    {
                                        *ppArcUsed = pEqualArc;
                                    }
                                }
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                    }
                }
            }
            else
            {
                // We have an equal arc with a different property or none.
                if (pEqualArc->m_pSemanticTag)
                {
                    // Has a different property.
                    // Move the properties of pEqualArc one back and create epsilon transition if needed.
                    hr = PushProperty(pEqualArc);
                    if (SUCCEEDED(hr))
                    {
                        if (fUseDestNode)
                        {
                            // We are the last arc in a phrase - must check we can finish off correctly.
                            if (pEqualArc->m_pNextState)
                            {
                                // Add an epsilon transition here for the property if this state doesn't already have one.
                                CArc *pEpsilonArc = pEqualArc->m_pNextState->FindEqualEpsilonArc();
                                if (!pEpsilonArc)
                                {
                                    // No epsilon exists already -- add epsilon arc to pEqualArc->m_pNextState.
                                    CArc *pEpsilonArc = new CArc;
                                    if (pEpsilonArc)
                                    {
                                        hr = pEpsilonArc->Init(pEqualArc->m_pNextState, pDestNode, NULL, NULL, pSemanticTag, 1.0F, FALSE, 0, NULL);
                                        if (SUCCEEDED(hr))
                                        {
                                            pEqualArc->m_pNextState->m_ArcList.InsertSorted(pEpsilonArc);
                                            pEqualArc->m_pNextState->m_cArcs++;

                                            *ppActualDestNode = pDestNode;
                                            fReusedArc = TRUE;
                                            if (ppArcUsed)
                                            {
                                                *ppArcUsed = pEqualArc;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                    }
                                
                                }
                                else
                                {
                                    // We cannot add another epsilon arc. This is ambiguous.
                                    hr = SPERR_AMBIGUOUS_PROPERTY;
                                }
                            }
                            else
                            {
                                // The next node goes to NULL. This should never happen as the PushProperty should fail.
                                SPDBG_ASSERT(FALSE);
                                hr = E_FAIL;
                            }
                        }
                        else
                        {
                            // We have successfully reused an arc and are not the final node in a path.
                            *ppActualDestNode = pEqualArc->m_pNextState;
                            fReusedArc = TRUE;
                            if (ppArcUsed)
                            {
                                *ppArcUsed = pEqualArc;
                            }
                        }
                    }
                    else
                    {
                        // We have failed to PushProperty on pEqualArc.
                        // Possible scenarios:
                        //  fUseDestNode = true && pEqualArc->m_pNextState == NULL 
                        //  fUseDestNode = true && pEqualArc->m_pNextState != NULL
                        //  fUseDestNode = false && pEqualArc->m_pNextState != NULL
                        //  fUseDestNode = false && pEqualArc->m_pNextState == NULL
                        //     This case handled here.
                        //     All other cases simply pass the PushProperty failure back.
                        //     This should be the only case which can be handled when PushProperty fails.
                        if (!fUseDestNode && pEqualArc->m_pNextState == NULL)
                        {
                            // One branch is a prefix of this one -->
                            // We can push the existing property onto an epsilon transition.
                            SPSTATEHANDLE hTempState;
                            CGramNode *pTempNode = NULL;
                            hr = CreateNewState(hFromState, &hTempState);
                            if (SUCCEEDED(hr))
                            {
                                hr = m_StateHandleTable.GetHandleObject(hTempState, &pTempNode);
                            }
                            if (SUCCEEDED(hr))
                            {
                                pEqualArc->m_pNextState = pTempNode;
                                CArc *pEpsilonArc = new CArc;
                                if (pEpsilonArc)
                                {
                                    hr = pEpsilonArc->Init(pTempNode, NULL, NULL, NULL, pEqualArc->m_pSemanticTag, 1.0F, FALSE, 0, NULL);
                                    if (SUCCEEDED(hr))
                                    {
                                        pEqualArc->m_pSemanticTag = NULL;
                                        pEqualArc->m_pNextArcForSemanticTag = NULL;

                                        pTempNode->m_ArcList.InsertSorted(pEpsilonArc);
                                        pTempNode->m_cArcs++;

                                        *ppActualDestNode = pTempNode;
                                        fReusedArc = TRUE;
                                        if (ppArcUsed)
                                        {
                                            *ppArcUsed = pEqualArc;
                                        }
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                        }

                        else if (fUseDestNode && pEqualArc->m_pNextState == NULL && pDestNode)
                        {
                            // new code
                            // We can push the existing property onto an epsilon transition.

                            // We want to go elsewhere than to NULL. 
                            // Insert a new node and add an epilson to NULL (original path) +
                            // an epsilon to pDestNode (our path).
                            SPSTATEHANDLE hTempState;
                            CGramNode *pTempNode = NULL;
                            hr = CreateNewState(hFromState, &hTempState);
                            if (SUCCEEDED(hr))
                            {
                                hr = m_StateHandleTable.GetHandleObject(hTempState, &pTempNode);
                            }
                            if (SUCCEEDED(hr))
                            {
                                // Change equal arc to point to a new node.
                                pEqualArc->m_pNextState = pTempNode;
                                CArc *pEpsilonArc = new CArc;
                                if (pEpsilonArc)
                                {
                                    // Add in epsilon to NULL from the new node.
                                    hr = pEpsilonArc->Init(pTempNode, NULL, NULL, NULL, pEqualArc->m_pSemanticTag, 1.0F, FALSE, 0, NULL);

                                    if (SUCCEEDED(hr))
                                    {
                                        pTempNode->m_ArcList.InsertSorted(pEpsilonArc);
                                        pTempNode->m_cArcs++;

                                        pEqualArc->m_pSemanticTag = NULL;
                                        pEqualArc->m_pNextArcForSemanticTag = NULL;

                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            if (SUCCEEDED(hr))
                            {
                                CArc *pEndArc = new CArc;
                                if (pEndArc)
                                {
                                    // Add in epsilon to pDestNode from the new node.
                                    hr = pEndArc->Init(pTempNode, pDestNode, NULL, NULL, pSemanticTag, 1.0F, FALSE, 0, NULL);
                                    if (SUCCEEDED(hr))
                                    {
                                        pTempNode->m_ArcList.InsertSorted(pEndArc);
                                        pTempNode->m_cArcs++;


                                        *ppActualDestNode = pDestNode;
                                        fReusedArc = TRUE;
                                        if (ppArcUsed)
                                        {
                                            *ppArcUsed = pEqualArc;
                                        }
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }


                        }

                    }
                }
                else
                {
                    // Matching arc has no property.
                    if (pEqualArc->m_pNextState == NULL)
                    {
                        // Matching arc goes to NULL.
                        if (fUseDestNode)
                        {
                            if (NULL == pSemanticTag)
                            {
                                // We have no semantic property.
                                if (NULL == pDestNode)
                                {
                                    // Semantic information matches. We can simply use it.
                                    *ppActualDestNode = NULL;
                                    fReusedArc = TRUE;
                                    if (ppArcUsed)
                                    {
                                        *ppArcUsed = pEqualArc;
                                    }
                                }
                                else
                                {
                                    // Our destination node is different. The equal arc has no property and
                                    // neither do we. Add in a node for the equal arc to go to together with
                                    // an epsilon.
                                    SPSTATEHANDLE hTempState;
                                    CGramNode *pTempNode = NULL;
                                    hr = CreateNewState(hFromState, &hTempState);
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = m_StateHandleTable.GetHandleObject(hTempState, &pTempNode);
                                    }
                                    if (SUCCEEDED(hr))
                                    {
                                        // Change equal arc to point to a new node.
                                        pEqualArc->m_pNextState = pTempNode;
                                        CArc *pEpsilonArc = new CArc;
                                        if (pEpsilonArc)
                                        {
                                            // Add in epsilon to NULL from the new node.
                                            hr = pEpsilonArc->Init(pTempNode, NULL, NULL, NULL, NULL, 1.0F, FALSE, 0, NULL);
                                            if (SUCCEEDED(hr))
                                            {
                                                pTempNode->m_ArcList.InsertSorted(pEpsilonArc);
                                                pTempNode->m_cArcs++;
                                            }
                                        }
                                        else
                                        {
                                            hr = E_OUTOFMEMORY;
                                        }
                                    }
                                    if (SUCCEEDED(hr))
                                    {
                                        CArc *pEndArc = new CArc;
                                        if (pEndArc)
                                        {
                                            // Add in epsilon to pDestNode from the new node.
                                            hr = pEndArc->Init(pTempNode, pDestNode, NULL, NULL, NULL, 1.0F, FALSE, 0, NULL);
                                            if (SUCCEEDED(hr))
                                            {
                                                pTempNode->m_ArcList.InsertSorted(pEndArc);
                                                pTempNode->m_cArcs++;

                                                *ppActualDestNode = pDestNode;
                                                fReusedArc = TRUE;
                                                if (ppArcUsed)
                                                {
                                                    *ppArcUsed = pEqualArc;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            hr = E_OUTOFMEMORY;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                // We have a semantic property but matching arc doesn't. It goes to NULL.
                                if (NULL == pDestNode)
                                {
                                    // This is ambiguous. We have a semantic property. They equal arc doesn't.
                                    hr = SPERR_AMBIGUOUS_PROPERTY;
                                }
                                else
                                {
                                    // We want to go elsewhere than to NULL. 
                                    // Insert a new node and add an epilson to NULL (original path) +
                                    // an epsilon to pDestNode (our path).
                                    SPSTATEHANDLE hTempState;
                                    CGramNode *pTempNode = NULL;
                                    hr = CreateNewState(hFromState, &hTempState);
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = m_StateHandleTable.GetHandleObject(hTempState, &pTempNode);
                                    }
                                    if (SUCCEEDED(hr))
                                    {
                                        // Change equal arc to point to a new node.
                                        pEqualArc->m_pNextState = pTempNode;
                                        CArc *pEpsilonArc = new CArc;
                                        if (pEpsilonArc)
                                        {
                                            // Add in epsilon to NULL from the new node.
                                            hr = pEpsilonArc->Init(pTempNode, NULL, NULL, NULL, NULL, 1.0F, FALSE, 0, NULL);
                                            if (SUCCEEDED(hr))
                                            {
                                                pTempNode->m_ArcList.InsertSorted(pEpsilonArc);
                                                pTempNode->m_cArcs++;
                                            }
                                        }
                                        else
                                        {
                                            hr = E_OUTOFMEMORY;
                                        }
                                    }
                                    if (SUCCEEDED(hr))
                                    {
                                        CArc *pEndArc = new CArc;
                                        if (pEndArc)
                                        {
                                            // Add in epsilon to pDestNode from the new node.
                                            hr = pEndArc->Init(pTempNode, pDestNode, NULL, NULL, pSemanticTag, 1.0F, FALSE, 0, NULL);
                                            if (SUCCEEDED(hr))
                                            {
                                                pTempNode->m_ArcList.InsertSorted(pEndArc);
                                                pTempNode->m_cArcs++;

                                                *ppActualDestNode = pDestNode;
                                                fReusedArc = TRUE;
                                                if (ppArcUsed)
                                                {
                                                    *ppArcUsed = pEqualArc;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            hr = E_OUTOFMEMORY;
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            // We are not the last arc in a path. Can create a new node and insert an epsilon.
                            SPSTATEHANDLE hTempState;
                            CGramNode *pTempNode = NULL;
                            hr = CreateNewState(hFromState, &hTempState);
                            if (SUCCEEDED(hr))
                            {
                                hr = m_StateHandleTable.GetHandleObject(hTempState, &pTempNode);
                            }
                            if (SUCCEEDED(hr))
                            {
                                // Create new node.
                                pEqualArc->m_pNextState = pTempNode;
                                CArc *pEpsilonArc = new CArc;
                                if (pEpsilonArc)
                                {
                                    // Create the epsilon to NULL.
                                    hr = pEpsilonArc->Init(pTempNode, NULL, NULL, NULL, NULL, 1.0F, FALSE, 0, NULL);
                                    if (SUCCEEDED(hr))
                                    {
                                        pTempNode->m_ArcList.InsertSorted(pEpsilonArc);
                                        pTempNode->m_cArcs++;
                                        *ppActualDestNode = pTempNode;
                                        fReusedArc = TRUE;
                                        *pfPropertyMatched = TRUE;
                                        if (ppArcUsed)
                                        {
                                            *ppArcUsed = pEqualArc;
                                        }
                                    }
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                        }
                    }
                    else
                    {
                        // Matching arc has no property and doesn't go to NULL.
                        if (fUseDestNode)
                        {
                            if (pSemanticTag)
                            {
                                // We are trying to add a semantic property to an arc which doesn't have one.
                                if (pEqualArc->m_pNextState == pDestNode)
                                {
                                    // Matching arc goes to our desired end node. Cannot add a property to this
                                    // case and hence we report it as ambiguous.
                                    hr = SPERR_AMBIGUOUS_PROPERTY;
                                }
                                else
                                {
                                    // Reuse existing arc and add epsilon if it doesn't exist already.
                                    CArc *pEpsilonArc = pEqualArc->m_pNextState->FindEqualEpsilonArc();
                                    if (!pEpsilonArc)
                                    {
                                        pEpsilonArc = new CArc();
                                        if (pEpsilonArc)
                                        {
                                            hr = pEpsilonArc->Init(pEqualArc->m_pNextState, pDestNode, NULL, NULL, pSemanticTag, 1.0F, FALSE, 0, NULL);
                                            if (SUCCEEDED(hr))
                                            {
                                                pEqualArc->m_pNextState->m_ArcList.InsertSorted(pEpsilonArc);
                                                pEqualArc->m_pNextState->m_cArcs++;
                                                if (ppArcUsed)
                                                {
                                                    *ppArcUsed = pEpsilonArc;
                                                }
                                                *ppActualDestNode = pDestNode;
                                                fReusedArc = TRUE;
                                                *pfPropertyMatched = TRUE;
                                            }
                                        }
                                        else
                                        {
                                            hr = E_OUTOFMEMORY;
                                        }
                                    }
                                    else
                                    {
                                        // We have already added an epsilon here. Can't add another.
                                        hr = SPERR_AMBIGUOUS_PROPERTY;
                                    }
                                }
                            }
                            else
                            {
                                // No semantic tag on our arc or the existing equal arc.
                                if (pEqualArc->m_pNextState == pDestNode)
                                {
                                    // We can legally use this arc as it goes to the correct place.
                                    *ppActualDestNode = pEqualArc->m_pNextState;
                                    fReusedArc = TRUE;
                                    if (ppArcUsed)
                                    {
                                        *ppArcUsed = pEqualArc;
                                    }
                                }
                                else
                                {
                                    // We cannot use this as it doesn't go to the correct place.
                                    // Add in epsilon to the correct place.
                                    CArc *pEpsilonArc = new CArc;
                                    if (pEpsilonArc)
                                    {
                                        // Create the epsilon to NULL.
                                        hr = pEpsilonArc->Init(pEqualArc->m_pNextState, pDestNode, NULL, NULL, NULL, 1.0F, FALSE, 0, NULL);
                                        if (SUCCEEDED(hr))
                                        {
                                            pEqualArc->m_pNextState->m_ArcList.InsertSorted(pEpsilonArc);
                                            pEqualArc->m_pNextState->m_cArcs++;
                                            *ppActualDestNode = pDestNode;
                                            fReusedArc = TRUE;
                                            *pfPropertyMatched = TRUE;
                                            if (ppArcUsed)
                                            {
                                                *ppArcUsed = pEqualArc;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                    }
                                }
                            }
                        }
                        else
                        {
                            // We can legally use this arc.
                            *ppActualDestNode = pEqualArc->m_pNextState;
                            fReusedArc = TRUE;
                            if (ppArcUsed)
                            {
                                *ppArcUsed = pEqualArc;
                            }
                        }
                    }
                }
            }
        }
        else
        {
            BOOL fInfDictation = FALSE;
            SPSTATEHANDLE hSpecialTrans = 0;
            if (psz && !wcscmp(psz, SPWILDCARD))
            {
                hSpecialTrans = SPRULETRANS_WILDCARD;
                pSrcNode->m_pRule->m_ulSpecialTransitions++;
                m_ulSpecialTransitions++;
            }
            else if (psz && !wcscmp(psz, SPDICTATION))
            {
                hSpecialTrans = SPRULETRANS_DICTATION;
                pSrcNode->m_pRule->m_ulSpecialTransitions++;
                m_ulSpecialTransitions++;
            }
            else if (psz && !wcscmp(psz, SPINFDICTATION))
            {
                hSpecialTrans = SPRULETRANS_DICTATION;
                pSrcNode->m_pRule->m_ulSpecialTransitions++;
                m_ulSpecialTransitions++;
                fInfDictation = TRUE;
            }
            if (fInfDictation)
            {
                // construct self loop and espilon out with temp node
                SPSTATEHANDLE hTempState;
                CGramNode *pTempNode = NULL;
                hr = CreateNewState(hFromState, &hTempState);
                if (SUCCEEDED(hr))
                {
                    hr = m_StateHandleTable.GetHandleObject(hTempState, &pTempNode);
                }
                if (SUCCEEDED(hr))
                {
                    hr = pArc->Init(pSrcNode, pTempNode, NULL, NULL, pSemanticTag,
                                    flWeight, FALSE, RequiredConfidence, SPRULETRANS_DICTATION);
                }
                if (SUCCEEDED(hr))
                {
                    CArc *pSelfArc = new CArc;
                    if (pSelfArc)
                    {
                        CSemanticTag *pSemTagDup = NULL;
                        if (pSemanticTag)
                        {
                            pSemTagDup = new CSemanticTag;
                            if (pSemTagDup)
                            {
                                *pSemTagDup = *pSemanticTag;
                                pSemTagDup->m_pStartArc = pSelfArc;
                                pSemTagDup->m_pEndArc = pSelfArc;
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            hr = pSelfArc->Init(pTempNode, pTempNode, NULL, NULL, pSemTagDup,
                                                1.0f, FALSE, RequiredConfidence, SPRULETRANS_DICTATION);
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    if (SUCCEEDED(hr))
                    {
                        pTempNode->m_ArcList.InsertSorted(pSelfArc);
                        pTempNode->m_cArcs++;
                    }
                }
                if (SUCCEEDED(hr))
                {
                    CArc *pEpsilonArc = new CArc;
                    if (pEpsilonArc)
                    {
                        if (fUseDestNode)
                        {
                            hr = pEpsilonArc->Init(pTempNode, pDestNode, NULL , NULL, NULL, 1.0f, FALSE, RequiredConfidence, NULL);
                            if (SUCCEEDED(hr))
                            {
                                pTempNode->m_ArcList.InsertSorted(pEpsilonArc);
                                pTempNode->m_cArcs++;
                            }
                        }
                        else
                        {
                            // create a new node and return it
                            SPSTATEHANDLE hTempDestState;
                            hr = CreateNewState(hFromState, &hTempDestState);
                            if (SUCCEEDED(hr))
                            {
                                hr = m_StateHandleTable.GetHandleObject(hTempDestState, ppActualDestNode);
                            }
                            hr = pEpsilonArc->Init(pTempNode, *ppActualDestNode, NULL , NULL, NULL, 1.0f, FALSE, RequiredConfidence, NULL);
                            if (SUCCEEDED(hr))
                            {
                                pTempNode->m_ArcList.InsertSorted(pEpsilonArc);
                                pTempNode->m_cArcs++;
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (ppArcUsed)
                            {
                                *ppArcUsed = pEpsilonArc;
                            }
                            *pfPropertyMatched = TRUE;
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            else if (fUseDestNode)
            {
                hr = pArc->Init(pSrcNode, pDestNode, (hSpecialTrans) ? NULL : psz, NULL, pSemanticTag,
                                flWeight, fOptional, RequiredConfidence, hSpecialTrans);
                if (SUCCEEDED(hr))
                {
                    if (ppArcUsed)
                    {
                        *ppArcUsed = pArc;
                    }
                    *pfPropertyMatched = TRUE;
                }
            }
            else
            {
                // create a new node and return it
                SPSTATEHANDLE hTempState;
                hr = CreateNewState(hFromState, &hTempState);
                if (SUCCEEDED(hr))
                {
                    hr = m_StateHandleTable.GetHandleObject(hTempState, ppActualDestNode);
                }
                if (SUCCEEDED(hr))
                {
                    hr = pArc->Init(pSrcNode, *ppActualDestNode, (hSpecialTrans) ? NULL : psz, NULL, pSemanticTag,
                                    flWeight, fOptional, RequiredConfidence, hSpecialTrans);
                }
                if (SUCCEEDED(hr))
                {
                    if (ppArcUsed)
                    {
                        *ppArcUsed = pArc;
                    }
                    *pfPropertyMatched = TRUE;
                }
            }
        }
        if (SUCCEEDED(hr) && !fReusedArc)
        {
            pSrcNode->m_ArcList.InsertSorted(pArc);
            pSrcNode->m_cEpsilonArcs += (fOptional == TRUE) ? 1 : 0;
            pSrcNode->m_cArcs += (fOptional == TRUE) ? 2 : 1;
            if (*ppActualDestNode == NULL)
            {
                *ppActualDestNode = pArc->m_pNextState;
            }
        }
        else
        {
            delete pArc;
        }
    }

    if (SPERR_AMBIGUOUS_PROPERTY != hr)
    {
        SPDBG_REPORT_ON_FAIL( hr );
    }
    return hr;
}
/****************************************************************************
* CGramBackEnd::ConvertPronToId *
*-------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

HRESULT CGramBackEnd::ConvertPronToId(WCHAR **ppStr)
{
    SPDBG_FUNC("CGramBackEnd::ConvertPronToId");
    HRESULT hr = S_OK;

    if (!m_cpPhoneConverter)
    {
        hr = SpCreatePhoneConverter(m_LangID, NULL, NULL, &m_cpPhoneConverter);
    }

    SPPHONEID *pPhoneId = STACK_ALLOC(SPPHONEID, wcslen(*ppStr)+1);

    if (SUCCEEDED(hr) && pPhoneId)
    {
        hr = m_cpPhoneConverter->PhoneToId(*ppStr, pPhoneId);
    }
    if (SUCCEEDED(hr))
    {
        memset(*ppStr, 0, wcslen(*ppStr)*sizeof(WCHAR));
        // copy the phone string over the original phoneme string
        wcscat(*ppStr, (WCHAR*)pPhoneId);
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramBackEnd::GetNextWord *
*---------------------------*
*   Description:  The input, psz, must be a double null terminated string to work properly.
*
*   Returns:  S_FALSE on the last word.
*
****************************************************** t-lleav ** PhilSch ***/

HRESULT CGramBackEnd::GetNextWord(WCHAR *psz, const WCHAR *pszSep, WCHAR **ppszNextWord, ULONG *pulOffset )
{
    SPDBG_FUNC("CGramBackEnd::GetNextWord");
    HRESULT hr = S_OK;

    // no parameter validation since this is an internal method
    
    *ppszNextWord = NULL;
    ULONG ulOffset = 0;
    if( *psz == 0 )
        return S_FALSE;

    while( isSeparator( *psz, pszSep) )
    {
        psz++;
        // don't increment ulOffset because we are incrementing the pointer
    }


    // skip over leading + and ? before doing the check    
    for(WCHAR * pStr = psz; (wcslen(pStr) > 1) && fIsSpecialChar(*pStr); pStr++, ulOffset++);
    *ppszNextWord = pStr;
    if (*pStr == L'/')
    {
        ULONG ulNumDelim = 0;
        WCHAR * pszBeginPron = NULL;
        WCHAR *p = *ppszNextWord + 1;

        while( *p && *p != L';')
        {
            if (*p == L'\\')
            {
                p += 2; // skip the next character since it can't be the delimiter
                ulOffset +=2;

            }
            else 
            {
                if (*p == L'/')
                {
                    ulNumDelim++;
                    if (ulNumDelim == 2)
                    {
                        pszBeginPron = p + 1;
                    }
                }
                p++;
                ulOffset++;
            }
        }
        
        if ( (*p == L';') && (ulNumDelim < 3))
        {
            *p = 0;
            ulOffset++;
            if (pszBeginPron && (p != pszBeginPron))
            {
                hr = ConvertPronToId(&pszBeginPron);
            }
        }
        else
        {
            *ppszNextWord = NULL;
            hr = SPERR_WORDFORMAT_ERROR;
        }
    }
    else if( *pStr == 0 )
    {
        // Since the wcslen() is 0, ppszNextWord is set to NULL at the bottom.
        hr = S_FALSE;
    }
    else
    {
        WCHAR * pEnd = pStr;
        while( *pEnd && !isSeparator( *pEnd, pszSep) )
        {
            pEnd++;
            ulOffset++;
        }
        *pEnd++ = 0;
        if (*pEnd == 0)
        {
            ulOffset --;
        }
    }
    *ppszNextWord = ( SUCCEEDED(hr) && wcslen(psz)) ? psz : NULL;
    *pulOffset = ulOffset;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CGramBackEnd::AddWordTransition *
*---------------------------------*
*   Description:
*       Adds a word transition from hFromState to hToState. If hToState == NULL
*       then the arc will be to the (implicit) terminal node. If psz == NULL then
*       we add an epsilon transition. The pszSeparators are used to separate word 
*       tokens in psz (this method creates internal nodes as necessary to build
*       a sequence of single word transitions). Properties are pushed back to the
*       first un-ambiguous arc in case we can share a common initial node path.
*       eWordType has to be lexical. The weight will be placed on the first arc
*       (if there exists an arc with the same word but different weight we will
*       create a new arc). We can
*   Returns:
*       S_OK, E_OUTOFMEMORY
*       E_INVALIDARC            -- parameter validation of strings, prop info, 
*                                  state handles and word type
*       SPERR_WORDFORMAT_ERROR  -- invalid word format /display/lexical/pron;
********************************************************************* RAL ***/

STDMETHODIMP CGramBackEnd::AddWordTransition(
                        SPSTATEHANDLE hFromState,
                        SPSTATEHANDLE hToState,
                        const WCHAR * psz,           // if NULL then SPEPSILONTRANS
                        const WCHAR * pszSeparators, // if NULL then psz contains single word
                        SPGRAMMARWORDTYPE eWordType,
                        float flWeight,
                        const SPPROPERTYINFO * pPropInfo)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CGramBackEnd::AddWordTransition");
    HRESULT hr = S_OK;
    BOOL fPropertyMatched = FALSE;

    if (SP_IS_BAD_OPTIONAL_STRING_PTR(psz) || 
        SP_IS_BAD_OPTIONAL_STRING_PTR(pszSeparators) ||
        SP_IS_BAD_OPTIONAL_READ_PTR(pPropInfo) || (eWordType != SPWT_LEXICAL) ||
        (flWeight < 0.0f))
    {
        return E_INVALIDARG;
    }

    // '/' cannot be a separator since it is being used for the complete format!
    if (pszSeparators && wcsstr(pszSeparators, L"/"))
    {
        return E_INVALIDARG;
    }

    CGramNode * pSrcNode = NULL;
    CGramNode * pDestNode = NULL;

    if (SUCCEEDED(hr))
    {
        hr = m_StateHandleTable.GetHandleObject(hFromState, &pSrcNode);
    }
    if (SUCCEEDED(hr) && pSrcNode->m_pRule->m_fStaticRule)
    {
        hr = SPERR_RULE_NOT_DYNAMIC;
    }
    if (SUCCEEDED(hr) && hToState)
    {
        hr = m_StateHandleTable.GetHandleObject(hToState, &pDestNode);
        if (SUCCEEDED(hr))
        {
            if (pSrcNode->m_pRule != pDestNode->m_pRule)
            {
                hr = E_INVALIDARG;   // NTRAID#SPEECH-7348-2000/08/24-philsch -- More specific error!
            }
        }
    }

    CSemanticTag * pSemanticTag = NULL;
    BOOL fSemanticTagValid = FALSE;
    if (SUCCEEDED(hr))
    {
        hr = ValidatePropInfo(pPropInfo);
    }
    if (SUCCEEDED(hr) && pPropInfo)
    {
        pSemanticTag = new CSemanticTag();
        if (pSemanticTag)
        {
            hr = pSemanticTag->Init(this, pPropInfo);
            fSemanticTagValid = TRUE;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (psz)
        {
            WCHAR *pStr = STACK_ALLOC(WCHAR, wcslen(psz)+2);
            if (pStr)
            {
                // double null terminate the string.
                wcscpy(pStr, psz);
                // right-trim the string
                for (WCHAR *pEnd = pStr + wcslen(pStr) -1; iswspace(*pEnd) && pEnd >= pStr; pEnd--)
                {
                    *pEnd = 0;
                }
                pStr[wcslen(pStr)] = 0;
                pStr[wcslen(pStr)+1] = 0;
                // scan until the end of the first word
                WCHAR *pszWord;                    
                ULONG ulOffset = 0;
                hr = GetNextWord(pStr, pszSeparators, &pszWord, &ulOffset );
                if ((S_OK == hr) && pszWord)
                {
                    CGramNode *pFromNode = pSrcNode;
                    CGramNode *pToNode = NULL;
                    CArc *pPrevArc = NULL;
                    BOOL fSetPropertyMovePath = FALSE;
                    float fw = flWeight;
                    while (SUCCEEDED(hr) && pszWord)
                    {
                        WCHAR *pszNextWord = NULL;
                        hr = GetNextWord(pszWord + ulOffset + 1, pszSeparators, &pszNextWord, &ulOffset );
                        // returns S_FALSE if we don't have another word
                        if (SUCCEEDED(hr))
                        {
                            CGramNode *pTargetNode = NULL;
                            CArc *pArcUsed = NULL;
                            BOOL fUseDestNode = (pszNextWord) ? FALSE : TRUE;
                            if (SUCCEEDED(hr))
                            {
                                hr = AddSingleWordTransition(hFromState, pFromNode, pDestNode,
                                                             pszWord, fw, 
                                                             fSemanticTagValid ? pSemanticTag : NULL, 
                                                             fUseDestNode, &pTargetNode, &pArcUsed, &fPropertyMatched);
                            }
                            fw = 1.0f;
                            if (SUCCEEDED(hr))
                            {
                                if (pPrevArc && fSetPropertyMovePath)
                                {
                                    pPrevArc->m_pNextArcForSemanticTag = pArcUsed;
                                }
                                if (fPropertyMatched)
                                {
                                    fSetPropertyMovePath = TRUE;
                                }
                                if (fSemanticTagValid && (pSemanticTag->m_pStartArc == NULL))
                                {
                                    SPDBG_ASSERT(pArcUsed != NULL);
                                    pSemanticTag->m_pStartArc = pArcUsed;
                                }
                                if (fSemanticTagValid && fPropertyMatched)
                                {
                                    fSemanticTagValid = FALSE;
                                }
                                if (pSemanticTag)
                                {
                                    pSemanticTag->m_pEndArc = pArcUsed;
                                }
                                pPrevArc = pArcUsed;
                                pszWord = pszNextWord;
                                pFromNode = pTargetNode;
                            }
                        }
                        else
                        {
                            hr = SPERR_WORDFORMAT_ERROR;
                        }
                    }
                }
                else
                {
                    hr = SPERR_WORDFORMAT_ERROR;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            CGramNode *pNode = NULL;
            CArc *pArcUsed = NULL;
            // epsilon transition
            hr = AddSingleWordTransition(hFromState, pSrcNode, pDestNode, 
                                         NULL, flWeight, pSemanticTag, TRUE, 
                                         &pNode, &pArcUsed, &fPropertyMatched);
            if (SUCCEEDED(hr) && pSemanticTag)
            {
                SPDBG_ASSERT(pArcUsed != NULL);
                pSemanticTag->m_pStartArc = pArcUsed;
                pSemanticTag->m_pEndArc = pArcUsed;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        pSrcNode->m_pRule->fDirtyRule = TRUE;
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CGramBackEnd::AddRuleTransition *
*---------------------------------*
*   Description:
*       Adds a rule (reference) transition from hFromState to hToState.
*       hRule can also be one of these special transition handles:
*           SPRULETRANS_WILDCARD   :    <WILDCARD> transition
*           SPRULETRANS_DICTATION  :    single word from dictation
*           SPRULETRANS_TEXTBUFFER :    <TEXTBUFFER> transition
*           
*   Returns:
*       S_OK, E_OUTOFMEMORY
*       E_INVALIDARC            -- parameter validation of rule statehandle, 
*                                   prop info, and state handles
*
********************************************************************* RAL ***/

STDMETHODIMP CGramBackEnd::AddRuleTransition(
                            SPSTATEHANDLE hFromState,
                            SPSTATEHANDLE hToState,
                            SPSTATEHANDLE hRule,        // must be initial state of rule
                            float flWeight,
                            const SPPROPERTYINFO * pPropInfo)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CGramBackEnd::AddRuleTransition");
    HRESULT hr = S_OK;
    CGramNode * pSrcNode = NULL;
    CGramNode * pDestNode = NULL;
    SPSTATEHANDLE hSpecialRuleTrans = NULL;
    CRule * pRuleToTransitionTo = NULL;

    if (flWeight < 0.0f)
    {
        hr = E_INVALIDARG;
    }
    if (SUCCEEDED(hr))
    {
        hr = m_StateHandleTable.GetHandleObject(hFromState, &pSrcNode);
    }
    if (SUCCEEDED(hr) && pSrcNode->m_pRule->m_fStaticRule)
    {
        hr = SPERR_RULE_NOT_DYNAMIC;
    }
    
    if (SUCCEEDED(hr) && hToState)
    {
        hr = m_StateHandleTable.GetHandleObject(hToState, &pDestNode);
        if (SUCCEEDED(hr))
        {
            if (pSrcNode->m_pRule != pDestNode->m_pRule)
            {
                hr = E_INVALIDARG;   // NTRAID#SPEECH-7348-2000/08/24-philsch -- More specific error!
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        if (hRule == SPRULETRANS_WILDCARD ||
            hRule == SPRULETRANS_DICTATION ||
            hRule == SPRULETRANS_TEXTBUFFER)
        {
            hSpecialRuleTrans = hRule;
            pSrcNode->m_pRule->m_ulSpecialTransitions++;
            m_ulSpecialTransitions++;
        }
        else
        {
            hr = RuleFromHandle(hRule, &pRuleToTransitionTo);
        }
    }
    if (SUCCEEDED(hr) && pRuleToTransitionTo)
    {
        if (pRuleToTransitionTo->fDynamic)
        {
            pSrcNode->m_pRule->m_fHasDynamicRef = true;
            pSrcNode->m_pRule->m_fCheckedAllRuleReferences = true;
        }
        else
        {
            SPRULEREFLIST *pRuleRef = new SPRULEREFLIST;
            if (pRuleRef)
            {
                pRuleRef->pRule = pRuleToTransitionTo;
                pSrcNode->m_pRule->m_ListOfReferencedRules.InsertHead(pRuleRef);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        CArc * pArc = new CArc();
        if (pArc == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            CSemanticTag * pSemanticTag = NULL;
            hr = ValidatePropInfo(pPropInfo);
            if (SUCCEEDED(hr) && pPropInfo)
            {
                pSemanticTag = new CSemanticTag();
                if (pSemanticTag)
                {
                    hr = pSemanticTag->Init(this, pPropInfo);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            // check to see if this arc already exists -- maybe with different property info?
            CArc *pEqualArc = NULL;
            if (SUCCEEDED(hr))
            {
                pEqualArc = pSrcNode->FindEqualRuleTransition(pDestNode, pRuleToTransitionTo, 
                                                              hSpecialRuleTrans, flWeight);
            }
            if (SUCCEEDED(hr) && pEqualArc)
            {
                if (pSemanticTag)
                {
                    if (SUCCEEDED(hr) && pEqualArc->m_pSemanticTag && (*pSemanticTag == *(pEqualArc->m_pSemanticTag)))
                    {
                        // arcs are equal -- reuse them
                    }
                    else
                    {
                        hr = SPERR_AMBIGUOUS_PROPERTY;
                    }
                }
                else
                {
                    if (pEqualArc->m_pSemanticTag)
                    {
                        hr = SPERR_AMBIGUOUS_PROPERTY;
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                hr = pArc->Init(pSrcNode, pDestNode, NULL, pRuleToTransitionTo, pSemanticTag,
                                flWeight, FALSE, 0, hSpecialRuleTrans);
                if (SUCCEEDED(hr))
                {
                    if (pSemanticTag)
                    {
                        pSemanticTag->m_pStartArc = pArc;
                        pSemanticTag->m_pEndArc = pArc;
                    }
                    pSrcNode->m_ArcList.InsertSorted(pArc);
                    pSrcNode->m_cArcs ++;
                }
                else
                {
                    delete pArc;
                }
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        pSrcNode->m_pRule->fDirtyRule = TRUE;
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CGramBackEnd::Commit *
*----------------------*
*   Description:
*       Performs consistency checks of the grammar structure, creates the
*       serialized format and either saves it to the stream provided by SetSaveOptions,
*       or reloads it into the CFG engine.
*   Returns:
*       S_OK, E_INVALIDARG
*       SPERR_UNINITIALIZED     -- stream not initiallized
*       SPERR_NO_RULES          -- no rules in grammar
*       SPERR_NO_TERMINATING_RULE_PATH
*       IDS_DYNAMIC_EXPORT
*       IDS_STATEWITHNOARCS
*       IDS_SAVE_FAILED
********************************************************************* RAL ***/

STDMETHODIMP CGramBackEnd::Commit(DWORD dwReserved)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CGramBackEnd::Commit");
    HRESULT hr = S_OK;
    float *pWeights = NULL;

    if (dwReserved & (~SPGF_RESET_DIRTY_FLAG))
    {
        return E_INVALIDARG;
    }

    if (!m_cpStream)
    {
        return SPERR_UNINITIALIZED;
    }

    if ((m_ulSpecialTransitions == 0) && (m_RuleList.GetCount() == 0))
    {
        hr = SPERR_NO_RULES;
        REPORTERRORFMT(IDS_MSG, L"Need at least one rule!");
        return hr;
    }

    hr = ValidateAndTagRules();

    if (FAILED(hr)) return hr;

    ULONG cArcs = 1; // Start with offset one! (0 indicates dead node).
    ULONG cSemanticTags = 0;
    ULONG cLargest = 0;

    CGramNode * pNode;
    SPSTATEHANDLE hState = NULL;

    // put all nodes CGramNode into a list sorted by rule parent index
    CSpBasicQueue<CGramNode, FALSE, TRUE>   NodeList;           // don't purge when deleted!
    while (m_StateHandleTable.Next(hState, &hState, &pNode))
    {
        NodeList.InsertSorted(pNode);
    }

    for (pNode = NodeList.GetHead(); SUCCEEDED(hr) && ( pNode != NULL ); pNode = NodeList.GetNext(pNode))
    {
        pNode->m_ulSerializeIndex = cArcs;
        ULONG cThisNode = pNode->NumArcs();
        if (cThisNode == 0 && pNode->m_pRule->m_cNodes > 1 ) 
        {
            LogError(SPERR_GRAMMAR_COMPILER_INTERNAL_ERROR, IDS_STATEWITHNOARCS);
            hr = SPERR_STATE_WITH_NO_ARCS;
        }
        if (SUCCEEDED(hr))
        {
            cArcs += cThisNode;
            if (cLargest < cThisNode)
            {
                cLargest = cThisNode;
            }
            cSemanticTags += pNode->NumSemanticTags();
        }
    }

    SPCFGSERIALIZEDHEADER H;
    ULONG ulOffset = sizeof(H);
    if (SUCCEEDED(hr))
    {
        memset(&H, 0, sizeof(H));

        H.FormatId = SPGDF_ContextFree;
        CoCreateGuid(&m_guid);
        H.GrammarGUID = m_guid;
        H.LangID = m_LangID;
        H.cArcsInLargestState = cLargest;

        H.cchWords = m_Words.StringSize();
        H.cWords = m_Words.GetNumItems();

        // StringSize() includes the beginning empty string in the m_Words blob
        // while GetNumItems() doesn't, so add 1 for the initial empty string.
        // Our code in other places are counting the empty string as one word.
        // But when the blob is empty, both StringSize() and GetNumItems() 
        // return 0, there's no need to add 1 to the word count. 
        // This fixes buffer overrun bug 11491.
        if( H.cWords ) H.cWords++;  

        H.pszWords = ulOffset;  
        ulOffset += m_Words.SerializeSize();

        H.cchSymbols = m_Symbols.StringSize();
        H.pszSymbols = ulOffset;  
        ulOffset += m_Symbols.SerializeSize();

        H.cRules = m_RuleList.GetCount();
        H.pRules = ulOffset;
        ulOffset += (m_RuleList.GetCount() * sizeof(SPCFGRULE));

        H.cResources = m_cResources;
        H.pResources = ulOffset;
        ulOffset += (m_cResources * sizeof(SPCFGRESOURCE));

        H.cArcs = cArcs;
        H.pArcs = ulOffset;
        ulOffset += (cArcs * sizeof(SPCFGARC));

        if (m_fNeedWeightTable)
        {
            H.pWeights = ulOffset;
            ulOffset += (cArcs * sizeof(float));
            pWeights = (float *) ::CoTaskMemAlloc(sizeof(float) * cArcs);
            if (!pWeights)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                pWeights[0] = 0.0;
            }
        }
        else
        {
            H.pWeights = 0;
            ulOffset += 0;
        }
    }

    if (SUCCEEDED(hr))
    {
        H.cSemanticTags = cSemanticTags;
        H.pSemanticTags = ulOffset;

        ulOffset += cSemanticTags * sizeof(SPCFGSEMANTICTAG);
        H.ulTotalSerializedSize = ulOffset;

        hr = WriteStream(H);
    }
    
    //
    //  For the string blobs, we must explicitly report I/O error since the blobs don't
    //  use the error log facility.
    //
    if (SUCCEEDED(hr))
    {
        hr = m_cpStream->Write(m_Words.SerializeData(), m_Words.SerializeSize(), NULL);
        if (SUCCEEDED(hr))
        {
            hr = m_cpStream->Write(m_Symbols.SerializeData(), m_Symbols.SerializeSize(), NULL);
        }
        if (FAILED(hr))
        {
            LogError(hr, IDS_WRITE_ERROR);
        }
    }

    for (CRule * pRule = m_RuleList.GetHead(); SUCCEEDED(hr) && pRule; pRule = pRule->m_pNext)
    {
        hr = pRule->Serialize();
    }

    for (pRule = m_RuleList.GetHead(); SUCCEEDED(hr) && pRule; pRule = pRule->m_pNext)
    {
        hr = pRule->SerializeResources();
    }

    //
    //  Write a dummy 0 index node entry 
    //  
    if (SUCCEEDED(hr))
    {
        SPCFGARC Dummy;
        memset(&Dummy, 0, sizeof(Dummy));
        hr = WriteStream(Dummy);
    }

    ULONG ulWeightOffset = 1;
    ULONG ulArcOffset = 1;
    for (pNode = NodeList.GetHead(); SUCCEEDED(hr) && ( pNode != NULL); pNode = NodeList.GetNext(pNode))
    {
        hr = pNode->SerializeNodeEntries(pWeights, &ulArcOffset, &ulWeightOffset);
    }

    if (SUCCEEDED(hr) && m_fNeedWeightTable)
    {
        hr = WriteStream(pWeights, cArcs*sizeof(float));
    }

    for (pNode = NodeList.GetHead(); SUCCEEDED(hr) && ( pNode != NULL); pNode = NodeList.GetNext(pNode))
    {
        hr = pNode->SerializeSemanticTags();
    }

    if (FAILED(hr))
    {
        SPDBG_REPORT_ON_FAIL( hr );
        LogError(hr, IDS_SAVE_FAILED);
    }
    else if ( dwReserved & SPGF_RESET_DIRTY_FLAG )
    {
        // clear the dirty bits so we don't invalidate rules in subsequent commits
        for (CRule * pRule = m_RuleList.GetHead(); SUCCEEDED(hr) && pRule; pRule = pRule->m_pNext)
        {
            pRule->fDirtyRule = FALSE;
        }
    }

    ::CoTaskMemFree(pWeights);

    return hr;
}


/****************************************************************************
* CGramBackEnd::ValidateAndTagRules *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CGramBackEnd::ValidateAndTagRules()
{
    SPDBG_FUNC("CGramBackEnd::ValidateAndTagRules");
    HRESULT hr = S_OK;

    //
    //  Reset the recursion test flags in all nodes.  Various pieces of code will set flags
    //  during this function call.
    //
    CGramNode * pNode;
    SPSTATEHANDLE hState = NULL;
    while (m_StateHandleTable.Next(hState, &hState, &pNode))
    {
        pNode->m_RecurTestFlags = 0;
    }

    BOOL fAtLeastOneRule = FALSE;
    ULONG ulIndex = 0;   
    for (CRule * pRule = m_RuleList.GetHead(); SUCCEEDED(hr) && pRule; pRule = pRule->m_pNext)
    {
        // set m_fHasExitPath = TRUE for empty dynamic grammars and imported rules
        pRule->m_fHasExitPath |= (pRule->fDynamic | pRule->fImport) ? TRUE : FALSE; // Clear this for the next loop through the rules....
        pRule->m_fCheckingForExitPath = FALSE;
        pRule->m_ulSerializeIndex = ulIndex++;
        fAtLeastOneRule |= (pRule->fDynamic || pRule->fTopLevel || pRule->fExport);
        hr = pRule->Validate();
    }

    //
    //  Now make sure that all rules have an exit path.
    //
    for (pRule = m_RuleList.GetHead(); SUCCEEDED(hr) && pRule; pRule = pRule->m_pNext)
    {
        hr = pRule->CheckForExitPath();
    }

    //
    //  Check each exported rule if it has a dynamic rule in its "scope"
    //
    for (pRule = m_RuleList.GetHead(); SUCCEEDED(hr) && pRule; pRule = pRule->m_pNext)
    {
        if (pRule->fExport && pRule->CheckForDynamicRef())
        {
            hr = LogError(SPERR_EXPORT_DYNAMIC_RULE, IDS_DYNAMIC_EXPORT, pRule);
        }
    }

    // If there are no rules in an in-memory dynamic grammar, that's OK
    if (SUCCEEDED(hr) && m_pInitHeader == NULL && (!fAtLeastOneRule))
    {
        hr = LogError(SPERR_NO_RULES, IDS_NO_RULES);
    }

    hState = NULL;
    while (SUCCEEDED(hr) && m_StateHandleTable.Next(hState, &hState, &pNode))
    {
        hr = pNode->CheckLeftRecursion();    
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRule::Validate *
*-----------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRule::Validate()
{
    SPDBG_FUNC("CGramBackEnd::ValidateRule");
    HRESULT hr = S_OK;


    if ((!fDynamic) && (!fImport) && m_pFirstNode->NumArcs() == 0)
    {
//        hr = m_pParent->LogError(SPERR_EMPTY_RULE, IDS_EMPTY_RULE, this);
        // This error condition is no longer treated as an error. Empty rules are allowed.
        // This also removes the above inconsistency between dynamic and static grammars.
        // There are clear cases where empty dynamic rules are valid. Similary, automatically
        // generated XML might contain empty rules deliberately so static grammars should be
        // allowed to have empty rules too which achieved the secondary aim of consistency.
        return S_OK;
    }
    else
    {
#if 0
        // NTRAID#SPEECH-7350-2000/08/24-philsch: fix and reenable it for RELEASE (RAID 3634)
        // Detect an epsilon path through the grammar
        // Mark the rule as fHasDynamicRef if it does
        if (!(fImport || fDynamic))
        {
            hr = m_pFirstNode->CheckEpsilonRule();
        }
#endif
        fHasDynamicRef = fDynamic;
    }
    return hr;
}


/****************************************************************************
* CRule::CheckForDynamicRef *
*---------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

bool CRule::CheckForDynamicRef(CHECKDYNRULESTACK * pStack)
{
    SPDBG_FUNC("CRule::CheckForDynamicRef");
    HRESULT hr = S_OK;

    if (!(m_fCheckedAllRuleReferences || m_fHasDynamicRef))
    {
        if (this->fDynamic)
        {
            m_fHasDynamicRef = true;
        }
        else
        {
            CHECKDYNRULESTACK LocalElem;
            CHECKDYNRULESTACK * pOurRuleElem = pStack;
            while (pOurRuleElem && pOurRuleElem->m_pRule != this)
            {
                pOurRuleElem = pOurRuleElem->m_pNext;
            }
            if (!pOurRuleElem)
            {
                LocalElem.m_pRule = this;
                LocalElem.m_pNextRuleRef = this->m_ListOfReferencedRules.GetHead();
                LocalElem.m_pNext = pStack;
                pStack = &LocalElem;
                pOurRuleElem = &LocalElem;
            }
            while ((!m_fHasDynamicRef) && pOurRuleElem->m_pNextRuleRef)
            {
                // Now move the pointer on the stack past the current element to avoid
                // an infinate recursion, then check the current element.
                SPRULEREFLIST * pTest = pOurRuleElem->m_pNextRuleRef;
                pOurRuleElem->m_pNextRuleRef = pTest->m_pNext;
                if (pTest->pRule->CheckForDynamicRef(pStack))
                {
                    m_fHasDynamicRef = true;
                }
            }
        }
        m_fCheckedAllRuleReferences = true;
    }
    return m_fHasDynamicRef;
}

/****************************************************************************
* CRule::CheckForExitPath *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRule::CheckForExitPath()
{
    SPDBG_FUNC("CRule::CheckForExitPath");
    HRESULT hr = S_OK;

    if (!(m_fHasExitPath || m_fCheckingForExitPath))
    {
        m_fCheckingForExitPath = true;
        // This check allows empty rules.
        if (m_pFirstNode->NumArcs() != 0)
        {
            hr = m_pFirstNode->CheckExitPath(0);
            if (!m_fHasExitPath)
            {
                hr = m_pParent->LogError(SPERR_NO_TERMINATING_RULE_PATH, IDS_NOEXITPATH, this);
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CRule::CRule *
*--------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CRule::CRule(CGramBackEnd * pParent, const WCHAR * pszRuleName, DWORD dwRuleId, DWORD dwAttributes, HRESULT * phr) 
{
    SPDBG_FUNC("CRule::CRule");
    *phr = S_OK;
    m_hInitialState = NULL;
    m_pFirstNode = NULL;

    memset(static_cast<SPCFGRULE *>(this), 0, sizeof(SPCFGRULE));
    m_pParent = pParent;
    fTopLevel = ((dwAttributes & SPRAF_TopLevel) != 0);
    fDefaultActive = ((dwAttributes & SPRAF_Active) != 0);
    fPropRule = ((dwAttributes & SPRAF_Interpreter) != 0);
    fExport = ((dwAttributes & SPRAF_Export) != 0);
    fDynamic = ((dwAttributes & SPRAF_Dynamic) != 0);
    fImport= ((dwAttributes & SPRAF_Import) != 0);
    fDirtyRule = TRUE;
    RuleId = dwRuleId;
    m_ulSerializeIndex = 0;
    m_ulOriginalBinarySerialIndex = INFINITE;
    m_fHasExitPath = false;
    m_fHasDynamicRef = false;
    m_fCheckedAllRuleReferences = false;
    m_ulSpecialTransitions = 0;
    m_fStaticRule = false;

    if (fImport)
    {
        pParent->m_cImportedRules++;
    }

    if (fDynamic && fExport)
    {
        *phr = SPERR_EXPORT_DYNAMIC_RULE;
    }
    else
    {
        *phr = pParent->m_Symbols.Add(pszRuleName, &(NameSymbolOffset));
    }

    if (SUCCEEDED(*phr))
    {
        m_pFirstNode = new CGramNode(this);
        if (m_pFirstNode)
        {
            *phr = pParent->m_StateHandleTable.Add(m_pFirstNode, &m_hInitialState);
            if (FAILED(*phr))
            {
                delete m_pFirstNode;
                m_pFirstNode = NULL;
            }
            else
            {
                m_pFirstNode->m_hState = m_hInitialState;
                m_cNodes = 1;
            }
        }
        else
        {
            *phr = E_OUTOFMEMORY;
        }
    }
}

/****************************************************************************
* CRule::Serialize *
*------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CRule::Serialize()
{
    SPDBG_FUNC("CRule::Serialize");
    HRESULT hr = S_OK;

    // Dynamic rules and imports have no arcs
    FirstArcIndex = m_pFirstNode->NumArcs() ? m_pFirstNode->m_ulSerializeIndex : 0;
    hr = m_pParent->WriteStream(static_cast<SPCFGRULE>(*this));

    return hr;
}
/****************************************************************************
* CRule::SerializeResources *
*---------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT CRule::SerializeResources()
{
    SPDBG_FUNC("CRule::SerializeResources");
    HRESULT hr = S_OK;

    for (CResource * pResource = m_ResourceList.GetHead(); pResource && SUCCEEDED(hr); pResource = pResource->m_pNext)
    {
        pResource->RuleIndex = m_ulSerializeIndex;
        hr = m_pParent->WriteStream(static_cast<SPCFGRESOURCE>(*pResource));
    }

    return hr;
}





/****************************************************************************
* CArc::CArc *
*------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CArc::CArc()
{
    m_pSemanticTag = NULL;
    m_pNextArcForSemanticTag = NULL;
    m_ulIndexOfWord = 0;
    m_ulCharOffsetOfWord = 0;
    m_flWeight = 1.0;
    m_pRuleRef = NULL;
    m_RequiredConfidence = 0;
    m_SpecialTransitionIndex = 0;
    m_ulSerializationIndex = 0;
}

/****************************************************************************
* CArc::~CArc() *
*---------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CArc::~CArc()
{
    delete m_pSemanticTag;
}

/****************************************************************************
* CArc::Init *
*------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CArc::Init(CGramNode * pSrcNode, CGramNode * pDestNode,
                    const WCHAR * pszWord, CRule * pRuleRef,
                    CSemanticTag * pSemanticTag,
                    float flWeight, 
                    bool fOptional,
                    char ConfRequired,
                    SPSTATEHANDLE hSpecialRule)
{
    SPDBG_FUNC("CArc::Init");
    HRESULT hr = S_OK;
    m_pSemanticTag = pSemanticTag;
    m_fOptional = fOptional;
    m_RequiredConfidence = ConfRequired;
    m_pRuleRef = pRuleRef;
    m_pNextState = pDestNode;
    m_flWeight = flWeight;
    if (flWeight != DEFAULT_WEIGHT)
    {
        pSrcNode->m_pParent->m_fNeedWeightTable = TRUE;
    }
    if (pRuleRef)
    {
        m_ulIndexOfWord = 0;
        m_ulCharOffsetOfWord = 0;
    }
    else
    {
        if (hSpecialRule)
        {
            m_SpecialTransitionIndex = (hSpecialRule == SPRULETRANS_WILDCARD) ? SPWILDCARDTRANSITION :
                                          (hSpecialRule == SPRULETRANS_DICTATION) ? SPDICTATIONTRANSITION : SPTEXTBUFFERTRANSITION;
        }
        else
        {
            hr = pSrcNode->m_pParent->m_Words.Add(pszWord, &m_ulCharOffsetOfWord, &m_ulIndexOfWord);
        }
    }
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CArc::Init2 *
*-------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CArc::Init2(CGramNode * pSrcNode, CGramNode * pDestNode,
                    const ULONG ulCharOffsetOfWord, 
                    const ULONG ulIndexOfWord,
                    CSemanticTag * pSemanticTag,
                    float flWeight, 
                    bool fOptional,
                    char ConfRequired,
                    const ULONG ulSpecialTransitionIndex)
{
    SPDBG_FUNC("CArc::Init2");
    HRESULT hr = S_OK;

    m_pSemanticTag = pSemanticTag;
    m_fOptional = fOptional;
    m_RequiredConfidence = ConfRequired;
    m_ulCharOffsetOfWord = ulCharOffsetOfWord;
    m_ulIndexOfWord = ulIndexOfWord;
    m_pRuleRef = NULL;
    m_pNextState = pDestNode;
    m_flWeight = flWeight;
    if (flWeight != DEFAULT_WEIGHT)
    {
        pSrcNode->m_pParent->m_fNeedWeightTable = TRUE;
    }
    m_SpecialTransitionIndex = ulSpecialTransitionIndex;
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CArc::SerializeArcData *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

inline HRESULT CArc::SerializeArcData(CGramBackEnd * pBackend, BOOL fIsEpsilon, ULONG ulArcIndex, float *pWeight)
{
    SPDBG_FUNC("CArc::SerializeArcData");
    HRESULT hr = S_OK;

    SPCFGARC A;

    memset(&A, 0, sizeof(A));
    
    A.fLastArc = (fIsEpsilon == TRUE) ? 0 : (m_pNext == NULL);
    A.fHasSemanticTag = HasSemanticTag();
    A.NextStartArcIndex = m_pNextState ? m_pNextState->m_ulSerializeIndex : 0;

    if (m_pRuleRef)
    {
        A.fRuleRef = true;
        A.TransitionIndex = m_pRuleRef->m_ulSerializeIndex; //m_pFirstNode->m_ulSerializeIndex;
    }
    else
    {
        A.fRuleRef = false;
        if (m_SpecialTransitionIndex)
        {
            A.TransitionIndex = m_SpecialTransitionIndex;
        }
        else
        {
            A.TransitionIndex = (fIsEpsilon == TRUE) ? 0 : m_ulIndexOfWord;
        }
    }
    A.fLowConfRequired = (m_RequiredConfidence < 0) ? 1 : 0;
    A.fHighConfRequired = (m_RequiredConfidence > 0) ? 1 : 0;
    m_ulSerializationIndex = ulArcIndex;

    hr =  pBackend->WriteStream(A);

    if (pWeight)
    {
        *pWeight = m_flWeight;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
/****************************************************************************
* CArc::SerializeSemanticData *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CArc::SerializeSemanticData(CGramBackEnd * pBackend, ULONG ulArcDataIndex)
{
    SPDBG_FUNC("CArc::SerializeSemanticData");
    HRESULT hr = S_OK;

    if (m_pSemanticTag)
    {
        m_pSemanticTag->ArcIndex = ulArcDataIndex;
        SPDBG_ASSERT(m_pSemanticTag->m_pStartArc != NULL);
        m_pSemanticTag->StartArcIndex = m_pSemanticTag->m_pStartArc->m_ulSerializationIndex;
        m_pSemanticTag->fStartParallelEpsilonArc |= m_pSemanticTag->m_pStartArc->m_fOptional;
        
        SPDBG_ASSERT(m_pSemanticTag->m_pEndArc != NULL);
        m_pSemanticTag->EndArcIndex = m_pSemanticTag->m_pEndArc->m_ulSerializationIndex;
        m_pSemanticTag->fEndParallelEpsilonArc |= m_pSemanticTag->m_pEndArc->m_fOptional;
        hr = pBackend->WriteStream(static_cast<SPCFGSEMANTICTAG>(*m_pSemanticTag));
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CSemanticTag::Init *
*--------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CSemanticTag::Init(CGramBackEnd * pBackEnd, const SPPROPERTYINFO * pPropInfo)
{
    SPDBG_FUNC("CSemanticTag::Init");
    HRESULT hr = S_OK;

    memset(static_cast<SPCFGSEMANTICTAG *>(this), 0, sizeof(SPCFGSEMANTICTAG));

    if (SP_IS_BAD_READ_PTR(pPropInfo))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = ValidateSemanticVariantType(pPropInfo->vValue.vt);
    }

    if (SUCCEEDED(hr))
    {
        ArcIndex = 0;
        PropId = pPropInfo->ulId;
        hr = pBackEnd->m_Symbols.Add(pPropInfo->pszName, &PropNameSymbolOffset);
    }
    if (SUCCEEDED(hr))
    {
        hr = pBackEnd->m_Symbols.Add(pPropInfo->pszValue, &PropValueSymbolOffset);
    }
    if (SUCCEEDED(hr))
    {
        hr = CopyVariantToSemanticValue(&pPropInfo->vValue, &this->SpVariantSubset);
    }
    if (SUCCEEDED(hr))
    {
        PropVariantType = (pPropInfo->vValue.vt == (VT_BYREF | VT_VOID)) ? SPVT_BYREF : pPropInfo->vValue.vt;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
/****************************************************************************
* CSemanticTag::Init *
*--------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CSemanticTag::Init(CGramBackEnd * pBackEnd, const SPCFGHEADER * pHeader, CArc ** apArcTable, const SPCFGSEMANTICTAG *pSemTag)
{
    SPDBG_FUNC("CSemanticTag::Init");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_READ_PTR(pSemTag))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        memcpy(this, pSemTag, sizeof(*pSemTag));
    }
    if (SUCCEEDED(hr) && pSemTag->PropNameSymbolOffset)
    {
        hr = pBackEnd->m_Symbols.Add(&pHeader->pszSymbols[pSemTag->PropNameSymbolOffset], &PropNameSymbolOffset);
    }
    if (SUCCEEDED(hr) && pSemTag->PropValueSymbolOffset)
    {
        hr = pBackEnd->m_Symbols.Add(&pHeader->pszSymbols[pSemTag->PropValueSymbolOffset], &PropValueSymbolOffset);
    }

    if (SUCCEEDED(hr) && apArcTable[pSemTag->StartArcIndex] == NULL)
    {
        apArcTable[pSemTag->StartArcIndex] = new CArc;
        if (apArcTable[pSemTag->StartArcIndex] == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_pStartArc = apArcTable[pSemTag->StartArcIndex];
    }
    if (SUCCEEDED(hr) && apArcTable[pSemTag->EndArcIndex] == NULL)
    {
        apArcTable[pSemTag->EndArcIndex] = new CArc;
        if (apArcTable[pSemTag->EndArcIndex] == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_pEndArc = apArcTable[pSemTag->EndArcIndex];
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\baseaudio.h ===
/****************************************************************************
*   baseaudio.h
*       Declaration of the templatized CBaseAudio class used to implement
*       ISpAudio for realtime audio devices (like speakers, microphone, etc)
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#pragma once

//--- Includes --------------------------------------------------------------

#include "speventq.h"
#include "baseaudiobuffer.h"
#include "audiobufferqueue.h"

//--- Forward and External Declarations -------------------------------------

//--- TypeDef and Enumeration Declarations ----------------------------------

typedef enum BUFFPROCREASON
{
    REASON_PAUSE,
    REASON_RUN,
    REASON_BUFFCOMPLETENOTIFY,
    REASON_STREAMIO // Read or write
};

//--- Constants -------------------------------------------------------------

#define WM_PRIVATE_CHANGE_STATE WM_APP

//--- Class, Struct and Union Definitions -----------------------------------

/****************************************************************************
*
* CBaseAudio<ISpAudioDerivative>
*
******************************************************************** robch */
template <class ISpAudioDerivative>
class ATL_NO_VTABLE CBaseAudio : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public ISpAudioDerivative,
    public ISpEventSource,
    public ISpEventSink,
    public ISpObjectWithToken,
    public ISpThreadTask
    //--- Automation
    #ifdef SAPI_AUTOMATION
    #endif
{
//=== ATL Setup ===
public:

    BEGIN_COM_MAP(CBaseAudio)
    	COM_INTERFACE_ENTRY(IStream)
        COM_INTERFACE_ENTRY(ISequentialStream)
        COM_INTERFACE_ENTRY(ISpStreamFormat)
        COM_INTERFACE_ENTRY(ISpAudio)
        COM_INTERFACE_ENTRY(ISpNotifySource)
    	COM_INTERFACE_ENTRY(ISpEventSource)
        COM_INTERFACE_ENTRY(ISpEventSink)
        COM_INTERFACE_ENTRY(ISpObjectWithToken)
        //--- Automation
        #ifdef SAPI_AUTOMATION
//      COM_INTERFACE_ENTRY(ISpeechAudio)
//      COM_INTERFACE_ENTRY(IDispatch)
        #endif
    END_COM_MAP()

    DECLARE_GET_CONTROLLING_UNKNOWN();

//=== Typedefs ===
public:

    typedef CBaseAudioBuffer CBuffer;
    typedef CAudioBufferQueue<CBaseAudioBuffer> CBufferQueue;

//=== Methods ===
public:

    //--- Ctor, dtor, etc
    CBaseAudio(BOOL fWrite);
    virtual ~CBaseAudio()
    { }

    HRESULT FinalConstruct();
    void FinalRelease();

    /*--- Non interface methods ---*/
    HRESULT _SetStat(SPAUDIOBUFFERINFO * pInfo, ULONG * pulField, float NewVal);
    HRESULT _GetStat(SPAUDIOBUFFERINFO * pInfo, ULONG * pulField, float * pRetVal);

  //=== Interfaces ============================================================
  public:
    //--- ISequentialStream ---
    STDMETHODIMP Read(void * pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(const void * pv, ULONG cb, ULONG *pcbWritten);

    //--- IStream ---
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER __RPC_FAR *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert(void);
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppstm);

    //--- ISpStreamFormat ---
    STDMETHODIMP GetFormat(GUID * pguidFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx);

    //--- ISpAudio ---
    STDMETHODIMP SetState(SPAUDIOSTATE NewState, ULONGLONG ullReserved );
    STDMETHODIMP SetFormat(REFGUID rguidFmtId, const WAVEFORMATEX * pWaveFormatEx);
    STDMETHODIMP GetStatus(SPAUDIOSTATUS *pStatus);
    STDMETHODIMP SetBufferInfo(const SPAUDIOBUFFERINFO * pInfo);
    STDMETHODIMP GetBufferInfo(SPAUDIOBUFFERINFO * pInfo);
    STDMETHODIMP GetDefaultFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx);
    STDMETHODIMP_(HANDLE) EventHandle();
	STDMETHODIMP GetVolumeLevel(ULONG *pLevel);
	STDMETHODIMP SetVolumeLevel(ULONG Level);
    STDMETHODIMP GetBufferNotifySize(ULONG *pcbSize);
    STDMETHODIMP SetBufferNotifySize(ULONG cbSize);

    //--- ISpNotifySource ---
    //--- ISpEventSource ---
    CSpEventSource m_SpEventSource;
    DECLARE_SPEVENTSOURCE_METHODS(m_SpEventSource)

    //--- ISpEventSink ---
    STDMETHODIMP AddEvents(const SPEVENT* pEventArray, ULONG ulCount);
    STDMETHODIMP GetEventInterest(ULONGLONG * pullEventInterest);

    //--- ISpObjectWithToken ---
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);
    STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken);

    //--- ISpThreadTask (called only from audio thread) ---
    STDMETHODIMP InitThread(void *, HWND hwnd);
    STDMETHODIMP ThreadProc(void * pvIgnored, HANDLE hExitThreadEvent, HANDLE hNotifyEvent, HWND hwnd, volatile const BOOL *);
    STDMETHODIMP_(LRESULT) WindowMessage(void * pvIgnored, HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam);

#ifdef SAPI_AUTOMATION
    //--- ISpeechBaseStream ----------------------------------------
    STDMETHODIMP get_Format(ISpeechAudioFormat** ppStreamFormat);
    STDMETHODIMP putref_Format(ISpeechAudioFormat* pFormat);
    STDMETHODIMP Read(VARIANT* pvtBuffer, long NumBytes, long* pRead);
    STDMETHODIMP Write(VARIANT vtBuffer, long* pWritten);
    STDMETHODIMP Seek(VARIANT Move, SpeechStreamSeekPositionType Origin, VARIANT* pNewPosition);

    //--- ISpeechAudio ----------------------------------------
	STDMETHODIMP get_Status( ISpeechAudioStatus** Status );
    STDMETHODIMP get_BufferInfo(ISpeechAudioBufferInfo** ppBufferInfo);
    STDMETHODIMP get_DefaultFormat(ISpeechAudioFormat** ppStreamFormat);
    STDMETHODIMP get_Volume(long* pVolume);
    STDMETHODIMP put_Volume(long Volume);
    STDMETHODIMP get_BufferNotifySize(long* pBufferNotifySize);
    STDMETHODIMP put_BufferNotifySize(long BufferNotifySize);
    STDMETHODIMP get_EventHandle(long* pEventHandle);
	STDMETHODIMP SetState( SpeechAudioState State );
#endif // SAPI_AUTOMATION

  //=== Virtual functions overridden by derived classes ===
  protected:
    // Note: Each of these functions is called with the critical section already owned.
    virtual HRESULT SetDeviceNameFromToken(const WCHAR * pszDeviceName) = 0;
    virtual HRESULT GetDefaultDeviceFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx) = 0;

    virtual HRESULT OpenDevice(HWND hwnd) = 0;                              // Called on audio thread
    virtual HRESULT ChangeDeviceState(SPAUDIOSTATE NewState) = 0;           // Called only on audio thread
    virtual HRESULT CloseDevice() = 0;                                      // Called only on audio thread

    virtual HRESULT AllocateDeviceBuffer(CBuffer ** ppBuff) = 0;

    virtual HRESULT ProcessDeviceBuffers(BUFFPROCREASON Reason);
    virtual BOOL UpdateDevicePosition(long * pulFreeSpace, ULONG *pulNonBlockingIO);

//=== Methods available for use by the derived class ===
protected:

    // Note: These functions should only be called from the virtual functions 
    // above. Calling from other methods may cause problems.

    SPAUDIOSTATE GetState() { return m_State; };

    HRESULT AllocateBuffer(CBuffer ** ppBuff);
    void FreeBuffer(CBuffer * pBuff);
    void CompactFreeQueue();
    void PurgeAllQueues();

    BOOL IsPumpRunning() { return m_bPumpRunning; };
    void StartPump() { m_bPumpRunning = TRUE; };
    void SetUnresponsiveSRDriver(bool f)
    {
        m_fReadBufferOverflow = f; 
    };
    
    void CheckForAsyncBufferCompletion();
    HRESULT InternalStateChange(SPAUDIOSTATE NewState);

///=== Protected data ===
protected:

    CComPtr<ISpObjectToken>     m_cpToken;
    SPAUDIOSTATE                m_State;
    CBufferQueue                m_IOInProgressQueue;
    CBufferQueue                m_HaveDataQueue;
    CBufferQueue                m_FreeQueue;

    HMODULE                     m_hmWTSapi32; //it is used to load wtsapi32.dll

    ULONG                       m_cDesiredBuffers;
    ULONG                       m_cAllocatedBuffers;
    ULONG                       m_cbBufferSize;
    ULONG                       m_cbQueueSize;
    ULONG                       m_cbMaxReadBufferSize;
    
    ULONGLONG                   m_ullSeekPosition;
    ULONGLONG                   m_ullDevicePosition;
    ULONGLONG                   m_ullLastVolumePosition;
    ULONGLONG                   m_ullVolumeEventPeriod;
    const BOOL                  m_fWrite;
    BOOL                        m_fautohAPIEventSet;
    DWORD                       m_lDelayedVolumeSet;

//=== Private methods ===
private:

    //HRESULT InternalStateChange(SPAUDIOSTATE NewState);
    void InternalUpdatePosition();
    void ProcessEvents();
    inline ULONG GetUnusedWriteBufferSpace(void);

//=== Protected data
protected:
    CSpStreamFormat             m_StreamFormat;
    bool                        m_fReadBufferOverflow;
    bool                        m_fReadBufferUnderflow;
    bool                        m_fNotInActiveSession;
    DWORD_PTR                   m_dwLastReadTickCount;

//=== Private data
private:

    typedef enum BLOCKSTATE
    {
        NotBlocked,
        WaitingInReadOrWrite 
    };


    CComAutoCriticalSection     m_StateChangeCritSec;

    CComPtr<ISpThreadControl>   m_cpThreadCtrl;
    BOOL                        m_bPumpRunning;

    CSpAutoEvent                m_autohBlockIoEvent;
    BLOCKSTATE                  m_BlockState;
    HRESULT                     m_hrUnblockResult;
    CSpAutoEvent                m_autohAPIEvent;
    
    SPAUDIOBUFFERINFO           m_BufferInfo;
    ULONG                       m_cbEventBias;
    ULONGLONG                   m_ullLastEventPos;
    ULONG                       m_cbBufferNotifySize;
};

//--- Inline Function Definitions -------------------------------------------
#include "baseaudio.inl"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\cfgengine.h ===
/*******************************************************************************
* CFGEngine.h *
*-------------*
*   Description:
*-------------------------------------------------------------------------------
*  Created By: RAL
*  Copyright (C) 1998, 1999 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/

#ifndef __CFGENGINE_H_
#define __CFGENGINE_H_

#include "cfggrammar.h"

#ifndef _CRTDBG_MAP_ALLOC
#define _CRTDBG_MAP_ALLOC
#endif
#include <crtdbg.h>
#include <stdio.h>  // for wprintf
#ifndef _WIN32_WCE
#include <wchar.h>  // for _wcsdup
#endif

class CCFGEngine;
class CBaseInterpreter;
class CInterpreterSite;
class CTransitionId;


// local datastructure to hold the ClientContext
struct WORDTABLEENTRY
{
    ULONG       cRefs;
    ULONG       ulTextOffset;
    void *      pvClientContext;
};


class CStateInfoListElement : public CSpStateInfo
{
public:
    CStateInfoListElement(): CSpStateInfo()
    {
    }

    CStateInfoListElement * m_pNext;
};

typedef struct SPPARSENODE
{
    SPTRANSITIONID      ID;
    BYTE                Type;
    union
    {
        const WCHAR        *pszRuleName;
        const WCHAR        *pszWordDisplayText;
    };
    ULONG               ulRuleId;
    BOOL                fInvokeInterpreter;
    BOOL                fRuleExit;
    BOOL                fRedoWildcard;
    union
    {
        SPWORDHANDLE hWord;
        SPRULEHANDLE hRule;
    };
    ULONG  ulFirstElement;
    ULONG  ulCountOfElements;
    signed char             RequiredConfidence;
} SPPARSENODE;

class CParseNode : public SPPARSENODE
{
public:
    CParseNode() : m_pLeft(NULL), m_pRight(NULL), m_pNext(NULL), m_pParent(NULL)
    {
        pszRuleName = NULL;
        ulRuleId = 0;
        fInvokeInterpreter = FALSE;
        fRedoWildcard = FALSE;
    }
    
    void Init()
    {
        m_pNext     = NULL;
        m_pLeft     = NULL;
        m_pRight    = NULL;
        m_pParent   = NULL;
        pszRuleName = NULL;
        ulRuleId    = 0;
        fInvokeInterpreter = FALSE;
        fRedoWildcard = FALSE;
    }
    
    CParseNode  * m_pNext;
    CParseNode  * m_pLeft;
    CParseNode  * m_pRight;
    CParseNode  * m_pParent;
};

struct SPTIDNODE
{
    SPTRANSITIONID  tid;
    DWORD           ulIndex : 22;       // count of words in the input (EPS will have the count of the *next* word!
    DWORD           fIsWord : 1;
    DWORD           dwReserved : 9;
};

class CTIDArray
{
public:
    CTIDArray(ULONG cWords) : m_cWords(cWords), m_cArcs(0), m_cAllocedArcs(0), m_ulIndex(0), m_ulCurrentIndex(0)
    {
        m_aTID = new SPTIDNODE[16];
        if (m_aTID) 
        {
            m_cAllocedArcs = 16;
            memset(m_aTID, 0, m_cAllocedArcs * sizeof(SPTIDNODE));
        }
    }
    CTIDArray(ULONG cArcs, ULONG cWords) : m_cWords(cWords), m_cArcs(0), m_cAllocedArcs(0), m_ulIndex(0), m_ulCurrentIndex(0)
    {
        m_aTID = new SPTIDNODE[2*cArcs];
        if (m_aTID) 
        {
            m_cAllocedArcs = 2*cArcs;
            memset(m_aTID, 0, m_cAllocedArcs * sizeof(SPTIDNODE));
        }
    }
    ~CTIDArray()
    {
        delete [] m_aTID;
    }
    HRESULT Insert(SPTRANSITIONID tid, BOOL fIsWord)
    {
        HRESULT hr = S_OK;
        if (m_cArcs == (m_cAllocedArcs -1))
        {
            // double the size
            SPTIDNODE *pTemp = new SPTIDNODE[2*m_cAllocedArcs];
            if (pTemp)
            {
                memset(pTemp, 0, 2* m_cAllocedArcs * sizeof(SPTIDNODE));
                memcpy(pTemp, m_aTID, m_cArcs*sizeof(SPTIDNODE));
                m_cAllocedArcs *= 2;
                delete [] m_aTID;
                m_aTID = pTemp;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        if (SUCCEEDED(hr))
        {
            m_aTID[m_cArcs].fIsWord = fIsWord;
            if (m_cArcs > 0)
            {
                m_ulIndex = m_aTID[m_cArcs-1].fIsWord ? m_ulIndex + 1 : m_ulIndex;
            }
//            SPDBG_ASSERT(m_ulIndex <= m_cWords);
            m_ulIndex = (m_ulIndex > m_cWords) ? m_cWords : m_ulIndex;
            m_aTID[m_cArcs].ulIndex = m_ulIndex;
            m_aTID[m_cArcs++].tid = tid;
        }
        return hr;
    }

    HRESULT ConstructFromParseTree(CParseNode *pParseNode)
    {
        HRESULT hr = S_OK;
        if (pParseNode->Type == SPTRANSEPSILON)
        {
            hr = Insert(pParseNode->ID, FALSE);
        }
        else if (pParseNode->Type == SPTRANSWORD)
        {
            hr = Insert(pParseNode->ID, TRUE);
        }
        else if (pParseNode->Type == SPTRANSDICTATION)
        {
            hr = Insert(pParseNode->ID, TRUE);
        }
        else if (pParseNode->Type == SPTRANSTEXTBUF)
        {
            hr = Insert(pParseNode->ID, TRUE);
        }
        else if (pParseNode->Type == SPTRANSWILDCARD)
        {
            hr = Insert(pParseNode->ID, TRUE);
        }
        if (SUCCEEDED(hr) && pParseNode->m_pLeft)
        {
            hr = ConstructFromParseTree(pParseNode->m_pLeft);
        }
        if (SUCCEEDED(hr) && pParseNode->m_pRight)
        {
            hr = ConstructFromParseTree(pParseNode->m_pRight);
        }
        return hr;
    }

public:
    SPTIDNODE         * m_aTID;
    ULONG               m_cArcs;
    ULONG               m_ulIndex;
    ULONG               m_cAllocedArcs;
    ULONG               m_cWords;
    ULONG               m_ulCurrentIndex;
};

#define RULESTACKHASHSIZE 128

class CRuleStack
{
public:
    CRuleStack()
    {
    }

    CRuleStack      *m_pNext;
    CRuleStack      *m_pParent;
    SPTRANSITIONID  m_TransitionId;
    SPSTATEHANDLE   m_hFollowState;
    SPRULEHANDLE    m_hRule;

    inline Init(CRuleStack *pRuleStack, SPTRANSITIONID TransitionId, SPSTATEHANDLE hFollowState, SPRULEHANDLE hRule)
    {
        m_pNext         = NULL;
        m_pParent       = pRuleStack;
        m_TransitionId  = TransitionId;
        m_hFollowState  = hFollowState;
        m_hRule         = hRule;
    }

    inline static ULONG GetHashEntry(CRuleStack *pRuleStack, SPTRANSITIONID TransitionId)
    {
        // NTRAID#SPEECH-7356-2000/08/24-agarside - Fix << 3
        return (ULONG)(((ULONG_PTR)(pRuleStack) + (ULONG_PTR)(TransitionId)) % RULESTACKHASHSIZE);
    }
};

#define SEARCHNODEHASHSIZE 1024

class CSearchNode
{
public:
    CSearchNode()
    {
        m_pNext         = NULL;
        m_pStack        = NULL;
        m_hState        = 0;
        m_cTransitions  = 0;
    }

    CSearchNode     *m_pNext;
    CRuleStack      *m_pStack;
    SPSTATEHANDLE   m_hState;
    UINT            m_cTransitions;

    inline void Init( CRuleStack *pRuleStack, SPSTATEHANDLE hState, UINT cTransitions )
    {
        m_pNext         = NULL;
        m_pStack        = pRuleStack;
        m_hState        = hState;
        m_cTransitions  = cTransitions;
    }

    inline static ULONG GetHashEntry(CRuleStack *pRuleStack, SPSTATEHANDLE hState, UINT cTransitions)
    {
        // NTRAID#SPEECH-7356-2000/08/24-agarside - Fix << 3
        return (ULONG)(((ULONG_PTR)(pRuleStack) + (ULONG_PTR)(hState) + cTransitions) % RULESTACKHASHSIZE);
    }
};

////////////////////////////////////////////////////////////////
//  Helper class for WORDTABLEENTRY
//
//  allocates and maintains WORDTABLEENTRY on behalf of the CFGEngine

class CWordTableEntryBlob
{
public:
    CWordTableEntryBlob()
    {
        m_pBlob = NULL;
        m_cBlobEntries = 0;
        m_ulNextUnusedEntry = 0;
    }
    ~CWordTableEntryBlob()
    {
        if (m_pBlob)
        {
            free(m_pBlob);
        }
    }

    HRESULT Init(ULONG ulInitSize)
    {
        HRESULT hr = S_OK;
        if ((m_pBlob = (WORDTABLEENTRY *)malloc(ulInitSize * sizeof(WORDTABLEENTRY))) == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        if (SUCCEEDED(hr))
        {
            m_cBlobEntries = ulInitSize;
        }
        return hr;
    }

    HRESULT GetNewWordTableEntry(WORDTABLEENTRY **ppEntry)
    {
        if (SP_IS_BAD_WRITE_PTR(ppEntry))
        {
            return E_INVALIDARG;
        }
        HRESULT hr = S_OK;
        if (m_ulNextUnusedEntry == m_cBlobEntries)      // this also catches m_pBlob == NULL
        {
            WORDTABLEENTRY *pTemp = (WORDTABLEENTRY*) realloc(m_pBlob,(m_cBlobEntries + 1024)*sizeof(WORDTABLEENTRY));
            if (pTemp == NULL)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                memset(pTemp+m_cBlobEntries,0, 1024*sizeof(WORDTABLEENTRY));
                m_pBlob = pTemp;
                m_cBlobEntries += 1024;
            }
        }
        if (SUCCEEDED(hr))
        {
            *ppEntry = &m_pBlob[m_ulNextUnusedEntry++];
        }
        return hr;
    }

    HRESULT Clear()
    {
        HRESULT hr = S_OK;
        m_ulNextUnusedEntry = 0;
        return hr;
    }

private:
    WORDTABLEENTRY    * m_pBlob;
    ULONG               m_cBlobEntries;
    ULONG               m_ulNextUnusedEntry;
};

/////////////////////////////////////////////////////////////////////////////
// CBaseInterpreter


/////////////////////////////////////////////////////////////////////////////
// CInterpreterSite

class CInterpreterSite : public ISpCFGInterpreterSite
{
public:
    CInterpreterSite()
    {
        m_pPhrase = NULL;
        m_pCFGEngine = NULL;
        m_hParentProperty = NULL;
        m_hThisNodeProperty = NULL;
        m_ulFirstElement = 0;
        m_ulCountOfElements = 0;
        m_hRule = NULL;
    }

    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == __uuidof(ISpCFGInterpreterSite) || riid == __uuidof(IUnknown))
        {
            *ppv = (ISpCFGInterpreterSite *)this;
            return S_OK;
        }
        return E_NOINTERFACE;
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return 2;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        return 1;
    }


    STDMETHODIMP AddTextReplacement(SPPHRASEREPLACEMENT * pReplace)
    {
        if (SP_IS_BAD_READ_PTR(pReplace))
        {
            return E_INVALIDARG;
        }
        pReplace->ulFirstElement = m_ulFirstElement;
        pReplace->ulCountOfElements = m_ulCountOfElements;
        return m_pPhrase->AddReplacements(1,pReplace);
    }

    STDMETHODIMP AddProperty(const SPPHRASEPROPERTY *pProperty)
    {
        m_CritSec.Lock();
        HRESULT hr = S_OK;
        if (m_hThisNodeProperty == NULL)
        {
            SPPHRASEPROPERTY prop;
            SpZeroStruct(prop);
            prop.ulFirstElement = m_ulFirstElement;
            prop.ulCountOfElements = m_ulCountOfElements;
            prop.pszName = m_pszRuleName;
            prop.ulId = m_ulRuleId;
            hr = m_pPhrase->AddProperties(m_hParentProperty, &prop, &m_hThisNodeProperty);
        }
        m_CritSec.Unlock();
        if (SUCCEEDED(hr))
        {
            hr = m_pPhrase->AddProperties(m_hThisNodeProperty, pProperty, NULL);
        }
        return hr;
    }
    
    STDMETHODIMP GetResourceValue(const WCHAR * pszResourceName, WCHAR **ppszResourceValue)
    {
        return m_pCFGEngine->GetResourceValue(m_hRule, pszResourceName, ppszResourceValue);
    }

    STDMETHODIMP Initialize(ISpCFGEngine *pCFGEngine, ISpPhraseBuilder *pPhrase,
                            const WCHAR * pszRuleName, ULONG ulRuleId,
                            const ULONG ulFirstElement, const ULONG ulCountOfElements,
                            SPPHRASEPROPERTYHANDLE hParentProperty, SPPHRASEPROPERTYHANDLE hThisNodeProperty,
                            SPRULEHANDLE hRule)
    {
        HRESULT hr = S_OK;
        m_pPhrase = pPhrase;
        m_ulFirstElement = ulFirstElement;
        m_ulCountOfElements = ulCountOfElements;
        m_pCFGEngine = pCFGEngine;
        m_hParentProperty = hParentProperty;
        m_hThisNodeProperty = hThisNodeProperty;
        m_pszRuleName = pszRuleName;
        m_ulRuleId = ulRuleId;
        m_hRule = hRule;
        return hr;
    }

//
//  Member data
//
    const WCHAR             * m_pszRuleName;
    ULONG                     m_ulRuleId;
    ISpCFGEngine            * m_pCFGEngine;
    ISpPhraseBuilder        * m_pPhrase;
    ULONG                     m_ulFirstElement;
    ULONG                     m_ulCountOfElements;
    SPPHRASEPROPERTYHANDLE    m_hParentProperty;
    SPPHRASEPROPERTYHANDLE    m_hThisNodeProperty;
    SPRULEHANDLE              m_hRule;
    CComAutoCriticalSection   m_CritSec;
};

/////////////////////////////////////////////////////////////////////////////
// CCFGEngine

const DWORD MAXNUMGRAMMARS = 1024;
const DWORD ARCCHUNK = 32;

class CRuleHandle
{
private:

    DWORD   m_RuleIndex : 22;
    DWORD   m_GrammarId : 10;
    
public:
    CRuleHandle()
    {}
    CRuleHandle(SPRULEHANDLE h)
    {
        *(DWORD*)this = HandleToUlong(h);
    }
    CRuleHandle(ULONG GrammarId, ULONG RuleIndex)
    {
        m_GrammarId = GrammarId;
        m_RuleIndex = RuleIndex+1;
    }
    inline CRuleHandle(const CCFGGrammar * pGrammar, ULONG RuleIndex);
    operator=(SPRULEHANDLE h)
    {
        *(DWORD*)this = HandleToUlong(h);
        return *(DWORD *)this;
    }
    operator SPRULEHANDLE()
    {
        return (SPRULEHANDLE)LongToHandle(*(DWORD*)this);
    }
    ULONG GrammarId()
    {
        return m_GrammarId;
    }
    ULONG RuleIndex()
    {
        return m_RuleIndex-1;
    }
};


class CStateHandle
{
private:
    DWORD   m_FirstArcIndex : 22;
    DWORD   m_GrammarId     : 10;

public:
    CStateHandle()
    {}
    CStateHandle(SPSTATEHANDLE h)
    {
        *(DWORD*)this = HandleToUlong(h);
    }
    CStateHandle(ULONG GrammarId, ULONG FirstArcIndex)
    {
        m_GrammarId = GrammarId;
        m_FirstArcIndex = FirstArcIndex;
    }
    inline CStateHandle(const CCFGGrammar * pGrammar, ULONG ArcIndex);
    operator =(SPSTATEHANDLE h)
    {
        *(DWORD*)this = HandleToUlong(h);
        return *(DWORD*)this;
    }
    operator SPSTATEHANDLE()
    {
        return (SPSTATEHANDLE)LongToHandle(*(DWORD*)this);
    }
    ULONG GrammarId()
    {
        return m_GrammarId;
    }
    ULONG FirstArcIndex()
    {
        return m_FirstArcIndex;
    }
};


class CTransitionId
{
private:
    DWORD   m_ArcIndex  : 22;
    DWORD   m_GrammarId : 10;

public:
    CTransitionId()
    {}
    CTransitionId(SPTRANSITIONID h)
    {
        *(DWORD*)this = HandleToUlong(h);
    }
    CTransitionId(ULONG GrammarId, ULONG ArcIndex)
    {
        m_GrammarId = GrammarId;
        m_ArcIndex = ArcIndex;
    }
    inline CTransitionId(const CCFGGrammar * pGrammar, ULONG ArcIndex);
    operator =(SPTRANSITIONID h)
    {
        *(DWORD*)this = HandleToUlong(h);
        return *(DWORD*)this;
    }
    operator SPTRANSITIONID()
    {
        return (SPTRANSITIONID)LongToHandle(*(DWORD*)this);
    }
    ULONG GrammarId()
    {
        return m_GrammarId;
    }
    ULONG ArcIndex()
    {
        return m_ArcIndex;
    }
    void IncToNextArcIndex()
    {
        m_ArcIndex++;
    }
};


class CWordHandle
{
private:
    DWORD   m_WordTableIndex;
public:
    CWordHandle()
    {}
    CWordHandle(SPWORDHANDLE h)
    {
        *(DWORD*)this = HandleToUlong(h);
    }
    CWordHandle(ULONG WordTableIndex)
    {
        m_WordTableIndex = WordTableIndex;
    }
    operator =(SPWORDHANDLE h)
    {
        *(DWORD *)this = HandleToUlong(h);
        return *(DWORD*)this;
    }
    operator =(ULONG WordTableIndex)
    {
        m_WordTableIndex = WordTableIndex;
        return m_WordTableIndex;
    }
    operator SPWORDHANDLE()
    {
        return (SPWORDHANDLE)LongToHandle(*(DWORD*)this);
    }
    ULONG WordTableIndex()
    {
        return m_WordTableIndex;
    }
};

// This class represents the results of a parse using ConstrctParseTree. It records total number
// of words parsed as well as how many of these were dictation tag or wildcard words.
// The Compare method allows two parses to be compared on the basis of which covers the most words
// and uses the least dictation words. This allows EmulateRecognition to pick a CFG parse over a dictation one.
class WordsParsed
{
public:
    ULONG ulWordsParsed;
    ULONG ulDictationWords;
    ULONG ulWildcardWords;

    WordsParsed() 
        : ulWordsParsed(0),
        ulDictationWords(0),
        ulWildcardWords(0)
    {
    }

    void Zero()
    {
        ulWordsParsed = 0;
        ulDictationWords = 0;
        ulWildcardWords = 0;
    }        

    void Add(WordsParsed *pSource)
    {
        ulWordsParsed += pSource->ulWordsParsed;
        ulDictationWords += pSource->ulDictationWords;
        ulWildcardWords += pSource->ulWildcardWords;
    }

    LONG Compare(WordsParsed *pSource)
    {
        if(ulWordsParsed > pSource->ulWordsParsed)
        {
            return 1;
        }
        else if(ulWordsParsed < pSource->ulWordsParsed)
        {
            return -1;
        }
        else if(ulWildcardWords < pSource->ulWildcardWords)
        {
            return 1;
        }
        else if(ulWildcardWords > pSource->ulWildcardWords)
        {
            return -1;
        }
        else if(ulDictationWords < pSource->ulDictationWords)
        {
            return 1;
        }
        else if(ulDictationWords > pSource->ulDictationWords)
        {
            return -1;
        }
        else
        {
            return 0;
        }
    }
};

class ATL_NO_VTABLE CCFGEngine : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CCFGEngine, &CLSID_SpCFGEngine>,
    public ISpCFGEngine,
    public ISpCFGInterpreter        // Not exposed by QI, used internally
{
friend CCFGGrammar;
public:
DECLARE_REGISTRY_RESOURCEID(IDR_CFGENGINE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCFGEngine)
  COM_INTERFACE_ENTRY(ISpCFGEngine)
END_COM_MAP()

// Non-interface methods
private:
    HRESULT AllocateGrammar(CCFGGrammar ** ppNewGrammar);
    signed char _CalcMultipleWordConfidence(const SPPHRASE *pPhrase, ULONG ulFirstElement, ULONG ulCountOfElements);

    // Hash code.
    HRESULT CreateParseHashes(void);
    HRESULT DeleteParseHashes( BOOL final );
    HRESULT FindCreateRuleStack(CRuleStack **pNewRuleStack, CRuleStack *pRuleStack, SPTRANSITIONID TransitionId, SPSTATEHANDLE hRuleFollowerState);
    HRESULT FindCreateSearchNode(CSearchNode **pNewSearchNode, CRuleStack *pRuleStack, SPSTATEHANDLE hState, UINT cTransitions);
    // End hash code.


    // memory management
    inline HRESULT AllocateStateInfo(CStateHandle StateHandle, CStateInfoListElement ** ppNewState);
    inline HRESULT AllocateSearchNode( CSearchNode **pNewSearchNode );
    inline HRESULT AllocateRuleStack( CRuleStack **pNewRuleStack );
    inline void FreeRuleStack( CRuleStack * pRuleStack );
    inline void FreeSearchNode( CSearchNode * pSearchNode );
    inline HRESULT FreeParseTree(CParseNode * pParseNode);
    // memory management

public:
    // on behalf of CCFGGrammar
    HRESULT AddWords(CCFGGrammar * pGrammar, ULONG ulOldNumWords, ULONG ulOldNumChars);
    HRESULT RemoveWords(const CCFGGrammar * pGrammar);
    HRESULT AddRules(CCFGGrammar * pGrammar, ULONG IndexStart);
    HRESULT RemoveRules(const CCFGGrammar * pGrammar);

    HRESULT ActivateRule(const CCFGGrammar * pGrammar, const ULONG ulRuleIndex);
    HRESULT DeactivateRule(const ULONG ulGrammarID, const ULONG ulRuleIndex);
    HRESULT SetGrammarState(const SPGRAMMARSTATE eGrammarState);

    HRESULT InternalParseFromPhrase(ISpPhraseBuilder *pPhrase,
                                    const SPPHRASE *pSPPhrase, 
                                    const _SPPATHENTRY *pPath, 
                                    const ULONG ulFirstElement,
                                    const BOOL fIsITN,
                                    const BOOL fIsHypothesis,
                                    WordsParsed *pWordsParsed);

    HRESULT ConstructParseTree(CStateHandle hState, const _SPPATHENTRY *pPath, const BOOL fUseWordHandles, const BOOL fIsITN,
                               const ULONG ulFirstTransition, const ULONG cTransitions, const BOOL fIsHypothesis,
                               WordsParsed *pWordsParsed, CParseNode **ppParseNode, BOOL *pfDeletedElements);
    HRESULT InternalConstructParseTree(CStateHandle hState, const _SPPATHENTRY *pPath, const BOOL fUseWordHandles, const BOOL fIsITN,
                               const ULONG ulFirstTransition, const ULONG cTransitions, const BOOL fIsHypothesis,
                               WordsParsed *pWordsParsed, CParseNode **ppParseNode, CRuleStack *pRuleStack);
    HRESULT RestructureParseTree(CParseNode *pParseNode, BOOL *pfDeletedElements);
    HRESULT RecurseAdjustCounts(CParseNode *pParseNode, UINT iRemove);
    HRESULT WalkParseTree(CParseNode *pParseNode,
                          const BOOL fIsITN,
                          const BOOL fIsHypothesis,
                          const SPPHRASEPROPERTYHANDLE hParentProperty,
                          const SPPHRASERULEHANDLE hParentRule,
                          const CTIDArray *pArcList,
                          const ULONG ulElementOffset,
                          const ULONG ulCountOfElements,
                          ISpPhraseBuilder  * pResultPhrase,
                          const SPPHRASE *pPhrase);
    HRESULT InternalGetStateInfo(CStateHandle StateHandle, SPSTATEINFO * pStateInfo, BOOL fWantImports);

    //
    //  Note that we support this interface but QI will not return it.  We simply
    //  support it internally so that we can always call m_cpInterpreter->Interpret()
    //  from a grammar.  For all non-object type grammars, it defers to the CFG Engine
    //
    STDMETHODIMP InitGrammar(const WCHAR * pszGrammarName, const void ** pvGrammarData)
    {
        SPDBG_ASSERT(FALSE);
        return E_NOTIMPL;       // This method should never be called
    }
    STDMETHODIMP Interpret(ISpPhraseBuilder * pPhrase, 
                           const ULONG ulFirstElement,
                           const ULONG ulCountOfElements,
                           ISpCFGInterpreterSite * pSite);

    //
    //  ISpCFGEngine
    //
public:

    HRESULT FinalConstruct()
    {
        HRESULT hr = S_OK;
        m_pGrammars = NULL;
        m_cGrammarTableSize = 0;
        m_cGrammarsLoaded = 0;
        m_cLoadsInProgress = 0;
        m_cArcs = 0;
        m_cTotalRules = 0;
        m_cTopLevelRules = 0;
        m_cNonImportRules = 0;
        m_pWordTable = NULL;
        m_ulLargestIndex = 0;
        m_cWordTableEntries = 0;
        m_RuleStackList = NULL;
        m_SearchNodeList = NULL;
        m_bIsCacheValid  = FALSE;
        m_cLangIDs = 0;
        m_CurLangID = 0;
        m_pClient = NULL;
        return hr;
    }

    ~CCFGEngine()
    {
        SPDBG_ASSERT(m_cGrammarsLoaded == 0);
        if( m_RuleStackList != NULL || m_SearchNodeList != NULL )
        {
            DeleteParseHashes( TRUE );
        }
        if (m_pWordTable)
        {
            delete[] m_pWordTable;
        }
        delete[] m_pGrammars;
    };

    STDMETHODIMP ParseITN( ISpPhraseBuilder *pPhrase );

    STDMETHODIMP ParseFromTransitions(const SPPARSEINFO * pParseInfo, ISpPhraseBuilder **ppPhrase);
    STDMETHODIMP ParseFromPhrase(ISpPhraseBuilder *pPhrase, const SPPHRASE *pSPPhrase, const ULONG ulFirstElementToParse, BOOL fIsITN, ULONG *pulWordsParsed);
    STDMETHODIMP LoadGrammarFromFile(const WCHAR * pszGrammarName, void * pvOwnerCookie, void * pvClientCookie, ISpCFGGrammar **ppGrammarObject);
    STDMETHODIMP LoadGrammarFromObject(REFCLSID rcid, const WCHAR * pszGrammarName, void * pvOwnerCookie, void * pvClientCookie, ISpCFGGrammar ** ppGrammarObject);
    STDMETHODIMP LoadGrammarFromMemory(const SPBINARYGRAMMAR * pData, 
                                       void * pvOwnerCookie, 
                                       void * pvClientCookie, 
                                       ISpCFGGrammar **ppGrammarObject,
                                       WCHAR * pszGrammarName);
    STDMETHODIMP LoadGrammarFromResource(const WCHAR *pszModuleName,
                                         const WCHAR *pszResourceName,
                                         const WCHAR *pszResourceType,
                                         WORD wLanguage,
                                         void * pvOwnerCookie,
                                         void * pvClientCookie,
                                         ISpCFGGrammar **ppGrammarObject);
    STDMETHODIMP SetClient(_ISpRecoMaster * pClient);

    STDMETHODIMP GetWordInfo(SPWORDENTRY * pWordEntry, SPWORDINFOOPT Options);
    STDMETHODIMP SetWordClientContext(SPWORDHANDLE hWord, void * pvClientContext);
    STDMETHODIMP GetRuleInfo(SPRULEENTRY * pRuleEntry, SPRULEINFOOPT Options);
    STDMETHODIMP SetRuleClientContext(SPRULEHANDLE hRule, void * pvClientContext);
    STDMETHODIMP GetStateInfo(SPSTATEHANDLE hState, SPSTATEINFO * pStateInfo);
    STDMETHODIMP GetOwnerCookieFromRule(SPRULEHANDLE rulehandle, void ** ppvOwnerCookie);

    STDMETHODIMP GetResourceValue(const SPRULEHANDLE hRule, const WCHAR *pszResourceName, WCHAR ** ppsz);

    STDMETHODIMP GetRuleDescription(const SPRULEHANDLE hRule, WCHAR ** ppszRuleDescription, ULONG *pulRuleId, LANGID * pLangID);
    STDMETHODIMP GetTransitionProperty(SPTRANSITIONID ID, SPTRANSITIONPROPERTY **ppCoMemProperty);
    STDMETHODIMP RemoveGrammar(ULONG ulGrammarID);
    STDMETHODIMP SetLanguageSupport(const LANGID * paLangIds, ULONG cLangIds);

    //
    //  Template function works for Rules, States, and Transitions
    //
    template<class C> 
    inline CCFGGrammar * GrammarOf(C h)
    {
        return m_pGrammars[h.GrammarId()];
    }

    inline RUNTIMERULEENTRY * RuleOf(CRuleHandle rh);


    inline WORDTABLEENTRY * WordTableEntryOf(CWordHandle wh)
    {
        return m_pWordTable + wh.WordTableIndex();
    }

    inline const WCHAR * TextOf(CWordHandle wh)
    {
        return m_WordStringBlob.String(WordTableEntryOf(wh)->ulTextOffset);
    }

    inline const WCHAR * TextOf(CTransitionId tid)
    {
        CCFGGrammar *pGram = GrammarOf(tid);
        if (pGram)
        {
            ULONG ulTid = pGram->m_Header.pArcs[tid.ArcIndex()].TransitionIndex;
            if (ulTid == SPWILDCARDTRANSITION)
            {
                return SPWILDCARD;
            }
            else if (ulTid == SPDICTATIONTRANSITION)
            {
                return NULL;    // the CFG engine then uses the SR engine provided data
            }
            else if (ulTid == SPTEXTBUFFERTRANSITION)
            {
                return NULL;    // the CFG engine then uses the SR engine provided data
            }
            CWordHandle wh = pGram->m_IndexToWordHandle[ulTid];
            return m_WordStringBlob.String(WordTableEntryOf(wh)->ulTextOffset);
        }
        return NULL;
    }


    inline ULONG IndexOf(const WCHAR *pszWord)
    {
        return m_WordStringBlob.Find(pszWord);
    }

    inline void * ClientContextOf(CWordHandle wh)
    {
        return WordTableEntryOf(wh)->pvClientContext;
    }

    void ScanForSlash(WCHAR **pp);
    HRESULT SetWordInfo(WCHAR *pszText, SPWORDENTRY *pWordEntry);

    BOOL CompareWords(const CWordHandle wh, const SPPHRASEELEMENT * elem, BOOL fCompareExact, BOOL fCaseSensitive);

    void ResolveWordHandles(_SPPATHENTRY *pPath, const ULONG cElements, BOOL fCaseSensitive);


    //
    //  Helper function for splitting up grammar words into its constituents
    //
    HRESULT AssignTextPointers(WCHAR *pszText, const WCHAR **ppszDisplayText, 
                               const WCHAR **ppszLexicalForm, const WCHAR **ppszPronunciation)
    {
        HRESULT hr = S_OK;
        SPDBG_ASSERT(pszText);
        if (pszText[0] != L'/')
        {
            *ppszDisplayText = pszText;
            *ppszLexicalForm = pszText;
            *ppszPronunciation = NULL;
        }
        else
        {
            *ppszDisplayText = &pszText[0] + 1;
            WCHAR *p = &pszText[0] + 1;     // skipping over '/'
            while(p && (*p != 0) && (*p != L'/'))
            {
                if (*p == L'\\')
                {
                    p++;
                }
                p++;
            }
            if (*p == L'/')
            {
                *ppszLexicalForm = p + 1;
                *p = 0;
                p++;      // skipping over '/'
                while((*p != 0) && (*p != L';') && (*p != L'/'))
                {
                    p++;
                }
                if (*p == L'/')
                {
                    *ppszPronunciation = p + 1;
                    *p = 0;
                }
                else
                {
                    *ppszPronunciation = NULL;
                }
            }
            else
            {
                SPDBG_ASSERT(*p == 0);
                *ppszLexicalForm = NULL;
                *ppszPronunciation = NULL;
            }
        }
        return hr;
    }

    inline BOOL GetPropertiesOfTransition(CTransitionId hTrans, SPPHRASEPROPERTY *pProperty, SPCFGSEMANTICTAG **ppTag, ULONG *pulGrammarId);
    inline BOOL GetPropertiesOfRule(CRuleHandle rh, const WCHAR **ppszRuleName, ULONG *pulRuleId, BOOL *pfIsPropertyRule);
    inline BOOL GetInterpreter(const CRuleHandle rh, ISpCFGInterpreter **ppInterpreter);

    HRESULT ValidateHandle(CRuleHandle rh);
    HRESULT ValidateHandle(CWordHandle wh);
    HRESULT ValidateHandle(CStateHandle sh);
    HRESULT ValidateHandle(CTransitionId th);

    HRESULT InternalLoadGrammarFromFile(const WCHAR * pszGrammarName, void * pvOwnerCookie, void * pvClientCookie, BOOL fIsToplevelLoad, ISpCFGGrammar **ppGrammarObject);
    HRESULT InternalLoadGrammarFromObject(REFCLSID rcid, const WCHAR * pszGrammarName, void * pvOwnerCookie, void * pvClientCookie, BOOL fIsToplevelLoad, ISpCFGGrammar ** ppGrammarObject);
    HRESULT InternalLoadGrammarFromResource(const WCHAR *pszModuleName,
                                         const WCHAR *pszResourceName,
                                         const WCHAR *pszResourceType,
                                         WORD wLanguage,
                                         void * pvOwnerCookie,
                                         void * pvClientCookie,
                                         BOOL fIsToplevelLoad,
                                         ISpCFGGrammar **ppGrammarObject);
    HRESULT InternalLoadGrammarFromMemory(const SPBINARYGRAMMAR * pData, 
                                          void * pvOwnerCookie, 
                                          void * pvClientCookie, 
                                          BOOL fIsToplevelLoad, 
                                          ISpCFGGrammar **ppGrammarObject, 
                                          WCHAR * pszGrammarName);

//
//  Member data
//
public:
    CCFGGrammar      ** m_pGrammars;
    ULONG               m_cLoadsInProgress;
private:

    ULONG               m_cGrammarTableSize;
    ULONG               m_cGrammarsLoaded;
    LANGID              m_aLangIDs[SP_MAX_LANGIDS];
    ULONG               m_cLangIDs;
    LANGID              m_CurLangID;
    ULONG               m_cArcs;
    ULONG               m_cTotalRules;
    ULONG               m_cNonImportRules;
    ULONG               m_cTopLevelRules;
    ULONG               m_cNonterminals;

    _ISpRecoMaster* m_pClient; //weak pointer to avoid circular reference

    CStringBlob         m_WordStringBlob;           // hash table for all words; index is used to access m_paWordTable
    ULONG               m_ulLargestIndex;           // used to detect addition vs. duplicate
    CWordTableEntryBlob m_WordTableEntryBlob;       // memory area for WORDTABLEENTRY to avoid malloc for each individual word

    WORDTABLEENTRY    * m_pWordTable;               // array that contains word info (indexed by String index rather than offset)
    ULONG               m_cWordTableEntries;

    CSpBasicList<CRuleStack>                **m_RuleStackList;
    CSpBasicList<CSearchNode>               **m_SearchNodeList;

    
    // Memory management lists.
    CSpBasicList<CStateInfoListElement>     m_mStateInfoList;
    CSpBasicList<CParseNode>                m_mParseNodeList;
    CSpBasicList<CSearchNode>               m_mSearchNodeList;
    CSpBasicList<CRuleStack>                m_mRuleStackList;

    CSpBasicList<FIRSTPAIR>                 m_mSpPairList;
    BOOL                                    m_bIsCacheValid;

    // Cache code.
    inline HRESULT  AllocatePair( FIRSTPAIR ** pNewPair );
    inline void     FreePair( FIRSTPAIR *pNewPair  );

    inline BOOL     IsInCache( RUNTIMERULEENTRY * pRuleEntry, SPWORDHANDLE hWord );
    inline HRESULT  CacheWord( RUNTIMERULEENTRY * pRuleEntry, SPWORDHANDLE hWord );
    inline HRESULT  InvalidateCache( RUNTIMERULEENTRY * pRuleEntry );

    HRESULT         InvalidateCache( const CCFGGrammar *pGram );
    HRESULT         InvalidateCache(void);

    HRESULT CreateCache(SPRULEHANDLE hRule);
    HRESULT CreateFanout( CStateHandle hState, CRuleStack * pRuleStack );
};


//***************************************************************************
//************************************************************** t-lleav ****

inline HRESULT CCFGEngine::InvalidateCache( RUNTIMERULEENTRY * pRuleEntry )
{
    FIRSTPAIR  * pDelete;
    FIRSTPAIR  * pPair   = pRuleEntry->pFirstList;
    
    while( pPair )
    {
        pDelete = pPair;
        pPair = pPair->m_pNext;
        FreePair( pDelete );
    }

    pRuleEntry->pFirstList    = NULL;
    pRuleEntry->eCacheStatus  = CACHE_VOID;

    return S_OK;
}

//***************************************************************************
//************************************************************** t-lleav ****
inline HRESULT CCFGEngine::CacheWord( RUNTIMERULEENTRY * pRuleEntry, SPWORDHANDLE hWord )
{
    //
    // Do an sorted insert.
    //
    HRESULT hr = S_FALSE;

    FIRSTPAIR  * pPair   = pRuleEntry->pFirstList;
    FIRSTPAIR  ** ppPair = &pRuleEntry->pFirstList;

    // find the end of the list or a hword greater than the one
    // that we are trying to insert.
    while( pPair && hWord > pPair->hWord )
    {
        ppPair = &pPair->m_pNext;
        pPair = pPair->m_pNext;
    }

    // Insert if at end of list or if the words are not equal.
    if( !pPair || hWord != pPair->hWord )
    {
        hr = AllocatePair( ppPair );
        if( SUCCEEDED( hr ) )
        {
            (*ppPair)->m_pNext = pPair;
            (*ppPair)->hWord = hWord;
            hr = S_OK;
            m_bIsCacheValid = TRUE;
        }
    }

    return hr;
}

//***************************************************************************
//************************************************************** t-lleav ****

inline BOOL CCFGEngine::IsInCache( RUNTIMERULEENTRY * pRuleEntry, SPWORDHANDLE hWord )
{
    BOOL bFound = FALSE;

    FIRSTPAIR  * pPair   = pRuleEntry->pFirstList;

    while( pPair && hWord > pPair->hWord )
    {
        pPair = pPair->m_pNext;
    }

    if( pPair && hWord == pPair->hWord )
    {
        bFound  = TRUE;
    }

    return bFound;
}

//***************************************************************************
//************************************************************** t-lleav ****
inline HRESULT CCFGEngine::AllocatePair( FIRSTPAIR ** pNewPair )
{
    SPDBG_FUNC("CCFGEngine::AllocatePair");
    HRESULT hr = S_OK;

    hr = m_mSpPairList.RemoveFirstOrAllocateNew(pNewPair);

    return hr;
}

//***************************************************************************
//************************************************************** t-lleav ****
inline void CCFGEngine::FreePair( FIRSTPAIR *pNewPair  )
{
    m_mSpPairList.AddNode( pNewPair );
}



//***************************************************************************

// used by GetNewWordList
DWORD _GetWordHashValue (const WCHAR * pszWords, const DWORD nLengthHash);

inline RUNTIMERULEENTRY * CCFGEngine::RuleOf(CRuleHandle rh)
{
    CCFGGrammar * pGram = m_pGrammars[rh.GrammarId()];
    return pGram->m_pRuleTable + rh.RuleIndex();
}


inline CRuleHandle::CRuleHandle(const CCFGGrammar * pGrammar, ULONG RuleIndex)
{
    m_GrammarId = pGrammar->m_ulGrammarID;
    m_RuleIndex = RuleIndex+1;
}

inline CStateHandle::CStateHandle(const CCFGGrammar * pGrammar, ULONG FirstArcIndex)
{
    m_GrammarId = pGrammar->m_ulGrammarID;
    m_FirstArcIndex = FirstArcIndex;
}


inline CTransitionId::CTransitionId(const CCFGGrammar * pGrammar, ULONG ArcIndex)
{
    m_GrammarId = pGrammar->m_ulGrammarID;
    m_ArcIndex = ArcIndex;
}

inline BOOL CCFGEngine::GetPropertiesOfTransition(CTransitionId hTrans, SPPHRASEPROPERTY *pProperty, 
                                                  SPCFGSEMANTICTAG **ppTag, ULONG *pulGrammarId)
{
    if (FAILED(ValidateHandle(hTrans)) || SP_IS_BAD_WRITE_PTR(pProperty))
    {
        return FALSE;
    }

    CCFGGrammar * pGram = m_pGrammars[hTrans.GrammarId()];
    SPDBG_ASSERT(pGram);

    // linear search
    SPCFGSEMANTICTAG *pTag = pGram->m_Header.pSemanticTags;
    for (ULONG i = 0; i < pGram->m_Header.cSemanticTags; i++, pTag++)
    {
        if (pTag->ArcIndex == hTrans.ArcIndex())
        {
            if (pTag->PropNameSymbolOffset)
            {
                pProperty->pszName = &pGram->m_Header.pszSymbols[pTag->PropNameSymbolOffset];
            }
            if (pTag->PropValueSymbolOffset)
            {
                pProperty->pszValue = &pGram->m_Header.pszSymbols[pTag->PropValueSymbolOffset];
            }
            pProperty->ulId = pTag->PropId;
            if (FAILED(AssignSemanticValue(pTag, &pProperty->vValue)))
            {
                return false;
            }
            *ppTag = pTag;
            *pulGrammarId = hTrans.GrammarId();
            return true;
        }
    }
    return false;
}

inline BOOL CCFGEngine::GetPropertiesOfRule(CRuleHandle rh, const WCHAR **ppszRuleName, ULONG *pulRuleId, BOOL *pfIsPropRule )
{
    if (FAILED(ValidateHandle(rh)))
    {
        return FALSE;
    }

    CCFGGrammar * pGram = m_pGrammars[rh.GrammarId()];
    SPDBG_ASSERT(pGram);
    if (rh.RuleIndex() > pGram->m_Header.cRules)
    {
        return false;
    }
    SPCFGRULE *pRule = pGram->m_Header.pRules + rh.RuleIndex();

    if (pulRuleId)
    {
        *pulRuleId = pRule->RuleId;
    }

    if (ppszRuleName)
    {
        *ppszRuleName = pRule->NameSymbolOffset ? pGram->m_Header.pszSymbols + pRule->NameSymbolOffset : NULL;
    }

    if (pfIsPropRule)
    {
        if (pRule->fImport)
        {
            RUNTIMERULEENTRY * pImpRule = pGram->m_pRuleTable + rh.RuleIndex();
            CCFGGrammar * pRefGram = pImpRule->pRefGrammar;
            *pfIsPropRule = pRefGram->m_Header.pRules[pImpRule->ulGrammarRuleIndex].fPropRule && (pRefGram->m_LoadedType == Object);
            
            // new rule id because it's an import!
            if (pulRuleId)
            {
                *pulRuleId = pRefGram->m_Header.pRules[pImpRule->ulGrammarRuleIndex].RuleId;
            }
            
            if (ppszRuleName)
            {
                *ppszRuleName = pRefGram->m_Header.pRules[pImpRule->ulGrammarRuleIndex].NameSymbolOffset ? 
                                pRefGram->m_Header.pszSymbols + pRefGram->m_Header.pRules[pImpRule->ulGrammarRuleIndex].NameSymbolOffset : NULL;
            }
        }
        else
        {
            //*pfIsPropRule = pRule->fPropRule;
            *pfIsPropRule = pRule->fPropRule && (pGram->m_LoadedType == Object);
        }
    }
    return true;
}

/****************************************************************************
* CCFGEngine::GetInterpreter *
*----------------------------*
*   Description:
*       Gets interpreter if one is associated with the grammar associated
*   with this rule handle.
*
*   Returns:
*       TRUE if this is a property rule, FALSE otherwise.
*       ppInterpreter   pointer to the interpreter object
*
***************************************************************** philsch ***/

inline BOOL CCFGEngine::GetInterpreter(CRuleHandle rh, ISpCFGInterpreter **ppInterpreter)
{
    CCFGGrammar * pGram = m_pGrammars[rh.GrammarId()];
    SPDBG_ASSERT(pGram);
    if (rh.RuleIndex() > pGram->m_Header.cRules)
    {
        return false;
    }
    SPCFGRULE *pRule = pGram->m_Header.pRules + rh.RuleIndex();
    if (pRule->fImport)
    {
        RUNTIMERULEENTRY * pImpRule = pGram->m_pRuleTable + rh.RuleIndex();
        CCFGGrammar * pRefGram = pImpRule->pRefGrammar;
        *ppInterpreter = pRefGram->m_cpInterpreter;
    }
    else
    {
        *ppInterpreter = pGram->m_cpInterpreter;
    }
    (*ppInterpreter)->AddRef();
    return true;    
}

/****************************************************************************
* CCFGEngine::AllocateStateInfo *
*-------------------------------*
*   Description:
*       Allocates a CStateInfoListElement from the free list and then, if successful,
*   initializes the state info structure.
*
*   Returns:
*       Standard hresults
*
********************************************************************* RAL ***/

inline HRESULT CCFGEngine::AllocateStateInfo(CStateHandle StateHandle, CStateInfoListElement ** ppNewState)
{
    SPDBG_FUNC("CCFGEngine::AllocateStateInfo");
    HRESULT hr = S_OK;

    hr = m_mStateInfoList.RemoveFirstOrAllocateNew(ppNewState);
    if (SUCCEEDED(hr))
    {
        hr = InternalGetStateInfo(StateHandle, *ppNewState, TRUE);
        if (FAILED(hr))
        {
            m_mStateInfoList.AddNode(*ppNewState);
            *ppNewState = NULL;
        }
    }

    return hr;
}

/****************************************************************************
* CCFGEngine::AllocateRuleStack *
****************************************************************************/

inline HRESULT CCFGEngine::AllocateRuleStack( CRuleStack **pNewRuleStack )
{
    SPDBG_FUNC("CCFGEngine::AllocateStateInfo");
    HRESULT hr = S_OK;

    hr = m_mRuleStackList.RemoveFirstOrAllocateNew( pNewRuleStack );

    return hr;
}

/****************************************************************************
* CCFGEngine::AllocateSearchNode *
****************************************************************************/

inline HRESULT CCFGEngine::AllocateSearchNode( CSearchNode **pNewSearchNode )
{
    SPDBG_FUNC("CCFGEngine::AllocateStateInfo");
    HRESULT hr = S_OK;

    hr = m_mSearchNodeList.RemoveFirstOrAllocateNew(pNewSearchNode);

    return hr;
}

/****************************************************************************
* CCFGEngine::FreeRuleStack *
****************************************************************************/

inline void CCFGEngine::FreeRuleStack( CRuleStack * pRuleStack )
{
    m_mRuleStackList.AddNode( pRuleStack );
}

/****************************************************************************
* CCFGEngine::FreeSearchNode *
****************************************************************************/

inline void CCFGEngine::FreeSearchNode( CSearchNode * pSearchNode )
{
    m_mSearchNodeList.AddNode( pSearchNode );
}


/****************************************************************************
* CCFGEngine::FreeParseTree *
*-------------------------------*
*   Description:
*       Recursively deletes the nodes of a parse tree
*
*   Returns:
*       Standard hresults
*
********************************************************************* RAL ***/
inline HRESULT CCFGEngine::FreeParseTree( CParseNode * pParseNode )
{
    SPDBG_ASSERT( pParseNode != NULL );
    // Eliminate stack overflows in the case of recursive nodes.
    CParseNode * pLeft   = pParseNode->m_pLeft;
    CParseNode * pRight  = pParseNode->m_pRight;
    pParseNode->m_pLeft  = NULL;
    pParseNode->m_pRight = NULL;

    SPDBG_ASSERT( pLeft != pParseNode );
    SPDBG_ASSERT( pRight != pParseNode );

    if (pLeft)
    {
        FreeParseTree(pLeft);
    }

    if (pRight)
    {
        FreeParseTree(pRight);
    }

    m_mParseNodeList.AddNode(pParseNode);

    return S_OK;
}


#endif //__CFGENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\baseaudiobuffer.cpp ===
/****************************************************************************
*   baseaudiobuffer.cpp
*       Implementations for the CBaseAudioBuffer class.
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------
#include "stdafx.h"
#include "baseaudiobuffer.h"

/****************************************************************************
* CBaseAudioBuffer::CBaseAudioBuffer *
*------------------------------------*
*   Description:  
*       ctor
*
*   Return:
*   n/a
******************************************************************** robch */
CBaseAudioBuffer::CBaseAudioBuffer()
{
    m_cbDataSize = 0;
    m_cbReadOffset = 0;
    m_cbWriteOffset = 0;
};

/****************************************************************************
* CBaseAudioBuffer::~CBaseAudioBuffer *
*-------------------------------------*
*   Description:  
*       dtor
*
*   Return:
*   n/a
******************************************************************** robch */
CBaseAudioBuffer::~CBaseAudioBuffer()
{
};

/****************************************************************************
* CBaseAudioBuffer::Init *
*------------------------*
*   Description:  
*       Initialize the buffer with a specific size
*
*   Return:
*   TRUE if initialization was successful
*   FALSE if it was not
******************************************************************** robch */
HRESULT CBaseAudioBuffer::Init(ULONG cbDataSize)
{
    // This method should only ever be called once
    SPDBG_ASSERT(0 == m_cbDataSize);

    // Let the derived class allocate it's internal buffers
    if (AllocInternalBuffer(cbDataSize))
    {
        m_cbDataSize = cbDataSize;
        return S_OK;
    }

    return E_OUTOFMEMORY;
};

/****************************************************************************
* CBaseAudioBuffer::Reset *
*-------------------------*
*   Description:  
*       Reset the object to be reused
*
*   Return:
*   n/a
******************************************************************** robch */
void CBaseAudioBuffer::Reset(ULONGLONG ullPos)
{
    SetReadOffset(0);
    SetWriteOffset(0);
};

/****************************************************************************
* CBaseAudioBuffer::Read *
*------------------------*
*   Description:  
*       Read data into ppvData for *pcb size from our internal buffer
*       advancing *ppvData and decrementing *pcb along the way.
*
*   Return:
*   The number of bytes read from our internal buffer
******************************************************************** robch */
ULONG CBaseAudioBuffer::Read(void ** ppvData, ULONG * pcb)
{
    SPDBG_ASSERT(GetReadOffset() <= GetDataSize());
    SPDBG_ASSERT(GetWriteOffset() <= GetDataSize());
    SPDBG_ASSERT(GetReadOffset() <= GetWriteOffset());
    
    ULONG cbCopy = GetWriteOffset() - GetReadOffset();
    SPDBG_ASSERT(cbCopy <= GetDataSize());

    // We can't read more than the caller requested
    if (*pcb < cbCopy)
    {
        cbCopy = *pcb;
    }

    SPDBG_VERIFY(SUCCEEDED(ReadFromInternalBuffer(*ppvData, cbCopy)));
    SetReadOffset(GetReadOffset() + cbCopy);

    *pcb -= cbCopy;
    *ppvData = (((BYTE *)(*ppvData)) + cbCopy);

    return cbCopy;
};

/****************************************************************************
* CBaseAudioBuffer::Write *
*-------------------------*
*   Description:  
*       Write at most *pcb bytes into ppvData from our internal buffer
*       advancing *ppvData and decrementing *pcb along the way.
*
*   Return:
*   The number of bytes written into our internal buffer
******************************************************************** robch */
ULONG CBaseAudioBuffer::Write(const void ** ppvData, ULONG * pcb)
{
    SPDBG_ASSERT(GetReadOffset() <= GetDataSize());
    SPDBG_ASSERT(GetWriteOffset() <= GetDataSize());
    SPDBG_ASSERT(GetReadOffset() <= GetWriteOffset());
    ULONG cbCopy = GetDataSize() - GetWriteOffset();

    // We can't write more than the caller requested
    if (*pcb < cbCopy)
    {
        cbCopy = *pcb;
    }

    SPDBG_VERIFY(SUCCEEDED(WriteToInternalBuffer(*ppvData, cbCopy)));
    SetWriteOffset(GetWriteOffset() + cbCopy);

    *pcb -= cbCopy;
    *ppvData = (((BYTE *)*ppvData) + cbCopy);

    return cbCopy;
};


/****************************************************************************
* CBaseAudioBuffer::GetAudioLevel *
*---------------------------------*
*   Description:  
*       Estimates the peak-peak audio level for the block (on a scale of 1 - 100)
*       and returns in pulLevel. Inheritors of this class should override
*       this method if they want to support audio level information and
*       use a format that this implementation does not support.
*       Audio format information is supplied in this function and not stored
*       in the class to minimize dependence of rest of class on format info.
*
*   Return:
*       S_OK normally
*       S_FALSE if the audio format was not suitable for conversion
*           (currently only linear PCM is supported).
*           Or there was no data in the buffer to analyse
****************************************************************** davewood */
HRESULT CBaseAudioBuffer::GetAudioLevel(ULONG *pulLevel, REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx)
{    
    HRESULT hr = S_OK;
    
    // Check if can calculate volume on this format
    if(rguidFormatId != SPDFID_WaveFormatEx ||
        pWaveFormatEx == NULL ||
        pWaveFormatEx->wFormatTag != WAVE_FORMAT_PCM)
    {
        *pulLevel = 0;
        return S_FALSE;
    }
    
    ULONG ulData = GetWriteOffset();
    SPDBG_ASSERT(ulData <= GetDataSize());

    // Check that we have some data to measure
    if(ulData == 0) 
    {
        *pulLevel = 0;
        hr = S_FALSE;
    }
    // Look at data size    
    else if(pWaveFormatEx->wBitsPerSample == 16)
    {
        short *psData = (short*) (m_Header.lpData);
        ulData = ulData / 2;

        short sMin, sMax;
        sMin = sMax = psData[0];
        for (ULONG ul = 0; ul < ulData; ul++) {
            if (psData[ul] < sMin)
                sMin = psData[ul];
            if (psData[ul] > sMax)
                sMax = psData[ul];
        }

        // If we're clipping at all then claim that we've maxed out.
        // Some sound cards have bad DC offsets
        *pulLevel = ((sMax >= 0x7F00) || (sMin <= -0x7F00)) ? 0xFFFF : (ULONG) (sMax - sMin);
        *pulLevel = (*pulLevel * 100) / 0xFFFF;
    }
    else if(pWaveFormatEx->wBitsPerSample == 8)
    {
        unsigned char *psData = (unsigned char*) (m_Header.lpData);

        unsigned char sMin, sMax;
        sMin = sMax = psData[0];
        for (ULONG ul = 0; ul < ulData; ul++) {
            if (psData[ul] < sMin)
                sMin = psData[ul];
            if (psData[ul] > sMax)
                sMax = psData[ul];
        }

        // If we're clipping at all then claim that we've maxed out.
        // Some sound cards have bad DC offsets
        *pulLevel = ((sMax >= 0xFF) || (sMin <= 0x00)) ? 0xFF : (ULONG) (sMax - sMin);
        *pulLevel = (*pulLevel * 100) / 0xFF;
    }
    else
    {
        *pulLevel = 0;
        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\cfggrammar.cpp ===
/*******************************************************************************
* CFGGrammar.cpp *
*--------------*
*   Description:
*-------------------------------------------------------------------------------
*  Created By: RAL
*  Copyright (C) 1998, 1999 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/

#include "stdafx.h"
#include "CFGEngine.h"
#include "CFGGrammar.h"

/////////////////////////////////////////////////////////////////////////////
//

/****************************************************************************
* CBaseGrammar::CBaseGrammar *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/
 
CBaseGrammar::CBaseGrammar()
{
    SPDBG_FUNC("CBaseGrammar::CBaseGrammar");
    m_LoadedType = Uninitialized;
    m_InLoadType = Uninitialized;
    m_eGrammarState = SPGS_ENABLED;
    m_hFile = INVALID_HANDLE_VALUE;
    m_hMapFile = NULL;
    m_pData = NULL;      // If this is non-null then if m_hFile != INVALID_HANDLE_VALUE then we allocated the memory
    memset(&m_clsidGrammar, 0, sizeof(m_clsidGrammar));
    m_hInstanceModule = NULL;
}

/****************************************************************************
* CBaseGrammar::~CBaseGrammar *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

CBaseGrammar::~CBaseGrammar()
{
    Clear();
}

/****************************************************************************
* CBaseGrammar::Clear *
*---------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CBaseGrammar::Clear()
{
    SPDBG_FUNC("CBaseGrammar::Clear");

    if (m_LoadedType == File)
    {
        ::UnmapViewOfFile(m_pData);
        ::CloseHandle(m_hMapFile);
        ::CloseHandle(m_hFile);
        m_hMapFile = NULL;
        m_hFile = INVALID_HANDLE_VALUE;
    }
    if (m_LoadedType == Memory)
    {
        delete[] m_pData;
        m_pData = NULL;
    }
    if (m_hInstanceModule)
    {
        ::FreeLibrary(m_hInstanceModule);
        m_hInstanceModule = NULL;
    }
    memset(&m_clsidGrammar, 0, sizeof(m_clsidGrammar));
    m_cpInterpreter.Release();

    m_LoadedType = Uninitialized;
}



/****************************************************************************
* CBaseGrammar::InitFromMemory *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CBaseGrammar::InitFromMemory(const SPCFGSERIALIZEDHEADER * pSerializedHeader, const WCHAR *pszGrammarName)
{
    SPDBG_FUNC("CBaseGrammar::InitFromMemory");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(m_LoadedType == Uninitialized);

    ULONG cb = pSerializedHeader->ulTotalSerializedSize;
    m_dstrGrammarName = pszGrammarName;
    m_pData = new BYTE[cb];
    if (m_pData)
    {
        memcpy(m_pData, pSerializedHeader, cb);
        m_LoadedType = Memory;
        hr = CompleteLoad();
        if (FAILED(hr))
        {
            m_LoadedType = Uninitialized;
            delete [] m_pData;
            m_pData = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}


/****************************************************************************
* CBaseGrammar::InitFromFile *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CBaseGrammar::InitFromFile(const WCHAR * pszGrammarName)
{
    SPDBG_FUNC("CBaseGrammar::InitFromFile");
    HRESULT hr = S_OK;

    SPDBG_ASSERT(m_LoadedType == Uninitialized);

    m_LoadedType = File;    // Assume it will work!

#ifdef _WIN32_WCE
    m_hFile = g_Unicode.CreateFileForMapping(pszGrammarName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
#else
    m_hFile = g_Unicode.CreateFile(pszGrammarName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
#endif

    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        m_hMapFile = ::CreateFileMapping(m_hFile, NULL, PAGE_READONLY, 0, 0, NULL);
        if (m_hMapFile)
        {
            m_pData = (BYTE *)::MapViewOfFile(m_hMapFile, FILE_MAP_READ, 0, 0, 0);
        }
    }
    if (m_pData == NULL)
    {
        hr = SpHrFromLastWin32Error();
    }
    else
    {
        m_dstrGrammarName.Append2(L"file://", pszGrammarName);
        if (m_dstrGrammarName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = CompleteLoad();
        }
    }
    if (FAILED(hr))
    {
        m_LoadedType = Uninitialized;
        m_dstrGrammarName.Clear();
        if (m_pData)
        {
            ::UnmapViewOfFile(m_pData);
            m_pData = NULL;
        }
        if (m_hMapFile) 
        {
            ::CloseHandle(m_hMapFile);
            m_hMapFile = NULL;
        }
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            ::CloseHandle(m_hFile);
            m_hFile = INVALID_HANDLE_VALUE;
        }
    }
    return hr;
}

/****************************************************************************
* CBaseGrammar::InitFromResource *
*-------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CBaseGrammar::InitFromResource(const WCHAR * pszModuleName,
                                      const WCHAR * pszResourceName,
                                      const WCHAR * pszResourceType,
                                      WORD wLanguage)

{
    SPDBG_FUNC("CBaseGrammar::InitFromResource");
    HRESULT hr = S_OK;

    m_LoadedType = Resource;
    m_wResLanguage = wLanguage;

#ifdef _WIN32_WCE
    // CAUTION!!!
    // Dont use LoadLibraryEx on WinCE. It compiles and links on Cedar but ends up corrupting the stack
    m_hInstanceModule = g_Unicode.LoadLibrary(pszModuleName);
#else
    m_hInstanceModule = g_Unicode.LoadLibraryEx(pszModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE);
#endif
    if (m_hInstanceModule)
    {
        m_dstrModuleName = pszModuleName;
#ifdef _WIN32_WCE
        // FindResourceEx is not supported in CE. So just use FindResource. That means in the module
        // the resources have to be uniquely named across LCIDs.
        HRSRC hResInfo = g_Unicode.FindResource(m_hInstanceModule, pszResourceName, pszResourceType);
#else
        HRSRC hResInfo = g_Unicode.FindResourceEx(m_hInstanceModule, pszResourceType, pszResourceName, wLanguage);
#endif
        if (hResInfo)
        {
            WCHAR temp[16];
            m_dstrGrammarName.Append2(L"res://", pszModuleName);
            if (HIWORD(pszResourceType))
            {
                m_dstrGrammarName.Append2(L"/", pszResourceType);
                m_dstrResourceType = pszResourceType;
                m_ResIdType = 0;
            }
            else
            {
                m_ResIdType = LOWORD(pszResourceType);
                swprintf(temp, L"/%i", m_ResIdType);
                m_dstrGrammarName.Append(temp);
            }
            if (HIWORD(pszResourceName))
            {
                m_dstrGrammarName.Append2(L"#", pszResourceName);
                m_ResIdName = 0;
            }
            else
            {
                m_ResIdName = LOWORD(pszResourceName);
                swprintf(temp, L"#%i", m_ResIdName);
                m_dstrGrammarName.Append(temp);
            }

            HGLOBAL hData = ::LoadResource(m_hInstanceModule, hResInfo);
            if (hData)
            {
                m_pData = (BYTE *)::LockResource(hData);
            }
        }
    }
    if (m_pData == NULL)
    {
        hr = SpHrFromLastWin32Error();
    }
    else
    {
        hr = CompleteLoad();
    }
    if (FAILED(hr))
    {
        m_LoadedType = Uninitialized;
        if (m_hInstanceModule)
        {
            ::FreeLibrary(m_hInstanceModule);
            m_hInstanceModule = NULL;
        }
    }

    return hr;
}

/****************************************************************************
* CBaseGrammar::InitFromCLSID *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CBaseGrammar::InitFromCLSID(REFCLSID rcid, const WCHAR * pszGrammarName)
{
    SPDBG_FUNC("CBaseGrammar::InitFromCLSID");
    HRESULT hr = S_OK;

    hr = m_cpInterpreter.CoCreateInstance(rcid);
    if (SUCCEEDED(hr))
    {
        hr = m_cpInterpreter->InitGrammar(pszGrammarName, (const void **)&m_pData);
    }
    if (SUCCEEDED(hr) && pszGrammarName)
    {
        m_dstrGrammarName = pszGrammarName;
        if (m_dstrGrammarName == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_InLoadType = Object;
        hr = CompleteLoad();
    }
    if (SUCCEEDED(hr))
    {
        m_LoadedType = Object;
    }
    else
    {
        m_cpInterpreter.Release();
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// 

/****************************************************************************
* CCFGGrammar::FinalConstruct *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CCFGGrammar::FinalConstruct()
{
    SPDBG_FUNC("CCFGGrammar::FinalConstruct");
    HRESULT hr = S_OK;

    m_pReplacementData = NULL;
    m_pEngine = NULL;
    m_pRuleTable = NULL;
    m_cNonImportRules = 0;
    m_cTopLevelRules = 0;
    m_fLoading = false;
    m_ulDictationTags = 0;
    m_IndexToWordHandle = NULL;
    m_pvOwnerCookie = NULL;
    m_pvClientCookie = NULL;
    memset( &m_Header, 0, sizeof( m_Header ) );
    return hr;
}
/****************************************************************************
* CCFGGrammar::BasicInit *
*------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CCFGGrammar::BasicInit(ULONG ulGrammarID, CCFGEngine * pEngine)
{
    SPDBG_FUNC("CCFGGrammar::BasicInit");
    m_ulGrammarID = ulGrammarID;
    m_pEngine = pEngine;
    m_pEngine->AddRef();
}


/****************************************************************************
* CCFGGrammar::FinalRelease *
*---------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

void CCFGGrammar::FinalRelease()
{
    SPDBG_FUNC("CCFGGrammar::FinalRelease");
    // tell CFGEngine to remove words from this grammar

    if (m_pRuleTable)
    {
		for (ULONG i = 0; i < m_Header.cRules; i++)
		{
			if (m_pRuleTable[i].fEngineActive)
			{
				m_pEngine->DeactivateRule(m_ulGrammarID, i);
				m_pRuleTable[i].fEngineActive = FALSE;
			}
		}
	}

    if (m_pEngine)
    {
        if (m_LoadedType != Uninitialized)
        {
            m_pEngine->RemoveRules(this);
            m_pEngine->RemoveWords(this);
        }

        m_pEngine->RemoveGrammar(m_ulGrammarID);
        m_pEngine->Release();
    }

    if (m_pRuleTable)
    {
        for (ULONG i = 0; i < m_Header.cRules; i++)
        {
            if (m_pRuleTable[i].pRefGrammar && m_pRuleTable[i].pRefGrammar != this)
            {
                m_pRuleTable[i].pRefGrammar->Release();
            }
        }
        delete[] m_pRuleTable;
    }

    if (m_IndexToWordHandle)
    {
        delete[] m_IndexToWordHandle;
    }
    if (m_pReplacementData)
    {
        delete[] m_pReplacementData;
    }
}


/****************************************************************************
* CCFGGrammar::CompleteLoad *
*---------------------------*
*   Description:
*       NOTE:  This function assumes that the m_LoadedType is set by the caller
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CCFGGrammar::CompleteLoad()
{
    SPDBG_FUNC("CCFGGrammar::CompleteLoad");
    HRESULT hr = S_OK;

    m_fLoading = true;
    m_pEngine->m_cLoadsInProgress++;

    //
    //  If the m_cpInterpreter is NULL then just set it to the engine.  If we're being
    //  loaded from an object, it will already be set.
    //
    if (!m_cpInterpreter)
    {
        m_cpInterpreter = m_pEngine;
    }

    hr = SpConvertCFGHeader((SPCFGSERIALIZEDHEADER *)m_pData, &m_Header);
    if (SUCCEEDED(hr))
    {
        //
        //  Now see if the language ID matches the supported languages.  

        // We would like to set the langid of the words to be what they 
        // are in the grammar (pGrammar->m_Header.LangID), but WordStringBlob can't
        // handle words with different langids.
        // So if multiple grammars get loaded we will fail if the langids are inconsistent.
        // If the langids match on primary language and the engine has specified it can
        // handle all secondary languages then we will succeed and tell the engine that
        // all words have the same langid as the first grammar loaded.

        if(m_pEngine->m_CurLangID)
        {
            // Already specified a current language
            if(m_Header.LangID != m_pEngine->m_CurLangID)
            {
                // New grammar id is different - see if there is a conflict
                hr = SPERR_LANGID_MISMATCH;
                for (ULONG i = 0; SPERR_LANGID_MISMATCH == hr && i < m_pEngine->m_cLangIDs; i++)
                {
                    if (PRIMARYLANGID(m_pEngine->m_aLangIDs[i]) == PRIMARYLANGID(m_Header.LangID) && 
                        PRIMARYLANGID(m_pEngine->m_aLangIDs[i]) == PRIMARYLANGID(m_pEngine->m_CurLangID) && 
                        SUBLANGID(m_pEngine->m_aLangIDs[i]) == SUBLANG_NEUTRAL)
                    {
                        hr = S_OK;
                    }
                }
            }
        }
        else
        {
            // No language currently specified
            if (m_pEngine->m_cLangIDs == 0)
            {
                // Engine didn't list any supported languages. Always succeed.
                m_pEngine->m_CurLangID = m_Header.LangID;
            }
            else
            {
                // See if there is an exact match
                hr = SPERR_LANGID_MISMATCH;
                for (ULONG i = 0; SPERR_LANGID_MISMATCH == hr && i < m_pEngine->m_cLangIDs; i++)
                {
                    if (m_pEngine->m_aLangIDs[i] == m_Header.LangID)
                    {
                        m_pEngine->m_CurLangID = m_Header.LangID;
                        hr = S_OK;
                    }
                }

                // Else see if there is a 'fuzzy' match based on primary id
                LANGID LangEngine = 0;
                bool fPrimaryMatch = false;
                for (ULONG i = 0; SPERR_LANGID_MISMATCH == hr && i < m_pEngine->m_cLangIDs; i++)
                {
                    if (PRIMARYLANGID(m_pEngine->m_aLangIDs[i]) == PRIMARYLANGID(m_Header.LangID))
                    {
                        if (SUBLANGID(m_pEngine->m_aLangIDs[i]) == SUBLANG_NEUTRAL)
                        {
                            fPrimaryMatch = true;
                        }
                        else
                        {
                            if(!LangEngine)
                            {
                                LangEngine = m_pEngine->m_aLangIDs[i];
                            }
                        }

                        if(fPrimaryMatch && LangEngine)
                        {
                            m_pEngine->m_CurLangID = LangEngine;
                            hr = S_OK;
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = AllocateArray(&m_pRuleTable, m_Header.cRules);
        }
        if (SUCCEEDED(hr))
        {
            //
            //  Deal with imports
            //
            for (ULONG i = 0; SUCCEEDED(hr) && i < m_Header.cRules; i++)
            {
                if (m_Header.pRules[i].fImport)
                {
                    hr = ImportRule(i);
                }
                else
                {
                    m_pRuleTable[i].pRefGrammar = this;
                    m_pRuleTable[i].ulGrammarRuleIndex = i;
                    m_pRuleTable[i].fDynamic = m_Header.pRules[i].fDynamic;
                    m_pRuleTable[i].fEngineActive = FALSE; // NOT m_Header.pRules[i].fDefaultActive -- use CComPtr<ISpCFGGrammar>::ActivateRule(NULL, SPRIF_ACTIVATE);
                    m_pRuleTable[i].fAppActive = FALSE;
                    m_pRuleTable[i].fAutoPause = FALSE;
                    m_pRuleTable[i].pvClientContext = NULL;
                    m_pRuleTable[i].eCacheStatus = CACHE_VOID;
                    m_pRuleTable[i].pFirstList   = NULL;
                }
            }
            //
            //  In the case of failure, DO NOT free the m_pRuleTable, let the cleanup
            //  code in FinalRelease() do it.  It will release references to 
            //  
        }
        if (SUCCEEDED(hr))
        {
            m_ulDictationTags = 0;
            for(ULONG nArc = 0; nArc < m_Header.cArcs; nArc++)
            {
                if (m_Header.pArcs[nArc].TransitionIndex == SPDICTATIONTRANSITION)
                {
                    m_ulDictationTags++;
                }
            }
        }

    }

    m_fLoading = false;
    m_pEngine->m_cLoadsInProgress--;

    if (SUCCEEDED(hr))
    {
        hr = m_pEngine->AddWords(this, 0, 0);
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pEngine->AddRules(this, 0);
        if (FAILED(hr))
        {
            m_pEngine->RemoveWords(this);       // ignore HRESULT since we already have a failure!            
        }
    }
    return hr;
}

/****************************************************************************
* CCFGGrammar::_FindRuleIndexByID *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAP ***/
HRESULT CCFGGrammar::_FindRuleIndexByID(DWORD dwRuleId, ULONG *pulRuleIndex)
{
    SPDBG_ASSERT(pulRuleIndex);
    
    for (ULONG i = 0; i < m_Header.cRules; i++)
    {
        const SPCFGRULE * pRule = m_Header.pRules + i;

        if (pRule->RuleId == dwRuleId)
        {
            *pulRuleIndex = i;
            return S_OK;
        }
    }
    return S_FALSE;
}

/****************************************************************************
* CCFGGrammar::_FindRuleIndexByName *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAP ***/
HRESULT CCFGGrammar::_FindRuleIndexByName(const WCHAR * pszRuleName, ULONG *pulRuleIndex)
{
    SPDBG_ASSERT(pulRuleIndex);
    for (ULONG i = 0; i < m_Header.cRules; i++)
    {
        const SPCFGRULE * pRule = m_Header.pRules + i;

        if (_wcsicmp(pszRuleName, &m_Header.pszSymbols[pRule->NameSymbolOffset]) == 0)
        {
            *pulRuleIndex = i;
            return S_OK;
        }
    }
    return S_FALSE;
}

/****************************************************************************
* CCFGGrammar::_FindRuleIndexByNameAndID *
*----------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAP ***/
HRESULT CCFGGrammar::_FindRuleIndexByNameAndID( const WCHAR * pszRuleName, DWORD dwRuleId, ULONG * pulRuleIndex )
{
    SPDBG_ASSERT( pulRuleIndex );
    HRESULT hr = S_OK;
    ULONG ulName;
    ULONG ulID;

    if (S_OK != _FindRuleIndexByName( pszRuleName, &ulName ) ||
        S_OK != _FindRuleIndexByID( dwRuleId, &ulID ) ||
        ulName != ulID )
    {
        hr = SPERR_RULE_NAME_ID_CONFLICT;
    }
    else
    {
        *pulRuleIndex = ulName;
    }
    return hr;
}


/****************************************************************************
* CCFGGrammar::ActivateRule *
*---------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAP ***/

STDMETHODIMP CCFGGrammar::ActivateRule(const WCHAR * pszRuleName, DWORD dwRuleId, SPRULESTATE NewState, ULONG * pulRulesActivated)
{
    SPAUTO_OBJ_LOCK;
    HRESULT hr = S_OK;
    ULONG cnt = 0;

    if( NewState == SPRS_INACTIVE )
    {
        return E_INVALIDARG;
    }

    if (pszRuleName == NULL && dwRuleId == 0)
    {
        BOOL fFoundTopLevel = false;
        BYTE * pfActivated = STACK_ALLOC_AND_ZERO(BYTE, m_Header.cRules);
        const BOOL fAutoPause = (NewState == SPRS_ACTIVE_WITH_AUTO_PAUSE);
        for (ULONG i = 0; hr == S_OK && i < m_Header.cRules; i++)
        {
            const SPCFGRULE * pRule = m_Header.pRules + i;
            if (pRule->fTopLevel)
            {
                fFoundTopLevel = true;
                m_pRuleTable[i].fAutoPause = fAutoPause;
                if (pRule->fDefaultActive && (!m_pRuleTable[i].fAppActive))
                {
                    if (m_eGrammarState == SPGS_ENABLED)
                    {
                        SPDBG_ASSERT(!m_pRuleTable[i].fEngineActive);
                        hr = m_pEngine->ActivateRule(this, i);
                    }
                    if (hr == S_OK)
                    {
                        m_pRuleTable[i].fAppActive = TRUE;
                        cnt++;
                        pfActivated[i] = true;
                    }
                }
            }
        }
        //
        //  If we fail for some reason, back out anything we have activated already...
        //
        if (hr == S_OK)
        {
            if (!fFoundTopLevel)
            {
                hr = SPERR_NOT_TOPLEVEL_RULE;
            }
        }
        else
        {
            // This can only fail in the case where m_eGrammarState == ENABLED since this is the 
            // only place we call the engine.
            SPDBG_ASSERT(m_eGrammarState == SPGS_ENABLED);
            for (ULONG j = 0; j < i; j++)
            {
                if (pfActivated[j])
                {
                    SPDBG_ASSERT(m_pRuleTable[j].fEngineActive);
                    m_pEngine->DeactivateRule(this->m_ulGrammarID, j);
                    m_pRuleTable[j].fAppActive = FALSE;
                }
            }
            cnt = 0;
        }
    }
    else
    {

        ULONG ulRuleIndex;

        if( pszRuleName  && SP_IS_BAD_STRING_PTR( pszRuleName ) )
        {
            hr = E_INVALIDARG;
        }
        else if( dwRuleId && pszRuleName )
        {
            hr = _FindRuleIndexByNameAndID( pszRuleName, dwRuleId, &ulRuleIndex );
        }
        else if( pszRuleName )
        {
            hr = _FindRuleIndexByName(pszRuleName, &ulRuleIndex);
        }
        else
        {
            hr = _FindRuleIndexByID(dwRuleId, &ulRuleIndex);
        }

        if (hr == S_OK)
        {
            const SPCFGRULE * pRule = m_Header.pRules + ulRuleIndex;
            if (pRule->fTopLevel)
            {
                m_pRuleTable[ulRuleIndex].fAutoPause = (NewState == SPRS_ACTIVE_WITH_AUTO_PAUSE);
                if (!m_pRuleTable[ulRuleIndex].fAppActive)
                {
                    if (m_eGrammarState == SPGS_ENABLED)
                    {
                        SPDBG_ASSERT(!m_pRuleTable[ulRuleIndex].fEngineActive);
                        hr = m_pEngine->ActivateRule(this, ulRuleIndex);
                    }
                    if (hr == S_OK)
                    {
                        m_pRuleTable[ulRuleIndex].fAppActive = TRUE;
                        cnt++;
                    }
                }
            }
            else
            {
                hr = SPERR_NOT_TOPLEVEL_RULE;
            }
        }
        else if (S_FALSE == hr)
        {
            hr = SPERR_NOT_TOPLEVEL_RULE;
        }
    }
    *pulRulesActivated = cnt;

    return hr;
}

/****************************************************************************
* CCFGGrammar::DeactivateRule *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAP ***/

STDMETHODIMP CCFGGrammar::DeactivateRule(const WCHAR * pszRuleName, DWORD dwRuleId, ULONG * pulRulesDeactivated)
{
    SPAUTO_OBJ_LOCK;
    HRESULT hr = S_OK;
    ULONG cnt = 0;

    if (pszRuleName == NULL && dwRuleId == 0)
    {
        // deactivate all currently active top level rules
        for (ULONG i = 0; i < m_Header.cRules; i++)
        {
            if (m_Header.pRules[i].fTopLevel && m_pRuleTable[i].fAppActive)
            {
                cnt++;
                m_pRuleTable[i].fAppActive = FALSE;
                m_pRuleTable[i].fAutoPause = FALSE;
                if (m_pRuleTable[i].fEngineActive)
                {
                    HRESULT hrEngine = m_pEngine->DeactivateRule(m_ulGrammarID, i);
                    if (hr == S_OK && FAILED(hrEngine))
                    {
                        hr = hrEngine;
                    }
                }
            }
        }
    }
    else
    {
        ULONG ulRuleIndex;

        if( pszRuleName  && SP_IS_BAD_STRING_PTR( pszRuleName ) )
        {
            hr = E_INVALIDARG;
        }
        else if( dwRuleId && pszRuleName )
        {
            hr = _FindRuleIndexByNameAndID( pszRuleName, dwRuleId, &ulRuleIndex );
        }
        else if( pszRuleName )
        {
            hr = _FindRuleIndexByName(pszRuleName, &ulRuleIndex);
        }
        else
        {
            hr = _FindRuleIndexByID(dwRuleId, &ulRuleIndex);
        }

        
        if (hr == S_OK)
        {
            if (m_Header.pRules[ulRuleIndex].fTopLevel)
            {
                if (m_pRuleTable[ulRuleIndex].fAppActive)
                {
                    cnt = 1;
                    m_pRuleTable[ulRuleIndex].fAppActive = FALSE;
                    m_pRuleTable[ulRuleIndex].fAutoPause = FALSE;
                    if (m_pRuleTable[ulRuleIndex].fEngineActive)
                    {
                        hr = m_pEngine->DeactivateRule(m_ulGrammarID, ulRuleIndex);
                    }
                }
            }
            else
            {
                hr = SPERR_NOT_TOPLEVEL_RULE;
            }
        }
    }
    *pulRulesDeactivated = cnt;
    return hr;
}

/****************************************************************************
* CCFGGrammar::SetGrammarState *
*------------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

HRESULT CCFGGrammar::SetGrammarState(SPGRAMMARSTATE eGrammarState)
{
    SPDBG_FUNC("CCFGGrammar::SetGrammarState");
    HRESULT hr = S_OK;

    if (eGrammarState != m_eGrammarState)
    {
        ULONG i;
        switch (eGrammarState)
        {
        case SPGS_ENABLED:
            // restore state of all rules of this grammar
            for (i = 0; i < m_Header.cRules; i++)
            {
                const SPCFGRULE * pRule = m_Header.pRules + i;
                if (pRule->fTopLevel && m_pRuleTable[i].fAppActive)
                {
                    SPDBG_ASSERT(!m_pRuleTable[i].fEngineActive);
                    hr = m_pEngine->ActivateRule(this, i);
                    if (FAILED(hr))
                    {
                        for (ULONG j = 0; j < i; j++)
                        {
                            pRule = m_Header.pRules + j;
                            if (pRule->fTopLevel && m_pRuleTable[j].fEngineActive)
                            {
                                m_pEngine->DeactivateRule(m_ulGrammarID, j);
                            }
                        }
                        break;
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                m_eGrammarState = SPGS_ENABLED;
            }
            break;

        case SPGS_DISABLED:
            // send RuleNotify() for each active rule and remember that the rule 
            // was active before this call
            for (i = 0; i < m_Header.cRules; i++)
            {
                const SPCFGRULE * pRule = m_Header.pRules + i;
                if (pRule->fTopLevel && m_pRuleTable[i].fEngineActive)
                {
                    SPDBG_ASSERT(m_pRuleTable[i].fAppActive);
                    HRESULT hrEngine = m_pEngine->DeactivateRule(m_ulGrammarID, i);
                    if (hr == S_OK && FAILED(hrEngine))
                    {
                        hr = hrEngine;
                    }
                }
            }
            m_eGrammarState = SPGS_DISABLED;
            break;

        case SPGS_EXCLUSIVE:
            SPDBG_ASSERT(TRUE); // Exclusive grammars are implemented by SrRecoInstGrammar, not CFG Engine...
            hr = E_NOTIMPL;
            break;
        }
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}


/****************************************************************************
* CCFGGrammar::ImportRule *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CCFGGrammar::ImportRule(ULONG ulImportRuleIndex)
{
    SPDBG_FUNC("CCFGGrammar::ImportRule");
    HRESULT hr = S_OK;

    //
    //  Import names can have two forms:  GrammarName\Rule for files or resources  OR
    //  Object\Grammar\Rule for global grammars.  Other forms are not allowed.
    //
    CSpDynamicString dstrName(m_Header.pszSymbols + m_Header.pRules[ulImportRuleIndex].NameSymbolOffset);
    CSpDynamicString dstrName2;

    ISpCFGGrammar * pComGramInterface = NULL;
    WCHAR *pszRuleName;
    bool fUseParentDir = false;

    if (dstrName)
    {
        ULONG ulLength = wcslen(dstrName);
        // read the protocol
        if ((ulLength > 12) && !wcsncmp(dstrName,L"SAPI5OBJECT", 11))
        {
            if (dstrName[11] != L':')
            {
                return SPERR_INVALID_IMPORT;
            }
            // now we expect ProgId.ProgId\\RuleName
            WCHAR *pszProgId = dstrName + 12;
            pszRuleName = wcsstr(pszProgId,L"\\\\");
            if (!pszRuleName || (wcslen(pszRuleName) < 3))
            {
                return SPERR_INVALID_IMPORT;
            }
            *pszRuleName = L'\0';
            pszRuleName += 2;
            CLSID clsid;
            if (SUCCEEDED(::CLSIDFromString(pszProgId, &clsid)) ||
                SUCCEEDED(::CLSIDFromProgID(pszProgId, &clsid)))
            {
                hr = m_pEngine->InternalLoadGrammarFromObject(clsid, pszProgId, NULL, NULL, FALSE, &pComGramInterface);
            }
            else
            {
                hr = SPERR_INVALID_IMPORT;
            }
        }
        else if ((ulLength > 4) && !wcsncmp(dstrName,L"URL", 3))
        {
            if (dstrName[3] != L':') // URL:blah
            {
                return SPERR_INVALID_IMPORT;
            }
            // now we expect Protocol://protocol specifics \\RuleName
            WCHAR *pszUrl = dstrName + 4;
            if (pszUrl[0] == 0)
            {
                return SPERR_INVALID_IMPORT;
            }
            WCHAR *pszEndProt = wcsstr(pszUrl, L":"); // e.g. file:// - finds ':' if file:// present
            if (pszEndProt == (pszUrl + 1)) // c:\ with no file://
            {
                pszEndProt = NULL;
            }
            pszRuleName = wcsstr(pszUrl,L"\\\\");
            if (pszRuleName == pszUrl ||         // i.e. \\somename\somedir\somefile\\rulename - found first \\ incorrectly
                pszRuleName == (pszEndProt + 3)) // i.e. file://\\somename\somedir\somefile\\rulename - found first \\ incorrectly.
            {
                pszRuleName = wcsstr(pszRuleName + 2,L"\\\\");
            }
            if (!pszRuleName || !pszEndProt || (wcslen(pszRuleName) < 3) || (wcslen(pszEndProt ) < 4))
            {
                // May need to use fully qualified name from parent grammar to get protocol.
                fUseParentDir = true;
                dstrName2 = m_dstrGrammarName;
                pszUrl = dstrName2;
                if (!pszUrl)
                {
                    return SPERR_INVALID_IMPORT;
                }
                pszEndProt = wcsstr(pszUrl, L":");
                if (pszEndProt)
                {
                    *pszEndProt = 0;
                }
                pszEndProt = dstrName + 4;
                if (!pszRuleName || !pszEndProt || (wcslen(pszRuleName) < 3) || (wcslen(pszEndProt ) < 4))
                {
                    return SPERR_INVALID_IMPORT;
                }
                *pszRuleName = L'\0';
                pszRuleName += 2;
            }
            else
            {
                *pszRuleName = L'\0';
                pszRuleName += 2;
                *pszEndProt = L'\0';
                // wcslen(pszEndProt) before previous line is 4 or more. Not enough. Hence need to explicitly check length again.
                if (wcslen(pszEndProt + 1) > 4 && // file://c: as minimum
                    pszEndProt[4] != L':' && // file://c: format
                    wcsncmp(&pszEndProt[3], L"\\\\", 2) != 0 &&
                    (!wcscmp(pszUrl, L"file") || !wcscmp(pszUrl, L"res"))) // file://\\ format
                {
                    // Need to allow for file://computer/dir/grammar.ext here.
                    // Also res://computer/dir/file/GRAMMAR#ID
                    // Need to not do http://computer/dir & https / ftp etc.
                    // Can't skip over //. Need to skip over the nulled : still however.
                    pszEndProt += 1;
                }
                else
                {
                    // We have the format "file://c:\..." and can skip over the // happily.
                    // Or the format file://\\computer\somedir\somefile
                    // Note pszEndProt points to the : in file://whatever (: has been set to zero).
                    pszEndProt += 3;
                }
                // Note the only support formats for file:// are:
                // file://X:\dir\name
                // file://X:/dir/name
                // file://computer/dir/name
                // file://computer\dir\name
                // file://\\computer\dir\name
                // file://\\computer/dir/name
                // i.e. file://..\something will not work.
                // file://file.cfg will probably work as a side effect. This is unfortunate.
            }
            // find protocol: if it is file:// then LoadCmdFromFile
            //                          res:// then LoadCmdFromResource
            //                otherwise use urlmon
            if (!wcscmp(pszUrl,L"file"))
            {
                hr = m_pEngine->InternalLoadGrammarFromFile(pszEndProt, NULL, NULL, FALSE, &pComGramInterface);
                if (FAILED(hr) && fUseParentDir && wcsrchr(m_dstrGrammarName + 7, L'\\') !=0 )
                {
                    CSpDynamicString dstr = m_dstrGrammarName + 7;
                    *(wcsrchr(dstr, L'\\')+1) = 0;
                    dstr.Append(pszEndProt);
                    hr = m_pEngine->InternalLoadGrammarFromFile(dstr, NULL, NULL, FALSE, &pComGramInterface);
                }
                if (FAILED(hr) && fUseParentDir && wcsrchr(m_dstrGrammarName + 7, L'/') !=0 )
                {
                    CSpDynamicString dstr = m_dstrGrammarName + 7;
                    *(wcsrchr(dstr, L'/')+1) = 0;
                    dstr.Append(pszEndProt);
                    hr = m_pEngine->InternalLoadGrammarFromFile(dstr, NULL, NULL, FALSE, &pComGramInterface);
                }
            }
            else if (!wcscmp(pszUrl,L"res"))
            {
                // the format is res://[resourcedir/]<resource file>[/resource type]#[<resource id> / <resource name>]
                // e.g. res://filedir/filename/SRGRAMMAR#134
                // e.g. res://filedir/filename/SRGRAMMAR           } Equivalent
                // e.g. res://filedir/filename/SRGRAMMAR#SRGRAMMAR }
                // e.g. res://filedir/filename/SRGRAMMAR#GRAMMAR1  // Named resource rather than ID.
                WCHAR *pszResourceType = NULL;
                WCHAR *pszResourceId = NULL;
                long lResourceId = 0;

                WCHAR *pszRes = wcsrchr(pszEndProt, L'/');
                if (pszRes)
                {
                    *pszRes = L'\0';
                    pszRes++;
                }
                else
                {
                    // Must have trailing /GRAMMARTYPE as a minimum.
                    // This minimum is equivalent to /GRAMMARTYPE#GRAMMARTYPE
                    hr = SPERR_INVALID_IMPORT;
                }
                if (SUCCEEDED(hr))
                {
                    WCHAR *pszHash = wcschr(pszRes,L'#');
                    if (pszHash)
                    {
                        *pszHash = L'\0';
                        pszHash++;
                        pszResourceType = pszRes;
                        pszResourceId = pszHash;
                    }
                    else
                    {
                        // Must have trailing /GRAMMARTYPE as a minimum.
                        // This minimum is equivalent to /GRAMMARTYPE#GRAMMARTYPE
                        pszResourceId = pszRes;
                    }

                    if (pszResourceId[0] >= L'0' && pszResourceId[0] <= L'9')
                    {
                        // If the #[0-9] assume we have numeric resource id.
                        // Otherwise we assume we have a named resource.
                        lResourceId = _wtol(&pszResourceId[0]);
                    }
                }
                if (SUCCEEDED(hr) && pszResourceId)
                {
                    hr = m_pEngine->InternalLoadGrammarFromResource(pszEndProt, lResourceId ? MAKEINTRESOURCEW(lResourceId) : pszResourceId, 
                                                                    pszResourceType, MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL), NULL, NULL, FALSE, 
                                                                    &pComGramInterface);
                    if (FAILED(hr) && fUseParentDir && wcsrchr(m_dstrGrammarName + 6, L'/') !=0 )
                    {
                        CSpDynamicString dstr = m_dstrGrammarName + 6;
                        *(wcsrchr(dstr, L'/')) = 0;
                        hr = m_pEngine->InternalLoadGrammarFromResource(dstr, lResourceId ? MAKEINTRESOURCEW(lResourceId) : pszResourceId, 
                                                                        pszResourceType, MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL), NULL, NULL, FALSE, 
                                                                        &pComGramInterface);
                    }
                    // Don't need to test for L'\\' form as lacking a L'/' means the parent didn't have a correctly specified resource and
                    // hence we would never get here (or have a valid parent to attempt to use).
                }
                else
                {
                    hr = SPERR_INVALID_IMPORT;
                }
            }
            else
            {
                // assume it is another URL protocol that URL Moniker is going to deal with
                IStream *pStream;
                HRESULT hr1 = S_OK;
                char *pBuffer = NULL;
                DWORD dwGot;
                CSpDynamicString dstrURL;
                dstrURL.Append2(pszUrl,L"://");
                dstrURL.Append(pszEndProt);

                SPCFGSERIALIZEDHEADER SerialHeader;

                hr = URLOpenBlockingStreamW( 0, dstrURL, &pStream, 0, 0);
                if (FAILED(hr) && fUseParentDir && wcsrchr(m_dstrGrammarName, L'/') !=0 )
                {
                    dstrURL.Clear();
                    dstrURL = m_dstrGrammarName;
                    *(wcsrchr(dstrURL, L'/')+1) = 0;
                    dstrURL.Append(pszEndProt);
                    hr = URLOpenBlockingStreamW( 0, dstrURL, &pStream, 0, 0);
                }
                if (FAILED(hr) && fUseParentDir && wcsrchr(m_dstrGrammarName, L'\\') !=0 )
                {
                    dstrURL.Clear();
                    dstrURL = m_dstrGrammarName;
                    *(wcsrchr(dstrURL, L'\\')+1) = 0;
                    dstrURL.Append(pszEndProt);
                    hr = URLOpenBlockingStreamW( 0, dstrURL, &pStream, 0, 0);
                }

                if (SUCCEEDED(hr))
                {
                    //
                    //  If the extension of the file is ".xml" then attempt to compile it
                    //
                    ULONG cch = wcslen(dstrURL);
                    if (cch > 4 && _wcsicmp(dstrURL + cch - 4, L".xml") == 0)
                    {
                        CComPtr<IStream> cpDestMemStream;
                        CComPtr<ISpGrammarCompiler> m_cpCompiler;
            
                        hr = ::CreateStreamOnHGlobal(NULL, TRUE, &cpDestMemStream);
                        if (SUCCEEDED(hr))
                        {
                            hr = m_cpCompiler.CoCreateInstance(CLSID_SpGrammarCompiler);
                        }
                        if (SUCCEEDED(hr))
                        {
                            hr = m_cpCompiler->CompileStream(pStream, cpDestMemStream, NULL, NULL, NULL, 0);
                        }
                        if (SUCCEEDED(hr))
                        {
                            HGLOBAL hGlobal;
                            hr = ::GetHGlobalFromStream(cpDestMemStream, &hGlobal);
                            if (SUCCEEDED(hr))
                            {
#ifndef _WIN32_WCE
                                SPCFGSERIALIZEDHEADER * pBinaryData = (SPCFGSERIALIZEDHEADER * )::GlobalLock(hGlobal);
#else
                                SPCFGSERIALIZEDHEADER * pBinaryData = (SPCFGSERIALIZEDHEADER * )GlobalLock(hGlobal);
#endif // _WIN32_WCE
                                if (pBinaryData)
                                {
                                    hr = m_pEngine->InternalLoadGrammarFromMemory((const SPCFGSERIALIZEDHEADER*)pBinaryData, NULL, NULL, FALSE, &pComGramInterface, dstrURL);
#ifndef _WIN32_WCE
                                    ::GlobalUnlock(hGlobal);
#else
                                    GlobalUnlock(hGlobal);
#endif // _WIN32_WCE
                                }
                            }
                        }
                        if (FAILED(hr))
                        {
                            hr = SPERR_INVALID_IMPORT;
                        }
                    }
                    else
                    {
                        hr = pStream->Read( &SerialHeader, sizeof(SerialHeader), &dwGot);
                        if (SUCCEEDED(hr))
                        {
                            if (dwGot == sizeof(SerialHeader))
                            {
                                pBuffer = (char*) malloc(SerialHeader.ulTotalSerializedSize*sizeof(char));
                                if (!pBuffer)
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                hr = SPERR_INVALID_IMPORT;
                            }
                            if (pBuffer)
                            {
                                memcpy(pBuffer, &SerialHeader, sizeof(SerialHeader));
                                hr = pStream->Read(pBuffer+sizeof(SerialHeader), SerialHeader.ulTotalSerializedSize - sizeof(SerialHeader), &dwGot);
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            hr = m_pEngine->InternalLoadGrammarFromMemory((const SPCFGSERIALIZEDHEADER*)pBuffer, NULL, NULL, FALSE, &pComGramInterface, dstrURL);
                            free(pBuffer);
                        }
                    }
                }
            }
        }
        else
        {
            hr = SPERR_INVALID_IMPORT;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    //
    //  Now we've found the grammar, so find the rule
    //
    if (SUCCEEDED(hr))
    {
        hr = SPERR_INVALID_IMPORT;  // Assume we won't find it.
        CCFGGrammar * pRefGrammar = static_cast<CCFGGrammar *>(pComGramInterface);
        for (ULONG i = 0; i < pRefGrammar->m_Header.cRules; i++)
        {
            if (pRefGrammar->m_Header.pRules[i].fExport &&
                _wcsicmp(pszRuleName, pRefGrammar->RuleName(i)) == 0)
            {
                m_pRuleTable[ulImportRuleIndex].pRefGrammar = pRefGrammar;
                m_pRuleTable[ulImportRuleIndex].ulGrammarRuleIndex = i;
                m_pRuleTable[ulImportRuleIndex].eCacheStatus = CACHE_VOID;
                m_pRuleTable[ulImportRuleIndex].pFirstList   = NULL;
                hr = S_OK;
                break;
            }
        }
        if (FAILED(hr))
        {
            pRefGrammar->Release();
        }
    }
#ifdef _DEBUG
    if (FAILED(hr))
    {
        USES_CONVERSION;
        SPDBG_DMSG0("Failed to import a rule.\n");
        if (m_dstrGrammarName)
        {
            SPDBG_DMSG1("Importing grammar: %s.\n", W2T(m_dstrGrammarName));
        }
        CSpDynamicString dstr(m_Header.pszSymbols + m_Header.pRules[ulImportRuleIndex].NameSymbolOffset);
        if (dstr)
        {
            SPDBG_DMSG1("Imported grammar: %s.\n", W2T(dstr));
        }
        if (pszRuleName)
        {
            SPDBG_DMSG1("Rule name : %s.\n", W2T(pszRuleName));
        }
    }
#endif

    return hr;
}


/****************************************************************************
* CCFGGrammar::IsEqualResource *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

BOOL CCFGGrammar::IsEqualResource(const WCHAR * pszModuleName,
                                  const WCHAR * pszResourceName,
                                  const WCHAR * pszResourceType,
                                  WORD wLanguage)
{
    SPDBG_FUNC("CCFGGrammar::IsEqualResouce");
    if (m_LoadedType != Resource ||
        _wcsicmp(pszModuleName, m_dstrModuleName) != 0 ||
        wLanguage != m_wResLanguage)
    {
        return FALSE;
    }
    if (HIWORD(pszResourceName))
    {
        if (m_ResIdName || _wcsicmp(pszResourceName, m_dstrGrammarName) != 0)
        {
            return FALSE;
        }
    }
    else
    {
        if (LOWORD(pszResourceName) != m_ResIdName)
        {
            return FALSE;
        }
    }
    if (HIWORD(pszResourceType))
    {
        if (m_ResIdType || _wcsicmp(pszResourceType, m_dstrResourceType) != 0)
        {
            return FALSE;
        }
    }
    else
    {
        if (m_dstrResourceType.m_psz || LOWORD(pszResourceType) != m_ResIdType)
        {
            return FALSE;
        }
    }
    return TRUE;
}

/****************************************************************************
* CCFGGrammar::IsEqualFile *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

BOOL CCFGGrammar::IsEqualFile(const WCHAR * pszFileName)
{
    return (m_LoadedType == File && (wcscmp(m_dstrGrammarName, pszFileName) == 0));
}

/****************************************************************************
* CCFGGrammar::IsEqualObject *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

BOOL CCFGGrammar::IsEqualObject(REFCLSID rcid, const WCHAR * pszGrammarName)
{
    return (((m_LoadedType == Object) || (m_InLoadType == Object)) && (wcscmp(m_dstrGrammarName, pszGrammarName) == 0));
}



/****************************************************************************
* CCFGGrammar::InternalReload *
*---------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CCFGGrammar::InternalReload( const SPBINARYGRAMMAR * pBinaryData )
{
    SPDBG_FUNC("CCFGGrammar::InternalReload");
    HRESULT hr;

    ULONG cOldWords = m_Header.cWords;
    ULONG cchOldWords = m_Header.cchWords;
    ULONG cOldRules = m_Header.cRules;

    //
    // Load the new header.
    //
    SPCFGSERIALIZEDHEADER * pSerializedHeader = (SPCFGSERIALIZEDHEADER *) pBinaryData;
    ULONG cb = pSerializedHeader->ulTotalSerializedSize;
    BYTE * pReplace = new BYTE[cb];

    if (pReplace)
    {
        memcpy(pReplace, pSerializedHeader, cb);
        hr = SpConvertCFGHeader((SPCFGSERIALIZEDHEADER *)pReplace, &m_Header);
        m_pReplacementData = pReplace;
        if (SUCCEEDED(hr) && m_LoadedType == Memory)
        {
            m_pData = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    // If there are any new words or rules add them
    if (SUCCEEDED(hr) && cchOldWords < m_Header.cchWords)
    {
        hr = m_pEngine->AddWords(this, cOldWords, cchOldWords);
    }

    // If there are new rules allocate space for them.
    if (SUCCEEDED(hr) && cOldRules < m_Header.cRules)
    {
        hr = CopyAndExpandArray(&m_pRuleTable, cOldRules, &m_pRuleTable, m_Header.cRules);
        if (SUCCEEDED(hr))
        {
            for (ULONG i = cOldRules; i < m_Header.cRules; i++)
            {
                m_pRuleTable[i].ulGrammarRuleIndex = i;
                m_pRuleTable[i].pRefGrammar     = this;
                m_pRuleTable[i].fEngineActive   = FALSE;    //pRule->fDefaultActive;
                m_pRuleTable[i].fAppActive      = FALSE;
                m_pRuleTable[i].fAutoPause      = FALSE;
                m_pRuleTable[i].pvClientContext = NULL;
                m_pRuleTable[i].fDynamic        = TRUE;     // additional rules have to be dynamic in a reload

                m_pRuleTable[i].eCacheStatus    = CACHE_VOID;
                m_pRuleTable[i].pFirstList      = NULL;
            }
        }        
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pEngine->AddRules(this, cOldRules);
    }

    // Now invalidate any rules which have changed
    if (SUCCEEDED(hr) && m_pEngine->m_pClient && cOldRules)
    {
        SPRULEENTRY * ahRule = STACK_ALLOC(SPRULEENTRY, cOldRules);
        for (ULONG i = 0, cDirtyDynamic = 0; i < cOldRules; i++)
        {
            if (m_pRuleTable[i].fDynamic && (m_Header.pRules[i].fDirtyRule || (cDirtyDynamic > 0)))
            {
                ahRule[cDirtyDynamic].hRule = CRuleHandle(this, i);
                ahRule[cDirtyDynamic].pvClientRuleContext = m_pRuleTable[i].pvClientContext;
                ahRule[cDirtyDynamic].pvClientGrammarContext = this->m_pvClientCookie;
                ULONG Attrib = 0;
                if (m_Header.pRules[i].fTopLevel)
                {
                    Attrib |= SPRAF_TopLevel;
                }
                if (m_pRuleTable[i].fEngineActive)
                {
                    Attrib |= SPRAF_Active;
                }
                if (m_Header.pRules[i].fPropRule)
                {
                    Attrib |= SPRAF_Interpreter;
                }
                ahRule[cDirtyDynamic].Attributes = Attrib;
                cDirtyDynamic++;
            }
        }
        if (cDirtyDynamic> 0)
        {
            hr = m_pEngine->m_pClient->RuleNotify(SPCFGN_INVALIDATE, cDirtyDynamic, ahRule);
        }
    }

        
    return hr;
}


/****************************************************************************
* CCFGGrammar::Reload *
*---------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CCFGGrammar::Reload(const SPBINARYGRAMMAR *pBinaryData)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGGrammar::Reload");
    HRESULT hr = S_OK;


    if( SP_IS_BAD_READ_PTR( pBinaryData ) )
    {
        return E_INVALIDARG;
    }
    
    //
    //  We need to figure out the differneces between the previous grammar and the
    //  current one.  We only want to add the new words and rules.
    //
    SPDBG_ASSERT( m_pEngine != NULL );
    SPDBG_ASSERT( !SP_IS_BAD_READ_PTR( m_pRuleTable ) );

    m_pEngine->InvalidateCache( this );

    // Store old state information.
    
    BYTE *                      old_pReplacementData;
    RUNTIMERULEENTRY *          old_pRuleTable;
    SPCFGHEADER                 old_Header;

    SPGRAMMARTYPE               old_LoadedType;
    BYTE *                      old_pData;
 

    memcpy( &old_Header, &m_Header, sizeof( SPCFGHEADER ) );
    old_pReplacementData = m_pReplacementData;
    old_pRuleTable       = m_pRuleTable;    
    old_pData            = m_pData;
    old_LoadedType       = m_LoadedType;


    hr = InternalReload( pBinaryData );

    if( SUCCEEDED( hr ) )
    {
        // Clean up the old state.
        delete[] old_pReplacementData;
        if( m_LoadedType == Memory )
        {
            delete [] old_pData;
        }
        if( old_Header.cRules != m_Header.cRules )
        {
            delete [] old_pRuleTable;
        }

        m_ulDictationTags = 0;
        for(ULONG nArc = 0; nArc < m_Header.cArcs; nArc++)
        {
            if (m_Header.pArcs[nArc].TransitionIndex == SPDICTATIONTRANSITION)
            {
                m_ulDictationTags++;
            }
        }

    }
    else
    {
        // Copy the header.
        // Restore the old state.

        memcpy( &m_Header, &old_Header, sizeof( SPCFGHEADER ) );
    
        if( m_pReplacementData != old_pReplacementData )
        {
            delete [] m_pReplacementData;
            m_pReplacementData = old_pReplacementData;
            m_pData = old_pData;
        }

        if( m_pRuleTable != old_pRuleTable )
        {
            delete [] m_pRuleTable;
            m_pRuleTable = old_pRuleTable;
        }
    }

    return hr;
}

/****************************************************************************
* CCFGGrammar::GetNumberDictationTags *
*-------------------------------------*
*   Description:
*       Returns the number of embedded dictation tags within the current CFG.
*       This is used by the srrecoinstgrammar to keep track of whether it should
*       load dictation for this CFG.
*
*   Returns:
*
****************************************************************** davewood ***/
STDMETHODIMP CCFGGrammar::GetNumberDictationTags(ULONG * pulTags)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGGrammar::NumberDictationTags");

    *pulTags = m_ulDictationTags;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\cfgengine.cpp ===
/*******************************************************************************
* CFGEngine.cpp *
*--------------*
*   Description:
*-------------------------------------------------------------------------------
*  Created By: RAL
*  Copyright (C) 1998, 1999 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/
#include "stdafx.h"

#include "CFGEngine.h"

extern CSpUnicodeSupport g_Unicode;

/////////////////////////////////////////////////////////////////////////////
// CCFGEngine

/****************************************************************************
* CCFGEngine::ValidateHandle (RuleHandles) *
*------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CCFGEngine::ValidateHandle(CRuleHandle rh)
{
    SPDBG_FUNC("CCFGEngine::ValidateHandle");

    ULONG id = rh.GrammarId();
    if (id <= m_cGrammarTableSize)
    {
        CCFGGrammar * pGram = m_pGrammars[id];
        if (pGram && rh.RuleIndex() < pGram->m_Header.cRules)
        {
            return S_OK;
        }
    }
    return SPERR_INVALID_HANDLE;
}

/****************************************************************************
* CCFGEngine::ValidateHandle (Word Handles) *
*-------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CCFGEngine::ValidateHandle(CWordHandle wh)
{
    SPDBG_FUNC("CCFGEngine::ValidateHandle (Word Handles)");
    ULONG i = wh.WordTableIndex();
    if (i && i < m_cWordTableEntries)
    {
        return S_OK;
    }
    return SPERR_INVALID_HANDLE;
}

/****************************************************************************
* CCFGEngine::ValidateHandle (State Handles) *
*--------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CCFGEngine::ValidateHandle(CStateHandle sh)
{
    SPDBG_FUNC("CCFGEngine::ValidateHandle (State Handles)");

    ULONG id = sh.GrammarId();
    if (id <= m_cGrammarTableSize)
    {
        CCFGGrammar * pGram = m_pGrammars[id];
        if (pGram && sh.FirstArcIndex() < pGram->m_Header.cArcs)
        {
            return S_OK;
        }
    }
    return SPERR_INVALID_HANDLE;
}

/****************************************************************************
* CCFGEngine::ValidateHandle (Transition ID's) *
*----------------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CCFGEngine::ValidateHandle(CTransitionId th)
{
    SPDBG_FUNC("CCFGEngine::ValidateHandle (Transition ID's)");

    ULONG id = th.GrammarId();
    if (id <= m_cGrammarTableSize)
    {
        CCFGGrammar * pGram = m_pGrammars[id];
        if (pGram && th.ArcIndex() < pGram->m_Header.cArcs)
        {
            return S_OK;
        }
    }
    return SPERR_INVALID_HANDLE;
}


/****************************************************************************
* CCFGEngine::RemoveWords *
*-------------------------*
*   Description:
*       Decrements word counts in the global word table (m_WordStringBlob)
*       and informs the engine if a word i no longer used in any loaded grammar.
*
*   Returns:
*
**************************************************************** PhilSch ***/

HRESULT CCFGEngine::RemoveWords(const CCFGGrammar * pGrammar)
{
    SPDBG_FUNC("CCFGEngine::RemoveWords");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_READ_PTR(pGrammar))
    {
        return E_POINTER;
    }

    //
    //  At most, we'll remove all of the words in this grammar...
    //
    ULONG cGramWords = pGrammar->m_Header.cWords;
    SPWORDENTRY *pWords = (SPWORDENTRY *) ::CoTaskMemAlloc(sizeof(SPWORDENTRY) * cGramWords);
    memset(pWords, 0, sizeof(SPWORDENTRY) * cGramWords);
    ULONG cDeleteWords = 0;

    for (ULONG i = 1; i < cGramWords; i++)
    {
        CWordHandle hWord = pGrammar->m_IndexToWordHandle[i];
        if (--m_pWordTable[hWord.WordTableIndex()].cRefs == 0)
        {
            pWords[cDeleteWords].hWord = hWord;
            pWords[cDeleteWords].pvClientContext = m_pWordTable[hWord.WordTableIndex()].pvClientContext;
            cDeleteWords++;
        }
    }
    if (SUCCEEDED(hr) && m_pClient)
    {
        hr = m_pClient->WordNotify(SPCFGN_REMOVE, cDeleteWords, pWords);
        //if (FAILED(hr))
        //{
            // there is no point in adding them back in case the engine failed ...
        //}
    }

    ::CoTaskMemFree(pWords);

    return hr;
}

/****************************************************************************
* CCFGEngine::AddWords *
*----------------------*
*   Description:
*       Adds words to the global string table (or increments ref count).
*       Informs the SR engine of any new words that were added.
*
*   Returns:
*
**************************************************************** PhilSch ***/

HRESULT CCFGEngine::AddWords(CCFGGrammar *pGrammar, ULONG ulOldCountOfWords, ULONG ulOldCountOfChars)
{
    SPDBG_FUNC("CCFGEngine::AddWords");
    HRESULT hr = S_OK;
    WCHAR *pszBufferRoot = NULL;

    if (SP_IS_BAD_READ_PTR(pGrammar))
    {
        return E_POINTER;
    }

    SPDBG_ASSERT(m_CurLangID); // Should have correctly set the lang id now

    //
    //  If this grammar has an index table, preserve it...
    //
    ULONG cNewWords = 0;
    SPWORDENTRY *pWords = (SPWORDENTRY *) ::CoTaskMemAlloc(sizeof(SPWORDENTRY) * (pGrammar->m_Header.cWords - ulOldCountOfWords));
    if (!pWords && ((pGrammar->m_Header.cWords - ulOldCountOfWords) > 0))
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = ReallocateArray(&pGrammar->m_IndexToWordHandle, ulOldCountOfWords, pGrammar->m_Header.cWords);
    }
    if (SUCCEEDED(hr))
    {
        // use a buffer for the text from the wordblob so we don't store pointers in the word blob!
        ULONG ulBufferSize = pGrammar->m_Header.cchWords + pGrammar->m_Header.cWords;
        pszBufferRoot = (WCHAR *) ::CoTaskMemAlloc(sizeof(WCHAR) * ulBufferSize);
        WCHAR *pszBuffer = pszBufferRoot;
        if (!pszBuffer)
        {
            ::CoTaskMemFree(pWords);
            return E_OUTOFMEMORY;
        }
        memset(pszBuffer, 0, ulBufferSize*sizeof(WCHAR));
        const WCHAR * pszWords = pGrammar->m_Header.pszWords;
        SPDBG_ASSERT(pszWords);

        ULONG cchWords = pGrammar->m_Header.cchWords;
        ULONG iWord = ulOldCountOfWords;

        for (ULONG iChar = ulOldCountOfChars;
             iChar < cchWords;
             iChar += wcslen(pszWords + iChar) + 1, iWord++)
        {
            ULONG ulOffset, ulIndex;
            if (wcslen(pszWords + iChar) == 0)
            {
                continue;
            }
            hr = m_WordStringBlob.Add(pszWords + iChar, &ulOffset, &ulIndex);
            if (SUCCEEDED(hr))
            {
                pGrammar->m_IndexToWordHandle[iWord] = ulIndex;
                if (ulIndex > m_ulLargestIndex)
                {
                    // we need to add this word
                    if (ulIndex >= m_cWordTableEntries)
                    {
                        ULONG ulDesiredSize = m_cWordTableEntries + 20;
                        hr = ReallocateArray(&m_pWordTable, m_cWordTableEntries, ulDesiredSize);
                        if (SUCCEEDED(hr))
                        {
                            m_cWordTableEntries = ulDesiredSize;
                        }
                    }
                    if (SUCCEEDED(hr))
                    {
                        m_pWordTable[ulIndex].cRefs++;
                        m_pWordTable[ulIndex].ulTextOffset = ulOffset;
                        m_pWordTable[ulIndex].pvClientContext = NULL;

                        m_ulLargestIndex = ulIndex;

                        // add to pWords
                        pWords[cNewWords].hWord = CWordHandle(ulIndex);
                        pWords[cNewWords].LangID = m_CurLangID;
                        pWords[cNewWords].pvClientContext = NULL;
                        const WCHAR *pWord = m_WordStringBlob.String(ulOffset);
                        ULONG ulInc = wcslen(pWord) + 1;
                        wcscpy(pszBuffer, pWord);
                        hr = SetWordInfo(pszBuffer, &pWords[cNewWords]);

                        // If the word has a pronunciation we cannot change its langid
                        if(SUCCEEDED(hr) && 
                            m_CurLangID != pGrammar->m_Header.LangID &&
                            pWords[cNewWords].aPhoneId)
                        {
                            hr = SPERR_LANGID_MISMATCH;
                        }

                        pszBuffer += ulInc;
                        cNewWords++;
                    }
                }
                else
                {
                    if (m_pWordTable[ulIndex].cRefs==0)
                    {
                        // add to ppWords
                        pWords[cNewWords].hWord = CWordHandle(ulIndex);
                        pWords[cNewWords].LangID = m_CurLangID;
                        pWords[cNewWords].pvClientContext = NULL;
                        const WCHAR *pWord = m_WordStringBlob.String(ulOffset);
                        ULONG ulInc = wcslen(pWord) + 1;
                        wcscpy(pszBuffer, pWord);
                        hr = SetWordInfo(pszBuffer, &pWords[cNewWords]);

                        // If the word has a pronunciation we cannot change its langid
                        if(SUCCEEDED(hr) && 
                            m_CurLangID != pGrammar->m_Header.LangID &&
                            pWords[cNewWords].aPhoneId)
                        {
                            hr = SPERR_LANGID_MISMATCH;
                        }

                        pszBuffer += ulInc;
                        cNewWords++;
                    }
                    m_pWordTable[ulIndex].cRefs++;
                }
            }
        }
    }

    if (SUCCEEDED(hr) && m_pClient)
    {
        hr = m_pClient->WordNotify(SPCFGN_ADD, cNewWords, pWords);

        // We need to decrement the cRefs in the failure case.
        if (FAILED(hr))
        {
            for (ULONG i = 0; i < cNewWords; i++)
            {
                ULONG ulIndex = HandleToUlong(pWords[i].hWord);
                SPDBG_ASSERT(m_pWordTable[ulIndex].cRefs > 0);
                m_pWordTable[ulIndex].cRefs--;
            }
        }
    }

    ::CoTaskMemFree(pszBufferRoot);
    ::CoTaskMemFree(pWords);
    return hr;
}


/****************************************************************************
* CCFGEngine::AddRules *
*----------------------*
*   Description:
*       Prior to calling this function, the grammar m_pRuleTable member will
*   have been updated.
*
*   Returns:
*
**************************************************************** PhilSch ***/

HRESULT CCFGEngine::AddRules(CCFGGrammar * pGrammar, ULONG IndexStart)
{
    SPDBG_FUNC("CCFGEngine::AddRules");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_READ_PTR(pGrammar))
    {
        return E_POINTER;
    }

    ULONG cTotalRules = pGrammar->m_Header.cRules - IndexStart;
    if (cTotalRules)
    {
        SPRULEENTRY *pRuleEntry = STACK_ALLOC_AND_ZERO(SPRULEENTRY, cTotalRules);
        if (!pRuleEntry)
        {
            return E_INVALIDARG;
        }
        ULONG cNonImport = 0;
        ULONG cTopLevel = 0;
        SPRULEENTRY * pCurEntry = pRuleEntry;
        SPCFGRULE * pRule = pGrammar->m_Header.pRules + IndexStart;
        if (!pRule)
        {
            return E_INVALIDARG;
        }

        for (ULONG i = IndexStart; i < pGrammar->m_Header.cRules; i++, pRule++)
        {
            if (!pRule->fImport)
            {
                cNonImport++;
                if (pRule->fTopLevel)
                {
                    cTopLevel++;
                    pCurEntry->Attributes |= SPRAF_TopLevel;
                }
                // else already 0 attributes from memset above.
                // client data is NULL also since this is an add operation
                pCurEntry->hRule = CRuleHandle(pGrammar, i);
                pCurEntry->pvClientGrammarContext = pGrammar->m_pvClientCookie;
                pCurEntry++;
            }
            if(pRule->fPropRule)
            {
                pCurEntry->Attributes |= SPRAF_Interpreter;
            }
        }


        if (m_pClient)
        {
            hr = m_pClient->RuleNotify(SPCFGN_ADD, cNonImport, pRuleEntry);

            // In the failure case we need to restore the rules to the
            // correct and appropriate values.  ( and the pGrammar values. )
        }

        if (SUCCEEDED(hr))
        {
            pGrammar->m_cTopLevelRules += cTopLevel;
            pGrammar->m_cNonImportRules += cNonImport;

            m_cTotalRules += cTotalRules;
            m_cTopLevelRules += cTopLevel;
            m_cNonImportRules += cNonImport;
        }
    }

    return hr;
}

/****************************************************************************
* CCFGEngine::RemoveRules *
*-------------------------*
*   Description:
*       Informs the SR engine of rules that were removed when a grammar got
*       unloaded.
*
*   Returns:
*
**************************************************************** PhilSch ***/

HRESULT CCFGEngine::RemoveRules(const CCFGGrammar * pGrammar)
{
    SPDBG_FUNC("CCFGEngine::RemoveRules");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_READ_PTR(pGrammar))
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr) && m_pClient)
    {
        //ULONG cRules = pGrammar->m_Header.cRules;
        ULONG cRules = pGrammar->m_cNonImportRules;
        SPRULEENTRY *pRuleEntry = new SPRULEENTRY [cRules];
        if (!pRuleEntry)
        {
            hr = E_OUTOFMEMORY;
        }
        if (SUCCEEDED(hr))
        {
            memset(pRuleEntry,0,cRules*sizeof(*pRuleEntry));
            for(ULONG i = 0, j = 0; i < pGrammar->m_Header.cRules; i++)
            {
                if (!pGrammar->m_Header.pRules[i].fImport)
                {
                    pRuleEntry[j].hRule = CRuleHandle(pGrammar, i);        
                    pRuleEntry[j].pvClientRuleContext = pGrammar->m_pRuleTable[i].pvClientContext;
                    pRuleEntry[j].pvClientGrammarContext = pGrammar->m_pvClientCookie;
                    j++;
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = m_pClient->RuleNotify(SPCFGN_REMOVE, cRules, pRuleEntry);
        }
        delete[] pRuleEntry;
    }

    if (SUCCEEDED(hr))
    {
        m_cTotalRules -= pGrammar->m_Header.cRules;
        m_cTopLevelRules -= pGrammar->m_cTopLevelRules;
        m_cNonImportRules -= pGrammar->m_cNonImportRules;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CCFGEngine::ActivateRule *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CCFGEngine::ActivateRule(const CCFGGrammar * pGrammar, const ULONG ulRuleIndex)
{
    SPDBG_FUNC("CCFGEngine::ActivateRule");
    HRESULT hr = S_OK;

    SPRULEENTRY entry;

    RUNTIMERULEENTRY * pRule = pGrammar->m_pRuleTable + ulRuleIndex;

    entry.hRule = CRuleHandle(pGrammar, ulRuleIndex);
    entry.pvClientRuleContext = pRule->pvClientContext;
    entry.pvClientGrammarContext = pGrammar->m_pvClientCookie;
    entry.Attributes = SPRAF_Active;
    if (pGrammar->m_Header.pRules[ulRuleIndex].fPropRule)
    {
        entry.Attributes |= SPRAF_Interpreter;
    }
    if (pGrammar->m_Header.pRules[ulRuleIndex].fTopLevel)
    {
        entry.Attributes |= SPRAF_TopLevel;
    }
    entry.hInitialState = CStateHandle(pRule->pRefGrammar, pRule->pRefGrammar->m_Header.pRules[ulRuleIndex].FirstArcIndex);
    if (m_pClient)
    {
        hr = m_pClient->RuleNotify(SPCFGN_ACTIVATE, 1, &entry);
    }

    if (SUCCEEDED(hr))
    {
        pRule->fEngineActive = TRUE;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CCFGEngine::DeactivateRule *
*----------------------------*
*   Description:
*
*   Returns:
*
**************************************************************** richp ***/
HRESULT CCFGEngine::DeactivateRule(const ULONG ulGrammarID, const ULONG ulRuleIndex)
{
    SPDBG_FUNC("CCFGEngine::DeactivateRule");
    SPRULEENTRY entry;

    CRuleHandle RuleHandle(ulGrammarID, ulRuleIndex);
    entry.hRule = RuleHandle;
    HRESULT hr = ValidateHandle(entry.hRule);
    if (FAILED(hr))
    {
        return hr;
    }

    entry.pvClientRuleContext = m_pGrammars[ulGrammarID]->m_pRuleTable[ulRuleIndex].pvClientContext;
    entry.pvClientGrammarContext = m_pGrammars[ulGrammarID]->m_pvClientCookie;
    entry.Attributes = 0;
    CCFGGrammar * pGram = GrammarOf(RuleHandle);
    if (pGram->m_Header.pRules[ulRuleIndex].fPropRule)
    {
        entry.Attributes |= SPRAF_Interpreter;
    }
    if (pGram->m_Header.pRules[ulRuleIndex].fTopLevel)
    {
        entry.Attributes |= SPRAF_TopLevel;
    }
    if (m_pClient)
    {
        hr = m_pClient->RuleNotify(SPCFGN_DEACTIVATE, 1, &entry);
    }

    if (SUCCEEDED(hr))
    {
        pGram->m_pRuleTable[ulRuleIndex].fEngineActive = FALSE;
    }
    return hr;
}


/****************************************************************************
* CCFGEngine::AllocateGrammar *
*-----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

HRESULT CCFGEngine::AllocateGrammar(CCFGGrammar ** ppNewGrammar)
{
    SPDBG_FUNC("CCFGEngine::AllocateGrammar");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppNewGrammar))
    {
        return E_POINTER;
    }

    for (ULONG i = 0; i < m_cGrammarTableSize && m_pGrammars[i]; i++)
    { }
    if (i >= m_cGrammarTableSize)
    {
        // Need to grow the table.  Grow in increments of 256...
        ULONG cDesired = m_cGrammarTableSize + 256;
        if (cDesired > MAXNUMGRAMMARS)
        {
            hr = SPERR_TOO_MANY_GRAMMARS;
        }
        else
        {
            CCFGGrammar ** pNew = new CCFGGrammar * [cDesired];
            if (pNew)
            {
                if (m_cGrammarTableSize)
                {
                    memcpy(pNew, m_pGrammars, m_cGrammarTableSize * sizeof(*pNew));
                }
                delete[] m_pGrammars;
                memset(pNew + m_cGrammarTableSize, 0, sizeof(*pNew) * (cDesired - m_cGrammarTableSize));
                m_pGrammars = pNew;
                m_cGrammarTableSize = cDesired;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        CComObject<CCFGGrammar> * pNewGram;
        hr = CComObject<CCFGGrammar>::CreateInstance(&pNewGram);
        if (SUCCEEDED(hr))
        {
            pNewGram->AddRef();
            m_pGrammars[i] = pNewGram;
            pNewGram->BasicInit(i, this);
            *ppNewGrammar = pNewGram;
            m_cGrammarsLoaded++;

        }
    }

    return hr;
}

/****************************************************************************
* CCFGEngine::LoadGrammarFromFile *
*---------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CCFGEngine::LoadGrammarFromFile(const WCHAR * pszFileName, void * pvOwnerCookie, void * pvClientCookie, ISpCFGGrammar ** ppGrammar)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::LoadGrammarFromFile");

    return InternalLoadGrammarFromFile(pszFileName, pvOwnerCookie, pvClientCookie, TRUE, ppGrammar);
}

HRESULT CCFGEngine::InternalLoadGrammarFromFile(const WCHAR * pszFileName, void * pvOwnerCookie, void * pvClientCookie, BOOL fIsToplevelLoad, ISpCFGGrammar ** ppGrammar)
{
    SPDBG_FUNC("CCFGEngine::LoadGrammarFromFile");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_STRING_PTR(pszFileName) || SP_IS_BAD_WRITE_PTR(ppGrammar))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (SP_IS_BAD_WRITE_PTR(ppGrammar))
        {
            hr = E_POINTER;
        }
        else
        {
            // Fully qualify filename here. Required so ->IsEqualFile works correctly for the same file.
            WCHAR pszFullName[MAX_PATH];
            WCHAR *pszFile;
            if (g_Unicode.GetFullPathName(const_cast<WCHAR *>(pszFileName), MAX_PATH, pszFullName, &pszFile) == 0)
            {
                hr = SpHrFromLastWin32Error();
            }

            if (SUCCEEDED(hr))
            {
                *ppGrammar = NULL;
                if (!fIsToplevelLoad)
                {
                    for (ULONG i = 0; i < m_cGrammarTableSize; i++)
                    {
                        if (m_pGrammars[i] && m_pGrammars[i]->IsEqualFile(pszFullName))
                        {
                            if (m_pGrammars[i]->m_fLoading)
                            {
                                hr = SPERR_CIRCULAR_REFERENCE;
                            }
                            else
                            {
                                *ppGrammar = m_pGrammars[i];
                                (*ppGrammar)->AddRef();
                            }
                            break;
                        }
                    }
                }
            }
            if (*ppGrammar == NULL && SUCCEEDED(hr))
            {
                CCFGGrammar * pNewGram;
                hr = AllocateGrammar(&pNewGram);    // Addref's the grammar
                if (SUCCEEDED(hr))
                {
                    pNewGram->m_pvOwnerCookie = pvOwnerCookie;
                    pNewGram->m_pvClientCookie = pvClientCookie;


                    //
                    //  If the extension of the file is ".xml" then attempt to compile it
                    //
                    ULONG cch = wcslen(pszFullName);
                    if (cch > 4 && _wcsicmp(pszFullName + cch - 4, L".xml") == 0)
                    {
                        CComPtr<ISpStream> cpSrcStream;
                        CComPtr<IStream> cpDestMemStream;
                        CComPtr<ISpGrammarCompiler> m_cpCompiler;
            
                        hr = SPBindToFile(pszFullName, SPFM_OPEN_READONLY, &cpSrcStream);
                        if (SUCCEEDED(hr))
                        {
                            hr = ::CreateStreamOnHGlobal(NULL, TRUE, &cpDestMemStream);
                        }
                        if (SUCCEEDED(hr))
                        {
                            hr = m_cpCompiler.CoCreateInstance(CLSID_SpGrammarCompiler);
                        }
                        if (SUCCEEDED(hr))
                        {
                            hr = m_cpCompiler->CompileStream(cpSrcStream, cpDestMemStream, NULL, NULL, NULL, 0);
                        }
                        if (SUCCEEDED(hr))
                        {
                            HGLOBAL hGlobal;
                            hr = ::GetHGlobalFromStream(cpDestMemStream, &hGlobal);
                            if (SUCCEEDED(hr))
                            {
#ifndef _WIN32_WCE
                                SPCFGSERIALIZEDHEADER * pBinaryData = (SPCFGSERIALIZEDHEADER * )::GlobalLock(hGlobal);
#else
                                SPCFGSERIALIZEDHEADER * pBinaryData = (SPCFGSERIALIZEDHEADER * )GlobalLock(hGlobal);
#endif // _WIN32_WCE
                                if (pBinaryData)
                                {
                                    // Adapt filename to fully qualify protocol.
                                    CSpDynamicString dstrName;
                                    if ( !wcsstr(pszFullName, L"://") ||
                                         wcsstr(pszFullName, L"/") != (wcsstr(pszFullName, L"://")+1) )
                                    {
                                        dstrName.Append2(L"file://", pszFullName);
                                    }
                                    else
                                    {
                                        dstrName = pszFullName;
                                    }

                                    hr = pNewGram->InitFromMemory(pBinaryData, dstrName);
#ifndef _WIN32_WCE
                                    ::GlobalUnlock(hGlobal);
#else
                                    GlobalUnlock(hGlobal);
#endif // _WIN32_WCE
                                }
                            }
                        }
                    }
                    else
                    {
                        hr = pNewGram->InitFromFile(pszFullName);
                    }
                    if (SUCCEEDED(hr))
                    {
                        *ppGrammar = pNewGram;
                    }
                    else
                    {
                        pNewGram->Release();
                    }
                }
            }
        }
    }

    return hr;
}


/**********************************************************************************
* LoadGrammarFromMemory *
*-----------------------*
*   Description:
*
*   Return:
*
************************************************************** richp **************/
STDMETHODIMP CCFGEngine::LoadGrammarFromMemory(const SPBINARYGRAMMAR * pSerializedHeader, 
                                               void * pvOwnerCookie, void * pvClientCookie, 
                                               ISpCFGGrammar **ppGrammar, WCHAR * pszGrammarName)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::LoadGrammarFromMemory");

    return InternalLoadGrammarFromMemory(pSerializedHeader, pvOwnerCookie, pvClientCookie, TRUE, ppGrammar, pszGrammarName);
}

HRESULT CCFGEngine::InternalLoadGrammarFromMemory(const SPBINARYGRAMMAR * pBinaryData, 
                                                  void * pvOwnerCookie, void * pvClientCookie, 
                                                  BOOL fIsToplevelLoad, ISpCFGGrammar **ppGrammar,
                                                  WCHAR * pszGrammarName)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::InternalLoadGrammarFromMemory");
    HRESULT hr = S_OK;
    SPCFGSERIALIZEDHEADER * pSerializedHeader = (SPCFGSERIALIZEDHEADER*) pBinaryData;
    ULONG   ulGrammarID = 0;


    if (SP_IS_BAD_WRITE_PTR(ppGrammar))
    {
        hr = E_POINTER;
    }
    if (SUCCEEDED(hr))
    {
        if (SP_IS_BAD_READ_PTR(pSerializedHeader) ||
            pSerializedHeader->FormatId != SPGDF_ContextFree ||
            SPIsBadReadPtr(pSerializedHeader, pSerializedHeader->ulTotalSerializedSize))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            *ppGrammar = NULL;
            if (!fIsToplevelLoad)
            {
                for (ULONG i = 0; i < m_cGrammarTableSize; i++)
                {
                    if (m_pGrammars[i] && m_pGrammars[i]->m_Header.GrammarGUID == pSerializedHeader->GrammarGUID)
                    {
                        if (m_pGrammars[i]->m_fLoading)
                        {
                            hr = SPERR_CIRCULAR_REFERENCE;
                        }
                        else
                        {
                            *ppGrammar = m_pGrammars[i];
                            (*ppGrammar)->AddRef();
                        }
                        break;
                    }
                }
            }
            if (*ppGrammar == NULL && SUCCEEDED(hr))
            {
                CCFGGrammar * pNewGram;
                hr = AllocateGrammar(&pNewGram);    // Addref's the grammar
                if (SUCCEEDED(hr))
                {
                    pNewGram->m_pvOwnerCookie = pvOwnerCookie;
                    pNewGram->m_pvClientCookie = pvClientCookie;
                    hr = pNewGram->InitFromMemory(pSerializedHeader, pszGrammarName);
                    if (SUCCEEDED(hr))
                    {
                        *ppGrammar = pNewGram;
                    }
                    else
                    {
                        pNewGram->Release();
                    }
                }
            }
        }
    }
    return hr;
}

/**********************************************************************************
* LoadGrammarFromResource *
*-------------------------*
*   Description:
*       Loads main grammar and all imported grammars using _InternalLoadGrammarFromResource.
*       This wrapper hides the ulGrammarID from the developer.
*
*   Return:
*       HRESULT -- S_OK if load was successful -- E_FAIL otherwise (need better
*       return codes here!)
*
************************************************************** richp **************/
STDMETHODIMP CCFGEngine::LoadGrammarFromResource(
                            const WCHAR *pszModuleName,
                            const WCHAR *pszResourceName,
                            const WCHAR *pszResourceType,
                            WORD wLanguage,
                            void * pvOwnerCookie,
                            void * pvClientCookie,
                            ISpCFGGrammar **ppGrammar)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::LoadGrammarFromResource");
   
    return InternalLoadGrammarFromResource(pszModuleName, pszResourceName, pszResourceType, wLanguage,
                                           pvOwnerCookie, pvClientCookie, TRUE, ppGrammar);
}

HRESULT CCFGEngine::InternalLoadGrammarFromResource(
                                const WCHAR *pszModuleName,
                                const WCHAR *pszResourceName,
                                const WCHAR *pszResourceType,
                                WORD wLanguage,
                                void * pvOwnerCookie,
                                void * pvClientCookie,
                                BOOL fIsToplevelLoad,
                                ISpCFGGrammar **ppGrammar)
{
    SPDBG_FUNC("CCFGEngine::InternalLoadGrammarFromResource");
    HRESULT hr = S_OK;
    ULONG   ulGrammarID = 0;


    if (SP_IS_BAD_WRITE_PTR(ppGrammar))
    {
        hr = E_POINTER;
    }
    else
    {
        if ((HIWORD(pszResourceName) && SP_IS_BAD_STRING_PTR(pszResourceName)) ||
            (HIWORD(pszResourceType) && SP_IS_BAD_STRING_PTR(pszResourceType)))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            *ppGrammar = NULL;
            if (!fIsToplevelLoad)
            {
                for (ULONG i = 0; i < m_cGrammarTableSize; i++)
                {
                    if (m_pGrammars[i] && m_pGrammars[i]->IsEqualResource(pszModuleName, pszResourceName, pszResourceType, wLanguage))
                    {
                        if (m_pGrammars[i]->m_fLoading)
                        {
                            hr = SPERR_CIRCULAR_REFERENCE;
                        }
                        else
                        {
                            *ppGrammar = m_pGrammars[i];
                            (*ppGrammar)->AddRef();
                        }
                        break;
                    }
                }
            }
            if (*ppGrammar == NULL && SUCCEEDED(hr))
            {
                CCFGGrammar * pNewGram;
                hr = AllocateGrammar(&pNewGram);    // Addref's the grammar
                if (SUCCEEDED(hr))
                {
                    pNewGram->m_pvOwnerCookie = pvOwnerCookie;
                    pNewGram->m_pvClientCookie = pvClientCookie;
                    hr = pNewGram->InitFromResource(pszModuleName, pszResourceName, pszResourceType, wLanguage);
                    if (SUCCEEDED(hr))
                    {
                        *ppGrammar = pNewGram;
                    }
                    else
                    {
                        pNewGram->Release();
                    }
                }
            }
        }
    }
    return hr;
}

/****************************************************************************
* CCFGEngine::LoadGrammarFromObject *
*-----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CCFGEngine::LoadGrammarFromObject(REFCLSID rcid, const WCHAR * pszGrammarName, void * pvOwnerCookie, void * pvClientCookie, ISpCFGGrammar ** ppGrammar)
{
    SPDBG_FUNC("CCFGEngine::LoadGrammarFromObject");
    
    return InternalLoadGrammarFromObject(rcid, pszGrammarName, pvOwnerCookie, pvClientCookie, TRUE, ppGrammar);
}

HRESULT CCFGEngine::InternalLoadGrammarFromObject(REFCLSID rcid, const WCHAR * pszGrammarName, 
                                                  void * pvOwnerCookie, void * pvClientCookie, 
                                                  BOOL fIsToplevelLoad, ISpCFGGrammar ** ppGrammar)
{
    SPDBG_FUNC("CCFGEngine::InternalLoadGrammarFromObject");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_STRING_PTR(pszGrammarName) || SP_IS_BAD_WRITE_PTR(ppGrammar))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppGrammar = NULL;
        if (!fIsToplevelLoad)
        {
            for (ULONG i = 0; i < m_cGrammarTableSize; i++)
            {
                if (m_pGrammars[i] && m_pGrammars[i]->IsEqualObject(rcid, pszGrammarName))
                {
                    if (m_pGrammars[i]->m_fLoading)
                    {
                        hr = SPERR_CIRCULAR_REFERENCE;
                    }
                    else
                    {
                        *ppGrammar = m_pGrammars[i];
                        (*ppGrammar)->AddRef();
                    }
                    break;
                }
            }
        }
        if (*ppGrammar == NULL && SUCCEEDED(hr))
        {
            CCFGGrammar * pNewGram;
            hr = AllocateGrammar(&pNewGram);    // Addref's the grammar
            if (SUCCEEDED(hr))
            {
                pNewGram->m_pvOwnerCookie = pvOwnerCookie;
                pNewGram->m_pvClientCookie = pvClientCookie;
                hr = pNewGram->InitFromCLSID(rcid, pszGrammarName);
                if (SUCCEEDED(hr))
                {
                    *ppGrammar = pNewGram;
                }
                else
                {
                    pNewGram->Release();
                }
            }
        }
    }


    return hr;
}

/****************************************************************************
* CCFGEngine::RemoveGrammar *
*---------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

HRESULT CCFGEngine::RemoveGrammar(ULONG ulGrammarID)
{
    SPDBG_FUNC("CCFGEngine::RemoveGrammar");
    HRESULT hr = S_OK;

    if (m_pGrammars[ulGrammarID] == NULL)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else
    {
        if( m_pGrammars[ulGrammarID]->m_pRuleTable )
        {
            InvalidateCache( m_pGrammars[ulGrammarID] );
        }

        SPDBG_ASSERT(m_cGrammarsLoaded > 0);
        
        m_cGrammarsLoaded --;
        if (m_cGrammarsLoaded == 0)
        {
            // Although we will still have words in the string table we
            // can safely allow the langid to change as we no that no engine
            // or grammar will be referencing these words.
            m_CurLangID = 0;
        }
        m_pGrammars[ulGrammarID] = NULL;
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CCFGEngine::GetOwnerCookieFromRule *
*------------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAP ***/
STDMETHODIMP CCFGEngine::GetOwnerCookieFromRule(SPRULEHANDLE hRule, void ** ppvOwnerCookie)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::GetOwnerFromRule");
    HRESULT hr;

    if (SP_IS_BAD_WRITE_PTR(ppvOwnerCookie))
    {
        hr = E_POINTER;
    }
    else
    {
        CRuleHandle RuleHandle(hRule);
        hr = ValidateHandle(RuleHandle);
        if (SUCCEEDED(hr))
        {
            CCFGGrammar * pGram = GrammarOf(RuleHandle);
            *ppvOwnerCookie = pGram->m_pvOwnerCookie;
        }
        else
        {
            *ppvOwnerCookie = NULL;
        }
    }
    return hr;
}

/****************************************************************************
* CCFGEngine::SetClient *
*-----------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CCFGEngine::SetClient(_ISpRecoMaster * pClient)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::SetClient");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_INTERFACE_PTR(pClient))
    {
        hr = E_POINTER;
    }
    else
    {
        m_pClient = pClient;
    }

    return hr;
}

/*
        --------------------- PARSING  ------------------------------------
*/

STDMETHODIMP CCFGEngine::GetTransitionProperty(SPTRANSITIONID ID, SPTRANSITIONPROPERTY **ppCoMemProperty)
{
    HRESULT hr = S_FALSE; // Assume property not found
    CTransitionId hTrans(ID);
    if (FAILED(ValidateHandle(hTrans)) || SP_IS_BAD_WRITE_PTR(ppCoMemProperty))
    {
        return E_INVALIDARG;
    }

    *ppCoMemProperty = NULL;

    CCFGGrammar * pGram = m_pGrammars[hTrans.GrammarId()];
    SPDBG_ASSERT(pGram);

    if(!(pGram->m_Header.pArcs + hTrans.ArcIndex())->fHasSemanticTag)
    {
        return S_FALSE; // Arc doesn't have a property
    }

    // linear search
    SPCFGSEMANTICTAG *pTag = pGram->m_Header.pSemanticTags;
    for (ULONG i = 0; i < pGram->m_Header.cSemanticTags; i++, pTag++)
    {
        if (pTag->ArcIndex == hTrans.ArcIndex())
        {
            ULONG ulSize = sizeof(SPTRANSITIONPROPERTY);
            if (pTag->PropNameSymbolOffset)
            {
                ulSize += (wcslen(&pGram->m_Header.pszSymbols[pTag->PropNameSymbolOffset]) + 1) * sizeof(WCHAR);
            }
            if (pTag->PropValueSymbolOffset)
            {
                ulSize += (wcslen(&pGram->m_Header.pszSymbols[pTag->PropValueSymbolOffset]) + 1) * sizeof(WCHAR);
            }
            *ppCoMemProperty =  (SPTRANSITIONPROPERTY*)::CoTaskMemAlloc(ulSize);
            if(!*ppCoMemProperty)
            {
                return E_OUTOFMEMORY;
            }
            WCHAR *pszName, *pszValue;
            pszName = pszValue = (WCHAR*)((*ppCoMemProperty) + 1);

            if (pTag->PropNameSymbolOffset)
            {
                wcscpy(pszName, &pGram->m_Header.pszSymbols[pTag->PropNameSymbolOffset]);
                pszValue += (wcslen(pszName) + 1);
            }
            else
            {
                pszName = NULL;
            }
            if (pTag->PropValueSymbolOffset)
            {
                wcscpy(pszValue, &pGram->m_Header.pszSymbols[pTag->PropValueSymbolOffset]);
            }
            else
            {
                pszValue = NULL;
            }

            (*ppCoMemProperty)->pszName = pszName;
            (*ppCoMemProperty)->pszValue = pszValue;
            (*ppCoMemProperty)->ulId = pTag->PropId;
            hr = AssignSemanticValue(pTag, &(*ppCoMemProperty)->vValue);
            if (FAILED(hr))
            {
                ::CoTaskMemFree(*ppCoMemProperty);
            }
            break; // Found property so exit
        }
    }
    return hr;
}

/**********************************************************************************
* _CalcMultipleWordConfidence *
*-----------------------------*
*   Description:
************************************************************** davewood **********/

signed char CCFGEngine::_CalcMultipleWordConfidence(const SPPHRASE *pPhrase, ULONG ulFirstElement, ULONG ulCountOfElements)
{
    SPDBG_ASSERT(pPhrase != NULL && ulFirstElement >= pPhrase->Rule.ulFirstElement
        && (ulFirstElement + ulCountOfElements <= pPhrase->Rule.ulFirstElement + pPhrase->Rule.ulCountOfElements));

    signed char Confidence;

    if(ulCountOfElements == 0)
    {
        Confidence = SP_NORMAL_CONFIDENCE;
    }
    else if(ulCountOfElements == 1)
    {
        Confidence = pPhrase->pElements[ulFirstElement].ActualConfidence;
    }
    else
    {
        // Do averaging of confidence values.
        // A simple average of the elements associated with the phrase is used.
        // May be more effective to scale these by word length or some other method
        float totalConf = 0.0;
        for(ULONG i = ulFirstElement; i < ulFirstElement + ulCountOfElements; i++)
        {
            totalConf += pPhrase->pElements[i].ActualConfidence;
        }
        totalConf /= ulCountOfElements;

        // Round borderline values towards middle
        if(totalConf < (float)(SP_NORMAL_CONFIDENCE + SP_LOW_CONFIDENCE) / 2)
        {
            Confidence = SP_LOW_CONFIDENCE;
        }
        else if(totalConf > (float)(SP_NORMAL_CONFIDENCE + SP_HIGH_CONFIDENCE) / 2)
        {
            Confidence = SP_HIGH_CONFIDENCE;
        }
        else
        {
            Confidence = SP_NORMAL_CONFIDENCE;
        }
    }
    return Confidence;
}

/**********************************************************************************
* ParseITN *
*----------*
*   Description:
*       This is used to ITN a phrase and its alternates.
*
************************************************************** t-lleav ***********/

STDMETHODIMP CCFGEngine::ParseITN( ISpPhraseBuilder *pPhrase )
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::ParseITN");
    HRESULT hr = S_OK;

    SPPHRASE *pSPPhrase = NULL;

    do 
    {
        hr = pPhrase->GetPhrase(&pSPPhrase);
        if( FAILED(hr) )
        {
            break;
        }

        HRESULT hr1 = S_OK;
        ULONG cWords = pSPPhrase->Rule.ulCountOfElements;

        if ( cWords == 0)
        {
            hr = E_INVALIDARG;
            break;
        }

        _SPPATHENTRY *pPath = STACK_ALLOC(_SPPATHENTRY, cWords);
        if (!pPath)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Create the path/elem structure.
        //
        const SPPHRASEELEMENT *pElem = pSPPhrase->pElements;
        for(ULONG i = 0; i < cWords; i++, pElem++)
        {
            // pPath[i].hWord = 0;
            memcpy( &pPath[i].elem, pElem, sizeof( SPPHRASEELEMENT ) );
        }
       
        //
        // We need to look up the word handles here.
        //
        ResolveWordHandles( pPath, cWords, TRUE );

        //
        // And parse the words.
        //
        ULONG ulFirstElementToParse = 0;

        while (SUCCEEDED(hr1) && (ulFirstElementToParse < cWords ))  
        // SP_NO_PARSE_FOUND is a SUCCEEDED HRESULT
        {
            WordsParsed wordsParsed;
            
            if( pPath[ulFirstElementToParse].hWord == 0 )
            {
                ulFirstElementToParse++;
                continue;
            }

            hr1 = InternalParseFromPhrase( pPhrase, 
                                           pSPPhrase, 
                                           pPath, 
                                           ulFirstElementToParse,
                                           TRUE,  // fIsITN
                                           FALSE, // fIsHypothesis
                                           &wordsParsed);

            
            if ( FAILED(hr1) || hr1 == SP_NO_RULE_ACTIVE )
            {
                hr = hr1;
                break;
            }
            else if (hr1 == SP_NO_PARSE_FOUND)
            {
                ulFirstElementToParse++;
            }
            else
            {
                SPDBG_ASSERT( wordsParsed.ulWordsParsed > 0 );
                ulFirstElementToParse += wordsParsed.ulWordsParsed;
            }
        }

        if( FAILED( hr ) || hr == SP_NO_RULE_ACTIVE )
        {
            break;
        }

        hr = pPhrase->Discard(SPDF_PROPERTY);

    } while( false );

    //
    // Clean up memory.
    //
    if( pSPPhrase != NULL )
    {
        ::CoTaskMemFree(pSPPhrase);
    }
        
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/**********************************************************************************
* InternalParseFromPhrase *
*-------------------------*
*   Description:
*       This is a brain-dead version of top-down parsing which tries every rule
*       until one (the first one) works.
*
*       PARSE RESULTS IN-PLACE!!
*
*   Return:
*       HRESULT -- S_OK if parse was found for entire phrase
                   S_FALSE if one or more but not all the words parsed
*       ppPhrase  -- result phrase (currently only containing terminals, but will
*                    eventually include the entire parse tree).
*
**************************************************** t-lleav * philsch ***********/
HRESULT CCFGEngine::InternalParseFromPhrase(ISpPhraseBuilder *pPhrase, 
                                            const SPPHRASE *pSPPhrase, 
                                            const _SPPATHENTRY *pPath, 
                                            const ULONG ulFirstElement,
                                            const BOOL fIsITN,
                                            const BOOL fIsHypothesis,
                                            WordsParsed *pWordsParsed)
{
    SPDBG_FUNC("CCFGEngine::InternalParseFromPhrase");
    HRESULT hr = S_OK;

    pWordsParsed->Zero();

    CParseNode *pBestParseTree = NULL;
    CParseNode *pParseTree = NULL;

    SPRULEHANDLE hSuccessfulRule = 0;

    ULONG cElementCount = pSPPhrase->Rule.ulCountOfElements;
    ULONG ulDeletedElements = 0;
    WordsParsed MaxWordsParsed;
    ULONG ulRulesActive = 0;
    BOOL fContinue = TRUE;
    
    // Make array of elements that will be deleted by wildcard transition
    BOOL *pfDeletedElements = new BOOL[cElementCount];    
    if(pfDeletedElements == NULL)
    {
        return E_OUTOFMEMORY;
    }
    BOOL *pfBestDeletedElements = new BOOL[cElementCount];
    if(pfBestDeletedElements == NULL)
    {
        delete[] pfDeletedElements;
        return E_OUTOFMEMORY;
    }

    for (ULONG i = 0; fContinue && i < m_cGrammarTableSize; i++)
    {
        const CCFGGrammar *pGram = m_pGrammars[i];
        if (pGram)
        {
            SPCFGRULE * pRule = pGram->m_Header.pRules;
            RUNTIMERULEENTRY * pRunTimeRule = pGram->m_pRuleTable;
            ULONG ulGrammarId = pGram->m_ulGrammarID;
            HRESULT hr1 = SP_NO_PARSE_FOUND;

            //
            // Construct all the parse trees.
            //
            for (ULONG iRule = 0; fContinue && (iRule < pGram->m_Header.cRules); iRule++, pRunTimeRule++, pRule++)
            {
                if (pRule->fTopLevel && pRunTimeRule->fEngineActive)
                {
                    ulRulesActive++;
                    SPRULEENTRY RuleInfo;
                    CRuleHandle cr(ulGrammarId, iRule);
                    RuleInfo.hRule = cr; 
                    hr1 = GetRuleInfo(&RuleInfo, SPRIO_NONE);

                    WordsParsed CurWordsParsed;
                    pParseTree = NULL;

                    if (SUCCEEDED(hr1))
                    {

                        BOOL  bFound = TRUE;

                        RUNTIMERULEENTRY * pRuleEntry = RuleOf( cr );

                        if( pRuleEntry->eCacheStatus == CACHE_VOID )
                        {
                            CreateCache( cr );
                        }

                        if( pRuleEntry->eCacheStatus == CACHE_VALID )
                        {
                            bFound = IsInCache( pRuleEntry, pPath[ulFirstElement].hWord );
                        } 

                        if( bFound )
                        {
                            hr1 = ConstructParseTree(RuleInfo.hInitialState, 
                                                     pPath, 
                                                     TRUE,
                                                     fIsITN,
                                                     ulFirstElement, 
                                                     cElementCount, 
                                                     FALSE, 
                                                     &CurWordsParsed, 
                                                     &pParseTree,
                                                     pfDeletedElements);
                        }
                        else
                        {
                            hr1 = SP_NO_PARSE_FOUND;
                        }
                    }

                    if (S_OK == hr1 || SP_PARTIAL_PARSE_FOUND == hr1 || S_FALSE == hr1)
                    {
                        SPDBG_ASSERT(S_FALSE != hr1);
                        //
                        // Store the best parse tree.
                        //
                        if( CurWordsParsed.Compare(&MaxWordsParsed) > 0 )
                        {
                            ulDeletedElements = 0;

                            // Copy list of deleted elements
                            for(ULONG ul = 0; ul < cElementCount; ul++)
                            {
                                if(ul < CurWordsParsed.ulWordsParsed)
                                {
                                    pfBestDeletedElements[ul] = pfDeletedElements[ul];
                                    if(pfBestDeletedElements[ul])
                                    {
                                        ulDeletedElements++; // Count of deleted elements
                                    }
                                }
                                else
                                {
                                    pfBestDeletedElements[ul] = FALSE;
                                }
                            }

                            //
                            // Create the root node.
                            //
                            CParseNode *pTreeRoot = NULL;
                            hr = m_mParseNodeList.RemoveFirstOrAllocateNew(&pTreeRoot);

                            if( SUCCEEDED(hr) )
                            {
                                memset( pTreeRoot, 0, sizeof( CParseNode ) );
                                pTreeRoot->m_pLeft  = pParseTree;
                                //
                                // Do an epsilon transition instead of a rule transition to avoid
                                // creating a top level rule transition.
                                //
                                pTreeRoot->Type = SPTRANSEPSILON;  
                                pTreeRoot->hRule = RuleInfo.hRule;
                                pTreeRoot->ulFirstElement = ulFirstElement;
                                pTreeRoot->ulCountOfElements = CurWordsParsed.ulWordsParsed - ulDeletedElements;

                                GetPropertiesOfRule(RuleInfo.hRule, 
                                                 &pTreeRoot->pszRuleName, 
                                                 &pTreeRoot->ulRuleId,
                                                 &pTreeRoot->fInvokeInterpreter);

                                pParseTree = pTreeRoot;
                            }
        
                            if (pBestParseTree)
                            {
                                FreeParseTree(pBestParseTree);
                            }
                            pBestParseTree = pParseTree;
                            MaxWordsParsed = CurWordsParsed;
                            hSuccessfulRule = RuleInfo.hRule;

                            // When text parsing, stop if got a complete parse with no dictation / wildcard words
                            if (MaxWordsParsed.ulWordsParsed == (cElementCount - ulFirstElement)
                                && MaxWordsParsed.ulDictationWords == 0
                                && MaxWordsParsed.ulWildcardWords == 0)
                            {
                                fContinue = false;
                            }
                        }
                        else
                        {
                            if (pParseTree)
                            {
                                FreeParseTree(pParseTree);
                            }
                        }
                    }
                }

                if (MaxWordsParsed.ulWordsParsed > 0)
                {
                    // If we have any sort of match, we pass S_OK onto next section.
                    *pWordsParsed = MaxWordsParsed;
                    hr = S_OK;
                }
                else
                {
                    hr = SP_NO_PARSE_FOUND; // was hr1
                    // Only occurs if we fail to parse completely.
                    // This will only pass through to the next section if no rules match at all.
                }
            }
        }
    }

    if (ulRulesActive == 0)
    {
        hr = SP_NO_RULE_ACTIVE;
    }


    pParseTree = pBestParseTree;

    do
    {
        if( S_OK != hr )
        {
            break;
        }
        //
        // Extract the properties and invoke the interpreter.
        //
        if( FAILED(hr) )
        {
            break;
        }
        else
        {
            CTIDArray * pArcList = new CTIDArray(MaxWordsParsed.ulWordsParsed - ulDeletedElements, MaxWordsParsed.ulWordsParsed - ulDeletedElements);
            if (!pArcList)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                // construct the arclist here so that it matches the best parse tree
                hr = pArcList->ConstructFromParseTree(pParseTree);
                // and "shift" the index values by ulFirstElement
                for (ULONG k = 0; SUCCEEDED(hr) && (k < pArcList->m_cArcs); k++)
                {
                    pArcList->m_aTID[k].ulIndex += ulFirstElement;
                }
            }

            if (SUCCEEDED(hr) && !fIsITN && ulDeletedElements)
            {
                // Remove the deleted elements from the phrase and path.
                // Note: This code breaks the constness of pPath and pSPPhrase.
                // This is not a problem as this is only done for emulate recognition,
                // where these structures are never re-used.
                for(ULONG ulFrom = 0, ulTo = 0; ulFrom < cElementCount; ulFrom++)
                {
                    if(!pfBestDeletedElements[ulFrom])
                    {
                        SPPHRASEELEMENT *pPETo = (SPPHRASEELEMENT *)&pSPPhrase->pElements[ulTo];
                        SPPHRASEELEMENT *pPEFrom = (SPPHRASEELEMENT *)&pSPPhrase->pElements[ulFrom];
                        *pPETo = *pPEFrom;

                        _SPPATHENTRY *pPTo = (_SPPATHENTRY *)&pPath[ulTo];
                        _SPPATHENTRY *pPFrom = (_SPPATHENTRY *)&pPath[ulFrom];
                        *pPTo = *pPFrom;

                        ulTo++;
                    }
                    else
                    {
                        SPPHRASEELEMENT *pPE = (SPPHRASEELEMENT *)&pSPPhrase->pElements[ulTo-1];
                        pPE->pszLexicalForm = SPWILDCARD;
                        pPE->pszDisplayText = SPWILDCARD;

                        _SPPATHENTRY *pP = (_SPPATHENTRY *)&pPath[ulTo-1];
                        pP->hWord = 0;
                    }
                }
                
                // Reinitialize pPhrase with the new element list
                (ULONG)pSPPhrase->Rule.ulCountOfElements -= ulDeletedElements;
                hr = pPhrase->InitFromPhrase(pSPPhrase);
            }

            if (SUCCEEDED(hr))
            {
                hr = WalkParseTree(pParseTree, fIsITN, fIsHypothesis, NULL, NULL, pArcList, ulFirstElement, MaxWordsParsed.ulWordsParsed, pPhrase, pSPPhrase);
            }

            delete pArcList;

            if( FAILED(hr) )
            {
                break;
            }

            //
            // Init the phrase.
            //

            if ( !fIsITN )
            {
                SPPHRASE *pspPhrase = NULL;
                hr = pPhrase->GetPhrase(&pspPhrase );
                if (SUCCEEDED(hr))
                {
                    pspPhrase ->Rule.pszName = pParseTree->pszRuleName;
                    pspPhrase ->Rule.ulId = pParseTree->ulRuleId;
                    // add in pszDisplayText if it's not already set
                    for (ULONG i = 0; i < cElementCount - ulDeletedElements; i++)
                    {
                        SPPHRASEELEMENT * pElem = const_cast<SPPHRASEELEMENT*>(pspPhrase->pElements);
                        if (pPath[i].hWord == 0)
                        {
                            // this is either TEXTBUFFER, WILDCARD or DICTATION and hence doesn't have a text from the grammar
                            pElem[i].pszLexicalForm = pSPPhrase->pElements[i].pszLexicalForm;
                            pElem[i].pszDisplayText = ( pSPPhrase->pElements[i].pszDisplayText ) ?  pSPPhrase->pElements[i].pszDisplayText :
                                                                                                    pSPPhrase->pElements[i].pszLexicalForm;
                        }
                        else
                        {
                            const WCHAR *pcText = TextOf(pPath[i].hWord);
                            WCHAR *pszText = STACK_ALLOC(WCHAR, wcslen(pcText) +1);
                            wcscpy(pszText, pcText);
                            HRESULT hr = AssignTextPointers(pszText, &pElem[i].pszDisplayText, 
                                                           &pElem[i].pszLexicalForm, 
                                                           &pElem[i].pszPronunciation);
                            if (SUCCEEDED(hr))
                            {
                                // clean up display text
                                WCHAR *p = const_cast<WCHAR*>(pElem[i].pszDisplayText);
                                WCHAR *q = p;
                                while (*p)
                                {
                                    if (*p == L'\\')
                                    {
                                        p++;
                                    }
                                    *q++ = *p++;
                                }
                                *q = 0;
                            }
                        }
                        pElem[i].ActualConfidence = SP_HIGH_CONFIDENCE;
                        pElem[i].RequiredConfidence = pSPPhrase->pElements[i].RequiredConfidence;
                    }
                    hr = pPhrase->InitFromPhrase( pspPhrase  );
                    ::CoTaskMemFree(pspPhrase );
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            CComQIPtr<_ISpCFGPhraseBuilder> pTempPhrase( pPhrase );
            hr = pTempPhrase->SetCFGInfo( this, pParseTree->hRule );
        }
    } 
    while( false );

    //
    // Free the parse tree
    //
    if (pParseTree)
    {
        FreeParseTree(pParseTree);
    }
    delete[] pfDeletedElements;
    delete[] pfBestDeletedElements;

    if( S_OK == hr )
    {
        hr = ((ulFirstElement + MaxWordsParsed.ulWordsParsed) < cElementCount)  ? S_FALSE : S_OK;
    }

    return hr;
}

/**********************************************************************************
* ParseFromPhrase *
*-----------------*
*   Description:
*       This is a brain-dead version of top-down parsing which tries every rule
*       until one (the first one) works.
*
*       PARSE RESULTS IN-PLACE!!
*
*   Return:
*       HRESULT -- S_OK if parse was found for entire phrase
                   S_FALSE if one or more but not all the words parsed
*       ppPhrase  -- result phrase (currently only containing terminals, but will
*                    eventually include the entire parse tree).
*
******************************************************* t-lleav * philsch **********/

STDMETHODIMP CCFGEngine::ParseFromPhrase(ISpPhraseBuilder *pPhrase, 
                                         const SPPHRASE *pSPPhrase, 
                                         const ULONG ulFirstElement, 
                                         BOOL fIsITN, 
                                         ULONG *pulWordsParsed)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::ParseFromPhrase");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_INTERFACE_PTR(pPhrase) ||
        SP_IS_BAD_READ_PTR(pSPPhrase) ||
        SP_IS_BAD_WRITE_PTR(pulWordsParsed))
    {
        return E_INVALIDARG;
    }

    BOOL fActive = false;
    ULONG cWords = pSPPhrase->Rule.ulCountOfElements;

    if ( cWords == 0)
    {
        return E_INVALIDARG;
    }

    if (ulFirstElement >= cWords)
    {
        SPDBG_ASSERT(FALSE);
        return E_INVALIDARG;
    }

    _SPPATHENTRY *pPath = NULL;

    pPath = STACK_ALLOC(_SPPATHENTRY, cWords);
    if (!pPath)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        const SPPHRASEELEMENT *pElem = pSPPhrase->pElements;
        for(ULONG i = 0; i < cWords; i++, pElem++)
        {
            // we don't really need the handles for i < ulFirstElement
            // pPath[i].hWord = 0;
            pPath[i].elem.pszDisplayText = pElem->pszDisplayText;
            pPath[i].elem.pszLexicalForm = pElem->pszLexicalForm;
            pPath[i].elem.pszPronunciation = pElem->pszPronunciation;
        }

        //
        // Need to look up the word handles here.
        //

        ResolveWordHandles( pPath, cWords, FALSE );

        //
        // And then parse from phrase
        //

        WordsParsed wordsParsed;

        hr = InternalParseFromPhrase( pPhrase,
                                     pSPPhrase,
                                     pPath, 
                                     ulFirstElement, 
                                     FALSE,     // fIsITN
                                     FALSE,     // fIsHypotesis
                                     &wordsParsed);

        if(pulWordsParsed)
        {
            *pulWordsParsed = wordsParsed.ulWordsParsed;
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/**********************************************************************************
* ParseFromTransitions *
*----------------------*
*   Description:
*       Simple, greedy-topdown search given a rule. Uses ConstructParseTree() to
*       construct the parse tree (using CStateInfoListElement) and 
*       WalkParseTree to constuct the result SPPHRASE.
*
*   Return:
*       HRESULT -- S_OK if parse was found
*       ppPhrase  -- result phrase (currently only containing terminals, but will
*                    eventually include the entire parse tree).
*
************************************************************** philsch ***********/

STDMETHODIMP CCFGEngine::ParseFromTransitions(const SPPARSEINFO * pParseInfo, 
                                              ISpPhraseBuilder **ppPhrase)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::ParseFromTransitions");
    HRESULT hr = S_OK;

    SPRULEENTRY RuleInfo;
    CParseNode *pParseTree = NULL;

    if ( SP_IS_BAD_WRITE_PTR(ppPhrase) )
    {
        hr = E_POINTER;
    }
    else if(
        SP_IS_BAD_READ_PTR(pParseInfo) || 
        SP_IS_BAD_READ_PTR(pParseInfo->pPath) ||
        (pParseInfo->cbSize != sizeof(SPPARSEINFO)) ||
        (pParseInfo->cTransitions <1) ||
        ((pParseInfo->ulSREnginePrivateDataSize == 0) && (pParseInfo->pSREnginePrivateData != NULL)) ||
        (pParseInfo->ulSREnginePrivateDataSize && 
        SPIsBadReadPtr(pParseInfo->pSREnginePrivateData, pParseInfo->ulSREnginePrivateDataSize)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppPhrase = NULL;
        RuleInfo.hRule = pParseInfo->hRule;
        hr = GetRuleInfo(&RuleInfo, SPRIO_NONE);     // Validates the rule handle for us
    }

    _SPPATHENTRY *pPath = NULL;
    if (SUCCEEDED(hr))
    {
        pPath = (_SPPATHENTRY *)pParseInfo->pPath;
    }

    //
    // Create the result phrase
    //
    CComPtr<_ISpCFGPhraseBuilder> cpResultPhrase;
    if (S_OK == hr)
    {
        hr = cpResultPhrase.CoCreateInstance(CLSID_SpPhraseBuilder);
    }

    if (S_OK == hr)
    {
        hr = cpResultPhrase->InitFromCFG(this, pParseInfo);
    }

    //
    // Add the Phrase Elements.
    //
    SPPHRASEELEMENT* pPhraseElement = NULL;
    if (S_OK == hr)
    {
        pPhraseElement = STACK_ALLOC(SPPHRASEELEMENT,pParseInfo->cTransitions);
        memset(pPhraseElement, 0, sizeof(SPPHRASEELEMENT)*pParseInfo->cTransitions);

        for (ULONG i = 0; i < pParseInfo->cTransitions; i++)
        {
            const WCHAR *pszStringBlobText = NULL;
            if ((pPath[i].elem.pszDisplayText == NULL ||
                 pPath[i].elem.pszLexicalForm == NULL ||
                 pPath[i].elem.pszPronunciation == NULL) &&
                 ((pszStringBlobText = TextOf(pPath[i].hTransition)) != NULL))
            {
                WCHAR *pszText = pszText = STACK_ALLOC(WCHAR, wcslen(pszStringBlobText) +1);
                if (pszText)
                {
                    wcscpy(pszText, pszStringBlobText);
                    hr = AssignTextPointers(pszText, &pPhraseElement[i].pszDisplayText, 
                                            &pPhraseElement[i].pszLexicalForm, 
                                            &pPhraseElement[i].pszPronunciation);
                    if (SUCCEEDED(hr))
                    {
                        // clean up display text
                        WCHAR *p = const_cast<WCHAR*>(pPhraseElement[i].pszDisplayText);
                        WCHAR *q = p;
                        while (*p)
                        {
                            if (*p == L'\\')
                            {
                                p++;
                            }
                            *q++ = *p++;
                        }
                        *q = 0;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                if (SUCCEEDED(hr))
                {
                    if (pPath[i].elem.pszDisplayText)
                    {
                        pPhraseElement[i].pszDisplayText = pPath[i].elem.pszDisplayText;
                    }
                    if (pPath[i].elem.pszLexicalForm)
                    {
                        pPhraseElement[i].pszLexicalForm = pPath[i].elem.pszLexicalForm;
                    }
                    if (pPath[i].elem.pszPronunciation)
                    {
                        pPhraseElement[i].pszPronunciation = pPath[i].elem.pszPronunciation;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                // just point to the engine data
                pPhraseElement[i].pszDisplayText = pPath[i].elem.pszDisplayText;
                pPhraseElement[i].pszLexicalForm = pPath[i].elem.pszLexicalForm;
                pPhraseElement[i].pszPronunciation = pPath[i].elem.pszPronunciation;
            }

            if (SUCCEEDED(hr))
            {
                pPhraseElement[i].bDisplayAttributes = pPath[i].elem.bDisplayAttributes;
                pPhraseElement[i].ulAudioStreamOffset = pPath[i].elem.ulAudioStreamOffset;
                pPhraseElement[i].ulAudioTimeOffset = pPath[i].elem.ulAudioTimeOffset;
                pPhraseElement[i].ulAudioSizeBytes = pPath[i].elem.ulAudioSizeBytes;
                pPhraseElement[i].ulAudioSizeTime = pPath[i].elem.ulAudioSizeTime;
                pPhraseElement[i].ActualConfidence = pPath[i].elem.ActualConfidence;
                pPhraseElement[i].Reserved = pPath[i].elem.Reserved;
                pPhraseElement[i].SREngineConfidence = pPath[i].elem.SREngineConfidence;

                CTransitionId tid = CTransitionId(pPath[i].hTransition);
                CCFGGrammar * pGram = m_pGrammars[tid.GrammarId()];
//                SPDBG_ASSERT(pGram && !(SPCFGARC*)(pGram->m_Header.pArcs + tid.ArcIndex())->fRuleRef);
                SPCFGARC *pArc = pGram->m_Header.pArcs + tid.ArcIndex();
                pPhraseElement[i].RequiredConfidence = (pArc->fLowConfRequired) ? SP_LOW_CONFIDENCE :
                                                       (pArc->fHighConfRequired) ? SP_HIGH_CONFIDENCE :
                                                       SP_NORMAL_CONFIDENCE;
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = cpResultPhrase->AddElements(pParseInfo->cTransitions, pPhraseElement);
        }
    }

    //
    // Build the parse tree
    //
    WordsParsed wordsParsed;
    if (SUCCEEDED(hr))
    {
        hr = ConstructParseTree(RuleInfo.hInitialState, pPath, FALSE, FALSE, 0, 
                                pParseInfo->cTransitions, pParseInfo->fHypothesis,
                                &wordsParsed, &pParseTree, NULL);
    }
    if (S_OK == hr || S_FALSE == hr || SP_PARTIAL_PARSE_FOUND == hr)
    {
        if (!pParseInfo->fHypothesis && (wordsParsed.ulWordsParsed != pParseInfo->cTransitions) ||
            SP_PARTIAL_PARSE_FOUND == hr)
        {
            hr = SP_NO_PARSE_FOUND;
        }
        else
        {
            hr = S_OK;
            //
            // Create the root node.
            //
            CParseNode *pTreeRoot = NULL;
            hr = m_mParseNodeList.RemoveFirstOrAllocateNew(&pTreeRoot);

            if (S_OK == hr)
            {
                memset( pTreeRoot, 0, sizeof( CParseNode ) );
                pTreeRoot->m_pLeft  = pParseTree;
                //
                // Do an epsilon transition instead of a rule transition to avoid
                // creating a top level rule transition.
                //
                pTreeRoot->Type     = SPTRANSEPSILON;
                pTreeRoot->hRule    = RuleInfo.hRule;
                pTreeRoot->ulFirstElement = 0;
                pTreeRoot->ulCountOfElements = wordsParsed.ulWordsParsed;

                GetPropertiesOfRule(RuleInfo.hRule, 
                                 &pTreeRoot->pszRuleName, 
                                 &pTreeRoot->ulRuleId,
                                 &pTreeRoot->fInvokeInterpreter);

                pParseTree = pTreeRoot;
            }
        }
    }

    //
    // We have a successful parse.
    //
    if (S_OK == hr)
    {        
        //
        // Extract the properties and invoke the interpreter.
        //
        CSpPhrasePtr cpPhrase(cpResultPhrase, &hr);
        
        if (SUCCEEDED(hr))
        {
            signed char Confidence = _CalcMultipleWordConfidence(cpPhrase, cpPhrase->Rule.ulFirstElement, cpPhrase->Rule.ulCountOfElements);
            hr = cpResultPhrase->SetTopLevelRuleConfidence(Confidence);
        }

        CTIDArray * pArcList = new CTIDArray(pParseInfo->cTransitions, pParseInfo->cTransitions);
        if (!pArcList)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            // construct the arclist here so that it matches the best parse tree
            hr = pArcList->ConstructFromParseTree(pParseTree);
        }

        if (SUCCEEDED(hr))
        {
            hr = WalkParseTree(pParseTree, FALSE, pParseInfo->fHypothesis, NULL, NULL, pArcList, 0, pParseInfo->cTransitions, cpResultPhrase, cpPhrase);
        }
        delete pArcList;
    }

    if (S_OK == hr)
    {
        *ppPhrase = cpResultPhrase.Detach();
    }    

    //
    // Free the parse tree.
    //
    if (pParseTree)
    {
        FreeParseTree(pParseTree);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}



/****************************************************************************
* CCFGEngine::CreateParseHashes *
*-------------------------------*
*   Description:
*
*   Returns:
*
**************************************************************** agarside ***/

HRESULT CCFGEngine::CreateParseHashes(void)
{
    if( m_RuleStackList == NULL )
    {
        m_RuleStackList = new CSpBasicList<CRuleStack>*[RULESTACKHASHSIZE];
        if (!m_RuleStackList)
        {
            return E_OUTOFMEMORY;
        }
        memset(m_RuleStackList, 0, sizeof (CSpBasicList<CRuleStack> *) * RULESTACKHASHSIZE);
    }

    if( m_SearchNodeList == NULL )
    {
        m_SearchNodeList = new CSpBasicList<CSearchNode>*[SEARCHNODEHASHSIZE];
        if (!m_SearchNodeList)
        {
            return E_OUTOFMEMORY;
        }
        memset(m_SearchNodeList, 0, sizeof (CSpBasicList<CSearchNode> *) * SEARCHNODEHASHSIZE);
    }
    return S_OK;
}

/****************************************************************************
* CCFGEngine::DeleteParseHashes *
*-------------------------------*
*   Description:
*
*   Returns:
*
**************************************************************** agarside ***/

HRESULT CCFGEngine::DeleteParseHashes( BOOL final )
{
    SPDBG_ASSERT( m_SearchNodeList != NULL );
    SPDBG_ASSERT( m_RuleStackList  != NULL );
    UINT i;

    for (i=0; i<RULESTACKHASHSIZE; i++)
    {
        if (m_RuleStackList[i])
        {
            CRuleStack * pNode;
            while ( pNode = m_RuleStackList[i]->RemoveFirst() )
            {
                FreeRuleStack( pNode );
            }

            m_RuleStackList[i]->m_pFirst = NULL;

            if( TRUE == final )
            {
                delete m_RuleStackList[i];
            }
        }
    }

    for (i=0; i<SEARCHNODEHASHSIZE; i++)
    {
        if (m_SearchNodeList[i])
        {
            CSearchNode * pNode;
            while ( pNode = m_SearchNodeList[i]->RemoveFirst() )
            {
                FreeSearchNode( pNode );
            }

            m_SearchNodeList[i]->m_pFirst = NULL;

            if( TRUE == final )
            {
                delete m_SearchNodeList[i];
            }
        }
    }

    if( TRUE == final )
    {
        if( m_RuleStackList )
        {
            delete [] m_RuleStackList;
            m_RuleStackList = NULL;
        }

        if( m_SearchNodeList )
        {
            delete [] m_SearchNodeList;
            m_RuleStackList = NULL;
        }

    }

    return S_OK;
}

/****************************************************************************
* CCFGEngine::FindCreateRuleStack *
*---------------------------------*
*   Description:
*
*   Returns:
*
**************************************************************** agarside ***/

HRESULT CCFGEngine::FindCreateRuleStack(CRuleStack **pNewRuleStack, CRuleStack *pRuleStack, SPTRANSITIONID TransitionId, SPSTATEHANDLE hRuleFollowerState)
{
    SPDBG_ASSERT(m_RuleStackList);
    SPDBG_ASSERT(pNewRuleStack);
    UINT hash = CRuleStack::GetHashEntry(pRuleStack, TransitionId);
    if (m_RuleStackList[hash] == NULL)
    {
        m_RuleStackList[hash] = new CSpBasicList<CRuleStack>;
        if (!m_RuleStackList[hash])
        {
            return E_OUTOFMEMORY;
        }
    }
    CRuleStack *pTmpStack = m_RuleStackList[hash]->m_pFirst;
    *pNewRuleStack = NULL;
    HRESULT hr = S_OK;

    while (pTmpStack)
    {
        if (pTmpStack->m_pParent == pRuleStack &&
            pTmpStack->m_TransitionId == TransitionId)
        {
            *pNewRuleStack = pTmpStack;
            break;
        }
        pTmpStack = pTmpStack->m_pNext;
    }
    if (!pTmpStack)
    {
        hr = AllocateRuleStack( pNewRuleStack );
        if (FAILED(hr) )
        {
            return E_OUTOFMEMORY;
        }
        (*pNewRuleStack)->Init(pRuleStack, TransitionId, hRuleFollowerState, 0);

        m_RuleStackList[hash]->AddNode(*pNewRuleStack);
        hr = S_FALSE;
    }

    return hr;
}

/****************************************************************************
* CCFGEngine::FindCreateSearchNode *
*----------------------------------*
*   Description:
*
*   Returns:
*
**************************************************************** agarside ***/

HRESULT CCFGEngine::FindCreateSearchNode(CSearchNode **pNewSearchNode, CRuleStack *pRuleStack, SPSTATEHANDLE hState, UINT cTransitions)
{
    SPDBG_ASSERT(m_SearchNodeList);
    SPDBG_ASSERT(pNewSearchNode);
    UINT hash = CSearchNode::GetHashEntry(pRuleStack, hState, cTransitions);
    if (m_SearchNodeList[hash] == NULL)
    {
        m_SearchNodeList[hash] = new CSpBasicList<CSearchNode>;
        if (!m_SearchNodeList[hash])
        {
            return E_OUTOFMEMORY;
        }
    }
    CSearchNode *pTmpSearchNode = m_SearchNodeList[hash]->m_pFirst;
    *pNewSearchNode = NULL;
    HRESULT hr = S_OK;

    while (pTmpSearchNode)
    {
        if (pTmpSearchNode->m_pStack == pRuleStack &&
            pTmpSearchNode->m_hState == hState &&
            pTmpSearchNode->m_cTransitions == cTransitions)
        {
            *pNewSearchNode = pTmpSearchNode;
            break;
        }
        pTmpSearchNode = pTmpSearchNode->m_pNext;
    }

    if (!pTmpSearchNode)
    {
        hr = AllocateSearchNode( pNewSearchNode );
        if( FAILED(hr) )
        {
            return hr;
        }
        (*pNewSearchNode)->Init(pRuleStack, hState, cTransitions);
        m_SearchNodeList[hash]->AddNode(*pNewSearchNode);
        hr = S_FALSE;
    }
    return hr;
}

/**********************************************************************************
* RestructureParseTree *
*----------------------*
*   Description:
*
*   Return:
*
************************************************************** agarside ***********/

HRESULT CCFGEngine::RestructureParseTree(CParseNode *pParseNode, BOOL *pfDeletedElements)
{
    SPDBG_FUNC("CCFGEngine::RestructureParseTree");
    HRESULT hr = S_OK;

    CParseNode *pFirstNode    = pParseNode;
    CParseNode *pTmpParseNode = pParseNode;
    CParseNode *pFirstRule    = NULL;

    // Remove excess wildcard nodes if in EmulateRecognition
    ULONG ulElementNumber = 0;
    ULONG ulRemovedElements = 0;

    while(pTmpParseNode)
    {
        if(pTmpParseNode->Type != SPTRANSRULE && pTmpParseNode->Type != SPTRANSEPSILON)
        {
            if(pfDeletedElements)
            {
                pfDeletedElements[ulElementNumber] = FALSE;
            }
            ulElementNumber++;
        }

        if(pTmpParseNode->Type == SPTRANSWILDCARD && pTmpParseNode->fRedoWildcard)
        {
            if(pTmpParseNode->m_pParent)
            {
                pTmpParseNode->m_pParent->m_pRight = pTmpParseNode->m_pRight;
            }
            if(pTmpParseNode->m_pRight)
            {
                pTmpParseNode->m_pRight->m_pParent = pTmpParseNode->m_pParent;
            }

            CParseNode *pDelParseNode = pTmpParseNode;
            pTmpParseNode = pTmpParseNode->m_pRight;

            m_mParseNodeList.AddNode(pDelParseNode);

            ulRemovedElements++;
            if(pfDeletedElements)
            {
                pfDeletedElements[ulElementNumber-1] = TRUE;
            }

            if(pTmpParseNode)
            {
                for(CParseNode *pTmpParseNode2 = pTmpParseNode->m_pParent; pTmpParseNode2; pTmpParseNode2 = pTmpParseNode2->m_pParent)
                {
                    pTmpParseNode2->ulCountOfElements--;
                }
            }
        }
        else
        {
            pTmpParseNode->ulFirstElement -= ulRemovedElements;
            pTmpParseNode = pTmpParseNode->m_pRight;
        }

    }

    while (pParseNode)
    {
        if (pParseNode->m_pRight && pParseNode->m_pRight->fRuleExit)
        {
            pTmpParseNode = pParseNode->m_pRight;
            pFirstRule    = pParseNode;

            // Find reattachment point up tree.

            while (pTmpParseNode && pTmpParseNode->fRuleExit)
            {
                if (pFirstRule->Type == SPTRANSRULE)
                {
                    pFirstRule = pFirstRule->m_pParent;
                }
                while (pFirstRule && (pFirstRule->Type != SPTRANSRULE || pFirstRule->m_pRight))
                {
                    pFirstRule = pFirstRule->m_pParent;
                }

                pTmpParseNode = pTmpParseNode->m_pRight;
            }
            if (pTmpParseNode)
            {
                // Reattach first non-rule exit node at that point.
                SPDBG_ASSERT(pFirstRule->m_pRight == NULL);
                pFirstRule->m_pRight = pTmpParseNode;
                pTmpParseNode->m_pParent->m_pRight = NULL;
                pTmpParseNode->m_pParent = pFirstRule;
                // Delete rule exit parse nodes.
                FreeParseTree(pParseNode->m_pRight);
                pParseNode->m_pRight = NULL;
                // Continue restructure from new attachment point.
                pParseNode = pTmpParseNode;
            }
            else
            {
                // We have we reached the end of the parse list.
                // Delete rule exit nodes.
                FreeParseTree(pParseNode->m_pRight);
                pParseNode->m_pRight = NULL;
                pParseNode = NULL;
            }
        }
        else
        {
            if (pParseNode->Type == SPTRANSRULE)
            {
                // Move rule transitions to left branch.
                SPDBG_ASSERT(pParseNode->m_pLeft == NULL);
                pParseNode->m_pLeft  = pParseNode->m_pRight;
                pParseNode->m_pRight = NULL;
                pParseNode = pParseNode->m_pLeft;
            }
            else
            {
                pParseNode = pParseNode->m_pRight;
            }
        }
    }

    // Now have forked tree structure required by WalkParseTree
    // Need to readjust elements counts.
    RecurseAdjustCounts(pFirstNode, 0);

    return S_OK;
} /* CCFGEngine::RestructureParseTree */

/**********************************************************************************
* RecurseAdjustCounts *
*---------------------*
*   Description:
*
*   Return:
*
************************************************************** agarside ***********/

HRESULT CCFGEngine::RecurseAdjustCounts(CParseNode *pParseNode, UINT iRemove)
{
    if (pParseNode->m_pLeft)
    {
        if (pParseNode->m_pRight)
        {
            SPDBG_ASSERT(pParseNode->ulCountOfElements >= pParseNode->m_pRight->ulCountOfElements);
            pParseNode->ulCountOfElements -= pParseNode->m_pRight->ulCountOfElements;
            RecurseAdjustCounts(pParseNode->m_pLeft, pParseNode->m_pRight->ulCountOfElements);
            RecurseAdjustCounts(pParseNode->m_pRight, iRemove);
        }
        else
        {
            SPDBG_ASSERT(pParseNode->ulCountOfElements >= iRemove);
            pParseNode->ulCountOfElements -= iRemove;
            RecurseAdjustCounts(pParseNode->m_pLeft, iRemove);
        }
    }
    else if (pParseNode->m_pRight)
    {
        SPDBG_ASSERT(pParseNode->ulCountOfElements >= pParseNode->m_pRight->ulCountOfElements);
        pParseNode->ulCountOfElements -= pParseNode->m_pRight->ulCountOfElements;
        RecurseAdjustCounts(pParseNode->m_pRight, iRemove);
    }
    else
    {
        SPDBG_ASSERT(pParseNode->ulCountOfElements >= iRemove);
        pParseNode->ulCountOfElements -= iRemove;
    }
    return S_OK;
} /* CCFGEngine::RecurseAdjustCounts */

/**********************************************************************************
* ConstructParseTree *
*--------------------*
*   Description:
*       Builds the parse tree by recursively expanding state fanouts.
*       This version is trying to match transition IDs.
*
*   Return:
*       S_OK                    -- Grammar ending parse found. ALL WORDS USED.
*       SP_PARTIAL_PARSE_FOUND  -- Grammar ending parse found. NOT ALL WORDS USED.
*       S_FALSE                 -- Non grammar ending parse found - all words have been used.
*       SP_NO_PARSE_FOUND       -- No parse found at all.
*       ppParseNode             -- parse tree
*       pulWordsParsed          -- number of terminals parsed by this rule
*
************************************************************** philsch ***********/

HRESULT CCFGEngine::ConstructParseTree(CStateHandle hState, 
                                  const _SPPATHENTRY *pPath,
                                  const BOOL fUseWordHandles,
                                  const BOOL fIsITN,
                                  const ULONG ulFirstTransition,
                                  const ULONG cTransitions, 
                                  const BOOL fHypothesis,
                                  WordsParsed *pWordsParsed,
                                  CParseNode **ppParseNode,
                                  BOOL *pfDeletedElements)
{
    SPDBG_FUNC("CCFGEngine::ConstructParseTree");
    HRESULT hr = S_OK;

    //
    // Parameter validation.
    //

    if (SP_IS_BAD_WRITE_PTR(ppParseNode) || SP_IS_BAD_WRITE_PTR(pWordsParsed))
    {
        return E_POINTER;
    }
    *ppParseNode = NULL;
    pWordsParsed->Zero();

    hr = ValidateHandle(hState);
    if (FAILED(hr))
    {
        SPDBG_ASSERT(hState != 0); // ValidateHandle should not fail this. Handle this case lower down.
        return hr;
    }
    
    hr = CreateParseHashes();
    if (SUCCEEDED(hr))
    {
        hr = InternalConstructParseTree(hState, pPath, fUseWordHandles, fIsITN, ulFirstTransition, cTransitions,
                                        fHypothesis, pWordsParsed, ppParseNode, NULL);
        // InternalConstructParseTree cannot easily detect the following state.
        if (SP_PARTIAL_PARSE_FOUND == hr && pWordsParsed->ulWordsParsed == 0)
        {
            hr = SP_NO_PARSE_FOUND;
        }
        SPDBG_ASSERT(SP_NO_PARSE_FOUND != hr || pWordsParsed->ulWordsParsed == 0);
        DeleteParseHashes( FALSE ); // Ignore return value.
    }

    // Now restructure linear parse list into parse tree in the format that WalkParseTree requires.
    if (S_OK == hr || SP_PARTIAL_PARSE_FOUND == hr || S_FALSE == hr)
    {
        RestructureParseTree(*ppParseNode, pfDeletedElements);
    }

    return hr;
} /* CCFGEngine::ConstructParseTree */

/**********************************************************************************
* InternalConstructParseTree *
*----------------------------*
*   Description:
*       Builds the parse tree by recursively expanding state fanouts.
*       This version is trying to match transition IDs.
*
*   Return:
*       S_OK                    -- Grammar ending parse found. ALL WORDS USED.
*       SP_PARTIAL_PARSE_FOUND  -- Grammar ending parse found. NOT ALL WORDS USED.
*       S_FALSE                 -- Non grammar ending parse found - all words have been used.
*       SP_NO_PARSE_FOUND       -- No parse found at all.
*       ppParseNode             -- parse tree
*       pulWordsParsed          -- number of terminals parsed by this rule
*
************************************************************** philsch ***********/

HRESULT CCFGEngine::InternalConstructParseTree(CStateHandle hState, 
                                  const _SPPATHENTRY *pPath,
                                  const BOOL fUseWordHandles,
                                  const BOOL fIsITN,
                                  const ULONG ulFirstTransition,
                                  const ULONG cTransitions,
                                  const BOOL fHypothesis,
                                  WordsParsed *pWordsParsed,
                                  CParseNode **ppParseNode,
                                  CRuleStack *pRuleStack)
{
    SPDBG_FUNC("CCFGEngine::InternalConstructParseTree");

    HRESULT hr = S_OK;
    BOOL bOnlyEpsilon = false;
    HRESULT parsehr = SP_NO_PARSE_FOUND;

    // used to find the maximal parse
    CParseNode *pBestParse   = NULL;
    WordsParsed bestWordsParsed;
    WordsParsed wordsParsedLeft;
    WordsParsed wordsParsedRight;

    // parameter validation
    if (ulFirstTransition > cTransitions)
    {
        return SP_NO_PARSE_FOUND;
    }
    else
    {
        if (ulFirstTransition == cTransitions)
        {
            bOnlyEpsilon = true;
        }
    }

    if (hState == 0 || hState.FirstArcIndex() == 0)
    {
        // Have reached the end of a rule.
        if (pRuleStack)
        {
            // Exiting a rule.
            hr = m_mParseNodeList.RemoveFirstOrAllocateNew(&pBestParse);
            if (SUCCEEDED(hr))
            {
                // Now call right parse path with correct values.
                memset(pBestParse,0,sizeof(CParseNode));
                pBestParse->fRuleExit = TRUE;
                pBestParse->Type      = SPTRANSRULE;
                // Irrelevant since these are removed and fRuleExit is set to true.
                hr = InternalConstructParseTree(pRuleStack->m_hFollowState,
                                        pPath, fUseWordHandles, fIsITN, ulFirstTransition,
                                        cTransitions, fHypothesis, pWordsParsed,
                                        &pBestParse->m_pRight, pRuleStack->m_pParent);
                // Whatever value of hr, following variables have been initialized to 0, NULL.
                pBestParse->ulCountOfElements = pWordsParsed->ulWordsParsed;
                if (pBestParse->m_pRight)
                {
                    pBestParse->m_pRight->m_pParent = pBestParse;
                }
                *ppParseNode = pBestParse;
            }
        }
        else
        {
            // End of grammar. Hence end of recursion.
            hr = ((ulFirstTransition == cTransitions)?S_OK:SP_PARTIAL_PARSE_FOUND);
        }

        return hr;
    }

    CSearchNode *pSearchNode = NULL;
    hr = FindCreateSearchNode(&pSearchNode, pRuleStack, hState, ulFirstTransition);
    SPDBG_ASSERT(SUCCEEDED(hr));
    if (S_OK == hr && (!fUseWordHandles || fIsITN))
    {
        // This path has already been examined in identical circumstances.
        return SP_NO_PARSE_FOUND;
    }

    // grab it from the list
    CStateInfoListElement *pStateInfo = NULL;

    // get state info
    hr = AllocateStateInfo(hState, &pStateInfo);

    if (SUCCEEDED(hr))
    {
        hr = m_mParseNodeList.RemoveFirstOrAllocateNew(&pBestParse);
    }
    if (SUCCEEDED(hr))
    {
        pBestParse->m_pLeft = pBestParse->m_pRight = NULL;
        ULONG cTransitionEntries = pStateInfo->cEpsilons + pStateInfo->cRules + pStateInfo->cWords + 
                                   pStateInfo->cSpecialTransitions;

        if (cTransitionEntries == 0)
        {
            m_mStateInfoList.AddNode(pStateInfo);
            FreeParseTree(pBestParse);
            return SP_NO_PARSE_FOUND;
        }

        BOOL fRedoWildcard = FALSE;
        for (int i = cTransitionEntries-1; i >= 0 || fRedoWildcard; i--)
        {
            if(fRedoWildcard)
            {
                i++; // Wildcards with emulate recognition get an extra parse as they can swallow multiple words
            }

            // default to NO_PARSE_FOUND;
            hr = SP_NO_PARSE_FOUND;
            wordsParsedLeft.Zero();
            wordsParsedRight.Zero();
            CParseNode ParseNode;

            switch (pStateInfo->pTransitions[i].Type)
            {
            case SPTRANSWORD: // 1
                {
                    if (!bOnlyEpsilon)
                    {
                        if (
                            (!fUseWordHandles && (pStateInfo->pTransitions[i].ID == CTransitionId(pPath[ulFirstTransition].hTransition))) ||
                            (fUseWordHandles && pStateInfo->pTransitions[i].hWord == pPath[ulFirstTransition].hWord) 
                            )
                        {

#ifdef _DEBUG
                            if( fUseWordHandles )
                            {
                                ParseNode.pszWordDisplayText = TextOf( pStateInfo->pTransitions[i].hWord );
                            }
                            if( ParseNode.pszWordDisplayText == NULL )
                            {
                                ParseNode.pszWordDisplayText = pPath[ulFirstTransition].elem.pszDisplayText;
                            }
#endif

                            if (SUCCEEDED(hr))
                            {
                                hr = InternalConstructParseTree(pStateInfo->pTransitions[i].hNextState, 
                                                        pPath, fUseWordHandles, fIsITN, ulFirstTransition + 1,
                                                        cTransitions, fHypothesis, &wordsParsedRight, 
                                                        &ParseNode.m_pRight, pRuleStack);
                                // Add in word we have just parsed.
                                wordsParsedLeft.ulWordsParsed = 1;
                                wordsParsedRight.ulWordsParsed++;
                            }
                        }
                    }
                }
                break;
            case SPTRANSRULE: // 2
                {
                    // non-empty dynamic rule
                    if (pStateInfo->pTransitions[i].hRuleInitialState != 0)
                    {
                        if( !bOnlyEpsilon && fUseWordHandles )
                        {
                            CRuleHandle cr = pStateInfo->pTransitions[i].hRule;
                            RUNTIMERULEENTRY * pRuleEntry = RuleOf( cr );

                            
                            if( pRuleEntry->eCacheStatus == CACHE_VOID )
                            {
                                CreateCache( cr );
                            }

                            if( pRuleEntry->eCacheStatus == CACHE_VALID && 
                                FALSE == IsInCache( pRuleEntry, pPath[ulFirstTransition].hWord )
                                )
                            {
                                break;
                            }
                        }
                        // if this is a property rule then first try a full parse (fHypothesis == FALSE)
                        // and if it fails then do a partial parse but don't invoke the interpreter later ...
                        if (GetPropertiesOfRule(pStateInfo->pTransitions[i].hRule,
                                            &ParseNode.pszRuleName, &ParseNode.ulRuleId,
                                            &ParseNode.fInvokeInterpreter))
                        {
                            CRuleStack *pNewRuleStack = NULL;
                            hr = FindCreateRuleStack(&pNewRuleStack, pRuleStack, pStateInfo->pTransitions[i].ID, pStateInfo->pTransitions[i].hNextState);
                            SPDBG_ASSERT(pNewRuleStack->m_hFollowState == pStateInfo->pTransitions[i].hNextState);

                            
                            hr = InternalConstructParseTree(pStateInfo->pTransitions[i].hRuleInitialState, 
                                                    pPath, fUseWordHandles, fIsITN, ulFirstTransition, cTransitions, 
                                                    fHypothesis, &wordsParsedRight, &ParseNode.m_pRight, pNewRuleStack);
                        }
                    }
                }
                break;
            case SPTRANSEPSILON:
                {
                    if (SUCCEEDED(hr))
                    {
                        hr = InternalConstructParseTree(pStateInfo->pTransitions[i].hNextState, 
                                                pPath, fUseWordHandles, fIsITN, ulFirstTransition,
                                                cTransitions, fHypothesis, &wordsParsedRight, &ParseNode.m_pRight, pRuleStack);
                    }
                }
                break;
            case SPTRANSTEXTBUF:
                {
                    if (fUseWordHandles)
                    {
                        hr = S_FALSE;
                        break;
                    }

                    if (!bOnlyEpsilon)
                    {
                        if (pStateInfo->pTransitions[i].ID == CTransitionId(pPath[ulFirstTransition].hTransition))
                        {
                            // "consume all text buffer words now"
                            ULONG idx = ulFirstTransition +1;
                            while ((idx < cTransitions) && 
                                   (pStateInfo->pTransitions[i].ID == CTransitionId(pPath[idx].hTransition)))
                            {
                                idx++;
                            }
                            hr = InternalConstructParseTree(pStateInfo->pTransitions[i].hNextState, 
                                                    pPath, fUseWordHandles, fIsITN, idx,
                                                    cTransitions, fHypothesis, &wordsParsedRight, 
                                                    &ParseNode.m_pRight, pRuleStack);
                            // Add in words we have just parsed.
                            wordsParsedLeft.ulWordsParsed   = idx - ulFirstTransition; 
                            wordsParsedRight.Add(&wordsParsedLeft);
                        }
                    }
                }
                break;
            case SPTRANSWILDCARD:
                {
                    // Can't have wildcard rules in ITN grammar
                    if (fIsITN)
                    {
                        hr = S_FALSE;
                    }
                     // Allow wildcards in emulate recognition - they can parse multiple words
                    else if (fUseWordHandles)
                    {

                        if(!fRedoWildcard)
                        {
                            // First try parsing the next word with the same wildcard
                            hr = InternalConstructParseTree(hState, 
                                                    pPath, fUseWordHandles, fIsITN, ulFirstTransition + 1,
                                                    cTransitions, fHypothesis, &wordsParsedRight, 
                                                    &ParseNode.m_pRight, pRuleStack);

                            if(ParseNode.m_pRight)
                            {
                                // If we did parse an extra word, mark it for deletion in the result phrase
                                ParseNode.m_pRight->fRedoWildcard = TRUE;
                            }
                            // Repeat the parse a second time
                            fRedoWildcard = TRUE;
                        }
                        else
                        {
                            // Now try parsing the next word with the next transition as normal
                            hr = InternalConstructParseTree(pStateInfo->pTransitions[i].hNextState, 
                                                    pPath, fUseWordHandles, fIsITN, ulFirstTransition + 1,
                                                    cTransitions, fHypothesis, &wordsParsedRight, 
                                                    &ParseNode.m_pRight, pRuleStack);

                            fRedoWildcard = FALSE;
                        }

                        // Add in word we have just parsed.
                        wordsParsedLeft.ulWordsParsed = 1;
                        wordsParsedLeft.ulWildcardWords = wordsParsedLeft.ulWordsParsed;
                        wordsParsedRight.Add(&wordsParsedLeft);
                    }
                    else
                    {
                        if (!bOnlyEpsilon)
                        {
                            // ParseFromTransitions wildcard
                            if (pStateInfo->pTransitions[i].ID == CTransitionId(pPath[ulFirstTransition].hTransition))
                            {
                                // "consume all wildcard transitions now"
                                ULONG idx = ulFirstTransition +1;
                                while ((idx < cTransitions) && 
                                       (pStateInfo->pTransitions[i].ID == CTransitionId(pPath[idx].hTransition)))
                                {
                                    idx++;
                                }
                                hr = InternalConstructParseTree(pStateInfo->pTransitions[i].hNextState, 
                                                        pPath, fUseWordHandles, fIsITN, idx,
                                                        cTransitions, fHypothesis, &wordsParsedRight, 
                                                        &ParseNode.m_pRight, pRuleStack);
                                // Add in words we have just parsed.
                                wordsParsedLeft.ulWordsParsed = idx - ulFirstTransition;
                                wordsParsedLeft.ulWildcardWords = wordsParsedLeft.ulWordsParsed;
                                wordsParsedRight.Add(&wordsParsedLeft);
                            }
                        }
                    }
                }
                break;
            case SPTRANSDICTATION:
                {
                    if (!bOnlyEpsilon)
                    {
                        if (fUseWordHandles || (pStateInfo->pTransitions[i].ID == CTransitionId(pPath[ulFirstTransition].hTransition)))
                        {
                            // simply match the next word since one transition equals one word
                            hr = InternalConstructParseTree(pStateInfo->pTransitions[i].hNextState, 
                                                    pPath, fUseWordHandles, fIsITN, ulFirstTransition + 1,
                                                    cTransitions, fHypothesis, &wordsParsedRight, 
                                                    &ParseNode.m_pRight, pRuleStack);
                            // Add in words we have just parsed.
                            wordsParsedLeft.ulWordsParsed = 1;
                            wordsParsedLeft.ulDictationWords = 1;
                            wordsParsedRight.Add(&wordsParsedLeft);
                        }
                    }
                }
                break;
            default:
                {
                    SPDBG_ASSERT(false); // should never get here
                }
            }

            LONG compareResult = wordsParsedRight.Compare(&bestWordsParsed);
            if ( ((compareResult >= 0) && hr == S_OK && parsehr != S_OK) ||
                 ((compareResult >  0) && hr == S_FALSE && fHypothesis) || 
                 ((compareResult >= 0) && hr == SP_PARTIAL_PARSE_FOUND && (parsehr == S_FALSE || parsehr == SP_NO_PARSE_FOUND)) ||
                 ((compareResult >  0) && (hr == SP_PARTIAL_PARSE_FOUND || hr == S_OK) ))
            {
                if( pBestParse->m_pRight )
                {
                    FreeParseTree(pBestParse->m_pRight);
                }

                memset(pBestParse,0,sizeof(CParseNode));
                pBestParse->ID = pStateInfo->pTransitions[i].ID;
                pBestParse->Type = pStateInfo->pTransitions[i].Type;
                pBestParse->ulFirstElement = ulFirstTransition;
                pBestParse->ulCountOfElements = wordsParsedRight.ulWordsParsed;
                switch (pBestParse->Type)
                {
                case SPTRANSWORD:
                    pBestParse->hWord = pStateInfo->pTransitions[i].hWord;
                    pBestParse->pszWordDisplayText = ParseNode.pszWordDisplayText;
                    pBestParse->RequiredConfidence = pStateInfo->pTransitions[i].RequiredConfidence;
                    break;
                case SPTRANSRULE:
                    pBestParse->hRule = pStateInfo->pTransitions[i].hRule;
                    pBestParse->fInvokeInterpreter = ParseNode.fInvokeInterpreter;
                    pBestParse->pszRuleName = ParseNode.pszRuleName;
                    pBestParse->ulRuleId = ParseNode.ulRuleId;
                    break;
                default:
                    break;
                }
                pBestParse->m_pRight = ParseNode.m_pRight;
                if (ParseNode.m_pRight)
                {
                    ParseNode.m_pRight->m_pParent = pBestParse;
                }
                bestWordsParsed = wordsParsedRight;
                parsehr = hr;
                if (S_OK == hr)
                {
                    // Found a complete parse that is also a grammar-end parse.
                    if(!fUseWordHandles || fIsITN)
                    {
                        // If doing real recognition or ITN no need to enumerate any more possibilities.
                        break;
                    }
                    // If doing parsing from text we continue if potentially better parses (fewer wildcard or dictation
                    else if(bestWordsParsed.ulDictationWords == 0 && bestWordsParsed.ulWildcardWords == 0)
                    {
                        break;
                    }
                }
            }
            else if( ParseNode.m_pRight )
            {
                FreeParseTree(ParseNode.m_pRight);
            }
        }
    }
    if (SP_NO_PARSE_FOUND != parsehr)
    {
        *pWordsParsed = bestWordsParsed;
        *ppParseNode    = pBestParse;
    }
    else
    {
        FreeParseTree(pBestParse); // could this be simple .Add() ???
    }

    m_mStateInfoList.AddNode(pStateInfo);

    if (fHypothesis &&
        parsehr == SP_NO_PARSE_FOUND &&
        ulFirstTransition == cTransitions)
    {
        // Non-grammar terminating paths are allowed for hypotheses.
        parsehr = S_FALSE;
    }
    hr = parsehr;

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* CCFGEngine::InternalConstructParseTree */

/**********************************************************************************
* WalkParseTree *
*---------------*
*   Description:
*       Top-down parsing algorithm using rule handle as starting point
*
*   Return:
*       HRESULT         S_OK = parsed
*       pResultPhrase   Phrase with elements (words) and properties
*
************************************************************** philsch ***********/

HRESULT CCFGEngine::WalkParseTree(CParseNode *pParseNode,
                                  const BOOL fIsITN,
                                  const BOOL fIsHypothesis,
                                  const SPPHRASEPROPERTYHANDLE hParentProperty,
                                  const SPPHRASERULEHANDLE hParentRule,
                                  const CTIDArray *pArcList, 
                                  const ULONG ulElementOffset,
                                  const ULONG ulCountOfElements,
                                  ISpPhraseBuilder *pResultPhrase,
                                  const SPPHRASE *pPhrase)
{

    SPDBG_FUNC("CCFGEngine::WalkParseTree");
    HRESULT hr = S_OK;
    SPPHRASEPROPERTYHANDLE hThisNodeProperty = NULL;
    SPPHRASERULEHANDLE hRule = hParentRule;

    if (pParseNode)
    {
        if (!fIsITN && (pParseNode->Type == SPTRANSRULE))
        {
            SPPHRASERULE rule;
            memset(&rule, 0, sizeof(rule));
            rule.pszName = pParseNode->pszRuleName;
            rule.ulId = pParseNode->ulRuleId;
            rule.ulFirstElement = pParseNode->ulFirstElement;
            rule.ulCountOfElements = pParseNode->ulCountOfElements;
            rule.SREngineConfidence = -1.0f;
            rule.Confidence = _CalcMultipleWordConfidence(pPhrase, rule.ulFirstElement, rule.ulCountOfElements);

            hr = pResultPhrase->AddRules(hParentRule, &rule, &hRule);
        }
        else if (!fIsITN && (pParseNode->Type == SPTRANSWORD))
        {
            SPPHRASEELEMENT *pElem = const_cast<SPPHRASEELEMENT*>(pPhrase->pElements);
            pElem[pParseNode->ulFirstElement].RequiredConfidence = pParseNode->RequiredConfidence;
        }

        if (SUCCEEDED(hr))
        {
            SPPHRASEPROPERTY prop;
            SPCFGSEMANTICTAG *pTag = NULL;
            ULONG ulGrammarId = 0;
            memset(&prop, 0, sizeof(prop));

            if ( GetPropertiesOfTransition(pParseNode->ID, &prop, &pTag, &ulGrammarId) )
            {
                //
                // Update the property structure.
                //
                if ((pParseNode->Type != SPTRANSEPSILON) && (pParseNode->Type != SPTRANSWORD))
                {
                    prop.ulFirstElement = pParseNode->ulFirstElement;
                    prop.ulCountOfElements = pParseNode->ulCountOfElements;
                }
                else
                {
                    SPDBG_ASSERT(pTag);
                    // find the range info by identifying the start and end arcs
                    //pArcList->m_ulCurrentIndex is used to keep track of the how many elements have been assigned properties on.
                    for (ULONG i = pArcList->m_ulCurrentIndex; i < pArcList->m_cArcs; i++)
                    {
                        CTransitionId tid = CTransitionId(pArcList->m_aTID[i].tid);
                        if ((pTag->StartArcIndex == tid.ArcIndex()) && (ulGrammarId == tid.GrammarId()))
                        {
                            prop.ulFirstElement = pArcList->m_aTID[i].ulIndex;
                            break;
                        }
                        else if ((pArcList->m_aTID[i].fIsWord == FALSE) && 
                                  pTag->fStartParallelEpsilonArc && (ulGrammarId == tid.GrammarId()))
                        {
                            CCFGGrammar * pGram = m_pGrammars[ulGrammarId];
                            SPDBG_ASSERT(pGram);
                            ULONG ulArcIndex = tid.ArcIndex();
                            ULONG ulTagArcIndex = pTag->StartArcIndex -1;
                            SPCFGARC *pArc = pGram->m_Header.pArcs + ulTagArcIndex;
                            BOOL fFoundInfo = FALSE;
                            while(pArc && !pArc->fLastArc && (ulArcIndex > 0))
                            {
                                if (ulArcIndex == ulTagArcIndex)
                                {
                                    prop.ulFirstElement = pArcList->m_aTID[i].ulIndex;
                                    fFoundInfo = TRUE;
                                    break;
                                }
                                pArc--;
                                ulTagArcIndex--;
                            }
                            if (fFoundInfo)
                            {
                                break;
                            }
                        }
                    }
                    BOOL fFoundInfo = FALSE;
                    for (; i < pArcList->m_cArcs; i++)
                    {
                        SPDBG_ASSERT(i < pArcList->m_cArcs);
                        CTransitionId tid = CTransitionId(pArcList->m_aTID[i].tid);
                        if ((pTag->EndArcIndex == tid.ArcIndex()) && (ulGrammarId == tid.GrammarId()))
                        {
                            prop.ulCountOfElements = pArcList->m_aTID[i].ulIndex - prop.ulFirstElement;
                            prop.ulCountOfElements += (pArcList->m_aTID[i].fIsWord ) ? 1 : 0;
                            fFoundInfo = TRUE;
                            break;
                        }
                        else if ((pArcList->m_aTID[i].fIsWord == FALSE) && 
                                  pTag->fEndParallelEpsilonArc && (ulGrammarId == tid.GrammarId()))
                        {
                            CCFGGrammar * pGram = m_pGrammars[ulGrammarId];
                            SPDBG_ASSERT(pGram);
                            ULONG ulArcIndex = tid.ArcIndex();
                            ULONG ulTagArcIndex = pTag->EndArcIndex -1;
                            SPCFGARC *pArc = pGram->m_Header.pArcs + ulTagArcIndex;
                            while(pArc && !pArc->fLastArc && (ulArcIndex > 0))
                            {
                                if (ulArcIndex == ulTagArcIndex)
                                {
                                    prop.ulCountOfElements = pArcList->m_aTID[i].ulIndex - prop.ulFirstElement;
                                    fFoundInfo = TRUE;
                                    break;
                                }
                                pArc--;
                                ulTagArcIndex--;
                            }
                            if (fFoundInfo)
                            {
                                break;
                            }
                        }
                    }
                    if (!fFoundInfo)
                    {
                        prop.ulFirstElement = pParseNode->ulFirstElement;
                        prop.ulCountOfElements = pParseNode->ulCountOfElements;
                        (const_cast<CTIDArray *>(pArcList))->m_ulCurrentIndex += pParseNode->ulCountOfElements;
                    }
                    else
                    {
                        (const_cast<CTIDArray *>(pArcList))->m_ulCurrentIndex = i + 1;
                    }
                }
 
                if (fIsHypothesis && ((prop.ulFirstElement + prop.ulCountOfElements) > (ulElementOffset + ulCountOfElements)))
                {
                    // trim if hypothesis
                    prop.ulCountOfElements = (ulElementOffset + ulCountOfElements) - prop.ulFirstElement;
                }
                SPDBG_ASSERT(prop.ulFirstElement + prop.ulCountOfElements <= (ulElementOffset + ulCountOfElements));            
                // Above assertion should never trigger now - a final recognition triggering this indicates a bug.
                prop.SREngineConfidence = -1.0f;
                prop.Confidence = _CalcMultipleWordConfidence(pPhrase, prop.ulFirstElement, prop.ulCountOfElements);
                hr = pResultPhrase->AddProperties(hParentProperty, &prop, &hThisNodeProperty);
            }

            if ( pParseNode->fInvokeInterpreter )
            {
                CInterpreterSite Site;
                CComPtr<ISpCFGInterpreter>cpInterpreter;

                CComPtr<_ISpCFGPhraseBuilder> cpNewPhrase;
                hr = cpNewPhrase.CoCreateInstance(CLSID_SpPhraseBuilder);

                if (SUCCEEDED(hr))
                {
                    SPDBG_ASSERT(pParseNode->pszRuleName);
                    SPPARSEINFO ParseInfo;
                    memset(&ParseInfo, 0, sizeof(SPPARSEINFO));
                    ParseInfo.cbSize = sizeof(SPPARSEINFO);
                    ParseInfo.hRule = pParseNode->hRule;
                    ParseInfo.ullAudioStreamPosition = pPhrase->ullAudioStreamPosition;
                    ParseInfo.ulAudioSize = pPhrase->ulAudioSizeBytes;
                    hr = cpNewPhrase->InitFromCFG(this, &ParseInfo);
                }
                if (SUCCEEDED(hr))
                {
                    hr = cpNewPhrase->AddElements(pPhrase->Rule.ulCountOfElements, pPhrase->pElements);
                }
                if (SUCCEEDED(hr))
                {
                    hr = GetInterpreter(pParseNode->hRule, &cpInterpreter) ? S_OK : E_FAIL;
                }
                if (SUCCEEDED(hr))
                {
                    Site.Initialize(this, pResultPhrase, pParseNode->pszRuleName, pParseNode->ulRuleId, 
                                    pParseNode->ulFirstElement, pParseNode->ulCountOfElements, hParentProperty, hThisNodeProperty, pParseNode->hRule);
                }
                if (SUCCEEDED(hr) && pParseNode->m_pLeft)
                {
                    hr = WalkParseTree(pParseNode->m_pLeft, fIsITN, fIsHypothesis, NULL /*hProperty*/, NULL /*hRule*/, pArcList,
                                       pParseNode->ulFirstElement, pParseNode->ulCountOfElements, cpNewPhrase, pPhrase);
                }
                if (SUCCEEDED(hr) && pParseNode->m_pRight)
                {
                    hr = WalkParseTree(pParseNode->m_pRight, fIsITN, fIsHypothesis, hParentProperty, hRule, pArcList,
                                       ulElementOffset, ulCountOfElements, pResultPhrase, pPhrase);
                }

                if (SUCCEEDED(hr))
                {
                    hr = cpInterpreter->Interpret(cpNewPhrase, pParseNode->ulFirstElement, pParseNode->ulCountOfElements, &Site);
                }
            }
            else
            {
                if (SUCCEEDED(hr) && pParseNode->m_pLeft)
                {
                    hr = WalkParseTree(pParseNode->m_pLeft, fIsITN, fIsHypothesis, 
                                       (hThisNodeProperty ? hThisNodeProperty : hParentProperty),
                                       hRule, pArcList,
                                       pParseNode->ulFirstElement, pParseNode->ulCountOfElements, pResultPhrase, pPhrase);
                }
                if (SUCCEEDED(hr) && pParseNode->m_pRight)
                {
                    hr = WalkParseTree(pParseNode->m_pRight, fIsITN, fIsHypothesis, hParentProperty, hParentRule, pArcList,
                                       ulElementOffset, ulCountOfElements, pResultPhrase, pPhrase);
                }
            }
        }
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

void CCFGEngine::ScanForSlash(WCHAR **pp)
{
    WCHAR *p = *pp;
    WCHAR *q = p;
    while(p && (*p != L'/') && (*p != 0))
    {
        if (*p == L'\\')
        {
            p ++;
        }
        *q = *p;
        p++;
        q++;
    }
    while(q < p)
    {
        *q = 0;
        q++;
    }
    *pp = p;
    return;
}

/****************************************************************************
* CCFGEngine::SetWordInfo *
*-------------------------*
*   Description:
*
*   Returns:
*
***************************************************************** PhilSch ***/

HRESULT CCFGEngine::SetWordInfo(WCHAR *pszText, SPWORDENTRY *pWordEntry)
{
    SPDBG_FUNC("CCFGEngine::SetWordInfo");
    HRESULT hr = S_OK;
    if (pszText)
    {
        if (*pszText == L'/')
        {
            WCHAR *p = pszText + 1;
            WCHAR *pBegin = p;
            ScanForSlash(&p);
            if (p && (*p == L'/'))
            {
                *p = 0;
                pWordEntry->pszDisplayText = pBegin;
                p++;
                pBegin = p;
            }
            else
            {
                // as long as we don't support TN we simply point at the DisplayForm
                pWordEntry->pszDisplayText = pBegin;
                pWordEntry->pszLexicalForm = pBegin;
            }
            ScanForSlash(&p);
            if (p && (*p == L'/'))
            {
                *p = 0;
                pWordEntry->pszLexicalForm = pBegin;
                pWordEntry->aPhoneId = p+1;
            }
            else
            {
                pWordEntry->pszLexicalForm = pBegin;
                pWordEntry->aPhoneId = NULL;
            }
        }
        else
        {
            pWordEntry->pszDisplayText = pszText;
            pWordEntry->pszLexicalForm = pszText;
            pWordEntry->aPhoneId = NULL;
        }
    }
    else
    {
        pWordEntry->pszDisplayText = NULL;
        pWordEntry->pszLexicalForm = NULL;
        pWordEntry->aPhoneId = NULL;
    }

    return hr;
}



/****************************************************************************
* CCFGEngine::GetWordInfo *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CCFGEngine::GetWordInfo(SPWORDENTRY * pWordEntry, SPWORDINFOOPT Options)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::GetWordInfo");
    HRESULT hr = S_OK;
    SPWORDENTRY we;
    memset(&we,0,sizeof(we));

    if (SP_IS_BAD_WRITE_PTR(pWordEntry))
    {
        hr = E_POINTER;
    }
    else
    {
        if (Options != SPWIO_NONE && Options != SPWIO_WANT_TEXT)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            CWordHandle WordHandle(pWordEntry->hWord);
            hr = ValidateHandle(WordHandle);
            if (SUCCEEDED(hr))
            {
                pWordEntry->LangID = m_CurLangID;
                pWordEntry->pvClientContext = ClientContextOf(WordHandle);
                if (Options == SPWIO_WANT_TEXT)
                {
                    const WCHAR *pszText = TextOf(WordHandle);
                    if (pszText)
                    {
                        WCHAR *pszLocalText = STACK_ALLOC(WCHAR, (wcslen(pszText)+1));
                        if (pszLocalText)
                        {
                            wcscpy(pszLocalText, pszText);
                            hr = SetWordInfo(pszLocalText, &we);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    hr = SetWordInfo(NULL, &we);
                }
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        // create CoTaskMemAlloc entries now
        WCHAR * psz = NULL;
        if (we.pszDisplayText)
        {
            psz = (WCHAR*) ::CoTaskMemAlloc((wcslen(we.pszDisplayText)+1)*sizeof(WCHAR));
            if (psz)
            {
                wcscpy(psz, we.pszDisplayText);
                pWordEntry->pszDisplayText = psz;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            pWordEntry->pszDisplayText = NULL;
        }
        if (we.pszLexicalForm)
        {
            if (SUCCEEDED(hr) && (psz = (WCHAR*) ::CoTaskMemAlloc((wcslen(we.pszLexicalForm)+1)*sizeof(WCHAR))))
            {
                wcscpy(psz, we.pszLexicalForm);
                pWordEntry->pszLexicalForm = psz;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            pWordEntry->pszLexicalForm = NULL;
        }
        if (we.aPhoneId)
        {
            SPPHONEID *pa = NULL;
            if (SUCCEEDED(hr))
            {
                pa = (SPPHONEID*) ::CoTaskMemAlloc((wcslen(we.aPhoneId)+1)*sizeof(SPPHONEID));
            }
            if (SUCCEEDED(hr) && pa)
            {
                wcscpy(pa, we.aPhoneId);
                pWordEntry->aPhoneId = pa;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            pWordEntry->aPhoneId = NULL;
        }
    }

    return hr;
}

/****************************************************************************
* CCFGEngine::SetWordClientContext *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CCFGEngine::SetWordClientContext(SPWORDHANDLE hWord, void * pvClientContext)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::SetWordClientContext");
    HRESULT hr = S_OK;
    
    CWordHandle WordHandle(hWord);
    hr = ValidateHandle(WordHandle);
    if (SUCCEEDED(hr))
    {
        WordTableEntryOf(WordHandle)->pvClientContext = pvClientContext;
    }
    else
    {
        hr = SPERR_INVALID_HANDLE;
    }

    return hr;
}

/****************************************************************************
* CCFGEngine::GetRuleInfo *
*-------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CCFGEngine::GetRuleInfo(SPRULEENTRY * pRuleEntry, SPRULEINFOOPT Options)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::GetRuleInfo");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pRuleEntry))
    {
        hr = E_POINTER;
    }
    else
    {
        if (Options != SPRIO_NONE)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            CRuleHandle RuleHandle(pRuleEntry->hRule);
            hr = ValidateHandle(RuleHandle);
            if (SUCCEEDED(hr))
            {
                CCFGGrammar * pGram = GrammarOf(RuleHandle);
                ULONG RuleIndex = RuleHandle.RuleIndex();
                RUNTIMERULEENTRY * pRule = pGram->m_pRuleTable + RuleIndex;

                // Construct the approrpriate attributes here
                pRuleEntry->Attributes = pGram->m_Header.pRules[RuleIndex].fTopLevel ? SPRAF_TopLevel : 0;
                if (pRule->fEngineActive)
                {
                    pRuleEntry->Attributes |= SPRAF_Active;
                }
                if (pRule->fAutoPause)
                {
                    pRuleEntry->Attributes |= SPRAF_AutoPause;
                }
                if (pGram->m_Header.pRules[RuleIndex].fPropRule)
                {
                    pRuleEntry->Attributes |= SPRAF_Interpreter;
                }
                // resolves imports and point to true state (maybe in other grammar)
                pRuleEntry->hInitialState = CStateHandle(pRule->pRefGrammar, pRule->pRefGrammar->m_Header.pRules[RuleIndex].FirstArcIndex);
                pRuleEntry->pvClientRuleContext = pRule->pvClientContext;
                pRuleEntry->pvClientGrammarContext = pGram->m_pvClientCookie;
            }
        }
    }
    return hr;
}

/****************************************************************************
* CCFGEngine::SetRuleClientContext *
*----------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CCFGEngine::SetRuleClientContext(SPRULEHANDLE hRule, void * pvClientContext)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::SetRuleClientContext");
    HRESULT hr = S_OK;

    CRuleHandle RuleHandle(hRule);
    hr = ValidateHandle(RuleHandle);
    if (SUCCEEDED(hr))
    {
        RuleOf(RuleHandle)->pvClientContext = pvClientContext;
    }
    else
    {
        hr = SPERR_INVALID_HANDLE;
    }

    return hr;
}

/****************************************************************************
* CCFGEngine::GetStateInfo *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CCFGEngine::GetStateInfo(SPSTATEHANDLE hState, SPSTATEINFO * pStateInfo)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::GetStateInfo");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_READ_PTR(pStateInfo) ||
        (pStateInfo->pTransitions && SPIsBadWritePtr(pStateInfo->pTransitions, pStateInfo->cAllocatedEntries * sizeof(*pStateInfo->pTransitions))))
    {
        hr = E_POINTER;
    }
    else
    {
        CStateHandle StateHandle(hState);
        hr = ValidateHandle(hState);
        if (SUCCEEDED(hr))
        {
            hr = InternalGetStateInfo(StateHandle, pStateInfo, FALSE);
        }
    }

    return hr;
}

/****************************************************************************
* CCFGEngine::InternalGetStateInfo *
*----------------------------------*
*   Description:
*       Exactly the same functionality as GetStateInfo, but this performs
*   no parameter validation.
*
*   Returns:
*       Same as GetStateInfo (except no E_INVALIDARG / E_POINTER)
*
********************************************************************* RAL ***/

HRESULT CCFGEngine::InternalGetStateInfo(CStateHandle StateHandle, SPSTATEINFO * pStateInfo, BOOL fWantImports)
{
    SPDBG_FUNC("CCFGEngine::InternalGetStateInfo");
    HRESULT hr = S_OK;

    CCFGGrammar * pGram = GrammarOf(StateHandle);
    ULONG ulFirstArc = StateHandle.FirstArcIndex();

    if (ulFirstArc == 0)
    {
        pStateInfo->cEpsilons = 0;
        pStateInfo->cWords = 0;
        pStateInfo->cRules = 0;
        pStateInfo->cSpecialTransitions = 0;
        return hr;
    }

    ULONG cArcs = 1;
    float flSum = 0.0;
    ULONG j = ulFirstArc;
    for (SPCFGARC * pArc = pGram->m_Header.pArcs + ulFirstArc; !pArc->fLastArc; pArc++, cArcs++, j++)
    {
        flSum += (pGram->m_Header.pWeights) ? pGram->m_Header.pWeights[j] : DEFAULT_WEIGHT;
    }
    flSum += (pGram->m_Header.pWeights) ? pGram->m_Header.pWeights[j] : DEFAULT_WEIGHT;

    if (flSum == 0.0)
    {
        flSum = 1.0;        // to avoid division by zero since all the weights will end up being 0!!
    }

    if (cArcs > pStateInfo->cAllocatedEntries)
    {
        ULONG cDesired = cArcs + 16;
        void * pNew = ::CoTaskMemAlloc(cDesired * sizeof(SPTRANSITIONENTRY));
        if (pNew)
        {
            ::CoTaskMemFree(pStateInfo->pTransitions);
            pStateInfo->pTransitions = (SPTRANSITIONENTRY *)pNew;
            pStateInfo->cAllocatedEntries = cDesired;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        pStateInfo->cRules = pStateInfo->cWords = pStateInfo->cEpsilons = pStateInfo->cSpecialTransitions = 0;
        SPTRANSITIONENTRY * pTrans = pStateInfo->pTransitions;
        SPTRANSITIONENTRY * pPastEnd = pTrans + cArcs;
        CTransitionId CurTransId(pGram, ulFirstArc);
        ULONG j = ulFirstArc;
        for (pArc = pGram->m_Header.pArcs + ulFirstArc;
             pTrans < pPastEnd;
             pTrans++, pArc++, CurTransId.IncToNextArcIndex(), j++)
        {
            pTrans->ID = CurTransId;
            pTrans->hNextState = (pArc->NextStartArcIndex) ?
                CStateHandle(pGram, pArc->NextStartArcIndex) : NULL;
            if (pArc->fRuleRef)
            {
                pTrans->Type = SPTRANSRULE;
                pStateInfo->cRules++;
                RUNTIMERULEENTRY * pRule = pGram->m_pRuleTable + pArc->TransitionIndex;
                CCFGGrammar * pRefGram = pRule->pRefGrammar;
                pTrans->hRuleInitialState = CStateHandle(pRefGram,
                        pRefGram->m_Header.pRules[pRule->ulGrammarRuleIndex].FirstArcIndex);
                // Internally we want to point to the import entry in this grammar
                // for external clients, we want to point to the destination rule of
                // the import.
                pTrans->hRule = (fWantImports) ?
                    CRuleHandle(pGram, pArc->TransitionIndex) :
                    CRuleHandle(pRefGram, pRule->ulGrammarRuleIndex);
                pTrans->pvClientRuleContext = pRule->pvClientContext;
            }
            else if (pArc->TransitionIndex == SPTEXTBUFFERTRANSITION)
            {
                pTrans->Type = SPTRANSTEXTBUF;
                pTrans->pvGrammarCookie = pGram->m_pvClientCookie;
                pStateInfo->cSpecialTransitions++;
            }
            else if (pArc->TransitionIndex == SPWILDCARDTRANSITION)
            {
                pTrans->Type = SPTRANSWILDCARD;
                pTrans->pvGrammarCookie = pGram->m_pvClientCookie;
                pStateInfo->cSpecialTransitions++;
            }
            else if (pArc->TransitionIndex == SPDICTATIONTRANSITION)
            {
                pTrans->Type = SPTRANSDICTATION;
                pTrans->pvGrammarCookie = pGram->m_pvClientCookie;
                pStateInfo->cSpecialTransitions++;
            }
            else
            {
                if (pArc->TransitionIndex)
                {
                    pTrans->Type = SPTRANSWORD;
                    pStateInfo->cWords++;
                    CWordHandle WordHandle = pGram->m_IndexToWordHandle[pArc->TransitionIndex];
                    pTrans->hWord = WordHandle;
                    pTrans->pvClientWordContext = ClientContextOf(WordHandle);
                }
                else 
                {
                    pTrans->Type = SPTRANSEPSILON;
                    pStateInfo->cEpsilons++;
                }
            }
            if (pArc->fLowConfRequired || pArc->fHighConfRequired)
            {
                pTrans->RequiredConfidence = pArc->fLowConfRequired ? SP_LOW_CONFIDENCE : SP_HIGH_CONFIDENCE;
            }
            else
            {
                pTrans->RequiredConfidence = SP_NORMAL_CONFIDENCE;
            }
            pTrans->fHasProperty = pArc->fHasSemanticTag;
            pTrans->Weight = (pGram->m_Header.pWeights) ? pGram->m_Header.pWeights[j] / flSum : 1.0f / flSum;
        }
    }

    return hr;
}


/****************************************************************************
* CCFGEngine::GetResourceValue *
*------------------------------*
*   Description:
*
*   Returns:
*       S_OK if resource was found
*       S_FALSE if resource was not found (*ppszCoMemResourceValue = NULL)
*       E_OUTOFMEMORY
*       E_INVALIDARG if pszResourceName is invalid
*       SPERR_INVALIDHANDLE if hRule is invalid
*
***************************************************************** philsch ***/

STDMETHODIMP CCFGEngine::GetResourceValue(const SPRULEHANDLE hRule, const WCHAR * pszResourceName, WCHAR **ppszCoMemResourceValue)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::GetResourceValue");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppszCoMemResourceValue) )
    {
        hr = E_POINTER;
    }
    else if ( SP_IS_BAD_READ_PTR(pszResourceName) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = ValidateHandle(hRule);
    }

    if (SUCCEEDED(hr))
    {
        // Now set up to assume we won't find the resource....
        hr = S_FALSE;
        *ppszCoMemResourceValue = NULL;      // in case there is no such resource
        CRuleHandle rh = CRuleHandle(hRule);
        ULONG id = rh.GrammarId();
        if (id <= m_cGrammarTableSize)
        {
            CCFGGrammar * pGram = m_pGrammars[id];
            ULONG  ulRuleIndex = rh.RuleIndex();
            SPCFGRESOURCE *pResource = pGram->m_Header.pResources;
            for(DWORD i = 0; i < pGram->m_Header.cResources; i++, pResource++)
            {
                if ((pResource->RuleIndex == ulRuleIndex) &&
                    (wcscmp(pszResourceName, &pGram->m_Header.pszSymbols[pResource->ResourceNameSymbolOffset]) == 0))
                {
                    if (pResource->ResourceValueSymbolOffset > 0)
                    {
                        ULONG cb = (wcslen(&pGram->m_Header.pszSymbols[pResource->ResourceValueSymbolOffset]) + 1)*sizeof(WCHAR);
                        *ppszCoMemResourceValue = (WCHAR*)::CoTaskMemAlloc(cb);
                        if (*ppszCoMemResourceValue)
                        {
                            memcpy(*ppszCoMemResourceValue, &pGram->m_Header.pszSymbols[pResource->ResourceValueSymbolOffset], cb);
                            hr = S_OK;
                            break;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                    }
                    else
                    {
                        SPDBG_ASSERT(hr == S_FALSE);
                        // empty resource
                        break;
                    }
                }
            }
        }
    }
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCFGEngine::Interpret *
*-----------------------*
*   Description:
*       This method will only be called if an application loads a grammar that
*   has a interpreted rule (INTERPRETER="YES") but is not loaded from the COM
*   object that has the actual interpreter.  In this case, we just copy the
*   properties to the parent.
*
*   Returns:
*
***************************************************************** PhilSch ***/

STDMETHODIMP CCFGEngine::Interpret(ISpPhraseBuilder * pPhrase, 
                                   const ULONG ulFirstElement,
                                   const ULONG ulCountOfElements,
                                   ISpCFGInterpreterSite * pSite)
{
    SPDBG_FUNC("CCFGEngine::Interpret");
    HRESULT hr = S_OK;

    CSpPhrasePtr cpElements(pPhrase, &hr);
    if (SUCCEEDED(hr) && cpElements->pProperties)
    {
        hr = pSite->AddProperty(cpElements->pProperties);
    }
    
    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}

/****************************************************************************
* CCFGEngine::GetRuleDescription *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CCFGEngine::GetRuleDescription(const SPRULEHANDLE hRule,
                                            WCHAR ** ppszRuleName,
                                            ULONG *pulRuleId,
                                            LANGID * pLangID)
{
    SPAUTO_OBJ_LOCK;
    SPDBG_FUNC("CCFGEngine::GetRuleDescription");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_OPTIONAL_WRITE_PTR(ppszRuleName) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR(pulRuleId) ||
        SP_IS_BAD_OPTIONAL_WRITE_PTR(pLangID))
    {
        hr = E_POINTER;
    }
    else
    {
        CRuleHandle RuleHandle(hRule);
        hr = ValidateHandle(RuleHandle);
        if (SUCCEEDED(hr))
        {
            CCFGGrammar * pGram = GrammarOf(RuleHandle);
            SPCFGRULE * pRule = pGram->m_Header.pRules + RuleHandle.RuleIndex();

            if (pulRuleId)
            {
                if (pRule->fImport)
                {
                    RUNTIMERULEENTRY * pRTRule = pGram->m_pRuleTable + RuleHandle.RuleIndex();
                    *pulRuleId = pRTRule->pRefGrammar->m_Header.pRules[pRTRule->ulGrammarRuleIndex].RuleId;
                }
                else
                {
                    *pulRuleId = pRule->RuleId;
                }
            }
            if (pLangID)
            {
                *pLangID = pGram->m_Header.LangID;
            }
            if (ppszRuleName)
            {
                *ppszRuleName = NULL;
                if (pRule->NameSymbolOffset)
                {
                    const WCHAR * pszName = pGram->m_Header.pszSymbols + pRule->NameSymbolOffset;
                    ULONG cb = (wcslen(pszName) + 1) * sizeof(*pszName);
                    *ppszRuleName = (WCHAR *)::CoTaskMemAlloc(cb);
                    if (*ppszRuleName)
                    {
                        memcpy(*ppszRuleName, pszName, cb);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
    }
    
    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}


/****************************************************************************
* CCFGEngine::CompareWords *
*--------------------------*
*   Description:
*       Compares a word with the form /disp/lex/pron with a given phrase
*       element.  If fCompareExact is TRUE then everything specified in the
*       phrase element must exactly match the information in the word table.
*       If fCompareExact is FALSE then as long as all information specified in
*       the phrase element matches the word table data, then it is a match (that
*       is, the phrase element is a proper subset of the word blob data).
*
*       Note that the one execption to the exact match rule is that if the word
*       blob contains only the lexical form OR the 

*
*   Returns:
*       TRUE if match, else FALSE
*
********************************************************************* RAL ***/

// Helper
inline BOOL CompareHunk(const WCHAR * pszFromBlob, const WCHAR * pszFromElement, BOOL fCompareExact, BOOL fCaseSensitive)
{
    if (pszFromElement)
    {
        if (pszFromBlob)
        {
            if(fCaseSensitive)
            {
                return (wcscmp(pszFromBlob, pszFromElement) == 0);
            }
            else
            {
                return (wcsicmp(pszFromBlob, pszFromElement) == 0);
            }
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return (pszFromBlob == NULL || (!fCompareExact));
    }

}

BOOL CCFGEngine::CompareWords(const CWordHandle wh, const SPPHRASEELEMENT * pElem, BOOL fCompareExact, BOOL fCaseSensitive)
{
    const WCHAR *pcText = TextOf(wh);              
    BOOL fMatch = FALSE;
    if (*pcText != L'/')
    {
        fMatch = ((pElem->pszPronunciation == NULL) &&
                  CompareHunk(pcText, pElem->pszLexicalForm, fCompareExact, fCaseSensitive));
        if (fMatch && pElem->pszDisplayText)
        {
            // Match only if the lexical form is equal to the display form.
            fMatch = CompareHunk(pElem->pszLexicalForm, pElem->pszDisplayText, TRUE, fCaseSensitive);
        }
    }
    else
    {
        //  Note:  In this function the pszParse array is a position dependent array
        //         in order of Disp(0)/Lex(1)/Pron(2)
        WCHAR * pszParse[3] = {NULL, NULL, NULL};
        ULONG cch = wcslen(pcText);
        WCHAR * pszScratch = STACK_ALLOC(WCHAR, cch);   // NOTE:  cch is right (not cch+1) since we skip the initial "/" below
        WCHAR * pDest = pszScratch;
        ULONG i = 0;
        pcText++;       // Skip initial "/"
        while (*pcText)
        {
            if (*pcText == L'/')
            {
                *pDest++ = 0;
                i++;
                if (i == 2)
                {
                    if (pcText[1] != 0)
                    {
                        wcscpy(pDest, pcText+1);
                        pszParse[2] = pDest;
                    }
                    break;
                }
                pcText++;
            }
            else
            {
                if (pszParse[i] == NULL)
                {
                    pszParse[i] = pDest;
                }
                if (*pcText == L'\\')
                {
                    *pDest++ = pcText[1];
                    pcText += 2;
                }
                else
                {
                    *pDest++ = *pcText++;
                }
            }
        }

        fMatch = CompareHunk(pszParse[1], pElem->pszLexicalForm, fCompareExact, fCaseSensitive) &&
                 CompareHunk(pszParse[2], pElem->pszPronunciation, fCompareExact, TRUE); // These are phone ids not strings so always case sensitive
        if (fMatch && pElem->pszDisplayText)
        {
            fMatch = CompareHunk(pszParse[0], pElem->pszDisplayText, fCompareExact, fCaseSensitive);
        }
    }
    return fMatch;
}



/****************************************************************************
* CCFGEngine::ResolveWordHandles*
*-------------------------------*
*   Description:
*       match all non-NULL parts in both to find the handle.
*       lexical form has to be provided at all times!
*   Returns:
*
**************************************************************** t-lleav ***/
void CCFGEngine::ResolveWordHandles(_SPPATHENTRY *pPath, const ULONG cElements, BOOL fCaseSensitive)
{
    SPDBG_FUNC("CCFGEngine::ResolveWordHandles");

    ULONG idx;
    ULONG idxw;
    ULONG cTransCount = 0;
    ULONG cMinZero;
    ULONG cMaxZero;

    CWordHandle wh;

    //
    // Try and resolve all the word handles for a given phrase.
    // First, look them up in the string blob.
    //
    cMinZero = cElements;
    cMaxZero = 0;

    for( idx = 0; idx < cElements; ++idx )
    {
        wh = IndexOf(pPath[idx].elem.pszLexicalForm);
        pPath[idx].hWord = wh;

        if( wh.WordTableIndex() != 0 )
        {
            cTransCount++;
        }
        else
        {
            if( idx < cMinZero )
            {
                cMinZero = idx;
            }
            cMaxZero = idx;
        }
    }
       
    if( cTransCount == cElements )
    {
        return;
    }

    //
    // Otherwise, search for them and use CompareWords to compare Lexical forms.
    //
    bool fCompareExact = true;
    while (TRUE)
    {
        for( idxw = 1; idxw <= m_ulLargestIndex; ++idxw )
        {
            wh = idxw;

            for( idx = cMinZero; idx <= cMaxZero; ++idx )
            {
                if( pPath[idx].hWord == 0 && CompareWords( wh, &pPath[idx].elem, fCompareExact, fCaseSensitive) )

                {
                    pPath[idx].hWord = wh;
                    cTransCount++;
                    if( cTransCount == cElements )
                    {
                        return;
                    }
                }
            }
        }
        if (fCompareExact)
        {
            fCompareExact = false;
        }
        else
        {
            return;
        }
    }
}


/****************************************************************************
* CCFGEngine::CreateCache        *
*--------------------------------*
***************************************************************** t-lleav ***/
HRESULT CCFGEngine::CreateCache(SPRULEHANDLE hRule)
{
    SPDBG_FUNC("CCFGEngine::CreateCache(hRule)");

    HRESULT hr;

    RUNTIMERULEENTRY * pRuleEntry;
    CRuleHandle cr;

    cr = hRule;
    pRuleEntry = RuleOf( cr );

    SPRULEENTRY RuleInfo;
    RuleInfo.hRule = cr;
    hr = GetRuleInfo(&RuleInfo, SPRIO_NONE);

    if( SUCCEEDED( hr ))
    {
        pRuleEntry->eCacheStatus = CACHE_VALID;
    
        CRuleStack RuleStack;
        RuleStack.Init( NULL, 0, 0, hRule );

        hr = CreateFanout( RuleInfo.hInitialState, &RuleStack );
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
/****************************************************************************
* CCFGEngine::InvalidateCache *
*-----------------------------*
***************************************************************** t-lleav ***/
HRESULT CCFGEngine::InvalidateCache( const CCFGGrammar *pGram )
{
    SPDBG_FUNC("CCFGEngine::InvalidateCache( CCFGGrammar )");

    if( !m_pGrammars || !pGram )
    {
        return S_FALSE;
    }

    if (pGram->m_pRuleTable)
    {

        SPCFGRULE * pRule               = pGram->m_Header.pRules;
        ULONG ulGrammarId               = pGram->m_ulGrammarID;

        //
        // Construct all the parse trees.
        //
        for (ULONG iRule = 0; iRule < pGram->m_Header.cRules; iRule++, pRule++)
        {
            CRuleHandle cr(ulGrammarId, iRule);
            RUNTIMERULEENTRY * pRuleEntry;
            pRuleEntry = RuleOf( cr );

            if( pRuleEntry && pRuleEntry->eCacheStatus != CACHE_VOID )
            {
                InvalidateCache( pRuleEntry );
            }
        }
    }

    return S_OK;
}

HRESULT CCFGEngine::InvalidateCache(void)
{    
    SPDBG_FUNC("CCFGEngine::InvalidateCache");

    if( FALSE == m_bIsCacheValid )
    {
        return S_FALSE;
    }
    
    if( !m_pGrammars )
    {
        return S_FALSE;
    }
    
    SPRULEHANDLE hSuccessfulRule = 0;
    m_bIsCacheValid = FALSE;

    for ( ULONG i = 0; i < m_cGrammarTableSize; i++)
    {
        if(m_pGrammars[i])
        {
            InvalidateCache( m_pGrammars[i] );
        }
    }

    return S_OK;
} 


/****************************************************************************
* CCFGEngine::CreateFanout *
*--------------------------------*
***************************************************************** t-lleav ***/
// pRuleStack->m_pParent

HRESULT CCFGEngine::CreateFanout( CStateHandle hState, CRuleStack *pRuleStack  )
{
    SPDBG_FUNC("CCFGEngine::CreateFanout");

    HRESULT hr = S_OK;

    // used to find the maximal parse
    CParseNode *pBestParse   = NULL;


    // grab it from the list
    CStateInfoListElement *pStateInfo = NULL;

    // get state info
    hr = AllocateStateInfo(hState, &pStateInfo);

    if (SUCCEEDED(hr))
    {

        ULONG cTransitionEntries = pStateInfo->cEpsilons + 
                                   pStateInfo->cRules + 
                                   pStateInfo->cWords + 
                                   pStateInfo->cSpecialTransitions;

        
        //
        // An empty rule?  
        // Then invalidate the parent, and return.
        // 
        if (cTransitionEntries == 0)
        {
            CRuleHandle cr;
            RUNTIMERULEENTRY * pRuleEntry;

            cr         = (SPRULEHANDLE)pRuleStack->m_hRule;
            pRuleEntry = RuleOf( cr );

            InvalidateCache( pRuleEntry );

            pRuleEntry->eCacheStatus = CACHE_DONOTCACHE;
            
            m_mStateInfoList.AddNode(pStateInfo);
            
            return SP_NO_PARSE_FOUND;
        }

        for (int i = cTransitionEntries-1; i >= 0; i--)
        {
            // default to S_OK
            hr = S_OK;

            switch (pStateInfo->pTransitions[i].Type)
            {
            case SPTRANSWORD: // 1
                {
                    // Add 
                    // 
                    CRuleHandle cr;
                    RUNTIMERULEENTRY * pRuleEntry;
                    CRuleStack * pStack  = pRuleStack;

                    while( pStack && SUCCEEDED( hr ))
                    {
                        cr         = (SPRULEHANDLE)pStack->m_hRule;
                        pRuleEntry = RuleOf( cr );

                        if( pRuleEntry->eCacheStatus == CACHE_VALID )
                        {
                            hr = CacheWord( pRuleEntry, pStateInfo->pTransitions[i].hWord );
                            if( FAILED( hr ) )
                            {
                                InvalidateCache( pRuleEntry );
                                pRuleEntry->eCacheStatus = CACHE_FAILED;
                            }
                        }
                        
                        pStack = pStack->m_pParent;
                    }

                }
                break;

            case SPTRANSRULE: // 2
                {

                    // non-empty dynamic rule
                    if (pStateInfo->pTransitions[i].hRuleInitialState != 0)
                    {
                        CRuleHandle cr;
                        RUNTIMERULEENTRY * pRuleEntry;
                        cr = pStateInfo->pTransitions[i].hRule;
                        pRuleEntry = RuleOf( cr );

                        if( pRuleEntry->eCacheStatus != CACHE_DONOTCACHE )
                        {
                            pRuleEntry->eCacheStatus = CACHE_VALID;

                            CRuleStack RuleStack;
                            RuleStack.Init( pRuleStack, 0, pStateInfo->pTransitions[i].hNextState, pStateInfo->pTransitions[i].hRule );

                            hr = CreateFanout( pStateInfo->pTransitions[i].hRuleInitialState, &RuleStack );
                            if( FAILED( hr ) )
                            {
                                pRuleEntry->eCacheStatus = CACHE_FAILED;
                            }
                        }
                    }
                }
                break;
            case SPTRANSEPSILON:
                {
                    if(pStateInfo->pTransitions[i].hNextState != NULL)
                    {
                        hr = CreateFanout( pStateInfo->pTransitions[i].hNextState, pRuleStack );
                    }
                    else
                    {
                        CRuleStack * pStack  = pRuleStack->m_pParent;

                        if(pStack)
                        {
                            RUNTIMERULEENTRY * pRuleEntry = RuleOf( pStack->m_hRule );

                            CRuleStack RuleStack;
                            RuleStack.Init( pRuleStack, 0, pStack->m_hFollowState, pStack->m_hRule );

                            hr = CreateFanout( pRuleStack->m_hFollowState, &RuleStack );
                            if( FAILED( hr ) )
                            {
                                pRuleEntry->eCacheStatus = CACHE_FAILED;
                            }
                        }                        
                    }
                }
                break;

            case SPTRANSWILDCARD:
            case SPTRANSTEXTBUF:
            case SPTRANSDICTATION:
                {
                    //
                    // Since we do not know what the words are, we cannot
                    // add them to the first set for the rule.  This may
                    // change for some of these cases.
                    // 
                    CRuleHandle cr;
                    RUNTIMERULEENTRY * pRuleEntry;
                    CRuleStack * pStack  = pRuleStack;

                    while( pStack )
                    {
                        cr         = (SPRULEHANDLE)pStack->m_hRule;
                        pRuleEntry = RuleOf( cr );

                        if( pRuleEntry->eCacheStatus == CACHE_VALID )
                        {
                            InvalidateCache( pRuleEntry );
                            pRuleEntry->eCacheStatus = CACHE_DONOTCACHE;
                        }
                        
                        pStack = pStack->m_pParent;
                    }
                }
                break;
            default:
                {
                    SPDBG_ASSERT(false); // should never get here
                }
            }

            if( FAILED( hr ) )
            {
                break;
            }
        }
    
        m_mStateInfoList.AddNode(pStateInfo);
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}

/****************************************************************************
* CCFGEngine::SetLanguageSupport *
*--------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

STDMETHODIMP CCFGEngine::SetLanguageSupport(const LANGID * paLangIDs, ULONG cLangIDs)
{
    SPDBG_FUNC("CCFGEngine::SetLanguageSupport");
    HRESULT hr = S_OK;

    if (m_cGrammarsLoaded)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else
    {
        if (paLangIDs)
        {
            if (cLangIDs > sp_countof(m_aLangIDs))
            {
                hr = E_UNEXPECTED;  // Strange -- too many languages
            }
            else
            {
                memcpy(m_aLangIDs, paLangIDs, cLangIDs * sizeof(*paLangIDs));
                m_cLangIDs = cLangIDs;
                m_CurLangID = 0;
            }
        }
        else
        {
            m_cLangIDs = 0;
            m_CurLangID = 0;
        }
    }


    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\baseaudio.inl ===
/****************************************************************************
*   baseaudio.inl
*       Implementations for the CBaseAudio templatized class for implementing
*       realtime audio devices such as speakers and microphones.
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#pragma once

#include "..\..\Patch\Include\atlbase.h"
#include "StreamHlp.h"
#include "a_audio.h"
#include "a_helpers.h"
#include <shlwapip.h>
#include <wtsapi32.h>
#include <winuser.h>

typedef BOOL (APIENTRY *PWTSUnRegisterSessionNotification)(HWND);
typedef BOOL (APIENTRY *PWTSRegisterSessionNotification)(HWND, DWORD);
typedef BOOL (APIENTRY *PWTSQuerySessionInformation)(HANDLE, DWORD, WTS_INFO_CLASS, LPTSTR*, DWORD*);
typedef VOID (APIENTRY *PWTSFreeMemory)(PVOID);

/****************************************************************************
* CBaseAudio::CBaseAudio *
*------------------------*
*   Description:  
*       Ctor
*
*   Return:
*   n/a
******************************************************************** robch */
template <class ISpAudioDerivative>
CBaseAudio<ISpAudioDerivative>::CBaseAudio(BOOL fWrite) :
    m_fWrite(fWrite),
    m_SpEventSource(this),
    m_BlockState(NotBlocked),
    m_State(SPAS_CLOSED),
    m_bPumpRunning(FALSE),
    m_ullLastEventPos(0),
    m_ullDevicePosition(0),
    m_ullSeekPosition(0),
    m_ullLastVolumePosition(0),
    m_ullVolumeEventPeriod(0),
    m_cAllocatedBuffers(0),
    m_fReadBufferOverflow(false),
    m_fReadBufferUnderflow(false),
    m_fNotInActiveSession(false),
    m_dwLastReadTickCount(0),
    m_cbMaxReadBufferSize(0),
    m_cbBufferNotifySize(1),
    m_fautohAPIEventSet(fWrite),
    m_hmWTSapi32(NULL),
    m_lDelayedVolumeSet(-1)
    {
    m_SpEventSource.m_ullEventInterest = 0;


}


/****************************************************************************
* CBaseAudio::FinalConstruct *
*----------------------------*
*   Description:  
*       ATL support method to finish initialization after the COM object has
*       been created
*
*   Return:
*   Errors from ::CreateEvent and SetBufferInfo on failure, or
*   S_OK
******************************************************************** robch */
template <class ISpAudioDerivative>
HRESULT CBaseAudio<ISpAudioDerivative>::FinalConstruct()
{
    HRESULT hr;

    #ifdef _WIN32_WCE
    hr = m_StreamFormat.AssignFormat(SPSF_16kHz16BitMono);
    #else
    hr = m_StreamFormat.AssignFormat(SPSF_22kHz16BitMono);
    #endif

    if (SUCCEEDED(hr))
    {
        hr = m_autohBlockIoEvent.InitEvent(NULL, FALSE, FALSE, NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = m_autohAPIEvent.InitEvent(NULL, TRUE, m_fWrite, NULL);
    }
    if (SUCCEEDED(hr))
    {
        static const SPAUDIOBUFFERINFO BuffInfo = {50, 500, 0};
        hr = SetBufferInfo(&BuffInfo);
    }

    m_hmWTSapi32 = IsOS(OS_WHISTLERORGREATER) ? LoadLibrary(_T("wtsapi32.dll")) : 0;
    return hr;
}

/****************************************************************************
* CBaseAudio::FinalRelease *
*--------------------------*
*   Description:  
*       ATL support method to clean up the object once it's been released.
*
*   Return:
*   n/a
******************************************************************** robch */
template <class ISpAudioDerivative>
void CBaseAudio<ISpAudioDerivative>::FinalRelease()
{
    SetState(SPAS_CLOSED, 0);
    if (m_hmWTSapi32)
    {
        FreeLibrary(m_hmWTSapi32);
        m_hmWTSapi32 = NULL;
    }
}

/****************************************************************************
* CBaseAudio::Read *
*------------------*
*   Description:  
*       ISequentialStream::Read implementation. Reads block when running, otherwise
*       Read returns the appropriate error.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::Read(void * pv, ULONG cb, ULONG *pcbRead)
{
    if (SP_IS_BAD_OPTIONAL_WRITE_PTR(pcbRead))
    {
        return E_POINTER;
    }
    if (m_fWrite)
    {
        if (pcbRead)
        {
            *pcbRead = 0;
        }
        return STG_E_ACCESSDENIED;
    }
    else
    {
        SPAUTO_OBJ_LOCK;
        HRESULT hr = S_OK;
        if (SPIsBadWritePtr(pv, cb))
        {
            hr = E_POINTER;
        }
        else
        {
            ULONG cbRemaining = cb;
            if (pcbRead)
            {
                *pcbRead = 0;
            }
            while (cbRemaining)
            {
                CBuffer * pBuff = m_HaveDataQueue.GetHead();
                if (pBuff)
                {
                    ULONG cbRead = pBuff->Read(&pv, &cbRemaining);
                    m_ullSeekPosition += cbRead;
                    if (pcbRead)
                    {
                        *pcbRead += cbRead;
                    }
                    if (pBuff->IsEmpty())
                    {
                        FreeBuffer(m_HaveDataQueue.RemoveHead());
                    }
                }
                else
                {
                    if (m_State == SPAS_RUN)
                    {
                        m_BlockState = WaitingInReadOrWrite;
                        ProcessDeviceBuffers(REASON_STREAMIO);
                        Unlock();
                        m_autohBlockIoEvent.Wait();
                        Lock();
                        hr = m_hrUnblockResult;
                        if (hr != S_OK) break;
                    }
                    else
                    {
                        if (m_fReadBufferOverflow)
                        {
                            SPDBG_ASSERT(m_State == SPAS_CLOSED);
                            hr = SPERR_AUDIO_BUFFER_OVERFLOW;
                        }
                        else if (m_fReadBufferUnderflow)
                        {
                            SPDBG_ASSERT(m_State == SPAS_CLOSED);
                            hr = SPERR_AUDIO_BUFFER_UNDERFLOW;
                        }
                        if (m_fNotInActiveSession)
                        {
                            SPDBG_ASSERT(m_State == SPAS_CLOSED);
                            hr = SPERR_NOT_ACTIVE_SESSION;
                        }
                        // Just return S_OK under a normal condition.
                        break;
                    }
                }
            }
            
            if (SUCCEEDED(hr))
            {
                hr = ProcessDeviceBuffers(REASON_STREAMIO);   // Kick off the service notify if needed...
            }
        }

        SPDBG_REPORT_ON_FAIL(hr);
        return hr;
    }
}

/****************************************************************************
* CBaseAudio::Write *
*-------------------*
*   Description:  
*       ISequentialStream::Write implementation. Write blocks if the state
*       is running or paused. Write does not block if closed or stopped, but
*       returns appropriate error code and data is not buffered.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::Write(const void * pv, ULONG cb, ULONG *pcbWritten)
{
    if (!m_fWrite)
    {
        if (pcbWritten)
        {
            *pcbWritten = 0;
        }
        return STG_E_ACCESSDENIED;
    }
    else
    {
        SPAUTO_OBJ_LOCK;
        HRESULT hr = S_OK;
        if (SPIsBadReadPtr(pv, cb) ||
            SP_IS_BAD_OPTIONAL_WRITE_PTR(pcbWritten))
        {
            hr = E_POINTER;
        }
        else
        {
            if (m_State == SPAS_RUN || m_State == SPAS_PAUSE)
            {
                ULONG cbRemaining = cb;
                CBuffer * pBuff = m_HaveDataQueue.GetTail();
                if (cbRemaining && pBuff)
                {
                    m_ullSeekPosition += pBuff->Write(&pv, &cbRemaining);    // Adjusts pv and cbRemaining
                }
                while (cbRemaining)
                {
                    if (m_ullSeekPosition - m_ullDevicePosition <= m_cbQueueSize)
                    {
                        hr = AllocateBuffer(&pBuff);
                        if (FAILED(hr)) break;
                        pBuff->Reset(m_ullSeekPosition);
                        m_ullSeekPosition += pBuff->Write(&pv, &cbRemaining);    // Adjusts pv and cbRemaining
                        m_HaveDataQueue.InsertTail(pBuff);
                    }
                    else
                    {
                        m_bPumpRunning = TRUE;
                        m_BlockState = WaitingInReadOrWrite;
                        ProcessDeviceBuffers(REASON_STREAMIO);
                        Unlock();
                        m_autohBlockIoEvent.Wait();
                        Lock();
                        hr = m_hrUnblockResult;
                        if (hr != S_OK) break;
                    }
                }
                if (pcbWritten)
                {
                    *pcbWritten = cb-cbRemaining;
                }
                ProcessDeviceBuffers(REASON_STREAMIO);
            }
            else
            {
                if (pcbWritten)
                {
                    *pcbWritten = 0;
                }
                if (m_fNotInActiveSession)
                {
                    hr = SPERR_NOT_ACTIVE_SESSION;
                }
                else
                {
                    hr = SP_AUDIO_STOPPED;
                }
            }
        }
        return hr;
    }
}


/****************************************************************************
* CBaseAudio::Seek *
*------------------*
*   Description:  
*       IStream::Seek implemenation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
    HRESULT hr = S_OK;
    if (dwOrigin != STREAM_SEEK_CUR || dlibMove.QuadPart)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (SPIsBadWritePtr(plibNewPosition, sizeof(*plibNewPosition)))
        {
            hr = E_POINTER;
        }
        else
        {
            plibNewPosition->QuadPart = m_ullSeekPosition;
        }
    }
    return hr;
}
    
/****************************************************************************
* CBaseAudio::SetSize *
*---------------------*
*   Description:  
*       IStream::SetSize implemenation.
*
*   Return:
*   S_OK
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::SetSize(ULARGE_INTEGER libNewSize)
{
    return S_OK;
}
    
/****************************************************************************
* CBaseAudio::CopyTo *
*--------------------*
*   Description:  
*       IStream::CopyTo implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::CopyTo(IStream *pstm, 
                    ULARGE_INTEGER cb,
                    ULARGE_INTEGER *pcbRead,
                    ULARGE_INTEGER *pcbWritten)
{
    if (m_fWrite)
    {
        return STG_E_ACCESSDENIED;
    }
    else
    {
        return SpGenericCopyTo(this, pstm, cb, pcbRead, pcbWritten);
    }
}
    
/****************************************************************************
* CBaseAudio::Commit *
*--------------------*
*   Description:  
*       IStream::Commit implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::Commit(DWORD grfCommitFlags)
{
    if (m_fWrite)
    {
        Lock();
        if (m_State == SPAS_RUN && m_ullSeekPosition != m_ullDevicePosition)
        {
            m_bPumpRunning = TRUE;                 // Force the thing to wake up
            ProcessDeviceBuffers(REASON_STREAMIO);   
            InternalUpdatePosition();              // Call this to clear the event if we're writing
        }
        Unlock();
    }
    return S_OK;
}
    
/****************************************************************************
* CBaseAudio::Revert *
*--------------------*
*   Description:  
*       IStream::Revert implementation.
*
*   Return:
*   E_NOTIMPL
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::Revert(void)
{
    return E_NOTIMPL;
}
    
/****************************************************************************
* CBaseAudio::LockRegion *
*------------------------*
*   Description:  
*       IStream::LockRegion implementation.
*
*   Return:
*   E_NOTIMPL
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::LockRegion(ULARGE_INTEGER libOffset,
                        ULARGE_INTEGER cb,
                        DWORD dwLockType)
{
    return E_NOTIMPL;
}

/****************************************************************************
* CBaseAudio::UnlockRegion *
*--------------------------*
*   Description:  
*       IStream::UnlockRegion implementation.
*
*   Return:
*   E_NOTIMPL
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::UnlockRegion(ULARGE_INTEGER libOffset,
                          ULARGE_INTEGER cb,
                          DWORD dwLockType)
{
    return E_NOTIMPL;
}
    
/****************************************************************************
* CBaseAudio::Stat *
*--------------------*
*   Description:  
*       IStream::Stat implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    HRESULT hr = S_OK;
    if (SP_IS_BAD_WRITE_PTR(pstatstg))
    {
        hr = E_POINTER;
    }
    else
    {
        //
        //  It is acceptable to simply fill in the size and type fields and zero the rest.
        //  This is what streams created by CreateStreamOnHGlobal return.
        //
        ZeroMemory(pstatstg, sizeof(*pstatstg));
        pstatstg->type = STGTY_STREAM;
        pstatstg->cbSize.QuadPart = m_ullSeekPosition;
    }
    return hr;
}
    
/****************************************************************************
* CBaseAudio::Clone *
*-------------------*
*   Description:  
*       IStream::Clone implementation.
*
*   Return:
*   E_NOTIMPL
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::Clone(IStream **ppstm)
{
    return E_NOTIMPL;
}

/****************************************************************************
* CBaseAudio::GetFormat *
*-----------------------*
*   Description:  
*       ISpStreamFormat::GetFormat implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::GetFormat(GUID * pguidFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    return m_StreamFormat.ParamValidateCopyTo(pguidFormatId, ppCoMemWaveFormatEx);
}

/****************************************************************************
* CBaseAudio::SetState *
*----------------------*
*   Description:  
*       ISpAudio::SetState implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::SetState(SPAUDIOSTATE NewState, ULONGLONG ullReserved) 
{
    HRESULT hr = S_OK;
    if (ullReserved != 0)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_StateChangeCritSec.Lock();
        if (m_State != NewState)
        {
            if (m_State == SPAS_CLOSED)
            {
                if (!m_cpThreadCtrl)
                {
                    CComPtr<ISpTaskManager> cpTaskManager;
                    hr = cpTaskManager.CoCreateInstance(CLSID_SpResourceManager);
                    if (SUCCEEDED(hr))
                    {
                        hr = cpTaskManager->CreateThreadControl(this, NULL, THREAD_PRIORITY_HIGHEST, &m_cpThreadCtrl);
                    }
                }
                if (SUCCEEDED(hr))
                {
                    HWND hwnd;
                    hr = m_cpThreadCtrl->StartThread(0, &hwnd);
                    // State is set to SPAS_STOP by the thread iff this funciton returns success.
                }
            }
            if (NewState == SPAS_CLOSED)
            {
                m_cpThreadCtrl->WaitForThreadDone(TRUE, &hr, INFINITE);
                // State is set to SPAS_CLOSED by the thread
            }
            //
            // Check here again for state equality since we may have just started the thread
            // and the state would change to SPAS_STOP by the thread creation.  If the state
            // isn't set right now, then send a message to the thread to change it.  We NEVER
            // change the state except on the worker thread.
            //
            if (SUCCEEDED(hr) && m_State != NewState)
            {
                ::SendMessage(m_cpThreadCtrl->WindowHandle(), WM_PRIVATE_CHANGE_STATE, NewState, (LPARAM)&hr);
            }
        }
        m_StateChangeCritSec.Unlock();
    }
    return hr;
}

/****************************************************************************
* CBaseAudio::SetFormat *
*-----------------------*
*   Description:  
*       ISpAudio::SetFormat implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::SetFormat(REFGUID rguidFmtId, const WAVEFORMATEX * pwfex)
{
    HRESULT hr = S_OK;
    SPAUTO_OBJ_LOCK;
    CSpStreamFormat NewFmt;
    hr = NewFmt.ParamValidateAssignFormat(rguidFmtId, pwfex, TRUE);
    
    // Validation of the wfex by checking if the device actually supports it is
    // done by the derived class which calls this as a first step in validation.
    if (SUCCEEDED(hr))
    {
        if (NewFmt != m_StreamFormat)
        {
            if (m_State != SPAS_CLOSED)     // Can't do this if the device is opened
            {
                hr = SPERR_DEVICE_BUSY;
            }
            else
            {
                if (pwfex == NULL ||
                    pwfex->wFormatTag != WAVE_FORMAT_PCM)
                {
                    hr = SPERR_UNSUPPORTED_FORMAT;
                }
                else
                {
                    NewFmt.DetachTo(m_StreamFormat);
                    SetBufferInfo(&m_BufferInfo);    // Update buffer sizes
                }
            }
        }
    }
    return hr;
}

/****************************************************************************
* CBaseAudio::GetStatus *
*-----------------------*
*   Description:  
*       ISpAudio::GetStatus implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::GetStatus(SPAUDIOSTATUS *pStatus)
{
    SPAUTO_OBJ_LOCK;
    HRESULT hr = S_OK;
    if (SP_IS_BAD_WRITE_PTR(pStatus))
    {
        hr = E_POINTER;
    }
    else
    {
        if (m_State == SPAS_RUN)
        {
            UpdateDevicePosition(&pStatus->cbFreeBuffSpace, &pStatus->cbNonBlockingIO);
        }
        else
        {
            pStatus->cbFreeBuffSpace = 0;   // NTRAID#SPEECH-0000-2000/08/24-robch
            pStatus->cbNonBlockingIO = 0;   // NTRAID#SPEECH-0000-2000/08/24-robch
        }
        pStatus->CurSeekPos = m_ullSeekPosition;
        pStatus->State = m_State;
        pStatus->CurDevicePos = m_ullDevicePosition;
        pStatus->dwReserved1 = 0;
        pStatus->dwReserved2 = 0;
    }
    return hr;
}



/****************************************************************************
* CBaseAudio::SetBufferInfo *
*---------------------------*
*   Description:  
*       ISpAudio::SetBufferInfo implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::SetBufferInfo(const SPAUDIOBUFFERINFO * pInfo)
{
    SPAUTO_OBJ_LOCK;
    HRESULT hr = S_OK;
    // Buffer size must be at least four times as large as the minimum notification size.
    // The event bias must be less than or equal to the buffer size.  Notification latency
    // is limited to at most 50Ms (200 times per second is a bit much!).  The mimimum total
    // buffer size is 200Ms
    if (SP_IS_BAD_READ_PTR(pInfo) || 
        (pInfo->ulMsMinNotification == 0) ||
        (pInfo->ulMsBufferSize < 200) ||
        (pInfo->ulMsMinNotification > (pInfo->ulMsBufferSize / 4)) ||
        (pInfo->ulMsEventBias > pInfo->ulMsBufferSize)) 
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if (m_State != SPAS_CLOSED)
        {
            hr = SPERR_DEVICE_BUSY;
        }
        else
        {
            m_BufferInfo = *pInfo;
            const WAVEFORMATEX * pwfex = m_StreamFormat.WaveFormatExPtr();
            //
            //  Now compute the buffer size, the minimum desired queue size, the maximum
            //  desired queue size, and the number of buffers we'll allow to be around
            //  in the ideal case.
            //
            //  The buffer size must be a multiple of the nBlockAlign or the data may be put into
            //  the buffer unaligned (fixed bug on NT 5, 7/8/99 -- robch)
            //
            //  For any minimum notification period less than 50ms we'll use 50ms
            //
            ULONG ulMsMinNotify = pInfo->ulMsMinNotification >= 50 ? pInfo->ulMsMinNotification : 50;
            m_cbBufferSize = (pwfex->nAvgBytesPerSec * ulMsMinNotify) / 1000;
            m_cbBufferSize = ((m_cbBufferSize + pwfex->nBlockAlign - 1) / pwfex->nBlockAlign) * pwfex->nBlockAlign;
            m_cbQueueSize = (pwfex->nAvgBytesPerSec * pInfo->ulMsBufferSize) / 1000;
            m_cbEventBias = (pwfex->nAvgBytesPerSec * pInfo->ulMsEventBias) / 1000;
            m_cDesiredBuffers = (m_cbQueueSize / m_cbBufferSize) + 1;    // Always add one buffer for slop.

            // Record a max of 30 sec audio
            m_cbMaxReadBufferSize = pwfex->nAvgBytesPerSec * 30;

            // Set the rate at which volume events fire
            m_ullVolumeEventPeriod = (100 * pwfex->nAvgBytesPerSec) / 1000;
        }
    }
    return hr;
}

/****************************************************************************
* CBaseAudio::GetBufferInfo *
*---------------------------*
*   Description:  
*       ISpAudio::GetBufferInfo implementation
*
*   Return:
*   S_OK on sucess
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::GetBufferInfo(SPAUDIOBUFFERINFO * pInfo)
{
    SPAUTO_OBJ_LOCK;
    HRESULT hr = S_OK;
    if (SP_IS_BAD_WRITE_PTR(pInfo))
    {
        hr = E_POINTER;
    }
    else
    {
        *pInfo = m_BufferInfo;
    }
    return hr;
}

/****************************************************************************
* CBaseAudio::GetDefaultFormat *
*------------------------------*
*   Description:  
*       ISpAudio::GetDefaultFormat implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::GetDefaultFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{
    SPAUTO_OBJ_LOCK;
    HRESULT hr = S_OK;
    if (SP_IS_BAD_WRITE_PTR(pFormatId) ||
        SP_IS_BAD_WRITE_PTR(ppCoMemWaveFormatEx))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = GetDefaultDeviceFormat(pFormatId, ppCoMemWaveFormatEx);
        if (FAILED(hr))
        {
            *ppCoMemWaveFormatEx = NULL;
            *pFormatId = GUID_NULL;
        }
    }
    return hr;
}

/****************************************************************************
* CBaseAudio::EventHandle *
*------------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

template <class ISpAudioDerivative>
STDMETHODIMP_(HANDLE) CBaseAudio<ISpAudioDerivative>::EventHandle()
{
    SPDBG_FUNC("CBaseAudio::EventHandle");
    return m_autohAPIEvent;
}

/****************************************************************************
* CBaseAudio::GetVolumeLevel *
*----------------------------*
*   Description:
*       The derived class overrides this function to support it.
*
*   Returns:
*
****************************************************************** YUNUSM ***/

template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::GetVolumeLevel(ULONG *)
{
    SPDBG_FUNC("CBaseAudio::GetVolumeLevel");
    return E_NOTIMPL;
}

/****************************************************************************
* CBaseAudio::SetVolumeLevel *
*----------------------------*
*   Description:
*       The derived class overrides this function to support it.
*
*   Returns:
*
****************************************************************** YUNUSM ***/

template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::SetVolumeLevel(ULONG)
{
    SPDBG_FUNC("CBaseAudio::SetVolumeLevel");
    return E_NOTIMPL;
}

/****************************************************************************
* CBaseAudio::GetBufferNotifySize *
*---------------------------------*
*   Description:
*       Returns the size of audio bytes on which the api event is set.
*
*   Returns:
*
****************************************************************** YUNUSM ***/

template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::GetBufferNotifySize(ULONG *pcbSize)
{
    if (SP_IS_BAD_WRITE_PTR(pcbSize))
    {
        return E_POINTER;
    }
    *pcbSize = m_cbBufferNotifySize;
    return S_OK;
}

/****************************************************************************
* CBaseAudio::SetBufferNotifySize *
*---------------------------------*
*   Description:
*       Sets the size of audio bytes on which the api event is set.
*
*   Returns:
*
****************************************************************** YUNUSM ***/

template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::SetBufferNotifySize(ULONG cbSize)
{
    SPAUTO_OBJ_LOCK;
    m_cbBufferNotifySize = cbSize;
    InternalUpdatePosition();
    return S_OK;
}

/****************************************************************************
* CBaseAudio::AddEvents *
*-----------------------*
*   Description:  
*       ISpEventSink::AddEvents implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::AddEvents(const SPEVENT* pEventArray, ULONG ulCount)
{                                                                               
    SPAUTO_OBJ_LOCK;                                                            
    HRESULT hr = S_OK;                                                          
    if( SPIsBadReadPtr(pEventArray, sizeof(SPEVENT ) * ulCount))
    {                                                                           
        hr = E_INVALIDARG;                                                      
    }                                                                               
    else 
    {
        hr = m_SpEventSource._AddEvents(pEventArray, ulCount);
        m_SpEventSource._CompleteEvents(m_ullDevicePosition + m_cbEventBias);
    }
    return hr;
}

/****************************************************************************
* CBaseAudio::GetEventInterest *
*------------------------------*
*   Description:  
*       ISpEventSink::GetEventInterest implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::GetEventInterest(ULONGLONG * pullEventInterest)
{
    HRESULT hr = S_OK;
    if (SP_IS_BAD_WRITE_PTR(pullEventInterest))
    {
        hr = E_POINTER;
    }
    else
    {
        *pullEventInterest = m_SpEventSource.m_ullEventInterest;
    }

    return hr;
}

/****************************************************************************
* CBaseAudio::SetObjectToken *
*----------------------------*
*   Description:  
*       ISpObjectWithToken::SetObjectToken implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::SetObjectToken(ISpObjectToken * pToken)
{
    SPAUTO_OBJ_LOCK;
    HRESULT hr = SpGenericSetObjectToken(pToken, m_cpToken);
    if (SUCCEEDED(hr))
    {
        CSpDynamicString dstrDeviceName;
        pToken->GetStringValue(L"DeviceName", &dstrDeviceName);
        if (dstrDeviceName)
        {
            hr = SetDeviceNameFromToken(dstrDeviceName);
        }
        // Just leave it set to the wav mapper if there is no device name.
    }
    return hr;
}

/****************************************************************************
* CBaseAudio::GetObjectToken *
*----------------------------*
*   Description:  
*       ISpObjectWithToken::GetObjectToken implementation.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::GetObjectToken(ISpObjectToken ** ppToken)
{
    SPAUTO_OBJ_LOCK;
    return SpGenericGetObjectToken(ppToken, m_cpToken);
}

/****************************************************************************
* CBaseAudio::InitThread *
*------------------------*
*   Description:  
*       ISpThreadTask::Init implementation. We use the init thread method
*       to open the device. If we can't open the device, we fail the init.
*
*       This method is only called on the audio thread.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::InitThread(void *, HWND hwnd)
{

    SPAUTO_OBJ_LOCK;
    HRESULT hr = S_OK;

    // if Terminal Services lib exists, then running in Whistler+
    //  Check if we are in active local console session or a remote
    //      session and should enable audio input/output capabilities
    if (m_hmWTSapi32)
    {

        // load WTSQuerySessionInformation procedure
        PWTSQuerySessionInformation pWTSQuerySessionInformation = (PWTSQuerySessionInformation)GetProcAddress(m_hmWTSapi32, "WTSQuerySessionInformationW");
        SPDBG_ASSERT( pWTSQuerySessionInformation ); // since we are on Whistler OS, this should never fail
        if (pWTSQuerySessionInformation)
        {
            BOOL fQuerySucceeded;
            PINT piConnectionState = NULL;
            DWORD cbSize = 0;
            fQuerySucceeded = pWTSQuerySessionInformation(WTS_CURRENT_SERVER_HANDLE,
                                                         WTS_CURRENT_SESSION,
                                                         WTSConnectState,
                                                         (LPTSTR*)&piConnectionState,
                                                         &cbSize);
            if (fQuerySucceeded)
            {
                // Check the terminal client's connection state
                switch (*piConnectionState)
                {

                // terminal client is disconnected (e.g. inactive local console session)
                case WTSDisconnected:
                    hr = SPERR_NOT_ACTIVE_SESSION;
                    break;

                // either active local session or remote session
                default:
                    break;
                }

                // load WTSFreeMemory API procedure
                PWTSFreeMemory pWTSFreeMemory = (PWTSFreeMemory)GetProcAddress(m_hmWTSapi32, "WTSFreeMemory");
                SPDBG_ASSERT( pWTSFreeMemory ); // since we are on Whistler OS, this should never fail
                if (pWTSFreeMemory) {
                    // free the terminal server memory allocated by QuerySessionInformation
                    pWTSFreeMemory( piConnectionState );
                } // end if GetProcAddress( WTSFreeMemory)

            } // end if WTSQuerySessionInformation succeeded

        } // if GetProcAddress(WTSQuerySessionInformation)

    } // if running in Whistler+

    if (SUCCEEDED(hr)) {
        hr = OpenDevice(hwnd);
    }

    if (SUCCEEDED(hr))
    {
        m_State = SPAS_STOP;
    }
    
    if (SUCCEEDED(hr))
    {
        m_fReadBufferOverflow = false;
        m_fReadBufferUnderflow = false;
        m_fNotInActiveSession = false;
        m_dwLastReadTickCount = 0;
    }
    
    if (SUCCEEDED(hr) && m_hmWTSapi32)
    {
        PWTSRegisterSessionNotification pWTSRegisterSessionNotification = (PWTSRegisterSessionNotification)GetProcAddress(m_hmWTSapi32, "WTSRegisterSessionNotification");
        if (pWTSRegisterSessionNotification)
        {
            pWTSRegisterSessionNotification(hwnd, NOTIFY_FOR_THIS_SESSION);
        }
    }

    return hr;
}

/****************************************************************************
* CBaseAudio::ThreadProc *
*------------------------*
*   Description:  
*       ISpThreadTask::ThreadProc implementation. We'll spend most of our
*       time in this threadproc for the audio thread, awaking only to
*       dispatch window messages, and to eventually exit the thread.
*
*       We have a 1/2 second timeout value to ensure that we process
*       device buffers at least that frequently.
*
*   Return:
*   S_OK if we successfully closed the device when the thread shuts down
*   FAILED(hr) if we didn't
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::ThreadProc(void * pvIgnored, HANDLE hExitThreadEvent, HANDLE hNotifyEvent, HWND hwnd, volatile const BOOL *)
{

    while (TRUE)
    {
        // If someone has set the read overflow, we should pretend we're dead,
        // just as if someone had terminated our thread
        if (m_fReadBufferOverflow | m_fReadBufferUnderflow | m_fNotInActiveSession)
        {
            SetEvent(hExitThreadEvent);
        }
        
        DWORD dwWaitId = ::MsgWaitForMultipleObjects(1, &hExitThreadEvent, FALSE,
                                500, // Time-out every 1/2 second -- See note above
                                QS_ALLINPUT);    
        switch (dwWaitId)
        {
            case WAIT_OBJECT_0:
                {
                    SPAUTO_OBJ_LOCK;
                    if (m_hmWTSapi32)
                    {
                        PWTSUnRegisterSessionNotification pWTSUnRegisterSessionNotification = (PWTSUnRegisterSessionNotification)GetProcAddress(m_hmWTSapi32, "WTSUnRegisterSessionNotification");
                        if (pWTSUnRegisterSessionNotification)
                        {
                            pWTSUnRegisterSessionNotification(hwnd);
                        }
                    }
                    InternalStateChange(SPAS_STOP);
                    return CloseDevice();
                }
            case WAIT_TIMEOUT:
                CheckForAsyncBufferCompletion();
                break;

            default:
                MSG Msg;
                while (::PeekMessage(&Msg, NULL, 0, 0, TRUE))
                {
                    ::DispatchMessage(&Msg);
                }
                break;
        }
    } 
}

/****************************************************************************
* CBaseAudio::WindowMessage *
*---------------------------*
*   Description:  
*       ISpThreadTask::WindowMessage implementation. We have a hidden window
*       that we can use for processing window messages if we'd like. We use
*       this window as a means of communication from other threads to the
*       audio thread to change the state of the audio device. This ensures
*       that we only attempt to change the device state on the audio thread.
*
*   Return:
*   Message specific (see Win32 API documentation)
******************************************************************** robch */
template <class ISpAudioDerivative>
STDMETHODIMP_(LRESULT) CBaseAudio<ISpAudioDerivative>::WindowMessage(void * pvIgnored, HWND hwnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    if (Msg == WM_PRIVATE_CHANGE_STATE)
    {
        SPAUTO_OBJ_LOCK;
        *((HRESULT *)(lParam)) = InternalStateChange((SPAUDIOSTATE)wParam);
    }
    else if (Msg == WM_WTSSESSION_CHANGE)
    {
        switch (wParam)
        {
            case WTS_CONSOLE_CONNECT:
                //your session was just reconnected to the console
                break;

            case WTS_CONSOLE_DISCONNECT:
                //your session was just disconnected from the
                //console but another session has not yet been 
                //connected.
                if (m_State != SPAS_CLOSED)
                {
                    m_fNotInActiveSession = TRUE;
                }
                break;
        }
    }
    return ::DefWindowProc(hwnd, Msg, wParam, lParam);
}

/****************************************************************************
* CBaseAudio::ProcessDeviceBuffers *
*----------------------------------*
*   Description:
*       Move buffers from one queue to another based on their state as well
*       as ensure that all queues have enough buffers.
*  
*       This function may be overridden by the derived class to do additional
*       work, however, the derived class must call this method before it
*       returns.
*
*       This function will only be called with the critical section owned.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
HRESULT CBaseAudio<ISpAudioDerivative>::ProcessDeviceBuffers(BUFFPROCREASON Reason)
{
    HRESULT hr = S_OK;
    if (m_fWrite)
    {
        if (Reason == REASON_BUFFCOMPLETENOTIFY)
        {
            m_IOInProgressQueue.MoveDoneBuffsToTailOf(m_FreeQueue);

            if(m_ullDevicePosition > m_ullLastVolumePosition + m_ullVolumeEventPeriod)
            {
                if((m_SpEventSource.m_ullEventInterest & SPFEI(SPEI_TTS_AUDIO_LEVEL)) == SPFEI(SPEI_TTS_AUDIO_LEVEL))
                {
                    // Look at most recently played-back buffer
                    CBuffer * pBuff = m_FreeQueue.GetTail();
                    if(pBuff)
                    {
                        ULONG ulLevel;
                        hr = pBuff->GetAudioLevel(&ulLevel, 
                            m_StreamFormat.m_guidFormatId, m_StreamFormat.m_pCoMemWaveFormatEx);
                        if(hr == S_OK)
                        {
                            SPEVENT Event;
                            Event.eEventId = SPEI_TTS_AUDIO_LEVEL;
                            Event.elParamType = SPET_LPARAM_IS_UNDEFINED;
                            Event.ullAudioStreamOffset = m_ullDevicePosition;
                            Event.wParam = ulLevel;
                            Event.lParam = NULL;
                            m_SpEventSource._GetStreamNumber(Event.ullAudioStreamOffset, &Event.ulStreamNum);
                            hr = m_SpEventSource._AddEvents(&Event, 1);

                            m_ullLastVolumePosition = m_ullDevicePosition;
                        }
                    }
                }
            }

            CompactFreeQueue();
        }
        if (m_State == SPAS_RUN && m_bPumpRunning)
        {
            CBuffer * pBuff;
            while (pBuff = m_HaveDataQueue.RemoveHead())
            {
                // Check for a partially full tail buffer.  If we have one, but the queue still has
                // enough data then don't write the buffer yet.
                if (m_HaveDataQueue.IsEmpty() &&
                    pBuff->GetWriteOffset() < pBuff->GetDataSize() &&
                    m_IOInProgressQueue.AreMinSamplesQueuedForWrite(m_cbQueueSize / 2))
                {
                    m_HaveDataQueue.InsertHead(pBuff);
                    break;
                }
                m_IOInProgressQueue.InsertTail(pBuff);
                pBuff->AsyncWrite();
            }
            UpdateDevicePosition(NULL, NULL); // Update the device position 
        }
    }
    else
    {
        if (m_State != SPAS_STOP && m_State != SPAS_CLOSED)
        {
            ULONG ulNewBytes = m_IOInProgressQueue.MoveDoneBuffsToTailOf(m_HaveDataQueue);
            
            // We have to watch to see that we're successfully reading data from the 
            // sound card at least every now and then, so we're going to keep track
            // of our last read.
             
            if (m_dwLastReadTickCount == 0 ||
                GetTickCount() < m_dwLastReadTickCount)
            {
                // If we haven't initialized yet, or we wrapped, reset our
                // counter
                m_dwLastReadTickCount = GetTickCount();
            }
            
            // If we read new data, update our counter, otherwise if it's been 5 seconds
            // we've underflowed
            if (ulNewBytes > 0)
            {
                m_dwLastReadTickCount = GetTickCount();
            }
            else if (GetTickCount() - m_dwLastReadTickCount > 5000)
            {
                m_fReadBufferUnderflow = true;
            }
            
            m_ullDevicePosition += ulNewBytes;
            if(m_ullDevicePosition > m_ullLastVolumePosition + m_ullVolumeEventPeriod)
            {
                if((m_SpEventSource.m_ullEventInterest & SPFEI(SPEI_SR_AUDIO_LEVEL)) == SPFEI(SPEI_SR_AUDIO_LEVEL))
                {
                    // Look at volume on latest read buffer
                    CBuffer * pBuff = m_HaveDataQueue.GetTail();
                    if(pBuff)
                    {
                        ULONG ulLevel;
                        hr = pBuff->GetAudioLevel(&ulLevel, 
                            m_StreamFormat.m_guidFormatId, m_StreamFormat.m_pCoMemWaveFormatEx);
                        if(hr == S_OK)
                        {
                            SPEVENT Event;
                            Event.eEventId = SPEI_SR_AUDIO_LEVEL;
                            Event.elParamType = SPET_LPARAM_IS_UNDEFINED;
                            Event.ulStreamNum = 0; // This gets filled in by SAPI
                            Event.ullAudioStreamOffset = m_ullDevicePosition;
                            Event.wParam = ulLevel;
                            Event.lParam = NULL;
                            hr = m_SpEventSource._AddEvents(&Event, 1);

                            // We don't absolutely fire every event period
                            // but just guarentee that we wait at least that period
                            // between events
                            m_ullLastVolumePosition = m_ullDevicePosition;
                        }
                    }
                }
            }

            while (m_FreeQueue.GetHead() ||
                   m_cDesiredBuffers > m_cAllocatedBuffers ||
                   m_IOInProgressQueue.AreMoreReadBuffersRequired(m_cbQueueSize / 2))
            {
                CBuffer *pBuff;
                hr = AllocateBuffer(&pBuff);
                if (FAILED(hr)) break;
                m_IOInProgressQueue.InsertTail(pBuff);
                pBuff->AsyncRead();
            }
        }
        else
        {
            m_IOInProgressQueue.MoveDoneBuffsToTailOf(m_FreeQueue);
            CompactFreeQueue();
        }
    }
    return hr;
}

/****************************************************************************
* CBaseAudio::UpdateDevicePosition *
*----------------------------------*
*   Description:  
*       Update the device position and return the amount of free space in the
*       audio object for reading/writing.
*
*       This function may be overridden by the derived class to do additional
*       work, however, the derived class must call this method before it
*       returns.
*
*       This function will only be called with the critical section owned.
*
*   Return:
*   TRUE - If the device needs servicing
*   FALSE - If there is no data to be serviced
******************************************************************** robch */
template <class ISpAudioDerivative>
BOOL CBaseAudio<ISpAudioDerivative>::UpdateDevicePosition(long * plFreeSpace, ULONG *pulNonBlockingIO)
{
    if (m_fWrite)
    {
        if (m_IOInProgressQueue.IsEmpty() && m_HaveDataQueue.IsEmpty())
        {
            // Some broken devices can have device positions which attempt to go backwards which we disallow
            // by ignoring it. This means they can then bet out of sync with the seek position when we have
            // finished writing all our data to them. Therefore we force the device position to equal the seek
            // position when have completed all our IO.
            // Note the seek position is updated when data is added to the HaveDataQueue - hence we require
            // both to be empty to do this validation.
            // Note we assert here if there is a mismatch so dodgy devices are very much in the developers
            // face since they could cause other subtle problems in SAPI.
            SPDBG_ASSERT(m_ullDevicePosition == m_ullSeekPosition);
            m_ullDevicePosition = m_ullSeekPosition;
        }

        SPDBG_ASSERT(m_ullDevicePosition <= m_ullSeekPosition);
        long lDataInQueue = (long)(m_ullSeekPosition - m_ullDevicePosition);
        if (plFreeSpace)
        {
            *plFreeSpace = ((long)m_cbQueueSize) - lDataInQueue;
        }
        if (pulNonBlockingIO)
        {
            *pulNonBlockingIO = ((long)m_cbQueueSize) - lDataInQueue - GetUnusedWriteBufferSpace();
        }
        return ((ULONG)lDataInQueue <= m_cbQueueSize);
    }
    else
    {
        SPDBG_ASSERT(m_ullDevicePosition >= m_ullSeekPosition);
        ULONG ulDataInQueue = (long)(m_ullDevicePosition - m_ullSeekPosition);
        if (plFreeSpace)
        {
            *plFreeSpace = ((long)m_cbQueueSize) - ((long)ulDataInQueue);
        }
        if (pulNonBlockingIO)
        {
            *pulNonBlockingIO = ulDataInQueue;
        }
        return ulDataInQueue;
    }
}

/****************************************************************************
* CBaseAudio::AllocateBuffer *
*----------------------------*
*   Description:  
*       Obtain a free device buffer, allocating one if necessary.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************** robch */
template <class ISpAudioDerivative>
HRESULT CBaseAudio<ISpAudioDerivative>::AllocateBuffer(CBuffer ** ppBuff)
{
    HRESULT hr = S_OK;
    *ppBuff = m_FreeQueue.RemoveHead();
    if (*ppBuff == NULL)
    {
        hr = AllocateDeviceBuffer(ppBuff);
        if (SUCCEEDED(hr))
        {
            SPDBG_ASSERT(*ppBuff);
            hr = (*ppBuff)->Init(m_cbBufferSize); 
            if (SUCCEEDED(hr))
            {
                m_cAllocatedBuffers++;
            }
            else
            {
                delete *ppBuff;
                *ppBuff = NULL;
            }
        }
    }
    return hr;
}

/****************************************************************************
* CBaseAudio::FreeBuffer *
*------------------------*
*   Description:  
*       Free a buffer, either by inserting into the free queue, or, if we
*       already have enough free buffers, deallocating it.
*
*   Return:
*   n/a
******************************************************************** robch */
template <class ISpAudioDerivative>
void CBaseAudio<ISpAudioDerivative>::FreeBuffer(CBuffer * pBuff)
{
    if (m_cAllocatedBuffers > m_cDesiredBuffers)
    {
        delete pBuff;
        m_cAllocatedBuffers--;
    }
    else
    {
        m_FreeQueue.InsertHead(pBuff);
    }
}

/****************************************************************************
* CBaseAudio::CompactFreeQueue *
*------------------------------*
*   Description:  
*       Compact the free queue by ensuring that we only have, at most, the 
*       requested number of free buffers in the free queue.
*
*   Return:
*   n/a
******************************************************************** robch */
template <class ISpAudioDerivative>
void CBaseAudio<ISpAudioDerivative>::CompactFreeQueue()
{
    CBuffer * pBuff;
    while (m_cAllocatedBuffers > m_cDesiredBuffers && (pBuff = m_FreeQueue.RemoveHead()))
    {
        FreeBuffer(pBuff);
    }
}

/****************************************************************************
* CBaseAudio::PurgeAllQueues *
*----------------------------*
*   Description:  
*       Purage all three queues (free, io in progress, and have data).
*
*   Return:
*   n/a
******************************************************************** robch */
template <class ISpAudioDerivative>
void CBaseAudio<ISpAudioDerivative>::PurgeAllQueues()
{
    m_FreeQueue.Purge();
    m_IOInProgressQueue.Purge();
    m_HaveDataQueue.Purge();
}

/****************************************************************************
* CBaseAudio::CheckForAsyncBufferCompletion *
*-------------------------------------------*
*   Description:  
*       Check to see if there are more device buffers available, as a side
*       effect, update our position and process events.
*
*   Return:
*   <>
******************************************************************** robch */
template <class ISpAudioDerivative>
void CBaseAudio<ISpAudioDerivative>::CheckForAsyncBufferCompletion()
{
    SPAUTO_OBJ_LOCK;
    ProcessDeviceBuffers(REASON_BUFFCOMPLETENOTIFY);
    InternalUpdatePosition();
    ProcessEvents();
}

/****************************************************************************
* CBaseAudio::InternalStateChange *
*---------------------------------*
*   Description:  
*       Change the state of the audio object to one of the states specified
*       by NewState.
*
*       This function will NOT be called with NewState == SPAS_CLOSED.  When
*       the device is being closed, this will be called with SPAS_STOP and 
*       the main thread code will then close the device.
*
*   Return:
*   <>
******************************************************************** robch */
template <class ISpAudioDerivative>
HRESULT CBaseAudio<ISpAudioDerivative>::InternalStateChange(SPAUDIOSTATE NewState)
{
    HRESULT hr = S_OK;
    if (NewState != m_State)
    {
        m_State = NewState;
        m_bPumpRunning = FALSE;     
        switch (NewState)
        {
        case SPAS_STOP:
            hr = ChangeDeviceState(NewState);
            if (SUCCEEDED(hr))
            {
                m_IOInProgressQueue.Purge();
                m_HaveDataQueue.Purge();
                m_FreeQueue.Purge();
                m_cAllocatedBuffers = 0;
                m_SpEventSource._RemoveAllEvents();    
                m_ullLastEventPos = m_ullDevicePosition = m_ullSeekPosition;
                if (m_BlockState != NotBlocked)
                {
                    m_BlockState = NotBlocked;
                    m_hrUnblockResult = SP_AUDIO_STOPPED;
                    m_autohBlockIoEvent.SetEvent();
                }
                m_fautohAPIEventSet = m_fWrite;
                if (m_fWrite)
                {
                    m_autohAPIEvent.SetEvent();
                }
                else
                {
                    m_autohAPIEvent.ResetEvent();
                }
            }
            break;

        case SPAS_PAUSE:
            m_dwLastReadTickCount = GetTickCount();
            hr = ChangeDeviceState(NewState);
            if (SUCCEEDED(hr))
            {
                if ((!m_fWrite) && m_BlockState != NotBlocked)
                {
                    m_BlockState = NotBlocked;
                    m_hrUnblockResult = SP_AUDIO_PAUSED;   // The read code will return the appropriate success code for pause...
                    m_autohBlockIoEvent.SetEvent();
                }
                hr = ProcessDeviceBuffers(REASON_PAUSE);
                if (SUCCEEDED(hr))
                {
                    ProcessEvents();
                }
            }
            break;

        case SPAS_RUN:

            m_dwLastReadTickCount = GetTickCount();
            hr = ChangeDeviceState(NewState);

            if (SUCCEEDED(hr))
            {
                CheckForAsyncBufferCompletion();
            }
            break;

        default:
            hr = SPERR_INVALID_AUDIO_STATE;
            SPDBG_ASSERT(FALSE);
        }
    }
    return hr;
}

/****************************************************************************
* CBaseAudio::InternalUpdatePosition *
*------------------------------------*
*   Description:  
*       Update the device position and unblock IO if we can/should.
*
*   Return:
*   n/a
******************************************************************** robch */
template <class ISpAudioDerivative>
void CBaseAudio<ISpAudioDerivative>::InternalUpdatePosition()
{
    BOOL fSetEvent;
    BOOL fNeedService = UpdateDevicePosition(NULL, NULL);
    if (fNeedService && m_BlockState == WaitingInReadOrWrite)
    {
        m_BlockState = NotBlocked;
        m_hrUnblockResult = S_OK;
        m_autohBlockIoEvent.SetEvent();
    }

    if (m_fWrite)
    {
        SPDBG_ASSERT(m_ullDevicePosition <= m_ullSeekPosition);
        if ((long)(m_ullSeekPosition - m_ullDevicePosition) + GetUnusedWriteBufferSpace()
                < m_cbBufferNotifySize)
        {
            fSetEvent = TRUE;
        }
        else
        {
            fSetEvent = FALSE;
        }
    }
    else
    {
        SPDBG_ASSERT(m_ullDevicePosition >= m_ullSeekPosition);
        if ((ULONG)(m_ullDevicePosition - m_ullSeekPosition) >=  m_cbBufferNotifySize)
        {
            fSetEvent = TRUE;
        }
        else
        {
            fSetEvent = FALSE;
        }
    }
    if (fSetEvent != m_fautohAPIEventSet)
    {
        if (fSetEvent)
        {
            m_autohAPIEvent.SetEvent();
        }
        else
        {
            m_autohAPIEvent.ResetEvent();
        }
        m_fautohAPIEventSet = fSetEvent;
    }
}

/****************************************************************************
* CBaseAudio::ProcessEvents *
*---------------------------*
*   Description:  
*       Process events for the current device position
*
*   Return:
*   n/a
******************************************************************** robch */
//
//  Call with critical section owned
//
template <class ISpAudioDerivative>
void CBaseAudio<ISpAudioDerivative>::ProcessEvents()
{
    if (m_ullLastEventPos != m_ullDevicePosition)
    {
        m_ullLastEventPos = m_ullDevicePosition;
        m_SpEventSource._CompleteEvents(m_ullDevicePosition + m_cbEventBias);
    }
}

/****************************************************************************
* CBaseAudio::GetUnusedWriteBufferSpace *
*---------------------------------------*
*   Description:  
*       Return the unused space in the last buffer of have data queue
*
*   Return:
******************************************************************* YUNUSM */
//
//  Call with critical section owned
//
template <class ISpAudioDerivative>
inline ULONG CBaseAudio<ISpAudioDerivative>::GetUnusedWriteBufferSpace(void)
{
    SPDBG_ASSERT(m_fWrite);
    SPDBG_ASSERT(m_ullDevicePosition <= m_ullSeekPosition);
    CBaseAudioBuffer *pNode = m_HaveDataQueue.GetHead();
    CBaseAudioBuffer *pLast = NULL;
    while (pNode)
    {
        pLast = pNode;
        pNode = m_HaveDataQueue.GetNext(pNode);
    }
    if (pLast)
    {
        return (pLast->GetDataSize() - pLast->GetWriteOffset());
    }
    else
    {
        return 0;
    }
}


#ifdef SAPI_AUTOMATION

//
//=== ISpeechBaseStream interface ==================================================
//

/*****************************************************************************
* CSpeechAudio::get_Format *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::get_Format( ISpeechAudioFormat** ppStreamFormat )
{
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppStreamFormat ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Create new object.
        CComObject<CSpeechAudioFormat> *pFormat;
        hr = CComObject<CSpeechAudioFormat>::CreateInstance( &pFormat );
        if ( SUCCEEDED( hr ) )
        {
            hr = pFormat->InitAudio( this );

            if ( SUCCEEDED( hr ) )
            {
                pFormat->AddRef();
                *ppStreamFormat = pFormat;
            }
        }
    }

    return hr;
} /* CSpeechAudio::get_Format */

/*****************************************************************************
* CSpeechAudio::Read *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::Read( VARIANT * pvtBuffer, long NumBytes, long* pRead )
{
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pvtBuffer ) || SP_IS_BAD_WRITE_PTR( pRead ) )
    {
        hr = E_POINTER;
    }
    else
    {
        BYTE *pArray;
        SAFEARRAY* psa = SafeArrayCreateVector( VT_UI1, 0, NumBytes );
        if( psa )
        {
            if( SUCCEEDED( hr = SafeArrayAccessData( psa, (void **)&pArray) ) )
            {
                hr = Read(pArray, NumBytes, (ULONG*)pRead);
                SafeArrayUnaccessData( psa );

                if ( NumBytes != *pRead )
                {
                    SAFEARRAYBOUND bounds = {*pRead, 0};
                    hr = SafeArrayRedim( psa, &bounds);
                }

                VariantClear(pvtBuffer);
                pvtBuffer->vt     = VT_ARRAY | VT_UI1;
                pvtBuffer->parray = psa;
 
                if ( !SUCCEEDED( hr ) )
                {
                    VariantClear(pvtBuffer);    // Free our memory if we failed.
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
} /* CSpeechAudio::Read */

/*****************************************************************************
* CSpeechAudio::Write *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::Write( VARIANT Buffer, long* pWritten )
{
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pWritten ) )
    {
        hr = E_POINTER;
    }
    else
    {
        BYTE * pData = NULL;
        ULONG ulDataSize = 0;

        hr = AccessVariantData( &Buffer, &pData, &ulDataSize );

        if( SUCCEEDED( hr ) )
        {
            hr = Write(pData, ulDataSize, (ULONG*)pWritten);
            UnaccessVariantData( &Buffer, pData );
        }
    }

    return hr;
} /* CSpeechAudio::Write */

/*****************************************************************************
* CSpeechAudio::Seek *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::Seek( VARIANT Move, SpeechStreamSeekPositionType Origin, VARIANT* pNewPosition )
{
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pNewPosition ) )
    {
        hr = E_POINTER;
    }
    else
    {
        ULARGE_INTEGER uliNewPos;
        LARGE_INTEGER liPos;

        hr = VariantToLongLong( &Move, &(liPos.QuadPart) );
        if (SUCCEEDED(hr))
        {
            hr = Seek(liPos, (DWORD)Origin, &uliNewPos);

            if (SUCCEEDED( hr ))
            {
                hr = ULongLongToVariant( uliNewPos.QuadPart, pNewPosition );
            }
        }
    }

    return hr;
} /* CSpeechAudio::Seek */


//
//=== ISpeechAudio interface ==================================================
//

/*****************************************************************************
* CBaseAudio::SetState *
*-------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::SetState( SpeechAudioState State )
{
    return SetState((SPAUDIOSTATE)State, 0);
} /* CBaseAudio::SetState */

/*****************************************************************************
* CBaseAudio::get_Status *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::get_Status( ISpeechAudioStatus** ppStatus )
{
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppStatus ) )
    {
        hr = E_POINTER;
    }
    else
    {
        SPAUDIOSTATUS Status;
        hr = GetStatus( &Status );

        if ( SUCCEEDED( hr ) )
        {
            // Create new object.
            CComObject<CSpeechAudioStatus> *pStatus;
            hr = CComObject<CSpeechAudioStatus>::CreateInstance( &pStatus );
            if ( SUCCEEDED( hr ) )
            {
                pStatus->AddRef();
                pStatus->m_AudioStatus = Status;
                *ppStatus = pStatus;
            }
        }
    }

    return hr;
} /* CBaseAudio::get_Status */

/*****************************************************************************
* CBaseAudio::get_BufferInfo *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::get_BufferInfo( ISpeechAudioBufferInfo** ppBufferInfo )
{
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppBufferInfo ) )
    {
        hr = E_POINTER;
    }
    else
    {
        // Create new object.
        CComObject<CSpeechAudioBufferInfo> *pBufferInfo;
        hr = CComObject<CSpeechAudioBufferInfo>::CreateInstance( &pBufferInfo );
        if ( SUCCEEDED( hr ) )
        {
            pBufferInfo->AddRef();
            pBufferInfo->m_pSpMMSysAudio = this; // Keep ref.
            *ppBufferInfo = pBufferInfo;
        }
    }

    return hr;
} /* CBaseAudio::get_BufferInfo */

/*****************************************************************************
* CBaseAudio::get_DefaultFormat *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::get_DefaultFormat( ISpeechAudioFormat** ppFormat )
{
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( ppFormat ) )
    {
        hr = E_POINTER;
    }
    else
    {
        GUID            guid;
        WAVEFORMATEX *  pWFEx;  // Must free.

        hr = GetDefaultFormat( &guid, &pWFEx );

        if ( SUCCEEDED( hr ))
        {
            // Create new object.
            CComObject<CSpeechAudioFormat> *pFormat;
            hr = CComObject<CSpeechAudioFormat>::CreateInstance( &pFormat );
            if ( SUCCEEDED( hr ) )
            {
                hr = pFormat->InitFormat( guid, pWFEx, true );
                if ( SUCCEEDED( hr ) )
                {
                    pFormat->AddRef();
                    *ppFormat = pFormat;
                }
            }

            if ( pWFEx )
            {
                ::CoTaskMemFree( pWFEx );
            }
        }
    }

    return hr;
} /* CBaseAudio::get_DefaultFormat */

/*****************************************************************************
* CBaseAudio::get_Volume *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::get_Volume( long* pVolume )
{
    return GetVolumeLevel( (ULONG*)pVolume );
} /* CBaseAudio::get_Volume */

/*****************************************************************************
* CBaseAudio::put_Volume *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::put_Volume( long Volume )
{
    return SetVolumeLevel( (ULONG)Volume );
} /* CBaseAudio::put_Volume */

/*****************************************************************************
* CBaseAudio::get_BufferNotifySize *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::get_BufferNotifySize( long* pBufferNotifySize )
{
    return GetBufferNotifySize( (ULONG*)pBufferNotifySize );
} /* CBaseAudio::get_BufferNotifySize */

/*****************************************************************************
* CBaseAudio::put_BufferNotifySize *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::put_BufferNotifySize( long BufferNotifySize )
{
    return SetBufferNotifySize( (ULONG)BufferNotifySize );
} /* CBaseAudio::put_BufferNotifySize */


/*****************************************************************************
* CBaseAudio::get_EventHandle *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::get_EventHandle( long* pEventHandle )
{
    HRESULT hr = S_OK;

    if( SP_IS_BAD_WRITE_PTR( pEventHandle ) )
    {
        hr = E_POINTER;
    }
    else
    {
        *pEventHandle = HandleToLong( EventHandle() );
    }

    return hr;
} /* CBaseAudio::get_EventHandle */

/*****************************************************************************
* CBaseAudio::putref_Format *
*-----------------------------*
*   Description:
*       This method 
********************************************************************* TODDT ***/
template <class ISpAudioDerivative>
STDMETHODIMP CBaseAudio<ISpAudioDerivative>::putref_Format( ISpeechAudioFormat* pAudioFormat )
{
    HRESULT hr = S_OK;

    if( SP_IS_BAD_INTERFACE_PTR( pAudioFormat ) )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        GUID            g;
        CComBSTR        szGuid;

        hr = pAudioFormat->get_Guid( &szGuid );

        if ( SUCCEEDED( hr ) )
        {
            hr = IIDFromString(szGuid, &g);
        }

        if ( SUCCEEDED( hr ) )
        {
            CComPtr<ISpeechWaveFormatEx> pWFEx;
            WAVEFORMATEX *  pWFExStruct = NULL;

            hr = pAudioFormat->GetWaveFormatEx( &pWFEx );

            if ( SUCCEEDED( hr ) )
            {
                hr = WaveFormatExFromInterface( pWFEx, &pWFExStruct );

                if ( SUCCEEDED( hr ) )
                {
                    hr = SetFormat(g, pWFExStruct);
                }

                ::CoTaskMemFree( pWFExStruct );
            }
        }
    }

    return hr;
} /* CBaseAudio::putref_Format */


#endif // SAPI_AUTOMATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\baseaudiobuffer.h ===
/****************************************************************************
*   baseaudiobuffer.h
*       Declarations for the CBaseAudioBuffer template class
*
*   Owner: robch
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#pragma once

//--- Class, Struct and Union Definitions -----------------------------------

/****************************************************************************
*
*   CBaseAudioBuffer
*
******************************************************************** robch */
class CBaseAudioBuffer
{
//=== Methods ===
public:

    //--- Ctor, dtor
    CBaseAudioBuffer();
    virtual ~CBaseAudioBuffer();

    //--- Initialize the buffer with a specific size
    virtual HRESULT Init(ULONG cbDataSize);

    //--- Accessors for the data size, the read offset, and the write offset
    virtual ULONG GetDataSize() const { return m_cbDataSize; };
    virtual ULONG GetReadOffset() const { return m_cbReadOffset; };
    virtual ULONG GetWriteOffset() const { return m_cbWriteOffset; };
    
    //--- Helper for checking if the buffer is empty
    BOOL IsEmpty() const { return GetReadOffset() == GetWriteOffset(); };

    //--- Reset the buffer for reuse
    virtual void Reset(ULONGLONG ullPos);

    //--- Read/write data from/to internal buffer
    virtual ULONG Read(void ** ppvData, ULONG * pcb);
    virtual ULONG Write(const void ** ppvData, ULONG * pcb);

    //-- Reading/writing is typically done asynchronously
    virtual HRESULT AsyncRead() = 0;
    virtual HRESULT AsyncWrite() = 0;
    virtual HRESULT IsAsyncDone() = 0;

    virtual HRESULT GetAudioLevel(ULONG *pulLevel,
        REFGUID rguidFormatId, const WAVEFORMATEX * pWaveFormatEx);

//=== Public data (used for containment in queue) ===
public:

    CBaseAudioBuffer *m_pNext;

    /*	
    #ifdef _WIN32_WCE
    // This is here because the CE compiler is expanding templates for functions
    // that aren't being called
    static LONG Compare(const Derived * pElem1, const Derived * pElem2)
    {
        return 0;
    }
    #endif // _WIN32_WCE
    */
	

public:
    virtual HRESULT WriteToInternalBuffer(const void *pvData, ULONG cb) = 0;
    virtual HRESULT ReadFromInternalBuffer(void *pvData, ULONG cb) = 0;
    virtual void SetReadOffset(ULONG cb) { m_cbReadOffset = cb; };

    WAVEHDR m_Header;

//=== Protected methods ===
protected:

    //--- Allocate, read from and write to internal buffers
    virtual BOOL AllocInternalBuffer(ULONG cb) = 0;
    //virtual HRESULT ReadFromInternalBuffer(void *pvData, ULONG cb) = 0;
    //virtual HRESULT WriteToInternalBuffer(const void *pvData, ULONG cb) = 0;

    //--- Manage the read and write offsets
    //virtual void SetReadOffset(ULONG cb) { m_cbReadOffset = cb; };
    virtual void SetWriteOffset(ULONG cb) { m_cbWriteOffset = cb; };

private:

    ULONG m_cbDataSize;
    ULONG m_cbReadOffset;
    ULONG m_cbWriteOffset;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\dict.cpp ===
/*******************************************************************************
* Dict.cpp *
*----------*
*       This is the cpp file for the CSpUnCompressedLexicon class that is the object implementing
*       shared user and application lexicons. Look in the header file for more
*       description of the custom lexicon object.
*
*  Owner: YUNUSM                                        Date: 06/18/99
*  Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
*******************************************************************************/

//--- Includes ----------------------------------------------------------------

#include "stdafx.h"
#include "Dict.h"
#include <shfolder.h>
#include <initguid.h>

//--- Globals -----------------------------------------------------------------

static const DWORD g_dwDefaultFlushRate = 10;           // The (default) nth write on which the lexicon is serialized
static const DWORD g_dwInitHashSize = 50;               // initial hash table length per LangID in a dict file
static const DWORD g_dwCacheSize = 25;                  // This is the maximum number of (latest) word additions we can efficiently access
static const DWORD g_dwNumLangIDsSupported = 25;          // Maximum number of LangIDs supported
static const WCHAR *g_pszDictInitMutexName = L"30F1B4D6-EEDA-11d2-9C23-00C04F8EF87C"; // mutex to serialize the init and creation of custom 
// {F893034C-29C1-11d3-9C26-00C04F8EF87C}
DEFINE_GUID(g_guidCustomLexValidationId, 0xf893034c, 0x29c1, 0x11d3, 0x9c, 0x26, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

//--- Constructor, Initializer and Destructor functions ------------------------

/*******************************************************************************
* CSpUnCompressedLexicon::CSpUnCompressedLexicon *
*------------------------------------------------*
/**************************************************************** YUNUSM ******/
CSpUnCompressedLexicon::CSpUnCompressedLexicon()
{
    SPDBG_FUNC("CSpUnCompressedLexicon::CSpUnCompressedLexicon");

    m_fInit = false;
    m_eLexType = eLEXTYPE_USER;
    m_pRWLexInfo = NULL;
    m_hInitMutex = NULL;
    m_pSharedMem = NULL;
    m_hFileMapping = NULL;
    m_dwMaxDictionarySize = 0;
    *m_wDictFile = 0;
    m_pChangedWordsCache = NULL;
    m_pRWLock = NULL;
    m_iWrite = 0;
    m_dwFlushRate = g_dwDefaultFlushRate;
    m_cpPhoneConv = NULL;
    m_LangIDPhoneConv = (LANGID)(-1);
    m_fReadOnly = false;
}

/*******************************************************************************
* CSpUnCompressedLexicon::~CSpUnCompressedLexicon() *
*---------------------------------------------------*
/**************************************************************** YUNUSM ******/
CSpUnCompressedLexicon::~CSpUnCompressedLexicon()
{
    SPDBG_FUNC("CSpUnCompressedLexicon::~CSpUnCompressedLexicon");

    if (m_fInit && !m_fReadOnly)
    {
        Serialize(false);
    }
    CloseHandle(m_hInitMutex);
    UnmapViewOfFile(m_pSharedMem);
    CloseHandle(m_hFileMapping);
    delete m_pRWLock;
}

/*******************************************************************************
* CSpUnCompressedLexicon::Init *
*------------------------------*
*   Description:
*       Reads the custom lexicon form a file. If the
*       file does not exist then it is created and inited
*
***************************************************************** YUNUSM ******/
HRESULT CSpUnCompressedLexicon::Init(const WCHAR *pwszLexFile, BOOL fNewFile)
{
    SPDBG_FUNC("CSpUnCompressedLexicon::Init");
    
    // We can get super long names from even internal callers
    if (wcslen(pwszLexFile) + 1 > (sizeof(m_wDictFile) / sizeof(WCHAR)))
    {
        return E_INVALIDARG;
    }
    bool fLockAcquired = false;
    HRESULT hr = S_OK;

    // Calculate the max size this custom lexicon can grow to
    // We want to grow to a max of 10% of the page file size available at this moment
    // or 10M whichever is smaller
#ifdef _WIN32_WCE
    MEMORYSTATUS MemStatus;
    GlobalMemoryStatus(&MemStatus);
    // WCE does not support PageFile
    m_dwMaxDictionarySize = MemStatus.dwAvailVirtual / 10;
#else  //_WIN32_WCE
    MEMORYSTATUSEX MemStatusEx;
    MemStatusEx.dwLength = sizeof(MemStatusEx);
	BOOL (PASCAL *lpfnGlobalMemoryStatusEx)(MEMORYSTATUSEX *);
	(FARPROC&)lpfnGlobalMemoryStatusEx = GetProcAddress(GetModuleHandle(_T("kernel32.dll")), "GlobalMemoryStatusEx");
    if (lpfnGlobalMemoryStatusEx && lpfnGlobalMemoryStatusEx(&MemStatusEx))
    {
        if (MemStatusEx.ullAvailPageFile > (DWORD)0x7fffffff)
		{
            MemStatusEx.ullAvailPageFile = (DWORD)0x7fffffff;
		}
        m_dwMaxDictionarySize = ((DWORD)(MemStatusEx.ullAvailPageFile)) / 10;
    }
    else
    {
        // GlobalMemoryStatus does not return an error. If it fails and the memory avialable
        // values are out of whack we will fail in the memory map creation below and catch that
        MEMORYSTATUS MemStatus;
        GlobalMemoryStatus(&MemStatus);
        m_dwMaxDictionarySize = ((DWORD)MemStatus.dwAvailPageFile) / 10;
    }
#endif  //_WIN32_WCE
    
    if (m_dwMaxDictionarySize > 10 * 1024 * 1024)
    {
        m_dwMaxDictionarySize = 10 * 1024 * 1024;
    }
    // Round downwards the max dictionary size to the allocation granularity. This is so that
    // MapViewofFile succeeds
    if (SUCCEEDED(hr))
    {
        SYSTEM_INFO SI;
        GetSystemInfo(&SI);
        m_dwMaxDictionarySize = (m_dwMaxDictionarySize / SI.dwAllocationGranularity) * SI.dwAllocationGranularity;
    }
    // Create the mutex
    if (SUCCEEDED(hr))
    {
        m_hInitMutex = g_Unicode.CreateMutex(NULL, FALSE, g_pszDictInitMutexName);
        if (!m_hInitMutex)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    HANDLE hFile = NULL;
    // Acquire the mutex. Open the file. If file does not exist, create it.
    if (SUCCEEDED(hr))
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(m_hInitMutex, INFINITE))
        {
            fLockAcquired = true;
        }
        else
        {
            hr = E_FAIL;
        }
        if (SUCCEEDED(hr))
        {
            wcscpy(m_wDictFile, pwszLexFile);
            if (fNewFile)
            {
                // if file does not exist, create a read/write file
                hr = BuildEmptyDict(pwszLexFile);
            }
            else
            {
                // App lexicons are read-only except when newly created.
                if (m_eLexType == eLEXTYPE_APP)
                {
                    m_fReadOnly = true;
                }
            }
            if (SUCCEEDED(hr))
            {
                hFile = g_Unicode.CreateFile(pwszLexFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, 
                                             FILE_ATTRIBUTE_NORMAL, NULL);
                if (INVALID_HANDLE_VALUE == hFile)
                {
                    hr = SpHrFromLastWin32Error();
                    if ((SpHrFromWin32(ERROR_PATH_NOT_FOUND) == hr || SpHrFromWin32(ERROR_FILE_NOT_FOUND) == hr) && 
                         m_eLexType == eLEXTYPE_USER)
                    {
                        // Registry entry still exists. But file pointed to has vanished. Handle
                        // this scenario more gracefully by recreating the user lexicon.
                        // We don't need to do this for app lexicons also as this is handled correctly
                        // later (the 'corrupted' app lexicon is simply ignored.
                        CSpDynamicString dstrLexFile;
                        hr = m_cpObjectToken->RemoveStorageFileName(CLSID_SpUnCompressedLexicon, L"Datafile", TRUE);
                        if (SUCCEEDED(hr))
                        {
                            hr = m_cpObjectToken->GetStorageFileName(CLSID_SpUnCompressedLexicon, L"Datafile", L"UserLexicons\\", CSIDL_FLAG_CREATE | CSIDL_APPDATA, &dstrLexFile);
                        }
                        if (SUCCEEDED(hr))
                        {
                            hr = BuildEmptyDict(dstrLexFile);
                        }
                        if (SUCCEEDED(hr))
                        {
                            hFile = g_Unicode.CreateFile(dstrLexFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, 
                                                         FILE_ATTRIBUTE_NORMAL, NULL);
                            if (INVALID_HANDLE_VALUE == hFile)
                            {
                                hr = SpHrFromLastWin32Error();
                            }
                            else
                            {
                                wcscpy(m_wDictFile, dstrLexFile);
                            }
                        }
                    }
                }
            }
        }
    }
    RWLEXINFO RWInfo;
    DWORD nRead = 0;
    // Read the header from the file
    if (SUCCEEDED(hr))
    {
        if (!ReadFile(hFile, &RWInfo, sizeof(RWInfo), &nRead, NULL) || nRead != sizeof(RWInfo))
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    // Validate the file
    if (SUCCEEDED(hr))
    {
        if (RWInfo.guidValidationId != g_guidCustomLexValidationId)
        {
            hr = E_INVALIDARG;
        }
    }
    // Get the file size
    if (SUCCEEDED(hr))
    {
        if ((DWORD)-1 == SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    DWORD nFileSize = 0;
    if (SUCCEEDED(hr))
    {
        nFileSize = GetFileSize(hFile, NULL);
        if (0xffffffff == nFileSize)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    // We do not support custom lexicons of size greater than m_dwMaxDictionarySize
    if (SUCCEEDED(hr))
    {
        if (nFileSize > m_dwMaxDictionarySize)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    OLECHAR szMapName[64];
    if (!StringFromGUID2(RWInfo.guidLexiconId, szMapName, sizeof(szMapName)/sizeof(OLECHAR)))
    {
        hr = E_FAIL;
    }
    // Create the map file
    if (SUCCEEDED(hr))
    {
        HANDLE hRsrc = INVALID_HANDLE_VALUE;
        DWORD dwSizeMap = m_dwMaxDictionarySize;
        m_hFileMapping =  g_Unicode.CreateFileMapping(hRsrc, NULL, PAGE_READWRITE, 0, dwSizeMap, szMapName);
        if (!m_hFileMapping)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    bool fMapCreated = false;
    // Map a view of the file
    if (SUCCEEDED(hr))
    {
        if (ERROR_ALREADY_EXISTS == GetLastError())
        {
            fMapCreated = false;
        }
        else
        {
            fMapCreated = true;
        }
        DWORD dwDesiredAccess = FILE_MAP_WRITE;
        m_pSharedMem = (BYTE*)MapViewOfFile(m_hFileMapping, dwDesiredAccess, 0, 0, 0);
        if (!m_pSharedMem)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    // Create the reader/writer lock if necessary
    if (SUCCEEDED(hr))
    {
        m_pRWLock = new CRWLock(&(RWInfo.RWLockInfo), hr);
        if (SUCCEEDED(hr))
        {
            // Read in the file if the map has been created (and not an existing map has been opened)
            if (fMapCreated == true && 
                (!ReadFile(hFile, m_pSharedMem, nFileSize, &nRead, NULL) || (nRead != nFileSize)))
            {
                hr = SpHrFromWin32(GetLastError ());
            }
        }
    }
    // set the RWLEXINFO header pointer and the changed words cache
    if (SUCCEEDED(hr))
    {
        m_pRWLexInfo = (PRWLEXINFO) m_pSharedMem;
        m_pChangedWordsCache = (PWCACHENODE) (m_pSharedMem + sizeof(RWLEXINFO) + g_dwNumLangIDsSupported * sizeof (LANGIDNODE));
        m_fInit = true;
    }
    // We operate on the memory - so release the file handle so 
    // that the file can be later serialized
    CloseHandle(hFile);
    if (fLockAcquired)
    {
        ReleaseMutex (m_hInitMutex);
    }
    return hr;
}

//--- ISpLexicon methods -------------------------------------------------------

/*******************************************************************************
* CSpUnCompressedLexicon::GetPronunciations *
*-------------------------------------------*
*   Description:
*       Gets the pronunciations and POSs of a word for a LangID. If the
*       LangID is zero then all LangIDs are matched.
*
*   Return:
*       SPERR_NOT_IN_LEX
*       E_OUTOFMEMORY
*       S_OK
**************************************************************** YUNUSM *******/
STDMETHODIMP CSpUnCompressedLexicon::GetPronunciations( const WCHAR *pszWord,                             // word
                                                        LANGID LangID,                                    // LANGID of word (can be zero)
                                                        DWORD,                                            // type of the lexicon - LEXTYPE_USER
                                                        SPWORDPRONUNCIATIONLIST * pWordPronunciationList  // buffer to return prons/POSs in
                                                        )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::GetPronunciations");

    if (SPIsBadWordPronunciationList(pWordPronunciationList))
    {
        return E_POINTER;
    }
    if (!pszWord || !pWordPronunciationList ||
        SPIsBadLexWord(pszWord))
    {
        return E_INVALIDARG;
    }
    if (!m_fInit)
    {
        return SPERR_UNINITIALIZED;
    }
    
    m_pRWLock->ClaimReaderLock();
    
    HRESULT hr = S_OK;
    LANGIDNODE *pLN = (LANGIDNODE *)(m_pSharedMem + sizeof(RWLEXINFO));
    LANGID aQueryLangIDs[g_dwNumLangIDsSupported];
    DWORD dwQueryLangIDs = 0;
    if (LangID)
    {
        // Query a specific LangID
        dwQueryLangIDs = 1;
        aQueryLangIDs[0] = LangID;
    }
    else
    {
        // Query all LangIDs
        dwQueryLangIDs = 0;
        for (DWORD i = 0; i < g_dwNumLangIDsSupported; i++)
        {
            if (!(pLN[i].LangID))
            {
                continue;
            }    
            aQueryLangIDs[dwQueryLangIDs++] = pLN[i].LangID;
        }
    }
    DWORD nWordOffset = 0;
    // Find the word
    // We return the word from only one of the LangIDs. That is correct because the words are langid specific.
    for (DWORD iLangID = 0; SUCCEEDED(hr) && !nWordOffset && (iLangID < dwQueryLangIDs); iLangID++)
    {
        LangID = aQueryLangIDs[iLangID];
        hr = WordOffsetFromLangID(aQueryLangIDs[iLangID], pszWord, &nWordOffset);
    }
    if (SUCCEEDED(hr))
    {
        if (!nWordOffset)
        {
            hr = SPERR_NOT_IN_LEX; // word does not exist
        }
        else
        {
            UNALIGNED DICTNODE* pDictNode = (UNALIGNED DICTNODE*)(m_pSharedMem + nWordOffset);
            if (!pDictNode->nNumInfoBlocks)
            {
                hr = SP_WORD_EXISTS_WITHOUT_PRONUNCIATION;
                // Blank passed in list.
                pWordPronunciationList->pFirstWordPronunciation = NULL;
            }
            else
            {
                // Get the word's information
                hr = SPListFromDictNodeOffset(LangID, nWordOffset, pWordPronunciationList);
            }
        }
    }
    m_pRWLock->ReleaseReaderLock();
    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::AddPronunciation *
*------------------------------------------*
*   Description:
*       Adds a word and its pronunciation/POS. If the word exists the
*       pron/POS are appended to the existing prons/POSs.
*
*   Return: 
*       E_INVALIDARG
*       LEXERR_ALREADYINLEX
*       E_OUTOFMEMORY
*       S_OK
**************************************************************** YUNUSM *******/
STDMETHODIMP CSpUnCompressedLexicon::AddPronunciation(  const WCHAR *pszWord,              // Word to add                    
                                                        LANGID LangID,                     // LangID of this word (cannot be zero)
                                                        SPPARTOFSPEECH ePartOfSpeech,      // Information(s) for this word  
                                                        const SPPHONEID *pszPronunciation      // New offset of the word        
                                                        )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::AddPronunciation");

    BOOL fBad = TRUE;
    if(pszPronunciation && SPIsBadStringPtr(pszPronunciation))
    {
        return E_INVALIDARG;
    }
    if (!LangID ||
        !pszWord || SPIsBadLexWord(pszWord) ||
        pszPronunciation && *pszPronunciation != L'\0' && (SPIsBadPartOfSpeech(ePartOfSpeech) ||
        FAILED(IsBadLexPronunciation(LangID, pszPronunciation, &fBad)) ||
        TRUE == fBad))
    {
        return E_INVALIDARG;
    }
    if (!m_fInit)
    {
        return SPERR_UNINITIALIZED;
    }
    if (m_fReadOnly)
    {
        return SPERR_APPLEX_READ_ONLY;
    }

    HRESULT hr = S_OK;
    DWORD nNewWordOffset = 0;
    DWORD nNewNodeSize = 0;
    DWORD nNewInfoSize = 0;
    WORDINFO *pNewInfo = NULL;

    if (SUCCEEDED(hr))
    {
        // Convert to zero length string
        if(pszPronunciation && *pszPronunciation == L'\0')
        {
            pszPronunciation = NULL;
        }

        // Convert the POS/pron to a WORDINFO array
        if (pszPronunciation)
        {
            pNewInfo = SPPRONToLexWordInfo(ePartOfSpeech, pszPronunciation);
            if (!pNewInfo)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    m_pRWLock->ClaimWriterLock ();
    
    // Look for LangID header. If not found create it
    if (SUCCEEDED(hr))
    {
        DWORD iLangID = LangIDIndexFromLangID(LangID);
        if (iLangID == (DWORD)-1)
        {
            hr = AddLangID(LangID);
        }
    }
    // find the word
    DWORD nOldWordOffset = 0;
    if (SUCCEEDED(hr))
    {
        hr = WordOffsetFromLangID(LangID, pszWord, &nOldWordOffset);
    }
    if (SUCCEEDED(hr) && nOldWordOffset)
    {
        if (!pszPronunciation)
        {
            hr = SP_ALREADY_IN_LEX;  // Word already exists
        }
        else
        {
            if (OffsetOfSubWordInfo(nOldWordOffset, pNewInfo))
            {
                hr = SP_ALREADY_IN_LEX;  // the POS-Pron combination already exists
            }
        }
    }
    if (SUCCEEDED(hr) && hr != SP_ALREADY_IN_LEX)
    {
        DWORD nNewNodeSize = 0;
        DWORD nNewInfoSize = 0;
        DWORD nNewNumInfo = 0;
        if (pszPronunciation)
        {
            nNewNumInfo = 1;
        }
        SizeOfDictNode(pszWord, pNewInfo, nNewNumInfo, &nNewNodeSize, &nNewInfoSize);

        WORDINFO *pOldInfo = WordInfoFromDictNodeOffset(nOldWordOffset);
        DWORD nOldNumInfo = NumInfoBlocksFromDictNodeOffset(nOldWordOffset);
        DWORD nOldInfoSize = SizeofWordInfoArray(pOldInfo, nOldNumInfo);

        // Add the new word and get its offset
        hr = AddWordAndInfo(pszWord, pNewInfo, nNewNodeSize, nNewInfoSize, nNewNumInfo, pOldInfo, 
                            nOldInfoSize, nOldNumInfo, &nNewWordOffset);
        if (SUCCEEDED(hr))
        {
            AddWordToHashTable(LangID, nNewWordOffset, !nOldWordOffset);
            if (nOldWordOffset)
            {
                DeleteWordFromHashTable(LangID, nOldWordOffset, false);
                // mark the old version of word as deleted
                AddCacheEntry(false, LangID, nOldWordOffset);
            }
    
            // mark the new version of word as added
            AddCacheEntry(true, LangID, nNewWordOffset);
        }
    }
    if (pNewInfo)
    {
        delete [] pNewInfo;
    }
    m_pRWLock->ReleaseWriterLock();
    if (SUCCEEDED(hr))
    {
        Flush(++m_iWrite);
    }
    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::RemovePronunciation *
*---------------------------------------------*
*   Description: 
*       Removes the pronunciation/POS of a word. If this is
*       the only pron/POS of this word then the word is deleted.
*
*   Return: 
*       E_INVALIDARG
*       SPERR_NOT_IN_LEX
*       E_OUTOFMEMORY
*       S_OK
**************************************************************** YUNUSM *******/
STDMETHODIMP CSpUnCompressedLexicon::RemovePronunciation(  const WCHAR * pszWord,              // word
                                                           LANGID LangID,                          // LangID (cannot be zero)
                                                           SPPARTOFSPEECH ePartOfSpeech,       // POS
                                                           const SPPHONEID * pszPronunciation      // pron
                                                           )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::RemovePronunciation");

    BOOL fBad = TRUE;
    if(pszPronunciation && SPIsBadStringPtr(pszPronunciation))
    {
        return E_INVALIDARG;
    }
    if (!LangID ||
        !pszWord || SPIsBadLexWord(pszWord) ||
        pszPronunciation && *pszPronunciation != L'\0' && (SPIsBadPartOfSpeech(ePartOfSpeech) ||
        FAILED(IsBadLexPronunciation(LangID, pszPronunciation, &fBad)) ||
        TRUE == fBad))
    {
        return E_INVALIDARG;
    }
    if (!m_fInit)
    {
        return SPERR_UNINITIALIZED;
    }
    if (m_fReadOnly)
    {
        return SPERR_APPLEX_READ_ONLY;
    }

    HRESULT hr = S_OK;
 
    m_pRWLock->ClaimWriterLock ();

    bool fDeleteEntireWord = false;
    if (!pszPronunciation || *pszPronunciation == L'\0')
    {
        fDeleteEntireWord = true;
    }
    // Look for LangID header
    if (SUCCEEDED(hr))
    {
        DWORD iLangID = LangIDIndexFromLangID(LangID);
        if (iLangID == (DWORD)-1)
        {
            hr = SPERR_NOT_IN_LEX;
        }
    }
    UNALIGNED DICTNODE * pDictNode = NULL;
    WORDINFO *pWordInfo = NULL;
    DWORD nWordOffset = 0;
    WORDINFO *pRemoveInfo = NULL;
    DWORD nRemoveOffset = 0;
    // Find the word
    if (SUCCEEDED(hr))
    {
        hr = WordOffsetFromLangID(LangID, pszWord, &nWordOffset);
        if (SUCCEEDED(hr))
        {
            if (!nWordOffset)
            {
                hr = SPERR_NOT_IN_LEX;
            }
            else if (false == fDeleteEntireWord)
            {
                pDictNode = (UNALIGNED DICTNODE *)(m_pSharedMem + nWordOffset);
                pWordInfo = WordInfoFromDictNode(pDictNode);

                // look for the passed in pron and POS in word's info
                pRemoveInfo = SPPRONToLexWordInfo(ePartOfSpeech, pszPronunciation);
                if (!pRemoveInfo)
                {
                    hr = E_OUTOFMEMORY;
                }
                if (SUCCEEDED(hr))
                {
                    nRemoveOffset = OffsetOfSubWordInfo(nWordOffset, pRemoveInfo);
                    if (nRemoveOffset)
                    {
                        if (pDictNode->nNumInfoBlocks == 1)
                        {
                            fDeleteEntireWord = true;
                        }
                    }
                    else
                    {
                        hr = SPERR_NOT_IN_LEX;
                    }
                    delete [] pRemoveInfo;
                }
            }
        }
    }
    WORDINFO *pRemainingInfo = NULL;
    // Do the actual deletion
    if (SUCCEEDED(hr))
    {
        // Delete the current dictnode from hash table. The word will still exist
        // but will not be accessible thru hash table
        DeleteWordFromHashTable(LangID, nWordOffset, fDeleteEntireWord);
        // fDeleteEntireWord flag here defines whether word count is decremented.

        // Add the word's offset in cache
        AddCacheEntry(false, LangID, nWordOffset);
        // Since we are not calling DeleteWordDictNode (because we are not deleting
        // the physical memory) which is where the fRemovals flag gets set we've to set it here
        m_pRWLexInfo->fRemovals = true;

        if (!fDeleteEntireWord)
        {
            DWORD nWordInfoSize = 0;
            DWORD nRemoveInfoSize = 0;

            // construct a WORDINFO array of (original - remove)
            pRemainingInfo = (WORDINFO *) malloc (pDictNode->nSize);
            if (!pRemainingInfo)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                pRemoveInfo = (WORDINFO*)(m_pSharedMem + nRemoveOffset);
                CopyMemory(pRemainingInfo, pWordInfo, ((PBYTE)pRemoveInfo) - ((PBYTE)pWordInfo));

                nWordInfoSize = SizeofWordInfoArray(pWordInfo, pDictNode->nNumInfoBlocks);
                nRemoveInfoSize = SizeofWordInfoArray(pRemoveInfo, 1);

                CopyMemory(((PBYTE)pRemainingInfo) + (((PBYTE)pRemoveInfo) - ((PBYTE)pWordInfo)),
                           ((PBYTE)pRemoveInfo) + nRemoveInfoSize,
                           nWordInfoSize - nRemoveInfoSize - (((PBYTE)pRemoveInfo) - ((PBYTE)pWordInfo)));
            }
            DWORD nRemainingWordOffset;
            if (SUCCEEDED(hr))
            {
                // Add the remaining word as DICTNODE and then add it to hash table
                hr = AddWordAndInfo(pszWord, pRemainingInfo, 
                            nWordInfoSize - nRemoveInfoSize + sizeof(DICTNODE) + (wcslen(pszWord) + 1) * sizeof(WCHAR),
                            nWordInfoSize - nRemoveInfoSize, pDictNode->nNumInfoBlocks - 1, NULL, 0, 0, &nRemainingWordOffset);
            }
            if (SUCCEEDED(hr))
            {
                // No need to increment word count since not decremented earlier.
                AddWordToHashTable(LangID, nRemainingWordOffset, false);
                // Mark the new version of the word as added.
                AddCacheEntry(true, LangID, nRemainingWordOffset);
            }
        }
    }
    free (pRemainingInfo);
    m_pRWLock->ReleaseWriterLock();

    if (SUCCEEDED(hr))
    {
        Flush(++m_iWrite);
    }

    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::GetGeneration *
*---------------------------------------*
*   Description:
*       Removes the pronunciation/POS of a word. If this is
*       the only pron/POS of this word then the word is deleted.
*
*   Return:
*       SPERR_NOT_IN_LEX
*       E_OUTOFMEMORY
*       S_OK
*       SP_LEX_NOTHING_TO_SYNC      - Read only app lexicon - never a generation change.
**************************************************************** YUNUSM *******/
STDMETHODIMP CSpUnCompressedLexicon::GetGeneration( DWORD *pdwGeneration      // returned generation id
                                                    )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::GetGeneration");

    HRESULT hr = S_OK;

    if (!pdwGeneration || SPIsBadWritePtr(pdwGeneration, sizeof(DWORD)))
    {
        hr = E_POINTER;
    }
    if (S_OK == hr && !m_fInit)
    {
        hr = SPERR_UNINITIALIZED;
    }
    if (S_OK == hr && m_fReadOnly)
    {
        SPDBG_ASSERT(*pdwGeneration == m_pRWLexInfo->nGenerationId);
        hr = SP_LEX_NOTHING_TO_SYNC;
    }
    if (SUCCEEDED(hr))
    {
        *pdwGeneration = m_pRWLexInfo->nGenerationId;
    }
    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::GetGenerationChange *
*---------------------------------------------*
*   Description:
*       This function gets the changes with generation id between the
*       passed in generation id and the current generation id.
*
*   Return:
*       SPERR_LEX_VERY_OUT_OF_SYNC
*       SP_LEX_NOTHING_TO_SYNC
*       E_INVALIDARG
*       E_OUTOFMEMORY
*       S_OK
*       SP_LEX_NOTHING_TO_SYNC      - Read only app lexicon - never a generation change.
**************************************************************** YUNUSM *******/
STDMETHODIMP CSpUnCompressedLexicon::GetGenerationChange(  DWORD dwFlags,
                                                           DWORD *pdwGeneration,       // generation id of client passed in, current lex gen id passed out
                                                           SPWORDLIST *pWordList       // buffer holding list of words and their info returned
                                                           )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::GetGenerationChange");

    if (!pdwGeneration ||
        SPIsBadWritePtr(pdwGeneration, sizeof(DWORD)) || SPIsBadWordList(pWordList))
    {
        return E_POINTER;
    }
    if (!m_fInit)
    {
        return SPERR_UNINITIALIZED;
    }
    if (static_cast<SPLEXICONTYPE>(dwFlags) != m_eLexType)
    {
        return E_INVALIDARG;
    }
    if (m_fReadOnly)
    {
        pWordList->pFirstWord = NULL;
        SPDBG_ASSERT(*pdwGeneration == m_pRWLexInfo->nGenerationId);
        return SP_LEX_NOTHING_TO_SYNC;
    }
    HRESULT hr = S_OK;
    DWORD *pdwOffsets = NULL;
    bool *pfAdd = NULL;
    LANGID *pLangIDs = NULL;
    DWORD nWords = 0;

    m_pRWLock->ClaimReaderLock ();

    if (*pdwGeneration > m_pRWLexInfo->nGenerationId)
    {
        // This should not occur if we are running on a single machine and everything
        // is running fine. But it can happen if (1) The SR engine gets the changes
        // in user lexicon and serializes its language model but user lexicon has not
        // serialized yet and there is a crash so user lex does not get serialized. Now
        // SR engine will have a gen id greateer than the one in user lex. Serializing
        // user lex on every GetGenerationChange or getWords call would be an overkill
        // for normal situations. (2) The user copies the language model file to another
        // machine but does not copy the user lexicon.
        //
        // For these reasons we will handle this situation as very out of sync so that
        // SR engine can call GetWords and re-sync with the custom lexicons.
        hr = SPERR_LEX_VERY_OUT_OF_SYNC;
    }
    if (SUCCEEDED(hr))
    {
        if (*pdwGeneration + m_pRWLexInfo->nHistory  < m_pRWLexInfo->nGenerationId)
        {
            hr = SPERR_LEX_VERY_OUT_OF_SYNC;
        }
    }
    if (SUCCEEDED(hr))
    {
        if (*pdwGeneration == m_pRWLexInfo->nGenerationId)
        {
            hr = SP_LEX_NOTHING_TO_SYNC;
        }
    }
    if (hr == S_OK)
    {
        nWords = m_pRWLexInfo->nGenerationId - *pdwGeneration;
        pdwOffsets = new DWORD[nWords];
        if (!pdwOffsets)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (hr == S_OK)
    {
        pfAdd = new bool[nWords];
        if (!pfAdd)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (hr == S_OK)
    {
        pLangIDs = new LANGID[nWords];
        if (!pLangIDs)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (hr == S_OK)
    {
        // get the offsets of the words
        int iGen = m_pRWLexInfo->iCacheNext - nWords;
        if (iGen < 0)
        {
            iGen += g_dwCacheSize;
        }
        for (DWORD i = 0; i < nWords; i++)
        {
            pLangIDs[i] = m_pChangedWordsCache[iGen].LangID;
            pdwOffsets[i] = m_pChangedWordsCache[iGen].nOffset;
            pfAdd[i] = m_pChangedWordsCache[iGen].fAdd;
            if (++iGen == g_dwCacheSize)
            {
                iGen = 0;
            }
        }
        // get the (approx) size of the buffer to be returned
        DWORD dwSize;
        SizeofWords(pdwOffsets, nWords, &dwSize);

        //realloc the buffer if necessary
        hr = ReallocSPWORDList(pWordList, dwSize);
    }
    if (hr == S_OK)
    {
        // Get the changed words
        GetDictEntries(pWordList, pdwOffsets, pfAdd, pLangIDs, nWords);
    }
    delete [] pdwOffsets;
    delete [] pfAdd;
    delete [] pLangIDs;

    if (hr == S_OK)
    {
        *pdwGeneration = m_pRWLexInfo->nGenerationId;
    }
    else
    {
        pWordList->pFirstWord = NULL;
    }
    m_pRWLock->ReleaseReaderLock ();
    
    return hr;
}
                                  
/*******************************************************************************
* CSpUnCompressedLexicon::GetWords *
*----------------------------------*
*     Description:
*        This function gets all the words in the lexicon
*        passed in generation id and the current generation id.
*
*     Return: E_OUTOFMEMORY
*             S_OK                      - All words returned. Cookie UNTOUCHED
*             SP_LEX_NOTHING_TO_SYNC    - App lexicon. No changes.
**************************************************************** YUNUSM *******/
STDMETHODIMP CSpUnCompressedLexicon::GetWords(  DWORD dwFlags,
                                                DWORD *pdwGeneration,          // current lex gen id passed out
                                                DWORD *pdwCookie,
                                                SPWORDLIST *pWordList          // buffer holding list of words and their info returned
                                                )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::GetWords");

    if (!pdwGeneration || !pWordList ||
        SPIsBadWritePtr(pdwGeneration, sizeof(DWORD)) || SPIsBadWordList(pWordList) ||
        (pdwCookie && SPIsBadWritePtr(pdwCookie, sizeof(DWORD))) )
    {
        return E_POINTER;
    }
    if (!m_fInit)
    {
        return SPERR_UNINITIALIZED;
    }
    if (static_cast<SPLEXICONTYPE>(dwFlags) != m_eLexType)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    DWORD *pdwOffsets = NULL;
    bool *pfAdd = NULL;
    LANGID *pLangIDs = NULL;
    DWORD nWords = 0;
    PLANGIDNODE pLN = NULL;
    DWORD iWord, i;
    iWord = i = 0;

    m_pRWLock->ClaimReaderLock ();
    
    nWords = m_pRWLexInfo->nRWWords;
    if (!nWords)
    {
        *pdwGeneration = m_pRWLexInfo->nGenerationId;
        hr = SP_LEX_NOTHING_TO_SYNC;
    }
    if (hr == S_OK)
    {
        pdwOffsets = new DWORD[nWords];
        if (!pdwOffsets)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (hr == S_OK)
    {
        pfAdd = new bool[nWords];
        if (!pfAdd)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (hr == S_OK)
    {
        pLangIDs = new LANGID[nWords];
        if (!pLangIDs)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (hr == S_OK)
    {
        pLN = (PLANGIDNODE)(m_pSharedMem + sizeof (RWLEXINFO));

        // get the offsets of the words
        for (i = 0; i < g_dwNumLangIDsSupported; i++)
        {
            if (0 == pLN[i].LangID)
            {
                continue;
            }
            SPDBG_ASSERT (pLN[i].nHashOffset);
        
            DWORD *pdwHash = (DWORD*)(m_pSharedMem + pLN[i].nHashOffset);
            for (DWORD j = 0; j < pLN[i].nHashLength; j++)
            {
                if (!pdwHash[j])
                {
                    continue;
                }
                DWORD nWordOffset = pdwHash[j];
                while (nWordOffset)
                {
                    pLangIDs[iWord] = pLN[i].LangID;
                    pdwOffsets[iWord] = nWordOffset;
                    pfAdd[iWord++] = eWORDTYPE_ADDED;

                    nWordOffset = ((UNALIGNED DICTNODE *)(m_pSharedMem + nWordOffset))->nNextOffset;
                }
            }
        }
        SPDBG_ASSERT(iWord == nWords);

        // get the (approx) size of the buffer to be returned
        DWORD dwSize;
        SizeofWords(pdwOffsets, nWords, &dwSize);

        //realloc the buffer if necessary
        hr = ReallocSPWORDList(pWordList, dwSize);
    }
    if (hr == S_OK)
    {
        // Get the changed words
        GetDictEntries(pWordList, pdwOffsets, pfAdd, pLangIDs, nWords);
    }
    delete [] pdwOffsets;
    delete [] pfAdd;
    delete [] pLangIDs;

    if (hr == S_OK)
    {
        *pdwGeneration = m_pRWLexInfo->nGenerationId;
    }
    else
    {
        pWordList->pFirstWord = NULL;
    }
    m_pRWLock->ReleaseReaderLock();

    return hr;
}

//--- ISpObjectToken methods ---------------------------------------------------

/*******************************************************************************
* CSpUnCompressedLexicon::SetObjectToken *
*----------------------------------------*
*   Initializes the user lexicon object.
*
**************************************************************** YUNUSM *******/
STDMETHODIMP CSpUnCompressedLexicon::SetObjectToken(ISpObjectToken * pToken)
{
    SPDBG_FUNC("CSpUnCompressedLexicon::SetObjectToken");

    if (SP_IS_BAD_INTERFACE_PTR(pToken))
    {
        return E_POINTER;
    }
    HRESULT hr = S_OK;

    hr = SpGenericSetObjectToken(pToken, m_cpObjectToken);
    // Determine the lexicon type
    if (SUCCEEDED(hr))
    {
        WCHAR *pszObjectId;
        hr = pToken->GetId(&pszObjectId);
        if (SUCCEEDED(hr))
        {
            if (wcsicmp(pszObjectId, SPCURRENT_USER_LEXICON_TOKEN_ID) == 0)
            {
                m_eLexType = eLEXTYPE_USER;
            }
            else
            {
                m_eLexType = eLEXTYPE_APP;
            }
            ::CoTaskMemFree(pszObjectId);
        }
    }
    // Get the flush rate for this user
    if (SUCCEEDED(hr))
    {
        WCHAR *pwszFlushRate;
        hr = pToken->GetStringValue(L"FlushRate", &pwszFlushRate);
        if (SUCCEEDED(hr))
        {
            WCHAR *p;
            m_dwFlushRate = wcstol(pwszFlushRate, &p, 10);
            ::CoTaskMemFree(pwszFlushRate);
        }
        else
        {
            WCHAR wszFlushRate[64];
            m_dwFlushRate = g_dwDefaultFlushRate;
            _itow(m_dwFlushRate, wszFlushRate, 10);
            hr = pToken->SetStringValue(L"FlushRate", wszFlushRate);
        }
    }
    // Load the lexicon datafile
    if (SUCCEEDED(hr))
    {
        CSpDynamicString pDataFile;
        ULONG nFolder;
        WCHAR *pszFolderPath;
        if(m_eLexType == eLEXTYPE_USER)
        {
            // User lexicons go in application settings which roams
            nFolder = CSIDL_APPDATA;
            pszFolderPath = L"UserLexicons\\";
        }
        else
        {
            // App lexicons go in local settings which doesn't roam
            // Note to create an app lexicon you must have write access to HKEY_LOCAL_MACHINE
            nFolder = CSIDL_LOCAL_APPDATA;
            pszFolderPath = L"AppLexicons\\";
        }

        hr = pToken->GetStorageFileName(CLSID_SpUnCompressedLexicon, L"Datafile", pszFolderPath, CSIDL_FLAG_CREATE | nFolder, &pDataFile);
        if (SUCCEEDED(hr))
        {
            hr = Init(pDataFile, (hr == S_FALSE));
        }
    }
    // Enumerate the App lexicons installed on this machine if this is a user lexicon
    if (m_eLexType == eLEXTYPE_USER)
    {
        CComPtr<IEnumSpObjectTokens> cpEnumTokens;
        CComPtr<ISpObjectToken> cpRegToken;
        if (SUCCEEDED(hr))
        {
            hr = SpEnumTokens(SPCAT_APPLEXICONS, NULL, NULL, &cpEnumTokens);
        }
        ULONG celtFetched;
        if(hr == S_FALSE)
        {
            hr = S_OK;
            celtFetched = 0;
        }
        else if (hr == S_OK)
        {
            hr = cpEnumTokens->GetCount(&celtFetched);
        }

        WCHAR **pAppIds = NULL;
        if (SUCCEEDED(hr) && celtFetched)
        {
            pAppIds = new WCHAR* [celtFetched];
            if (!pAppIds)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                ZeroMemory(pAppIds, celtFetched * sizeof(WCHAR *));
            }
        }
        if (SUCCEEDED(hr) && celtFetched)
        {
            ULONG cAppLexicons = 0;
            ULONG celtTemp;
            while (SUCCEEDED(hr) && (S_OK == (hr = cpEnumTokens->Next(1, &cpRegToken, &celtTemp))))
            {
                if (SUCCEEDED(hr))
                {
                    hr = cpRegToken->GetId(&pAppIds[cAppLexicons]);
                }
                if (SUCCEEDED(hr))
                {
                    cAppLexicons++;
                }
                cpRegToken = NULL;
            }
            if (SUCCEEDED(hr))
            {
                if (cAppLexicons != celtFetched)
                {
                    hr = E_FAIL;        // undefined error
                }
                else
                {
                    hr = S_OK;
                }
            }
        }
        // Check if the list of app lexicons or any of the app lexicons have changed for this user
        // Get the app lexicons list under this user
        CComPtr<ISpDataKey> cpDataKey;
        bool fTooMuchChange = false;
        if (SUCCEEDED(hr))
        {
            hr = pToken->OpenKey(L"AppLexicons", &cpDataKey);
            if (FAILED(hr))
            {
                // we assume the error is that the key does not exist
                fTooMuchChange = true;
                hr = S_OK;
            }
        }
        WCHAR *pszOldAppId = NULL;
        for (ULONG i = 0; (i < celtFetched) && SUCCEEDED(hr) && !fTooMuchChange; i++)
        {
            ULONG ulSize = sizeof(ULONG);
            hr = cpDataKey->EnumValues(i, &pszOldAppId);
            if (SUCCEEDED(hr))
            {
                int nCmp = g_Unicode.CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT),
                                                          NORM_IGNORECASE, pAppIds[i], -1, pszOldAppId, -1);
                if (!nCmp)
                {
                    hr = SpHrFromLastWin32Error(); // probably the LangID's language pack is not installed on machine
                }
                else
                {
                    if (CSTR_EQUAL != nCmp)
                    {
                        fTooMuchChange = true;
                        break;
                    }
                }
            }
            else
            {
                // We assume the error is that we ran out of values - meaning an app lexicon has 
                // been installed since we last ran
                fTooMuchChange = true;
                hr = S_OK;
                break;
            }
            ::CoTaskMemFree(pszOldAppId);
        }
        if (SUCCEEDED(hr))
        {
            if (i < celtFetched)
            {
                fTooMuchChange = true;
            }
            else
            {
                hr = cpDataKey->EnumValues(i, &pszOldAppId);
                if (SUCCEEDED(hr))
                {
                    // means i > celtFetched
                    fTooMuchChange = true;
                    ::CoTaskMemFree(pszOldAppId);
                }
                else
                {
                    hr = S_OK;
                }
            }
        }
        cpDataKey = NULL;
        if (SUCCEEDED(hr))
        {
            if (fTooMuchChange)
            {
                SetTooMuchChange();
                // Claim this user's writer lock so that two apps starting up with the same user
                // dont mess up the registry
                m_pRWLock->ClaimWriterLock();
                // Replace the current app lexicon list for this user
                // Delete the existing key - Dont check the return code because the key may not exist
                hr = pToken->DeleteKey(L"AppLexicons");
                hr = pToken->CreateKey(L"AppLexicons", &cpDataKey);
                for (i = 0; SUCCEEDED(hr) && (i < celtFetched); i++)
                {
                    hr = cpDataKey->SetStringValue(pAppIds[i], L"");
                }
                m_pRWLock->ReleaseWriterLock();
            }
        }
        if (pAppIds)
        {
            for (i = 0; i < celtFetched; i++)
            {
                ::CoTaskMemFree(pAppIds[i]);
            }
            delete [] pAppIds;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_fInit = true;
    }
    return hr;
}

STDMETHODIMP CSpUnCompressedLexicon::GetObjectToken(ISpObjectToken ** ppToken)
{
    return SpGenericGetObjectToken(ppToken, m_cpObjectToken);
}

//--- Internal functions supporting ISpLexicon functions -----------------------

/*******************************************************************************
* CSpUnCompressedLexicon::BuildEmptyDict *
*----------------------------------------*
*   Description:
*       Builds an empty dictionary file
*
*   Return:
*       E_INVALIDARG
*       GetLastError()
*       E_FAIL
*       S_OK
/**************************************************************** YUNUSM ******/
inline HRESULT CSpUnCompressedLexicon::BuildEmptyDict(   const WCHAR *wszLexFile   // lexicon file name
                                                         )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::BuildEmptyDict");

    HRESULT hr = S_OK;
    RWLEXINFO DictInfo;
    ZeroMemory (&DictInfo, sizeof (RWLEXINFO));
    DictInfo.guidValidationId = g_guidCustomLexValidationId;
    
    // Create the guids necessary for sharing the file
    hr = CoCreateGuid (&(DictInfo.guidLexiconId));
    if (SUCCEEDED(hr))
    {
        hr = CoCreateGuid(&(DictInfo.RWLockInfo.guidLockMapName));
    }
    if (SUCCEEDED(hr))
    {
        hr = CoCreateGuid(&(DictInfo.RWLockInfo.guidLockInitMutexName));
    }
    if (SUCCEEDED(hr))
    {
        hr = CoCreateGuid(&(DictInfo.RWLockInfo.guidLockReaderEventName));
    }
    if (SUCCEEDED(hr))
    {
        hr = CoCreateGuid(&(DictInfo.RWLockInfo.guidLockGlobalMutexName));
    }
    if (SUCCEEDED(hr))
    {
        hr = CoCreateGuid(&(DictInfo.RWLockInfo.guidLockWriterMutexName));
    }
    HANDLE hLexFile = NULL;
    if (SUCCEEDED(hr))
    {    
        hLexFile = g_Unicode.CreateFile(wszLexFile, GENERIC_WRITE, 0, NULL, 
                                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (!hLexFile)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    DWORD dwBytesWritten;
    if (SUCCEEDED(hr))
    {    
        DictInfo.nDictSize = sizeof (RWLEXINFO) + (sizeof (LANGIDNODE) * g_dwNumLangIDsSupported) +
                             g_dwCacheSize * sizeof(WCACHENODE);
        if (!WriteFile(hLexFile, &DictInfo, sizeof(RWLEXINFO), &dwBytesWritten, NULL))
        {
            hr = GetLastError();
        }
    }
    if (SUCCEEDED(hr))
    {
        LANGIDNODE aLangIDInfo[g_dwNumLangIDsSupported];
        ZeroMemory(aLangIDInfo, g_dwNumLangIDsSupported * sizeof (LANGIDNODE));
        if (!WriteFile(hLexFile, aLangIDInfo, sizeof(LANGIDNODE) * g_dwNumLangIDsSupported, &dwBytesWritten, NULL))
        {
            hr = GetLastError();
        }
    }
    if (SUCCEEDED(hr))
    {
        WCACHENODE aCache[g_dwCacheSize];
        ZeroMemory (aCache, g_dwCacheSize * sizeof (WCACHENODE));
        if (!WriteFile(hLexFile, aCache, sizeof(WCACHENODE) * g_dwCacheSize, &dwBytesWritten, NULL))
        {
            hr = GetLastError();
        }
    }
    CloseHandle(hLexFile);

    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::SizeofWordInfoArray *
*---------------------------------------------*
*   Description:
*       Calcuates the size of a WORDINFO array
*   
*   Return:
*       size
/**************************************************************** YUNUSM ******/
inline DWORD CSpUnCompressedLexicon::SizeofWordInfoArray(WORDINFO* pInfo,          // Array of WORDINFO
                                        DWORD dwNumInfo           // Number of elements in array
                                        )
{   
    SPDBG_FUNC("CSpUnCompressedLexicon::SizeofWordInfoArray");

    DWORD nInfoSize = 0;
    if (pInfo && dwNumInfo)
    {
        WORDINFO* p = pInfo;
        for (DWORD i = 0; i < dwNumInfo; i++)
        {
            p = (WORDINFO*)(((PBYTE)pInfo) + nInfoSize);
            nInfoSize += sizeof(WORDINFO) + (wcslen(p->wPronunciation) + 1) * sizeof(WCHAR);
        }
    }
    
    return nInfoSize;
}
    
/*******************************************************************************
* CSpUnCompressedLexicon::SizeOfDictNode *
*----------------------------------------*
*   Description:
*       Calcuates the size of a DICTNODE
*
*   Return:
*       sizeof DICT node and its WORDINFO array
/**************************************************************** YUNUSM ******/
inline void CSpUnCompressedLexicon::SizeOfDictNode(PCWSTR pwWord,                 // word
                                  WORDINFO* pInfo,               // info array
                                  DWORD dwNumInfo,               // number of info blocks
                                  DWORD *pnDictNodeSize,         // returned dict node size
                                  DWORD *pnInfoSize              // returned info array size
                                  )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::SizeOfDictNode");

    *pnDictNodeSize = sizeof(DICTNODE) + ((wcslen(pwWord) + 1) * sizeof(WCHAR));
    *pnInfoSize = SizeofWordInfoArray(pInfo, dwNumInfo);
    (*pnDictNodeSize) += (*pnInfoSize);
}

/*******************************************************************************
* CSpUnCompressedLexicon::SizeofWords *
*-------------------------------------*
*   Description:
*       This function calculates the number and size of the changed
*       words and their information.
*
*   Return: n/a
**************************************************************** YUNUSM *******/
void CSpUnCompressedLexicon::SizeofWords(DWORD *pdwOffsets,                  // array of offsets of words
                        DWORD nOffsets,                     // length of array of offsets
                        DWORD *pdwSize                      // total size of the words
                        )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::SizeofWords");

    *pdwSize = sizeof(SPWORDLIST);

    for (DWORD i = 0; i < nOffsets; i++)
    {
        UNALIGNED DICTNODE * p = (UNALIGNED DICTNODE *)(m_pSharedMem + pdwOffsets[i]);
        *pdwSize += sizeof(SPWORD) + p->nNumInfoBlocks * sizeof(SPWORDPRONUNCIATION) + (p->nNumInfoBlocks + 1 ) *(sizeof(void *) - 2) + p->nSize;
    }
}

/*******************************************************************************
* CSpUnCompressedLexicon::AddWordAndInfo *
*----------------------------------------*
*   Description:
*       Adds a word and its information (new + existing) to the dictionary
*
*   Return:
*       S_OK
*       E_OUTOFMEMORY
/**************************************************************** YUNUSM ******/
inline HRESULT CSpUnCompressedLexicon::AddWordAndInfo(PCWSTR pwWord,             // word
                                     WORDINFO* pWordInfo,       // info array
                                     DWORD nNewNodeSize,        // size of the dict node
                                     DWORD nInfoSize,           // size of info array
                                     DWORD nNumInfo,            // number of info blocks
                                     WORDINFO* pOldInfo,        // existing info array of this word
                                     DWORD nOldInfoSize,        // size of existing info
                                     DWORD nNumOldInfo,         // number of existing info blocks
                                     DWORD *pdwOffset           // Offset of word returned
                                     )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::AddWordAndInfo");

    HRESULT hr = S_OK;

    *pdwOffset = GetFreeDictNode(nNewNodeSize + nOldInfoSize);
    if (!*pdwOffset)
    {
        // Check if the dict has exceeded its max allowable size
        if (m_dwMaxDictionarySize - m_pRWLexInfo->nDictSize > nNewNodeSize)
        {
            *pdwOffset = m_pRWLexInfo->nDictSize;
        }
    }
    if (*pdwOffset)
    {
        UNALIGNED DICTNODE* pDictNode = (UNALIGNED DICTNODE*) (m_pSharedMem + (*pdwOffset));
        ZeroMemory(pDictNode, sizeof(DICTNODE));
        pDictNode->nNumInfoBlocks = nNumInfo + nNumOldInfo;
        pDictNode->nSize = nNewNodeSize + nOldInfoSize;
    
        PBYTE pBuffer = (PBYTE)(pDictNode->pBuffer);
        wcscpy((PWSTR)pBuffer, pwWord);
        pBuffer += (wcslen((PWSTR)pBuffer) + 1) * sizeof (WCHAR);
   
        if (pWordInfo)
        {
            CopyMemory(pBuffer, (PBYTE)pWordInfo, nInfoSize);
        }
        if (pOldInfo)
        {
            CopyMemory((PBYTE)pBuffer + nInfoSize, (PBYTE)pOldInfo, nOldInfoSize);
        }
        m_pRWLexInfo->nDictSize += nNewNodeSize + nOldInfoSize;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::DeleteWordDictNode *
*--------------------------------------------*
*   Description:
*       Frees a dictionary node at the passed in offset by adding it
*       to the free list.
*
*   Return:
*       n/a 
/**************************************************************** YUNUSM ******/
inline void CSpUnCompressedLexicon::DeleteWordDictNode(DWORD nOffset // Offset of the dictnode to free
                                      )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::DeleteWordDictNode");

    DWORD nSize = ((UNALIGNED DICTNODE *)(m_pSharedMem + nOffset))->nSize;
    DWORD d = m_pRWLexInfo->nFreeHeadOffset;
    m_pRWLexInfo->nFreeHeadOffset = nOffset;
    ((UNALIGNED FREENODE *)(m_pSharedMem + nOffset))->nSize = nSize;
    ((UNALIGNED FREENODE *)(m_pSharedMem + nOffset))->nNextOffset = d;

    m_pRWLexInfo->fRemovals = true;
}

/*******************************************************************************
* CSpUnCompressedLexicon::GetFreeDictNode *
*-----------------------------------------*
*   Description:
*       Searches free link list for a node of passed-in size
*
*   Return:
*       Offset of the dict node
/**************************************************************** YUNUSM ******/
DWORD CSpUnCompressedLexicon::GetFreeDictNode(DWORD nSize // free space needed
                             )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::GetFreeDictNode");

    DWORD nOffset = m_pRWLexInfo->nFreeHeadOffset;
    DWORD nOffsetPrev = m_pRWLexInfo->nFreeHeadOffset;
    while (nOffset && ((UNALIGNED FREENODE *)(m_pSharedMem + nOffset))->nSize < nSize)
    {
        nOffsetPrev = nOffset;
        nOffset = ((UNALIGNED FREENODE *)(m_pSharedMem + nOffset))->nNextOffset;
    }
    
    if (nOffset)
    {
        if (nOffset == nOffsetPrev)
        {
            SPDBG_ASSERT(nOffset == m_pRWLexInfo->nFreeHeadOffset);
            m_pRWLexInfo->nFreeHeadOffset = ((UNALIGNED FREENODE *)(m_pSharedMem + nOffset))->nNextOffset;
        }
        else
        {
            ((UNALIGNED FREENODE *)(m_pSharedMem + nOffsetPrev))->nNextOffset = 
                ((UNALIGNED FREENODE *)(m_pSharedMem + nOffset))->nNextOffset;
        }
    }

    return nOffset;
}

/*******************************************************************************
* CSpUnCompressedLexicon::AddDictNode *
*-------------------------------------*
*   Description:
*       Adds a dictnode and adds the word's offset to hash table
*
*   Return:
*       S_OK
*       E_OUTOFMEMORY
**************************************************************** YUNUSM *******/
inline HRESULT CSpUnCompressedLexicon::AddDictNode(LANGID LangID,            // LangID of the word
                                  UNALIGNED DICTNODE *pDictNode,  // dictnode of the word
                                  DWORD *pdwOffset      // returned offset of the word
                                  )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::AddDictNode");

    HRESULT hr = S_OK;
    *pdwOffset = 0;

    WCHAR *pszWord = WordFromDictNode(pDictNode);
    hr = AddWordAndInfo(pszWord, (WORDINFO *)(pDictNode->pBuffer + (wcslen(pszWord) + 1) * sizeof(WCHAR)),
                        pDictNode->nSize, pDictNode->nSize - sizeof(DICTNODE) - (wcslen(pszWord) + 1) * sizeof(WCHAR),
                        pDictNode->nNumInfoBlocks, NULL, 0, 0, pdwOffset);
    if (SUCCEEDED(hr))
    {
        AddWordToHashTable(LangID, *pdwOffset, false);
    }
    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::AllocateHashTable *
*-------------------------------------------*
*   Description:
*       Allocates a hash table for an LangID.
*
*   Return:
*       S_OK
*       E_OUTOFMEMORY
**************************************************************** YUNUSM ******/
inline HRESULT CSpUnCompressedLexicon::AllocateHashTable(DWORD iLangID,        // index of LangID for the hash table
                                        DWORD nHashLength   // size of the hash table
                                        )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::AllocateHashTable");

    HRESULT hr = S_OK;
    UNALIGNED LANGIDNODE * pLN = (UNALIGNED LANGIDNODE *)(m_pSharedMem + sizeof(RWLEXINFO));
    pLN += iLangID;
  
    // Allocate the hash table
    DWORD nFreeOffset = GetFreeDictNode(nHashLength * sizeof (DWORD));
    if (!nFreeOffset)
    {
        nFreeOffset = m_pRWLexInfo->nDictSize;
        if (m_dwMaxDictionarySize - nFreeOffset < nHashLength * sizeof (DWORD))
        {
            hr = E_OUTOFMEMORY; // This dict object has exceeded its maximum size
        }
        else
        {
            m_pRWLexInfo->nDictSize += nHashLength * sizeof (DWORD);
        }
    }
    if (SUCCEEDED(hr))
    {
        pLN->nHashOffset = nFreeOffset;
        pLN->nHashLength = nHashLength;
        pLN->nWords = 0;
        ZeroMemory (m_pSharedMem + nFreeOffset, pLN->nHashLength * sizeof (DWORD));
    }
    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::ReallocateHashTable *
*---------------------------------------------*
*   Description:
*       ReAllocates a hash table for an LangID if necessary. This function is only
*       called from Serialize()
*
*   Return:
*       S_OK
*       E_OUTOFMEMORY
**************************************************************** YUNUSM ******/
HRESULT CSpUnCompressedLexicon::ReallocateHashTable(DWORD iLangID          // index of LangID for hash table
                                   )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::ReallocateHashTable");

    HRESULT hr = S_OK;
    UNALIGNED LANGIDNODE * pLN = (UNALIGNED LANGIDNODE *)(m_pSharedMem + sizeof(RWLEXINFO));
    pLN += iLangID;
    SPDBG_ASSERT(pLN->nHashLength);
    DWORD nWordsSave = pLN->nWords;

    // Not deallocating the existing hash table on purpose since this
    // function is only called from Serialize which has truncated the lexicon
    if (1.5 * pLN->nWords > pLN->nHashLength)
    {
        hr = AllocateHashTable(iLangID, (DWORD)(1.5 * pLN->nWords));
    }
    else
    {
        hr = AllocateHashTable(iLangID, g_dwInitHashSize);
    }
    if (SUCCEEDED(hr))
    {
        pLN->nWords = nWordsSave;
    }
    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::AddWordToHashTable *
*--------------------------------------------*
*   Description:
*       Adds a word's offset to the hash table. The word should exist as a dictnode
*       before this is called.
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
inline void CSpUnCompressedLexicon::AddWordToHashTable(LANGID LangID,            // LangID of the word
                                      DWORD dwOffset,       // offset to the dictnode of the word
                                      bool fNewWord         // true if it is a brand new word
                                      )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::AddWordToHashTable");

    DWORD iLangID = LangIDIndexFromLangID(LangID);
    UNALIGNED LANGIDNODE * pLN = (UNALIGNED LANGIDNODE *)(m_pSharedMem + sizeof(RWLEXINFO));
    DWORD *pHashTable = (DWORD *)(m_pSharedMem + pLN[iLangID].nHashOffset);
    UNALIGNED DICTNODE * pDictNode = (UNALIGNED DICTNODE *)(m_pSharedMem + dwOffset);
    WCHAR *pszWord = WordFromDictNode(pDictNode);

    DWORD dwHashVal = GetWordHashValue(pszWord, pLN[iLangID].nHashLength);
    if (!pHashTable[dwHashVal])
    {
        pHashTable[dwHashVal] = dwOffset;
    }
    else
    {
        pDictNode->nNextOffset = pHashTable[dwHashVal];
        pHashTable[dwHashVal] = dwOffset;
    }
    if (fNewWord)
    {
        (m_pRWLexInfo->nRWWords)++;
        (pLN->nWords)++;
    }
}

/*******************************************************************************
* CSpUnCompressedLexicon::DeleteWordFromHashTable *
*-------------------------------------------------*
*   Description:
*       Deletes a word's offset from the hash table. The word should exist as a dictnode
*       before this is called.
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
inline void CSpUnCompressedLexicon::DeleteWordFromHashTable(LANGID LangID,               // LangID of the word                     
                                           DWORD dwOffset,          // offset to the dictnode of the word   
                                           bool fDeleteEntireWord   // true if the entire word is getting deleted
                                           )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::DeleteWordFromHashTable");
    SPDBG_ASSERT(dwOffset != 0); // Programming error if this happens.
    DWORD iLangID = LangIDIndexFromLangID(LangID);
    PLANGIDNODE pLN = (PLANGIDNODE)(m_pSharedMem + sizeof(RWLEXINFO));
    DWORD *pHashTable = (DWORD *)(m_pSharedMem + pLN[iLangID].nHashOffset);
    WCHAR *pszWord = WordFromDictNodeOffset(dwOffset);

    SPDBG_ASSERT(pLN[iLangID].nHashLength);

    DWORD dwHashVal = GetWordHashValue(pszWord, pLN[iLangID].nHashLength);
    DWORD nWordOffset = pHashTable[dwHashVal];
    DWORD nPrevOffset = pHashTable[dwHashVal];

    UNALIGNED DICTNODE * pDictNode = (UNALIGNED DICTNODE *)(m_pSharedMem + nWordOffset);
    while (nWordOffset && nWordOffset != dwOffset)
    {
        nPrevOffset = nWordOffset;
        nWordOffset = pDictNode->nNextOffset;
        pDictNode = (UNALIGNED DICTNODE *)(m_pSharedMem + nWordOffset);
    }

    SPDBG_ASSERT(nWordOffset);
    if (nWordOffset == pHashTable[dwHashVal])
    {
        pHashTable[dwHashVal] = pDictNode->nNextOffset;
    }
    else
    {
        UNALIGNED DICTNODE * pPrevDictNode = (UNALIGNED DICTNODE *)(m_pSharedMem + nPrevOffset);
        pPrevDictNode->nNextOffset = pDictNode->nNextOffset;
    }
    if (fDeleteEntireWord)
    {
        (m_pRWLexInfo->nRWWords)--;
        (pLN->nWords)--;
        SPDBG_ASSERT(((int)(m_pRWLexInfo->nRWWords)) >= 0);
        SPDBG_ASSERT(((int)(pLN->nWords)) >= 0);
    }
}

/*******************************************************************************
* CSpUnCompressedLexicon::WordOffsetFromHashTable *
*-------------------------------------------------*
*   Description:
*       Get the offset of a word from the hash table
*
*   Return: 
*       offset
/**************************************************************** YUNUSM ******/
inline HRESULT CSpUnCompressedLexicon::WordOffsetFromHashTable(LANGID LangID,              // LangID of the word
                                              DWORD nHashOffset,      // offset of the hash table
                                              DWORD nHashLength,      // length of hash table
                                              const WCHAR *pszWordKey,// word, NOT case-folded
                                              DWORD *pdwOffset        // word offset
                                              )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::WordOffsetFromHashTable");

    DWORD dwHashVal = GetWordHashValue(pszWordKey, nHashLength);
    DWORD *pHashTable = (PDWORD)(m_pSharedMem + nHashOffset);
    
    // find the word
    *pdwOffset = pHashTable[dwHashVal];
    while (*pdwOffset)
    {    
        int nCmp = g_Unicode.CompareString(LangID, 0 , pszWordKey, -1, 
                                           (WCHAR*)(((UNALIGNED DICTNODE *)(m_pSharedMem + (*pdwOffset)))->pBuffer), -1);
        if (CSTR_EQUAL == nCmp)
        {
            break;
        }
        *pdwOffset = ((UNALIGNED DICTNODE *)(m_pSharedMem + (*pdwOffset)))->nNextOffset;
    }
    return S_OK;
}

/*******************************************************************************
* CSpUnCompressedLexicon::AddLangID *
*-----------------------------------*
*   Description:
*       Adds a LangID node and allocates hash table
*
*   Return:
*       S_OK
*       E_OUTOFMEMORY
***************************************************************** YUNUSM ******/
inline HRESULT CSpUnCompressedLexicon::AddLangID(LANGID LangID     // LangID to add to the lexicon
                              )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::AddLangID");
    
    HRESULT hr = S_OK;
    PLANGIDNODE pLN = (PLANGIDNODE)(m_pSharedMem + sizeof(RWLEXINFO));
    for (DWORD i = 0; i < g_dwNumLangIDsSupported; i++)
    {
        SPDBG_ASSERT(pLN[i].LangID != LangID);
        if (!(pLN[i].LangID))
            break;
    }
    if (i == g_dwNumLangIDsSupported)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pLN[i].LangID = LangID;
        hr = AllocateHashTable(i, g_dwInitHashSize);
    }
    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::LangIDIndexFromLangID *
*-----------------------------------------------*
*   Description:
*       Get the index of an LangID
*
*   Return: 
*       index
/**************************************************************** YUNUSM ******/
inline DWORD CSpUnCompressedLexicon::LangIDIndexFromLangID(LANGID LangID  // LangID to search
                                      )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::LangIDIndexFromLangID");

    PLANGIDNODE pLN = (PLANGIDNODE)(m_pSharedMem + sizeof(RWLEXINFO));
    for (DWORD i = 0; i < g_dwNumLangIDsSupported; i++)
    {
        if (!(pLN[i].LangID))
        {
            i = (DWORD)-1;
            break;
        }
        if (LangID == pLN[i].LangID)
        {
            break;
        }
    }
    return i;
}

/*******************************************************************************
* CSpUnCompressedLexicon::WordOffsetFromLangID *
*----------------------------------------------*
*   Description:
*       Get the offset of word of an LangID
*
*   Return: 
*       offset
/**************************************************************** YUNUSM ******/
inline HRESULT CSpUnCompressedLexicon::WordOffsetFromLangID(LANGID LangID,           // LangID of the word
                                                      const WCHAR *pszWord,    // word string
                                                      DWORD *pdwOffset
                                                      )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::WordOffsetFromLangID");

    HRESULT hr = S_OK;
    PLANGIDNODE pLN = (PLANGIDNODE)(m_pSharedMem + sizeof(RWLEXINFO));
    DWORD iLangID = LangIDIndexFromLangID(LangID);
    *pdwOffset = 0;
    if (iLangID != (DWORD)-1)
    {
        hr = WordOffsetFromHashTable(LangID, pLN[iLangID].nHashOffset, pLN[iLangID].nHashLength, pszWord, pdwOffset);
    }
    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::AddCacheEntry *
*---------------------------------------*
*   Description:
*       Adds an entry to the cache of changes
*
*   Return: n/a
**************************************************************** YUNUSM *******/
inline void CSpUnCompressedLexicon::AddCacheEntry(bool fAdd,        // add or delete
                                 LANGID LangID,        // LangID of the entry
                                 DWORD nOffset     // offset of the DICTNODE
                                 )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::AddCacheEntry");

    if (m_pChangedWordsCache[m_pRWLexInfo->iCacheNext].nOffset &&
        m_pChangedWordsCache[m_pRWLexInfo->iCacheNext].fAdd == false)
    {
        // We are overwriting a deleted and cached word
        // Delete it for good
        DeleteWordDictNode(m_pChangedWordsCache[m_pRWLexInfo->iCacheNext].nOffset);
    }

    // Create a cache entry
    m_pChangedWordsCache[m_pRWLexInfo->iCacheNext].fAdd = fAdd;
    m_pChangedWordsCache[m_pRWLexInfo->iCacheNext].LangID = LangID;
    m_pChangedWordsCache[m_pRWLexInfo->iCacheNext].nGenerationId = (m_pRWLexInfo->nGenerationId)++;
    m_pChangedWordsCache[(m_pRWLexInfo->iCacheNext)++].nOffset = nOffset;
    if (m_pRWLexInfo->iCacheNext == g_dwCacheSize)
    {
        m_pRWLexInfo->iCacheNext = 0;
    }
    if (m_pRWLexInfo->nHistory < g_dwCacheSize)
    {
        (m_pRWLexInfo->nHistory)++;
    }
    if (true == fAdd)
    {
        m_pRWLexInfo->fAdditions = true;
    }
}

/*******************************************************************************
* CSpUnCompressedLexicon::WordFromDictNode *
*------------------------------------------*
*   Description:
*       Return the word pointer from dictnode
*
*   Return: 
*       word pointer
/**************************************************************** YUNUSM ******/
inline WCHAR* CSpUnCompressedLexicon::WordFromDictNode(UNALIGNED DICTNODE *pDictNode   // dict node
                                      )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::WordFromDictNode");
    return (WCHAR*)(pDictNode->pBuffer);
}

/*******************************************************************************
* CSpUnCompressedLexicon::WordFromDictNodeOffset *
*------------------------------------------------*
*   Description:
*       Return the word pointer from dictnode offset
*
*   Return: 
*       word pointer
/**************************************************************** YUNUSM ******/
inline WCHAR* CSpUnCompressedLexicon::WordFromDictNodeOffset(DWORD dwOffset   // dict node offset
                                            )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::WordFromDictNodeOffset");

    WCHAR *pszWord = NULL;
    if (dwOffset)
    {
        pszWord = WordFromDictNode((DICTNODE*)(m_pSharedMem + dwOffset));
    }
    return pszWord;
}

/*******************************************************************************
* CSpUnCompressedLexicon::WordInfoFromDictNode *
*----------------------------------------------*
*   Description:
*       Return the word info pointer from dictnode
*
*   Return: 
*       word info pointer
/**************************************************************** YUNUSM ******/
inline WORDINFO* CSpUnCompressedLexicon::WordInfoFromDictNode(UNALIGNED DICTNODE *pDictNode   // dict node
                                             )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::WordInfoFromDictNode");

    WCHAR *pszWord = WordFromDictNode(pDictNode);
    return (WORDINFO *)(pDictNode->pBuffer + (wcslen(pszWord) + 1) * sizeof(WCHAR));
}

/*******************************************************************************
* CSpUnCompressedLexicon::WordInfoFromDictNodeOffset *
*----------------------------------------------------*
*   Description:
*       Return the word info pointer from dictnode offset
*
*   Return: 
*       word info pointer
/**************************************************************** YUNUSM ******/
inline WORDINFO* CSpUnCompressedLexicon::WordInfoFromDictNodeOffset(DWORD dwOffset   // dict node offset
                                                   )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::WordInfoFromDictNodeOffset");

    WORDINFO *pWordInfo = NULL;
    if (dwOffset)
    {
        pWordInfo = WordInfoFromDictNode((DICTNODE*)(m_pSharedMem + dwOffset));
    }
    return pWordInfo;
}

/*******************************************************************************
* CSpUnCompressedLexicon::NumInfoBlocksFromDictNode *
*---------------------------------------------------*
*   Description:
*       Return the number of info blocks from dictnode
*
*   Return: 
*       number of info blocks
/**************************************************************** YUNUSM ******/
inline DWORD CSpUnCompressedLexicon::NumInfoBlocksFromDictNode(UNALIGNED DICTNODE *pDictNode   // dict node
                                              )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::NumInfoBlocksFromDictNode");

    return pDictNode->nNumInfoBlocks;
}

/*******************************************************************************
* CSpUnCompressedLexicon::NumInfoBlocksFromDictNodeOffset *
*---------------------------------------------------------*
*   Description:
*       Return the number of info blocks from dictnode offset
*
*   Return: 
*       number of info blocks
/**************************************************************** YUNUSM ******/
inline DWORD CSpUnCompressedLexicon::NumInfoBlocksFromDictNodeOffset(DWORD dwOffset   // dict node offset
                                                    )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::NumInfoBlocksFromDictNodeOffset");

    DWORD nNumInfoBlocks = 0;
    if (dwOffset)
    {
        nNumInfoBlocks = NumInfoBlocksFromDictNode((DICTNODE*)(m_pSharedMem + dwOffset));
    }
    return nNumInfoBlocks;
}

/*******************************************************************************
* CSpUnCompressedLexicon::SPListFromDictNodeOffset *
*--------------------------------------------------*
*   Description:
*       Convert a dictnode to SPWORDPRONUNCIATIONLIST
*
*   Return: 
*       S_OK
*       E_OUTOFMEMORY
/**************************************************************** YUNUSM ******/
inline HRESULT CSpUnCompressedLexicon::SPListFromDictNodeOffset(LANGID LangID,                           // LangID of the word
                                                          DWORD nWordOffset,                   // word offset
                                                          SPWORDPRONUNCIATIONLIST *pSPList     // list to fill
                                                          )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::SPListFromDictNodeOffset");

    HRESULT hr = S_OK;

    if (!nWordOffset)
    {
        hr = E_FAIL;
    }
    else
    {
        UNALIGNED DICTNODE * pDictNode = (UNALIGNED DICTNODE *)(m_pSharedMem + nWordOffset);
        if (pDictNode->nNumInfoBlocks)
        {
            DWORD dwLen = pDictNode->nSize + 
                                                pDictNode->nNumInfoBlocks * sizeof(SPWORDPRONUNCIATION) +
                                                (pDictNode->nNumInfoBlocks - 1) * (sizeof(void*)-2); //We need to add paddings for the previous n-1 pronunciation, the size of padding is at most sizeof(void*)-2, since WCHAR takes two bytes

            hr = ReallocSPWORDPRONList(pSPList, dwLen);
            if (SUCCEEDED(hr))
            {
                pSPList->pFirstWordPronunciation = (SPWORDPRONUNCIATION*)(pSPList->pvBuffer);
    
                SPWORDPRONUNCIATION *p = pSPList->pFirstWordPronunciation;
                UNALIGNED WORDINFO *pInfo = WordInfoFromDictNode(pDictNode);
    
                for (DWORD i = 0; i < pDictNode->nNumInfoBlocks; i ++)
                {
                    p->eLexiconType = m_eLexType;
                    p->ePartOfSpeech = pInfo->ePartOfSpeech;
                    p->LangID = LangID;
                    wcscpy(p->szPronunciation, ((WORDINFO *)pInfo)->wPronunciation);
                    pInfo = (WORDINFO*)((BYTE*)pInfo + sizeof(WORDINFO) + (wcslen(((WORDINFO *)pInfo)->wPronunciation) + 1) * sizeof(WCHAR));
    
                    if (i != pDictNode->nNumInfoBlocks - 1)
                    {
                        // +1 for zero termination included in the size of the SPWORDPRONUNCIATION structure.
                        p->pNextWordPronunciation = (SPWORDPRONUNCIATION*)(((BYTE*)p) + PronSize(p->szPronunciation));
                    }
                    else
                    {
                        p->pNextWordPronunciation = NULL;
                    }
                    p = p->pNextWordPronunciation;
                }
            }
        }
    }
    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::OffsetOfSubWordInfo *
*---------------------------------------------*
*   Description:
*       Get the offset (from the start of lex file) of the sub-lexwordinfo 
*       in the word info starting at dwWordOffset
*
*   Return: offset
**************************************************************** YUNUSM *******/
inline DWORD CSpUnCompressedLexicon::OffsetOfSubWordInfo(DWORD dwWordOffset,            // offset of the word
                                        WORDINFO *pSubLexInfo          // lexwordinfo to search for in the word's info
                                        )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::OffsetOfSubWordInfo");

    DWORD dwSubOffset = 0;
    if (dwWordOffset)
    {
       WORDINFO *pWordInfo = WordInfoFromDictNodeOffset(dwWordOffset);
        DWORD dwOldNumInfo = NumInfoBlocksFromDictNodeOffset(dwWordOffset);
        for (DWORD i = 0; i < dwOldNumInfo; i++)
        {
            if (((UNALIGNED WORDINFO*)pWordInfo)->ePartOfSpeech == ((UNALIGNED WORDINFO*)pSubLexInfo)->ePartOfSpeech &&
                !wcscmp(pWordInfo->wPronunciation,pSubLexInfo->wPronunciation))
            {
                break;
            }
            pWordInfo = (WORDINFO*)(((BYTE*)pWordInfo) + sizeof(WORDINFO) + (wcslen(pWordInfo->wPronunciation) + 1)*sizeof(WCHAR));
        }
        if (i < dwOldNumInfo)
        {
            dwSubOffset = ULONG(((BYTE*)pWordInfo) - m_pSharedMem);
        }
    }
    return dwSubOffset;
}

/*******************************************************************************
* CSpUnCompressedLexicon::SPPRONToLexWordInfo *
*---------------------------------------------*
*   Description:
*       Get the offset (from the start of lex file) of the sub-lexwordinfo 
*       in the word info starting at dwWordOffset
*
*   Return: offset
**************************************************************** YUNUSM *******/
WORDINFO* CSpUnCompressedLexicon::SPPRONToLexWordInfo(SPPARTOFSPEECH ePartOfSpeech,             // POS
                                     const WCHAR *pszPronunciation             // pron
                                     )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::SPPRONToLexWordInfo");

    WORDINFO *pWordInfo = (WORDINFO*) new BYTE[sizeof(WORDINFO) + (wcslen(pszPronunciation) + 1)*sizeof(WCHAR)];
    if (pWordInfo)
    {
        pWordInfo->ePartOfSpeech = ePartOfSpeech;
        wcscpy(pWordInfo->wPronunciation, pszPronunciation);
    }
    return pWordInfo;
}

/*******************************************************************************
* CSpUnCompressedLexicon::GetDictEntries *
*----------------------------------------*
*     Description:
*        This function gets the entries in the dictionary whose offsets
*        have been passed in   
*
*     Return: n/a
**************************************************************** YUNUSM *******/
void CSpUnCompressedLexicon::GetDictEntries(SPWORDLIST *pWordList,    // The buffer to fill with words and wordinfo
                           DWORD *pdwOffsets,        // The offsets of the words
                           bool *pfAdd,              // bools for add/deleted words
                           LANGID *pLangIDs,             // LangIDs of the words
                           DWORD nWords              // The number of offsets
                           )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::GetDictEntries");

    pWordList->ulSize = sizeof(SPWORDLIST);
    SPWORD *pWord = pWordList->pFirstWord;

    for (DWORD i = 0; i < nWords; i++)
    {
        UNALIGNED DICTNODE *pNode = (UNALIGNED DICTNODE *)(m_pSharedMem + pdwOffsets[i]);

        if (true == pfAdd[i])
        {
            pWord->eWordType = eWORDTYPE_ADDED;
        }
        else
        {
            pWord->eWordType = eWORDTYPE_DELETED;
        }
        pWord->LangID = pLangIDs[i];

        pWord->pszWord = (WCHAR*)(pWord + 1);
        wcscpy(pWord->pszWord, (WCHAR*)(pNode->pBuffer));

        if (pNode->nNumInfoBlocks)
        {
            pWord->pFirstWordPronunciation = (SPWORDPRONUNCIATION*)((BYTE *)pWord + WordSize(pWord->pszWord));
        }
        else
        {
            pWord->pFirstWordPronunciation = NULL;
        }
        SPWORDPRONUNCIATION *pWordPronunciation = pWord->pFirstWordPronunciation;

        UNALIGNED WORDINFO *pInfo = (WORDINFO *)(pNode->pBuffer + (wcslen(pWord->pszWord) + 1) * sizeof(WCHAR));
        for (DWORD j = 0; j < pNode->nNumInfoBlocks; j++)
        {
            pWordPronunciation->eLexiconType = m_eLexType;
            pWordPronunciation->ePartOfSpeech = pInfo->ePartOfSpeech;
            pWordPronunciation->LangID = pWord->LangID;
            wcscpy(((SPWORDPRONUNCIATION *)pWordPronunciation)->szPronunciation, ((WORDINFO *)pInfo)->wPronunciation);
            pInfo = (WORDINFO*)((BYTE*)pInfo + sizeof(WORDINFO) + (wcslen(((WORDINFO *)pInfo)->wPronunciation) + 1) * sizeof(WCHAR));

            // +1 for zero termination included in the size of the SPWORDPRONUNCIATION structure.
            SPWORDPRONUNCIATION *pWordPronunciationNext = (SPWORDPRONUNCIATION *)((BYTE*)pWordPronunciation + PronSize(pWordPronunciation->szPronunciation));

            if (j < pNode->nNumInfoBlocks - 1)
            {
                pWordPronunciation->pNextWordPronunciation = pWordPronunciationNext;
            }
            else
            {
                pWordPronunciation->pNextWordPronunciation = NULL;
            }
            pWordPronunciation = pWordPronunciationNext;
        }

        DWORD dwWordSize = DWORD(WordSize(pWord->pszWord) + 
            ((BYTE*)pWordPronunciation) - ((BYTE*)pWord->pFirstWordPronunciation));

        pWordList->ulSize += dwWordSize;
        SPWORD *pNextWord = (SPWORD *)(((BYTE*)pWord) + dwWordSize);

        if (i < nWords - 1)
        {
            pWord->pNextWord = pNextWord;
        }
        else
        {
            pWord->pNextWord = NULL;
        }
        pWord = pWord->pNextWord;
    }
}

/*******************************************************************************
* CSpUnCompressedLexicon::SetTooMuchChange *
*------------------------------------------*
*   Description:
*       Reset the history and cache
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
void CSpUnCompressedLexicon::SetTooMuchChange(void)
{
    SPDBG_FUNC("CSpUnCompressedLexicon::SetTooMuchChange");

    m_pRWLock->ClaimWriterLock();

    // Free all the dictnodes pointed to in the cache
    int iGen = m_pRWLexInfo->iCacheNext;
    if (iGen)
    {
        iGen--;
    }
    // Removal of cache words should not set fRemovals to true.
    // Store current value and reset after.
    for (DWORD i = 0; i < m_pRWLexInfo->nHistory; i++)
    {
        if (!m_pChangedWordsCache[iGen].fAdd)
        {
            DeleteWordDictNode(m_pChangedWordsCache[iGen--].nOffset);
        }
        if (iGen < 0)
        {
            iGen = g_dwCacheSize - 1;
        }
    }
    // Zero the history and up the generation id
    m_pRWLexInfo->iCacheNext = 0;
    m_pRWLexInfo->nHistory = 0;
    ZeroMemory(m_pChangedWordsCache, g_dwCacheSize * sizeof(WCACHENODE));
    (m_pRWLexInfo->nGenerationId)++;

    m_pRWLock->ReleaseWriterLock();
}

/*******************************************************************************
* CSpUnCompressedLexicon::Flush *
*-------------------------------*
*   Description:
*       Flushes the lexicon to disk
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
HRESULT CSpUnCompressedLexicon::Flush(DWORD iWrite   // ith write
                     )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::Flush");

    HRESULT hr = S_OK;
    if (iWrite == m_dwFlushRate)
    {
        if (m_eLexType == eLEXTYPE_USER)
        {
            hr = Serialize(true);
        }
        m_iWrite = 0;
    }

    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::Serialize *
*-----------------------------------*
*   Description:
*       Compact and serilaize the lexicon 
*
*   Return:
*       GetLastError()
*       E_OUTOFMEMORY
*       S_OK
**************************************************************** YUNUSM *******/
HRESULT CSpUnCompressedLexicon::Serialize(bool fQuick               // if true serilaize without compacting
                         )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::Serialize");

    HRESULT hr = S_OK;
    bool fLockAcquired = false;
 
    m_pRWLock->ClaimWriterLock();

    HANDLE hInitMutex = g_Unicode.CreateMutex(NULL, FALSE, g_pszDictInitMutexName);
    if (!hInitMutex)
    {
        hr = SpHrFromLastWin32Error();
    }
    if (SUCCEEDED(hr))
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(hInitMutex, INFINITE))
        {
            fLockAcquired = true;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    // Check if any changes have been made
    if (SUCCEEDED(hr))
    {
        WCHAR wszTempFile[MAX_PATH*2];
        PBYTE pBuf = NULL;
        DWORD nAddBuf = 0;
        DWORD nBuf = 0;
        DWORD *pdwOffsets = NULL;
        bool fRemovalsSave = m_pRWLexInfo->fRemovals;
        bool fAdditionsSave = m_pRWLexInfo->fAdditions;

        wcscpy(wszTempFile, m_wDictFile);
        wcscat(wszTempFile, L".tmp");
 
        g_Unicode.DeleteFile(wszTempFile);
 
        HANDLE hFile = g_Unicode.CreateFile(wszTempFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = SpHrFromWin32(GetLastError ());
        }
        if (SUCCEEDED(hr) && m_pRWLexInfo->fRemovals && !fQuick)
        {
            UNALIGNED LANGIDNODE * paLangID = NULL;
            DWORD iWord = 0;
            DWORD i = 0;

            // get all the entries in the object
            pBuf = new BYTE[m_pRWLexInfo->nDictSize];
            if (!pBuf)
            {
                hr = E_OUTOFMEMORY;
            }
            if (SUCCEEDED(hr))
            {
                paLangID = (UNALIGNED LANGIDNODE *)(m_pSharedMem + sizeof(RWLEXINFO));
                pdwOffsets = new DWORD[m_pRWLexInfo->nRWWords];
                if (!pdwOffsets)
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            if (SUCCEEDED(hr))
            {
                // Copy the real words .i.e. those accessible thru the hash table
                for (i = 0; i < g_dwNumLangIDsSupported; i++)
                {
                    if (0 == paLangID[i].LangID)
                    {
                        continue;
                    }        
                    SPDBG_ASSERT (paLangID[i].nHashOffset);
        
                    PDWORD pHashTable = (PDWORD)(m_pSharedMem + paLangID[i].nHashOffset);
                    for (DWORD j = 0; j < paLangID[i].nHashLength; j++)
                    {
                        if (0 == pHashTable[j])
                        {
                            continue;
                        }
                        DWORD nOffset = pHashTable[j];
                        while (nOffset)
                        {
                            pdwOffsets[iWord++] = nOffset;
                            CopyMemory (pBuf + nBuf, (PDICTNODE)(m_pSharedMem + nOffset), 
                                ((UNALIGNED DICTNODE *)(m_pSharedMem + nOffset))->nSize);
        
                           //cache away the LangID in the unused nNextOffset of DICTNODE
                           ((UNALIGNED DICTNODE *)(pBuf + nBuf))->nNextOffset = paLangID[i].LangID;
        
                           nBuf += ((UNALIGNED DICTNODE *)(m_pSharedMem + nOffset))->nSize;
       
                           SPDBG_ASSERT(((UNALIGNED DICTNODE *)(m_pSharedMem + nOffset))->nNextOffset != nOffset);
                           nOffset = ((UNALIGNED DICTNODE *)(m_pSharedMem + nOffset))->nNextOffset;
                        }
                    }
                }

                SPDBG_ASSERT(nBuf < m_pRWLexInfo->nDictSize);
                SPDBG_ASSERT(iWord == m_pRWLexInfo->nRWWords);

                // Copy the words maintained for history (not accessible thru the hash table)
                nAddBuf = nBuf;
 
                bool aOffsetAdjusted[g_dwCacheSize];
                ZeroMemory(aOffsetAdjusted, g_dwCacheSize * sizeof(bool));

                if (m_pRWLexInfo->nHistory)
                {
                    // Left-align the cache nodes array (which is a circular buffer)
                    // It is possible to do this without using the temp buffer (as done below). You have to
                    // independently reverse the two parts of the cache, delete the intervening spaces
                    // and then reverse the entire (contiguous) cache. This takes O(n) time.
                    DWORD j;
                    WCACHENODE aTempCache[g_dwCacheSize];
                    if (m_pRWLexInfo->iCacheNext == 0)
                    {
                        j = g_dwCacheSize - 1;
                    }
                    else
                    {
                        j = m_pRWLexInfo->iCacheNext - 1;
                    }
                    for (i = m_pRWLexInfo->nHistory - 1; ((int)i) >= 0; )
                    {    
                        aTempCache[i--] = m_pChangedWordsCache[j--];
                        if (j == (DWORD)-1)
                        {
                            j = g_dwCacheSize - 1;
                        }
                    }
 
                    CopyMemory(m_pChangedWordsCache, aTempCache, m_pRWLexInfo->nHistory * sizeof(WCACHENODE));
                    m_pRWLexInfo->iCacheNext = m_pRWLexInfo->nHistory;
                    if (m_pRWLexInfo->iCacheNext == g_dwCacheSize)
                    {
                        m_pRWLexInfo->iCacheNext = 0;
                    }
                    // Get the words that have been deleted and cached. These words do not have their offsets
                    // in the hash table
                    for (i = 0; i < m_pRWLexInfo->nHistory; i++)
                    {
                        if (m_pChangedWordsCache[i].fAdd == true)
                        {
                            continue;
                        }
                        CopyMemory(pBuf + nBuf, (PDICTNODE)(m_pSharedMem + m_pChangedWordsCache[i].nOffset), 
                                    ((UNALIGNED DICTNODE *)(m_pSharedMem + m_pChangedWordsCache[i].nOffset))->nSize);
            
                        nBuf += ((UNALIGNED DICTNODE *)(m_pSharedMem + m_pChangedWordsCache[i].nOffset))->nSize;
                    }
                }
       
                // Reset the object
                // leave the header and add/delete caches alone
                m_pRWLexInfo->nDictSize = sizeof(RWLEXINFO);
 
                (m_pRWLexInfo->nDictSize) += sizeof(LANGIDNODE) * g_dwNumLangIDsSupported + sizeof(WCACHENODE) * g_dwCacheSize;
                m_pRWLexInfo->nFreeHeadOffset = 0;
                m_pRWLexInfo->fRemovals = false;

                // Reallocate the hash tables growing them if necessary
                paLangID = (UNALIGNED LANGIDNODE *)(m_pSharedMem + sizeof(RWLEXINFO));
                for (i = 0; i < g_dwNumLangIDsSupported; i++)
                {
                    if (!paLangID[i].LangID)
                    {
                        break;
                    }
                    hr = ReallocateHashTable(i);
                    if (FAILED(hr))
                    {
                        break;
                    }
                }

                DWORD n = 0;
                if (SUCCEEDED(hr))
                {
                    // add the words back so that they are added compacted
                    iWord = 0;
                    
                    while (n < nAddBuf)
                    {
                        UNALIGNED DICTNODE * p = (UNALIGNED DICTNODE *)(pBuf + n);
                        PWSTR pwWord = (PWSTR)(p->pBuffer);
                        DWORD nNewOffset, nOffsetFind;
 
                        hr = AddDictNode((LANGID)(p->nNextOffset), p, &nNewOffset);
                        if (FAILED(hr))
                        {
                            break;
                        }
                        // Look for this word's offset in the changed word's cache. If found, update the offset
                        nOffsetFind = pdwOffsets[iWord++];
 
                        for (UINT iFind = 0; iFind < m_pRWLexInfo->nHistory; iFind++)
                        {
                            if (m_pChangedWordsCache[iFind].nOffset == nOffsetFind && !aOffsetAdjusted[iFind])
                            {
                                SPDBG_ASSERT (m_pChangedWordsCache[iFind].fAdd == true);
                                m_pChangedWordsCache[iFind].nOffset = nNewOffset;
                                aOffsetAdjusted[iFind] = true;
                            }
                        }
                        n += p->nSize;
                    }
                    SPDBG_ASSERT(n == nAddBuf);
                    SPDBG_ASSERT(iWord == m_pRWLexInfo->nRWWords);
                }
                if (SUCCEEDED(hr))
                {
                    // add the history words back - These words are not added above because we dont want them to be accessible thru the hash table
                    // which can cause duplicate words
                    CopyMemory(m_pSharedMem + m_pRWLexInfo->nDictSize, pBuf + nAddBuf, nBuf - nAddBuf);
 
                    // Set the new offsets in the history cache
                    n = m_pRWLexInfo->nDictSize;
                    iWord = 0;
                    while (n < (m_pRWLexInfo->nDictSize + nBuf - nAddBuf))
                    {
                        UNALIGNED DICTNODE * p = (UNALIGNED DICTNODE *)(m_pSharedMem + n);
                
                        // Look for this word's offset in the changed word's cache.
                        for (DWORD iFind = iWord; iFind < m_pRWLexInfo->nHistory && m_pChangedWordsCache[iFind].fAdd; iFind++);
                        SPDBG_ASSERT(iFind < m_pRWLexInfo->nHistory);
                        SPDBG_ASSERT(!aOffsetAdjusted[iFind]);
                        DWORD nDeletedOffset = m_pChangedWordsCache[iFind].nOffset;
                        m_pChangedWordsCache[iFind].nOffset = n;
                        aOffsetAdjusted[iFind] = true;
                        iWord = iFind + 1;
                        // find any other (add) entries with the same offset and update that too
                        for (iFind = 0; iFind < m_pRWLexInfo->nHistory; iFind++)
                        {
                            if (m_pChangedWordsCache[iFind].nOffset == nDeletedOffset && !aOffsetAdjusted[iFind])
                            {
                                SPDBG_ASSERT(m_pChangedWordsCache[iFind].fAdd);
                                m_pChangedWordsCache[iFind].nOffset = n;
                                aOffsetAdjusted[iFind] = true;
                            }
                        }
                        n += p->nSize;
                    }
 
#ifdef _DEBUG
                    for (int i = 0; i < m_pRWLexInfo->nHistory; i++) 
                    {
                        SPDBG_ASSERT(aOffsetAdjusted[i]);
                    }
#endif
                    SPDBG_ASSERT(n == m_pRWLexInfo->nDictSize + nBuf - nAddBuf);
                    m_pRWLexInfo->nDictSize = n;   
                } // if (SUCCEEDED(hr))
            } // if (SUCCEEDED(hr))
            if (pdwOffsets)
            {
                delete [] pdwOffsets;
            }
            if (pBuf)
            {
                delete [] pBuf;
            }
        } // if (m_pRWLexInfo->fRemovals && !fQuick)

        if (SUCCEEDED(hr))
        {
            DWORD d;
            m_pRWLexInfo->fRemovals = false;
            m_pRWLexInfo->fAdditions = false;
   
            // Write out the dictionary
            if (!WriteFile (hFile, m_pSharedMem, m_pRWLexInfo->nDictSize, &d, NULL) || (d != m_pRWLexInfo->nDictSize))
            {
                hr = SpHrFromLastWin32Error();
            }
            CloseHandle (hFile);
            if (SUCCEEDED(hr))
            {
                g_Unicode.DeleteFile(m_wDictFile);
                g_Unicode.MoveFile(wszTempFile, m_wDictFile); // Would like to use MoveFileEx but unsupported on 9X and CE
            }
            else
            {
                g_Unicode.DeleteFile(wszTempFile);
            }
        }
        else
        {
            CloseHandle (hFile);
            m_pRWLexInfo->fRemovals = fRemovalsSave;
            m_pRWLexInfo->fAdditions = fAdditionsSave;
        }
    } // if (SUCCEEDED(hr) && (true == m_pRWLexInfo->fAdditions || true == m_pRWLexInfo->fRemovals))
    if (fLockAcquired)
    {
        ReleaseMutex (hInitMutex);
    }
    CloseHandle(hInitMutex);
    m_pRWLock->ReleaseWriterLock ();
 
    return hr;
}

/*******************************************************************************
* CSpUnCompressedLexicon::IsBadLexPronunciation *
*-----------------------------------------------*
*   Checks and updates the phone convertor to match the passed in LangID and then
*   validates the pronunciation
*       
***************************************************************** YUNUSM ******/
HRESULT CSpUnCompressedLexicon::IsBadLexPronunciation(LANGID LangID,                        // LangID of the pronunciation
                                                const SPPHONEID *pszPronunciation,    // pronunciation
                                                BOOL *pfBad                       // true if bad pronunciation
                                                )
{
    SPDBG_FUNC("CSpUnCompressedLexicon::IsBadLexPronunciation");
    SPAUTO_OBJ_LOCK;
    
    HRESULT hr = S_OK;
    *pfBad = true;
    if (LangID != m_LangIDPhoneConv)
    {
        m_LangIDPhoneConv = (LANGID)(-1);
        m_cpPhoneConv.Release();
        hr = SpCreatePhoneConverter(LangID, NULL, NULL, &m_cpPhoneConv);
        if (SUCCEEDED(hr))
        {
            m_LangIDPhoneConv = LangID;
        }
    }
    if (SUCCEEDED(hr))
    {
        *pfBad = SPIsBadLexPronunciation(m_cpPhoneConv, pszPronunciation);
    }
    return hr;
}

//--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\cfggrammar.h ===
/*******************************************************************************
* CFGGrammar.h *
*-------------*
*   Description:
*-------------------------------------------------------------------------------
*  Created By: RAL
*  Copyright (C) 1998, 1999 Microsoft Corporation
*  All Rights Reserved
*******************************************************************************/

#ifndef __CFGGRAMMAR_H_
#define __CFGGRAMMAR_H_


#include "sapiint.h"

class CCFGEngine;
class CCFGGrammar;
class CWordHandle;

struct FIRSTPAIR
{
    FIRSTPAIR *   m_pNext;
    SPWORDHANDLE  hWord;
};

typedef enum CACHESTATUS { CACHE_VOID, CACHE_DONOTCACHE, CACHE_FAILED, CACHE_VALID };


struct RUNTIMERULEENTRY
{
    CCFGGrammar *   pRefGrammar;
    ULONG           ulGrammarRuleIndex;
    void *          pvClientContext;

    FIRSTPAIR *     pFirstList;
    CACHESTATUS     eCacheStatus;

    BOOL            fDynamic;                 // we keep track here since the binary is not reliable
    BOOL            fAutoPause;
    BOOL            fEngineActive;            // that's what we told the SR engine
    BOOL            fAppActive;               // that's what the app wants it to be                                              // can be different if the grammar is SPGM_DISABLED
};



//
//  This base class is used by the the CFG Engine and the SR Engine grammar implementations
//

class ATL_NO_VTABLE CBaseGrammar
{
friend CCFGEngine;
public:
    HRESULT InitFromMemory( const SPCFGSERIALIZEDHEADER * pHeader,
                            const WCHAR *pszGrammarName);
    HRESULT InitFromResource(const WCHAR * pszModuleName,
                             const WCHAR * pszResourceName,
                             const WCHAR * pszResourceType,
                             WORD wLanguage);
    HRESULT InitFromFile(const WCHAR * pszGrammarName);
    HRESULT InitFromCLSID(REFCLSID rcid, const WCHAR * pszGrammarName);

    void Clear();

    const SPCFGSERIALIZEDHEADER * Header()
    {
        SPDBG_ASSERT(m_pData);
        return (SPCFGSERIALIZEDHEADER *)m_pData;
    }

protected:
    //
    //  Derived class can implement this method to perform post-processing when the 
    //  grammar is loaded.
    //
    virtual HRESULT CompleteLoad()
    {
        return S_OK;
    }

    CBaseGrammar();
    virtual ~CBaseGrammar();

//
//  Derived class can access these data members directly
//
    CComPtr<ISpCFGInterpreter>  m_cpInterpreter;
    SPGRAMMARTYPE               m_LoadedType;
    SPGRAMMARTYPE               m_InLoadType;
    CSpDynamicString            m_dstrGrammarName;
    WORD                        m_ResIdName;    // If 0 then dstrGrammarName
    WORD                        m_ResIdType;    // If 0 then dstrResourceType
    WORD                        m_wResLanguage;
    CSpDynamicString            m_dstrResourceType;
    CSpDynamicString            m_dstrModuleName;
    HMODULE                     m_hInstanceModule;
    CLSID                       m_clsidGrammar;
    HANDLE                      m_hFile;
    HANDLE                      m_hMapFile;
    BYTE *                      m_pData;
    SPGRAMMARSTATE              m_eGrammarState;
};


typedef enum PROTOCOL { PROT_GUID, PROT_OBJECT, PROT_URL, PROT_UNK };

class ATL_NO_VTABLE CCFGGrammar : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public ISpCFGGrammar,
    public CBaseGrammar
{
public:
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCFGGrammar)
  COM_INTERFACE_ENTRY(ISpCFGGrammar)
END_COM_MAP()

// Non-interface methods
public:
    //
    //  ISpCFGGrammar
    //
    HRESULT CompleteLoad();

    HRESULT FinalConstruct();

    void BasicInit(ULONG ulGrammarID, CCFGEngine * pEngine);

    const WCHAR * RuleName(ULONG ulRuleIndex)
    {
        SPDBG_ASSERT(ulRuleIndex < m_Header.cRules);
        return m_Header.pszSymbols + m_Header.pRules[ulRuleIndex].NameSymbolOffset;
    }

    HRESULT ImportRule(ULONG ulImportRuleIndex);

    BOOL IsEqualResource(const WCHAR * pszModuleName,
                         const WCHAR * pszResourceName,
                         const WCHAR * pszResourceType,
                         WORD wLanguage);
    BOOL IsEqualFile(const WCHAR * pszFileName);
    BOOL IsEqualObject(REFCLSID rcid, const WCHAR * pszGrammarName);

    void FinalRelease();

    HRESULT _FindRuleIndexByID(DWORD dwRuleId, ULONG *pulRuleIndex);
    HRESULT _FindRuleIndexByName(const WCHAR * pszRuleName, ULONG *pulRuleIndex);
	HRESULT _FindRuleIndexByNameAndID( const WCHAR * pszRuleName, DWORD dwRuleId, ULONG * pulRuleIndex );

    STDMETHODIMP ActivateRule(const WCHAR * pszRuleName, DWORD dwRuleId, SPRULESTATE NewState, ULONG * pulNumActivated);
    STDMETHODIMP DeactivateRule(const WCHAR * pszRuleName, DWORD dwRuleId, ULONG * pulNumDeactivated);
    STDMETHODIMP SetGrammarState(const SPGRAMMARSTATE eGrammarState);
    STDMETHODIMP Reload(const SPBINARYGRAMMAR *pBinaryData);
    STDMETHODIMP GetNumberDictationTags(ULONG * pulTags);

    HRESULT      InternalReload( const SPBINARYGRAMMAR * pBinaryData );

//
//  Member data
//
public:
    CCFGEngine                 *m_pEngine;
    ULONG                       m_ulGrammarID;
    BYTE *                      m_pReplacementData;
    RUNTIMERULEENTRY *          m_pRuleTable;
    ULONG                       m_cNonImportRules;
    ULONG                       m_cTopLevelRules;
    BOOL                        m_fLoading;
    SPCFGHEADER                 m_Header;
    void *                      m_pvOwnerCookie;   // owner supplied cookie
    void *                      m_pvClientCookie;  // cookie to identify text buffer
    CWordHandle *               m_IndexToWordHandle;
    ULONG                       m_ulDictationTags;
};






#endif  // #ifndef __CFGGRAMMAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\dsaudiodevice.cpp ===
/****************************************************************************
*   dsaudiodevice.cpp
*       Implementation of the CDSoundAudioDevice class.
*
*   Owner: YUNUSM
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------

#include "stdafx.h"
#ifdef _WIN32_WCE
#include "sphelper.h"
#include "dsaudiodevice.h"

/****************************************************************************
* CDSoundAudioDevice::CDSoundAudioDevice *
*----------------------------------------*
*   Description:  
*       Ctor
*
*   Return:
*   n/a
******************************************************************* YUNUSM */
CDSoundAudioDevice::CDSoundAudioDevice(BOOL bWrite) :
    CBaseAudio<ISpDSoundAudio>(bWrite)
{
    m_guidDSoundDriver = GUID_NULL;
    NullMembers();
}

/****************************************************************************
* CDSoundAudioDevice::~CDSoundAudioDevice *
*-----------------------------------------*
*   Description:  
*       Dtor
*
*   Return:
*   n/a
******************************************************************* YUNUSM */
CDSoundAudioDevice::~CDSoundAudioDevice()
{
    CleanUp();
}

/****************************************************************************
* CDSoundAudioDevice::CleanUp *
*-----------------------------*
*   Description:  
*       Real Destructor
*
******************************************************************* YUNUSM */
HRESULT CDSoundAudioDevice::CleanUp()
{
    for (ULONG i = 0; i < m_ulNotifications; i++)
        CloseHandle(m_pdsbpn[i].hEventNotify);

    delete [] m_pdsbpn;
    delete [] m_paEvents;

    NullMembers();

    return S_OK;
}

/****************************************************************************
* CDSoundAudioDevice::NullMembers *
*---------------------------------*
*   Description:  
*       Real Constructor
*
******************************************************************* YUNUSM */
void CDSoundAudioDevice::NullMembers()
{
    m_pdsbpn = NULL;
    m_paEvents = NULL;
    m_ulNotifications = 0;
}

/****************************************************************************
* CDSoundAudioDevice::SetDSoundDriverGUID *
*-----------------------------------------*
*   Description:  
*       Set the device GUID.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
STDMETHODIMP CDSoundAudioDevice::SetDSoundDriverGUID(REFGUID rguidDSoundDriver)
{
    HRESULT hr = S_OK;
    SPAUTO_OBJ_LOCK;
    BOOL fInput;

    // Enumerate devices to determine if it is
    // 1. A valid guid for a dsound device.
    // 2. Is either an input or output guid as appropriate.
    //--- Determine if we're input or output based on our token
    CComPtr<ISpObjectToken> cpToken;
    CSpDynamicString dstrTokenId;
    hr = GetObjectToken(&cpToken);

    if (cpToken)
    {
        if (SUCCEEDED(hr))
        {
            hr = cpToken->GetId(&dstrTokenId);
        }
        if (SUCCEEDED(hr))
        {
            if (wcsnicmp(dstrTokenId, SPCAT_AUDIOIN, wcslen(SPCAT_AUDIOIN)) == 0)
            {
                fInput = TRUE;
            }
            else if (wcsnicmp(dstrTokenId, SPCAT_AUDIOOUT, wcslen(SPCAT_AUDIOOUT)) == 0)
            {
                fInput = FALSE;
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }

        CComPtr<IEnumSpObjectTokens> cpEnum;
        CComPtr<ISpObjectToken> cpObjToken;
        if (SUCCEEDED(hr))
        {
            if (fInput)
            {
                hr = SpEnumTokens(SPCAT_AUDIOIN, L"Technology=DSoundSys", NULL, &cpEnum);
            }
            else
            {
                hr = SpEnumTokens(SPCAT_AUDIOOUT, L"Technology=DSoundSys", NULL, &cpEnum);
            }
        }
        ULONG ulCount = 0, celtFetched = 0;
        if (SUCCEEDED(hr))
        {
            hr = cpEnum->Reset();
        }
        if (SUCCEEDED(hr))
        {
            HRESULT tmphr = S_OK;
            hr = E_INVALIDARG;
            celtFetched = 0;
            while (hr = SUCCEEDED(cpEnum->Next(1, &cpObjToken, &celtFetched)))
            {
                WCHAR szDriverGuid[128];
                CSpDynamicString dstrDriverGuid, dstrrGuid;
                StringFromGUID2(rguidDSoundDriver, szDriverGuid, sizeof(szDriverGuid));
                tmphr = cpObjToken->GetStringValue(L"DriverGUID", &dstrDriverGuid);
                if (SUCCEEDED(hr))
                {
                    if (wcscmp(szDriverGuid, dstrDriverGuid) == 0)
                    {
                        hr = S_OK;
                        break;
                    }
                }
            }
        }
    }
    if (SUCCEEDED(hr) && m_guidDSoundDriver != rguidDSoundDriver)
    {
        if (GetState() != SPAS_CLOSED)
        {
            hr = SPERR_DEVICE_BUSY;
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                //  If we have an object token, and have already been initialzed to a device
                //  other than the NULL (default) then we will fail.
                if (cpToken && m_guidDSoundDriver != GUID_NULL)
                {
                    hr = SPERR_ALREADY_INITIALIZED;
                }
                else
                {
                    m_guidDSoundDriver = rguidDSoundDriver;
                }
            }
        }
    }
    return hr;
}

/****************************************************************************
* CDSoundAudioDevice::GetDSoundDriverGUID *
*-----------------------------------------*
*   Description:  
*       Get the device GUID.
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
STDMETHODIMP CDSoundAudioDevice::GetDSoundDriverGUID(GUID * pguidDSoundDriver)
{
    SPAUTO_OBJ_LOCK;
    HRESULT hr = S_OK;

    if (::SPIsBadWritePtr(pguidDSoundDriver, sizeof(*pguidDSoundDriver)))
        hr = E_POINTER;
    else
        *pguidDSoundDriver = m_guidDSoundDriver;

    return hr;
}

/****************************************************************************
* CDSoundAudioDevice::SetDeviceNameFromToken *
*--------------------------------------------*
*   Description:  
*       Set the device name from the token (called by base class)
*       Not Needed.
*
*   Return:
******************************************************************* YUNUSM */
HRESULT CDSoundAudioDevice::SetDeviceNameFromToken(const WCHAR * pszDeviceName)
{
    return E_NOTIMPL;
}

/****************************************************************************
* CDSoundAudioDevice::SetObjectToken *
*------------------------------------*
*   Description:  
*       Initialize the audio device
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
STDMETHODIMP CDSoundAudioDevice::SetObjectToken(ISpObjectToken * pToken)
{
    SPAUTO_OBJ_LOCK;
    HRESULT hr = SpGenericSetObjectToken(pToken, m_cpToken);
    if (SUCCEEDED(hr))
    {
        CSpDynamicString dstrDriverGUID;
        pToken->GetStringValue(L"DriverGUID", &dstrDriverGUID);
        if (dstrDriverGUID)
        {
            CLSID clsid;
            hr = CLSIDFromString(dstrDriverGUID,  &clsid);
            if (SUCCEEDED(hr))
            {
                hr = SetDSoundDriverGUID(clsid);
            }
        }
    }

    return hr;
}

#endif // _WIN32_WCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\dict.h ===
/*******************************************************************************
*   Dict.h
*       Declaration of the CDict class that implements shared custom (user 
*       and app) lexicons. The custom lexicon is shared across the processes
*       using shared memory and a reader/writer lock. When an instance of 
*       CDict is created it is initialized with a lexicon file on the disk.
*       If this file does not exist then an empty file is created. The file
*       is loaded into memory and the memory is mapped and shared across 
*       processes. When an instance of the shared lexicon is shutting down
*       the data in the memory is flushed to the disk. At the Serilaization
*       time, the data is compacted to eliminate the holes created by
*       making modifications to the lexicon.
*
*       CUSTOM LEXICON FILE DATA FORMAT
*       -------------------------------
*       RWLEXINFO header + LANGIDNODE[g_dwNumLangIDsSupported] + 
*       WCACHENODE[g_dwCacheSize] + Data holding DICTNODEs
*
*       STRUCTS USED
*       ------------
*       RWLEXINFO holds the header information and other vital information 
*       about the lexicon file that needs to be shared across lexicon 
*       instances and that needs to be serialized.
*
*       LANGIDNODE holds an LANGID and an offset to the hash table that indexes
*       all the words belonging of this LANGID. Each entry in the hash table 
*       holds an offset to a word and its information. Word and its information
*       are encapsulated in a DICTNODE. Collisions in the hash table are
*       resolved by linear probing. We allow a maximum of
*       g_dwNumLangIDsSupported (25) LANDIDs. Since NT supports 23 LANDIDs we 
*       should be safe.
*
*       DICTNODE holds a word and the word's pronunciation and POS.
*       The format is a NULL terminated WCHAR string followed by an array
*       of WORDINFO nodes.
*
*       WORDINFO holds a POS and a pronunciation of a word. The 
*       pronunciation is stored as a NULL terminated IPA (WCHAR) string.
*
*       FREENODE is a free-link-list node. The free-link-list nodes are
*       created when words are deleted or chanegd. The nodes in the
*       free-link-list are attempted to be used first before allocating any
*       new memory.
*
*       WCACHENODE is a word cache node holding a change that has been made
*       to the lexicon. The WCACHENODE array is a circular buffer in which
*       changes are cached and are communicated to the clients. So memory
*       freed by changes to the lexicon is not really freed until the
*       WCACHENODE array is full and until an occupied cache node is
*       overwritten. At the point the memory of the cached word change is
*       freed and added to the free link list.
*
*   Owner: yunusm                                              Date: 06/18/99
*
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*******************************************************************************/

#pragma once

//--- Includes -----------------------------------------------------------------

#include "Sapi.h"
#include "RWLock.h"
#include "CommonLx.h"

#pragma warning(disable : 4200)

//--- TypeDef and Enumeration Declarations -------------------------------------

// Header for the Read/Write (RW) lexicon
typedef struct tagrwlexinfo
{
    GUID        guidValidationId;   // Validation Id for user/app lexicon object
    GUID        guidLexiconId;      // Lexicon ID - also used for mapname
    SPLEXICONTYPE eLexType;         // Lexicon Type
    RWLOCKINFO  RWLockInfo;         // reader/writer lock
    DWORD       nRWWords;           // number of words in dict
    DWORD       nDictSize;          // dict size in bytes
    DWORD       nFreeHeadOffset;    // free list head
    bool        fRemovals;          // true if there have been any removals - used to detect if data is compact
    bool        fAdditions;         // true if there have been any additions
    DWORD       nGenerationId;      // the master word generation id
    WORD        iCacheNext;         // Index in the changed words cache where the next element is to be added
    WORD        nHistory;           // Number of generation ids you can back to
} RWLEXINFO, *PRWLEXINFO;


typedef struct taglangidnode
{
    LANGID      LangID;             // langid of this node
    WORD        wReserved;
    DWORD       nHashOffset;        // offset in bytes from the start of mem block to the hash table
    DWORD       nHashLength;        // hash table length
    DWORD       nWords;             // number of words in the hash table
} LANGIDNODE, *PLANGIDNODE;


typedef struct tagdictnode
{
   
    DWORD       nSize;              // size of this node
    DWORD       nNextOffset;        // offsets in bytes from the start of the shared memory block
    DWORD       nNumInfoBlocks;     // Number of Pron+POS pairs for this word
    BYTE        pBuffer[0];         // Buffer holding (Null-terminated Word + 1 or more of WORDINFO blocks)
} DICTNODE, *PDICTNODE;


typedef struct taglexwordinfo
{
    SPPARTOFSPEECH ePartOfSpeech;   // part of speech
    WCHAR          wPronunciation[0];  // null terminated IPA pronunciation
} WORDINFO;


typedef struct tagfreedictnode
{
    DWORD       nSize;              // sizeof this node;
    DWORD       nNextOffset;        // offsets in bytes from the start of the shared memory block to the next node
} FREENODE, *PFREENODE;


// An array of WCACHENODE nodes is the cache holding offsets to changed words
typedef struct tagchangedwordcachenode
{
    LANGID      LangID;             // LangID of this word
    WORD        wReserved;
    DWORD       nOffset;            // offset of the word
    bool        fAdd;               // true if this is an added word, otherwise false
    DWORD       nGenerationId;      // generation id of this changed word
} WCACHENODE, *PWCACHENODE;

//--- Class, Struct and Union Definitions --------------------------------------

/*******************************************************************************
*
*   CDict
*
****************************************************************** YUNUSM *****/
class ATL_NO_VTABLE CSpUnCompressedLexicon : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CSpUnCompressedLexicon, &CLSID_SpUnCompressedLexicon>,
    public ISpLexicon,
    public ISpObjectWithToken
    #ifdef SAPI_AUTOMATION
    , public IDispatchImpl<ISpeechLexicon, &IID_ISpeechLexicon, &LIBID_SpeechLib, 5>
    #endif
{
//=== ATL Setup ===
public:
    DECLARE_REGISTRY_RESOURCEID(IDR_UNCOMPRESSEDLEXICON)
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    BEGIN_COM_MAP(CSpUnCompressedLexicon)
        COM_INTERFACE_ENTRY(ISpLexicon)
        COM_INTERFACE_ENTRY(ISpObjectWithToken)
#ifdef SAPI_AUTOMATION
        COM_INTERFACE_ENTRY(ISpeechLexicon)
        COM_INTERFACE_ENTRY(IDispatch)
#endif // SAPI_AUTOMATION
    END_COM_MAP()

//=== Methods ====
public:
    //--- Ctor, dtor, etc
    CSpUnCompressedLexicon();
    ~CSpUnCompressedLexicon();
    
//=== Interfaces ===
public:
    //--- ISpLexicon
    STDMETHODIMP GetPronunciations(const WCHAR * pwWord, LANGID LangID, DWORD dwFlags, SPWORDPRONUNCIATIONLIST * pWordPronunciationList);
    STDMETHODIMP AddPronunciation(const WCHAR * pwWord, LANGID LangID, SPPARTOFSPEECH ePartOfSpeech, const SPPHONEID * pszPronunciations);
    STDMETHODIMP RemovePronunciation(const WCHAR * pszWord, LANGID LangID, SPPARTOFSPEECH ePartOfSpeech, const SPPHONEID * pszPronunciation);
    STDMETHODIMP GetGeneration(DWORD *pdwGeneration);
    STDMETHODIMP GetGenerationChange(DWORD dwFlags, DWORD *pdwGeneration, SPWORDLIST *pWordList);
    STDMETHODIMP GetWords(DWORD dwFlags, DWORD *pdwGeneration, DWORD *pdwCookie, SPWORDLIST *pWordList);

    //--- ISpObjectWithToken
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);
    STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken);

#ifdef SAPI_AUTOMATION
    //--- ISpeechLexicon -----------------------------------------------------
    STDMETHODIMP get_GenerationId( long* GenerationId );
    STDMETHODIMP GetWords(SpeechLexiconType TypeFlags, long* GenerationID, ISpeechLexiconWords** Words );
    STDMETHODIMP AddPronunciation(BSTR bstrWord, SpeechLanguageId LangId, SpeechPartOfSpeech PartOfSpeech, BSTR bstrPronunciation);
    STDMETHODIMP AddPronunciationByPhoneIds(BSTR bstrWord, SpeechLanguageId LangId, SpeechPartOfSpeech PartOfSpeech, VARIANT* PhoneIds);
    STDMETHODIMP RemovePronunciation(BSTR bstrWord, SpeechLanguageId LangId, SpeechPartOfSpeech PartOfSpeech, BSTR bstrPronunciation );
    STDMETHODIMP RemovePronunciationByPhoneIds(BSTR bstrWord, SpeechLanguageId LangId, SpeechPartOfSpeech PartOfSpeech, VARIANT* PhoneIds );
    STDMETHODIMP GetPronunciations(BSTR bstrWord, SpeechLanguageId LangId, SpeechLexiconType TypeFlags, ISpeechLexiconPronunciations** ppPronunciations );
    STDMETHODIMP GetGenerationChange(long* GenerationID, ISpeechLexiconWords** ppWords);
#endif // SAPI_AUTOMATION

//=== Private methods ===
private:
    //--- Initialization and cleanup
    HRESULT Init(const WCHAR *pwszLexFile, BOOL fNewFile);
    HRESULT BuildEmptyDict(const WCHAR *wszLexFile);

    //--- Cache Reset
    void SetTooMuchChange(void);

    //--- Serialization
    HRESULT Serialize (bool fQuick = false);
    
    //--- Sizeof
    DWORD SizeofWordInfoArray(WORDINFO* pInfo, DWORD dwNumInfo);
    void SizeOfDictNode(PCWSTR pwWord, WORDINFO* pInfo, DWORD dwNumInfo, DWORD *pnDictNodeSize, DWORD *pnInfoSize);
    void SizeofWords(DWORD *pdwOffsets, DWORD nOffsets, DWORD *pdwSize);

    //--- DictNode management
    HRESULT AddWordAndInfo(PCWSTR pwWord, WORDINFO* pWordInfo, DWORD nNewNodeSize, DWORD nInfoSize,
                         DWORD nNumInfo, WORDINFO* pOldInfo, DWORD nOldInfoSize, DWORD nNumOldInfo, DWORD *pdwOffset);
    void DeleteWordDictNode(DWORD nOffset);
    DWORD GetFreeDictNode(DWORD nSize);
    HRESULT AddDictNode(LANGID LangID, UNALIGNED DICTNODE *pDictNode, DWORD *pdwOffset);

    //--- Hash table management
    HRESULT AllocateHashTable(DWORD iLangID, DWORD nHashLength);
    HRESULT ReallocateHashTable(DWORD iLangID);
    void AddWordToHashTable(LANGID LangID, DWORD dwOffset, bool fNewWord);
    void DeleteWordFromHashTable(LANGID LangID, DWORD dwOffset, bool fDeleteEntireWord);
    HRESULT WordOffsetFromHashTable(LANGID LangID, DWORD nHOffset, DWORD nHashLength, const WCHAR *pszWordKey, DWORD *pdwOffset);

    //--- LandID array management
    HRESULT AddLangID(LANGID LangID);
    DWORD LangIDIndexFromLangID(LANGID LangID);
    HRESULT WordOffsetFromLangID(LANGID LangID, const WCHAR *pszWord, DWORD *pdwOffset);

    //--- Cache management
    void AddCacheEntry(bool fAdd, LANGID LangID, DWORD nOffset);

    //--- Conversion/Derivation
    WCHAR* WordFromDictNode(UNALIGNED DICTNODE *pDictNode);
    WCHAR* WordFromDictNodeOffset(DWORD dwOffset);
    WORDINFO* WordInfoFromDictNode(UNALIGNED DICTNODE *pDictNode);
    WORDINFO* WordInfoFromDictNodeOffset(DWORD dwOffset);
    DWORD NumInfoBlocksFromDictNode(UNALIGNED DICTNODE *pDictNode);
    DWORD NumInfoBlocksFromDictNodeOffset(DWORD dwOffset);
    HRESULT SPListFromDictNodeOffset(LANGID LangID, DWORD nWordOffset, SPWORDPRONUNCIATIONLIST *pSPList);
    DWORD OffsetOfSubWordInfo(DWORD dwWordOffset, WORDINFO *pSubLexInfo);
    WORDINFO* SPPRONToLexWordInfo(SPPARTOFSPEECH ePartOfSpeech, const WCHAR *pszPronunciation);

    //--- Serialization
    HRESULT Flush(DWORD iWrite);

    //--- Helpers
    void GetDictEntries(SPWORDLIST *pWordList, DWORD *pdwOffsets, bool *pfAdd, LANGID *pLangIDs, DWORD nWords);

    //-- Validation
    HRESULT IsBadLexPronunciation(LANGID LangID, const WCHAR *pszPronunciation, BOOL *pfBad);

//=== Private data ===    
private:
    bool        m_fInit;                    // true if successfully initialized
    SPLEXICONTYPE m_eLexType;               // lexicon type (user/app)
    PRWLEXINFO  m_pRWLexInfo;               // lex header
    WCHAR       m_wDictFile[MAX_PATH];      // The disk file name for this dict object
    HANDLE      m_hInitMutex;               // mutex to protect init and serialize
    HANDLE      m_hFileMapping;             // file map handle
    PBYTE       m_pSharedMem;               // shared mem pointer
    DWORD       m_dwMaxDictionarySize;      // The max size this object can grow to
    PWCACHENODE m_pChangedWordsCache;       // Cache holding offsets to the last g_dwCacheSize word changes
    CRWLock     *m_pRWLock;                 // reader/writer lock to protect access to dictionary
    DWORD       m_iWrite;                   // The ith write - keys when the lex gets flushed
    DWORD       m_dwFlushRate;              // nth write on which the lexicon is flushed
    LANGID      m_LangIDPhoneConv;          // LangID of the phone convertor
    CComPtr<ISpPhoneConverter> m_cpPhoneConv;// Phone Converter
    CComPtr<ISpObjectToken> m_cpObjectToken;// Object token to find and instantiate lexicons
    bool        m_fReadOnly;
};

//--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\dsaudioenum.cpp ===
/****************************************************************************
*   dsaudioenum.cpp
*       Implementation of the CDSoundAudioEnum class.
*
*   Owner: YUNUSM
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------
#include "stdafx.h"
#ifdef 0
#include "dsaudioenum.h"
#include "RegHelpers.h"

/****************************************************************************
* CDSoundAudioEnum::CDSoundAudioEnum *
*----------------------------*
*   Description:  
*       Ctor
*
*   Return:
*   n/a
******************************************************************* YUNUSM */
CDSoundAudioEnum::CDSoundAudioEnum()
{   
}   

STDMETHODIMP CDSoundAudioEnum::SetObjectToken(ISpObjectToken * pToken)
{
    SPDBG_FUNC("CDSoundAudioEnum::SetObjectToken");
    HRESULT hr = S_OK;

    if (m_cpEnum != NULL)
    {
        hr = SPERR_ALREADY_INITIALIZED;
    }
    else if (SP_IS_BAD_INTERFACE_PTR(pToken))
    {
        hr = E_POINTER;
    }

    //--- Determine if we're input or output based on our token
    CSpDynamicString dstrTokenId;
    if (SUCCEEDED(hr))
    {
        hr = pToken->GetId(&dstrTokenId);
    }

    if (SUCCEEDED(hr))
    {
        if (wcsnicmp(dstrTokenId, SPCAT_AUDIOIN, wcslen(SPCAT_AUDIOIN)) == 0)
        {
            m_fInput = TRUE;
        }
        else if (wcsnicmp(dstrTokenId, SPCAT_AUDIOOUT, wcslen(SPCAT_AUDIOOUT)) == 0)
        {
            m_fInput = FALSE;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }

    // Set our token, create the enum, and we're done
    if (SUCCEEDED(hr))
    {
        hr = SpGenericSetObjectToken(pToken, m_cpToken);
    }

    if (SUCCEEDED(hr))
    {
        hr = CreateEnum();
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}


STDMETHODIMP CDSoundAudioEnum::GetObjectToken(ISpObjectToken ** ppToken)
{
    SPDBG_FUNC("CDSoundAudioEnum::GetObjectToken");
    HRESULT hr;

    hr = SpGenericGetObjectToken(ppToken, m_cpToken);

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;    
}

STDMETHODIMP CDSoundAudioEnum::Next(ULONG celt, ISpObjectToken ** pelt, ULONG *pceltFetched)
{
    SPDBG_FUNC("CDSoundAudioEnum::Next");

    return m_cpEnum != NULL
                ? m_cpEnum->Next(celt, pelt, pceltFetched)
                : SPERR_UNINITIALIZED;
}

STDMETHODIMP CDSoundAudioEnum::Skip(ULONG celt)
{
    SPDBG_FUNC("CDSoundAudioEnum::Skip");

    return m_cpEnum != NULL
                ? m_cpEnum->Skip(celt)
                : SPERR_UNINITIALIZED;
}

STDMETHODIMP CDSoundAudioEnum::Reset()
{
    SPDBG_FUNC("CDSoundAudioEnum::Reset");

    return m_cpEnum != NULL
                ? m_cpEnum->Reset()
                : SPERR_UNINITIALIZED;
}

STDMETHODIMP CDSoundAudioEnum::Clone(IEnumSpObjectTokens **ppEnum)
{
    SPDBG_FUNC("CDSoundAudioEnum::Clone");

    return m_cpEnum != NULL
                ? m_cpEnum->Clone(ppEnum)
                : SPERR_UNINITIALIZED;
}

STDMETHODIMP CDSoundAudioEnum::GetCount(ULONG * pulCount)
{
    SPDBG_FUNC("CDSoundAudioEnum::GetCount");

    return m_cpEnum != NULL
                ? m_cpEnum->GetCount(pulCount)
                : SPERR_UNINITIALIZED;
}

STDMETHODIMP CDSoundAudioEnum::Item(ULONG Index, ISpObjectToken ** ppToken)
{
    SPDBG_FUNC("CDSoundAudioEnum::Item");

    return m_cpEnum != NULL
                ? m_cpEnum->Item(Index, ppToken)
                : SPERR_UNINITIALIZED;
}

STDMETHODIMP CDSoundAudioEnum::CreateEnum()
{
    SPDBG_FUNC("CDSoundAudioEnum::CreateEnum");
    HRESULT hr;

    // Create the enum builder
    hr = m_cpEnum.CoCreateInstance(CLSID_SpObjectTokenEnum);

    if (SUCCEEDED(hr))
    {
        hr = m_cpEnum->SetAttribs(NULL, NULL);
    }

    // Load DSound
    HMODULE hmodDSound;
    if (SUCCEEDED(hr))
    {
        hmodDSound = LoadLibrary(_T("dsound.dll"));
        if (hmodDSound == NULL)
        {
            hr = SpHrFromLastWin32Error();
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }
        }
    }

    // Now we will need someplace to store the tokens (in user)
    if (SUCCEEDED(hr))
    {
        CSpDynamicString dstrRegPath;
        dstrRegPath = m_fInput
            ? SPDSOUND_AUDIO_IN_TOKEN_ID
            : SPDSOUND_AUDIO_OUT_TOKEN_ID;
            
        SPDBG_ASSERT(dstrRegPath[dstrRegPath.Length() - 1] == '\\');
        dstrRegPath.TrimToSize(dstrRegPath.Length() - 1);
        
        hr = SpSzRegPathToDataKey(
                HKEY_CURRENT_USER, 
                dstrRegPath,
                TRUE,
                &m_cpDataKeyToStoreTokens);
    }

    
    // Enumerate the devices
    if (SUCCEEDED(hr))
    {
        typedef HRESULT (WINAPI *PFN_DSE)(LPDSENUMCALLBACKW, LPVOID);
        PFN_DSE pfnDSoundEnum;

        pfnDSoundEnum = PFN_DSE(GetProcAddress(
                                    hmodDSound,
                                    m_fInput
                                        ? ("DirectSoundCaptureEnumerateW")
                                        : ("DirectSoundEnumerateW")));
        if (pfnDSoundEnum == NULL)
        {
            hr = SpHrFromLastWin32Error();
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }
        }
        else
        {
            hr = pfnDSoundEnum(DSEnumCallbackSTATIC, this);
        }

        FreeLibrary(hmodDSound);
    }
    
    // NTRAID#SPEECH-0000-2000/08/24-agarside: Should we force success like this? The old code did, so we 
    // are here too
    hr = S_OK;

    return hr;
}

BOOL CDSoundAudioEnum::DSEnumCallback(
    LPGUID pguid, 
    LPCWSTR pszDescription, 
    LPCWSTR pszModule)
{
    SPDBG_FUNC("CDSoundAudioEnum::DSEnumCallback");
    HRESULT hr;
    
    if (!wcscmp(pszDescription, L"Primary Sound Driver") ||
        !wcscmp(pszDescription, L"Primary Sound Capture Driver"))
        return TRUE;

    // Build the device name
    CSpDynamicString dstrDeviceName;
    dstrDeviceName = L"Direct Sound ";
    dstrDeviceName.Append(pszDescription);
    
    // Create the token id for the new token
    CSpDynamicString dstrTokenId;
    dstrTokenId.Append(
        m_fInput
            ? SPDSOUND_AUDIO_IN_TOKEN_ID
            : SPDSOUND_AUDIO_OUT_TOKEN_ID);
    dstrTokenId.Append(dstrDeviceName);
    
    // Create a token for the device, and initialize it
    CComPtr<ISpDataKey> cpDataKeyForToken;
    hr = m_cpDataKeyToStoreTokens->CreateKey(dstrDeviceName, &cpDataKeyForToken);
    
    CComPtr<ISpObjectTokenInit> cpToken;
    if (SUCCEEDED(hr))
    {
        hr = cpToken.CoCreateInstance(CLSID_SpObjectToken);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpToken->InitFromDataKey(
                        m_fInput
                            ? SPCAT_AUDIOIN
                            : SPCAT_AUDIOOUT,
                        dstrTokenId,
                        cpDataKeyForToken);
    }
    
    // Tell it what it's language independent name is
    if (SUCCEEDED(hr))
    {
        hr = cpToken->SetStringValue(NULL, dstrDeviceName);
    }
    
    // Set it's CLSID
    CSpDynamicString dstrClsidToCreate;
    if (SUCCEEDED(hr))
    {
        hr = StringFromCLSID(
                m_fInput
                    ? CLSID_SpDSoundAudioIn
                    : CLSID_SpDSoundAudioOut,
                &dstrClsidToCreate);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpToken->SetStringValue(SPTOKENVALUE_CLSID, dstrClsidToCreate);
    }

    // Set it's device name, id and it's attributes
    if (SUCCEEDED(hr))
    {
        hr = cpToken->SetStringValue(L"DeviceName", dstrDeviceName);
    }
    
    if (SUCCEEDED(hr))
    {
        WCHAR szDriverGuid[128];
        StringFromGUID2(*pguid, szDriverGuid, sizeof(szDriverGuid));
        hr = cpToken->SetStringValue(L"DriverGUID", szDriverGuid);
    }
    
    CComPtr<ISpDataKey> cpDataKeyAttribs;
    if (SUCCEEDED(hr))
    {
        hr = cpToken->CreateKey(SPTOKENKEY_ATTRIBUTES, &cpDataKeyAttribs);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Vendor", L"Microsoft");
    }
    
    if (SUCCEEDED(hr))
    {
        hr = cpDataKeyAttribs->SetStringValue(L"Technology", L"DSoundSys");
    }
    
    // If we've gotten this far, add this token to the enum builder
    if (SUCCEEDED(hr))
    {
        ISpObjectToken * pToken = cpToken;
        hr = m_cpEnum->AddTokens(1, &pToken);
    }
    
    // NTRAID#SPEECH-0000-2000/08/24-agarside: Put the default DSound first
    
    return SUCCEEDED(hr);
}

BOOL CALLBACK CDSoundAudioEnum::DSEnumCallbackSTATIC(
    LPGUID pguid, 
    LPCWSTR pszDescription, 
    LPCWSTR pszModule, 
    void * pThis)
{
    return ((CDSoundAudioEnum*)pThis)->DSEnumCallback(pguid, pszDescription, pszModule);
}

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\dsaudiodevice.h ===
/****************************************************************************
*   dsaudiodevice.h
*       Declarataions for the CDSoundAudioDevice
*
*   Owner: YUNUSM
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#ifdef _WIN32_WCE

#pragma once

//--- Includes --------------------------------------------------------------

#include "baseaudio.h"
#include "dsaudiobuffer.h"
#include <dsound.h>

//--- Class, Struct and Union Definitions -----------------------------------

/****************************************************************************
*
*   CDSoundAudioDevice
*
******************************************************************* YUNUSM */
class ATL_NO_VTABLE CDSoundAudioDevice : 
    public CBaseAudio<ISpDSoundAudio>
{
//=== ATL Setup ===
public:

    BEGIN_COM_MAP(CDSoundAudioDevice)
        COM_INTERFACE_ENTRY(ISpDSoundAudio)
        COM_INTERFACE_ENTRY_CHAIN(CBaseAudio<ISpDSoundAudio>)
    END_COM_MAP()

//=== Methods ===
public:

    //--- Ctor, dtor
    CDSoundAudioDevice(BOOL bWrite);
    ~CDSoundAudioDevice();
    HRESULT CleanUp();
    void NullMembers();

//=== Interfaces ===
public:

    //--- ISpDSoundAudio ----------------------------------------------------
    STDMETHODIMP SetDSoundDriverGUID(REFGUID rguidDSoundDriver);
    STDMETHODIMP GetDSoundDriverGUID(GUID * pguidDSoundDriver);

//=== Overrides ===
public:
    HRESULT SetDeviceNameFromToken(const WCHAR * pszDeviceName);
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);

//=== Protected data ===
protected:

    GUID m_guidDSoundDriver;
    DSBPOSITIONNOTIFY * m_pdsbpn;
    HANDLE *m_paEvents;
    ULONG m_ulNotifications;
};

#endif // _WIN32_WCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\dsaudiobuffer.cpp ===
/****************************************************************************
*   dsaudiobuffer.cpp
*       Implementation of the CDSoundAudioBuffer class and it's derivatives.
*
*   Owner: YUNUSM
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------
#include "stdafx.h"
#ifdef _WIN32_WCE
#include "dsaudiobuffer.h"
#include <dsound.h>

/****************************************************************************
* CDSoundAudioBuffer::CDSoundAudioBuffer *
*----------------------------------------*
*   Description:  
*       Ctor
*
*   Return:
*   n/a
******************************************************************* YUNUSM */
CDSoundAudioBuffer::CDSoundAudioBuffer()
{
    ZeroMemory(&m_Header, sizeof(m_Header));
}

/****************************************************************************
* CDSoundAudioBuffer::AllocInternalBuffer *
*-----------------------------------------*
*   Description:  
*       Allocate internal buffer store for this object.
*
*   Return:
*   TRUE if successful
*   FALSE if not
******************************************************************* YUNUSM */
BOOL CDSoundAudioBuffer::AllocInternalBuffer(ULONG cb)
{
    SPDBG_ASSERT(NULL == m_Header.lpData);
    m_Header.lpData = new char[cb];
    if (m_Header.lpData)
    {
        m_Header.dwUser = 0;
        return TRUE;
    }
    return FALSE;
}

/****************************************************************************
* CDSoundAudioBuffer::~CDSoundAudioBuffer *
*-----------------------------------------*
*   Description:  
*       Dtor
*
*   Return:
*   n/a
******************************************************************* YUNUSM */
CDSoundAudioBuffer::~CDSoundAudioBuffer()
{
    delete[] m_Header.lpData;
}

/****************************************************************************
* CDSoundAudioBuffer::AsyncRead *
*-------------------------------*
*   Description:  
*       Overriden because this is a virtual function in base class.
*       This function is only called for input object buffers.
*
*   Return:
*   S_OK
******************************************************************* YUNUSM */
HRESULT CDSoundAudioBuffer::AsyncRead()
{
    SetReadOffset(0);
    SetWriteOffset(0);
    m_Header.dwFlags &= ~(WHDR_PREPARED | WHDR_DONE);
    return S_OK;
}

/****************************************************************************
* CDSoundAudioBuffer::AsyncWrite *
*----------------------------------*
*   Description:  
*       Overriden because this is a virtual function in base class.
*       This function is only called for output object buffers.
*
*   Return:
*   S_OK
******************************************************************* YUNUSM */
HRESULT CDSoundAudioBuffer::AsyncWrite()
{
    return S_OK;
}

/****************************************************************************
* CDSoundAudioInBuffer::ReadFromInternalBuffer *
*----------------------------------------------*
*   Description:  
*       Read from the internal buffer into the memory pointed to by pvData
*
*   Return:
*   S_OK if successful
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
HRESULT CDSoundAudioInBuffer::ReadFromInternalBuffer(void *pvData, ULONG cb)
{
    SPDBG_ASSERT(IsAsyncDone());
    memcpy(pvData, m_Header.lpData + GetReadOffset(), cb);
    return S_OK;
}

/****************************************************************************
* CDSoundAudioInBuffer::WriteToInternalBuffer *
*---------------------------------------------*
*   Description:  
*       Write to the internal buffer from the memory pointed to by pvData
*
*   Return:
*   S_OK if successful
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
HRESULT CDSoundAudioInBuffer::WriteToInternalBuffer(const void *pvData, ULONG cb)
{
    memcpy(m_Header.lpData + GetWriteOffset(), pvData, cb);
    m_Header.dwBytesRecorded = cb;
    m_Header.dwFlags = WHDR_PREPARED | WHDR_DONE;
    return S_OK;
}

/****************************************************************************
* CDSoundAudioOutBuffer::ReadFromInternalBuffer *
*-----------------------------------------------*
*   Description:  
*       Read from the internal buffer into the memory pointed to by pvData
*
*   Return:
*   S_OK if successful
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
HRESULT CDSoundAudioOutBuffer::ReadFromInternalBuffer(void *pvData, ULONG cb)
{
    if (cb > m_Header.dwBytesRecorded - GetReadOffset())
        cb = m_Header.dwBytesRecorded - GetReadOffset();

    memcpy(pvData, m_Header.lpData + GetReadOffset(), cb);
    if (cb + GetReadOffset() == m_Header.dwBytesRecorded)
        m_Header.dwFlags = WHDR_PREPARED | WHDR_DONE;

    SetReadOffset(GetReadOffset() + cb);

    return S_OK;
}

/****************************************************************************
* CDSoundAudioOutBuffer::WriteToInternalBuffer *
*----------------------------------------------*
*   Description:  
*       Write to the internal buffer from the memory pointed to by pvData
*
*   Return:
*   S_OK if successful
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
HRESULT CDSoundAudioOutBuffer::WriteToInternalBuffer(const void *pvData, ULONG cb)
{
    m_Header.dwFlags &= ~(WHDR_PREPARED | WHDR_DONE);

    memcpy(m_Header.lpData + GetWriteOffset(), pvData, cb);
    
    if (!GetWriteOffset())
        m_Header.dwBytesRecorded = cb;
    else
        m_Header.dwBytesRecorded += cb;

    return S_OK;
}

#endif // WIN32_WCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\dsaudiobuffer.h ===
/****************************************************************************
*   dsaudiobuffer.h
*       Declarations for the CDSoundAudioBuffer class and it's derivatives.
*
*   Owner: YUNUSM
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#ifdef 0

#pragma once

//--- Includes --------------------------------------------------------------

#include "sapi.h"
#include "baseaudiobuffer.h"
#include <dsound.h>

//--- Class, Struct and Union Definitions -----------------------------------

/****************************************************************************
*
*   CDSoundAudioBuffer
*
******************************************************************* YUNUSM */
class CDSoundAudioBuffer : public CBaseAudioBuffer
{
//=== Methods ===
public:

    //--- Ctor, dtor
    CDSoundAudioBuffer();
    ~CDSoundAudioBuffer();

//=== Protected methods ===
protected:

    //--- Override internal buffer related functions
    BOOL AllocInternalBuffer(ULONG cb);
    HRESULT AsyncRead();
    HRESULT AsyncWrite();
    HRESULT IsAsyncDone() { return (m_Header.dwFlags & WHDR_DONE); }

//=== Protected data ===
protected:

    //BOOL m_fAsyncInProgress;
    //WAVEHDR m_Header;
};

/****************************************************************************
*
*   CDSoundAudioInBuffer
*
******************************************************************* YUNUSM */
class CDSoundAudioInBuffer : public CDSoundAudioBuffer
{
//=== Methods ===
public:
    //--- Overriden methods
    ULONG GetWriteOffset() const { return m_Header.dwBytesRecorded; };
    void SetWriteOffset(ULONG cb) { m_Header.dwBytesRecorded = cb; };

//=== Protected methods ===
protected:

    //--- Override internal buffer related functions
    HRESULT ReadFromInternalBuffer(void *pvData, ULONG cb);
    HRESULT WriteToInternalBuffer(const void *pvData, ULONG cb);
};

/****************************************************************************
*
*   CDSoundAudioOutBuffer
*
******************************************************************* YUNUSM */
class CDSoundAudioOutBuffer : public CDSoundAudioBuffer
{
//=== Methods ===
public:

    //--- Override async methods
    //HRESULT IsAsyncDone();

//=== Protected methods ===
protected:

    //--- Override internal buffer related functions
    HRESULT ReadFromInternalBuffer(void *pvData, ULONG cb);
    HRESULT WriteToInternalBuffer(const void *pvData, ULONG cb);
};

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\dsaudioenum.h ===
/****************************************************************************
*   dsaudioenum.h
*       Declaration for the CDSoundAudioEnum class used to enumerate DS audio
*       input and output devices.
*
*   Owner: YUNUSM
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#ifdef 0

#pragma once

#include <dsound.h>

//--- Class, Struct and Union Definitions -----------------------------------

/****************************************************************************
*
*   CDSoundAudioEnum
*
******************************************************************* YUNUSM */
class ATL_NO_VTABLE CDSoundAudioEnum: 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDSoundAudioEnum, &CLSID_SpDSoundAudioEnum>,
    public ISpObjectWithToken,
    public IEnumSpObjectTokens
{
//=== ATL Setup ===
public:

    BEGIN_COM_MAP(CDSoundAudioEnum)
        COM_INTERFACE_ENTRY(ISpObjectWithToken)
        COM_INTERFACE_ENTRY(IEnumSpObjectTokens)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_DSAUDIOENUM)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

//=== Methods ===
public:

    //--- Ctor
    CDSoundAudioEnum();

//=== Interfaces ===
public:

    //--- ISpObjectWithToken ------------------------------------------------
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);
    STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken);

    //--- IEnumSpObjectTokens -----------------------------------------------
    STDMETHODIMP Next(ULONG celt, ISpObjectToken ** pelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumSpObjectTokens **ppEnum);
    STDMETHODIMP GetCount(ULONG * pulCount);
    STDMETHODIMP Item(ULONG Index, ISpObjectToken ** ppToken);

//=== Private methods
private:

    STDMETHODIMP CreateEnum();
    
    BOOL DSEnumCallback(
            LPGUID pguid, 
            LPCWSTR pszDescription, 
            LPCWSTR pszModule);

    static BOOL CALLBACK DSEnumCallbackSTATIC(
                            LPGUID pGuid, 
                            LPCWSTR pszDescription, 
                            LPCWSTR pszModule, 
                            void * pContext);

//=== Private data ===
private:

    CComPtr<ISpObjectToken> m_cpToken;
    BOOL m_fInput;

    CComPtr<ISpDataKey> m_cpDataKeyToStoreTokens;
    
    CComPtr<ISpObjectTokenEnumBuilder> m_cpEnum;
};

#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\dsaudioout.h ===
/****************************************************************************
*   dsaudioout.h
*       Declarataions for the CDSoundAudioDevice
*
*   Owner: YUNUSM
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#ifdef _WIN32_WCE

#pragma once

//--- Includes --------------------------------------------------------------

#include "dsaudiodevice.h"

//--- Class, Struct and Union Definitions -----------------------------------

/****************************************************************************
*
*   CDSoundAudioOut
*
******************************************************************* YUNUSM */
class ATL_NO_VTABLE CDSoundAudioOut : 
    public CDSoundAudioDevice,
	public CComCoClass<CDSoundAudioOut, &CLSID_SpDSoundAudioOut>
{
//=== ATL Setup ===
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_DSAUDIOOUT)
    DECLARE_NOT_AGGREGATEABLE(CDSoundAudioOut);
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

//=== Methods ===
public:

    //--- Ctor, Dtor ---
    CDSoundAudioOut();
    ~CDSoundAudioOut();
    HRESULT CleanUp();
    void NullMembers();

//=== Interfaces ===
public:

    //--- ISpAudio ----------------------------------------------------------
	STDMETHODIMP GetVolumeLevel(ULONG *pulLevel);
	STDMETHODIMP SetVolumeLevel(ULONG ulLevel);

    //--- ISpDSoundAudio ----------------------------------------------------
    STDMETHODIMP GetDSoundInterface(REFIID iid, void **ppvObject);

    //--- ISpThreadTask ----------------------------------------------------
    STDMETHODIMP ThreadProc(void * pvIgnored, HANDLE hExitThreadEvent, HANDLE hNotifyEvent, HWND hwnd, volatile const BOOL *);

//=== Overrides from the base class ===
public:

    HRESULT OpenDevice(HWND hwnd);
    HRESULT CloseDevice();
    HRESULT GetDefaultDeviceFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx);
    HRESULT ChangeDeviceState(SPAUDIOSTATE NewState);
    HRESULT AllocateDeviceBuffer(CBuffer ** ppBuff);
    BOOL UpdateDevicePosition(long * plFreeSpace, ULONG *pulNonBlockingIO);

//=== Private data ===
private:
    
    bool m_fInit;
    IDirectSound * m_pDS;
    IDirectSoundBuffer * m_pDSB;
    IDirectSoundNotify *m_pDSNotify;
    ULONGLONG m_ullDevicePositionPrivate;
};

#endif // _WIN32_WCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\dsaudioin.h ===
/****************************************************************************
*   dsaudioin.h
*       Declarataions for the CDSoundAudioDevice
*
*   Owner: YUNUSM
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

#ifdef _WIN32_WCE

#pragma once

//--- Includes --------------------------------------------------------------

#include "dsaudiodevice.h"

//--- Class, Struct and Union Definitions -----------------------------------

/****************************************************************************
*
*   CDSoundAudioIn
*
******************************************************************* YUNUSM */
class ATL_NO_VTABLE CDSoundAudioIn : 
    public CDSoundAudioDevice,
	public CComCoClass<CDSoundAudioIn, &CLSID_SpDSoundAudioIn>
{
//=== ATL Setup ===
public:

    DECLARE_REGISTRY_RESOURCEID(IDR_DSAUDIOIN)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

//=== Methods ===
public:

    //--- Ctor, Dtor ---
    CDSoundAudioIn();
    ~CDSoundAudioIn();
    HRESULT CleanUp();
    void NullMembers();

//=== Interfaces ===
public:

    //--- ISpDSoundAudio ----------------------------------------------------
    STDMETHODIMP GetDSoundInterface(REFIID iid, void **ppvObject);

    //--- ISpThreadTask ----------------------------------------------------
    STDMETHODIMP ThreadProc(void * pvIgnored, HANDLE hExitThreadEvent, HANDLE hNotifyEvent, HWND hwnd, volatile const BOOL *);

//=== Overrides from the base class ===
public:

    HRESULT OpenDevice(HWND hwnd);
    HRESULT CloseDevice();
    HRESULT GetDefaultDeviceFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx);
    HRESULT ChangeDeviceState(SPAUDIOSTATE NewState);
    HRESULT AllocateDeviceBuffer(CBuffer ** ppBuff);
    HRESULT ProcessDeviceBuffers(BUFFPROCREASON Reason);

//=== Private data ===
private:

    bool m_fInit;
    IDirectSoundCapture * m_pDSC;
    IDirectSoundCaptureBuffer * m_pDSCB;
    IDirectSoundNotify *m_pDSNotify;
};

#endif // _WIN32_WCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\dsaudioout.cpp ===
/****************************************************************************
*   dsaudiodevice.cpp
*       Implementation of the CDSoundAudioDevice class.
*
*   Owner: YUNUSM
*   Copyright (c) 1999 Microsoft Corporation All Rights Reserved.
*****************************************************************************/

//--- Includes --------------------------------------------------------------

#include "StdAfx.h"
#ifdef _WIN32_WCE
#include "mmaudioutils.h"
#include "dsaudioout.h"

/****************************************************************************
* CDSoundAudioOut::CDSoundAudioOut *
*----------------------------------*
*   Description:  
*       Constructor
*
******************************************************************* YUNUSM */
CDSoundAudioOut :: CDSoundAudioOut() :
    CDSoundAudioDevice(TRUE)
{
    m_ullDevicePosition = 0;
    m_ullDevicePositionPrivate = 0;
    NullMembers();   
}

/****************************************************************************
* CDSoundAudioOut::~CDSoundAudioOut *
*-----------------------------------*
*   Description:  
*       Destructor
*
******************************************************************* YUNUSM */
CDSoundAudioOut :: ~CDSoundAudioOut()
{
    CleanUp();
}

/****************************************************************************
* CDSoundAudioOut::CleanUp *
*--------------------------*
*   Description:  
*       Real Destructor
*
******************************************************************* YUNUSM */
HRESULT CDSoundAudioOut :: CleanUp()
{
    HRESULT hr = S_OK;

    SPAUTO_OBJ_LOCK;
    
    if (m_fInit)
    {
        InternalStateChange(SPAS_STOP);
    }
    if (m_pDSB)
    {
        hr = m_pDSB->Stop();
    }
    PurgeAllQueues();

    // CAUTION!!!
    // Releasing m_pDS frees the object (internally) pointed to by m_pDS, m_pDSB
    // and m_pDSNotify. One might think a ref count problem. But it is not.
    // If you release m_pDSNotify and m_pDSB and then release m_pDS everything is peachy.
    // This is what the samples that ship with DSound do. It is like DSound folks
    // designed the release behavior to be such that if the first obtained interface
    // (m_pDS) is released, then this object is not needed so get rid of all the
    // ref counts of interfaces on this object. This kindof makes sense but runs
    // counter to COM principles.
    if (m_pDSNotify)
    {
        m_pDSNotify->Release();
    }
    if (m_pDSB)
    {
        m_pDSB->Release();
    }
    if (m_pDS)
    {
        m_pDS->Release();
    }
    CDSoundAudioDevice::CleanUp();
    NullMembers();
    m_State = SPAS_CLOSED;

    return hr;
}

/****************************************************************************
* CDSoundAudioOut::NullMembers *
*------------------------------*
*   Description:  
*       Real Constructor
*
******************************************************************* YUNUSM */
void CDSoundAudioOut :: NullMembers()
{
    m_fInit = false;
    m_pDSNotify = NULL;
    m_pDSB = NULL;
    m_pDS = NULL;

    CDSoundAudioDevice::NullMembers();
}

/****************************************************************************
* CDSoundAudioOut::GetVolumeLevel *
*---------------------------------*
*   Description:
*       Returns the volume level on a scale of 0 - 10000
*       DSound currently defines DSBVOLUME_MIN = -10000 and DSBVOLUME_MAX = 0
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
****************************************************************** YUNUSM ***/
STDMETHODIMP CDSoundAudioOut::GetVolumeLevel(ULONG *pulLevel)
{
    SPDBG_FUNC("CDSoundAudioOut::GetVolumeLevel");
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(pulLevel))
    {
        return E_POINTER;
    }
    LONG lLevel;
    if (!m_fInit)
    {
        if (m_lDelayedVolumeSet != -1)
        {
            lLevel = m_lDelayedVolumeSet;
            hr = S_OK;
        }
        else
        {
            lLevel = 0;
            return SPERR_UNINITIALIZED;
        }
    }
    hr = m_pDSB->GetVolume(&lLevel);
    if (SUCCEEDED(hr))
    {
        lLevel += DSBVOLUME_MAX - DSBVOLUME_MIN; // bring it to positive scale
        *pulLevel = (lLevel * 10000) / (DSBVOLUME_MAX - DSBVOLUME_MIN);
    }
    return hr;
}

/****************************************************************************
* CDSoundAudioOut::SetVolumeLevel *
*---------------------------------*
*   Description:
*       Sets the volume level on a linear scale of 0 - 10000
*       DSound currently defines DSBVOLUME_MIN = -10000 and DSBVOLUME_MAX = 0
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
****************************************************************** YUNUSM ***/
STDMETHODIMP CDSoundAudioOut::SetVolumeLevel(ULONG ulLevel)
{
    SPDBG_FUNC("CDSoundAudioOut::SetVolumeLevel");
    if  (ulLevel > 10000)
    {
        return E_INVALIDARG;
    }
    if (!m_fInit)
    {
        m_lDelayedVolumeSet = (ulLevel * 10000 ) / (DSBVOLUME_MAX - DSBVOLUME_MIN);
        return S_OK;
    }
    LONG lLevel = (ulLevel * 10000) / (DSBVOLUME_MAX - DSBVOLUME_MIN); // rescale
    lLevel -= DSBVOLUME_MAX - DSBVOLUME_MIN; // Make it negative scale.
    return m_pDSB->SetVolume(lLevel);
}

/****************************************************************************
* CDSoundAudioOut::GetDSoundInterface *
*-------------------------------------*
*   Description:  
*       Return the DSound interface pointer
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
HRESULT CDSoundAudioOut::GetDSoundInterface(REFIID iid, void **ppvObject)
{
    HRESULT hr = S_OK;

    if (SP_IS_BAD_WRITE_PTR(ppvObject))
    {
        hr = E_POINTER;
    }
    else if (!m_fInit)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if (iid == IID_IDirectSound)
    {
        m_pDS->AddRef();
        *ppvObject = m_pDS;
    }
    else if (iid == IID_IDirectSoundBuffer)
    {
        m_pDSB->AddRef();
        *ppvObject = m_pDSB;
    }
    else if (iid == IID_IDirectSoundNotify)
    {
        m_pDSNotify->AddRef();
        *ppvObject = m_pDSNotify;
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}

/****************************************************************************
* CDSoundAudioOut::GetDefaultDeviceFormat *
*-----------------------------------------*
*   Description:  
*       Get the default device format (called by base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
HRESULT CDSoundAudioOut::GetDefaultDeviceFormat(GUID * pFormatId, WAVEFORMATEX ** ppCoMemWaveFormatEx)
{

    HRESULT hr = S_OK;

    if (!m_fInit)
    {
        hr = SPERR_UNINITIALIZED;
    }
    else
    {
        *pFormatId = SPDFID_WaveFormatEx;
        *ppCoMemWaveFormatEx = (WAVEFORMATEX *)::CoTaskMemAlloc(sizeof(WAVEFORMATEX));
        if (*ppCoMemWaveFormatEx)
        {
            hr = m_pDSB->GetFormat(*ppCoMemWaveFormatEx, sizeof(WAVEFORMATEX), NULL);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

/****************************************************************************
* CDSoundAudioOut::ChangeDeviceState *
*------------------------------------*
*   Description:  
*       Make whatever changes to the device status that are required (called
*       by the base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
HRESULT CDSoundAudioOut::ChangeDeviceState(SPAUDIOSTATE NewState)
{
    HRESULT hr = S_OK;

    switch (NewState)
    {
        case SPAS_STOP:
            m_ullDevicePositionPrivate = m_ullSeekPosition;
            hr = m_pDSB->Stop();
            if (SUCCEEDED(hr))
            {
                hr = m_pDSB->SetCurrentPosition(0);
            }
            break;

        case SPAS_PAUSE:
            hr = m_pDSB->Stop();
            break;

        case SPAS_RUN:  // restart
            hr = m_pDSB->Play(0, 0, DSBPLAY_LOOPING);
            if (SUCCEEDED(hr))
            {
                StartPump();
            }
            break;
    }
    return hr;
}
                
/****************************************************************************
* CDSoundAudioOut::AllocateDeviceBuffer *
*---------------------------------------*
*   Description:  
*       Allocate a buffer specific for this device
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
HRESULT CDSoundAudioOut::AllocateDeviceBuffer(CBuffer ** ppBuff)
{
    *ppBuff = new CDSoundAudioOutBuffer();
    if (*ppBuff)
    {
        return S_OK;
    }
    else 
    {
        return E_OUTOFMEMORY;
    }
}

/****************************************************************************
* CDSoundAudioOut::OpenDevice *
*-----------------------------*
*   Description:  
*       Open the device (called by the base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
HRESULT CDSoundAudioOut::OpenDevice(HWND hwnd)
{
    HRESULT hr = S_OK;

    SPAUTO_OBJ_LOCK;

    CleanUp();

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_DirectSound, NULL, CLSCTX_INPROC_SERVER,
                              IID_IDirectSound, reinterpret_cast<void**> (&m_pDS));
    }
    if (SUCCEEDED(hr))
    {
        hr = m_pDS->Initialize(m_guidDSoundDriver == GUID_NULL ? NULL : &m_guidDSoundDriver);
    }
    if (SUCCEEDED(hr))
    {
        HWND hWnd = GetForegroundWindow();
        if (hWnd == NULL)
        {
            hWnd = GetDesktopWindow();
        }
#ifdef _WIN32_WCE
        hr = m_pDS->SetCooperativeLevel(hWnd, DSSCL_NORMAL);
#else
        hr = m_pDS->SetCooperativeLevel(hWnd, DSSCL_PRIORITY);
#endif
    }
    if (SUCCEEDED(hr))
    {
        DSBUFFERDESC dsbd;
        ZeroMemory( &dsbd, sizeof(dsbd));
        dsbd.dwSize = sizeof(dsbd);
        dsbd.dwFlags = DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_GLOBALFOCUS
                      | DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_CTRLVOLUME ; 
        dsbd.dwBufferBytes = m_cDesiredBuffers * m_cbBufferSize; // smaller size might do
        dsbd.lpwfxFormat = m_StreamFormat.m_pCoMemWaveFormatEx;
        hr = m_pDS->CreateSoundBuffer(&dsbd, &m_pDSB, NULL);
    }
    //create the notification
    if (SUCCEEDED(hr))
    {
        hr = m_pDSB->QueryInterface(IID_IDirectSoundNotify, (void**)&m_pDSNotify);
    }
    if (SUCCEEDED(hr))
    {
        m_pdsbpn = new DSBPOSITIONNOTIFY[m_cDesiredBuffers];
        if (!m_pdsbpn)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            m_ulNotifications = m_cDesiredBuffers;
        }
    }
    if (SUCCEEDED(hr))
    {
        for (ULONG i = 0; i < m_ulNotifications; i++)
        {
            m_pdsbpn[i].hEventNotify = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (NULL == m_pdsbpn[i].hEventNotify)
            {
                hr = GetLastError();
                break;
            }

            m_pdsbpn[i].dwOffset = (i + 1) * m_cbBufferSize - 1;
        }
    }
    if (SUCCEEDED(hr))
    {
        hr = m_pDSNotify->SetNotificationPositions(m_ulNotifications, m_pdsbpn);
    }
    if (SUCCEEDED(hr))
    {
        m_paEvents = new HANDLE[m_ulNotifications + 1];
        if (!m_paEvents)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        for (ULONG i = 1; i < m_ulNotifications + 1; i++)
        {
            m_paEvents[i] = m_pdsbpn[i-1].hEventNotify;
        }
        m_fInit = true;
    }
    if (SUCCEEDED(hr))
    {
        StartPump();
    }
    if (SUCCEEDED(hr))
    {
        hr = m_pDSB->Play(0, 0, DSBPLAY_LOOPING);
    }
    if (SUCCEEDED(hr) && m_lDelayedVolumeSet != -1)
    {
        hr = m_pDSB->SetVolume(m_lDelayedVolumeSet);
        m_lDelayedVolumeSet = -1;
    }
    return hr;
}

/****************************************************************************
* CDSoundAudioOut::CloseDevice *
*------------------------------*
*   Description:  
*       Close the device (called by base class)
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
HRESULT CDSoundAudioOut::CloseDevice()
{
    HRESULT hr = CleanUp();
    m_State = SPAS_CLOSED;
    return hr;
}

/****************************************************************************
* CDSoundAudioOut::UpdateDevicePosition *
*---------------------------------------*
*   Description:  
*       Update the device position by calling teh wave out APIs, then chaining
*       to the base class.
*
*   Return:
*   BaseClass::UpdateDevicePosition()
******************************************************************* YUNUSM */
BOOL CDSoundAudioOut::UpdateDevicePosition(long * plFreeSpace, ULONG *pulNonBlockingIO)
{
    m_ullDevicePosition = m_ullDevicePositionPrivate;
    return CDSoundAudioDevice::UpdateDevicePosition(plFreeSpace, pulNonBlockingIO);
}

/****************************************************************************
* CDSoundAudioOut::ThreadProc *
*----------------------------*
*   Description:  
*       Overriden thread proc
*
*   Return:
*   S_OK on success
*   FAILED(hr) otherwise
******************************************************************* YUNUSM */
STDMETHODIMP CDSoundAudioOut::ThreadProc(void * pvIgnored, HANDLE hExitThreadEvent, HANDLE hNotifyEvent, HWND hwnd, volatile const BOOL *)
{
    m_paEvents[0] = hExitThreadEvent;
    while (TRUE)
    {
        DWORD dwWaitId = ::MsgWaitForMultipleObjects(m_ulNotifications + 1, m_paEvents, FALSE,
                                (m_State == SPAS_RUN) ? 500 : INFINITE, // Time-out every 1/2 second -- See note above
                                QS_ALLINPUT);
        
        if (dwWaitId == WAIT_OBJECT_0)
        {
            return CloseDevice();
        }
        else if (dwWaitId == WAIT_TIMEOUT)
        {
            CheckForAsyncBufferCompletion();
        }
        else if (m_fInit && dwWaitId > WAIT_OBJECT_0 && dwWaitId <= WAIT_OBJECT_0 + m_ulNotifications)
        {
            SPAUTO_OBJ_LOCK;
            
            // get a buffer from io queue that has not been played yet
            HRESULT hr = S_OK;
            void *pv1, *pv2;
            DWORD cb1, cb2;
            pv1 = pv2 = NULL;
            cb1 = cb2 = 0;

            CBuffer * pBuffer = NULL;
            DWORD cbToRead = m_cbBufferSize;
            // Allocating a buffer so that following logic is simpler
            BYTE * pBufferRead = new BYTE[m_cbBufferSize];
            if (!pBufferRead)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                // Fill with zeros so that in case the locked DSound buffer segment of size m_cbBufferSize
                // cannot be filled up with data (because we ran out of buffers in IOProgressQueue) then the
                // rest of DSound buffer segment is filled with silence (zeros).
                ZeroMemory(pBufferRead, m_cbBufferSize);
            }
            if (SUCCEEDED(hr))
            {
                hr = m_pDSB->Lock(0, m_cbBufferSize, &pv1, &cb1, &pv2, &cb2, DSBLOCK_FROMWRITECURSOR);
            }
            SPDBG_ASSERT(cb1 + cb2 == m_cbBufferSize);

            // Pull out buffers from the queue and read as much as we want to. If a buffer is not
            // completely read from in an iteration the same buffer is returned in the next call
            // to GetToProcessBuffer() as this buffer would not yet have been marked as DONE.
            while (SUCCEEDED(hr) && cbToRead && NULL != (pBuffer = m_IOInProgressQueue.GetToProcessBuffer()))
            {
                // It is not safe to call on the buffer after it has been read from because
                // it may have been marked DONE which would cause it to be recycled.
                DWORD cbBufferSize = pBuffer->GetWriteOffset() - pBuffer->GetReadOffset();
                hr = pBuffer->ReadFromInternalBuffer(pBufferRead + m_cbBufferSize - cbToRead, cbToRead);
                if (SUCCEEDED(hr))
                {
                    if (cbBufferSize >= cbToRead)
                    {
                        cbToRead = 0;
                    }
                    else
                    {
                        cbToRead -= cbBufferSize;
                    }
                }
            }
            // Copy the data to the locked DSound buffer but only if there is data to copy!
            if (SUCCEEDED(hr) && (m_cbBufferSize - cbToRead)>0)
            {
                CopyMemory(pv1, pBufferRead, cb1);
                if (pv2)
                {
                    CopyMemory(pv2, pBufferRead + cb1, cb2);
                }
            }
            // Update Device Position
            if (SUCCEEDED(hr))
            {
                m_ullDevicePositionPrivate += m_cbBufferSize - cbToRead;
            }
            // Deliberately not checking for SUCCEEDED(hr)
            m_pDSB->Unlock(pv1, cb1, pv2, cb2);
            CheckForAsyncBufferCompletion();
            if (pBufferRead)
            {
                delete [] pBufferRead;
            }
            SPDBG_ASSERT(SUCCEEDED(hr));
        }
        else
        {
            MSG Msg;
            while (::PeekMessage(&Msg, NULL, 0, 0, TRUE))
            {
                ::DispatchMessage(&Msg);
            }
        }
    } 
}

#endif // _WIN32_WCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\speech\sapi\sapi\fmtconv.cpp ===
/*******************************************************************************
* FmtConv.cpp *
*-------------*
*   Description:
*       This module is the main implementation file for the CFmtConv class.
*-------------------------------------------------------------------------------
*  Created By: EDC                                        Date: 04/03/2000
*  Copyright (C) 2000 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/

//--- Additional includes
#include "stdafx.h"
#include "FmtConv.h"
#include "StreamHlp.h"

//--- Local


/*****************************************************************************
* CFmtConv::FinalConstruct *
*--------------------------*
*   Description:
*       Constructor
********************************************************************* EDC ***/
HRESULT CFmtConv::FinalConstruct()
{
    SPDBG_FUNC( "CFmtConv::FinalConstruct" );
    m_ConvertedFormat.Clear();
    m_BaseFormat.Clear();
    m_SampleScaleFactor = 0;
    m_ullInitialSeekOffset = 0;
    m_fIsInitialized = false;
    m_fWrite         = false;
    m_fIsPassThrough = false;
    m_fDoFlush       = false;
    m_hPriAcmStream  = NULL;
    m_hSecAcmStream  = NULL;
    m_ulMinWriteBuffCount = 1;
    memset( &m_PriAcmStreamHdr, 0, sizeof( m_PriAcmStreamHdr ) );
    memset( &m_SecAcmStreamHdr, 0, sizeof( m_SecAcmStreamHdr ) );
    m_PriAcmStreamHdr.cbStruct = sizeof( m_PriAcmStreamHdr );
    m_SecAcmStreamHdr.cbStruct = sizeof( m_SecAcmStreamHdr );
    return S_OK;
} /* CFmtConv::FinalConstruct */

/*****************************************************************************
* CFmtConv::FinalRelease *
*------------------------*
*   Description:
*       
********************************************************************* EDC ***/
void CFmtConv::FinalRelease()
{
    SPDBG_FUNC( "CFmtConv::FinalRelease" );
    Flush();
    CloseACM();
} /* CFmtConv::FinalRelease */

/*****************************************************************************
* CFmtConv::AudioQI *
*-------------------*
*   Description:
*       This method exposes the ISpAudio interface if the base stream object
*   supports it.
********************************************************************* EDC ***/
HRESULT WINAPI CFmtConv::AudioQI( void* pvThis, REFIID riid, LPVOID* ppv, DWORD_PTR dw )
{
    SPDBG_FUNC( "CFmtConv::AudioQI" );
    HRESULT hr = S_OK;
    CFmtConv* pThis = (CFmtConv *)pvThis;

    if( pThis->m_cqipAudio )
    {
        ISpAudio *pAudio = (ISpAudio *)pThis;
        pAudio->AddRef();
        *ppv = pAudio;
    }
    else
    {
        *ppv = NULL;
        hr = S_FALSE;
    }
    return hr;
} /* CFmtConv::AudioQI */

/*****************************************************************************
* CFmtConv::EventSinkQI *
*-----------------------*
*   Description:
*       This method exposes the ISpEventSink interface if the base stream object
*   supports it.
********************************************************************* EDC ***/
HRESULT WINAPI CFmtConv::EventSinkQI( void* pvThis, REFIID riid, LPVOID* ppv, DWORD_PTR dw )
{
    SPDBG_FUNC( "CFmtConv::EventSinkQI" );
    HRESULT hr = S_OK;
    CFmtConv * pThis = (CFmtConv *)pvThis;

    if( pThis->m_cqipBaseEventSink )
    {
        ISpEventSink *pSink = (ISpEventSink *)pThis;
        pSink->AddRef();
        *ppv = pSink;
    }
    else
    {
        *ppv = NULL;
        hr = S_FALSE;
    }
    return hr;
} /* CFmtConv::EventSinkQI */

/*****************************************************************************
* CFmtConv::EventSourceQI *
*-------------------------*
*   Description:
*       This method exposes the ISpEventSource interface if the base stream object
*   supports it.
********************************************************************* EDC ***/
HRESULT WINAPI CFmtConv::EventSourceQI( void* pvThis, REFIID riid, LPVOID* ppv, DWORD_PTR dw )
{
    SPDBG_FUNC( "CFmtConv::EventSourceQI" );
    HRESULT hr = S_OK;
    CFmtConv * pThis = (CFmtConv *)pvThis;

    if( pThis->m_cqipBaseEventSource )
    {
        ISpEventSource *pSink = (ISpEventSource *)pThis;
        pSink->AddRef();
        *ppv = pSink;
    }
    else
    {
        *ppv = NULL;
        hr = S_FALSE;
    }
    return hr;
} /* CFmtConv::EventSourceQI */

/****************************************************************************
* CFmtConv::CloseACM *
*--------------------*
*   Description:
*       This method is used to release all ACM resources.
******************************************************************** EDC ***/
void CFmtConv::CloseACM( void )
{
    SPDBG_FUNC("CFmtConv::CloseACM");
    ClearIoCounts();
    if( m_hPriAcmStream )
    {
        ::acmStreamClose( m_hPriAcmStream, 0 );
        m_hPriAcmStream = NULL;
    }
    if( m_hSecAcmStream )
    {
        ::acmStreamClose( m_hSecAcmStream, 0 );
        m_hSecAcmStream = NULL;
    }
    m_fIsInitialized = false;
} /* CFmtConv::CloseACM */

/****************************************************************************
* CFmtConv::Flush *
*-----------------*
*   Description:
*       This method is used to process any data that has been buffered
*   for conversion.
******************************************************************** EDC ***/
void CFmtConv::Flush( void )
{
    SPDBG_FUNC("CFmtConv::Flush");
    if( m_fWrite && !m_fIsPassThrough && m_cpBaseStream && m_PriIn.GetCount() )
    {
        m_fDoFlush = true;
        BYTE DummyBuff;
        Write( &DummyBuff, 0, NULL );
        m_fDoFlush = false;
    }
} /* CFmtConv::Flush */

/****************************************************************************
* CFmtConv::ReleaseBaseStream *
*-----------------------------*
*   Description:
*       This method is used to release the base stream and reset member
*   variables back to the uninitialized state.
********************************************************************* RAL ***/
void CFmtConv::ReleaseBaseStream()
{
    SPDBG_FUNC("CFmtConv::ReleaseBaseStream");
    m_cpBaseStream.Release();
    m_cqipBaseEventSink.Release();
    m_cqipBaseEventSource.Release();
    m_BaseFormat.Clear();
    m_fIsInitialized = false;
} /* CFmtConv::ReleaseBaseStream */

/****************************************************************************
* OpenConversionStream *
*----------------------*
*   Description:
*
******************************************************************** EDC ***/
HRESULT OpenConversionStream( HACMSTREAM* pStm, WAVEFORMATEX* pSrc, WAVEFORMATEX* pDst )
{
    SPDBG_FUNC("CFmtConv::OpenConversionStream");
    HRESULT hr = S_OK;
    //--- Open suggested primary real time conversion
    hr = HRFromACM( ::acmStreamOpen( pStm, NULL, pSrc, pDst, NULL, 0, 0, 0 ) );
    if( hr == SPERR_UNSUPPORTED_FORMAT )
    {
        hr = HRFromACM( ::acmStreamOpen( pStm, NULL, pSrc, pDst, NULL, 0, 0,
                                         ACM_STREAMOPENF_NONREALTIME ) );
    }
    return hr;
} /* OpenConversionStream */

/****************************************************************************
* CFmtConv::SetupConversion *
*---------------------------*
*   Description:
*       This function is called internally by SetFormat and by SetBaseStream
*       to setup the ACM conversion process.  If the conversion process can not
*       be setup, the base stream is released.
*
******************************************************************** EDC ***/
HRESULT CFmtConv::SetupConversion( void )
{
    SPDBG_FUNC("CFmtConv::SetupConversion");
    HRESULT hr = S_OK;

    //--- Clear the previous conversion
    CloseACM();

    //--- Determine if we have a simple pass through
    m_fIsPassThrough = (m_ConvertedFormat == m_BaseFormat)?(true):(false);

    //--- Try to lookup appropriate codec(s)
    WAVEFORMATEX *pwfexSrc, *pwfexDst, *pSuggestWFEX;
    if( !m_fIsPassThrough )
    {
        //--- Select source and destination formats
        if( m_fWrite )
        {
            pwfexSrc = m_ConvertedFormat.m_pCoMemWaveFormatEx;
            pwfexDst = m_BaseFormat.m_pCoMemWaveFormatEx;
        }
        else
        {
            pwfexSrc = m_BaseFormat.m_pCoMemWaveFormatEx;
            pwfexDst = m_ConvertedFormat.m_pCoMemWaveFormatEx;
        }

        if( pwfexSrc && pwfexDst )
        {
            //--- Save the sample scale factor
            m_SampleScaleFactor = (double)pwfexDst->nAvgBytesPerSec /
                                  (double)pwfexSrc->nAvgBytesPerSec;

            //--- Try to open a direct conversion codec
            hr = OpenConversionStream( &m_hPriAcmStream, pwfexSrc, pwfexDst );
            if( hr == SPERR_UNSUPPORTED_FORMAT )
            {
                //--- Try to adjust the channels and sample rate to match destination
                BYTE aWFEXBuff[1000];
                pSuggestWFEX = (WAVEFORMATEX *)aWFEXBuff;
                memset(pSuggestWFEX, 0, sizeof(*pSuggestWFEX));
                DWORD dwValidFields = ACM_FORMATSUGGESTF_WFORMATTAG;
                pSuggestWFEX->wFormatTag = WAVE_FORMAT_PCM;

                if( pwfexSrc->wFormatTag == WAVE_FORMAT_PCM )
                {
                    dwValidFields |= ACM_FORMATSUGGESTF_NSAMPLESPERSEC |
                                     ACM_FORMATSUGGESTF_NCHANNELS;
                    pSuggestWFEX->nChannels      = pwfexDst->nChannels;
                    pSuggestWFEX->nSamplesPerSec = pwfexDst->nSamplesPerSec;
                }

                //--- See if we can find a suggested conversion
                if( ::acmFormatSuggest( NULL, pwfexSrc, pSuggestWFEX,
                                        sizeof(aWFEXBuff), dwValidFields ) )
                {
                    hr = SPERR_UNSUPPORTED_FORMAT;
                }
                else
                {
                    //--- Open suggested primary and secondary conversions
                    hr = OpenConversionStream( &m_hPriAcmStream, pwfexSrc, pSuggestWFEX );
                    if( SUCCEEDED( hr ) )
                    {
                        hr = OpenConversionStream( &m_hSecAcmStream, pSuggestWFEX, pwfexDst );
                    }
                }
            }
        }
        else
        {
            // Either Source or Dest is not a WAVEFORMATEX. We don't like it!
            hr = SPERR_UNSUPPORTED_FORMAT;
        }
    }

    if( SUCCEEDED(hr) )
    {
        //--- Estimate minimum number of bytes to accumulate in the write buffer
        if( !m_fIsPassThrough && m_fWrite )
        {
            MMRESULT mmr;
            if( m_hSecAcmStream )
            {
                mmr = ::acmStreamSize( m_hSecAcmStream, pwfexDst->nBlockAlign,
                                       &m_ulMinWriteBuffCount, ACM_STREAMSIZEF_DESTINATION );
                mmr = ::acmStreamSize( m_hPriAcmStream,
                                       max( pSuggestWFEX->nBlockAlign, m_ulMinWriteBuffCount ),
                                       &m_ulMinWriteBuffCount, ACM_STREAMSIZEF_DESTINATION );
            }
            else
            {
                mmr = ::acmStreamSize( m_hPriAcmStream, pwfexDst->nBlockAlign,
                                       &m_ulMinWriteBuffCount, ACM_STREAMSIZEF_DESTINATION );
            }
        }
        m_fIsInitialized = true;
    }
    else
    {
        CloseACM();
    }

    SPDBG_REPORT_ON_FAIL( hr );
    return hr;
} /* SetupConversion */

//
//=== ISpStreamFormatConverter implementation =================================
//
/*****************************************************************************
* EstimateReadSize *
*------------------*
*   Description:
*       This method uses the ACM to estimate a non zero read buffer size
********************************************************************* EDC ***/
HRESULT EstimateReadSize( HACMSTREAM hAcmStm, ULONG ulInSize, ULONG* pulOutSize )
{
    SPDBG_FUNC("CFmtConv::EstimateReadSize");
    HRESULT hr = S_OK;
    MMRESULT mmr;
    do
    {
        mmr = ::acmStreamSize( hAcmStm, ulInSize, pulOutSize,
                               ACM_STREAMSIZEF_DESTINATION );
        if( ( *pulOutSize == 0 ) || ( mmr == ACMERR_NOTPOSSIBLE ) )
        {
            ulInSize *= 2;
        }
        else if( mmr )
        {
            hr = E_FAIL;
        }
    } while( SUCCEEDED( hr ) && ( *pulOutSize == 0 ) );
    return hr;
} /* EstimateReadSize */

/*****************************************************************************
* CFmtConv::Read *
*----------------*
*   Description:
*       This method uses the ACM to convert data during a read operation.
********************************************************************* EDC ***/
STDMETHODIMP CFmtConv::Read( void * pv, ULONG cb, ULONG *pcbRead )
{
    SPDBG_FUNC( "CFmtConv::Read" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pcbRead ) )
    {
        hr = E_POINTER;
    }
    else if( SPIsBadWritePtr( pv, cb ) )
    {
        hr = E_INVALIDARG;
    }
    else if( m_fWrite )
    {
        //--- The base stream is write only
        hr = STG_E_ACCESSDENIED;
    }
    else if( !m_fIsInitialized )
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if( m_fIsPassThrough )
    {
        hr = m_cpBaseStream->Read( pv, cb, pcbRead );
    }
    else if( cb )
    {
        CIoBuff* pResult   = ( m_hSecAcmStream )?( &m_SecOut ):( &m_PriOut );
        ULONG    ulReadCnt = cb;

        while( SUCCEEDED( hr ) )
        {
            //--- Write result data if we have enough to fill the request
            if( pResult->GetCount() >= cb )
            {
                //--- We were able to generate the entire request
                hr = pResult->WriteTo( (BYTE*)pv, cb );
                if( pcbRead ) *pcbRead = cb;
                break;
            }

            //--- Estimate how much we need to read from the base stream
            if( m_hSecAcmStream )
            {
                hr = EstimateReadSize( m_hSecAcmStream, ulReadCnt, &ulReadCnt );
            }
            if( SUCCEEDED( hr ) )
            {
                hr = EstimateReadSize( m_hPriAcmStream, ulReadCnt, &ulReadCnt );
            }

            //--- Fill primary buffer
            ULONG ulNumRead = 0;
            if( SUCCEEDED( hr ) )
            {
                hr = m_PriIn.AddToBuff( m_cpBaseStream, ulReadCnt, &ulNumRead );
            }

            //--- Do primary conversion
            if( SUCCEEDED( hr ) && ulNumRead )
            {
                hr = DoConversion( m_hPriAcmStream, &m_PriAcmStreamHdr, &m_PriIn, &m_PriOut );
            }

            //--- Do secondary conversion
            if( SUCCEEDED( hr ) && m_hSecAcmStream && ulNumRead )
            {
                hr = m_PriOut.WriteTo( m_SecIn, m_PriOut.GetCount() );
                if( SUCCEEDED( hr ) )
                {
                    hr = DoConversion( m_hSecAcmStream, &m_SecAcmStreamHdr, &m_SecIn, &m_SecOut );
                }
            }

            //--- Check if we ran out of source data and were only able
            //    to generate a partial request
            if( ulNumRead == 0 )
            {
                if( pcbRead ) *pcbRead = pResult->GetCount();
                hr = pResult->WriteTo( (BYTE*)pv, pResult->GetCount() );
                break;
            }
            else if( pResult->GetCount() < cb )
            {
                //--- We need more source data to try and fill request
                ulReadCnt = (cb - pResult->GetCount()) * 2;
            }
        }
    }
    else if( pcbRead )
    {
        *pcbRead = 0;
    }

    if( FAILED( hr ) )
    {
        ClearIoCounts();
    }

    return hr;
} /* CFmtConv::Read */

/*****************************************************************************
* CFmtConv::Write *
*-----------------*
*   Description:
*       This method uses the ACM to convert the specified input data and
*   write it to the base stream.
********************************************************************* EDC ***/
STDMETHODIMP CFmtConv::Write( const void * pv, ULONG cb, ULONG *pcbWritten )
{
    SPDBG_FUNC( "CFmtConv::Write" );
    HRESULT hr = S_OK;

    if( SP_IS_BAD_OPTIONAL_WRITE_PTR( pcbWritten ) )
    {
        hr = E_POINTER;
    }
    else if( SPIsBadReadPtr( pv, cb ) )
    {
        hr = E_INVALIDARG;
    }
    else if( !m_fWrite )
    {
        //--- The base stream is read only
        hr = STG_E_ACCESSDENIED;
    }
    else if( !m_fIsInitialized )
    {
        hr = SPERR_UNINITIALIZED;
    }
    else if( m_fIsPassThrough )
    {
        hr = m_cpBaseStream->Write( pv, cb, pcbWritten );
    }
    else if( cb || m_fDoFlush )
    {
        CIoBuff* pResult = ( m_hSecAcmStream )?( &m_SecOut ):( &m_PriOut );

        //--- Setup input buffer
        hr = m_PriIn.AddToBuff( (BYTE*)pv, cb );

        //--- Make sure we have enough source data
        if( ( m_PriIn.GetCount() >= m_ulMinWriteBuffCount ) || m_fDoFlush )
        {
            //--- Do primary conversion
            if( SUCCEEDED( hr ) )
            {
                hr = DoConversion( m_hPriAcmStream, &m_PriAcmStreamHdr, &m_PriIn, &m_PriOut );
            }

            //--- Do secondary conversion
            if( (hr == S_OK) && m_hSecAcmStream )
            {
                hr = m_PriOut.WriteTo( m_SecIn, m_PriOut.GetCount() );
                if( SUCCEEDED( hr ) )
                {
                    hr = DoConversion( m_hSecAcmStream, &m_SecAcmStreamHdr, &m_SecIn, &m_SecOut );
                }
            }

            //--- Write result
            if( pResult->GetCount() )
            {
                hr = m_cpBaseStream->Write( pResult->GetBuff(), pResult->GetCount(), NULL );
                pResult->SetCount( 0 );
            }
        }

        //--- Return how many we wrote even if we just buffered it
        if( SUCCEEDED( hr ) )
        {
            //--- It's okay that we could only buffer the data
            if( hr == S_FALSE ) hr = S_OK;
            if( pcbWritten )
      