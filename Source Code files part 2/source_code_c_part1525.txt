Exists;		// set to true to use hack 
	bool	m_fIsText2Mode;
	bool	SelectMode(BYTE ch1, BYTE ch2);
	bool	IsText2Mode(void)			{ return m_fIsText2Mode ; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvel21dec.cpp ===
// -------------------------------------------------------
//  TveL21Dec.cpp
//
//		This is the Line21 (CC / T2) byte parser code.
//		It's responsible for taking pairs of bytes off
//		of the CC Decoder, which is set to deliver JUST T2 data,
//		and return full Atvef Triggers.
//
//		Code to strip out non T2 data has been removed from this
//		file.   
// -------------------------------------------------------

#include "stdafx.h"

#include <stdio.h>
#include <windows.h>
#include <atlbase.h>

#include "TveL21Dec.h"
#include "TveDbg.h"			// My debug tracing 

L21Buff::L21Buff()
{
	ClearBuff();
	m_bExpectRepeat = false;
	m_szBuffTrig[0] = 0;

	m_fIsText2Mode = false;
//	m_fCCDecoderBugsExists = true;			// HACK HACK HACK -- remove this!
}

BOOL L21Buff::IsTRorRTD(BYTE chFirst, BYTE chSecond)				// (0x14|0x15|0x1C|0x1D):0x2A|0x2B
{
	DBG_HEADER(CDebugLog::DBG_FLT_CC_PARSER2, _T("L21Buff::IsPAC"));

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now match code with control code list
    if ((0x14 <= chFirst  && 0x15 >= chFirst)  &&
        (0x2A <= chSecond && 0x2B >= chSecond))
        return TRUE ;
    
    return FALSE ;
}

BOOL L21Buff::IsPAC(BYTE chFirst, BYTE chSecond)				// (0x10-0x17|0x18-0x1F):0x40-0x7f
{
	DBG_HEADER(CDebugLog::DBG_FLT_CC_PARSER2, _T("L21Buff::IsPAC"));

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now match code with control code list
    if ((0x10 <= chFirst  && 0x17 >= chFirst)  &&
        (0x40 <= chSecond && 0x7F >= chSecond))
        return TRUE ;
    if ((0x18 <= chFirst  && 0x1F >= chFirst)  &&
        (0x40 <= chSecond && 0x7F >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


BOOL L21Buff::IsMiscControlCode(BYTE chFirst, BYTE chSecond)	// 0x21-0x23:0x17-0x1f | (0x14|0x15|0x1C|0x1D):0x20-0x2f
{
	DBG_HEADER(CDebugLog::DBG_FLT_CC_PARSER2, _T("L21Buff::IsMiscControlCode"));

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // first match with TO1 -> TO3 codes
    if ((0x21 <= chSecond && 0x23 >= chSecond)  &&
        (0x17 == chFirst  ||  0x1F == chFirst))
        return TRUE ;
    
    // Now match with the other misc control code
    if ((0x14 == chFirst  ||  0x15 == chFirst)  &&  
        (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    if ((0x1C == chFirst  ||  0x1D == chFirst)  &&  
        (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;

    return FALSE ;
}


BOOL L21Buff::IsMidRowCode(BYTE chFirst, BYTE chSecond)						// (0x11|0x19):0x20-0x2f
{
 	DBG_HEADER(CDebugLog::DBG_FLT_CC_PARSER2, _T("L21Buff::IsMidRowCode"));
 
    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // Now match with the mid row code list
    if ((0x11 == chFirst)  &&  (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    if ((0x19 == chFirst)  &&  (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    
    return FALSE ;
}

BOOL L21Buff::IsSpecialChar(BYTE chFirst, BYTE chSecond)			// (0x11|0x19):0x30-0x3f
{
 	DBG_HEADER(CDebugLog::DBG_FLT_CC_PARSER2, _T("L21Buff::IsSpecialChar"));
  
    // Strip the parity bit before determining the service channel
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now match code with special char list
    if (0x11 == chFirst && (0x30 <= chSecond && 0x3f >= chSecond))
        return TRUE ;
    if (0x19 == chFirst && (0x30 <= chSecond && 0x3f >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


UINT L21Buff::CheckControlCode(BYTE chFirst, BYTE chSecond)
{
 //	DBG_HEADER(CDebugLog::DBG_FLT_CC_PARSER, _T("L21Buff::CheckControlCode"));
     
	if(IsTRorRTD(chFirst, chSecond))
		return L21_CONTROLCODE_TR_OR_RTD;

    if (IsPAC(chFirst, chSecond))
        return L21_CONTROLCODE_PAC ;
    
    if (IsMidRowCode(chFirst, chSecond))
        return L21_CONTROLCODE_MIDROW ;
    
    if (IsMiscControlCode(chFirst, chSecond))
        return L21_CONTROLCODE_MISCCONTROL ;
 
    if (IsSpecialChar(chFirst, chSecond))
		return L21_CONTROLCODE_SPECIAL ;
 
    return L21_CONTROLCODE_NOTCONTROL ;
}


// returns false on error (out of space or bad parity)

BOOL L21Buff::AddChar(char c)		// rather bogus, needs more work..
{
	DBG_HEADER(CDebugLog::DBG_FLT_CC_PARSER, _T("L21Buff::AddChar"));
	if(m_cChars >= kMaxLen)
	{
		TVEDebugLog((CDebugLog::DBG_FLT_CC_PARSER, 3, 
			_T("Buffer > %d chars long, dropping char (%c)"),kMaxLen,c));
#if 1
		TVEDebugLog((CDebugLog::DBG_SEV1, 1,				// avoid too may of these...
			_T("Buffer too long - restarting it.")));
		ClearBuff();
#endif
		return false;							// out of space
	}

	if(ValidParity(c)) 
	{		
		m_szBuff[m_cChars++] = c & 0x7f;
		m_szBuff[m_cChars]   = 0;				// null terminate...
		return true;
	} else {
		return false;							// bad parity is cause for failure
	}
}

// returns true at end of trigger...

BOOL L21Buff::ParseForTrigger()		// somewhat bogus, needs more work for channel filtering
{
	DBG_HEADER(CDebugLog::DBG_FLT_CC_PARSER, _T("L21Buff::ParseForTrigger"));

	if(m_cChars > 0)
	{
		char cZ = m_szBuff[m_cChars-1];			// last character.
		
							// if it's an '<', restart the whole trigger
		if(cZ == '<') {							// start of trigger
			ClearBuff();						// initialize bracket count, values
			m_fInsideOfTrigger = true;
			m_fInsideOfURL  = true;
			m_szBuff[0] = '<';						// re-add this one character..
			m_szBuff[1] = 0;
			m_cChars = 1;

			TVEDebugLog((CDebugLog::DBG_FLT_CC_PARSER, 3, _T("Trigger Start")));
			return false;
		}
		
		if(!m_fInsideOfTrigger)					// blow out if not parsing
		{
			m_cChars = 0; m_szBuff[0] = 0;
			return false;
		}

		if(cZ < 0x20 || cZ > 0x7e) {			// character out of range - ignore it
			m_cChars--;							// (This allows one to put <CR> into a trigger)
			m_szBuff[m_cChars] = 0;
			return false;
		}


		bool fError = false;
		switch(cZ) {
		case '>' : if(m_fInsideOfURL)  {
						if(m_fHadURL) fError = true;
						m_fInsideOfURL = false;
						m_fHadURL = true;
				   }
				   if(m_fHadBracket) fError = true;
				   break;

		case '[' : m_iBracketCount++; 
				   if(m_iBracketCount > 1) fError = true;
			       m_fMayBeAtEndOfTrigger = false;
				   m_fHadBracket = true;
				   break;
		case ']' : m_iBracketCount--; 
				   if(m_iBracketCount < 0) fError = true;
			       if(0 == m_iBracketCount && m_fHadURL && m_fHadBracket)
					  m_fMayBeAtEndOfTrigger = true;
			       break;
		default:
				   if(m_fMayBeAtEndOfTrigger)  // yep, really at end. (char not '<>[]').
				   {
					   if(cZ == ' ')			// allow extra spaces in between blocks..
						   break;

					    m_szBuff[m_cChars-1] = 0;						// womp the after end char (cZ)
						memcpy(m_szBuffTrig, m_szBuff, m_cChars);		// copy upward
						ClearBuff();									// clear current buffer
						AddChar(cZ);									// add this character in
						TVEDebugLog((CDebugLog::DBG_FLT_CC_PARSER, 3, 
							        _T("Trigger End : %s"), m_szBuffTrig));
						return true;									// YEAH! We found a trigger string!
				   } 
		}

						// fast end test - needed to locate end of trigger without waiting for post-trigger data		
		if(!fError && m_fMayBeAtEndOfTrigger)	// test for [XXXX] part of <>[...][...][XXXX] as end of trigger
		{									    //   and make as fast end
			if(m_cChars > 8 &&			// 6 bytes for [xxxx] and at least <>
				m_szBuff[m_cChars-6] == '[')
			{
				if( isxdigit(m_szBuff[m_cChars-5]) &&
					isxdigit(m_szBuff[m_cChars-4]) &&
					isxdigit(m_szBuff[m_cChars-3]) &&
					isxdigit(m_szBuff[m_cChars-2]))
				{
						memcpy(m_szBuffTrig, m_szBuff, m_cChars+1);		// copy upward
						ClearBuff();									// clear current buffer
						TVEDebugLog((CDebugLog::DBG_FLT_CC_PARSER, 3, 
							        _T("[XXXX] Trigger End : %s"), m_szBuffTrig));
						return true;									// YEAH! We found a trigger string!

				}
			}
		}
		if(fError) {
			TVEDebugLog((CDebugLog::DBG_FLT_CC_PARSER, 2,
					   _T("Parse error on last character : %s, aborting trigger"),m_szBuff));
			ClearBuff();
			return false;
		}
	}
	return false;							// not done yet...
}

//		d:\nt\multimedia\dshow\filters\lin21dec\l21decod.cpp
//		d:\nt\multimedia\dshow\filters\lin21dec\l21decod.h




bool L21Buff::SelectMode(BYTE ch1, BYTE ch2)
{
    if ( (ch1 == 0x1C)  &&					// T2 mode (ch1 == 0x14 => T1 mode)
         (ch2 == 0x2A || ch2 == 0x2B) )		// TR or RTD
    {
          m_fIsText2Mode = true ;
          return true ;
    }

    if ( ( (ch1 == 0x1C)  &&				// (ch1 = 0x14 => T1)
            ((ch2 >= 0x20 && ch2 <= 0x29) || 
			 (ch2 >= 0x2C && ch2 <= 0x2F)) ) ||		// RCL/BS/AOF/AON/DER/RU2-3-4/
 													// FON/RDC/EDM/CR/ENM/EOC
          ( (ch1 == 0x1F)  &&  // (ch1 = 0x17 => T1)
            (ch2 == 0x21 || ch2 == 0x22  ||  ch2 == 0x23))  )	// TO1/2/3
    {
          m_fIsText2Mode = false ;
          return true ;
    }

					// not a mode-changing byte-pair -- leave it as is.
    return false ;  // mode wasn't changed by this byte-pair
}


HRESULT L21Buff::ParseCCBytePair(DWORD dwMode, 
							   char cbFirst, char cbSecond, 
							   bool *pfDoneWithLine)
{
	DBG_HEADER(CDebugLog::DBG_FLT_CC_PARSER, _T("L21Buff::ParseCCBytePair"));
    TVEDebugLog((CDebugLog::DBG_FLT_CC_PARSER, 5, 
				TEXT("(0x%08x '%c'(0x%02x), '%c'(0x%02x)"),
				 dwMode, 
				 isprint(cbFirst&0x7f) ? cbFirst&0x7f :'?', (BYTE) cbFirst, 
				 isprint(cbSecond&0x7f)? cbSecond&0x7f:'?', (BYTE) cbSecond )) ; 

#ifdef _DEBUG
#if 0
	if(g_Log.m_fileLog)
	{
		static int n = 0;
		if(++n % 10 == 0)
			_ftprintf(g_Log.m_fileLog,_T("\n %6d : "),n/10);

		_ftprintf(g_Log.m_fileLog, _T("%c %c "),
					 isprint(cbFirst&0x7f) ? cbFirst&0x7f :'?',  
					 isprint(cbSecond&0x7f)? cbSecond&0x7f:'?' ) ;
	}
#endif
#endif

	*pfDoneWithLine = false;


	BOOL fDone = false;

				// quick way assuming CCDecoder filter is just giving us T2 data
	
	if ( AddChar(cbFirst) )	{	// AddChar strips parity...
		fDone =  ParseForTrigger();
	}

	if( AddChar(cbSecond) ) 
	{
		fDone |= ParseForTrigger();
	}
  						// parse buffer, checking if we got the end of the string...
	if(fDone) 
		*pfDoneWithLine = true;


				// slower more complicated not working way...
/*

	switch(CheckControlCode(cbFirst, cbSecond))
	{
	case L21_CONTROLCODE_TR_OR_RTD:		// (0x14|0x15|0x1C|0x1D):0x2A|0x2B	- T2 TR=(1C,1A) RTD=(1C,2B)
		break;
	case L21_CONTROLCODE_PAC:			// (0x10-0x17|0x18-0x1F):0x40-0x7f
		break;
    case L21_CONTROLCODE_MIDROW:		// (0x11|0x19):0x20-0x2f
		break;
    case L21_CONTROLCODE_MISCCONTROL:	// 0x21-0x23:0x17-0x1f | (0x14|0x15|0x1C|0x1D):0x20-0x2f
 		break;
	case L21_CONTROLCODE_SPECIAL:		// (0x11|0x19):0x30-0x3f
 		break;
	case L21_CONTROLCODE_NOTCONTROL:
       // If the 1st byte is in [0, F] then ignore 1st byte and print 2nd byte
        // as just a printable char
  
		if(m_fCCDecoderBugsExists)
		{
			if(SelectMode(cbFirst&0x7F, cbSecond&0x7F))
				break;					// if byte pair switched mode - done with it
		}
		if(!IsText2Mode())				// if not it T2 mode, break
			break;

 //     if (! ((cbFirst &0x7F) >= 0x0 && (cbFirst & 0x7F) <= 0xF) )
        {
            if ( AddChar(cbFirst) )	{	// AddChar strips parity...
				fDone =  ParseForTrigger();
				fResult |= true ;
			}
        }
        if( AddChar(cbSecond) ) 
		{
			fDone |= ParseForTrigger();
			fResult |= true;		// If one of the two bytes decode right, we take it as a success
		}

        m_bExpectRepeat = FALSE ;  // turn it off now
 		break;
	}
				// parse buffer, checking if we got the end of the string...
	if(fDone) 
		*pfDoneWithLine = true;
	
*/
	return S_OK;
}




BOOL L21Buff::ValidParity(BYTE ch)		// simple test method
{
#if 1
    ch ^= ch >> 4 ;
    ch ^= ch >> 2 ;
    return (0 != (0x01 & (ch ^ (ch >> 1)))) ;
#else
    return TRUE ;
#endif
}


HRESULT L21Buff::GetBuff(BSTR *pBstrBuff)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_FLT_CC_PARSER, _T("L21Buff::GetBuff"));
	CHECK_OUT_PARAM(pBstrBuff);

	try {

		CComBSTR bstrX(m_cChars+2);
		WCHAR *wBuff = bstrX.m_str;
		for(int i=0; i < m_cChars; i++)
		{
			wBuff[i] = m_szBuff[i];			// simple copy loop for now.to convert to Unicode
		}
		wBuff[m_cChars] = 0;

		TVEDebugLog((CDebugLog::DBG_FLT_CC_PARSER, 3, 
					 _T("%d chars: '%s'"),
					 m_cChars, wBuff));
		bstrX.CopyTo(pBstrBuff);
		return S_OK;

	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED; 
	}
	return hr;
}

HRESULT L21Buff::GetBuffTrig(BSTR *pBstrBuff)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_FLT_CC_PARSER, _T("L21Buff::GetBuffTrig"));
	CHECK_OUT_PARAM(pBstrBuff);
	try {
	
		int cChars = strlen(m_szBuffTrig);

		CComBSTR bstrX(cChars+2);
		WCHAR *wBuff = bstrX.m_str;

		for(int i=0; i < cChars; i++)
		{
			wBuff[i] = m_szBuffTrig[i];			// simple copy loop for now..
		}
		wBuff[cChars] = 0;

		TVEDebugLog((CDebugLog::DBG_FLT_CC_PARSER, 3, 
					 _T("%d chars: '%a'"),
					 cChars, wBuff));

		bstrX.CopyTo(pBstrBuff);
		return S_OK;
	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED; 
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvemcast.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEMCast.cpp : Implementation of CTVEMCast
#include "stdafx.h"
#include <stdio.h>

#include "MSTvE.h"
#include "TVEMCast.h"

#include "valid.h"
#include "TveDbg.h"
#include "DbgStuff.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

_COM_SMARTPTR_TYPEDEF(ITVEMCastManager,         __uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager_Helper,  __uuidof(ITVEMCastManager_Helper));

/////////////////////////////////////////////////////////////////////////////
// CTVEMCast

STDMETHODIMP CTVEMCast::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_ITVEMCast
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

HRESULT CTVEMCast::FinalConstruct()
{
    HRESULT hr;
    DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCast::FinalConstruct"));
    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_spUnkMarshaler.p);

    int whr;
    if (0 != (whr = WSAStartup(MAKEWORD(2, 0), &m_wsadata))) 
    {
        hr = HRESULT_FROM_WIN32(whr);
        return hr;
    }

    m_Port     = 0 ;
    m_socket   = INVALID_SOCKET ;
    m_pManager = NULL ;

    m_hStopEvent = CreateEvent (NULL, TRUE, FALSE, NULL) ;
    _ASSERTE (m_hStopEvent) ;

    m_hWorkerThread   = NULL ;
    m_dwMainThreadId  = 0;

    m_dwQueueThreadId = 0;

    m_cPackets = 0 ;
    m_cBytes = 0 ;

//  m_pstats        = pstats ;

    m_fSuspended = FALSE ;

    InitializeCriticalSection (&m_crt) ;

    m_fCountStats       = false;
    m_pstats            = NULL;
    m_hwndStatDetails   = NULL;
    m_hStatErrorLog     = NULL;
    m_hwndDumpDetail    = NULL;

    SET_STATE_DEFAULTS(&m_state) ;
    SET_SETTINGS_DEFAULTS(&m_settings) ;

    return hr;

}


void 
CTVEMCast::FinalRelease()
{
    DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCast::FinalRelease"));
    Leave () ;
   
    WSACleanup () ;
    
    CloseHandle (m_hStopEvent) ;
    
    delete [] m_bufferPool;

    DeleteCriticalSection (&m_crt) ;
    
    m_spUnkMarshaler.Release();

    return ;
}

STDMETHODIMP CTVEMCast::get_IPAdapter(BSTR *pVal)
{
    if(NULL == pVal) return E_POINTER;
    HRESULT hr = m_spbsNIC.CopyTo(pVal);
    return hr;
}

STDMETHODIMP CTVEMCast::put_IPAdapter(BSTR newVal)
{
    try{
        USES_CONVERSION;        // should check to see if valid IP adapter on this machine here.

        if(wcslen(newVal) < 7)          // can't be any shorter .
            return E_INVALIDARG;
        if(inet_addr (W2A(newVal)) == INADDR_NONE) 
            return E_INVALIDARG;
        m_spbsNIC = newVal; 
        return S_OK;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CTVEMCast::get_IPAddress(BSTR *pVal)
{
    if(NULL == pVal) return E_POINTER;
    HRESULT hr = m_spbsIP.CopyTo(pVal);
    return hr;
}

STDMETHODIMP CTVEMCast::put_IPAddress(BSTR newVal)
{
    try{
    USES_CONVERSION;
    ULONG ipAddr = inet_addr(W2A(newVal));
    if(ipAddr == INADDR_NONE) return E_INVALIDARG;
    if(0xE != ((ipAddr>>4) & 0xF)) return E_INVALIDARG;     // must be in 224 to 239 range
    m_spbsIP = newVal;
    return S_OK;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CTVEMCast::get_IPPort(long *pVal)
{
    if(NULL == pVal) return E_POINTER;

    *pVal = m_Port;
    return S_OK;
}

STDMETHODIMP CTVEMCast::put_IPPort(long newVal)
{
    if(newVal < 0 || newVal >= 65536) return E_INVALIDARG;

    m_Port = newVal;
    return S_OK;
}

STDMETHODIMP CTVEMCast::get_QueueThreadId(long *pVal)
{
    if(NULL == pVal) return E_POINTER;

    *pVal = (DWORD) m_dwQueueThreadId;
    return S_OK;
}


STDMETHODIMP CTVEMCast::put_QueueThreadId(long newVal)
{
#ifdef _DEBUG
    TCHAR tbuff[128];
    _stprintf(tbuff,L"CTVEMCast::put_QueueThreadId (0x%08x)",newVal);
    DBG_HEADER(CDebugLog::DBG_MCAST, tbuff);
#endif
    m_dwQueueThreadId = newVal;
    return S_OK;
}


STDMETHODIMP CTVEMCast::get_MainThreadId(long *pVal)
{
    if(NULL == pVal) return E_POINTER;

    *pVal = m_dwMainThreadId;
    return S_OK;
}
// --------------------------------------------------------------
// --------------------------------------------------------------------------


STDMETHODIMP CTVEMCast::get_IsSuspended(VARIANT_BOOL *pVal)
{
    if(NULL == pVal) return E_POINTER;

    *pVal = m_fSuspended ? VARIANT_TRUE : VARIANT_FALSE;;
    return S_OK;
}

STDMETHODIMP CTVEMCast::Suspend(VARIANT_BOOL fSuspend)
{
    DBG_HEADER(CDebugLog::DBG_MCAST, fSuspend ? _T("CTVEMCast::Suspend") : _T("CTVEMCast::(Un)Suspend"));
    m_fSuspended = fSuspend;
    return S_OK;
}

// if already joined, leaves and rejoins again, clearing any statistics.
STDMETHODIMP CTVEMCast::Join()
{
    DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCast::Join"));

    USES_CONVERSION;

    int     isize ;
    BOOL    t = TRUE ;
    DWORD   dwThreadId ;
    USHORT  usPort;

    if (FJoined ()) {
        Leave () ;
    }
    
    m_socket = WSASocket(AF_INET, 
                         SOCK_DGRAM, 
                         0, 
                         NULL, 
                         0, 
                         WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_OVERLAPPED) ;
    if (m_socket == INVALID_SOCKET) {
        goto JoinFail ;
    }
    
    ZeroMemory (&m_thisHostAddress, sizeof m_thisHostAddress) ;
    ZeroMemory (&m_McastAddress, sizeof m_McastAddress) ;

    isize = sizeof m_thisHostAddress ;
    if (WSAStringToAddress(W2T(m_spbsNIC), 
                           AF_INET, 
                           NULL, 
                           (SOCKADDR *) &m_thisHostAddress,
                           &isize)) {
        goto JoinFail ;
    }
    
//  if(1)  ((sockaddr *) &m_thisHostAddress)->sa_data = ADDR_ANY;

    usPort = (USHORT) m_Port;
    m_thisHostAddress.sin_port = htons(usPort) ;

    if (setsockopt(m_socket, 
                   SOL_SOCKET, 
                   SO_REUSEADDR, 
                   (char *)&t, 
                   sizeof(t)) == SOCKET_ERROR) {
        goto JoinFail ;
    }
    
    if (bind(m_socket, 
             (LPSOCKADDR) &m_thisHostAddress, 
             sizeof m_thisHostAddress) == SOCKET_ERROR) {
        goto JoinFail ;
    }
    
    isize = sizeof m_McastAddress ;
    if (WSAStringToAddress(W2T(m_spbsIP), 
                           AF_INET, 
                           NULL, 
                           (SOCKADDR *) &m_McastAddress, 
                           &isize)) {
        goto JoinFail ;
    }
    
    m_McastAddress.sin_port = 0 ;

    WSABUF calleeBuf;
    memset((void *) &calleeBuf, 0, sizeof(calleeBuf));
    calleeBuf.len = 0;
    calleeBuf.buf = 0;

    if (WSAJoinLeaf(m_socket, 
                    (SOCKADDR *) &m_McastAddress, 
                    sizeof m_McastAddress, 
                    NULL, 
                    &calleeBuf, 
                    NULL, 
                    NULL, 
                    JL_RECEIVER_ONLY) == INVALID_SOCKET) {
        goto JoinFail ;                    
    }

     
    m_cPackets = 0 ;
    m_cBytes = 0 ;

    ResetEvent (m_hStopEvent) ;

    m_hWorkerThread = CreateThread (NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE) workerThread,
                                    (LPVOID) this,
                                    NULL,
                                    &dwThreadId) ;
                                    
    if (!m_hWorkerThread) {
        Leave () ;
        return E_FAIL ;
    }
   
    if(DBG_FSET(CDebugLog::DBG_MCAST)) 
    {
        WCHAR wbuff[256];
        swprintf(wbuff,L"Joining MCast %s:%d on %s (Thread 0x%x - 0x%x)\n", 
            m_spbsIP, m_Port, m_spbsNIC, m_hWorkerThread, dwThreadId);
        DBG_WARN(CDebugLog::DBG_MCAST, W2T(wbuff));
    }

        
    setWorkerThreadPriority_ (-1) ;
    
    return S_OK;
    
 JoinFail :
    int ierr = WSAGetLastError();     
    if (m_socket != INVALID_SOCKET) {
        closesocket(m_socket) ;
        m_socket = INVALID_SOCKET ;
    }
    return HRESULT_FROM_WIN32(ierr);
}

STDMETHODIMP CTVEMCast::Leave()
{
    DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCast::Leave"));
    HRESULT hr = S_OK;
    if (m_hWorkerThread) {

        if(DBG_FSET(CDebugLog::DBG_MCAST)) 
        {
            USES_CONVERSION;
            WCHAR wbuff[256];
            swprintf(wbuff,L"\t\t - 0x%08x Leaving MCast %s:%d on %s (Thread 0x%x)\n", 
                this, m_spbsIP, m_Port, m_spbsNIC, m_hWorkerThread);
            DBG_WARN(CDebugLog::DBG_MCAST, W2T(wbuff));
        }

        Suspend(VARIANT_TRUE);              // to avoid processing any further messages...

        SetEvent (m_hStopEvent) ;
        WaitForSingleObject (m_hWorkerThread, INFINITE) ;
        CloseHandle (m_hWorkerThread) ;
        m_hWorkerThread = NULL ;
    }
    
    if (m_socket != INVALID_SOCKET) {
        closesocket (m_socket) ;
        m_socket = INVALID_SOCKET ;
    }
    
    return hr;
}

STDMETHODIMP CTVEMCast::get_IsJoined(VARIANT_BOOL *pVal)
{
    *pVal = (m_socket != INVALID_SOCKET) ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

// -------------------------------------------------------------------
// -------------------------------------------------------------------
void 
CTVEMCast::workerThread (CTVEMCast *pcontext)
{
    _ASSERT(pcontext) ;
    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    pcontext -> workerThreadBody () ;
    
    return ;
}

void 
CTVEMCast::workerThreadBody ()
{
    DWORD retval ;
    DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCast::workerThreadBody"));
   
    for (int k = 0; k < m_cBuffer_Pool_Size; k++) {
        
        ZeroMemory (&m_bufferPool[k], sizeof ASYNC_READ_BUFFER) ;
        m_bufferPool[k].index = k ;
        issueRead_ (&m_bufferPool[k]) ;
    }
    
    for (;;) {
        
        retval = WaitForSingleObjectEx (m_hStopEvent, CYCLE_MILLIS, TRUE) ;
        
        if (retval == WAIT_OBJECT_0) {
            break ;
        }
        else if (retval == WAIT_TIMEOUT) {
            for (INT i = 0; i < m_cBuffer_Pool_Size; i++) {
                if (!m_bufferPool[i].fReadPending) {
                    issueRead_ (&m_bufferPool[i]) ;
                }
            }
        }
        else if (retval == WAIT_IO_COMPLETION) {
            // cool !!
        }
        else {
            break ;
        }
    }
    
    ExitThread (0) ;
    
    return ;
}

void 
CTVEMCast::process (ASYNC_READ_BUFFER *pbuffer)
{
    HRESULT hr = S_OK;
    DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCast::process"));
   _ASSERTE (pbuffer -> fReadPending) ;
    pbuffer -> fReadPending = FALSE ;
    
    TVEDebugLog((CDebugLog::DBG_MCAST, 3,
                L"\t\t - 0x%08x - Processing %d byte MCast Buffer %s:%d on %s (Thread 0x%x)\n", 
                this, pbuffer->bytes_read, m_spbsIP, m_Port, m_spbsNIC, m_hWorkerThread));


    ITVEMCastManagerPtr spManager;
        
    if (!m_fSuspended) 
    {
//      CSmartLock spLock(&m_sLk, WriteLock);   // MCasts shouldn't need locking - they run on their own threads
        if(NULL == m_pManager)
        {
            _ASSERT(false);                     // totally unexpected - MCast not setup correctly
            return;
        }

       spManager = m_pManager ;
    
        m_cPackets++ ;
        m_cBytes += pbuffer->bytes_read;
//        spLock->ConvertToRead();
        

    //  if(m_spMCastCallback)
    //      m_spMCastCallback->ProcessPacket((BYTE *) pbuffer -> buffer, pbuffer -> bytes_read);
                            

        if(DBG_FSET(CDebugLog::DBG_UHTTPPACKET))
        {
            spManager->Lock_();                             // lock here to avoid
            TVEDebugLog((CDebugLog::DBG_UHTTPPACKET, 5,
                        _T("CTVEMCast::process -- %s:%-5d - Packet(%d) %d Bytes %d Total"),
                        m_spbsIP, m_Port, m_cPackets, pbuffer->bytes_read, m_cBytes));          
            spManager->Unlock_();
        }
        
                            // Post packet to serialize it's processing on the QueueThread
        ITVEMCastManager_HelperPtr spManagerHelper(spManager);
        spManagerHelper->PostToQueueThread(WM_TVEPACKET_EVENT, (LPARAM) this, (LPARAM) pbuffer);  
    }
                            // put buffer back in the pool
    issueRead_ (pbuffer) ;
    
    // do some sort of cleanup here .. such as checking if there are any ASYNC_READ_BUFFERS
    //  reads not pending
    
    return ;
}    

void CALLBACK 
CTVEMCast::AsyncReadCallback (DWORD error, DWORD bytes_xfer, LPWSAOVERLAPPED overlapped, DWORD flags)
{
//  DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCast::AsyncReadCallback"));
    _ASSERTE (overlapped -> hEvent) ;
    
    ASYNC_READ_BUFFER *pasyncbuffer = (ASYNC_READ_BUFFER *) overlapped -> hEvent ;
    pasyncbuffer -> bytes_read = bytes_xfer ;
    pasyncbuffer -> pcontext -> process (pasyncbuffer) ;
    
    return ;
}

DWORD CTVEMCast::issueRead_ (ASYNC_READ_BUFFER *pbuffer)
{
//  DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCast::issueRead_"));
    _ASSERTE (pbuffer) ;
    _ASSERTE (!pbuffer -> fReadPending) ;
    
    DWORD retval ;
    WSABUF wsabuf ;
    
    wsabuf.buf = pbuffer -> buffer ;
    wsabuf.len = sizeof pbuffer -> buffer ;
    
    pbuffer -> overlapped.Offset       = 0 ;
    pbuffer -> overlapped.OffsetHigh   = 0 ;
    pbuffer -> overlapped.hEvent       = (HANDLE) pbuffer ;
    
    pbuffer -> flags = 0 ;
    
    pbuffer -> pcontext = this ;
        
    retval = WSARecvFrom (m_socket,
                         &wsabuf,
                         1,
                         &pbuffer -> bytes_read,
                         &pbuffer -> flags,
                         NULL,
                         NULL,
                         &pbuffer -> overlapped, 
                         AsyncReadCallback) ;

    if (retval == SOCKET_ERROR) {
        retval = WSAGetLastError () ;
        
        switch (retval) {
        case    WSA_IO_PENDING:
            pbuffer -> fReadPending = TRUE ;
            return retval ;

        default:
            // huh ??
            ;
        }
    }
    else if (retval == 0) {
        pbuffer -> fReadPending = TRUE ;
        retval = WSA_IO_PENDING ;
        return retval ;
    }
    
    return 0 ;
}    


void 
CTVEMCast::setWorkerThreadPriority_ (int iPrioritySetback)  //  iPrioritySetback typically -1 (THREAD_PRIORITY_BELOW_NORMAL)
{
    _ASSERTE (m_hWorkerThread) ;
    _ASSERTE(iPrioritySetback <= 0);        // probably a mistake if making larger..
    
    // we know that this means this thread will be called upon to perform
    //  UI work, so we down the priority of the thread - it is possible
    //  otherwise to get an unresponsive UI in high bandwidth situations
    
//    SuspendThread (m_hWorkerThread) ;
    SetThreadPriority (m_hWorkerThread, iPrioritySetback) ;
//    ResumeThread (m_hWorkerThread) ;
}


// -------------------------------------------------------------
// -------------------------------------------------------------
void CTVEMCast::setStatCounter (CCountupStats *pstats) 
{ 
    lock_ () ;
    m_pstats = pstats ; 
    unlock_ () ; 
}

STDMETHODIMP CTVEMCast::get_PacketCount(long *pVal)
{
    if(NULL == pVal) return E_POINTER;
    *pVal = m_cPackets;
    return S_OK;
}

STDMETHODIMP CTVEMCast::get_ByteCount(long *pVal)
{
    if(NULL == pVal) return E_POINTER;
    *pVal = m_cBytes;
    return S_OK;
}

STDMETHODIMP CTVEMCast::KeepStats(VARIANT_BOOL fKeepStats)
{
    m_fCountStats = fKeepStats;
    return S_OK;
}

STDMETHODIMP CTVEMCast::ResetStats()
{
    m_cPackets = 0 ;
    m_cBytes = 0;
    return S_OK;
}


// -------------------------------------------------------------------------------

STDMETHODIMP CTVEMCast::get_Manager(IUnknown **ppVal)           
{
    if(!ppVal) return E_POINTER;

    if(m_pManager)
        return m_pManager->QueryInterface(ppVal);                   // does addref here

    return E_FAIL;
}

STDMETHODIMP CTVEMCast::ConnectManager(ITVEMCastManager *pManager)      // doesn't addref (back pointer)
{
    if(!pManager) return E_POINTER;

    m_pManager = pManager;          // avoid addref here
    return S_OK;
}

// ----------------------------------------------------------------------
// --------------------------------------------------------------------------
void TVEDefaultDumpCallback (char * pachBuffer, int ilen, CTVEMCast * pMCast, HWND hwnd)
{
 //   _ASSERTE (psession) ;
 //   _ASSERTE (pachBuffer) ;
 //   _ASSERTE (hwnd) ;

    HRESULT hr;
    USES_CONVERSION;

    static const int ilinelength = 16 ;
    static int ilines ;
    static int i, k, j, index ;
    static DWORD *pdw ;
    
    static const int LENGTH_OFFSET      = 12 ;      // "0x012345:   "
    static const int LENGTH_BYTEHEXVAL  = 3 ;       // "xx-"
    static const int LENGTH_DWORDHEXVAL = 9 ;       // "01234567-"
    
    WCHAR *pwach;
    
    ilines = ilen / ilinelength + (ilen % ilinelength ? 1 : 0) ;
    pdw = (DWORD *) pachBuffer ;

    IUnknownPtr spUnk;
    hr = pMCast->get_Manager(&spUnk);
    if(FAILED(hr))
        return;

    ITVEMCastManagerPtr spMCM(spUnk);
    ITVEMCastManager_HelperPtr  spMCM_H(spUnk);
    if(NULL == spMCM)
        return;

    spMCM->Lock_();


                // dummy callback
    WCHAR wBuff[256];
    swprintf(wBuff,L"IP: %s:%d - Packet(%d) %d Bytes\n",pMCast->m_spbsIP,pMCast->m_Port,pMCast->m_cPackets, ilen);
    ATLTRACE("%s",wBuff);


    spMCM_H->DumpString(wBuff);

    for (i = 0; i < ilines; i++) {
        pwach = wBuff;
        swprintf(pwach, L"%08x:   ", i * ilinelength) ;
        pwach += LENGTH_OFFSET ;
            
        if (pMCast->m_settings.detailType == DETAIL_TYPE_RAWDUMP_DWORDS) 
        {
            for (k = 0, j = i * ilinelength / sizeof(DWORD); 
                 k < ilinelength; j++, k += sizeof(DWORD)) 
            {
                index = i * ilinelength + k ;
                
                if (index < ilen) {
                
                    swprintf(pwach, L"%08x%c", pdw[j], (k == (ilinelength >> 1) - 1 ? '-' : ' ')) ;
                    pwach += LENGTH_DWORDHEXVAL ;
                    
                }
                else {
                
                    swprintf(pwach, L"         ") ;
                    pwach += LENGTH_DWORDHEXVAL ;
                }
            }
        } else {
            for (k = 0; k < ilinelength; k++) {
                index = i * ilinelength + k ;
                if (index < ilen) {
                
                    swprintf(pwach, L"%02x%c", 0x000000ff & pachBuffer[index], (k == (ilinelength >> 1) - 1 ? __T('-') : __T(' '))) ;
                    pwach += LENGTH_BYTEHEXVAL ;
                }
                else {
                
                    swprintf(pwach, L"   ") ;
                    pwach += LENGTH_BYTEHEXVAL ;
                }
            }
        }
            
        // separator from hex values to character values
        swprintf(pwach,L"  ") ;
        pwach += 2 ;
        
        // dump characters
        for (k = 0; k < ilinelength; k++) {
            index = i * ilinelength + k ;
            if ((i * ilinelength) + k < ilen) {
            
                swprintf(pwach, L"%c", (isalnum(pachBuffer[index]) ? pachBuffer[index] : '.')) ;
                pwach++ ;
            }
            else {
                break ;
            }
        }
            
        *pwach++ = '\n';
        *pwach = '\0' ;

        spMCM_H->DumpString(wBuff);
    }       // end of I loop
    spMCM->Unlock_();

    return ;
}

// -------------------------------------------
//  sets the PacketRead callback function object.
//    cBuffers is number of read-buffers to put down.  Good value is around 5, or perhaps 10 for data.
//    If 0, uses the current or default (5) value.
//    iPrioritySetback is how much to setback the worker thread priority.  Good value is -1.
//    pICallBack must ether be NULL, or support ITVEMCastCallback.
//    Else it will return E_NOINTERFACE.
//    
STDMETHODIMP 
CTVEMCast::SetReadCallback(int cBuffers, int iPrioritySetback, IUnknown *pICallBack)
{
    DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCast::SetReadCallback"));
    if(iPrioritySetback > THREAD_BASE_PRIORITY_MAX || iPrioritySetback < THREAD_BASE_PRIORITY_MIN)
        return E_INVALIDARG;

    lock_ () ;  
    
    if(0 == cBuffers) 
        cBuffers = m_cBuffer_Pool_Size;
//  if(0 == cBuffers)
//      cBuffers = 5;                           // paranoia case...

    if(NULL != m_bufferPool &&                  // if changed number buffers, or numm buffers, 
        m_cBuffer_Pool_Size != cBuffers)        //   need to realloc them...
    {
        delete[] m_bufferPool;
        m_bufferPool = NULL;
    }

    if(NULL == m_bufferPool && cBuffers != 0) 
    {
        m_bufferPool = (ASYNC_READ_BUFFER*) new ASYNC_READ_BUFFER[cBuffers];
        if(NULL == m_bufferPool)
            return E_OUTOFMEMORY;
        m_cBuffer_Pool_Size = cBuffers;
    }

    if(NULL == pICallBack) 
    {
 //       _ASSERT(false);                         // Don't do this - probably a bug unless
        m_spMCastCallback = NULL;               //   can make sure no messages with this MCast in the QueueThread
    } else {
        m_spMCastCallback = NULL;
        ITVEMCastCallbackPtr spCB(pICallBack);
        if(NULL == spCB) 
            return E_NOINTERFACE;
        m_spMCastCallback = spCB;
    
        m_spMCastCallback->SetMCast(this);
    }

    if(FJoined())                           // drop thread priority downward..
        setWorkerThreadPriority_(iPrioritySetback) ;

    unlock_ () ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvemcasts.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEMCasts.cpp : Implementation of CTVEMCasts
#include "stdafx.h"
#include "MSTvE.h"
#include "TVEMCasts.h"

/////////////////////////////////////////////////////////////////////////////
// CTVEMCasts
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

STDMETHODIMP CTVEMCasts::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVEMCasts
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvemcasts.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEMCasts.h : Declaration of the CTVEMCasts

#ifndef __TVEMCASTS_H_
#define __TVEMCASTS_H_

#include "resource.h"       // main symbols
#include "TVECollect.h"

/////////////////////////////////////////////////////////////////////////////
// CTVEMCasts
class ATL_NO_VTABLE CTVEMCasts : public TVECollection<ITVEMCast, ITVEMCasts>,
	public ISupportErrorInfo
{
public:

	DECLARE_REGISTRY_RESOURCEID(IDR_TVEMCASTS)
	DECLARE_PROTECT_FINAL_CONSTRUCT()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ITVEMCasts
public:
};

#endif //__TVEMCASTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvemcast.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
    
// TVEMCast.h : Declaration of the CTVEMCast

#ifndef __TVEMCAST_H_
#define __TVEMCAST_H_

#include "resource.h"       // main symbols
#include "TveDbg.h"

_COM_SMARTPTR_TYPEDEF(ITVEMCastCallback, __uuidof(ITVEMCastCallback));

////////////////////////////////////////////////////////////////////////////
#define STATS_UPDATE_MILLIS     1000
#define MAX_BUFFERLINES         1000        // (not used?)
////////////////////////////////////////////////////////////////////////////
// forward declarations

class CNIC ;
class CBitfield ;
class CNodeList ;
class CTVEMCastManager;

class CCountupStats         // bogus struct - need to fill in...
{
};

// -----------------------------------------

typedef struct _MCAST_STATE {
    DWORD   fJoined             : 1,
            fDetail             : 1,
            fStatDetail         : 1 ;
} MCAST_STATE ;

inline void UPDATE_STATE_ICON (MCAST_STATE * pstate, int row) {};       // do nothing...

inline void SET_STATE_JOINED (MCAST_STATE *pstate, BOOL f, int row = -1) { pstate -> fJoined = f ? 1 : 0 ; UPDATE_STATE_ICON (pstate, row) ; }
inline void SET_STATE_DETAIL_ON (MCAST_STATE *pstate, BOOL f, int row = -1) { pstate -> fDetail = f ? 1 : 0 ; UPDATE_STATE_ICON (pstate, row) ; }
inline void SET_STATE_STAT_DETAIL_ON (MCAST_STATE *pstate, BOOL f = TRUE) { pstate -> fStatDetail = f ? 1 : 0 ; }

inline BOOL JOINED (MCAST_STATE *pstate) { return pstate -> fJoined == 1 ? TRUE : FALSE ; }
inline BOOL DETAILED (MCAST_STATE *pstate) { return pstate -> fDetail == 1 ? TRUE : FALSE ; }
inline BOOL DETAILED_STATS (MCAST_STATE *pstate) { return pstate -> fStatDetail == 1 ? TRUE : FALSE ; }

inline void SET_STATE_DEFAULTS (MCAST_STATE *pstate) 
{
    ZeroMemory (pstate, sizeof MCAST_STATE) ;
    
    SET_STATE_JOINED (pstate, FALSE) ;
    SET_STATE_DETAIL_ON (pstate, FALSE) ;
}

// --------------------------------------------

typedef struct _MCAST_SETTINGS {
    DWORD   statCycleMillis ;
    DWORD   bufferLines ;
    DWORD   detailType ;
    BOOL    fStats ;
    BOOL    fStatErrorLog ;
} MCAST_SETTINGS ;

// indeces into our image list for icon states (not really used)
enum {
    JOINED_ICON_INDEX,
    DETAILED_ICON_INDEX,
    JOINED_AND_DETAILED_ICON_INDEX
} ;

// type of dump to display
enum {
    DETAIL_TYPE_RAWDUMP_BYTES,
    DETAIL_TYPE_RAWDUMP_DWORDS
} ;

inline void SET_SETTINGS_DEFAULTS (MCAST_SETTINGS *psettings)
{
    psettings -> statCycleMillis    = STATS_UPDATE_MILLIS ;
    psettings -> bufferLines        = MAX_BUFFERLINES ;
    psettings -> detailType         = DETAIL_TYPE_RAWDUMP_BYTES ;
    psettings -> fStats             = FALSE ;
    psettings -> fStatErrorLog      = FALSE ;
}


/*
    struct name: root struct for list manipulation methods of data nodes
    
    description:
    
    3/11/98
*/                


_COM_SMARTPTR_TYPEDEF(ITVEMCast, __uuidof(ITVEMCast));

/*
typedef struct _MCAST_SESSION {
    ITVEMCastPtr    m_spMCast ;
    CCountupStats * m_pstats ;
    MCAST_SETTINGS  settings ;
    MCAST_STATE     state ;
    HWND            hwndStatDetails ;
    HANDLE          hStatErrorLog ;
    HWND            hwndDumpDetail ;
} MCAST_SESSION ;
*/
/////////////////////////////////////////////////////////////////////////
#define BUFFER_SIZE 4096            // probably too big... (by factor of 4?)

class CTVEMCast;                // forward declaration...

typedef struct _ASYNC_READ_BUFFER {
    CTVEMCast      *pcontext ;
    int         index ;
    char        buffer[BUFFER_SIZE] ;
    OVERLAPPED  overlapped ;
    DWORD       bytes_read ;
    DWORD       flags ;
    BOOL        fReadPending ;
} ASYNC_READ_BUFFER ;



/////////////////////////////////////////////////////////////////////////////
// CTVEMCast
class ATL_NO_VTABLE CTVEMCast : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CTVEMCast, &CLSID_TVEMCast>,
    public ISupportErrorInfo,
    public IDispatchImpl<ITVEMCast, &IID_ITVEMCast, &LIBID_MSTvELib>
{
public:
    CTVEMCast()
    {
        m_bufferPool        = NULL;
        m_cBuffer_Pool_Size = 5;            // default value...
        m_whatType          = NWHAT_Other;
    }

    ~CTVEMCast()
    {
        DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCast::~CTVEMCast"));
    }

DECLARE_REGISTRY_RESOURCEID(IDR_TVEMCAST)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVEMCast)
    COM_INTERFACE_ENTRY(ITVEMCast)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct();
    void FinalRelease();

    CComPtr<IUnknown> m_spUnkMarshaler;

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ITVEMCast
public:

   enum {
        CYCLE_MILLIS = 250                              // workerThreadBody timeout 
    } ;
    
    int                 m_cBuffer_Pool_Size;
    CComBSTR            m_spbsIP ;
    CComBSTR            m_spbsNIC ;
    long                m_Port ;
    WSADATA             m_wsadata ;
    SOCKET              m_socket ;                      // INVALID_SOCKET if not joined
    SOCKADDR_IN         m_thisHostAddress ;
    SOCKADDR_IN         m_McastAddress ;
    ASYNC_READ_BUFFER   *m_bufferPool ;
    HANDLE              m_hStopEvent;
 
    DWORD               m_dwQueueThreadId;              // Thread used to queue up/process all packets
  
    DWORD               m_dwMainThreadId;               // Supervisor Thread 
    HANDLE              m_hWorkerThread ;               // this thread

    CRITICAL_SECTION    m_crt ;
    BOOL                m_fSuspended ;

    ITVEMCastCallbackPtr    m_spMCastCallback;  

    ITVEMCastManager *  m_pManager ;
  
                // stats...
    BOOL                m_fCountStats ;
    DWORD               m_cPackets ;                // number of packets read...
    DWORD               m_cBytes ;                  // number of Bytes read...
    CCountupStats     * m_pstats ;          // not really used (for testing with wSend???)
    NWHAT_Mode          m_whatType;

    MCAST_SETTINGS      m_settings ;
    MCAST_STATE         m_state ;
    HWND                m_hwndStatDetails ;
    HANDLE              m_hStatErrorLog ;
    HWND                m_hwndDumpDetail ;

    DWORD issueRead_ (ASYNC_READ_BUFFER *) ;
    void lock_ ()       { EnterCriticalSection (&m_crt) ; }
    void unlock_ ()     { LeaveCriticalSection (&m_crt) ; }

    void setWorkerThreadPriority_ (int iPrioritySetback) ;          // lower priority, iPrioritySetback typically -1
    BOOL FJoined()    {VARIANT_BOOL vbf; get_IsJoined(&vbf); return vbf == VARIANT_TRUE ? true : false;}    
    BOOL FSuspended() {VARIANT_BOOL vbf; get_IsSuspended(&vbf); return vbf == VARIANT_TRUE ? true : false;} 

    // P U B L I C
    
    public :
        STDMETHOD(Join)();
        STDMETHOD(get_IsJoined)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    //    BOOL join (TCHAR *, USHORT ) ;

        STDMETHOD(Leave)();

        STDMETHOD(Suspend)(VARIANT_BOOL fSuspend);
        STDMETHOD(get_IsSuspended)(/*[out, retval]*/ VARIANT_BOOL *pVal);

        STDMETHOD(get_IPPort)(/*[out, retval]*/ long *pVal);
        STDMETHOD(put_IPPort)(/*[in]*/ long newVal);
        STDMETHOD(get_IPAddress)(/*[out, retval]*/ BSTR *pVal);
        STDMETHOD(put_IPAddress)(/*[in]*/ BSTR newVal);
        STDMETHOD(get_IPAdapter)(/*[out, retval]*/ BSTR *pVal);
        STDMETHOD(put_IPAdapter)(/*[in]*/ BSTR newVal);
        STDMETHOD(put_WhatType)(/*[out, retval]*/ NWHAT_Mode whatType)      {m_whatType = whatType; return S_OK;}       
        STDMETHOD(get_WhatType)(/*[out, retval]*/ NWHAT_Mode *pWhatType)    {if(pWhatType) *pWhatType=m_whatType; return S_OK;}     

        STDMETHOD(SetReadCallback)(/*in*/ int cBuffers, /*in*/ int iPrioritySetback, /*[in]*/ IUnknown *pVal);      // # read buffers(5), pUnk of read callback

        STDMETHOD(get_Manager)(/*[out, retval]*/ IUnknown* *ppVal);
        STDMETHOD(ConnectManager)(/*[in]*/ ITVEMCastManager* newVal);

        STDMETHOD(KeepStats)(VARIANT_BOOL fKeepStats);                          // turn stats on/off
        STDMETHOD(ResetStats)();                                        // reset counters back to zero
        STDMETHOD(get_PacketCount)(/*[out, retval]*/ long *pVal);
        STDMETHOD(get_ByteCount)(/*[out, retval]*/ long *pVal);     
        
        STDMETHOD(get_QueueThreadId)(/*[out, retval]*/ long* pVal);
        STDMETHOD(put_QueueThreadId)(/*[int]*/ long newVal);
        STDMETHOD(get_MainThreadId)(/*[out, retval]*/ long* pVal);

        virtual void process(ASYNC_READ_BUFFER *) ;
                

  protected:    
        void workerThreadBody () ;
         
        void setStatCounter (CCountupStats *pstats) ;    
        
        static void workerThread(CTVEMCast *pcontext) ;
        static void CALLBACK AsyncReadCallback(DWORD error, DWORD bytes_xfer, LPWSAOVERLAPPED overlapped, DWORD flags) ;
  };

#endif //__TVEMCAST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvemccback.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------
//   TVEMCCback.cpp : Implementation of CTVEMCastCallback
//
//	This is base implementation class for TVE Multicast callbacks.
//	The idea is to inherit off this class for each type of multicast
//	data parser that needs to be written.
//
//	
//	The primary method to implement is 
//		ProcessPacket(char *pchBuffer, int cBytes)
//	This method is called for every packet is received.	
//
//	An interface to CTVEMCast object, describing the multicast object being
//	read (it's IP address, port, number of packets read, ...) may
//  be accessed through the:
//		GetMCast(ITVEMCast **ppIMCast)  method,
//	A pointer to the actual object may be accessed though the:
//		m_pcMCast   member variable.
//
//	To use this, 
//		- create a class that inherits from CTVEMCastCallback
//		  and supports the ITVEMCastCallback interface.
//		- add any member variables as you see fit, and some init function.
//		- write the ProcessPacket method
//	
//	
//	The actual callback is invoked from inside of:
//		CTVEMCast::process().
//	This function is called via the 
//		CTVEMCast::AsyncReadCallback() method
//	which is called via the call to WSARecvFrom() in CTVEMCast::issueRead()
//
//			(probably should simplify this a bit, shouldn't I?)
//		
//	
// ------------------------------------------------------------------
#include "stdafx.h"
#include "MSTvE.h"

#include "TVEMCast.h"
#include "TVEMCCback.h"

_COM_SMARTPTR_TYPEDEF(ITVEMCast, __uuidof(ITVEMCast));
_COM_SMARTPTR_TYPEDEF(ITVEMCasts, __uuidof(ITVEMCasts));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager, __uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCastCallback, __uuidof(ITVEMCastCallback));

/////////////////////////////////////////////////////////////////////////////
// CTVEMCastCallback

STDMETHODIMP CTVEMCastCallback::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVEMCastCallback
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CTVEMCastCallback::FinalConstruct()
{
 	DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCastCallback::FinalConstruct"));
	m_pcMCast = NULL;
	return S_OK;
}

HRESULT CTVEMCastCallback::FinalRelease()
{
 	DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCastCallback::FinalRelease"));
	m_pcMCast = NULL;
	return S_OK;
}

// PostPacket
// Ships the packet over to be processed in the Queue thread
//		should be called in each of the receiver threads.
// note receiver must call SysFreeString to free the data packet

HRESULT 
CTVEMCastCallback::PostPacket(unsigned char *pchBuffer,  long cBytes, long wPacketId)		// post the message on the main thread...
{
 	DBG_HEADER(CDebugLog::DBG_MCAST, _T("CTVEMCastCallback::PostPacket"));
    
    DWORD dwQueueThreadId;
	_ASSERT(NULL != m_pcMCast);

	HRESULT hr = m_pcMCast->get_QueueThreadId((long *) &dwQueueThreadId);
	if(FAILED(hr))
		return hr;

	_ASSERTE(NULL != dwQueueThreadId);			// oops, forgot to create this thread in MCastManager...
	// -------
	char *szBuff = (char *) CoTaskMemAlloc(cBytes+sizeof(CPacketHeader));	
	if(NULL == szBuff)
		return E_OUTOFMEMORY;

	CPacketHeader *pcph = (CPacketHeader *) szBuff;
	pcph->m_cbHeader   = sizeof(CPacketHeader);
	pcph->m_dwPacketId = (DWORD) wPacketId;
	pcph->m_cbData	   = cBytes;

	memcpy((void *) (szBuff+sizeof(CPacketHeader)), (void *) pchBuffer, cBytes);  // copy data to this new buffer

	TVEDebugLog((CDebugLog::DBG_MCAST, 3,
                L"\t\t - 0x%08x - Posting %d byte Buffer, ID %d to MCast 0x%08x on Thread 0x%08x\n", 
			    this, cBytes, wPacketId, m_pcMCast, dwQueueThreadId));

												// goes to CTVEMCastManager::queueThreadBody()
// was	return PostThreadMessage(dwQueueThreadId, WM_TVEPACKET_EVENT, (WPARAM) this, (LPARAM) szBuff);

    return PostThreadMessage(dwQueueThreadId, WM_TVEPACKET_EVENT, (WPARAM) m_pcMCast, (LPARAM) szBuff) ? S_OK : E_FAIL;
}


/*
STDMETHODIMP CTVEMCastCallback::ProcessPacket(unsigned char *pchBuffer, long cBytes, long lPacketId)
{
    HRESULT hr;
	USES_CONVERSION;

 	WCHAR wBuff[256];

	IUnknownPtr spUnk;
	hr = m_pcMCast->get_Manager(&spUnk);
	if(FAILED(hr))
		return hr;

	ITVEMCastManagerPtr spMCM(spUnk);
	if(NULL == spMCM)
		return E_NOINTERFACE;

//	spMCM->Lock();

	if(DBG_FSET(CDebugLog::DBG_UHTTPPACKET)))
	{
		swprintf(wBuff,L"CB: %s:%d - Packet(%d) %d Bytes\n",
			m_pcMCast->m_spbsIP, m_pcMCast->m_Port, m_pcMCast->m_cPackets, cBytes);
		m_pManager->Lock_();
		DBG_HEADER(CDebugLog::DBG_UHTTPPACKET, W2A(wBuff));
		m_pManager->Unlock_();
	}

//	spMCM->DumpString(wBuff);
//	spMCM->UnLock();

	return S_OK;
}
*/
HRESULT CTVEMCastCallback::GetMCast(ITVEMCast **ppMCast)
{
	*ppMCast = NULL;
	if(NULL == ppMCast) return E_POINTER;
	if(NULL == m_pcMCast) return E_FAIL;
	ITVEMCast *pmCast = (ITVEMCast *)  m_pcMCast;		// NASTY CAST - but should work!
	pmCast->AddRef();
	*ppMCast = pmCast;
	return S_OK;
}


HRESULT CTVEMCastCallback::SetMCast(ITVEMCast *pIMCast)
{
	if(NULL == pIMCast)
		return E_INVALIDARG;
//	ITVEMCastPtr spMCast(pIMCast);
	m_pcMCast = static_cast<CTVEMCast *>(pIMCast);
//	m_spIMCast = pIMCast;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvemcmng.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEMCMng.h : Declaration of the CTVEMCastManager

#ifndef __TVEMCASTMANAGER_H_
#define __TVEMCASTMANAGER_H_

#include "resource.h"       // main symbols
#include "MSTvE.h"
#include "TVESmartLock.h"

_COM_SMARTPTR_TYPEDEF(ITVEMCasts, __uuidof(ITVEMCasts));

/////////////////////////////////////////////////////////////////////////////
// CTVEMCastManager
class ATL_NO_VTABLE CTVEMCastManager : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CTVEMCastManager, &CLSID_TVEMCastManager>,
    public ISupportErrorInfo,
    public ITVEMCastManager_Helper,
    public IDispatchImpl<ITVEMCastManager, &IID_ITVEMCastManager, &LIBID_MSTvELib>
{
public:
    CTVEMCastManager()
    {
        m_dwSuperGITProxyCookie     = 0;
        m_dwGrfHaltFlags            = 0;
        m_cTimerCount               = 0;
        m_cExternalInterfaceLocks   = 0;
        m_dwQueueThreadId           = 0;
        m_hQueueThread              = 0;
        m_hQueueThreadAliveEvent    = NULL;
        m_hKillMCastEvent           = NULL;
        m_idExpireTimer             = 0;
        m_pTveSuper                 = NULL;
        m_cPackets                  = 0;
        m_cPacketsDropped           = 0;
        m_cPacketsDroppedTotal      = 0;
        m_cQueueMessages            = 0;
        m_cQueueSize                = 0;
        m_kQueueMaxSize             = MAX_QUEUE_TREAD_MESSAGES;
        m_fQueueThreadSizeExceeded  = false;    
    }


DECLARE_REGISTRY_RESOURCEID(IDR_TVEMCASTMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

    HRESULT FinalConstruct();                       // create internal objects
    HRESULT FinalRelease();

BEGIN_COM_MAP(CTVEMCastManager)
    COM_INTERFACE_ENTRY(ITVEMCastManager)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITVEMCastManager_Helper)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

   enum {
		KILL_CYCLES_BEFORE_FAILING	= 5,					// number of times we cycle before giving up
 		KILL_TIMEOUT_MILLIS			= 1000,					// cycle time for the killing event
		EXPIRE_TIMEOUT_MILLIS		= 1000 * 60, 			// run expire code every (10-60) seconds
        MAX_QUEUE_TREAD_MESSAGES    = 1000                  // maximum messages we want in the queue thread message queue (4K bytes each)

    } ;

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ITVEMCastManager
public:

    STDMETHOD(RemoveMulticast)(ITVEMCast *pMCast);
    STDMETHOD(get_MCasts)(/*[out, retval]*/ ITVEMCasts* *pVal);     // return the enumerator

    STDMETHOD(AddMulticast)(NWHAT_Mode whatType, BSTR bsAdapter, BSTR bsIPAddress, LONG usIPPort, LONG cBuffers, IUnknown *pICallback, ITVEMCast **ppMCast);
    STDMETHOD(FindMulticast)(BSTR bstrIPAdapter, BSTR bstrIPAddress, LONG ulPort,  ITVEMCast **ppMCast, LONG *pcMatches);

    STDMETHOD(JoinAll)();                                           // join all managed multicasts
    STDMETHOD(LeaveAll)();                                          // leave (remove) all managed multicasts
    STDMETHOD(SuspendAll)(VARIANT_BOOL fSuspend);                   // suspend (true) or run (false) all managed multicasts

                    // not recommended for normal users (should protect!)
    STDMETHOD(Lock_)();                                             //   useful for syncing multiple threads
    STDMETHOD(Unlock_)();                                           // puts/removes lock on manager
    STDMETHOD(DumpStatsToBSTR)(int iType, BSTR *pbstrDump);

    STDMETHOD(put_Supervisor)(ITVESupervisor *pTveSuper);           // gets/sets the containing supervisor
    STDMETHOD(get_Supervisor)(ITVESupervisor **ppTveSuper);

    STDMETHOD(put_HaltFlags)(LONG lGrfHaltFlags);
    STDMETHOD(get_HaltFlags)(LONG *plGrfHaltFlags)  {if(NULL == plGrfHaltFlags) return E_POINTER; *plGrfHaltFlags = (LONG) m_dwGrfHaltFlags; return S_OK;}


//  ITVEMCastManager_Helper
    STDMETHOD(DumpString)(BSTR bstrDump);                           // writes information about mcasts to a string
    STDMETHOD(CreateQueueThread)();
    STDMETHOD(KillQueueThread)();

    STDMETHOD(PostToQueueThread)(UINT dwEvent, WPARAM wParam, LPARAM lParam);
    STDMETHOD(GetPacketCounts)(LONG *pCPackets, LONG *pCPacketsDropped, LONG *pCPacketsDroppedTotal);
private:

    CTVESmartLock           m_sLk;

    CTVESmartLock           m_sLkExternal ;
    CTVESmartLock           m_sLkQueueThread ;

    ITVEMCastsPtr           m_spMCasts;
    ITVESupervisor          *m_pTveSuper;                   // non ref-counted back pointer.

    long                    m_cExternalInterfaceLocks;      // debug counter for Interface Lock()/Unlock()

    DWORD                   m_dwQueueThreadId;              // Thread used to queue up/process all packets
    HANDLE                  m_hQueueThread;                 // Thread used to queue up/process all packets
    HANDLE                  m_hQueueThreadAliveEvent;       // Signal from thread that its ready
    HANDLE                  m_hKillMCastEvent;              // Signal from thread that the MCast has been terminated
 
    void                    queueThreadBody () ;       
    static void             queueThreadProc(CTVEMCastManager *pcontext) ;

    int                     m_idExpireTimer;                // expire timer identifier
    unsigned int            m_uiExpireTimerTimeout;         // default to EXPIRE_TIMEOUT_MILLIS
    int                     m_cTimerCount;

    DWORD                   m_dwGrfHaltFlags;               // if !zero bits, avoid running various sections of code - see enum NFLT_grfHaltFlags

    HRESULT                 CreateSuperGITCookie();
    CComPtr<IGlobalInterfaceTable>  m_spIGlobalInterfaceTable;
    DWORD                   m_dwSuperGITProxyCookie;        // cookie to supervisor GIT Proxy object registered in the global interface table

    LONG                    m_cPackets;                     // total number of packets sent
    LONG                    m_cPacketsDropped;              // number of packets dropped 'cause we exceeded Queue limit, reset on unjam
    LONG                    m_cPacketsDroppedTotal;         // total number of packets dropped (sum of above)

    LONG                    m_kQueueMaxSize;                // max # of message before we start dropping them...
    LONG                    m_cQueueMessages;               // # of messages in the queue thread (minus the ones we don't know about like timer...)
    LONG                    m_cQueueSize;                   // # of bytes in the queue thread 
    BOOL                    m_fQueueThreadSizeExceeded;     // exceeded desired size of queue - must cleanup
 };

#endif //__TVEMCASTMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvemcmng.cpp ===
// ----------------------------------------------------------------------------
// Copyright (c) 1999-2001  Microsoft Corporation.  All Rights Reserved.
// TVEMCMng.cpp : Implementation of CTVEMCastManager
//
//  Implementation of the MulticastManager.
//
//      This servers two purposes.
//          1) It manages all the Multicast Reader threads 
//          2) It manages the the QueueThread.  
//
//      Each multicast reader is quite simple, it simply reads data from a
//      particular multicast reader into a buffer.  It then takes this buffer
//      of data, posts it onto the QueueThread, and then returns to read then 
//      next buffer.
//
//      The QueueThread hence serializes all multicast reads.  It is a seperate
//      thread than the main thread to avoid blocking user interaction.
//      When it's done processing the data, it posts an event onto/through the main
//      thread.  The Main thread in essense serializes the U/I calls.
//      Oh yeah, the QueueThread also runs the ExpireQueue. This is simply
//      a queue of objects that need to expire, sorted by there expire data.
//      Every N seconds (or in perhaps a next version, when needed), a timer event
//      kicks off the QueueThread to look for items to expire.  
//
//      Nasty proxying code here..
//
//      Stuff I've learned.
//          In order to marshall data from the queue thread back into the
//      main thread, the queue thread needs a marshalled pointer to the supervisor.
//      It gets this through the GIT.   
//          When you put things into the GIT, they get AddRef'ed.  This would
//      normally be OK, except for the Supervisor whose lifetime is managed
//      by an external client.  Hence there can be no internal add-refed counters
//      onto the supervisor, otherwise the clients release of the supervisor reference
//      wouldn't release the object, and we're left with an orphened and running supervisor.
//      Hence the MAGIC release.  What we do here is to immediatly release one reference
//      to the object we just added to the GIT.  Then on our FinalRelease, right before
//      we revoke that object from the GIT, we AddRef it.
//          
//          Problem is that ATL debugging code counts interface instances, not
//      objects.  So if I create a new ISuperB from a SuperA, and add it to the
//      GIT, I end up with 2 references to ISuperB (and 3 references to Super).  
//      If I then release the known ISuperB, ok, but we still have a reference to
//      the SuperB in the Git (and 2 total references to Super).  If I then
//      do the magic SuperB->Release(), well we end up with only 1 total refernece
//      to Super, but guess what?  In ATL reference instance debugging, SuperB now has zero
//      references, and the instance of SuperB in the GIT gets 'released', and futher
//      use of it caues errors.  This means we can't get the object from the GIT anymore.
//
//          What actually happens is that ATL refernce counted object is in two parts, a 
//      Top 'interface' part, and a bottom 'object' pUnk pointer part.  When this second 
//      release happens, the 'interface' count goes to zero.  This cause the pUnk pointer 
//      to be Free'ed, even though the object it points to (our Super) still has a reference 
//      count of 1.   Since the GIT is holding onto one of these two-part objects in this
//      debug mode, use of that object, in fact trying to get the object from the GIT, fails.
//      (The Git actually throws in this instance!)  None of this happens in retail or
//      non ATL interface debugging builds, but it certainly makes it hard to debug!
//          The solution is to not create a new ISuperB and insert it into the GIT.
//      Instead, the main Supervisor object (it's this pointer?) needs to be added to the GIT.
//  
//         The real fix to this would be not use a GIT to any object whose lifetime is
//      managed by an external client.  This is the ITVESupervisorGITProxy object...
//          
// -----------------------------------------------------------------------------
#include "stdafx.h"
#include "MSTvE.h"

#include "TVEServi.h"
#include "TVEMCast.h"
#include "TVEMCasts.h"
#include "TVEMCMng.h"

#include <stdio.h>      // needed in the release build...

#include "TveMCCBack.h"
#include "TVEDbg.h"
#include "DbgStuff.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

_COM_SMARTPTR_TYPEDEF(ITVEMCast, __uuidof(ITVEMCast));
_COM_SMARTPTR_TYPEDEF(ITVEMCasts, __uuidof(ITVEMCasts));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager, __uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCastCallback, __uuidof(ITVEMCastCallback));
_COM_SMARTPTR_TYPEDEF(ITVESupervisorGITProxy, __uuidof(ITVESupervisorGITProxy));

/////////////////////////////////////////////////////////////////////////////
// CTVEMCastManager

STDMETHODIMP CTVEMCastManager::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_ITVEMCastManager
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}



HRESULT CTVEMCastManager::FinalConstruct()
{                                                       // create variation list
    HRESULT hr = S_OK;
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::FinalConstruct"));

    try
    {
        CSmartLock spLock(&m_sLk, WriteLock);

        m_cExternalInterfaceLocks = 0;

        m_hQueueThread           = NULL;
        m_hQueueThreadAliveEvent = NULL;
        m_hKillMCastEvent        = NULL;

        CComObject<CTVEMCasts> *pMCasts;
        hr = CComObject<CTVEMCasts>::CreateInstance(&pMCasts);
        if(FAILED(hr))
            return hr;
        hr = pMCasts->QueryInterface(&m_spMCasts);          // typesafe QI
        if(FAILED(hr)) {
            delete pMCasts;
            return hr;
        }

        m_uiExpireTimerTimeout = EXPIRE_TIMEOUT_MILLIS;

        m_idExpireTimer         = 0;
        m_cTimerCount           = 0;
        m_pTveSuper             = NULL;         // not a smart pointer
        m_dwSuperGITProxyCookie = 0;


        m_hKillMCastEvent = CreateEvent( NULL, FALSE, FALSE, NULL );        // used to syncronize after killing an MCast
        if(NULL == m_hKillMCastEvent)
        {
            _ASSERT(FALSE);
            return E_FAIL;
        }

        hr = CreateQueueThread();               // moved into the Filter PAUSE method...
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}

HRESULT CTVEMCastManager::FinalRelease()
{                                               // create variation list
    HRESULT hr = S_OK;
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::FinalRelease"));

	_ASSERT(0 == m_cQueueMessages);
	
    try 
    {
		CSmartLock spLock(&m_sLk, WriteLock);			// smart lock's need to go inside try/catch loops!

                //  Null out global interface table references to the TVE supervisor...
        put_Supervisor(NULL);

        if(0 != m_idExpireTimer) KillTimer(0, m_idExpireTimer);     // may not actually do much for timer events
        m_idExpireTimer = 0;

                //  LeaveAll multicast listeners, also kills the expire queue
        LeaveAll();

                // cause these sub-objects to release themselves...
        m_spIGlobalInterfaceTable = NULL;
        m_pTveSuper = NULL;                         // null out this un-refed pointer

        CloseHandle( m_hKillMCastEvent );

	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}

HRESULT
CTVEMCastManager::CreateSuperGITCookie()        // can't use SuperHelper at ALL!, class isn't in the proxy-styb DLL
{
    HRESULT hr = S_OK;

    if(0 != m_dwSuperGITProxyCookie)            // already created, simply return
        return S_OK;

    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::CreateSuperGITCookie"));

    if(NULL == m_pTveSuper)                             // haven't initalized this yet.
        return E_FAIL;

            // used this to marshal calls to the TVESuper
    try
    {
        CSmartLock spLock(&m_sLk, WriteLock);
        m_spIGlobalInterfaceTable = NULL;
                    // create a copy of the one and only GIT..
        hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, 
                               IID_IGlobalInterfaceTable, reinterpret_cast<void**>(&m_spIGlobalInterfaceTable));

        if(FAILED(hr))
        {
            DBG_WARN(CDebugLog::DBG_SEV1, _T("*** Error creating/getting GIT"));
            return hr;
        }

        try         // caution - below will throw if ProxyStub not set up right (problem with SuperHelper!)
        {
            ITVESupervisor_HelperPtr spSuperHelper(m_pTveSuper);
            if(NULL == spSuperHelper)
            {
                _ASSERT(false);
                return E_FAIL;
            }
            ITVESupervisorGITProxy *pGITProxy;                      // don't create a new ATL (PTR) object here! - use simple object
            hr = spSuperHelper->get_SupervisorGITProxy(&pGITProxy); //    ATL interface debugging will womp object in GIT if we do...
            if(!FAILED(hr))
                hr = m_spIGlobalInterfaceTable->RegisterInterfaceInGlobal(pGITProxy,         
                                                                            __uuidof(*pGITProxy),         
                                                                            &m_dwSuperGITProxyCookie);
            if(pGITProxy)
                pGITProxy->Release();       // releases the AddRef done in the get_ call, not the one in the GIT

	    } catch (_com_error e) {
            hr = e.Error();
        } catch (HRESULT hrCatch) {
            hr = hrCatch;
        } catch (...) {       
             hr = TYPE_E_LIBNOTREGISTERED;               // didn't register the proxy-stub DLL (see Prof ATL Com Prog.  Pg 395)
            _ASSERTE(TYPE_E_LIBNOTREGISTERED);
        }
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }

    if(FAILED(hr))
    {
        DBG_WARN(CDebugLog::DBG_SEV1, _T("CTVEFilter::Error Registering Interfaces in GIT"));
        return hr;
    }
    return hr;
}

STDMETHODIMP 
CTVEMCastManager::put_Supervisor(ITVESupervisor *pTveSuper) 
{
    HRESULT hr = S_OK;
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::put_Supervisor"));

    try
    {
        CSmartLock spLock(&m_sLk, ReadLock);
        if(m_pTveSuper != NULL && pTveSuper == NULL)
        {
            if(pTveSuper == NULL)
            {
                TVEDebugLog((CDebugLog::DBG_SEV2, 2 ,_T("Leaving all multicasts since shutting down supervisor"))); 
            } else {
                                            // if change supervisor, all reader threads will have invalid callbacks
                                            //    so 'leave' them all to avoid problems...
                TVEDebugLog((CDebugLog::DBG_SEV2, 2 ,_T("Leaving all multicasts since changing supervisor")));  
            }

            spLock.ConvertToWrite();                // LeaveAll needs WriteLock, so convert to it for a bit
            if(0 != m_dwSuperGITProxyCookie)        // revoke from GIT if it's there
            {
                if(m_dwSuperGITProxyCookie)
                {
                // create a copy of the one and only GIT..
                    CComPtr<IGlobalInterfaceTable>  spIGlobalInterfaceTable;

                    hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, 
                                            IID_IGlobalInterfaceTable, reinterpret_cast<void**>(&spIGlobalInterfaceTable));
                    if(!FAILED(hr))
                        hr = spIGlobalInterfaceTable->RevokeInterfaceFromGlobal(m_dwSuperGITProxyCookie);
                }
                if(FAILED(hr))
                {
                    TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("RevokeInterfaceFromGlobal failed (hr=0x%08x). May leak"),hr));
        //          _ASSERT(false);                         // going to leak if failed this...
                }
                m_dwSuperGITProxyCookie = 0;
                m_pTveSuper = NULL;
            } 

            LeaveAll();             
            spLock.ConvertToRead();
        } 


        if(!FAILED(hr) && m_pTveSuper != pTveSuper)
        {
            spLock.ConvertToWrite();
            m_pTveSuper = pTveSuper;        // a non-refcounted back pointer

            if(pTveSuper)
                hr = CreateSuperGITCookie();
        }
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;

}

                // get a marshalled version of the supervisor.
                //  Required inside the QueueThread process, 
STDMETHODIMP CTVEMCastManager::get_Supervisor(ITVESupervisor **ppSuper)     // could return NULL    
{
    
    HRESULT hr = S_OK;
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::get_Supervisor"));
    if(NULL == ppSuper)
        return E_POINTER;


    try 
    {
   //  CSmartLock spLock(&m_sLk);  - when called from different thread, this hangs, so don't bother (serialized in GIT call below I think)...
       *ppSuper = NULL;
        if(0 == m_dwSuperGITProxyCookie)
            hr = E_FAIL;                    // hasn't done a put_Supervisor yet...


        ITVESupervisorGITProxyPtr spSuperGITProxyMainThread;
        if(!FAILED(hr))
        {
            CComPtr<IGlobalInterfaceTable>  spIGlobalInterfaceTable;

            hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_IGlobalInterfaceTable, reinterpret_cast<void**>(&spIGlobalInterfaceTable));
            if(!FAILED(hr))
                hr = spIGlobalInterfaceTable->GetInterfaceFromGlobal(m_dwSuperGITProxyCookie,
                                                                    __uuidof(spSuperGITProxyMainThread),  
                                                                    reinterpret_cast<void**>(&spSuperGITProxyMainThread));
        }
        if(!FAILED(hr))
        {
            hr = spSuperGITProxyMainThread->get_Supervisor(ppSuper);
        }
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}


        // returns the enumerator
STDMETHODIMP CTVEMCastManager::get_MCasts(ITVEMCasts **ppVal)
{
    HRESULT hr = S_OK;
	
	try {
		CSmartLock spLock(&m_sLk, ReadLock);
		if(NULL == ppVal)
			return E_POINTER;

		hr = m_spMCasts->QueryInterface(ppVal);
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEMCastManager::put_HaltFlags(LONG lGrfHaltFlags)        
{   
    HRESULT hr = S_OK;
	
	try {
		long cMCasts;
		CSmartLock spLock(&m_sLk, ReadLock);

		HRESULT hr = m_spMCasts->get_Count(&cMCasts);
		if(FAILED(hr))
			return hr;

		spLock.ConvertToWrite();

		for(int i = 0; i < cMCasts; i++) {
			ITVEMCastPtr spMC;
			CComVariant vc(i);
			hr = m_spMCasts->get_Item(vc,&spMC);
        
			NWHAT_Mode whatType;        spMC->get_WhatType(&whatType);
			CComBSTR spbsAddr;          spMC->get_IPAddress(&spbsAddr);
			CComBSTR spbsAdptr;         spMC->get_IPAdapter(&spbsAdptr);
			long     ulPort;            spMC->get_IPPort(&ulPort);
			VARIANT_BOOL fJoined;       spMC->get_IsJoined(&fJoined);
			VARIANT_BOOL fSuspended;    spMC->get_IsSuspended(&fSuspended);

			if(NWHAT_Announcement == whatType)              // the announcement listener
			{
				if(fJoined && 0 != (lGrfHaltFlags & NFLT_grfTA_Listen))
					spMC->Leave();
				if(!fJoined && 0 == (lGrfHaltFlags & NFLT_grfTA_Listen))
					spMC->Join();

				if(!fSuspended && 0 != (lGrfHaltFlags & NFLT_grfTB_AnncDecode)) // suspend announcements
					spMC->Suspend(VARIANT_TRUE);
				if(fSuspended && 0 == (lGrfHaltFlags & NFLT_grfTB_AnncDecode))
					spMC->Suspend(VARIANT_FALSE);
			} else if(NWHAT_Trigger == whatType) {
				if(fJoined && 0 != (lGrfHaltFlags & NFLT_grfTB_TrigListen))
					spMC->Leave();
				if(!fJoined && 0 == (lGrfHaltFlags & NFLT_grfTB_TrigListen))
					spMC->Join();

				if(!fSuspended && 0 != (lGrfHaltFlags & NFLT_grfTB_TrigDecode)) // suspend announcements
					spMC->Suspend(VARIANT_TRUE);
				if(fSuspended && 0 == (lGrfHaltFlags & NFLT_grfTB_TrigDecode))
					spMC->Suspend(VARIANT_FALSE);
			} else if(NWHAT_Data == whatType) {
				if(fJoined && 0 != (lGrfHaltFlags & NFLT_grfTB_DataListen))
					spMC->Leave();
				if(!fJoined && 0 == (lGrfHaltFlags & NFLT_grfTB_DataListen))
					spMC->Join();

				if(!fSuspended && 0 != (lGrfHaltFlags & NFLT_grfTB_DataDecode)) // suspend announcements
					spMC->Suspend(VARIANT_TRUE);
				if(fSuspended && 0 == (lGrfHaltFlags & NFLT_grfTB_DataDecode))
					spMC->Suspend(VARIANT_FALSE);
			}
		}

		m_dwGrfHaltFlags = (DWORD) lGrfHaltFlags; 
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}


// Finds a particular multicast added onto the manager with given parameters. 
//  Kind of wierd interface - watch it.
//   If pcMatches is NULL, must have the extact match.
//      Returns S_OK if find exactly one match, else returns S_FALSE;
//   If pcMatches is !NULL (contains valid address), can be used for partial matches.
//   If bstrIPAdapter or bstrIPAddress are NULL or zero length strings, or 
//   port is -1, looks for any matches or values.  
//   This returns <last> one found, and also count of matching values in *pcount.
//   (This is useful for seaching without specifying the adapter address.)
//      Returns S_FALSE if can't find any matches, S_OK if found at least one match.
//
//   Returned ITVEMCast object has been Add-Ref'ed - it's up to the caller to remove it.
//   Important:
//      Use '-1' for the searching ports, rather than 0.

STDMETHODIMP CTVEMCastManager::FindMulticast(BSTR bstrIPAdapter, BSTR bstrIPAddress, LONG ulIPPort, 
                                             ITVEMCast **ppMCast, LONG *pcMatches)
{
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::FindMulticast"));

    HRESULT hr = S_OK;;

	try
	{
		long cMCasts;
		BOOL fExactMatch = false;
		if(NULL == pcMatches) 
			fExactMatch = true;

		CSmartLock spLock(&m_sLk, ReadLock);

		hr = m_spMCasts->get_Count(&cMCasts);
		if(FAILED(hr))
			return hr;
		if(ppMCast == NULL) 
			return E_POINTER;
    
		if(fExactMatch) {
			if(NULL == bstrIPAdapter || (wcslen(bstrIPAdapter) == 0)) return E_INVALIDARG;
			if(NULL == bstrIPAddress || (wcslen(bstrIPAddress) == 0)) return E_INVALIDARG;
			if(ulIPPort < 0 || ulIPPort > 65535) return E_INVALIDARG;
		}

		long cMatches = 0;

		for(int i = 0; i < cMCasts; i++) {
			ITVEMCastPtr spMC;
			CComVariant vc(i);
			hr = m_spMCasts->get_Item(vc,&spMC);
        
			CComBSTR spbsAddr;  spMC->get_IPAddress(&spbsAddr);
			CComBSTR spbsAdptr; spMC->get_IPAdapter(&spbsAdptr);
			long     ulPort;    spMC->get_IPPort(&ulPort);

			if(fExactMatch || (bstrIPAdapter && (wcslen(bstrIPAdapter) > 0)))
				if(0 != wcscmp(bstrIPAdapter,spbsAdptr)) continue;
			if(fExactMatch || (bstrIPAddress && (wcslen(bstrIPAddress) > 0)))
				if(0 != wcscmp(bstrIPAddress,spbsAddr)) continue;
			if(fExactMatch || (ulIPPort != -1))
				if(ulIPPort != ulPort) continue;
			cMatches++;

			if(ppMCast) {               // returned AddRef'ed Pointer
				spMC->AddRef();
				*ppMCast = spMC;
			}

		}
		if(fExactMatch)  {
			if(cMatches == 1) return S_OK;      // found exatcly 1 match
			return S_FALSE;                     // couldn't find it, or more than one
		}

		if(pcMatches) 
			*pcMatches = cMatches;
    
		hr = (cMatches == 0) ? S_FALSE : S_OK;
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}

// AddMulticast()
//   adds a new multicast address to listen to.
//     will return E_INVALIDPARAM if invalid multicast address specified.
//     will return S_FALSE if it already exists.
//     will return E_NOINTERFACE is pICallback does not support ITVEMCastCallback
//   must still specify a processCallback and Join before actually listening occurs. 
//   If ppMCAdded is non null, will return an addref'ed pointer to the newly created multicast object by it. 
//      
//  pICallback is either an interface that supports ITVEMCastCallback or NULL.
//  If NULL, then you must call ITVEMCast::SetReadCallback(ITVEMCastCallback* px)
//  and specify some callback before calling ITVEMCast::Join().  
//
//  cBuffers is the number of read buffers to put down for this call back.  If 0, it uses the default (5).
//  This parameter is primarilly for uping the data multicast reader on fast transport systems
//  to something like 10-20.   
//  
STDMETHODIMP 
CTVEMCastManager::AddMulticast(NWHAT_Mode whatType, BSTR bsAdapter, BSTR bsIPAddress, LONG ulIPPort, LONG cBuffers, IUnknown *pICallback, ITVEMCast **ppMCAdded)
{
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::AddMulticast"));
    if(cBuffers < 0 || cBuffers > 500) 
        return E_INVALIDARG;

    HRESULT hr = S_OK;

	try {
		ITVEMCastPtr spMC;

		CSmartLock spLock(&m_sLk, ReadLock);

		hr = FindMulticast(bsAdapter, bsIPAddress, ulIPPort, &spMC, NULL);
        if(S_FALSE == hr)           // null means exact match
		{
									// create a new service node
			CComObject<CTVEMCast> *pMC;
			hr = CComObject<CTVEMCast>::CreateInstance(&pMC);
			if(!FAILED(hr)) 
				hr = pMC->QueryInterface(&spMC);        
			if(FAILED(hr)) {
				delete pMC;;
			} else {
				hr = spMC->put_WhatType(whatType);
			}

			if(!FAILED(hr)) 
				hr = spMC->put_IPAdapter(bsAdapter);

			if(!FAILED(hr)) 
				hr = spMC->put_IPAddress(bsIPAddress);

			if(!FAILED(hr)) 
				hr = spMC->put_IPPort(ulIPPort);

			if(!FAILED(hr)) 
				hr = spMC->put_QueueThreadId(m_dwQueueThreadId);;

			if(!FAILED(hr)) 
				hr = spMC->SetReadCallback(/*cBuffers*/ cBuffers, /*iPrioritySetback (-1)*/ THREAD_PRIORITY_BELOW_NORMAL, pICallback);

			if(!FAILED(hr)) 
				hr = spMC->ConnectManager(this);        // non-countered interface (this works through casting!)

			//{                                         // buggy code, should work like this pointer above, but doesn't
			//  HRESULT hr;
			//  ITVEMCastManagerPtr spMCM;
			//  hr = this->QueryInterface(IID_ITVEMCastManager,(void **) &spMCM);  // don't do when ATL_DEBUG is on
			//  IUnknownPtr spUnk;
			//  hr = QueryInterface(IID_IUnknown,(void **) &spUnk); 
			//  spMC->ConnectManager(spMCM);        // non-countered interface 
			//  spMCM->AddRef();    //???
			//}
        
			if(!FAILED(hr)) 
				hr = m_spMCasts->Add( spMC );
        
		} 
        else if(S_OK == hr)                             // found it...
        {                         
			_ASSERT(NULL != spMC);

			hr = spMC->SetReadCallback(/*cBuffers*/ cBuffers, /*iPrioritySetback (-1)*/ THREAD_PRIORITY_BELOW_NORMAL, pICallback);     // reset callback 

			if(!FAILED(hr)) 
			{
        
				VARIANT_BOOL fSuspended;
				hr = spMC->get_IsSuspended(&fSuspended);
				if(fSuspended)
					hr = spMC->Suspend(VARIANT_FALSE);          // if suspended, start it up again -- counter to Suspend in CTVEMCast::Leave()()

				hr = S_FALSE;               // already has it
			}
		}

		if(!FAILED(hr) && ppMCAdded) 
        {
			spMC->AddRef();         // Since returning it, addref it here..
			*ppMCAdded = spMC;      // return the MC we just created or modified...
		}
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEMCastManager::DumpString(BSTR bstrDump)
{
    static FILE *fp = NULL;
    Lock_();                                    // call's external lock.
    if(NULL == fp) {
        fp = fopen("dump.txt","w+");
        _ASSERT(NULL != fp);                    // hope this never fails!!
    }    

    if(fp) {
//      lock_();
        fprintf(fp,"%S",bstrDump);              // hopefully, this does internal locking...
        fflush(fp);
//      unlock_();
    }
    Unlock_();
    return S_OK;
}

STDMETHODIMP CTVEMCastManager::Lock_()          // avoid using these in client code if possible
{
	HRESULT hr = S_OK;
//	DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::Lock_"));

	try {
		m_sLkExternal.lockW_();                     // this is a write lock...
		m_cExternalInterfaceLocks++;
//		ATLTRACE("MCM Lock   +%d\n",m_cExternalInterfaceLocks);
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEMCastManager::Unlock_()
{
//  DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::Unlock_"));
//  _ASSERTE(m_cExternalInterfaceLocks > 0);
    HRESULT hr = S_OK;
	try {
	    if(m_cExternalInterfaceLocks <= 0)          // error condition
            return S_FALSE;                 
    //  ATLTRACE("MCM UnLock %d-\n",m_cExternalInterfaceLocks);
        m_sLkExternal.unlock_();
        --m_cExternalInterfaceLocks;
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}


// handy little dumper method
STDMETHODIMP CTVEMCastManager::DumpStatsToBSTR(int iType, BSTR *pbstrDump)
{
    HRESULT hr = S_OK;
    CComBSTR bstrM;
    WCHAR wBuff[256];

    try 
    {
        long cMCasts;           // need to lock (or copy) the enumerator list....
        CSmartLock spLock(&m_sLk, ReadLock);

        hr = m_spMCasts->get_Count(&cMCasts);
        swprintf(wBuff,L"    --------- %d Multicasts Managed -------\n",cMCasts);
        bstrM.Append(wBuff);
        for(int i = 0; i < cMCasts; i++) {
            ITVEMCastPtr spMC;
            CComVariant vc(i);
            hr = m_spMCasts->get_Item(vc,&spMC);
        
            if(!FAILED(hr)) { 
                CComBSTR        spbsAdpt;       spMC->get_IPAdapter(&spbsAdpt);
                CComBSTR        spbsAddr;       spMC->get_IPAddress(&spbsAddr);
                long            lPort;          spMC->get_IPPort(&lPort);
                VARIANT_BOOL    fJoined;        spMC->get_IsJoined(&fJoined);
                VARIANT_BOOL    fSuspended;     spMC->get_IsSuspended(&fSuspended);
                long            lPktCount;      spMC->get_PacketCount(&lPktCount);
                long            lBytCount;      spMC->get_ByteCount(&lBytCount);

                swprintf(wBuff,L"    %4d  %15s:%-5d [%c%c] Packets %-8d Bytes %-8d (%s)\n",
                            i, spbsAddr,lPort,
                            fJoined    ? 'J' : '-',
                            fSuspended ? 'S' : '-',
                            lPktCount, lBytCount,
                            spbsAdpt);
                bstrM.Append(wBuff);
            }
        }


        hr = bstrM.CopyTo(pbstrDump);
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEMCastManager::GetPacketCounts(LONG *pCPackets,LONG *pCPacketsDropped, LONG *pCPacketsDroppedTotal)
{
	DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::GetPacketCounts"));
	HRESULT hr = S_OK;
    if(NULL == pCPackets || NULL == pCPacketsDropped || NULL == pCPacketsDroppedTotal)
        return E_POINTER;

    try
    {
    	CSmartLock spLock(&m_sLk, ReadLock);

        *pCPackets = m_cPackets;
        *pCPacketsDropped = m_cPacketsDropped;
        *pCPacketsDroppedTotal = m_cPacketsDroppedTotal;
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEMCastManager::JoinAll()
{
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::JoinAll"));
    HRESULT hr = S_OK;

    try
    {
        CSmartLock spLock(&m_sLk, ReadLock);

        long cMCasts;
        hr = m_spMCasts->get_Count(&cMCasts);
        if(FAILED(hr)) 
            return hr;

        VARIANT_BOOL fJoined;
        for(int iMCast = 0; iMCast < cMCasts; iMCast++)
        {
            CComVariant cv(iMCast);
            ITVEMCastPtr spMCast;
            m_spMCasts->get_Item(cv, &spMCast);
            spMCast->get_IsJoined(&fJoined);
            if(!fJoined) 
                hr = spMCast->Join();
            if(FAILED(hr)) 
                return hr;
        }

	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEMCastManager::LeaveAll()
{
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::LeaveAll"));
    HRESULT hr = S_OK;

    try
    {
        CSmartLock spLock(&m_sLk, WriteLock);       // this could throw..

        long cMCasts;
        hr = m_spMCasts->get_Count(&cMCasts);
        if(FAILED(hr)) 
            return hr;

        if(cMCasts == 0) 
        {
            KillQueueThread() ;     // this was a painful routine to get right! 
            return S_OK;            // nothing to do
        }

        VARIANT_BOOL fJoined;
        HRESULT hrTotal = S_OK;

        for(int iMCast = cMCasts-1; iMCast >= 0; --iMCast)
        {
            CComVariant cv(iMCast);
            ITVEMCastPtr spMCast;
            m_spMCasts->get_Item(cv, &spMCast);
            spMCast->get_IsJoined(&fJoined);
            if(fJoined) 
                hr = spMCast->Leave();      
            if(FAILED(hr)) {
                hrTotal = hr;                   // remember we failed, by try to kill rest of MCasts if can
            } else {
                m_spMCasts->Remove(cv);
            }
        }
        hr = hrTotal;

        KillQueueThread() ;                     /// need to do this, but boy, this method is has been difficult
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}

// if suspended, still reads multicasts, but dumps data into the bit-buckets...

STDMETHODIMP CTVEMCastManager::SuspendAll(VARIANT_BOOL fSuspend)
{
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::SuspendAll"));
    HRESULT hr = S_OK;

    try
    {
        CSmartLock spLock(&m_sLk, ReadLock);

        long cMCasts;
        hr = m_spMCasts->get_Count(&cMCasts);
        if(FAILED(hr)) 
            return hr;

        for(int iMCast = 0; iMCast < cMCasts; iMCast++)
        {
            CComVariant cv(iMCast);
            ITVEMCastPtr spMCast;
            m_spMCasts->get_Item(cv, &spMCast);
            VARIANT_BOOL fSuspended;
            spMCast->get_IsSuspended(&fSuspended);
            if(fSuspend) {
                if(!fSuspended) hr = spMCast->Suspend(true);
            } else {
                if(fSuspended)  hr = spMCast->Suspend(false);
            }
            if(FAILED(hr)) 
                return hr;
        }
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}


STDMETHODIMP CTVEMCastManager::RemoveMulticast(ITVEMCast *pMCast)
{
    long cMCasts;
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::RemoveMulticast"));

    if(NULL == pMCast)          // null multicast not found...
        return S_FALSE;

    HRESULT hr = S_OK;
    try
    {
        CSmartLock spLock(&m_sLk, ReadLock);            // (WriteLock on the collection...)
        ITVEMCastPtr spMCast(pMCast);                   //   extra ref-count on the mCast so no one can delete it from under us

        HRESULT hr = m_spMCasts->get_Count(&cMCasts);
        if(cMCasts <= 0) 
            return S_FALSE;
    
        hr = pMCast->Leave();                           // syncronous call, stop reading in more data from the MCast's port.
        _ASSERT(!FAILED(hr));

            //  There may be posted messages by the this MCast on the QueueThread.  
            //   Need to process them first before removing the MCast.
            //   So, post a message onto the QueueThread to delete this MCast.
            //   First however, remove from the MCasts collection so don't find it anywhere...

        {
            spLock.ConvertToWrite();                   // don't let anyone in here until we've terminated this MCast...

            ITVEMCastCallbackPtr spCallback;
            if(!FAILED(hr))
            {
                pMCast->AddRef();                         // release in the ExpireQueue KillMCast event
                {
                    CComVariant cvMCast(pMCast);
                    hr = m_spMCasts->Remove(cvMCast);        // remove from the collection here... 
                }
    
                TVEDebugLog((CDebugLog::DBG_MCASTMNGR, 3, L"Trying to Kill MCast (0x%08x)\n", pMCast)); 

                ResetEvent( m_hKillMCastEvent );            // needed? Should already be cleared
                hr = PostToQueueThread(WM_TVEKILLMCAST_EVENT, (WPARAM) pMCast , NULL);      // this undoes the AddRef() above.
                _ASSERT(!FAILED(hr));

                HRESULT dwWaitRes,err;
                for(int i = 0; i < KILL_CYCLES_BEFORE_FAILING; i++)
                {
                    dwWaitRes = WaitForSingleObject(m_hKillMCastEvent, KILL_TIMEOUT_MILLIS);
				    if(dwWaitRes == WAIT_FAILED)
					    err = GetLastError();
                    if(dwWaitRes != WAIT_TIMEOUT)
                        break;
                }
                if(dwWaitRes == WAIT_TIMEOUT) 
                {
                    TVEDebugLog((CDebugLog::DBG_MCASTMNGR, 5, L"Unable to Kill MCast 0x%08x - abandoning wait",pMCast)); 
                    _ASSERT(false);
                }

            }
        }

	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEMCastManager::CreateQueueThread()
{
    HRESULT hr = S_OK;
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::CreateQueueThread"));

    if(m_hQueueThread)          // already created.
         return S_FALSE;

    _ASSERT(NULL == m_hQueueThread);

    try
    {
        CSmartLock spLock(&m_sLk, WriteLock);   
        
        m_hQueueThreadAliveEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if( !m_hQueueThreadAliveEvent ) {
            KillQueueThread();
            return E_FAIL;
        }

        m_hQueueThread = CreateThread (NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE) queueThreadProc,
                                        (LPVOID) this,
                                        NULL,
                                        &m_dwQueueThreadId) ;
                                    
        if (!m_hQueueThread) {
            KillQueueThread() ;
            return E_FAIL ;
        }

        // wait for it to finish initializing
        WaitForSingleObject( m_hQueueThreadAliveEvent, INFINITE );

        TVEDebugLog((CDebugLog::DBG_MCASTMNGR, 3, L"Creating Queue Thread (Thread 0x%x - id 0x%x)\n", 
                     m_hQueueThread, m_dwQueueThreadId));

                    // drop the queue thread priority down a bit...
//        SetThreadPriority (m_hQueueThread, THREAD_PRIORITY_NORMAL);
        SetThreadPriority (m_hQueueThread, THREAD_PRIORITY_BELOW_NORMAL);

	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}


                // Post a message to the QueueThread's queue.  Used to serialize processing of messages.
                //   Called by each MCast object when they receive a packet of data.

STDMETHODIMP
CTVEMCastManager::PostToQueueThread(UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::PostToQueueThread"));
    BOOL PostRet=FALSE;
    BOOL fOK = true;

    try {
        switch(uiMsg) 
        {
        case WM_TVEPACKET_EVENT:
            {
                
                ITVEMCast * pMCast = (ITVEMCast *) wParam;          // hope there's no marsalling going on here.
                ASYNC_READ_BUFFER * pBuffer = (ASYNC_READ_BUFFER *) lParam;
                
                InterlockedIncrement(&m_cPackets);                  // total number of packets read (even ones dropped)
                
                
                if(m_cQueueMessages > m_kQueueMaxSize)
                {
                    //	    	CSmartLock spLock(ReadLock);
                    
                    if(!m_fQueueThreadSizeExceeded)
                    {
                        ITVESupervisorPtr spSuper;
                        hr = get_Supervisor(&spSuper);
                        if(!FAILED(hr) && spSuper != NULL)
                        {
                            ITVESupervisor_HelperPtr spSuper_Helper(spSuper);
                            if(spSuper_Helper)
                            {
                                CComBSTR spbsBuff;
                                const int kChars=128;
                                WCHAR wBuff[kChars];  wBuff[kChars-1] = 0;     
                                spbsBuff.LoadString(IDS_AuxInfo_MessageQueueJammed); // L"Message Queue jammed at packet %d - (Queue Length %d) starting to drop packets"	
                                
                                wnsprintf(wBuff,kChars-1,spbsBuff,  m_cPackets-m_kQueueMaxSize, m_kQueueMaxSize);
                                m_cPacketsDropped = 0;      // reset the counter for this jam
                                spSuper_Helper->NotifyAuxInfo(NWHAT_Other,wBuff, 0, 0);
                            }
                        }
                    }
                    m_fQueueThreadSizeExceeded = true;
                }
                
                if(m_fQueueThreadSizeExceeded)                      // simply drop data packets if exceeded
                {
                    InterlockedIncrement(&m_cPacketsDropped);        // we droped some...
/*                  LONG lCount = -1;
                    if(pMCast)                                      // could be NULL (KILL event)
                    pMCast->get_PacketCount(&lCount);
                    TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("Queue size exceeded - dropping packet MCast:0x%08x, id %d, Packet id %d\n"),
                    pMCast, lCount, m_cPackets)); */
                    TVEDebugLog((CDebugLog::DBG_SEV4, 3, _T("Queue size exceeded - dropping packet id %d\n"),
                        m_cPackets));
                    return S_FALSE;
                }
                
                int cBytes      = pBuffer->bytes_read;
                int cTotalBytes = cBytes + sizeof(CPacketHeader);
                
                
                // alloc data to copy our packet into 
                //  (This alloc is why we have the Exceeded tests above...)
                
                char * szBuff = (char *) CoTaskMemAlloc(cTotalBytes);
                if(NULL == szBuff)
                    return E_OUTOFMEMORY;
                
                CPacketHeader *pcph = (CPacketHeader *) szBuff;
                pcph->m_cbHeader        = sizeof(CPacketHeader);
                pcph->m_dwPacketId      = m_cPackets;                   // total number of packets read (unique ID)
                pcph->m_cbData          = cBytes;                       
                
                memcpy((void *) (szBuff + sizeof(CPacketHeader)), (void *) pBuffer->buffer, cBytes);
                
                // -- message format
                // uiMsg     =  WM_TVEPACKET_EVENT
                // wParamOut = (CTVEMCast *)
                // lParamOut = (char *) buffer
                
                fOK = PostThreadMessage(m_dwQueueThreadId, uiMsg, wParam, (LPARAM) szBuff);
                if(fOK) {
                    InterlockedIncrement(&m_cQueueMessages);            
                    InterlockedExchangeAdd(&m_cQueueSize,cTotalBytes);
                } else {
                    hr = GetLastError();
                }
            } 
            break;
            
        case WM_TVEKILLMCAST_EVENT:         // these are never tossed
            {
                fOK = PostThreadMessage(m_dwQueueThreadId, uiMsg, wParam, lParam);
                if(fOK) {
                    InterlockedIncrement(&m_cQueueMessages);
                } else {
                    hr = GetLastError();
                }
            }
            break;
                
        default:                // don't increment for messages we don't know about..
            fOK = PostThreadMessage(m_dwQueueThreadId, uiMsg, wParam, lParam);
            if(!fOK) {
                hr =  GetLastError();
            }
            break;
        }                       // end switch
            
    } catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}

void 
CTVEMCastManager::queueThreadProc (CTVEMCastManager *pcontext)
{
    _ASSERT(pcontext) ;
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::queueThreadProc"));

    DBG_StartingANewThread();       // bop counter... (since don't exit thread, counter is 1 to big.                

    // NOTE: the thread will not have a message loop until we call some function that references it.
    //          CoInitializeEx with a APARTMENTTHREADED will implicitly reference the message queue
    //          So block the calling thread (sending the WM_QUIT) until after we have initialized
    //          (see the SetEvent in queueThreadBody).

 
    CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);     // initialize it... (maybe multithreaded later???)
    pcontext -> queueThreadBody () ;
    
    return ;                                            // never actually returns ???
}

// queueThreadBody
//   called via the CTVEMCastCallback::PostPacket() method in that MCast's thread
//   which then calls this  CTVEMCastCallback::ProcessPacket(), but in the QueueThread.
//
//   Could do lots of error checking here if could figure out how long the queue is...
//
//  Messages Handled... (compare to PostToQueueThread() above.)
//
//  WM_TVEKILLQTHREAD_EVENT:            - shut down the queue thread (because WM_QUIT doesn't seem to work)
//     wParam  = N/A
//     lParam  = N/A
//
//  WM_TVEPACKET_EVENT:                 - process packet
//     wParam  = CTVEMCast *            - multicast object (non-ref counted.)
//     lParam  = (char *) buffer        - CPacketHeader* followed by data - must be CoTaskMemFree'ed
//
//
//  WM_TVEKILLMCAST_EVENT:              - remove the MCast from the MCastManagers list
//     wParam = ITVEMCast *             - multicast object to release 
//     lParam = N/A
//      
//          // WM_TVETIMER_EVENT:
//  WM_TIMER:                           - cleanup events (about once a minute)
//     wParam = N/A
//     lParam = N/A
//
//  Others:                             - other messages are ignored
//
//
//  All WM_TVE... messages decrement the queue element count (m_cQueueMessages)
//  The WM_TVEPACKET_EVENT message decrements the queue size count (m_cQueueSize)
//
//  If the m_fQueueThreadSizeExceeded flag is set, TVEPACKET_EVENT's are not processed.
//    By 'processed', I mean the MCastCallback's process method will not be called.
//    This means the message will not be handled (e.g. announcements and triggers won't be parsed, data packets
//    will simply be ignored.)
//    When this flag is set, no more messages will be placed onto the Queue either.
//  No more TVEPACKET_EVENT messages will be placed on the queue either, meaning that it won't grow in size
//    very much more.   (The KILL events will be placed on the queue however.).
//  Events will only be processed again when the queue size goes all the way back to zero.  This means the
//  U/I size needs to become unblocked, and the old and crufty packets in the queue must be pulled off (but
//  not processed), before it restarts.
//    This fixes the problem of the U/I thread being blocked (e.g. an alert box pops up (e.g. IE complains of a
//  scripting error), the user being away from his monitor for an extended period of time, and the unblocked
//  message handling threads malloc'ing up space for lots and lots of messages that can't get processed further.
//  
//  

//  
//
void 
CTVEMCastManager::queueThreadBody ()            
{
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::queueThreadBody"));
    
    MSG msg;
    HWND hWndBogus = NULL;
    UINT wMsgFilterMin = WM_TIMER;
    // UINT wMsgFilterMin = WM_TVEPACKET_EVENT;     // only worry about TVE packets
    UINT wMsgFilterMax = WM_TVELAST_EVENT;
    
    // signal caller we're ready
    BOOL bRet = PeekMessage( &msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);
	SetEvent( m_hQueueThreadAliveEvent );

#define DO_EXPIRE_TIMER
#ifdef DO_EXPIRE_TIMER
    m_idExpireTimer = SetTimer(NULL, WM_TVETIMER_EVENT, m_uiExpireTimerTimeout, 0);
    if(0 == m_idExpireTimer)
    {
        TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("Error creating expire timer queue")));
    }
#endif
    
    // GetMessage returns FALSE when it receives a WM_QUIT
    while( GetMessage(&msg, hWndBogus, wMsgFilterMin, wMsgFilterMax) )
    {
        if(WM_TVEKILLQTHREAD_EVENT == msg.message)      // just incase WM_QUIT doesn't work (and having problems believe it does)
            break;                                      // exit this loop
        switch(msg.message )
        {
        default:
            // some other message
            {
                int imsg = msg.message;     // a place for a breakpoint 
            }
            break;
        case WM_TVEPACKET_EVENT:
            {
 // was               CTVEMCastCallback *pMCastCB = (CTVEMCastCallback *) msg.wParam;        
                CTVEMCast *pMCast = (CTVEMCast *) msg.wParam;                       // WARNING WILL ROBENSON! Nasty Casts! 
                char    *szPacket = (char *)      msg.lParam;
                ITVEMCastCallbackPtr spMCastCB = pMCast->m_spMCastCallback;

                 
                CPacketHeader *pcph = (CPacketHeader *) szPacket;  
                if(pcph == NULL || sizeof(CPacketHeader) != pcph->m_cbHeader)           // TODO - need better tests
                {
                    USES_CONVERSION;
                    TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("*** Unexpected Message: msg=0x%08x wp=0x%08x lp=0x%08x"),
                        msg.message, msg.wParam, msg.lParam));
                    if(msg.message != 0x400)        // we sort of know about this one...
                        _ASSERTE(false);            // continue reading other packets
                    ::CoTaskMemFree(szPacket);
                    continue;
                }

                InterlockedDecrement(&m_cQueueMessages);
                InterlockedExchangeAdd(&m_cQueueSize, -(pcph->m_cbHeader + pcph->m_cbData));

                _ASSERTE(sizeof(CPacketHeader) == pcph->m_cbHeader);                // data structures out of sync
/*#ifdef DEBUG  
                WCHAR wBuff[256];
                swprintf(wBuff,L"%s:%-5d - Packet(%d) %d Bytes (%d Total) \n",
                pMCastCB->m_pcMCast->m_spbsIP, pMCastCB->m_pcMCast->m_Port, 
                pMCastCB->m_pcMCast->m_cPackets,        // cPackets often wrong - incremented in previous thread before we get it here..
                cBytes, 
                pMCastCB->m_pcMCast->m_cBytes);
                ATLTRACE("%s",wBuff);
#endif*/ 
                
                // if start crashing here, suspect that TuneTo(NULL,NULL) not called to disable reads before shutdown...
   // was             pMCastCB->ProcessPacket((unsigned char *) szPacket + sizeof(CPacketHeader), pcph->m_cbData,  pcph->m_dwPacketId );

                if(NULL == spMCastCB)           /// Fix to Avoid that nasty timing bug
                {
                    ::CoTaskMemFree(szPacket);      
                    continue;               // it's been womped...
                }
   
                        // now this call can hang...
                        //   for example IE can leave us in an Alert box for hours...
                        // When this happens, we set the fSizeExceeded flag in the ProcessPacket.
                        //   So if it has happened, we stop processing packets until they are all cleaned up
                if(!m_fQueueThreadSizeExceeded)
                    spMCastCB->ProcessPacket((unsigned char *) szPacket + sizeof(CPacketHeader), pcph->m_cbData,  pcph->m_dwPacketId );
                else
                   TVEDebugLog((CDebugLog::DBG_SEV4, 3, _T("    * Dropping Packet %d in Cleanup since Queue Thread Size exceeded"),
                                            pcph->m_dwPacketId));

                ::CoTaskMemFree(szPacket);

                        // so - if we were hung, clean out all messages on the queue.
                        //   to tell if we were hung , check the m_fQueueThreadSizeExceeded flag

                if(m_fQueueThreadSizeExceeded && m_cQueueMessages <= 0)
                {
                    long cPackets = m_cPackets;
                    long cPDropped = m_cPacketsDropped;
                    m_cPacketsDropped = 0;
                    m_fQueueThreadSizeExceeded = false;             // unset this flag
                    TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("Restarting Queue at Packet %d - Approximately %d Packets Dropped"),cPackets, cPDropped+m_kQueueMaxSize));

                    m_cPacketsDroppedTotal += cPDropped;
                    
                    ITVESupervisorPtr spSuper;
                    HRESULT hr = get_Supervisor(&spSuper);
                    if(!FAILED(hr) && spSuper != NULL)
                    {
                        ITVESupervisor_HelperPtr spSuper_Helper(spSuper);
                        if(spSuper_Helper)
                        {
                            const int kChars=128;
                            WCHAR wBuff[kChars]; wBuff[kChars-1] = 0;   
                            CComBSTR spbsBuff;
                            spbsBuff.LoadString(IDS_AuxInfo_MessageQueueUnjammed);	// L"Message Queue unjammed at Packet %d - Approximately %d packets lost this jam, %d total"
                            
                            wnsprintf(wBuff,kChars-1, spbsBuff, cPackets, cPDropped, m_cPacketsDroppedTotal);
                            spSuper_Helper->NotifyAuxInfo(NWHAT_Other,wBuff, 0, 0);
                        }
                    }
                }
            }
            break;
            
            // remove the MCast from the MCastManagers list...
        case WM_TVEKILLMCAST_EVENT:
			{
                InterlockedDecrement(&m_cQueueMessages);

                long cMCasts;
                if(NULL == m_spMCasts)
                    return;
                ITVEMCast *pMCast = (ITVEMCast *)  msg.wParam;
                if(NULL == pMCast)
                    return;

#ifdef _DEBUG
                NWHAT_Mode enType;
                CComBSTR spbsAddr, spbsAdapter;
                long lPort;
                pMCast->get_WhatType(&enType);
                pMCast->get_IPAddress(&spbsAddr);
                pMCast->get_IPPort(&lPort);
                pMCast->get_IPAdapter(&spbsAdapter);
                
                TVEDebugLog((CDebugLog::DBG_MCASTMNGR, 2, L"Killing MCast 0x%08x %s:%d on %s, type %s", 
                    pMCast,
                    spbsAddr,
                    lPort,
                    spbsAdapter,
                    enType == NWHAT_Announcement ? L"Annc" :
                (enType == NWHAT_Trigger ? L"Trig" :
                (enType == NWHAT_Data ? L"Data" :
                (enType == NWHAT_Other ? L"Other" :
                (enType == NWHAT_Extra ? L"Extra" : L"Unknown"))))
                    ));
#endif 
                pMCast->Release();                        // (almost) final release..      (see  pMCast->AddRef(); line in CTVEMCastManager::RemoveMulticast())
                SetEvent( m_hKillMCastEvent );            //  Tell calling thread it's OK to run again...              
            }
            break;
            //      case WM_TVETIMER_EVENT:
        case WM_TIMER:
            {
                if(m_idExpireTimer == msg.wParam)
                {
                    static DWORD dwTimeStart =  msg.time;
                    DATE dateNow = 0.0;
                    
                    SYSTEMTIME SysTime;
                    GetSystemTime(&SysTime);
                    SystemTimeToVariantTime(&SysTime, &dateNow);
                    
                    
                    DWORD dwTime   = (msg.time - dwTimeStart);
                    DWORD dateTime = dwTime / (60.0 * 60.0 * 24.0);
                    
                    CComBSTR bstrNow = DateToBSTR(dateNow);
                    
                    TVEDebugLog((CDebugLog::DBG_MCASTMNGR, 3, _T("Timer Event - %6d - %s"), m_cTimerCount, bstrNow));
                    m_cTimerCount++;
                    
                    LONG lgrfHaltFlags;
                    get_HaltFlags(&lgrfHaltFlags);
                    if(0 == (lgrfHaltFlags & NFLT_grf_ExpireQueue))
                    {                   // Supervisor may be cross thread, get it this way
#if 1 // USE_Proxying
                        try
                        {
                            //                      CSmartLock spLock(&m_sLk, ReadLock);        
                            ITVESupervisorPtr spSuperHelperMainThread;
                            HRESULT hr = get_Supervisor(&spSuperHelperMainThread);      // may fail if have Breakpoint in Super's constructor
                            if(!FAILED(hr) && NULL != spSuperHelperMainThread)          //    and GIT is not set up before getting here.
                                spSuperHelperMainThread->ExpireForDate(0.0);
                        }
                        catch (HRESULT hrCatch)
                        {
                            TVEDebugLog((CDebugLog::DBG_SEV2, 3, _T("get_Supervisor Failed - ignoring")))
                        } 
                        catch (...)
                        {
                            TVEDebugLog((CDebugLog::DBG_SEV2, 3, _T("get_Supervisor Failed - ignoring")))
                        }
#else
                        m_pTveSuper->ExpireForDate(0.0);                    // expire now
#endif                  
                    }
                } else {
                    static int cStrangeTimer = 0;
                    if(cStrangeTimer < 5)
                    {
                        TVEDebugLog((CDebugLog::DBG_MCASTMNGR, 3, _T("Strange Timer Event - %d"), cStrangeTimer++ ));
                    }
                }
                    //  m_idExpireTimer = SetTimer(NULL, WM_TVETIMER_EVENT, m_uiExpireTimerTimeout, 0);
            }
            break;
        }                       // end of switch
    }
    
    // received WM_QUIT or WM_TVEKILLQTHREAD_EVENT
    TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("Kill Event - Terminate Mr. QueueThread!")));
    ExitThread (0) ;
    
    return ;
}


STDMETHODIMP 
CTVEMCastManager::KillQueueThread()
{
    DBG_HEADER(CDebugLog::DBG_MCASTMNGR, _T("CTVEMCastManager::KillQueueThread"));
    HRESULT hr = S_OK;

    try {
 
        if (m_hQueueThread) {
            CSmartLock spLock(&m_sLk, WriteLock);       

            TVEDebugLog((CDebugLog::DBG_MCASTMNGR, 3, L"Trying to Kill Queue Thread (Thread 0x%x - id 0x%x)\n", 
                          m_hQueueThread, m_dwQueueThreadId));

     //       HANDLE hThread2 = OpenThread(STANDARD_RIGHTS_REQUIRED, false, m_dwQueueThreadId);

               // Humm... Doc's have something about using PostQuitMessage() instead of sending a WM_QUIT message,
               //  but I don't know how to call it on a different thread.  This is perhaps why I need my own quit event
			DWORD err = 0;
			DWORD dwWaitRes = 0;
            hr = PostToQueueThread(WM_TVEKILLQTHREAD_EVENT, 0, 0); 
    //      int iErr3 = PostToQueueThread(WM_QUIT, 0, 0);               // tell it to die - however, WM_QUIT doesn't work
    //      Sleep(100);                                                 // give it a chance to switch threads...
            if(FAILED(hr))  
            {
                _ASSERT(false);
            }
            else
            {
                dwWaitRes = WaitForSingleObject (m_hQueueThread, KILL_CYCLES_BEFORE_FAILING*KILL_TIMEOUT_MILLIS) ;                   // wait for it to die (maybe INFINITE?)
			    if(dwWaitRes == WAIT_FAILED)
                {
 				    hr = GetLastError();
                    TVEDebugLog((CDebugLog::DBG_SEV2, 5, L"Error trying Kill QueueThread (hr=%0x%d) - simply exiting",hr)); 
                    _ASSERT(false);
                }
   
                if(dwWaitRes == WAIT_TIMEOUT) 
                {
                    TVEDebugLog((CDebugLog::DBG_SEV2, 5, L"Timout trying to Kill QueueThread- abandoning wait")); 
                    _ASSERT(false);
                }
            }

            CloseHandle (m_hQueueThread) ;
            m_hQueueThread = NULL ;

            CloseHandle( m_hQueueThreadAliveEvent );
            m_hQueueThreadAliveEvent = NULL;

            TVEDebugLog((CDebugLog::DBG_MCASTMNGR, 2, _T("CTVEMCastManager::KillQueueThread - Killed Thread")));
        }
	} catch (_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
        hr = hrCatch;
    } catch (...) {              
        hr = E_UNEXPECTED;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvemccback.h ===
// Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.
// TVEMCCback.h : Declaration of the CTVEMCastCallback

#ifndef __TVEMCASTCALLBACK_H_
#define __TVEMCASTCALLBACK_H_

#include "resource.h"       // main symbols

class CTVEMCast;
_COM_SMARTPTR_TYPEDEF(ITVEMCast, __uuidof(ITVEMCast));
/////////////////////////////////////////////////////////////////////////////
// CTVEMCastCallback
class ATL_NO_VTABLE CTVEMCastCallback : 
	public CComObjectRootEx<CComMultiThreadModel>,
//	public CComCoClass<CTVEMCastCallback, &CLSID_TVEMCastCallback>,
	public ISupportErrorInfo,
	public IDispatchImpl<ITVEMCastCallback, &IID_ITVEMCastCallback, &LIBID_MSTvELib>
{
public:
	CTVEMCastCallback()
	{
	}

	virtual ~CTVEMCastCallback()	// place to hang a breakpoint...
	{
#ifdef _DEBUG
        static int xxx = 0;
        xxx++;
#endif
	}


DECLARE_REGISTRY_RESOURCEID(IDR_TVEMCASTCALLBACK)

DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct();						// create internal objects
	HRESULT FinalRelease();

BEGIN_COM_MAP(CTVEMCastCallback)
	COM_INTERFACE_ENTRY(ITVEMCastCallback)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ITVEMCastCallback
public:
	STDMETHOD(SetMCast)(ITVEMCast  *pcMCast);			// puts raw MCast over...
	STDMETHOD(GetMCast)(ITVEMCast **ppIMCast);			// gets interface to MCast back
	STDMETHOD(PostPacket)(unsigned char *pchBuffer, long cBytes, long wPacketId);	// post to main thread
	STDMETHOD(ProcessPacket)(unsigned char *pchBuffer, long cBytes, long lPacketId) = 0;

protected:

protected:
	CTVEMCast		*m_pcMCast;
//	ITVEMCastPtr	m_spIMCast;
};


// actual  header of the packet used in the PostPacket() method
//  
struct CPacketHeader 
{
	DWORD	m_cbHeader;			// length of header in bytes (useful for decoding)
	DWORD	m_dwPacketId;		// simply a count on packets as they're received.. (useful cross message pump queue)
	DWORD	m_cbData;			// number of bytes of non-header data in packet (which follow the header)
};


#endif //__TVEMCASTCALLBACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvenavaid.cpp ===
// Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------
//  CTVENavAid.cpp : Implementation of CTVENavAid
//
//		Helper Class responsible for hooking up an IEBrowser, the VidControl,
//		the TVETriggerCtrl, their events and other gunk required
//		for a working Atvef system.  Usually CoCreate by an Application.
//
// -----------------------------------------------------------------

#include "stdafx.h"
#include <stdio.h>

#include "TveDbg.h"

#include "MSTvE.h"
#include "TveNavAid.h"
#include <MSVidCtl.h>		// F:\nt\public\sdk\inc\msvidctl.h
#include "TveFeature.h"

#include <Mshtml.h>			// IHTML Classes
#include <ExDisp.h>			// IWebBrowser Classes
#include <memory.h>			// memset

//#import "..\..\..\vidctl\tvegseg\tvegseg.idl" 
//#import "..\..\..\vidctl\TveGSeg\objd\i386\TveGSeg.tlb"  named_guids raw_interfaces_only
//#import "..\..\..\vidctl\TveGSeg\objd\i386\TveGSeg.tlb"  named_guids raw_interfaces_only
//#import "..\..\..\vidctl\msvidctl\objd\i386\msvidctl.dll" named_guids raw_interfaces_only
//#include "msvidctl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


_COM_SMARTPTR_TYPEDEF(IMSVidCtl,				__uuidof(IMSVidCtl));

_COM_SMARTPTR_TYPEDEF(IHTMLDocument,			__uuidof(IHTMLDocument));
_COM_SMARTPTR_TYPEDEF(IHTMLDocument2,			__uuidof(IHTMLDocument2));
_COM_SMARTPTR_TYPEDEF(IHTMLDocument3,			__uuidof(IHTMLDocument3));
_COM_SMARTPTR_TYPEDEF(IHTMLWindow2,				__uuidof(IHTMLWindow2));
_COM_SMARTPTR_TYPEDEF(IHTMLObjectElement,		__uuidof(IHTMLObjectElement));

_COM_SMARTPTR_TYPEDEF(IMSVidFeatures,			__uuidof(IMSVidFeatures));
_COM_SMARTPTR_TYPEDEF(IMSVidFeature,			__uuidof(IMSVidFeature));

_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEVariations,			__uuidof(ITVEVariations));
_COM_SMARTPTR_TYPEDEF(ITVETrack,				__uuidof(ITVETrack));

_COM_SMARTPTR_TYPEDEF(ITVENavAid,				__uuidof(ITVENavAid));
_COM_SMARTPTR_TYPEDEF(ITVENavAid_Helper,		__uuidof(ITVENavAid_Helper));
//_COM_SMARTPTR_TYPEDEF(IMSTVEGSeg,				__uuidof(IMSTVEGSeg));


// //////////////////////////////////////////////////////////////////////////
// Helper functions

// IE address has ABC<01><01>http:\\XYZ stuff - strip out junk up to 01's  
//   URL's can also contain '#' or '?' with data following - truncate off all that junk too

HRESULT 
CleanIEAddress(BSTR bstrAddr, BSTR *pbstrOut)	// IE address has ABC<01><01>http:\\XYZ stuff - strip out the 01's  
{

	const int kChars = MAX_PATH;
	WCHAR wszBuff[kChars]; 
	DWORD cResultChars;
	HRESULT hr;
						// will this work all by itself?
	hr = CoInternetParseUrl(bstrAddr, PARSE_CANONICALIZE , URL_PLUGGABLE_PROTOCOL | URL_ESCAPE_UNSAFE , 
							wszBuff, kChars, &cResultChars, /*reserved*/ 0);

	WCHAR *pwcAddr = bstrAddr;
	BOOL fSawAOne = false;
	while(*pwcAddr >= 0x01)
	{
		if(*pwcAddr == 0x00)
			break;
		if(*pwcAddr == 0x01)
			fSawAOne = true;
		else if(fSawAOne)
			break;
		pwcAddr++;
	}
	if(*pwcAddr == 0x00)			// no ones...
		pwcAddr = bstrAddr;

								// URL's can also contain '#' or '?' with data following - truncate off all that junk too
	CComBSTR bstrTmp(pwcAddr);		// truncate off the begining
	pwcAddr = bstrTmp;
	while(*pwcAddr != 0x00)
	{
		if(*pwcAddr == '#' || *pwcAddr == '?')
			break;
		pwcAddr++;
	}
	*pwcAddr = 0;					// terminate at the end...

	bstrTmp.CopyTo(pbstrOut);


	return S_OK;
}

BOOL FSameURL(BSTR bstr1, BSTR bstr2)
{

	if(NULL == bstr1 && NULL == bstr2)		// simply null string tests
		return true;
	if((NULL == bstr1) ^ (NULL == bstr2))	// if one is null, then obviously aren't equal
		return false;
//	return (0 == _wcsicmp( bstr1, bstr2));					// case insenstive

	// AfxParseURL( LPCTSTR pstrURL, DWORD& dwServiceType, CString& strServer, CString& strObject, INTERNET_PORT& nPort );

	const int kChars = MAX_PATH;
	const int kChars1 = kChars+1;
	WCHAR wszBuff1[kChars1];  //memset(wszBuff1,0,kChars1*sizeof(WCHAR));
	WCHAR wszBuff2[kChars1];  //memset(wszBuff1,0,kChars1*sizeof(WCHAR));
	DWORD cResultChars;
	HRESULT hr;

//	fOK = CoInternetParseUrl(bstr1, PARSE_LOCATION, NULL, wszBuff1, kChars, &cResultChars, /*reserved*/ 0);
//	fOK = CoInternetParseUrl(bstr1, PARSE_FRIENDLY, NULL, wszBuff1, kChars, &cResultChars, /*reserved*/ 0);
	hr = CoInternetParseUrl(bstr1, PARSE_CANONICALIZE , URL_PLUGGABLE_PROTOCOL | URL_ESCAPE_UNSAFE , 
							wszBuff1, kChars, &cResultChars, /*reserved*/ 0);
	hr = CoInternetParseUrl(bstr2, PARSE_CANONICALIZE , URL_PLUGGABLE_PROTOCOL | URL_ESCAPE_UNSAFE , 
							wszBuff2, kChars, &cResultChars, /*reserved*/ 0);


 //	return (0 == wcscmp( wszBuff1, wszBuff2));			
 	return (0 == _wcsicmp( wszBuff1, wszBuff2));					// case insenstive - very strange!!!
}
/////////////////////////////////////////////////////////////////////////////
// CTVETrigger_Helper


HRESULT 
CTVENavAid::FinalConstruct()							// initialize and/or create internal objects
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::FinalConstruct"));
	HRESULT hr = S_OK;
	m_lAutoTriggers = 1;								// default to allow it

	m_dwEventsWebBrowserCookie = 0;
	m_dwEventsTveSuperCookie  = 0;	
	m_dwEventsTveFeatureCookie  = 0;

	m_dwEventsFakeTveSuperCookie = 0;
	m_dwNavAidGITCookie = 0;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_spUnkMarshaler.p);
    if(FAILED(hr)) {
        _ASSERT(false);
        return hr;
    }

	hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, 
					 IID_IGlobalInterfaceTable, (void**) &m_spIGlobalInterfaceTable);
	if(FAILED(hr)) {
		return hr;
	}
	
	try				// assumes nav aid is constructed in the same thread that web browser is running in...
	{
		IUnknownPtr spPunk(this);
		hr = m_spIGlobalInterfaceTable->RegisterInterfaceInGlobal(spPunk, IID_ITVENavAid, &m_dwNavAidGITCookie);
		_ASSERT(!FAILED(hr)); 

        this->Release();                      // Reference Count Magic ! - (RegisterInterfaceInGlobal put's extra ref-count on 'this'.)

	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = TYPE_E_LIBNOTREGISTERED;			// didn't register the proxy-stub DLL (see Prof ATL Com Prog.  Pg 395)
		_ASSERTE(TYPE_E_LIBNOTREGISTERED);
	}


	return hr;
}

HRESULT 
CTVENavAid::FinalRelease()
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::FinalRelease"));
	put_ActiveVariation(NULL);

	put_WebBrowserApp(NULL);			// womp the Advise sink...
	put_NoVidCtl_Supervisor(NULL);

	TVEDebugLog((CDebugLog::DBG_NAVAID, 4, _T("Killing Global Interface Pointers")));
												// Inverse RefCount Fix...
												//    The FinalConstruct did an extra Release in the GIT calls
												//    So do an extra AddRef here..

	if(m_dwNavAidGITCookie && m_spIGlobalInterfaceTable) {
		this->AddRef();                       // Inverse Reference Count Magic ! - (RegisterInterfaceInGlobal put an extra Addref, we removed it
                                                //    removed it in the constructor, add it back here 'cause the Revoke will remove it again.

		hr = m_spIGlobalInterfaceTable->RevokeInterfaceFromGlobal(m_dwNavAidGITCookie);
		m_dwNavAidGITCookie = 0;
		m_spIGlobalInterfaceTable = NULL;		// done with this instance of it
	}
	if(FAILED(hr))
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("RevokeInterfaceFromGlobal failed (hr=0x%08x). May leak"),hr));
	}

    m_spUnkMarshaler = NULL;            

	return S_OK;
}

STDMETHODIMP 
CTVENavAid::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVENavAid,
		&IID_ITVENavAid_Helper
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


// --------------------------------------------------------------------------------
		// OK to pass in NULL to clean out the reference.
//
//  note magic code below won't work in Atl reference count debugTracing.  See
//	  long note over in the tvemastmng.cpp
//	  Shouldn't need it however, the NavAid's lifetime is managed by the
//	  U/I object directly...

STDMETHODIMP 
CTVENavAid::put_WebBrowserApp(/*[in]*/ IDispatch *pDispWebBrowser)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::put_WebBrowserApp"));
	HRESULT hr = S_OK;

    try {
        CSmartLock spLock(&m_sLk, WriteLock);

 	    if(m_dwEventsWebBrowserCookie) 
	    {
		    IUnknownPtr spPunkWebBrowser(m_spWebBrowser);	// the event source
		    IUnknownPtr spPunkSink(GetUnknown());			// this new event sink...
    //		spPunkSink->AddRef();							// MAGIC code (inverse)
		    hr = AtlUnadvise(spPunkWebBrowser,
						     DIID_DWebBrowserEvents2,
						     m_dwEventsWebBrowserCookie);	// need to pass to AtlUnadvise...
		    m_dwEventsWebBrowserCookie = 0;
		    m_spWebBrowser = NULL;							// wipe out any previous pointer...
	    }

	    if(NULL == pDispWebBrowser)				// NULL input value OK to release everything
		    return S_OK;

	    IWebBrowserAppPtr pWebBrowser(pDispWebBrowser);
	    if(NULL == pWebBrowser)
		    return E_NOINTERFACE;

	    m_spWebBrowser = pWebBrowser;			// ref-counted back pointer


				    // Try to catch the web browser events
	    {
										    // get the events...		
		    IUnknownPtr spPunkWebBrowser(m_spWebBrowser);	// the event source
		    IUnknownPtr spPunkSink(GetUnknown());			// this new event sink...

		    hr = AtlAdvise(spPunkWebBrowser,				// event source (IE Browser)
					       spPunkSink,						// event sink (gseg event listener...)
					       DIID_DWebBrowserEvents2,			// <--- hard line
					       &m_dwEventsWebBrowserCookie);	// need to pass to AtlUnadvise

    //		if(!FAILED(hr))
    //			spPunkSink->Release();							// MAGIC code here (Forward) (avoid having WebBrowser put a Ref on the NavAid) - see FinalRelease code
	    }

			    // more stuff here to get the document/top level window (???)
    } catch(_com_error e) {
        hr = e.Error();
 	} catch(HRESULT hrCatch) {
		hr = hrCatch;
    } catch(...) {
		hr = E_UNEXPECTED;
    }
	return hr;
}

STDMETHODIMP 
//CTVENavAid::WebBrowserApp(/*[out, retval]*/ IWebBrowserAppPtr **ppWebBrowser);
CTVENavAid::get_WebBrowserApp(/*[out, retval]*/ IDispatch **ppWebBrowser)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::get_WebBrowserApp"));
    HRESULT hr = S_OK;

    try {
	    CheckOutPtr<IDispatch*>(ppWebBrowser);
        CSmartLock spLock(&m_sLk, ReadLock);

	    *ppWebBrowser = NULL;

	    if(NULL == m_spWebBrowser)
		    return S_FALSE;

	    IDispatchPtr spDispWebBrowser(m_spWebBrowser);
	    if(NULL == spDispWebBrowser)
		    return E_NOINTERFACE;			// very unlikely

	    *ppWebBrowser = spDispWebBrowser;
	    (*ppWebBrowser)->AddRef();
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
		hr = hrCatch;
    } catch(...) {
		hr = E_UNEXPECTED;
    }
	return hr;
}

STDMETHODIMP 
CTVENavAid::get_TVETriggerCtrl(/*[out, retval]*/ ITVETriggerCtrl **ppTriggerCtrl)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::get_TVETriggerCtrl"));
    HRESULT hr = S_OK;
    try {
	    CheckOutPtr<ITVETriggerCtrl*>(ppTriggerCtrl);
        CSmartLock spLock(&m_sLk, ReadLock);

        *ppTriggerCtrl = m_spTriggerCtrl;
        if( *ppTriggerCtrl)
	        (*ppTriggerCtrl)->AddRef();
        else
            hr = S_FALSE;
    } catch(_com_error e) {
        hr = e.Error();
 	} catch(HRESULT hrCatch) {
		hr = hrCatch;
    } catch(...) {
		hr = E_UNEXPECTED;
    }
	return hr;

}

		// Cches the current NavAid state away in a buffer
		// This state is:
		//   Current URL
		//   Current Track Name
		//   Current ActiveVariation
		//
		// This caches ActiveVariation by names of it's variation and media to avoid storing pointers
		//    

#define MV(x) (x) ? (x) : ""
STDMETHODIMP 
CTVENavAid::get_CacheState(/*[out, retval]*/ BSTR *pbstrBuff)
{
    HRESULT hr = S_OK;
    DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::get_CachedState"));
    
    try {
	    CheckOutPtr<BSTR>(pbstrBuff);
        
        CComBSTR spbsBuff(sizeof(TVENavAidCacheState));
        TVENavAidCacheState *pCS = (TVENavAidCacheState *) spbsBuff.m_str;	// cast!
        memset(pCS, 0, sizeof(TVENavAidCacheState));

        CSmartLock spLock(&m_sLk, ReadLock);
           
        // dest, src
        pCS->m_cBytes = sizeof(TVENavAidCacheState);
        wcsncpy(pCS->m_wszCurrURL, MV(m_spbsCurrTVEURL), sizeof(pCS->m_wszCurrURL));
        wcsncpy(pCS->m_wszCurrName, MV(m_spbsCurrTVEName), sizeof(pCS->m_wszCurrName));
        
        if(m_spActiveVariation)
        {
            CComBSTR spbsVarMediaName;
            CComBSTR spbsVarMediaTitle;
            m_spActiveVariation->get_MediaName(&spbsVarMediaName);
            m_spActiveVariation->get_MediaName(&spbsVarMediaTitle);
            wcsncpy(pCS->m_wszActiveVarMediaName,  MV(spbsVarMediaName), sizeof(pCS->m_wszActiveVarMediaName));
            wcsncpy(pCS->m_wszActiveVarMediaTitle, MV(spbsVarMediaTitle), sizeof(pCS->m_wszActiveVarMediaTitle));
            
            IUnknownPtr spPunkEnh;
            hr = m_spActiveVariation->get_Parent(&spPunkEnh);
            if(!FAILED(hr))
            {
                ITVEEnhancementPtr spEnhancement(spPunkEnh);
                if(spEnhancement) {
                    CComBSTR spbsEnhDesc;
                    CComBSTR spbsEnhUUID;
                    spEnhancement->get_Description(&spbsEnhDesc);
                    spEnhancement->get_UUID(&spbsEnhUUID);
                    wcsncpy(pCS->m_wszActiveEnhDesc, MV(spbsEnhDesc), sizeof(pCS->m_wszActiveEnhDesc));
                    wcsncpy(pCS->m_wszActiveEnhUUID, MV(spbsEnhUUID), sizeof(pCS->m_wszActiveEnhUUID));
                }
            }
        }
        
        hr = spbsBuff.CopyTo(pbstrBuff);
    } catch(_com_error e) {
        hr = e.Error();
     } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}


STDMETHODIMP 
CTVENavAid::put_CacheState(/*[out, retval]*/ BSTR bstrBuff)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::get_CachedState"));

	TVENavAidCacheState *pCS = (TVENavAidCacheState *) bstrBuff;
    if(0 == pCS)
        return E_INVALIDARG;                        // this is certainly unexpected....

	if(pCS->m_cBytes != sizeof(TVENavAidCacheState))
	{
		_ASSERT(false);
		return E_INVALIDARG;
	}
	
	if(NULL == m_spCurrTVEService)
	{
		return E_INVALIDARG;			// no active service
	} else {
        try  {
           CSmartLock spLock(&m_sLk, ReadLock);
 
		    ITVEEnhancementsPtr spEnhs;
		    hr = m_spCurrTVEService->get_Enhancements(&spEnhs);
		    _ASSERT(!FAILED(hr));
		    if(!FAILED(hr))
		    {
			    long cEnhs;
			    hr = spEnhs->get_Count(&cEnhs); 
			    _ASSERT(!FAILED(hr));
			    for(int i = 0; i < cEnhs; i++)		// search though enhancements
			    {
				    ITVEEnhancementPtr spEnh;
				    CComVariant cvI(i);
				    hr = spEnhs->get_Item(cvI, &spEnh);
				    if(spEnh) 
				    {
					    CComBSTR spbsEnhDesc;
					    CComBSTR spbsEnhUUID;
					    spEnh->get_Description(&spbsEnhDesc);
					    spEnh->get_UUID(&spbsEnhUUID);		// did we find a matching one? (check both Desc and UUID to limit duplicates)
					    if(0 == wcscmp(pCS->m_wszActiveEnhDesc, spbsEnhDesc) &&
					       0 == wcscmp(pCS->m_wszActiveEnhUUID, spbsEnhUUID))
					    {
						    ITVEVariationsPtr spVars;		// yep - now go try to find a matching variation
						    hr = spEnh->get_Variations(&spVars);
						    _ASSERT(!FAILED(hr));
						    if(!FAILED(hr))
						    {
							    long cVars;
							    hr = spVars->get_Count(&cVars); _ASSERT(!FAILED(hr));
							    for(int j = 0; j < cVars; j++)
							    {
								    CComVariant cvJ(j);
								    ITVEVariationPtr spVar;
								    hr = spVars->get_Item(cvJ, &spVar);
								    _ASSERT(!FAILED(hr));
								    if(!FAILED(hr))
								    {
									    CComBSTR spbsVarMediaName;
									    CComBSTR spbsVarMediaTitle;
									    spVar->get_MediaName(&spbsVarMediaName);
									    spVar->get_MediaName(&spbsVarMediaTitle);
									    if(0 == wcscmp(pCS->m_wszActiveVarMediaName,  spbsVarMediaName) &&
									       0 == wcscmp(pCS->m_wszActiveVarMediaTitle, spbsVarMediaTitle))
									    {
															    // if we found a matching variation too -- mark it as the new active one
                                            spLock.ConvertToWrite();

										    m_spActiveVariation = spVar;
										    m_spbsCurrTVEName = pCS->m_wszCurrName;
										    m_spbsCurrTVEURL  = pCS->m_wszCurrURL;
										    m_spbsNavTVESourceID = pCS->m_wszActiveEnhUUID;	// just for fun, should of been set in last SetSite
										    hr = S_OK;
                                            break;
									    }
								    }
							    }
						    }
					    }
				    }
			    }
			    if(!FAILED(hr))
				    hr = E_INVALIDARG;
		    }
        } catch(_com_error e) {
            hr = e.Error();
        } catch(HRESULT hrCatch) {
		    hr = hrCatch;
	    } catch (...) {
		    hr = E_UNEXPECTED;
	    }
    }
	if(FAILED(hr)) 
    {					// if an error, start over from scratch
        try {
            CSmartLock spLock(&m_sLk, WriteLock);
		    m_spActiveVariation = NULL;
		    m_spbsCurrTVEName.Empty();
		    m_spbsCurrTVEURL.Empty();
        } catch(_com_error e) {
            hr = e.Error();
        } catch(HRESULT hrCatch) {
		    hr = hrCatch;
	    } catch (...) {
		    hr = E_UNEXPECTED;
	    }
	}
	return hr;
}
	

STDMETHODIMP 
CTVENavAid::put_ActiveVariation(/*[in]*/ ITVEVariation *pActiveVariation)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::get_TVETriggerCtrl"));

	m_spActiveVariation = pActiveVariation;
	return S_OK;

}


STDMETHODIMP 
CTVENavAid::get_ActiveVariation(/*[out, retval]*/ ITVEVariation **ppActiveVariation)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::get_TVETriggerCtrl"));

    HRESULT hr = S_OK;
    try {
	    CheckOutPtr<ITVEVariation *>(ppActiveVariation);
        CSmartLock spLock(&m_sLk, ReadLock);
        
	    *ppActiveVariation = m_spActiveVariation;       // ?? possible bug here- someone release's it before we addref it below?
	    if(*ppActiveVariation)
	        (*ppActiveVariation)->AddRef();
        else
            hr = S_FALSE;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
		hr = hrCatch;
    } catch(...) {
		hr = E_UNEXPECTED;
    }
	return hr;

}

STDMETHODIMP 
CTVENavAid::put_EnableAutoTriggering(/*[in]*/ long lAutoTriggers)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::put_EnableAutoTriggering"));
	
							// be strict about invalid parameters for a bit
	if(lAutoTriggers < 0 || lAutoTriggers > 1)
		return E_INVALIDARG;

	m_lAutoTriggers = lAutoTriggers;
	return S_OK;
}

STDMETHODIMP 
CTVENavAid::get_EnableAutoTriggering(/*[out, retval]*/ long *plAutoTriggers)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::get_EnableAutoTriggering"));
    HRESULT hr = S_OK;
    try {
	    CheckOutPtr<long>(plAutoTriggers);
	    *plAutoTriggers = m_lAutoTriggers;
    } catch(_com_error e) {
        hr = e.Error();
 	} catch(HRESULT hrCatch) {
		hr = hrCatch;
    } catch(...) {
		hr = E_UNEXPECTED;
    }
	return hr;
}

STDMETHODIMP 
CTVENavAid::get_CurrTVEName(/*[out, retval]*/  BSTR *pbstrName)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::get_CurrTVEName"));
    HRESULT hr = S_OK;
    try {
	    CheckOutPtr<BSTR>(pbstrName);
        CSmartLock spLock(&m_sLk, ReadLock);
 	    hr = m_spbsCurrTVEName.CopyTo(pbstrName);
    } catch(_com_error e) {
        hr = e.Error();
 	} catch(HRESULT hrCatch) {
		hr = hrCatch;
    } catch(...) {
		hr = E_UNEXPECTED;
    }
	return hr;
}

STDMETHODIMP 
CTVENavAid::get_CurrTVEURL(/*[out, retval]*/  BSTR *pbstrURL)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::get_CurrTVEURL"));
    HRESULT hr = S_OK;
    try {
	    CheckOutPtr<BSTR>(pbstrURL);
        CSmartLock spLock(&m_sLk, ReadLock);
        hr = m_spbsCurrTVEURL.CopyTo(pbstrURL);
    } catch(_com_error e) {
        hr = e.Error();
 	} catch(HRESULT hrCatch) {
		hr = hrCatch;
    } catch(...) {
		hr = E_UNEXPECTED;
    }
	return hr;
}

STDMETHODIMP 
CTVENavAid::ReInitCurrNavState(/*[in]*/ long lReserved)                    // lReserved must be 0
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::ReInitCurrNavState"));
    if(lReserved != 0)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    try {
        CSmartLock spLock(&m_sLk, WriteLock);
	    m_spbsCurrTVEURL.Empty();          // re-initialize these values...
        m_spbsCurrTVEName.Empty();
        m_spCurrTVEService = NULL;
        m_spActiveVariation = NULL;
    } catch(_com_error e) {
        hr = e.Error();
 	} catch(HRESULT hrCatch) {
		hr = hrCatch;
    } catch(...) {
		hr = E_UNEXPECTED;
    }
	return hr;

}


			// SCRIPT is either VBSCRIPT,JSCRIPT,JAVASCRIPT
			// according to AtvefSpec, it must be JSCRIPT for triggers

STDMETHODIMP 
CTVENavAid::ExecScript(/*[in]*/ BSTR bstrScript, /*[in]*/ BSTR bstrLanguage)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::ExecScript"));
	
	if(NULL == bstrScript)
		return E_POINTER;		
	
	if(NULL == m_spWebBrowser)
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	// in Comdex VB demo this magic code was:    
	//		WebBrowser1.Document.parentWindow.window.execScript CStr(pTrigger.Script)
    //  idea is to find the active frame in the frameset of the document...

	try {

		IDispatchPtr spDspDoc;
		hr = m_spWebBrowser->get_Document(&spDspDoc);
		if(S_OK == hr && NULL != spDspDoc)
		{
			IHTMLDocument2Ptr spHTMLDoc2(spDspDoc);				// see also IHTMLDocument and IHTMLDocument3 interfaces

			if(spHTMLDoc2)
			{
				IHTMLWindow2Ptr spHTMLWin2;
				hr = spHTMLDoc2->get_parentWindow(&spHTMLWin2);	// this could be the frame set..
				if(S_OK == hr && NULL != spHTMLWin2)
				{
					IHTMLWindow2Ptr spwin_HTMLWin2;				// the currently active window in the frame
                    hr = spHTMLWin2->get_window(&spwin_HTMLWin2);
					if(FAILED(hr) || NULL == spwin_HTMLWin2)
					{
						spwin_HTMLWin2 == spHTMLWin2;		// execute script on parent if get_window failed
						hr = S_OK;
					}
					
					{
						CComVariant cvReturn;
						CComBSTR spbsLanguage = bstrLanguage;
						if(spbsLanguage.Length() == 0)
							spbsLanguage = L"JSCRIPT";
						hr = spwin_HTMLWin2->execScript(bstrScript, bstrLanguage, &cvReturn);
					}
				}
			}
		}
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrRes) {
		hr = hrRes;
    } catch(...) {
	//	_ASSERT(false);			// something bad happened here.
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP 
CTVENavAid::Navigate(VARIANT *URL, VARIANT *Flags, VARIANT *TargetFrameName, VARIANT *PostData, VARIANT *Headers)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::Navigate"));

	if(NULL == m_spWebBrowser)
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	try
	{
		IWebBrowser2Ptr spBrowser2(m_spWebBrowser);
		if(spBrowser2 == NULL)
			return E_NOINTERFACE;

		CacheTriggerToExecAfterNav(NULL);	// zonk SourceID in TriggerCtrl since doing manual navigation

		hr = spBrowser2->Navigate2(URL, Flags, TargetFrameName, PostData, Headers); 

    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrRes) {
		hr = hrRes;
    } catch(...) {
	//	_ASSERT(false);			// something bad happened here.
		hr = E_FAIL;
	}
	return hr;
}


		// Recursive through frames to locate vidcontrol and Trigger control under the specified window
		//   If not found, one or both output params will remain NULL and this will return S_FALSE
		//
HRESULT 
CTVENavAid::LocateVidAndTriggerCtrls2(IHTMLWindow2 *pBaseHTMLWindow, IDispatch **ppVidCtrl, IDispatch **ppTrigCtrl)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::LocateVidAndTriggerCtrls2"));

    USES_CONVERSION;

    // Walk Object Model To Navigate

						// first get list of all the element in the document

 //   CComPtr<IHTMLDocument2> spDocument;
    IHTMLDocument2Ptr spDocument;
    HRESULT hr = pBaseHTMLWindow->get_document(&spDocument);
	if(FAILED(hr))
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("IHTMLWindow2::get_document Failed - hr = 0x%0x8"), hr));
		return hr;
	}

	IHTMLDocument3Ptr  spDocument3(spDocument);
	if(NULL == spDocument3)
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("IHTMLWindow2::QI for IHTMLWindow3 failed")));
		return E_NOINTERFACE;
	}

 //   CComPtr<IHTMLElementCollection> spElementCollection;
    IHTMLElementCollectionPtr spElementCollection;

    hr = spDocument3->getElementsByTagName(L"OBJECT", &spElementCollection);		// TODO - need to add Image Tags and lots of other stuff
	if(FAILED(hr))																	//        go back to get_all() and use get_type below
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("IHTMLDocument3::getElementsByTagName Failed - hr = 0x%0x8"), hr));
		return hr;
	}

    long lNoElements;
    hr = spElementCollection->get_length(&lNoElements);
	if(FAILED(hr))
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("IHTMLElementCollection::get_length Failed - hr = 0x%0x8"), hr));
		return hr;
	}

								// now walk through each element to look for our objects

    for (long lElement = 0; lElement < lNoElements; lElement++)
    {
		CComVariant vIndex(lElement);
		CComVariant vNull;

//		CComPtr<IDispatch> pDispatch;
		IDispatchPtr spDispatch;
		hr = spElementCollection->item( vIndex, vNull, &spDispatch);
		if(FAILED(hr))
		{
			TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("IHTMLElementCollection::item Failed - hr = 0x%0x8"), hr));
			continue;
		}

//		CComQIPtr<IHTMLElement, &IID_IHTMLElement> pElement(pDispatch);
		IHTMLElementPtr spElement(spDispatch);
		if(NULL == spElement)
		{
			TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("QI for IHTMLElementPtr Failed")));
			continue;
		}

										// is it an element we are looking for?

										// since it's a OBJECT element, QI for the HTML Object class
		IHTMLObjectElementPtr spObjElement(spDispatch);
		if(NULL == spObjElement)
		{
			TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("QI for IHTMLObjectElementPtr Failed")));
			continue;
		} else {

					// random test code
			CComBSTR spbsClassID;
			hr = spObjElement->get_classid(&spbsClassID);
			CComBSTR spbsType;
			hr = spObjElement->get_type(&spbsType);

					// end random test code

			IDispatchPtr spDispObj;		// get the contained object
			hr = spObjElement->get_object(&spDispObj);
			if(!FAILED(hr) && NULL != spDispObj)
			{
				if(NULL == *ppTrigCtrl)		// if we haven't found the TriggerCtrl yet
				{							//   QI the object element for it to see if it is
					ITVETriggerCtrlPtr spTriggerCtl(spDispObj);
					if(NULL != spTriggerCtl)
					{
						*ppTrigCtrl = spDispObj;		// yeah we found it, keep track of the internal pointer
						(*ppTrigCtrl)->AddRef();
						TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("Found TVETriggerCtrl")));
					}
				}

				if(NULL == *ppVidCtrl)		// perform same logic to see if we found the Vid control
				{
					IMSVidCtlPtr spVidCtrl(spDispObj);
					if(NULL != spVidCtrl)
					{
						*ppVidCtrl = spDispObj;
						(*ppVidCtrl)->AddRef();
						TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("Found MSVidCtl")));
					}
				}
			}
		} 

										// did we find both of them?
		if(NULL != *ppTrigCtrl && NULL != *ppVidCtrl)
			return S_OK;								// yeah we did!  Get out of this place...

    }					// end of element loop

			// If we didn't find the two tags yet, recurse into all frames to see if their contained deeper in the DOM

//    CComPtr<IHTMLFramesCollection2> spFrames;
    IHTMLFramesCollection2Ptr spFrames;
    hr = pBaseHTMLWindow->get_frames(&spFrames);
	if(FAILED(hr))
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("IHTMLWindow2::get_frames Failed - hr = 0x%0x8"), hr));
		return hr;
	}

    long lNoFrames;
    hr = spFrames->get_length(&lNoFrames);
	if(FAILED(hr))
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("IHTMLFramesCollection2::get_length Failed - hr = 0x%0x8"), hr));
		return hr;
	}

    for (long lFrame = 0; lFrame < lNoFrames; lFrame++)
    {
		CComVariant vFrame;
		CComVariant vIndex(lFrame);
		hr = spFrames->item(&vIndex, &vFrame);
		if(FAILED(hr))
		{
			TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("IHTMLFramesCollection2::item Failed - hr = 0x%0x8"), hr));
			return hr;
		}

//		CComPtr<IHTMLWindow2> pNewWindow;
//		hr = (vFrame.pdispVal)->QueryInterface(IID_IHTMLWindow2, (LPVOID*) &pNewWindow);
		IHTMLWindow2Ptr spNewWindow(vFrame.pdispVal);
		if(NULL == spNewWindow)
		{
			TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("Frame QI for IHTMLWindow2 Failed")));
			return E_NOINTERFACE;
		}
					// recursive call
		hr = LocateVidAndTriggerCtrls2(spNewWindow, ppVidCtrl, ppTrigCtrl);
		if (S_OK == hr)			// if found both,
			return S_OK;		//    return from this call
    }							// end of frame loop
    return S_FALSE;
}


		// --------------------------------

#define _RUN_WITHOUT_VIDCTL

HRESULT
CTVENavAid::HookupTVEFeature(IDispatch *pVidCtrl)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::HookupTVEFeature"));

	HRESULT hr = S_OK;


	if(NULL == pVidCtrl)			// if there is no VidControl to hookup, then exit 
	{								//   (or if allowed, instead create and hookup to an Supervisor
		put_TVEFeature(NULL);
#ifdef _RUN_WITHOUT_VIDCTL
		{						// to run without the VidCtl, simply get the TveSupervisor and sink it's events
										// create/get a supervisor object...(there is only one, it's a singleton)
			ITVESupervisorPtr spSuper;
			try
			{
				spSuper = ITVESupervisorPtr(CLSID_TVESupervisor);		// singleton - so gets the running one
            } catch(_com_error e) {
                hr = e.Error();
            } catch (HRESULT hrCatch) {
				return hrCatch;
			} catch (...) {
				return E_UNEXPECTED;
			}
			if(NULL == spSuper) 
				return E_OUTOFMEMORY;

												// start it running 
			try
			{
				ITVESupervisor_HelperPtr spSuperHelper(spSuper);
				int iAdapt = 0;
				CComBSTR spbsAdapter;			// TODO - this interface SUCKS!  I need to know unidirectional vs. bidirectional ones
				bool fItsAUniDiAddr = true;
				while(S_OK == (hr = spSuperHelper->get_PossibleIPAdapterAddress(iAdapt++,&spbsAdapter)))
				{
					WCHAR *pChar = spbsAdapter.m_str;		// get the first number in the string
					while(*pChar && *pChar != '.')			//   -- if less than 100, assume it's an IPSink adapter
						pChar++;
					fItsAUniDiAddr = ((pChar - &(spbsAdapter.m_str)[0]) < 3);
					if(!fItsAUniDiAddr) break;
				}
				if(S_OK != hr ||  fItsAUniDiAddr)
				{
					return S_FALSE;		// this not expected - couldn't find a bi-di adapter
				}

				if(NULL == m_spNoVidCtlSuper)			// if haven't got a fake supervisor, set up the one we just 'created'
				{
					if(!FAILED(hr))								// describe it.
						hr = spSuper->put_Description(L"NonVid TveSuper");

					if(!FAILED(hr))								// cache it, and do the advise to listen to events from it
						hr = put_NoVidCtl_Supervisor(spSuper);
					
				}

												// finally tune to this super to receive data on it... (if we aren't already tuned to some station)
                ITVEServicePtr spActiveService;
                if(!FAILED(hr))
                    hr = spSuperHelper->GetActiveService(&spActiveService);
				if(!FAILED(hr) && spActiveService == NULL)
                {
                                                // no active service, tune to the first one...
                    ITVEServicesPtr spServices;
                    hr = spSuper->get_Services(&spServices);
                    if(!FAILED(hr))
                    {
                        ITVEServicePtr spService;
                        CComVariant cv(0);
                        hr = spServices->get_Item(cv, &spService);
                        if(!FAILED(hr) && spService != NULL)
                            hr = spSuper->ReTune(spService);
                        else                    // if no services at all, create a new one...
                            hr = spSuper->TuneTo(L"Multicast Service", spbsAdapter);        // TODO - put this default name into resource
                    }
                }

            } catch(_com_error e) {
                hr = e.Error();
            } catch (HRESULT hrCatch) {
				hr = hrCatch;
			} catch (...) {
				hr = E_FAIL;
			}

			return hr;
		}
#else
		return S_FALSE;
#endif
	}

	IMSVidCtlPtr spVidCtrl(pVidCtrl);
	if(NULL == spVidCtrl)
	{
		put_TVEFeature(NULL);
		return S_FALSE;
	}
					// at this point, we have a pointer to the VidCtl...
					//   now dig down into it to locate the TVEFeature object that the TVEGraphSeg placed there.
					//   We want to sink it's events

	IMSVidFeaturesPtr spMSVidFeatures; 
	hr = spVidCtrl->get_FeaturesActive(&spMSVidFeatures);
	if(!FAILED(hr) && NULL != spMSVidFeatures)
	{
		long cFeatures;
		hr = spMSVidFeatures->get_Count(&cFeatures);
		int i = 0;
		for(i = 0; i < cFeatures; i++)
		{
			CComVariant cv(i);
			IMSVidFeaturePtr spFeature;
			hr = spMSVidFeatures->get_Item(cv, &spFeature);
			CComBSTR spbsClassID;
			spFeature->get_ClassID(&spbsClassID);

					// is it the TVE Graph Segment?
			if(0 == _wcsicmp( spbsClassID, L"{1600F001-6666-4f66-B1E2-BF3C9FBB9BA6}"))
			{
		//		IMSVidTVEGSegPtr spTVEGSeg(spFeature);

				ITVEFeaturePtr spTVEFeature(spFeature);
					// if it is, navigate to the ITVEFeature
					//   and then sink it's events
				
				if(spTVEFeature)
					hr = put_TVEFeature(spTVEFeature);
				else
				{
					hr = E_FAIL;
					_ASSERT(false);				// wrong wrong wrong!  What happened
				}

				break;
			}
		}				// end of for loop
		if(i >= cFeatures || cFeatures == 0)
		{
			// no Atvef feature found
		}
	}	
	
	return S_OK;
}


STDMETHODIMP 
//CTVENavAid::LocateVidAndTriggerCtrls(/*[out]*/ IMSVidCtrl **pVidCtrl, /*[out]*/ ITVETriggerCtrl **pVidCtrl)
CTVENavAid::LocateVidAndTriggerCtrls(/*[out]*/ IDispatch **ppVidCtrl, /*[out]*/ IDispatch **ppTrigCtrl)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::LocateVidAndTriggerCtrls"));

    HRESULT hr = S_OK;

	if(NULL == ppVidCtrl) return E_POINTER;
	if(NULL == ppTrigCtrl) return E_POINTER;
	if(NULL == m_spBaseHTMLWindow) return E_INVALIDARG;		// not initalized correctly

    try {
        *ppVidCtrl = NULL;				// init with NULL, so values get filled in
	    *ppTrigCtrl = NULL;
	    hr = LocateVidAndTriggerCtrls2(m_spBaseHTMLWindow, ppVidCtrl, ppTrigCtrl);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}


		// ----------------------------------------
		// selects the default active variation
		//  This is first variation of first enhancement with 'primary bit' set

HRESULT 
CTVENavAid::SetDefaultActiveVariation(ITVEService *pService)
{
	HRESULT hr = S_OK;
	if(NULL == pService)
		return E_INVALIDARG;
	
    try {
	    ITVEEnhancementsPtr spEnhancements;
	    hr = pService->get_Enhancements(&spEnhancements);
	    if(FAILED(hr)) 
		    return hr;
	    if(NULL == spEnhancements)
		    return E_INVALIDARG;

	    long cEnhans;
	    hr = spEnhancements->get_Count(&cEnhans);		
	    for(int i = 0; i < cEnhans; i++)					// Search for first variation of first 'primary' enhancement
	    {
		    CComVariant cvI(i);
		    ITVEEnhancementPtr spEnhancement;
		    hr = spEnhancements->get_Item(cvI, &spEnhancement);
		    if(!FAILED(hr))
		    {
			    VARIANT_BOOL fvPrimary;				
			    spEnhancement->get_IsPrimary(&fvPrimary);
			    if(fvPrimary)								// did we find the primary one?
			    {
				    ITVEVariationsPtr spVarias;
				    hr = spEnhancement->get_Variations(&spVarias);
				    CComVariant cv0(i);
				    ITVEVariationPtr spVariation;
				    hr = spVarias->get_Item(cv0, &spVariation);
				    if(!FAILED(hr) && NULL != spVariation)
				    {
					    m_spActiveVariation = spVariation;
					    return S_OK;
				    }
			    }
		    }
	    }
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
	return S_FALSE;										// couldn't find a primary enhancement
}
		// ----------------------------------------
		//     Rather yecky code to walk up the trigger hierarchy and determine
		//     wether we should AutoBrowse on this trigger
		//		
		//		Returns S_OK if should, S_FALSE if shouldn't, or an HRESULT
		//
					// Auto browse if :
					//  - AND
					//	   - Either
					//            Current URL is NULL 
					//       OR
					//          - Trigger Controls .releasable flag is set
					//          - UI says it OK (m_fAutoBrowse is set)
					//	        - TriggerCtrl's .enabled flag is set
					//          - Trigger Name is not NULL (note that low level TVE software attaches names if URL mathes earlier sent one)
					//          - Trigger URL is not NULL
					//          - Triggers Variation is selected as the Active one
		//		

	
HRESULT 
CTVENavAid::FDoAutoBrowse(ITVETrigger *pTrigger)				// note ActiveVariation set in the EnhN ew or Updated events
{
	BOOL fDoAutoBrowse = false;
	HRESULT hr = S_OK;

	if(NULL == pTrigger)
		return E_INVALIDARG;

	CComBSTR spbsName;
	CComBSTR spbsURL;
	
	if (!(m_lAutoTriggers & 0x1))							// auto browse flag turned off
		return S_FALSE;

	hr = pTrigger->get_Name(&spbsName);
	if(FAILED(hr))
		return hr;

	hr = pTrigger->get_URL(&spbsURL);
	if(FAILED(hr))
		return hr;


	bool fEnabled = true;									// these are the defaults
	bool fReleaseable = false;
	if(m_spTriggerCtrl)
	{
		VARIANT_BOOL vfEnabled;
		VARIANT_BOOL vfReleaseable;
		hr = m_spTriggerCtrl->get_enabled(&vfEnabled);		        // .enable flag turned off on the web page
		hr = m_spTriggerCtrl->get_releasable(&vfReleaseable);		// .releasable flag turned off on the web page
		fEnabled = (VARIANT_TRUE == vfEnabled);
		fReleaseable = (VARIANT_TRUE == vfReleaseable);
	}

	if(0 == spbsName.Length() || 0 == spbsURL.Length())		        // NULL trigger strings for Name or URL avoid AutoBrowse
		return S_FALSE;


	 if(!fReleaseable && 0 != m_spbsCurrTVEURL.Length())		    // don't browse if someplace already and releaseable flag not set
	   return S_FALSE;


										
				// get the enhancement -- rather nasty code to walk up the tree, isn't it?

	IUnknownPtr spPunk;
	hr = pTrigger->get_Parent(&spPunk);
	if(!FAILED(hr) || NULL != spPunk)
	{
		ITVETrackPtr spTrack(spPunk);		// spTrack(spPunk);
		if(NULL != spTrack) 
		{
			hr = spTrack->get_Parent(&spPunk);
			if(!FAILED(hr) &&  NULL != spPunk)
			{
				ITVEVariationPtr spTriggerVar(spPunk);
				if(NULL != spTriggerVar)
				{
					if(m_spActiveVariation == spTriggerVar)			// is it marked active?
						fDoAutoBrowse = true;

				}  
			}
		}
	}
	if(FAILED(hr))
		return hr;
	
	return fDoAutoBrowse ? S_OK : S_FALSE;
}

HRESULT 
CTVENavAid::DoExecuteScript(ITVETrigger *pTrigger)
{
	CComBSTR spbsScript, spbsLanguage;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::DoExecuteScript"));

	HRESULT hr = pTrigger->get_Script(&spbsScript);
	if(FAILED(hr) || 0 == spbsScript.Length())
		return hr;
		
		// SCRIPT is either VBSCRIPT,JSCRIPT,JAVASCRIPT
		// according to AtvefSpec, it must be JSCRIPT
	spbsLanguage = L"JSCRIPT";
	return ExecScript(spbsScript, spbsLanguage);
}

				
							// this method called when get a new trigger (via the NotifyTVETrigger[New/Updated] callbacks)
HRESULT 
CTVENavAid::DoNavigateAndExecScript(ITVETrigger *pTrigger, long lForceExec)
{

	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::DoNavigate"));

	if(NULL == pTrigger)
		return E_POINTER;
	
	CComBSTR spbsURL;

	hr = pTrigger->get_URL(&spbsURL);
	if(S_OK != hr || 0 == spbsURL.Length())
		return hr;

			// ??? do something here to convert namespaces ???
	
	CComBSTR spbsURL_Fixed;
	CleanIEAddress(spbsURL, &spbsURL_Fixed);

	CComBSTR spbsNavTVEScript;
	CComBSTR spbsNavTVEURL;
	pTrigger->get_Script(&spbsNavTVEScript);		// cache these away - used to execute script on DocumentComplete
	pTrigger->get_URL(&spbsNavTVEURL);

	if(lForceExec & 0x1)
		CacheTriggerToExecAfterNav(pTrigger);
	else
		CacheTriggerToExecAfterNav(NULL);
	CComVariant varZero(0);
	CComVariant varNull("");									
	hr = m_spWebBrowser->Navigate(spbsURL_Fixed, &varZero, &varNull, &varNull, &varNull);

	return hr;
}

HRESULT 
CTVENavAid::CacheTriggerToExecAfterNav(ITVETrigger *pTrigger)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::CacheTriggerToExecAfterNav"));

	if(NULL == pTrigger)
	{
		m_spbsNavTVEURL.Empty();
		m_spbsNavTVEScript.Empty();
		m_spbsNavTVESourceID.Empty();
	} else {
		pTrigger->get_URL(&m_spbsNavTVEURL);			
		pTrigger->get_Script(&m_spbsNavTVEScript);
	
					// walk up trigger hierarchy to find enhancement, and get the UUID 
					//   this turns into the triggerCtrl's sourceID
		IUnknownPtr spPunkTrack;
		hr = pTrigger->get_Parent(&spPunkTrack);

		CComBSTR spbsUUID;
		if(!FAILED(hr))
		{
			ITVETrackPtr spTrack(spPunkTrack);
			IUnknownPtr spPunkVariation;
			if(NULL == spTrack)
			{
				hr = E_NOINTERFACE;
			} else {
				hr = spTrack->get_Parent(&spPunkVariation);
			}
			if(!FAILED(hr))
			{
				ITVEVariationPtr spVariation(spPunkVariation);
				IUnknownPtr spPunkEnhancement;
				if(NULL == spTrack)
				{
					hr = E_NOINTERFACE;
				} else {
					hr = spVariation->get_Parent(&spPunkEnhancement);
				}
				if(!FAILED(hr))
				{
					ITVEEnhancementPtr spEnhancement(spPunkEnhancement);
					if(NULL == spTrack)
					{
						hr = E_NOINTERFACE;
					} else {
						hr = spEnhancement->get_UUID(&spbsUUID);
					}
				}
			}
		}
		m_spbsNavTVESourceID = (S_OK == hr) ? spbsUUID : NULL;

		if(m_spWebBrowser)				// try shoving the UUID into the web browser's property list 
		{								//  -- get in CTVETriggerCtrl::SetSite()
			CComVariant cvUUID(spbsUUID);
			m_spWebBrowser->PutProperty(L"MSTvE.TVENavAid.SourceID",cvUUID);
		}
	}

	return hr;
}
// -------------------------------------------------------------------------------
//		
STDMETHODIMP 
CTVENavAid::NavUsingTVETrigger(/*[in]*/ ITVETrigger *pTrigger, LONG lForceNav, LONG lForceExec)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NavUsingTVETrigger"));

	if(lForceNav > 1)			// currently, on 0 and 1 allowed
		return E_INVALIDARG;

	if(NULL == pTrigger)
		return E_POINTER;

	CComBSTR spbsName;
	CComBSTR spbsURL;
	CComBSTR spbsScript;
	ITVEServicePtr spService;

	pTrigger->get_Service((ITVEService **) &spService);
	pTrigger->get_Name(&spbsName);
	pTrigger->get_URL(&spbsURL);
	pTrigger->get_Script(&spbsScript);

	if(NULL == m_spCurrTVEService)			// UI not 'tuned' to a service - so use the first one we get
	{
		m_spbsCurrTVEURL.Empty();			  // unremember the default HOME page in this case  
		m_spbsCurrTVEName.Empty();			  //  zomp the name for good measure...
		m_spCurrTVEService = spService;		  //  (needed for AutoBrowse test)
	}

	if(m_spCurrTVEService != spService)		// if tuned to a different service than this trigger, ignore it
	{
		return S_OK;
	}

	if(NULL == m_spWebBrowser)				// not setup correctly...
		return E_INVALIDARG;


					// if we are not currently watching Atvef
					//  -- see if we auto browse


	hr = FDoAutoBrowse(pTrigger);			// should we auto browse???
	_ASSERT(!FAILED(hr));
	bool fDoAutoBrowse = (S_OK == hr);

	if(0 == m_spbsCurrTVEURL.Length())		// if no current URL
	{
	
		if(!fDoAutoBrowse) {				// if not autobrowsing and haven't set a URL
			m_spCurrTVEService = NULL;		//   unset the service (so the TVEURL gets nulled out above)
			return S_OK;
		}
	}

	if(fDoAutoBrowse || (lForceNav & 0x1))			// if auto browsing set, tune to the first trigger that arrives (???)
	{										// (this is NOT deterministic)

		m_spbsCurrTVEName = spbsName;				// set the current name

		hr = DoNavigateAndExecScript(pTrigger, lForceExec);
	} 
								// if not autobowsing, but the URL and or NAME is the same - execute 
								//    the script
	else if((lForceExec  & 0x1) && FSameURL(m_spbsCurrTVEURL,spbsURL))		// don't use '==', case senstive and doesn't seem to work)
	{	
		// same URL, same NAME
		if(m_spbsCurrTVEName == spbsName ||
		   0 == spbsName.Length())
		{
			hr = DoExecuteScript(pTrigger);			// don't renav if same, just exec the script
		}
	} else {
		// strange case according to Lee, but I think it makes sense
		//  -- different URL, same NAME
		if(m_spbsCurrTVEName == spbsName)
		{
	//		hr = DoNavigateAndExecScript(pTrigger, lForceExec);		// think same name, differnt variations...
		}
	}

	return hr;
}

STDMETHODIMP 
CTVENavAid::get_TVEFeature(/*[out, retval]*/ ITVEFeature **ppFeature)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::get_TVEFeature"));
    HRESULT hr = S_OK;
    try {
	    CheckOutPtr<ITVEFeature*>(ppFeature);
	    *ppFeature = m_spTVEFeature;
	    if(*ppFeature)
		    (*ppFeature)->AddRef();
        else
            hr = S_FALSE;
    } catch(_com_error e) {
        hr = e.Error();
 	} catch(HRESULT hrCatch) {
		hr = hrCatch;
    } catch(...) {
		hr = E_UNEXPECTED;
    }
	return hr;
}


HRESULT AtlAdvise2(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Advise(pUnk, pdw);
	return hRes;
}

STDMETHODIMP 
CTVENavAid::put_NoVidCtl_Supervisor(/*[in]*/ ITVESupervisor *pSuper)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::put_NoVidCtl_Supervisor"));
		
	IUnknownPtr spPunkSink(GetUnknown());			// this new event sink...
	HRESULT hr = S_OK;

	if(m_dwEventsFakeTveSuperCookie) 
	{
		IUnknownPtr spPunkOldSuper(m_spNoVidCtlSuper);	// the old event sink we want to get rid of
//		spPunkSink->AddRef();							// MAGIC code (inverse)

		if(NULL != spPunkOldSuper)
			hr = AtlUnadvise(spPunkOldSuper,
							 DIID__ITVEEvents,
							 m_dwEventsFakeTveSuperCookie);	// need to pass to AtlUnadvise...
		m_dwEventsFakeTveSuperCookie = 0;
		m_spNoVidCtlSuper = NULL;
	}

	if(NULL == pSuper)
		return hr;

	IUnknownPtr spPunkSuper(pSuper);				// the event source
	hr = AtlAdvise2(spPunkSuper,						// event source (TveSupervisor)
				   spPunkSink,						// event sink (this app...)
				   DIID__ITVEEvents,				// <--- hard line
				   &m_dwEventsFakeTveSuperCookie);	// need to pass to AtlUnadvise
//		if(!FAILED(hr))
//			spPunkSink->Release();							// MAGIC code here (Forward) (avoid having WebBrowser put a Ref on the NavAid) - see FinalRelease code

	if(!FAILED(hr))
		m_spNoVidCtlSuper = pSuper;							// keep track of it
	return hr;
}

STDMETHODIMP 
CTVENavAid::get_NoVidCtl_Supervisor(/*[out, retval]*/ ITVESupervisor **ppSuper)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::get_NoVidCtl_Supervisor"));
    HRESULT hr = S_OK;

    try {
	    CheckOutPtr<ITVESupervisor *>(ppSuper);
        
	    *ppSuper = m_spNoVidCtlSuper;
	    if(*ppSuper)
		    (*ppSuper)->AddRef();
        else
            hr = S_FALSE;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
    return hr;
}

HRESULT							// creates the event sink for _ITVEEvents from the TVEFeature 
CTVENavAid::put_TVEFeature(/*[in]*/ ITVEFeature *pTVEFeature)
{
    HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::put_TVEFeature"));
		
    try {
	    IUnknownPtr spPunkSink(GetUnknown());	// this new event sink...
	    HRESULT hr = S_OK;

	    if(m_dwEventsTveFeatureCookie) 
	    {
		    IUnknownPtr spPunkOldFeature(m_spTVEFeature);	// this old event sink we want to get rid of
    //		spPunkSink->AddRef();							// inverse magic 
		    if(NULL != spPunkOldFeature)
			    hr = AtlUnadvise(spPunkOldFeature,
							     DIID__ITVEEvents,
							     m_dwEventsTveFeatureCookie);	// need to pass to AtlUnadvise...
		    m_dwEventsTveFeatureCookie = 0;
		    m_spTVEFeature = NULL;
	    }

	    if(NULL == pTVEFeature)
		    return hr;

	    IUnknownPtr spPunkTveFeature(pTVEFeature);				// the event source
	    hr = AtlAdvise(spPunkTveFeature,				// event source (TveFeature
				       spPunkSink,						// event sink (this app...)
				       DIID__ITVEEvents,				// <--- hard line
				       &m_dwEventsTveFeatureCookie);	// need to pass to AtlUnadvise

    //		if(!FAILED(hr))
    //			spPunkSink->Release();							// MAGIC code here (Forward) (avoid having WebBrowser put a Ref on the NavAid) - see FinalRelease code

	    if(!FAILED(hr))
		    m_spTVEFeature = pTVEFeature;							// keep track of it

    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }    
	return hr;

}

///////////////////////////////////////////////////////////////////////////////////
///  TVE Events
///////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CTVENavAid::NotifyTVETune( NTUN_Mode tuneMode,  ITVEService *pService, BSTR bstrDescription, BSTR bstrIPAdapter)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyTVETune"));

	if(pService != NULL && pService != m_spCurrTVEService)
	{

		// save current state
		CComBSTR spbsCacheState;
		hr = get_CacheState(&spbsCacheState);

/* -- not ready for prime time yet
		if(!FAILED(hr) && NULL != m_spCurrTVEService)
			hr = m_spCurrTVEService->put_Property(L"NavAid.CacheState", spbsCacheState);
	
		// restore old state
		m_spCurrTVEService = pService;
		hr = m_spCurrTVEService->get_Property(L"NavAid.CacheState", &spbsCacheState);
		if(!FAILED(hr))
			hr = put_CacheState(spbsCacheState);
*/
	}

	if(NTUN_Turnoff == tuneMode )
	{
		ReInitCurrNavState(0);	 		// kill all cached state...
	}


	return hr;
}

STDMETHODIMP CTVENavAid::NotifyTVEEnhancementNew(ITVEEnhancement *pEnh)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyTVEEnhancementNew"));

    try {
	    if(NULL == m_spActiveVariation)						// default the primary variation if not set
	    {													
		    IUnknownPtr spServicePunk;
		    hr = pEnh->get_Parent(&spServicePunk);
		    if(!FAILED(hr) && NULL != spServicePunk)
		    {
			    ITVEServicePtr spService(spServicePunk);
			    if(spService)
				    SetDefaultActiveVariation(spService);
		    }
	    }
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
	return S_OK;
}
									// changedFlags : NENH_grfDiff
STDMETHODIMP CTVENavAid::NotifyTVEEnhancementUpdated(ITVEEnhancement *pEnh, long lChangedFlags)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyTVEEnhancementUpdated"));

    try {
	    if(NULL == m_spActiveVariation)						// default the primary variation if not set
	    {
		    IUnknownPtr spServicePunk;
		    hr = pEnh->get_Parent(&spServicePunk);
		    if(!FAILED(hr) && NULL != spServicePunk)
		    {
			    ITVEServicePtr spService(spServicePunk);
			    if(spService)
				    SetDefaultActiveVariation(spService);
		    }
	    }
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }	
	return hr;
}

STDMETHODIMP CTVENavAid::NotifyTVEEnhancementStarting(ITVEEnhancement *pEnh)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyTVEEnhancementStarting"));
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyTVEEnhancementExpired(ITVEEnhancement *pEnh)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyTVEEnhancementExpired"));

    try {
	    if(NULL != m_spActiveVariation)				// if active variation on this service, womp it
	    {
		    IUnknownPtr spEnhPunk;
		    hr = m_spActiveVariation->get_Parent(&spEnhPunk);
		    if(!FAILED(hr) && spEnhPunk == pEnh)
		    {
			    VARIANT_BOOL fvPrimary;
			    pEnh->get_IsPrimary(&fvPrimary);
			    if(fvPrimary)
				    m_spActiveVariation = NULL;			// if it's the primary enhancement, simply womp it..
			    else									
			    {										// else reset to the primary enhancement
				    IUnknownPtr spServicePunk;
				    hr = pEnh->get_Parent(&spServicePunk);
				    if(!FAILED(hr) && NULL != spServicePunk)
				    {
					    ITVEServicePtr spService(spServicePunk);
					    if(spService)
						    SetDefaultActiveVariation(spService);		// since pEnh is not primary, will find another one if its there
				    }
			    }
		    }
	    }
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
	return hr;
}

STDMETHODIMP CTVENavAid::NotifyTVETriggerNew(ITVETrigger *pTrigger, BOOL fActive)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyTVETriggerNew"));
	NotifyTVETriggerUpdated(pTrigger, fActive, 0xfffff);					// Just call the Update function
	return S_OK;
}

									// changedFlags : NTRK_grfDiff
STDMETHODIMP CTVENavAid::NotifyTVETriggerUpdated(ITVETrigger *pTrigger, BOOL fActive, long lChangedFlags)
{
//#if 0       
			// need the Proxying - else can't exec the triggers 
			//   spwin_HTMLWin2->execScript() fails
			//.. but seem to leak a NavAid or 4
#if 1
    HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyTVETriggerUpdated"));

				    // this method often called from Queue Thread,
				    //   need to marshel over to the WebBrowswer thread to get it to accept our call
    try {
        ITVENavAidPtr spNavAidBrowserThread;
	    HRESULT hr = m_spIGlobalInterfaceTable->GetInterfaceFromGlobal(m_dwNavAidGITCookie,
																    __uuidof(spNavAidBrowserThread),  
																    reinterpret_cast<void**>(&spNavAidBrowserThread));

	    if(!FAILED(hr))
	    {
		    ITVENavAid_HelperPtr spNavAidHelper_BrowserThread(spNavAidBrowserThread);
		    if(NULL == spNavAidHelper_BrowserThread)
		    {
			    _ASSERT(false);
			    return E_NOINTERFACE;
		    }
		    hr = spNavAidHelper_BrowserThread->NotifyTVETriggerUpdated_XProxy(pTrigger, fActive, lChangedFlags);
			spNavAidHelper_BrowserThread = NULL;
	    }
		spNavAidBrowserThread = NULL;
		return hr;
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }
	return hr;
#else
	return NotifyTVETriggerUpdated_XProxy(pTrigger, fActive, lChangedFlags);
#endif
}

HRESULT 
CTVENavAid::NotifyTVETriggerUpdated_XProxy(ITVETrigger *pTrigger, BOOL fActive, long lChangedFlags)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyTVETriggerUpdated_XProxy"));

/*	CComBSTR spbsName;
	CComBSTR spbsURL;
	CComBSTR spbsScript;
	ITVEServicePtr spService;

	pTrigger->get_Service((ITVEService **) &spService);
	pTrigger->get_Name(&spbsName);
	pTrigger->get_URL(&spbsURL);
	pTrigger->get_Script(&spbsScript);
*/

	return NavUsingTVETrigger(pTrigger, /*forceNav*/ 0x0, /*forceExec*/ 0x1);
}

STDMETHODIMP CTVENavAid::NotifyTVETriggerExpired(ITVETrigger *pTrigger, BOOL fActive)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyTVETriggerExpired"));
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyTVEPackage(NPKG_Mode engPkgMode, ITVEVariation *pVariation, BSTR bstrUUID, long  cBytesTotal, long  cBytesReceived)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyTVEPackage"));
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyTVEFile(NFLE_Mode engFileMode, ITVEVariation *pVariation, BSTR bstrUrlName, BSTR bstrFileName)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyTVEFile"));
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyTVEAuxInfo(NWHAT_Mode enAuxInfoMode, BSTR bstrAuxInfoString, long lChangedFlags, long lErrorLine)	// WhatIsIt is NWHAT_Mode - lChangedFlags is NENH_grfDiff or NTRK_grfDiff treated as error bits 
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyTVEAuxInfo"));
	return S_OK;
}
////////////////////////////////////////////////////////////////////////////////////
////   DWebBrowserEvents2
////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CTVENavAid::NotifyNavigateComplete2(IDispatch * pDisp, VARIANT * URL)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyDocumentComplete(IDispatch * pDisp, VARIANT * URL)
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyDocumentComplete"));
	HRESULT hr = S_OK;

	IDispatchPtr spDispVidCtrl;
	IDispatchPtr spDispTrigCtrl;

    try {                                           // TODO - need locking here somewhere?
        IWebBrowser2Ptr spWebBrowser(pDisp);
        
        CComBSTR bstrURL;
        CleanIEAddress(URL->bstrVal, &bstrURL);
        
        {
            IUnknownPtr spPunkIn(pDisp);
            IUnknownPtr spPunkWebBrowser(m_spWebBrowser);
            if(spPunkIn != spPunkWebBrowser)
                return S_OK;									// different browser (getting on about:blank URL's)
            _ASSERT(spPunkIn == spPunkWebBrowser);				// paranoia checking.... (Did someone change browsers on us?)
        }
        
        // walk the object model to find the top level HTML window.
        if(spWebBrowser)
        {
            IDispatchPtr spDspDoc;
            hr = spWebBrowser->get_Document(&spDspDoc);
            if(S_OK == hr && NULL != spDspDoc)
            {
                IHTMLDocument2Ptr spHTMLDoc2(spDspDoc);				// see also IHTMLDocument and IHTMLDocument3 interfaces
                
                if(spHTMLDoc2)										// will be NULL on when browsing directories
                {
                    IHTMLWindow2Ptr spHTMLWin2;
                    hr = spHTMLDoc2->get_parentWindow(&spHTMLWin2);	// this could be the frame set..
                    if(!FAILED(hr))
                    {
                        m_spBaseHTMLWindow = spHTMLWin2;			// cache it away .. (is this really needed?)
                        hr = LocateVidAndTriggerCtrls(&spDispVidCtrl, &spDispTrigCtrl);
                    } else {
                        m_spBaseHTMLWindow = NULL;
                        hr = S_FALSE;
                    }
                } else {
                    m_spBaseHTMLWindow = NULL;
                    hr = S_FALSE;
                }
            } else {
                m_spBaseHTMLWindow = NULL;
                hr = S_FALSE;
            }
        }
        
        // call regardless of above state - a NULL value will release currently cached value
        HookupTVEFeature(spDispVidCtrl);		// binds the m_spTVEFeature variable
        
        
        m_spTriggerCtrl = spDispTrigCtrl;
        
        if(hr == S_OK)
        {
            IMSVidCtlPtr spVidCtrl(spDispVidCtrl);
            ITVETriggerCtrlPtr spTrigCtrl(spDispTrigCtrl);
            
            TVEDebugLog((CDebugLog::DBG_NAVAID, 2, _T("Nav to Atvef page %s\n VidCtrl: 0x%08x TrigCtrl: 0x%08x"), bstrURL, spVidCtrl, spTrigCtrl));
        } else {
#ifndef _RUN_WITHOUT_VIDCTL
            m_spTriggerCtrl = NULL;		// for now, allow TriggerCtrl to live without VidCtrl
#endif
            put_TVEFeature(NULL);
            
            TVEDebugLog((CDebugLog::DBG_NAVAID, 2, _T("Nav to Non-Atvef page %s\n VidCtrl: 0x%08x TrigCtrl: 0x%08x"), bstrURL, spDispVidCtrl, spDispTrigCtrl));
        }
        
        // now execute our cached script (assuming the web page hasn't changed)
        
        {
            if(m_spbsNavTVEURL.Length() > 0 &&
                FSameURL(bstrURL, m_spbsNavTVEURL ))	
            {
                if(m_spbsNavTVEScript.Length() > 0)
                    hr = ExecScript(m_spbsNavTVEScript, L"JSCRIPT");
            }
        }
        
        // save our URL 
        if(m_spbsCurrTVEURL != bstrURL)
        {
            m_spbsCurrTVEURL = bstrURL;
        }

    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        hr = hrCatch;
    } catch(...) {
        hr = E_UNEXPECTED;
    }  
	return hr;
}

STDMETHODIMP CTVENavAid::NotifyStatusTextChange(BSTR Text)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyProgressChange(LONG Progress, LONG ProgressMax)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyCommandStateChange(LONG Command, VARIANT_BOOL Enable)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyDownloadBegin()
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyDownloadBegin"));
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyDownloadComplete()
{
	DBG_HEADER(CDebugLog::DBG_NAVAID, _T("CTVENavAid::NotifyDownloadComplete"));
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyTitleChange(BSTR Text)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyPropertyChange(BSTR szProperty)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyBeforeNavigate2(IDispatch * pDisp, VARIANT * URL, VARIANT * Flags, VARIANT * TargetFrameName, VARIANT * PostData, VARIANT * Headers, VARIANT_BOOL * Cancel)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyNewWindow2(IDispatch * * ppDisp, VARIANT_BOOL * Cancel)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyOnQuit()
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyOnVisible(VARIANT_BOOL Visible)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyOnToolBar(VARIANT_BOOL ToolBar)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyOnMenuBar(VARIANT_BOOL MenuBar)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyOnStatusBar(VARIANT_BOOL StatusBar)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyOnFullScreen(VARIANT_BOOL FullScreen)
{
	return S_OK;
}

STDMETHODIMP CTVENavAid::NotifyOnTheaterMode(VARIANT_BOOL TheaterMode)
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveservi.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEService.h : Declaration of the CTVEService

#ifndef __TVESERVICE_H_
#define __TVESERVICE_H_

#include "resource.h"       // main symbols
#include "TVEEnhans.h"
#include "TVESmartLock.h"

#include "TveAttrQ.h"		// expireQ
#include "TveAttrM.h"		// RandomProperty map
#include "TveDbg.h"

_COM_SMARTPTR_TYPEDEF(ITVEAttrTimeQ,		__uuidof(ITVEAttrTimeQ));
_COM_SMARTPTR_TYPEDEF(ITVEAttrMap,			__uuidof(ITVEAttrMap));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,		__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancements,		__uuidof(ITVEEnhancements));


/////////////////////////////////////////////////////////////////////////////
// CTVEService
class ATL_NO_VTABLE CTVEService : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTVEService, &CLSID_TVEService>,
	public ITVEService_Helper,
	public ISupportErrorInfo,
	public IDispatchImpl<ITVEService, &IID_ITVEService, &LIBID_MSTvELib>
{
public:
    CTVEService()
    {
        m_pSupervisor               = NULL;								// back pointer 
        m_spbsDescription           = L"Default TVE Service";
        
        m_dwAnncPort                = 0;
        m_spXOverEnhancement        = 0;
        m_dateExpireOffset          = 0.0;
        m_dwExpireQueueChangeCount  = 0;
        m_fIsActive                 = false;
    }

    HRESULT FinalConstruct()								// create internal objects
    {
        HRESULT hr;
        DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::FinalConstruct"));
        hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_spUnkMarshaler.p);
        if(FAILED(hr)) {
            _ASSERT(false);
            return hr;
        }
        
        CComObject<CTVEAttrTimeQ> *pExpireQueue;
        hr = CComObject<CTVEAttrTimeQ>::CreateInstance(&pExpireQueue);
        if(FAILED(hr))
            return hr;
        hr = pExpireQueue->QueryInterface(&m_spExpireQueue);			// typesafe QI
        if(FAILED(hr)) {
            delete pExpireQueue;
            return hr;
        }
        
        CComObject<CTVEAttrMap> *pMap;
        hr = CComObject<CTVEAttrMap>::CreateInstance(&pMap);
        if(FAILED(hr))
            return hr;
        hr = pMap->QueryInterface(&m_spamRandomProperties);			// typesafe QI
        if(FAILED(hr)) {
            delete pMap;
            return hr;
        }
        
        CComObject<CTVEEnhancements> *pEnhancements;
        hr = CComObject<CTVEEnhancements>::CreateInstance(&pEnhancements);
        if(FAILED(hr))
            return hr;
        hr = pEnhancements->QueryInterface(&m_spEnhancements);			// typesafe QI
        if(FAILED(hr)) {
            delete pEnhancements;
        }
        
        if(!FAILED(hr))
            hr = InitXOverEnhancement();
        return hr;
    }
    
    HRESULT FinalRelease();
    
DECLARE_REGISTRY_RESOURCEID(IDR_TVESERVICE)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVEService)
	COM_INTERFACE_ENTRY(ITVEService)
	COM_INTERFACE_ENTRY(ITVEService_Helper)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	CComPtr<IUnknown> m_spUnkMarshaler;
public:
	// ITVEService
	
	STDMETHOD(get_Parent)(/*[out, retval]*/ IUnknown* *pVal);
	STDMETHOD(get_Enhancements)(/*[out, retval]*/ ITVEEnhancements* *pVal);

	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Description)(/*[in]*/ BSTR newVal);

	STDMETHOD(get_XOverEnhancement)(/*out, retval*/ ITVEEnhancement **ppVal);	// special for tree views... (use get_XOverLinks)
	STDMETHOD(get_XOverLinks)(/*[out, retval]*/ ITVETracks* *pVal);				// ITVETracks collection
	STDMETHOD(NewXOverLink)(/*[in]*/ BSTR bstrLine21Trigger);
	STDMETHOD(get_ExpireOffset)(/*[out, retval]*/ DATE *pVal);
	STDMETHOD(put_ExpireOffset)(/*[in]*/ DATE newVal);
	STDMETHOD(get_ExpireQueue)(/*[out]*/ ITVEAttrTimeQ **ppVal);
	STDMETHOD(ExpireForDate)(/*[in]*/ DATE dateExpireTime);		// if DATE=0, use <NOW>-offset

	STDMETHOD(Activate)();
	STDMETHOD(Deactivate)();
	STDMETHOD(get_IsActive)(VARIANT_BOOL *fIsActive);

	STDMETHOD(put_Property)(/*[in]*/ BSTR bstrPropName, BSTR bstrPropVal);
	STDMETHOD(get_Property)(/*[in]*/ BSTR bstrPropName, /*[out, retval]*/  BSTR *pbstrPropVal);

	void Initialize(BSTR bstrDesc);		// debug

	// ITVEService_Helper
public:
	STDMETHOD(AddToExpireQueue)(/*[in]*/ DATE dateExpires, /*[in]*/ IUnknown *punkItem);
	STDMETHOD(ChangeInExpireQueue)(/*[in]*/ DATE dateExpires, /*[in]*/ IUnknown *punkItem);
	STDMETHOD(RemoveFromExpireQueue)(/*[in]*/ IUnknown *punkItem);
	STDMETHOD(RemoveEnhFilesFromExpireQueue)(/*[in]*/ ITVEEnhancement *pEnhItem);
	STDMETHOD(ConnectParent)(/*[in]*/ ITVESupervisor * pService);
	STDMETHOD(ParseCBAnnouncement)(/*[in]*/ BSTR bstrFileTrigAdapter,/*[in]*/ BSTR *pbstrBuff);				// parses announcement, creating a new enhancement if necessary
	STDMETHOD(SetAnncIPValues)(/*[in]*/ BSTR bstrAnncIPAdapter,/*[in]*/ BSTR bstrAnncIPAddress,/*[in]*/ LONG lAnncPort);
	STDMETHOD(GetAnncIPValues)(/*[out]*/ BSTR *pbstrAnncIPAdapter, /*[out]*/ BSTR *pbstrAnncIPAddress,/*[out]*/  LONG *plAnncPort);
	STDMETHOD(RemoveYourself)();
	STDMETHOD(DumpToBSTR)(/*[out]*/ BSTR *pbstrBuff);
	STDMETHOD(InitXOverEnhancement)();
															// to see if need to referesh the queue
	STDMETHOD(get_ExpireQueueChangeCount)(/*out, retval*/ long *plChangeCount)
		 	{*plChangeCount = m_dwExpireQueueChangeCount; return S_OK;}

	// public methods


	// private methods
private:


	CTVESmartLock		m_sLk;

private:
	ITVESupervisor				*m_pSupervisor;			// up tree pointer, no addref
	ITVEEnhancementsPtr			m_spEnhancements;		// down tree collection pointer
	ITVEEnhancementPtr			m_spXOverEnhancement;

	CComBSTR					m_spbsDescription;

	CComBSTR					m_spbsAnncIPAdapter;
	CComBSTR					m_spbsAnncIPAddr;
	DWORD						m_dwAnncPort;

	DATE						m_dateExpireOffset;	// offset of expire dates due to recording.
	ITVEAttrTimeQPtr			m_spExpireQueue;	// time based queue of objects to expire
	DWORD						m_dwExpireQueueChangeCount;
	BOOL						m_fIsActive;

	ITVEAttrMapPtr				m_spamRandomProperties;		// used in get/put_ Properties
};

#endif //__TVESERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvenavaid.h ===
// Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.
// TVENavAid.h : Declaration of the CTVENavAid
//


#ifndef __TVENAVAID_H_
#define __TVENAVAID_H_

#include "resource.h"       // main symbols
#include "TveSmartLock.h"

_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,		__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancements,			__uuidof(ITVEEnhancements));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement_Helper,	__uuidof(ITVEEnhancement_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEVariation_Helper,		__uuidof(ITVEVariation_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrack,				__uuidof(ITVETrack));
_COM_SMARTPTR_TYPEDEF(ITVETrack_Helper,			__uuidof(ITVETrack_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrigger,				__uuidof(ITVETrigger));
_COM_SMARTPTR_TYPEDEF(ITVETrigger_Helper,		__uuidof(ITVETrigger_Helper));

_COM_SMARTPTR_TYPEDEF(ITVETriggerCtrl,			__uuidof(ITVETriggerCtrl));
_COM_SMARTPTR_TYPEDEF(ITVETriggerCtrl_Helper,	__uuidof(ITVETriggerCtrl_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEFeature,				__uuidof(ITVEFeature));

_COM_SMARTPTR_TYPEDEF(IWebBrowserApp,			__uuidof(IWebBrowserApp));

_COM_SMARTPTR_TYPEDEF(ITVENavAid,			    __uuidof(ITVENavAid));
//_COM_SMARTPTR_TYPEDEF(ITVENavAidGITProxy,	    __uuidof(ITVENavAidGITProxy));

/////////////////////////////////////////////////////////////////////////////
// TVENavAidCacheState
//
//    Simple (blind) data structure to hold names of current NavAid state.
//    Used in get/put_CacheState() calls on tune events.
//    Clients should not know what's in this structure.
//    Should optimize to reduce total structure size.

struct TVENavAidCacheState
{
public:
	long  m_cBytes;								// sizeof the structure
	WCHAR m_wszCurrURL[MAX_PATH];
	WCHAR m_wszCurrName[MAX_PATH];
	WCHAR m_wszActiveVarMediaName[MAX_PATH];
	WCHAR m_wszActiveVarMediaTitle[MAX_PATH];
	WCHAR m_wszActiveEnhDesc[MAX_PATH];
	WCHAR m_wszActiveEnhUUID[MAX_PATH];
};


// --------------------------------------------------------
//  CTVENavAidGITProxy
//
//		Simple little holding object to hand out to internal objects
//		that want to refcount the NavAid (such as the GIT).
//		They refcount this one instead.  This avoid's internal refcounts
//		on the supervisor itself, letting client objects manage its
//		lifetime.
// --------------------------------------------------------
/*
class ATL_NO_VTABLE CTVENavAidGITProxy : 
	public CComObjectRootEx<CComMultiThreadModel>,	
//	public CComCoClass<CTVESupervisor, &CLSID_TVESupervisorGITProxy>,
	public ITVENavAidGITProxy
{
public:

DECLARE_GET_CONTROLLING_UNKNOWN()
//DECLARE_REGISTRY_RESOURCEID(IDR_TVENAVAIDGITPROXY)

BEGIN_COM_MAP(CTVENavAidGITProxy)
	COM_INTERFACE_ENTRY(ITVENavAidGITProxy)
END_COM_MAP()

public:
	CTVENavAidGITProxy()
	{
		m_pTVENavAid = NULL;
	}

	~CTVENavAidGITProxy()
	{
		m_pTVENavAid = NULL;
	}
	
	STDMETHOD(get_NavAid)(ITVENavAid **ppTVENavAid)
	{
		if(NULL == ppTVENavAid)
			return E_POINTER;

		if(NULL != m_pTVENavAid)
		{
			*ppTVENavAid = m_pTVENavAid;
			(*ppTVENavAid)->AddRef();
			return S_OK;
		} else {
			*ppTVENavAid = NULL;
			return E_FAIL;
		}
	}

	STDMETHOD(put_NavAid)(ITVENavAid *pTVENavAid)
	{
	
		m_pTVENavAid = pTVENavAid;
		return S_OK;
	}
private:
	ITVENavAid		*m_pTVENavAid;
};
*/
/////////////////////////////////////////////////////////////////////////////
// CTVENavAid

class ATL_NO_VTABLE CTVENavAid : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTVENavAid, &CLSID_TVENavAid>,
	public ITVENavAid_Helper,
	public ITVENavAid_NoVidCtl,
	public ISupportErrorInfo,
	public IDispatchImpl<ITVENavAid, &IID_ITVENavAid, &LIBID_MSTvELib>
{
public:
	CTVENavAid()
	{
		m_lAutoTriggers		= 0x01;		// bit field, only using the bottom bit so far...
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVENAVAID)

DECLARE_PROTECT_FINAL_CONSTRUCT()
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CTVENavAid)
	COM_INTERFACE_ENTRY(ITVENavAid)
	COM_INTERFACE_ENTRY(ITVENavAid_Helper)
	COM_INTERFACE_ENTRY(ITVENavAid_NoVidCtl)
	COM_INTERFACE_ENTRY(IDispatch)
//	COM_INTERFACE_ENTRY2(IDispatch, ITVENavAid)
	COM_INTERFACE_ENTRY_IID(DIID__ITVEEvents, IDispatch)	// input event sink (where are the IE events?)

	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
END_COM_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	CComPtr<IUnknown> m_spUnkMarshaler;                     // free threaded marsheller...

	HRESULT FinalConstruct();
	HRESULT FinalRelease();

// ITVENavAid
	STDMETHOD(put_WebBrowserApp)(/*[in]*/ IDispatch *pWebBrowser);
//	STDMETHOD(get_WebBrowserApp)(/*[out, retval]*/ IWebBrowserAppPtr **ppWebBrowser);
	STDMETHOD(get_WebBrowserApp)(/*[out, retval]*/ IDispatch **ppWebBrowser);
	STDMETHOD(get_TVETriggerCtrl)(/*[out, retval]*/ ITVETriggerCtrl **ppTriggerCtrl);
	STDMETHOD(put_ActiveVariation)(/*[in]*/ ITVEVariation *pActiveVariation);
	STDMETHOD(get_ActiveVariation)(/*[out, retval]*/ ITVEVariation **ppActiveVariation);
	STDMETHOD(put_EnableAutoTriggering)(/*[in]*/ long lAutoTriggers);
	STDMETHOD(get_EnableAutoTriggering)(/*[out, retval]*/ long *plAutoTriggers);
	STDMETHOD(get_TVEFeature)(/*[out, retval]*/ ITVEFeature **ppTVEFeature);

	STDMETHOD(get_CacheState)(/*[out, retval]*/ BSTR *pbstrBuff);		// data disquised in a string
	STDMETHOD(put_CacheState)(/*[in]*/ BSTR bstrBuff);

	STDMETHOD(NavUsingTVETrigger)(/*[in]*/ ITVETrigger *pTrigger, /*[in]*/ long lForceNav, /*[in]*/ long lForceExec);
	STDMETHOD(ExecScript)(/*[in]*/ BSTR bstrScript, /*[in]*/ BSTR bstrLanguage);
	STDMETHOD(Navigate)(/*[in]*/ VARIANT *URL, /*[in]*/ VARIANT *Flags, /*[in]*/ VARIANT *TargetFrameName, /*[in]*/ VARIANT *PostData,/*[in]*/ VARIANT *Headers);

	STDMETHOD(get_CurrTVEName)(/*[out, retval]*/ BSTR *pbstrName);          // return current values... useful for debugging NavAid state
	STDMETHOD(get_CurrTVEURL)(/*[out, retval]*/ BSTR *pbstrURL);


// ITVENavAid_NoVidCtl
	STDMETHOD(put_NoVidCtl_Supervisor)(/*[in]*/ ITVESupervisor *pSuper);	
	STDMETHOD(get_NoVidCtl_Supervisor)(/*[out, retval]*/ ITVESupervisor **ppSuper);	

// ITVENavAid_Helper
//	STDMETHOD(LocateVidAndTriggerCtrls)(/*[out]*/ IMSVidCtrl **pVidCtrl, /*[out]*/ ITVETriggerCtrl **pVidCtrl);
	STDMETHOD(LocateVidAndTriggerCtrls)(/*[out]*/ IDispatch **pVidCtrl, /*[out]*/ IDispatch **pTrigCtrl);
	STDMETHOD(NotifyTVETriggerUpdated_XProxy)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive, /*[in]*/ long lChangedFlags);	
	STDMETHOD(ReInitCurrNavState)(/*[in]*/ long lReserved);                    // dwReserved must be 0

// _ITVEEvents
	STDMETHOD(NotifyTVETune)(/*[in]*/ NTUN_Mode tuneMode,/*[in]*/ ITVEService *pService,/*[in]*/ BSTR bstrDescription,/*[in]*/ BSTR bstrIPAdapter);
	STDMETHOD(NotifyTVEEnhancementNew)(/*[in]*/ ITVEEnhancement *pEnh);
		// changedFlags : NENH_grfDiff
	STDMETHOD(NotifyTVEEnhancementUpdated)(/*[in]*/ ITVEEnhancement *pEnh, /*[in]*/ long lChangedFlags);	
	STDMETHOD(NotifyTVEEnhancementStarting)(/*[in]*/ ITVEEnhancement *pEnh);
	STDMETHOD(NotifyTVEEnhancementExpired)(/*[in]*/ ITVEEnhancement *pEnh);
	STDMETHOD(NotifyTVETriggerNew)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive);
		// changedFlags : NTRK_grfDiff
	STDMETHOD(NotifyTVETriggerUpdated)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive, /*[in]*/ long lChangedFlags);	
	STDMETHOD(NotifyTVETriggerExpired)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive);
	STDMETHOD(NotifyTVEPackage)(/*[in]*/ NPKG_Mode engPkgMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUUID, /*[in]*/ long  cBytesTotal, /*[in]*/ long  cBytesReceived);
	STDMETHOD(NotifyTVEFile)(/*[in]*/ NFLE_Mode engFileMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUrlName, /*[in]*/ BSTR bstrFileName);
		// WhatIsIt : NWHAT_Mode - lChangedFlags : NENH_grfDiff or NTRK_grfDiff treated as error bits
	STDMETHOD(NotifyTVEAuxInfo)(/*[in]*/ NWHAT_Mode enAuxInfoMode, /*[in]*/ BSTR bstrAuxInfoString, /*[in]*/ long lChangedFlags, /*[in]*/ long lErrorLine);	


// DWebBrowserEvents2
	STDMETHOD(NotifyStatusTextChange)(BSTR Text);
	STDMETHOD(NotifyProgressChange)(LONG Progress, LONG ProgressMax);
	STDMETHOD(NotifyCommandStateChange)(LONG Command, VARIANT_BOOL Enable);
	STDMETHOD(NotifyDownloadBegin)();
	STDMETHOD(NotifyDownloadComplete)();
	STDMETHOD(NotifyTitleChange)(BSTR Text);
	STDMETHOD(NotifyPropertyChange)(BSTR szProperty);
	STDMETHOD(NotifyBeforeNavigate2)(IDispatch * pDisp, VARIANT * URL, VARIANT * Flags, VARIANT * TargetFrameName, VARIANT * PostData, VARIANT * Headers, VARIANT_BOOL * Cancel);
	STDMETHOD(NotifyNewWindow2)(IDispatch * * ppDisp, VARIANT_BOOL * Cancel);
	STDMETHOD(NotifyNavigateComplete2)(IDispatch * pDisp, VARIANT * URL);
	STDMETHOD(NotifyDocumentComplete)(IDispatch * pDisp, VARIANT * URL);
	STDMETHOD(NotifyOnQuit)();
	STDMETHOD(NotifyOnVisible)(VARIANT_BOOL Visible);
	STDMETHOD(NotifyOnToolBar)(VARIANT_BOOL ToolBar);
	STDMETHOD(NotifyOnMenuBar)(VARIANT_BOOL MenuBar);
	STDMETHOD(NotifyOnStatusBar)(VARIANT_BOOL StatusBar);
	STDMETHOD(NotifyOnFullScreen)(VARIANT_BOOL FullScreen);
	STDMETHOD(NotifyOnTheaterMode)(VARIANT_BOOL TheaterMode);
public:

private:
	HRESULT LocateVidAndTriggerCtrls2(IHTMLWindow2 *spBaseHTMLWindow, IDispatch **ppVidCtrl, IDispatch **ppTrigCtrl);
	HRESULT HookupTVEFeature(IDispatch *ppVidCtrl);						// hookup the TVE Feature event sink

	HRESULT DoFixURL(BSTR bstrIn, BSTR *pbstrOut);								// cleans up URL
	HRESULT	SetDefaultActiveVariation(ITVEService *pService);					// sets to first variation of first enhancement with primary bit set
	HRESULT FDoAutoBrowse(ITVETrigger *pTrigger);								// determine if allowed to autobrowse on this trigger
	HRESULT DoNavigateAndExecScript(ITVETrigger *pTrigger, long lForceNav);	    // navigate to URL in this trigger, >>>then<<< run script
	HRESULT DoExecuteScript(ITVETrigger *pTrigger);								// just execute the triggers script

	HRESULT CacheTriggerToExecAfterNav(ITVETrigger *pTrigger);

	HRESULT put_TVEFeature(/*[in]*/ ITVEFeature *pTVEFeature);

	CTVESmartLock		m_sLk;
 
	long				m_lAutoTriggers;		// if 1, do auto triggering
	IHTMLWindow2Ptr		m_spBaseHTMLWindow;
	IWebBrowserAppPtr	m_spWebBrowser;			// non ref-counted back pointer
	ITVETriggerCtrlPtr	m_spTriggerCtrl;		// ref-counted down-pointer
	ITVEFeaturePtr		m_spTVEFeature;			// ref-counted down-pointer

	DWORD				m_dwEventsWebBrowserCookie;
	DWORD				m_dwEventsTveSuperCookie;		// eventually get rid of this and ony use FeatureCookie
	DWORD				m_dwEventsTveFeatureCookie;

	DWORD				m_dwEventsFakeTveSuperCookie;	// temp - needed to debug without the VidCtl


	ITVESupervisorPtr	m_spNoVidCtlSuper;			// (see _RUN_WITHOUT_VIDCTL)

	CComPtr<IGlobalInterfaceTable>	m_spIGlobalInterfaceTable;
	DWORD				m_dwNavAidGITCookie;

			// UI state
	ITVEServicePtr		m_spCurrTVEService;
	ITVEVariationPtr	m_spActiveVariation;		// active variation for AutoNav

	CComBSTR			m_spbsCurrTVEName;			// trigger 'name'
	CComBSTR			m_spbsCurrTVEURL;			// URL returned after the 'Nav' call..
	
	CComBSTR			m_spbsNavTVEURL;			// used when navigating, cached right before the 'Nav' call
	CComBSTR			m_spbsNavTVEScript;			//  internal script executed on Document Complete
	CComBSTR			m_spbsNavTVESourceID;		//  enhancment UUID -> triggerctrl's SourceID
};

#endif //__TVENAVAID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveservi.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEService.cpp : Implementation of CTVEService
//
// ------------------------------------------------------------------------------------
//	fMajorUpdate hack alert!
//
//		An annoucement can be sent that mostly matches a previous annoucement, but
//		has 'major' changes, it's called a MajorUpdate in this code.  Reasons for it
//		are:
//			IP adapter, addresses or ports on trigger of file changed.
//			Number of variations changed 
//		Code for handling a major update is not robust in this version.  Instead
//		of trying to keep as much existing state information as possible, the old
//		enhancement is simply deleted and a new one is created in it's place.  Not correct, but simple.
//		Search for 'fMajorUpdate' string in the code...
//		
//
// ------------------------------------------------------------------------------------
#include "stdafx.h"
#include "MSTvE.h"
#include "TVEServi.h"
#include "TVEEnhan.h"
#include <stdio.h> 
#include "TveDbg.h"

#include "TVECBAnnc.h"		// multicast callback objects
#include "TVECBDummy.h"

#include "dbgstuff.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
// -------------------------------------------------------------------------
static DATE 
DateNow()
{		SYSTEMTIME SysTimeNow;
		GetSystemTime(&SysTimeNow);									// initialize with currrent time.
		DATE dateNow;
		SystemTimeToVariantTime(&SysTimeNow, &dateNow);
		return dateNow;
}

/////////////////////////////////////////////////////////////////////////////
// ITVEService_Helper

_COM_SMARTPTR_TYPEDEF(ITVEMCastManager,			__uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCast,				__uuidof(ITVEMCast));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement_Helper,	__uuidof(ITVEEnhancement_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEVariations,			__uuidof(ITVEVariations));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));

_COM_SMARTPTR_TYPEDEF(ITVECBAnnc,				__uuidof(ITVECBAnnc));
_COM_SMARTPTR_TYPEDEF(ITVECBDummy,				__uuidof(ITVECBDummy));


_COM_SMARTPTR_TYPEDEF(ITVETrack,				__uuidof(ITVETrack));
_COM_SMARTPTR_TYPEDEF(ITVETracks,				__uuidof(ITVETracks));
_COM_SMARTPTR_TYPEDEF(ITVETrigger,				__uuidof(ITVETrigger));


// ------------------------------------------------------------------------------------------
HRESULT 
CTVEService::FinalRelease()
{
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::FinalRelease"));
	HRESULT hr = S_OK;

										// null out children's parent pointers
	{
		long cEnhancements;
		hr = m_spEnhancements->get_Count(&cEnhancements);
		if(S_OK == hr) 
		{
			for(int iEnhc = 0; iEnhc < cEnhancements; iEnhc++)
			{
				CComVariant cv(iEnhc);
				ITVEEnhancementPtr spEnhc;
				hr = m_spEnhancements->get_Item(cv, &spEnhc);
				_ASSERT(S_OK == hr);
				ITVEEnhancement_HelperPtr spEnhcHelper(spEnhc);
				spEnhcHelper->ConnectParent(NULL);
			}
		}
	}

	m_spExpireQueue->RemoveAll();

	m_spExpireQueue = NULL;
	m_pSupervisor = NULL;
	m_spEnhancements = NULL;
	m_spXOverEnhancement = NULL;

	m_spUnkMarshaler = NULL;
	return S_OK;
}

//---------------------------------------------------------
// ITVEService_Helper
//
//  ConnectParent()


STDMETHODIMP CTVEService::ConnectParent(ITVESupervisor *pSupervisor)
{
	if(!pSupervisor) return E_POINTER;
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::ConnectParent"));

    CSmartLock spLock(&m_sLk);
	m_pSupervisor = pSupervisor;		// not smart pointer add ref here, I hope.
	return S_OK;
}

STDMETHODIMP CTVEService::RemoveYourself()
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::RemoveYourself"));
	
	CSmartLock spLock(&m_sLk);

	if(NULL == m_pSupervisor) {
		return S_FALSE;
	}
	
	CComPtr<ITVEServices> spServices;
	hr = m_pSupervisor->get_Services(&spServices);
	if(S_OK == hr) {
		ITVEServicePtr	spServiceThis(this);
		IUnknownPtr		spPunkThis(spServiceThis);
		CComVariant		cvThis((IUnknown *) spPunkThis);

		hr = spServices->Remove(cvThis);			// remove the ref-counted down pointer from the collection
	}
	
					// for lack of anything else, send a bogus method...
	ITVESupervisor_HelperPtr spSuperHelper = m_pSupervisor;
    if(spSuperHelper) 
    {
        CComBSTR spbsBuff;
        spbsBuff.LoadString(IDS_AuxInfo_ServiceRemoved); // L"Service Being Removed"		
        spSuperHelper->NotifyAuxInfo(NWHAT_Announcement,spbsBuff , 0, 0);
    }
	

	m_pSupervisor = NULL;							// remove the non ref-counted up pointer
		
	return S_OK;
}

STDMETHODIMP CTVEService::AddToExpireQueue(/*[in]*/ DATE dateExpires, /*[in]*/ IUnknown *punkItem)
{
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::AddToExpireQueue"));
	if(NULL == punkItem)				// needs to be valid...
		return E_POINTER;

	CSmartLock spLock(&m_sLk);

	if(dateExpires > 0.0 && dateExpires < 100.0)				// relative date hack  - if small (<100?), treat as days relative offset of days from now
		dateExpires += DateNow();					

	if(dateExpires + m_dateExpireOffset < DateNow())
	{
			// already expired... But do nothing since we still want to remove it
	}
	if(NULL == m_spExpireQueue)
		return E_NOTIMPL;
//	IUnknownPtr spPunk(punkItem);		// just to make sure get the IUnknown  pointer (sometimes users don't do this for us)
	CComPtr<IUnknown> spPunk(punkItem);

	HRESULT hr = m_spExpireQueue->Add(dateExpires, (IUnknown *)  spPunk);
	if(!FAILED(hr))
		m_dwExpireQueueChangeCount++;
	return hr;
}



STDMETHODIMP CTVEService::ChangeInExpireQueue(/*[in]*/ DATE dateExpires, /*[in]*/ IUnknown *punkItem)
{
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::ChangeInExpireQueue"));
	if(NULL == punkItem)				// needs to be valid...
		return E_POINTER;

	CSmartLock spLock(&m_sLk);

	if(dateExpires > 0.0 && dateExpires < 100.0)				// relative date hack  - if small (<100?), treat as days relative offset of days from now
		dateExpires += DateNow();					

	if(dateExpires + m_dateExpireOffset < DateNow())
	{
			// already expired... But do nothing since we still want to remove it
	}
	if(NULL == m_spExpireQueue)
		return E_NOTIMPL;
	CComPtr<IUnknown> spPunk(punkItem);
											// change the expire time of the item (move it around).
	HRESULT hr = m_spExpireQueue->Update(dateExpires, (IUnknown *)  spPunk);
	if(!FAILED(hr))
		m_dwExpireQueueChangeCount++;
	return hr;
}

STDMETHODIMP CTVEService::RemoveFromExpireQueue(/*[in]*/ IUnknown *punkItem)
{
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::RemoveFromExpireQueue"));
	if(NULL == punkItem)				// needs to be valid...
		return E_POINTER;


	CSmartLock spLock(&m_sLk);
										// just to make sure get the IUnknown  pointer (sometimes users don't do this for us)
	IUnknownPtr spPunk(punkItem);
	CComVariant cvPunk((IUnknown *) spPunk);

	HRESULT hr = m_spExpireQueue->Remove(cvPunk);		// returns S_FALSE if it isn't there to remove
	if(S_OK == hr)
		m_dwExpireQueueChangeCount++;
	return hr;
}

		// remove files that reference the given enhancement from the Expire Queue
		//   needed because the enhancement may be kicked out of the queue before
		//   any of the files that reference it..
		//
		// do the same for triggers
STDMETHODIMP 
CTVEService::RemoveEnhFilesFromExpireQueue(/*[in]*/ ITVEEnhancement *pEnh)
{
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::RemoveEnhFilesFromExpireQueue"));
	if(NULL == pEnh)				// needs to be valid...
		return E_POINTER;
	
	HRESULT hr = S_OK;
	IUnknownPtr spPunkEnh(pEnh);

	CSmartLock spLock(&m_sLk);

	long cItems;
	m_spExpireQueue->get_Count(&cItems);
	for(int i = cItems-1; i >= 0; --i)
	{
		CComVariant cv(i);
		IUnknownPtr spPunk;
		m_spExpireQueue->get_Item(cv, &spPunk);
		ITVEFilePtr spFile(spPunk);				// try QI to see if its a File object
		if(spFile)
		{
			ITVEVariationPtr spFileVar;
			spFile->get_Variation(&spFileVar);
			IUnknownPtr spPunkFileEnh;
			spFileVar->get_Parent(&spPunkFileEnh);		// if file's Enh matches the one passed in,
			if(spPunkFileEnh == spPunkEnh)				//    remove it out of the expire queue...
			{
				hr = m_spExpireQueue->Remove(cv);
				if(S_OK == hr)
					m_dwExpireQueueChangeCount++;
			}
		} else {
														// also need to remove triggers..
			ITVETriggerPtr spTrig(spPunk);
			if(spTrig)
			{											// find pUnk of enhancement for this trigger
				IUnknownPtr spPunkTrigTrack;
				hr = spTrig->get_Parent(&spPunkTrigTrack);
				if(!FAILED(hr) && NULL != spPunkTrigTrack)
				{
					ITVETrackPtr  spTrigTrack(spPunkTrigTrack);
					_ASSERT(spTrigTrack != NULL);
					if(NULL !=  spTrigTrack)
					{
						IUnknownPtr spPunkTrigVar;
						hr = spTrigTrack->get_Parent(&spPunkTrigVar);
						if(!FAILED(hr) && NULL != spPunkTrigVar)
						{
							ITVEVariationPtr spTrigVar(spPunkTrigVar);
							_ASSERT(NULL !=  spTrigVar);
							if(NULL !=  spTrigVar)
							{
								IUnknownPtr spPunkTrigEnh;
								hr = spTrigVar->get_Parent(&spPunkTrigEnh);
								if(!FAILED(hr))
								{
															// is this trigger's enhancement the one we are looking for ?
									if(spPunkEnh == spPunkTrigEnh)					
									{						//    remove it out of the expire queue...

										hr = m_spExpireQueue->Remove(cv);
										if(S_OK == hr)
											m_dwExpireQueueChangeCount++;

									}
								}
							}
						}
					}
				}
			}
		}										
	}
	return hr;
}
// --------------------------------------------------------

//	Activate()		-- creates and join's the multicast for this service 
//	Deactivate()	-- unjoin's and 
// --------------------------------------------------------

STDMETHODIMP CTVEService::Activate()
{
	USES_CONVERSION;
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::Activate"));

	HRESULT hr = S_OK;
	_ASSERT(NULL != m_pSupervisor);
    if(NULL == m_pSupervisor){
        return E_INVALIDARG;
    }

	ITVESupervisor_HelperPtr	spSuperHelper(m_pSupervisor);
	ITVEMCastManagerPtr spMCM;
	hr = spSuperHelper->GetMCastManager(&spMCM);
	if(FAILED(hr))
		return hr;

	CSmartLock spLock(&m_sLk);

	CComBSTR spbstrFileTrigAdapter = m_spbsAnncIPAdapter;			// change if eventually want to read from different adapter
								// look for the multicast, is it there???
	long cMatches;
	ITVEMCastPtr spMCastMatch;
	hr = spMCM->FindMulticast(m_spbsAnncIPAdapter, m_spbsAnncIPAddr, m_dwAnncPort, &spMCastMatch, &cMatches);
	if(FAILED(hr))
		return hr;

//	_ASSERT(S_FALSE == hr);		// error...
	if(S_OK == hr) 
		return S_OK;
	
	ITVECBAnncPtr spCBAnncPtr;							// create the announcement callback
	CComObject<CTVECBAnnc> *pAnnc;
	hr = CComObject<CTVECBAnnc>::CreateInstance(&pAnnc);
	if(FAILED(hr))
		return hr;
	hr = pAnnc->QueryInterface(&spCBAnncPtr);
	if(FAILED(hr)) {
		delete pAnnc;
		return hr;
	}
/*
	ITVECBDummyPtr spCBDummyPtr;						// create a dummy callback that just logs announcements (for fun!)
	CComObject<CTVECBDummy> *pDummy;
	hr = CComObject<CTVECBDummy>::CreateInstance(&pDummy);
	if(FAILED(hr))
		return hr;
	hr = pDummy->QueryInterface(&spCBDummyPtr);		
	if(FAILED(hr)) {
		delete pDummy;
		return hr;
	}	
*/

								// bind the announcement node callback's back to this service
	ITVEServicePtr spServiceThis(this);
	// needed ??? spServiceThis->AddRef();					// WARNING ???
	hr = spCBAnncPtr->Init(spbstrFileTrigAdapter, spServiceThis);

								// add the callback to the list being managed by the supervisor
	ITVEMCastPtr spMCAnnc;
	if(!FAILED(hr)) 
	{									// 0 cbuffers mean use the default...
		const int kAnncCbuffers = 0;
		hr = spMCM->AddMulticast(NWHAT_Announcement, m_spbsAnncIPAdapter, m_spbsAnncIPAddr, m_dwAnncPort, kAnncCbuffers, spCBAnncPtr,  &spMCAnnc);
		if(!FAILED(hr) && DBG_FSET(CDebugLog::DBG_SERVICE)) 
		{
			WCHAR wszBuff[256];
			swprintf(wszBuff,L"Added Annc MCast %s:%d on %s\n",m_spbsAnncIPAddr,m_dwAnncPort,m_spbsAnncIPAdapter);
			DBG_WARN(CDebugLog::DBG_SERVICE, W2T(wszBuff));
		} else if ((S_FALSE == hr) && DBG_FSET(CDebugLog::DBG_SERVICE)) {
			WCHAR wszBuff[256];
			swprintf(wszBuff,L"Already Added Annc MCast %s:%d on %s\n",m_spbsAnncIPAddr,m_dwAnncPort,m_spbsAnncIPAdapter);
			DBG_WARN(CDebugLog::DBG_SERVICE, W2T(wszBuff));
		} else if(FAILED(hr)) {
			DBG_WARN(CDebugLog::DBG_SEV2, _T("Failed To Create New Announcement Service"));
		}
	}
//	if(!FAILED(hr))
//		spMCM->AddRef();			// NOTE1

	if(!FAILED(hr))
		hr = spMCAnnc->Join();		// join the announcement multicast...

	if(FAILED(hr))
	{
		DBG_WARN(CDebugLog::DBG_SEV2, _T("Failed To Join Multicast"));
		return hr;
	}


	/// -- if have existing variations, need to activate them now 
	long cEnhancements;
	m_spEnhancements->get_Count(&cEnhancements);
	for(int iEnhc = 0; iEnhc < cEnhancements; iEnhc++)
	{
		CComVariant cv(iEnhc);
		ITVEEnhancementPtr spEnhc;
		hr = m_spEnhancements->get_Item(cv, &spEnhc);
		_ASSERT(S_OK == hr);
		ITVEEnhancement_HelperPtr spEnhcHelper(spEnhc);
		hr = spEnhcHelper->Activate();				// activate each enhancement, re-creating muticast listeners from each variation
		_ASSERT(S_OK == hr);
	}

	if(hr == S_OK)
		m_fIsActive = true;

	return hr;
}


	// returns S_FALSE if the service wasn't activated
STDMETHODIMP CTVEService::Deactivate()
{
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::Deactivate"));

	HRESULT hr = S_OK;
	_ASSERT(NULL != m_pSupervisor);
    if(NULL == m_pSupervisor){
        return E_INVALIDARG;
    }
	ITVESupervisor_HelperPtr	spSuperHelper(m_pSupervisor);
	ITVEMCastManagerPtr spMCM;
	hr = spSuperHelper->GetMCastManager(&spMCM);

	CSmartLock spLock(&m_sLk);		// service lock...

				// look for the announcement multicast, is it there???
	BOOL fLocked = false;
	try {
		spMCM->Lock_();					// multicast manager lock	- may throw...
		fLocked = true;

		long cMatches;
		ITVEMCastPtr spMCastMatch;
		hr = spMCM->FindMulticast(m_spbsAnncIPAdapter, m_spbsAnncIPAddr, m_dwAnncPort, &spMCastMatch, &cMatches);

										// -- S_FALSE - wasn't actually activated
		if(S_OK == hr)
		{
			hr = spMCM->RemoveMulticast(spMCastMatch);			// remove the announcement multicast listener
			_ASSERT(S_OK == hr);

			long cEnhancements;
			m_spEnhancements->get_Count(&cEnhancements);
			for(int iEnhc = 0; iEnhc < cEnhancements; iEnhc++)
			{
				CComVariant cv(iEnhc);
				ITVEEnhancementPtr spEnhc;
				hr = m_spEnhancements->get_Item(cv, &spEnhc);
				_ASSERT(S_OK == hr);
				ITVEEnhancement_HelperPtr spEnhcHelper(spEnhc);
				hr = spEnhcHelper->Deactivate();				// deactivate each enhancement, removing muticast listeners from each variation
				_ASSERT(S_OK == hr);
			}
		}

	//	spMCM->Release();		// release extra count on the Mulitcast Manager.. (NOTE1)

	} catch (HRESULT hrCatch) {
		_ASSERT(false);
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
		_ASSERT(false);
	}
	if(fLocked)
		spMCM->Unlock_();			// MCast Manager unlock...
								// service unlock in the destructor

	if(hr == S_OK)
		m_fIsActive = false;

	return hr;
}

			// returns wether this service is marked active or not
STDMETHODIMP CTVEService::get_IsActive(VARIANT_BOOL *fIsActive)
{
//	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::get_IsActive"));

	HRESULT hr = S_OK;
	if(NULL == fIsActive)
		return E_POINTER;
	try {
		*fIsActive = m_fIsActive ? VARIANT_TRUE : VARIANT_FALSE;
	} catch (HRESULT hrCatch) {
		_ASSERT(false);
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED; 
	}
	return hr;
}

STDMETHODIMP CTVEService::SetAnncIPValues(BSTR bstrAnncIPAdapter, BSTR bstrAnncIPAddress, long lAnncPort)
{
	CSmartLock spLock(&m_sLk);

	m_spbsAnncIPAdapter = bstrAnncIPAdapter;
	m_spbsAnncIPAddr    = bstrAnncIPAddress;
	m_dwAnncPort		= (DWORD) lAnncPort;
	return S_OK;
}

STDMETHODIMP CTVEService::GetAnncIPValues(BSTR *pbstrAnncIPAdapter, BSTR *pbstrAnncIPAddress, LONG *plAnncPort)
{
	CSmartLock spLock(&m_sLk);

	m_spbsAnncIPAdapter.CopyTo(pbstrAnncIPAdapter);
	m_spbsAnncIPAddr.CopyTo(pbstrAnncIPAddress);
	*plAnncPort = (LONG) m_dwAnncPort;
	return S_OK;
}
// --------------------------------------------------------
//		Callback - ParseCBAnnouncement.
//			- Takes a string giving the IP adapter (IP address) for the file and trigger receivers
//			- Takes an string containing an announcement
//			- Parses the data fields out of it (converts it to an enhancement)
//			- Looks in list of existing enhancements under this service to see if its already there
//				-- matches on 
//					1) SAP header originating source 
//					2) SAP header MsgIDHash				- if not zero
//					3) Announcement SID and Version		
//			- If its a new announcement, 
//				 1) creates a new enhancement object to contain it
//				 2) creates the multicast readers for the trigger/file streams for all variations
//					of the enhancement
//				 3) joins those multicasts.
//				 4) Sends an event indicating a new or changed announcement.
//
STDMETHODIMP CTVEService::ParseCBAnnouncement(BSTR bstrFileTrigAdapter, BSTR *pbstrAnnc)
{
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::ParseCBAnnouncement"));

	HRESULT hr = S_OK;
	if(!pbstrAnnc) return E_POINTER;

	CSmartLock spLock(&m_sLk);

	IUnknownPtr			   spUnk;
	get_Parent(&spUnk);
	_ASSERT(NULL !=spUnk);
	ITVESupervisor_HelperPtr	   spTVESuperHelper(spUnk);
	_ASSERT(NULL != spTVESuperHelper);

	ITVEMCastManagerPtr		spMCM;
	spTVESuperHelper->GetMCastManager(&spMCM);

	ITVEEnhancementPtr spTVEEnhParsed;
				// spTVEEnhParsed = ITVEEnhancementPtr(CLSID_TVEEnhancement); // doesn't work this way in Multithreads...

	CComObject<CTVEEnhancement> *pEnhancement;
	hr = CComObject<CTVEEnhancement>::CreateInstance(&pEnhancement);
	if(FAILED(hr))
		return hr;
	hr = pEnhancement->QueryInterface(&spTVEEnhParsed);			// typesafe QI
	if(FAILED(hr)) {
		delete pEnhancement;
		return hr;
	}
																// biggie... creates new data structure down to variation level
	long lgrfParseError=0;
	long lLineError=0;
	hr = spTVEEnhParsed->ParseAnnouncement(bstrFileTrigAdapter, pbstrAnnc, &lgrfParseError, &lLineError);

                                                                // at this point, haven't looked at
                                                                //   expire time

            // what we really want here is someway to tell the user the show has expired, a way for them
            //  to adjust the date ...if they want to..., and then to continue on with further processing.
            // However, just added code to Parser to check for old stop dates, and if so, move them to Now+1/2 hour.
    if(!FAILED(hr))
    {
        DATE dateStop = DateNow() + 1.0;                        // 1 day, of course not really needed...
        hr = spTVEEnhParsed->get_StopTime(&dateStop);
        _ASSERT(!FAILED(hr));

		if(DateNow() > dateStop + m_dateExpireOffset)
		{
			lgrfParseError |= NENH_grfStopTime;
			hr = E_INVALIDARG;
			if(lLineError == 0)						            // if expired, simply put date to end of the string (should do better calc...)
				lLineError = 999;                               // wrong line number for end-time, but would else have to parse for it...
		}
	}

	if(FAILED(hr))
	{

		WCHAR *pwString = (WCHAR *) *pbstrAnnc;				// see CTVEEnhancement::ParseSAPHeader

					// skip over zero bytes in SAP header - else crashes the string 
		if(pwString)
		{
			BYTE   ucSAPHeaderBits = (BYTE) *pwString; pwString++;
			BYTE   ucSAPAuthLength = (BYTE) *pwString; pwString++;		// number of 32bit words that contain Auth data
			USHORT usSAPMsgIDHash = (USHORT) (*pwString | ((*(pwString+1))<<8));  pwString+=2;
			ULONG  ulSAPSendingIP = *(pwString+0) | ((*(pwString+1))<<8) | ((*(pwString+2))<<16)| ((*(pwString+3))<<24); pwString += 4;
			pwString += ucSAPAuthLength;
		}

        CComBSTR spbsBuff;
        spbsBuff.LoadString(IDS_AuxInfo_NoData);	// L"<*** No Data ***>"	
		hr = spTVESuperHelper->NotifyAuxInfo(NWHAT_Announcement, 
										   pwString ? pwString : spbsBuff ,  // note - does the deref here!
										   lgrfParseError, lLineError);
		return S_FALSE;
	}

	ITVEEnhancement_HelperPtr spEnhancementHelper(spTVEEnhParsed);
#ifdef _DEBUG
/*		CComBSTR bstrTemp;
		spEnhancementHelper->DumpToBSTR(&bstrTemp);
		bstrTemp.Append("----------------------------------------------\n\n");
		ATLTRACE_ALL(bstrTemp); */
#endif

		// look for this enhancement in the list of ones we have available...

	long cEnhns;
	long iEnhn = 0;
	ITVEEnhancementPtr spEnh;
	BOOL fMatch = false;
	BOOL fExactMatch = false;

	BOOL fMajorUpdate = false;
	BOOL fBrandNew = false;

	BOOL fUseSAPStuff = false;		// set to true if use SAP parameters

	hr = m_spEnhancements->get_Count(&cEnhns);
	if(FAILED(hr)) return hr;

				//if any current enhancements, need to see if new one is a resend
	CComBSTR spbsPSAPSendingIP;
	LONG  lPSAPMsgID;

	CComBSTR spbsPSessionName;
	CComBSTR spbsPSessionIPAddress;
	CComBSTR spbsPSessionUUID;
	LONG     lPSessionID;
	LONG     lPSessionVersion;
							// announcement we just sent
	spTVEEnhParsed->get_SAPMsgIDHash(&lPSAPMsgID);
	spTVEEnhParsed->get_SAPSendingIP(&spbsPSAPSendingIP);

	spTVEEnhParsed->get_SessionId(&lPSessionID);
	spTVEEnhParsed->get_SessionVersion(&lPSessionVersion);
	spTVEEnhParsed->get_SessionIPAddress(&spbsPSessionIPAddress);

	spTVEEnhParsed->get_SessionName(&spbsPSessionName);
	spTVEEnhParsed->get_UUID(&spbsPSessionUUID);


	CComBSTR spbsSAPSendingIP;
	LONG	 lSAPMsgID;

	CComBSTR spbsSessionName;
	CComBSTR spbsSessionIPAddress;
	CComBSTR spbsSessionUUID;
	LONG	 lSessionID;
	LONG	 lSessionVersion;
	long lgrfEnhChanged;
		
	for(iEnhn = 0; (iEnhn < cEnhns) && !fMatch; iEnhn++) {
		CComVariant vc(iEnhn);
		hr = m_spEnhancements->get_Item(vc,&spEnh);

							// existing enhancement
		spEnh->get_SAPMsgIDHash(&lSAPMsgID);
		spEnh->get_SAPSendingIP(&spbsSAPSendingIP);

		spEnh->get_SessionId(&lSessionID);
		spEnh->get_SessionVersion(&lSessionVersion);
		spEnh->get_SessionIPAddress(&spbsSessionIPAddress);

		spEnh->get_SessionName(&spbsSessionName);
		spEnh->get_UUID(&spbsSessionUUID);

		if(fUseSAPStuff) {
			if((lSAPMsgID == lPSAPMsgID) && (0 != lPSAPMsgID) &&
			   (spbsSAPSendingIP == spbsPSAPSendingIP)) 
			  fMatch = true;
			  fExactMatch = true;
		}
		if(lSessionID == lPSessionID) fMatch = true;
		if(lSessionVersion == lPSessionVersion) fExactMatch = true;
	}

	if(fExactMatch)				// found an exact match - ignore it (resend of announcement)
	{			
		ITVEEnhancement_HelperPtr spEnhHelper(spEnh);
		if(!FAILED(hr))
			hr = spTVESuperHelper->NotifyEnhancement(NENH_Duplicate, spTVEEnhParsed, NENH_grfNone);
	} 
	else if (fMatch)			// had a match, but it changed - modify existing one
	{	
		ITVEEnhancementPtr spEnh(spEnh);

		ITVEEnhancement_HelperPtr spEnhHelper(spEnh);
		hr = spEnhHelper->UpdateEnhancement(spTVEEnhParsed, &lgrfEnhChanged);

		if(lgrfEnhChanged & (NENH_grfSomeVarIP | NENH_grfVariationAdded | NENH_grfVariationRemoved))					
			fMajorUpdate = true;					// major change, had to tear out old Multicast
		else {										// minor update, just a minor parameter changed

			if(lgrfEnhChanged & NENH_grfStopTime)		// if stop time changed, update it in the expire queue.
			{
/*				spEnh->AddRef();						// removeFrom below does Release, need AddRef() here cause it's smart!
				hr = RemoveFromExpireQueue(spEnh);		// remove item from expire queue.- way drastic! FIX (full remove!)..
				_ASSERT(S_OK == hr);
				hr = AddToExpireQueue(dateExpires, spEnh);	*/

				DATE dateExpires;
				spTVEEnhParsed->get_StopTime(&dateExpires);
				hr = ChangeInExpireQueue(dateExpires, spEnh);

				_ASSERT(S_OK == hr);
				
			}
			hr = spTVESuperHelper->NotifyEnhancement(NENH_Updated, spEnh, 	lgrfEnhChanged);
		}


	} else {
		fBrandNew = true;
	}
								// it's new (or major change).   Create it.
	if(fBrandNew || fMajorUpdate)
	{
		ITVEEnhancementPtr spEnh(spEnh);
		ITVEEnhancementPtr spEnhP(spTVEEnhParsed);
	
					// Need to delete old enhancement.. it changed so much we can't deal with it
					// TODO - this means changing # of variations in a show will clear out all history! (good, bad, or just ugly?)
		if(fMajorUpdate)		
		{
			ITVEEnhancement_HelperPtr spEnhHelper(spEnh);
			hr = spEnhHelper->Deactivate();					// shutdown the existing IP Sink queues(POTENTIAL THREAD ERROR!)
			_ASSERT(S_OK == hr);	
			spEnh->AddRef();								// below releases, but we need it around cause it's a smart pointer.
			hr = RemoveFromExpireQueue(spEnh);				// remove item from expire queue... also calls RemoveYouself(), which sends Delete event
			_ASSERT(S_OK == hr);
		} else { 
			_ASSERT(iEnhn == cEnhns);
		}
						

//		ITVEServicePtr spServThis(this);
		CComPtr<ITVEService> spServThis(this);				// want the CComPtr here, the Ptr version causes trigger parsing to fail

		ITVEEnhancement_HelperPtr spEnhParsedHelper(spEnhP);
		spEnhParsedHelper->ConnectParent(spServThis);				// Don't use SmartPTR's (CComPtr<ITVEEnhancement>) for ConnectParent calls (ATLDebug Blow's it)

		if(!FAILED(hr)) {
			hr = m_spEnhancements->Add(spEnhP);				// connect the ref-counted down pointers via the collection
		}
								
		if(!FAILED(hr))
			hr = spEnhancementHelper->Activate();					// Activate it (create and join the multicasts)

		if(!FAILED(hr)) {
			if(fBrandNew) 
			{
				if(!FAILED(hr)) 
				{									// add to the expire Queue
					DATE dateStarts, dateExpires;
					DATE dateNow = DateNow();

					spEnhP->get_StartTime(&dateStarts);
					spEnhP->get_StopTime(&dateExpires);	
				
					hr = spTVESuperHelper->NotifyEnhancement(NENH_New, spEnhP,  long(NENH_grfAll));
					if(dateStarts + m_dateExpireOffset < dateNow + 5/(24.0 * 60 * 60))		// if started in past or next five seconds
					{	
						hr = spTVESuperHelper->NotifyEnhancement(NENH_Starting, spEnhP,  long(NENH_grfAll));
					} else {
							// tricky code... Starts in the future.  Add it into the Expire Queue on it's Start Date
                            //   - note all times added to expire queue do not have the offset in them...
                            //     The offset is taken into account in the ExpireForDate() method.
						hr = AddToExpireQueue(dateStarts, spEnhP);	// Event expire code is simply going to have to ignore it..
					}					
					hr = AddToExpireQueue(dateExpires, spEnhP);	
				}
			}
			else // fMajorUpdate
			{
				if(!FAILED(hr)) 
				{
					DATE dateExpires;
					spEnhP->get_StopTime(&dateExpires);
					hr = AddToExpireQueue(dateExpires, spEnhP);		
				}
				hr = spTVESuperHelper->NotifyEnhancement(NENH_Updated, spEnhP, 	lgrfEnhChanged);
					
			}																	
		}
	}
	return hr;
}

STDMETHODIMP CTVEService::DumpToBSTR(BSTR *pBstrBuff)
{
	const int kMaxChars = 1024;
	TCHAR tBuff[kMaxChars];
	int iLen;
	CComBSTR bstrOut;
	bstrOut.Empty();

	CHECK_OUT_PARAM(pBstrBuff);

	CSmartLock spLock(&m_sLk);

  	bstrOut.Append(_T("Service: "));
	iLen = m_spbsDescription.Length()+12;
	if(iLen < kMaxChars) {
		_stprintf(tBuff,_T("Description     : %s\n"),m_spbsDescription);
		bstrOut.Append(tBuff);
	}
	_stprintf(tBuff,_T("Active             : %s\n"),m_fIsActive ? _T("True") : _T("False")); bstrOut.Append(tBuff);
	_stprintf(tBuff,_T("Annc IP Adapter    : %s\n"),m_spbsAnncIPAdapter); bstrOut.Append(tBuff);
	_stprintf(tBuff,_T("Annc IP Address    : %s:%d\n"),m_spbsAnncIPAddr, m_dwAnncPort); bstrOut.Append(tBuff);

    bstrOut.Append(_T("     WHY DOESN'T THIS SHOW UP   \n"));
    bstrOut.Append(_T("     -- -- -- --  \n"));
	if(NULL == m_spExpireQueue) {
		bstrOut.Append(_T("<<< Uninitialized Expire Queue >>>\n"));
	} else {
		long cExpItems;
		m_spExpireQueue->get_Count(&cExpItems);
		_stprintf(tBuff,_T("%d Queued Items to Expire. Offset %8.2f Hrs, ChangeCnt %d\n"), 
			cExpItems, m_dateExpireOffset*24, m_dwExpireQueueChangeCount);
		bstrOut.Append(tBuff);

		CComBSTR bstrExpireQ;
		m_spExpireQueue->DumpToBSTR(&bstrExpireQ);
		bstrOut.Append(bstrExpireQ);
	}

    bstrOut.Append(_T("     -- -- -- --  \n"));
	_stprintf(tBuff,_T("CrossOver Links Enhancement\n"));
	bstrOut.Append(tBuff);
	ITVEEnhancement_HelperPtr spXOverEnhancementHelper = m_spXOverEnhancement;
	if(NULL == spXOverEnhancementHelper) 
	{
		bstrOut.Append(_T("*** Error in Cross Over Enhancement\n"));
	} else {
		CComBSTR bstrXOverEnh;
		spXOverEnhancementHelper->DumpToBSTR(&bstrXOverEnh);
		bstrOut.Append(bstrXOverEnh);
	}

	if(NULL == m_spEnhancements) {
		_stprintf(tBuff,_T("<<< Uninitialized Enhancements >>>\n"));
		bstrOut.Append(tBuff);
	} else {
		long cEnhancements;
		m_spEnhancements->get_Count(&cEnhancements);	
		_stprintf(tBuff,_T("%d Enhancements\n"), cEnhancements);
		bstrOut.Append(tBuff);

		for(long i = 0; i < cEnhancements; i++) 
		{
			_stprintf(tBuff,_T("Enhancements %d\n"), i);
			bstrOut.Append(tBuff);

			CComVariant var(i);
			ITVEEnhancementPtr spEnhancement;
			HRESULT hr = m_spEnhancements->get_Item(var, &spEnhancement);			// does AddRef!  - 1 base?

			if(S_OK == hr)
			{
				ITVEEnhancement_HelperPtr spEnhancementHelper = spEnhancement;
				if(NULL == spEnhancementHelper) {bstrOut.Append(_T("*** Error in Variation\n")); break;}

				CComBSTR bstrVariation;
				spEnhancementHelper->DumpToBSTR(&bstrVariation);
				bstrOut.Append(bstrVariation);
			} else {
				bstrOut.Append(_T("*** Invalid, wasn't able to get_Item on it\n")); 
			}
		}
	}

	bstrOut.CopyTo(pBstrBuff);

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTVEService

STDMETHODIMP CTVEService::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVEService,
		&IID_ITVEService_Helper
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

			// return Addref'ed pointer to parent.  (Not m_pService is not add Refed.)
			//		there is a small possibility that this object is bogus if 
			//		tree is deleted in wrong order.

STDMETHODIMP CTVEService::get_Parent(IUnknown **ppVal)
{
	HRESULT hr = S_OK;
	CHECK_OUT_PARAM(ppVal);
		
    try {
		CSmartLock spLock(&m_sLk);

		if(m_pSupervisor) {
			hr = m_pSupervisor->QueryInterface(IID_IUnknown,(void **) ppVal);
		}
		else {
			*ppVal = NULL;
			hr = E_INVALIDARG;
		}
    } catch(...) {
		_ASSERT(false);			// supervisor got womped...
        return E_POINTER;
    }
	return hr; 
}


STDMETHODIMP CTVEService::get_Enhancements(ITVEEnhancements **ppVal)
{
	HRESULT hr;
	CHECK_OUT_PARAM(ppVal);

    try {
		CSmartLock spLock(&m_sLk);
        hr = m_spEnhancements->QueryInterface(ppVal);
    } catch(...) {
		*ppVal = NULL;
        return E_POINTER;
    }
	return hr;
}

STDMETHODIMP CTVEService::get_Description(BSTR *pVal)
{
	CHECK_OUT_PARAM(pVal);
	CSmartLock spLock(&m_sLk);
	return m_spbsDescription.CopyTo(pVal);
}

STDMETHODIMP CTVEService::put_Description(BSTR newVal)
{
	CSmartLock spLock(&m_sLk);
	m_spbsDescription = newVal;
	return S_OK;
}


STDMETHODIMP CTVEService::get_ExpireOffset(DATE *pVal)
{
	CHECK_OUT_PARAM(pVal);
	CSmartLock spLock(&m_sLk);			// CHANGE to pick up value of currently active service!
	*pVal = m_dateExpireOffset; 
	return S_OK;
}

STDMETHODIMP CTVEService::put_ExpireOffset(DATE newVal)
{
	CSmartLock spLock(&m_sLk);			// CHANGE to set value of currently active service!
	m_dateExpireOffset = newVal;
//	ASSERT(newVal > -1000.0 && newVal < -1000.0);		// bogus value testing.(+/- 3 years or so)
	return S_OK;
}


void CTVEService::Initialize(BSTR bstrDescription)
{
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::Initialize"));

	m_spbsDescription = bstrDescription;
	m_spEnhancements->RemoveAll();

	InitXOverEnhancement();
}

typedef ITVEFile		* PITVEFile;			// nasty typedef to make it easier to New arrays of pointers to these guys
typedef ITVETrigger		* PITVETrigger;
typedef ITVEEnhancement	* PITVEEnhancement;

STDMETHODIMP CTVEService::ExpireForDate(DATE dateToExpire)
{
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::ExpireForDate"));

	CSmartLock spLock(&m_sLk);			// ? lock here is dangerous, could be lots of changes going on...

	if(0.0 == dateToExpire) {
		dateToExpire = DateNow();
	}
										// JB change - tape delayed expire offsets should be positive
	CComVariant cvDate(dateToExpire	- m_dateExpireOffset);		// should perhaps check if any of the IUnknowns are 'this'

	/// -------------

			// this is NASTY code...
			//   there are lots of circular references kicked off by ExpireQueue objects that need to be
			//   very carefully removed.
	
										// Expire all the Files or Triggers that are older than this date first
										//   - else can end up deleting the Enhancement they point to
										//     before removing them.
	m_spExpireQueue->LockRead();
	long cItems;
	HRESULT hr = m_spExpireQueue->get_Count(&cItems);		// how many to remove?
	PITVEFile *rgTVEFiles       = new PITVEFile[cItems];			// copy them over, and remove from the list
	PITVETrigger *rgTVETriggers = new PITVETrigger[cItems];			// copy them over, and remove from the list
	if(NULL == rgTVEFiles || NULL == rgTVETriggers)
	{
		delete [] rgTVEFiles;
		delete [] rgTVETriggers;
		return E_OUTOFMEMORY;
	}

	long cFilesToRemove = 0;
	long cTriggersToRemove = 0;
	int i = 0;
	while(cItems > 0)
	{
		CComVariant cv(i++);
		DATE dateExpires;
		IUnknownPtr pUnkItem;
		hr = m_spExpireQueue->get_Key(cv, &dateExpires);
		hr = m_spExpireQueue->get_Item(cv, &pUnkItem);
		if(FAILED(hr) || dateExpires > cvDate.date)		// if failed or dates in queue expire later than our test date, stop the search
			break;										// (Assumes objects are correctly sorted in order of increasing expire dates)

		ITVEFilePtr spFile(pUnkItem);					// is it a file object?
		if(spFile != NULL)
		{
			rgTVEFiles[cFilesToRemove++] = spFile;		// store in a temp array
			spFile->AddRef();							//   add to this array
		} else {
			ITVETriggerPtr spTrigger(pUnkItem);					// is it a file object?
			if(spTrigger != NULL)
			{
				rgTVETriggers[cTriggersToRemove++] = spTrigger;		// store in a temp array
				spTrigger->AddRef();							//   add to this array
			} 
		}
		--cItems;
	}					
	
	// now clean up all those files...
	if(cTriggersToRemove + cFilesToRemove > 0) 
	{
		for(int i = 0; i < cFilesToRemove; i++)
		{
			IUnknownPtr spPunk(rgTVEFiles[i]);					//  create a smart Punk refcount
			CComVariant cvPunk((IUnknown *) spPunk);		
			m_spExpireQueue->Remove(cvPunk);					// remove item from the queue (calls the TVERemoveYourself method on the file).
		}
		for(int i = 0; i < cTriggersToRemove; i++)
		{
			IUnknownPtr spPunk(rgTVETriggers[i]);
			CComVariant cvPunk((IUnknown *) spPunk);		
			m_spExpireQueue->Remove(cvPunk);					// remove item from the queue (calls the TVERemoveYourself method on the file).
		}
		m_spExpireQueue->Unlock();								// unlcok so can release the files outside the lock
																//  (I don't think this is necessary anymore...)
							
		for(int i = 0; i < cFilesToRemove; i++)
		{
			rgTVEFiles[i]->Release();
			rgTVEFiles[i] = NULL;
		}

		for(int i = 0; i < cTriggersToRemove; i++)
		{
			rgTVETriggers[i]->Release();
			rgTVETriggers[i] = NULL;
		}

		m_dwExpireQueueChangeCount++;
	} else {
		m_spExpireQueue->Unlock();
	}

	delete [] rgTVETriggers;
	delete [] rgTVEFiles;
	
	// ---------------
	
										// Expire queue may contain enhancements twice if the start time
										//   was delayed.  If find an enhancement with a expire-time greater
										//   than the test time, then see if it's in the list again later (it should be)
										//   In this case, just start that enhancement and remove it from the queue.
	m_spExpireQueue->LockRead();
	hr = m_spExpireQueue->get_Count(&cItems);		// how many to remove?
	PITVEEnhancement *rgTVEEnhs = new PITVEEnhancement[cItems];					// copy them over, and remove from the list
	if(NULL == rgTVEEnhs)
		return E_OUTOFMEMORY;

	long cEnhsToStart = 0;
	i = 0;
	while(cItems > 0)
	{
		CComVariant cv(i++);
		DATE dateExpires;
		IUnknownPtr pUnkItem;
		hr = m_spExpireQueue->get_Key(cv, &dateExpires);
		hr = m_spExpireQueue->get_Item(cv, &pUnkItem);
		if(FAILED(hr) || dateExpires > cvDate.date+ 2/(24.0*60*60))		// if failed or dates in queue expire later than our test date, stop the search
			break;											// (Assumes objects are correctly sorted in order of increasing expire dates)

		ITVEEnhancementPtr spEnh(pUnkItem);					// is it a file object?
		if(spEnh != NULL)
		{
			DATE dateStart, dateStop;
			spEnh->get_StartTime(&dateStart);
			spEnh->get_StopTime(&dateStop);

			if(dateStop > cvDate.date + 5/(24.0*60*60))			// if Enhancements stop date is in the future, then it
			{												//    must be here in the queue to start.
				rgTVEEnhs[cEnhsToStart++] = spEnh;			// store in a temp array
				spEnh->AddRef();							//   add to this array
			}
		}
		--cItems;
	}
	if(cEnhsToStart > 0)								// some enhancement had a start time..
	{
		for(int i = 0; i < cEnhsToStart; i++)
		{
			IUnknownPtr spPunk(rgTVEEnhs[i]);					//  create a smart Punk refcount
			CComVariant cvPunk((IUnknown *) spPunk);		
			m_spExpireQueue->RemoveSimple(cvPunk);				// remove first item from the queue (RemoveSimple doesn't call the TVERemoveYourself method on the file).

				// paranoia checking - the second version should really be there
			IUnknownPtr spPunk2;
			hr = m_spExpireQueue->get_Item(cvPunk, &spPunk2);
			_ASSERT(S_OK == hr && spPunk2 == spPunk);
		}													
		m_spExpireQueue->Unlock();								

						// now go back and fire Start Events for each of these enhancements
						//  (Assuming we aren't going to just go and expire them....)
		IUnknownPtr spPunkSuper;
		hr = get_Parent(&spPunkSuper);
		if(hr == S_OK && NULL != spPunkSuper)
		{
			ITVESupervisor_HelperPtr spSuperHelper(spPunkSuper);

			for(int i = 0; i < cEnhsToStart; i++)
			{
				DATE dateExpires;
				rgTVEEnhs[i]->get_StopTime(&dateExpires);
				if(dateExpires > cvDate.date)
				{
					spSuperHelper->NotifyEnhancement(NENH_Starting, rgTVEEnhs[i], long(NENH_grfAll));
				} 			
			}		
		}									//    don't call remove yourself..

	} else {
		m_spExpireQueue->Unlock();								
	}


	delete [] rgTVEEnhs;					// womp our temp array

	  // ---------------------------

				// now that files are gone, go clean up the major objects...

	hr = m_spExpireQueue->Remove(cvDate);
	if(hr == S_OK)
		m_dwExpireQueueChangeCount++;
//	Release();

	return hr;
}

STDMETHODIMP CTVEService::get_ExpireQueue(ITVEAttrTimeQ **ppVal)
{
    HRESULT hr;
    try {
        CheckOutPtr<ITVEAttrTimeQ *>(ppVal);
        CSmartLock spLock(&m_sLk);
        hr = m_spExpireQueue->QueryInterface(ppVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
        return hrCatch;
    } catch(...) {
        return E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CTVEService::put_Property(/*[in]*/ BSTR bstrPropName, BSTR bstrPropVal)
{
	HRESULT hr;
	if(NULL == bstrPropName)
		return E_POINTER;
	try {
		hr = m_spamRandomProperties->Replace(bstrPropName, bstrPropVal);
		if(hr == S_FALSE) hr = S_OK;		// don't bother complaining if it isn't already there.
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
		return hrCatch;
    } catch(...) {
        return E_UNEXPECTED;
    }
	return hr;
}

STDMETHODIMP CTVEService::get_Property(/*[in]*/ BSTR bstrPropName, BSTR *pbstrPropVal)
{
	HRESULT hr;
	if(NULL == bstrPropName)
		return E_POINTER;
	try {
        CheckOutPtr<BSTR>(pbstrPropVal);
		CComVariant cvKey(bstrPropName);
		hr = m_spamRandomProperties->get_Item(cvKey, pbstrPropVal); 
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
		return hrCatch;
    } catch(...) {
        return E_UNEXPECTED;
    }
	return hr;
}
HRESULT CTVEService::InitXOverEnhancement()
{
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::InitXOverEnhancement"));

	HRESULT hr = S_OK;

	if(m_spXOverEnhancement)
		m_spXOverEnhancement = NULL;	// I hope this clears things out

														// specific cross over (Line21 links) service
	CComObject<CTVEEnhancement> *pXOverEnhancement;
	hr = CComObject<CTVEEnhancement>::CreateInstance(&pXOverEnhancement);
	if(FAILED(hr))
		return hr;
	hr = pXOverEnhancement->QueryInterface(&m_spXOverEnhancement);		
	if(FAILED(hr)) {
		delete pXOverEnhancement;
		return hr;
	}

	//ITVEServicePtr spServiceThis(this);				// buggie?  Better luck in past with CComPtr's instead
	CComPtr<ITVEService>	spServiceThis(this);		// interface pointer to stuff into parent-pointers

	ITVEEnhancement_HelperPtr	spXOverEnhancement_Helper(m_spXOverEnhancement);
	hr = spXOverEnhancement_Helper->ConnectParent(spServiceThis);	// store the back pointer...
	if(FAILED(hr)) 
	{
		return hr;
	}
														// make it the Xover Enhancement
	hr = spXOverEnhancement_Helper->InitAsXOver();
	if(FAILED(hr))
	{
		m_spXOverEnhancement = NULL;
		return hr;
	}

														// label it...
	m_spXOverEnhancement->put_Description(L"Line21 Crossover Enhancement");

	return hr;
}

STDMETHODIMP CTVEService::NewXOverLink(BSTR bstrLine21Trigger)
{
	DBG_HEADER(CDebugLog::DBG_SERVICE, _T("CTVEService::NewXOverLink"));
	HRESULT hr = S_OK;

    if(!m_fIsActive) 
        return S_FALSE;

	if(m_spXOverEnhancement == NULL)
		return E_INVALIDARG;

	ITVEEnhancement_HelperPtr	spXOverEnhancement_Helper(m_spXOverEnhancement);
														// Pass down the link
	hr = spXOverEnhancement_Helper->NewXOverLink(bstrLine21Trigger);

	return hr;
}

		// return the special Crossover Links Enhancement 
		//   (this has one variation, and a set of tracks under it...)
		//   (Special purpose routine, used for treeviews...)

STDMETHODIMP CTVEService::get_XOverEnhancement(ITVEEnhancement **ppVal)
{

	HRESULT hr;
	CHECK_OUT_PARAM(ppVal);
	try {
		CSmartLock spLock(&m_sLk);
		hr = m_spXOverEnhancement->QueryInterface(ppVal);
    } catch(...) {
		*ppVal = NULL;
        return E_POINTER;
    }
	return hr;
}
		// returns the ITVETracks collection object of the 
		//   one and only ITVEVariation of the 
		//   one and only Crossover Links Enhancement
		// of this service
STDMETHODIMP CTVEService::get_XOverLinks(ITVETracks **ppVal)
{
	HRESULT hr = S_OK;
	CHECK_OUT_PARAM(ppVal);

	ITVEVariationsPtr spXoverVariations;
	hr = m_spXOverEnhancement->get_Variations(&spXoverVariations);
	long cVars = 0;
	spXoverVariations->get_Count(&cVars);
	if(cVars != 1)
		return E_UNEXPECTED;

	ITVEVariationPtr spXOverVariation;
	CComVariant varZero(0);
	hr = spXoverVariations->get_Item(varZero, &spXOverVariation);			// does AddRef!  - 1 base?
	if(FAILED(hr)) 
		return hr;

	hr = spXOverVariation->get_Tracks(ppVal);
	if(FAILED(hr))
		return hr;

	// -- debug test code
/*
	ITVETracksPtr spTracks(*ppVal);
	long cTracks;
	spTracks->get_Count(&cTracks);
	CComBSTR bstrDump;
	for(long i = 0; i < cTracks; i++)
	{
		ITVETrackPtr spTrack;
		CComVariant cv(i);
		spTracks->get_Item(cv,&spTrack);
		ITVETrack_HelperPtr spTrackHlp(spTrack);
		bstrDump.Empty();
		spTrackHlp->DumpToBSTR(&bstrDump);
	}
*/
	// ---
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveservis.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEServices.cpp : Implementation of CTVEServices
#include "stdafx.h"
#include "MSTvE.h"
#include "TVEServis.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
/////////////////////////////////////////////////////////////////////////////
// CTVEServices


STDMETHODIMP CTVEServices::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVEServices
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveservis.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEServices.h : Declaration of the CTVEServices

#ifndef __TVESERVICES_H_
#define __TVESERVICES_H_

#include "resource.h"       // main symbols
#include "TVECollect.h"

/////////////////////////////////////////////////////////////////////////////
// CTVEServices
class ATL_NO_VTABLE CTVEServices : public TVECollection<ITVEService, ITVEServices>,
	public ISupportErrorInfo
{
public:
	DECLARE_REGISTRY_RESOURCEID(IDR_TVESERVICES);
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

#endif //__TVESERVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvesmartlock.h ===
// ------------------------------------------------------------
//  TveSmartLock.h
//
//		Class that allows read-many/write-once shared or exclusive access to
//		a section of code.
//
//      To use, declare the following variable in the class to protect:
//              CTVESmartLock m_sLk
//      Then in scope of code method to protect, create the
//              CSmartLock spLock(&m_sLk [,ReadLock|WriteLock]);	(defaults to ReadLock)	
//
//			If WriteLock, then ensures exclusive access to that section of code.
//			else if ReadLock, then allows shared access.
//
//		The destructor for the CTVESmartLock will remove the lock for you.
//
//		Two other interesting methods are:
//			CTVESmartLock::ConvertToRead()		- converts shared read lock to exclusive write lock
//			CTVESmartLock::ConvertToWrite()		- converts exclusive write lock to shared read lock
//
//
//		A deadlock condition in the use of the exclusive WriteLock will toss an 
//		STATUS_POSSIBLE_DEADLOCK exception (0xC0000194L).
//			
//
//		Internal Methods 
//
// ------------------------------------------------------------
#ifndef __TVESMARTLOCK_H__
#define __TVESMARTLOCK_H__

#include "wtypes.h"

typedef LONG NTSTATUS;
//#include "winnt.h"

//							// this from ntsatus.h (// f:\nt\public\sdk\inc\ntstatus.h)
//							//     not found in standard exception list.
//							//     (otherwise need wierd #define WIN32_NO_STATUS to #include)
// MessageId: STATUS_POSSIBLE_DEADLOCK
//
// MessageText:
//
//  {EXCEPTION}
//  Possible deadlock condition.
//
#ifndef STATUS_POSSIBLE_DEADLOCK
#define STATUS_POSSIBLE_DEADLOCK         ((NTSTATUS)0xC0000194L)
#endif

//
//  Shared resource function definitions
//


const int SL_RESOURCE_FLAG_LONG_TERM = 1;

typedef struct _SL_RESOURCE {

    //
    //  The following field controls entering and exiting the critical
    //  section for the resource
    //

    CRITICAL_SECTION CriticalSection;

    //
    //  The following four fields indicate the number of both shared or
    //  exclusive waiters
    //

    HANDLE SharedSemaphore;
    ULONG NumberOfWaitingShared;
    HANDLE ExclusiveSemaphore;
    ULONG NumberOfWaitingExclusive;

    //
    //  The following indicates the current state of the resource
    //
    //      <0 the resource is acquired for exclusive access with the
    //         absolute value indicating the number of recursive accesses
    //         to the resource
    //
    //       0 the resource is available
    //
    //      >0 the resource is acquired for shared access with the
    //         value indicating the number of shared accesses to the resource
    //

    LONG NumberOfActive;
    DWORD dwExclusiveOwnerThreadId;

    ULONG Flags;        // See SL_RESOURCE_FLAG_ equates below.

//    PSL_RESOURCE_DEBUG DebugInfo;
} SL_RESOURCE, *PSL_RESOURCE;


VOID
SLRaiseStatus (
    IN NTSTATUS Status
    );

VOID
SLInitializeResource(
    PSL_RESOURCE Resource
    );

BOOLEAN
SLAcquireResourceShared(
    PSL_RESOURCE Resource,
    BOOLEAN Wait
    );

BOOLEAN
SLAcquireResourceExclusive(
    PSL_RESOURCE Resource,
    BOOLEAN Wait
    );

VOID
SLReleaseResource(
    PSL_RESOURCE Resource
    );

VOID
SLConvertSharedToExclusive(
    PSL_RESOURCE Resource
    );

VOID
SLConvertExclusiveToShared(
    PSL_RESOURCE Resource
    );

VOID
SLDeleteResource (
    PSL_RESOURCE Resource
    );


// ---------------------------------------------------------------------------------
// ---------------------------------------------------------------------------------

class CTVESmartLock
{
public:
	CTVESmartLock()		{ SLInitializeResource (&m_SLResource) ; }
	~CTVESmartLock()	{ SLDeleteResource (&m_SLResource) ; }
	void lockR_ ()		{ m_lErr = SLAcquireResourceShared (&m_SLResource, true) ; }		// wait True..
 	void lockW_ ()		{ m_lErr = SLAcquireResourceExclusive (&m_SLResource, true) ; }
	void convertToW_()	{ SLConvertSharedToExclusive(&m_SLResource);}		// don't work , get __global_unwind2 already defined in ntdll errors
	void convertToR_()	{ SLConvertExclusiveToShared(&m_SLResource);}
    void unlock_ ()		{ SLReleaseResource (&m_SLResource) ; }
	int  lockCount_()	{ return m_SLResource.NumberOfActive; }
private:
	SL_RESOURCE		m_SLResource;
	int					m_lErr;
};

typedef enum EnSLType {ReadLock=0,WriteLock=1} ;

class CSmartLock
{
private:
	CTVESmartLock		*m_pSmartLock;
public:
	
	CSmartLock(CTVESmartLock *pSmartLock, EnSLType fForWrite)	
	{
		m_pSmartLock = pSmartLock; 
		if(fForWrite) 
			m_pSmartLock->lockW_();
		else 
			m_pSmartLock->lockR_();
	} 

	CSmartLock(CTVESmartLock *pSmartLock)	
	{
		m_pSmartLock = pSmartLock; 
		m_pSmartLock->lockR_();				// by default, everything is a read lock.. (should it default to a write lock?)
	} 


	int LockCount()			// returns >= 1 if read locked, <= -1 if write locked, and 0 if unlocked
	{
		return m_pSmartLock->lockCount_();
	}

	void ConvertToRead()
	{
		m_pSmartLock->convertToR_();
	}

	void ConvertToWrite()
	{
		m_pSmartLock->convertToW_();
	}

	~CSmartLock()	
	{
		m_pSmartLock->unlock_();
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvesuper.cpp ===
// Copyright (c) 1999, 2000  Microsoft Corporation.  All Rights Reserved.
// TVESupervisor.cpp : Implementation of CTVESupervisor
//
// ------------------------------------------------------------------------------
//	Notes on Threads and how MSTvE works.
//
//		This is a multi-threaded component.
//			1) There is the main thread the Supervisor is created in,
//			   coming from the client (its the client thread).
//			2) There is a 'QueueThread' created in the Multicast manager. 
//				(see CTVEMCastManager::CreateQueueThread())
//			3) There are threads created for each multicast address we are listening on.
//				(see CTVEMCastManager::AddMulticast())
//
//		The listener threads simply gather up multicast packets and forward
//		them on to the queue thread as quickly as possible.  This is done so the
//		listener threads avoid missing packets as much as possible.
//
//		The queue thread processes each packet according to it's type.  It has a
//		message loop formed with GetMessage that waits for data packets sent up
//		from any of the listner threads.  (Amoung other things, this serializes
//		the receiving process.  It also allows the parsing to be performed in a
//		lower priority.)  (See CTVEMCastManager::queueThreadBody.)  
//
//		The wParam parameter returned by GetMessage is cast to a CTVEMCastCallback
//		base class.  There are several classes derivied from this base class, one
//		for each type of data being processed: announcements, triggers, UHTTP data,
//		(and test dump routines.)  This class was set during the first AddMulticast call.
//		Various parameters required provide the correct context to parse the data, such
//		as which variation the trigger is being parsed in, are stored in the derived classes.
//		The lParam parameter containes the actual packet data to be parsed.
//
//		The callback class's process method is ProcessPacket() method is called to
//		actually process the data.  (See:the following...)
//				CTVECBAnnc::ProcessPacket()
//			    CTVECBTrig::ProcessPacket(),   
//			    CTVECBFile::ProcessPacket()
//			    CTVECBDummy::ProcessPacket()   -- generic test routine 
//		
//		These methods gather up the data, preprocess the data (for example,
//		all triggers and announcment parsers want Unicode, but the data arrives in 8-bit chars,
//		so it must be converted), and then call the correct parsing routines.  (See the following...)
//		    ITVEService_Helper    CTVEService::ParseCBAnnouncement()
//			ITVEVariation_Helper  CTVEVariation::ParseCBTrigger()
//								  UHTTP_Receiver:.NewPacket()
//
//		When all done with the parsing, the parsing routines signal events up to the U/I informing
//		it of it's progess.   These are the  CTVESupervisor::NotifyXXX() methods down below.
//	
//		Because all this parsing is done in the queue thread rather than the client thread,
//		the events need to be marshelled over.   This is done in the CTVESupervisor::NotifyXXX_XProxy()
//		methods also found below.  Actual marshelling is done via ATL magic through interfaces
//		stored in the global interface table (GIT).  
//
//		Actual events coming out of the Supervisor are caught by the TVE Graph segment, which them
//		bounces them up to the U/I object that requests them.
//			
//  Circular RefCount Issues (and Locations)
//		
//		One of the most plexing problems in this code is preventing or dealing
//		with circular refcounts.   These occur when object A has a refcounted
//		pointer to object B, which also has a refcounted pointer directly to A 
//		or some sequence of objects (C,D,E,...) which eventually lead back to A.
//		
//		The problem occurs when trying to release everything.  Suppose Z has
//		a reference to A
//			obj   refcount  (from)
//			 Z		1		 
//			 A      2        (Z,B)
//			 B      1        (A)
//
//		If Z releses A, then A's refcount goes to just 1, but not to zero.  Hence
//		A's final release never gets called, and it never releases B.
//
//		There are several solutions to this problem of circular refcounts.  The
//		one I've used thoughout this code is:summed up by:the rule:
//
//		  rule 1)		"Backward pointers are not refcounted"
//
//		In other words, A would contain a refcount to B, but B would NOT contain
//		a ref-counted pointer to A.   Instead, it just contains a normal pointer.
//		This works pretty well.  In the example above, A would only have a refcount
//		of one, so when it's released from Z, it's final release would get called
//		and it (and B) would go away.
//
//		This rule does have some problems.  First is that sub-objects cannot be 
//		handed over to some other object (that places a refcount on it) and then
//		the backpointer used reliably if A can be deleted.   Either A must remain
//		stable, the back pointer can not be used, or the process of deleting A
//		must NULL out back refernces to it in B before doing so and then B must
//		check to see if it's back pointer is non-null before using it.
//
//		I've tried to do the third option (nulling out the back reference) throughout
//		the code.  In other words, I have this second rule
//
//			rule 2)		"It is the responsiblity of the parent object to null out
//					     back pointers to it in it's FinalRelease() before releaseing
//						 the downward pointer"
//
//
//		This is primarilly true in the parent pointers in each
//		of the base objects (service,enhancement,variation,track,trigger).
//		These are returned by the get_Parent() methods on each of them, this get_Parent()
//		call may return NULL if the parent has been released - it's up to it's callers to check.
//
//
//		There are a few other locations...  This comment serves as documentation for them.
//
//	Circular Reference Locations
//
//		According to my rule of refcounting, I do not refcount backwards references.
//		But I do have those references.  This section describes where they are.
//
//		1)  All major objects contain 'parent' pointers to their containing objects.
//
//			CTVETrigger::m_pTrack
//			CTVETrack::m_pVariation
//			CTVEVariation::m_pEnhancement
//			CTVEEnhancement::m_pService
//			CTVEService::m_pSupervisor
//			CTVESupervisor::m_pUnkParent	(not actually used???)
//
//		    These pointers are returned via the ITVExxx:get_Parent(IUnknown *pUnk) methods.
//			This method may return NULL.
//
//			Note the helper function ITVExxx::get_Service() on many of the lower
//			level object which walks all the way back up the object tree to the service
//			level may also return a null pointer.
//
//			It is the responsibility of the FinalRelease() methods on each of these
//			object to null out any up pointers back to it.  This is done with
//			a call of the form:
//				 	spXXXHelper->ConnectParent(NULL);
//
//			Possible bugs:  none that I know of
//
//		2) The GIT references the Supervisor
//			
//			The global information table contains references to the supervisor used
//			for marshelling accross threads.  In the supervisors FinalConstruct, the
//			reference count of the supervisior is automatically incremented in the
//			RegisterInterfaceInGlobal() call.   
//
//			The GIT is managed (a sub-object) of the supervisor, leading to
//			the circular reference.  Without a fix, the supervisor can't be
//			deleted.
//
//			To obey my no ref-counted backpointer rule, I make calls to Release() to
//			remove those refcounts.   Then in the FinalRelease() method, I 
//			make calls to AddRef right before the RevokeInterfaceFromGlobal() call
//			to avoid having the reference count drop below zero.
//
//			  Rule 1a)		"In the case where ref-counted back pointers exist,
//							 the FinalConstruct/FinalRelease do a Release/AddRef()
//							 to make it not so."
//
//			Possible bugs;  none that I know of.   The GIT is totally managed
//			by the supervisor, and there is not way for anyone to get a reference
//			to it outside my code.  
//
//			(Note the Advise reference on the TVEGraphSeg is similar, and is treated
//			the same way via the release in the final construct and addref in the 
//			final release.) 
//
//		3) Multicast Manager references the Supervisor.
//			
//			The multicast manager is an object owned by the supervisor.  It is responsible
//			for owing all multicast listener threads.   These threads wait for announcement/trigger/file data
//			on particular IP addresses, and when they receive it, modifiy the data graph
//			and make callbacks on the supervisor to fire events to clients.
//
//			As such, there are several backwards references.  The first is in the
//			manager itself (CTVEMCastManager::m_pTveSuper).   Obeying my earlier rules,
//			this is not refcounted, and the Supervisor nulls out this back pointers
//			on it's FinalRelease.
//
//			The multicast listeners are a bit more difficult since there could be 
//			many of them.  These point up to the supervisor or want to call events
//			on the supervisor.  In the case where the supervisor is destoryed,
//			the code simply stops all listener threads and leaves/deletes them to
//			avoid problems.
//
//			Possible bugs:  The callback threads are not shut down before the supervisor
//			(or other object) is deleted.
//
//
//		4) g_CacheManager references
//
//			The cache manager caches files into the IE cache.  It has a pointer
//			to the supervisor. CCacheManager::m_pTVESuper.   Only used for NotifyCacheFile events.
//			
//			The g_CacheManager is a global object crated in unpack.cpp
//
//		5) MulticastCallback functions reference into the tree
//
//			The multicast listener spins of multiple threads to read data.  When it's
//			received, it has to be placed into the right locations of the TVE data tree.
//			To do this, each callback object contains a reference to the part of the
//			tree that is going to be altered as follows:
//
//			   CTVECBFile::	m_spTVEService,   m_spTVEVariation, m_uhttpReceiver
//
//			   CTVECBTrig::	m_spTVEVariation
//
//			   CTVECBAnnc::   m_spTVEService
//
//			I've decided to leave these as smart pointers for now.  They all point
//			to levels below the supervisor, but are managed by the supervisor.
//			Hence deleting them (ITVEMCast::Leave or ITVEMCastManager::LeaveAll)
//			in the supervisor's FinalRelease() clears the refcounts up before
//			the objects themselves are deleted.
//
//			Multicasts reference pointers are organized like this:
//
//				ITVESupervisor
//					-> ITVEMCastManager   (-> m_pTveSuper back pointer)
//					     -> (QueueThread)
//						 -> ITVEMCasts			(enumeration object)
//							  --> ITVEMCast
//								  (WorkerThread)
//								  -->ITVEMCastCallback (one of 3 types)
//										--> ITVEMCast (m_pcMCast)
//										--> ITVEVariation and/or ITVEService (depending on type) (ref counted)
//										--> UHTTP_Receiver (File type)
//										      --> list of UHTTP_Package(s) 
//													--> ITVESupervisor
//													--> ITVEVariation
//			Supervisor contains one manager
//			Supervisor contains list of services, which contain enhancements, which contain ...
//				This manager contains list of multicasts
//					Each multicast points to a callback 
//						Each callback points back to:
//							non-refcounted pointer to it's parent multicast object
//							ref-counted pointer to some object under the supervisor tree
//
//			There is a circular ref-count between the callback and lower objects
//			under the supervisor.
//
//			Possible bugs:  many if the threads are not shut down and cleaned up
//			before the objects they point to go away...   Hard to do this because of 
//			the ref-count.
//
//		5)  ExpireQueue
//
//			The ExpireQueue queue is a time-sorted list of TVE objects that need to be deleted at given times.
//			It can contain pointers to just about any of the main TVE objects (other than the Supervisor).
//			There is an expire queue per supervisor object.
//
//			These are ref-counted pointers.   The fix is to delete them before deleteing the supervisor.
//
//
//			
//	ToDo:	
//		Optimization:		    use NT's thread pools rather than list of threads to listen on.
//  
// ------------------------------------------------------------------------------
#include "stdafx.h"
#include "MSTvE.h"
#include "TVESuper.h"
#include "TVEServi.h"

#include "TveDbg.h"
#include <stdio.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DBG_INIT(DEF_LOG_TVE);

/////////////////////////////////////////////////////////////////////////////
// CTVESupervisor  ITVESupervisor_Helper

_COM_SMARTPTR_TYPEDEF(ITVESupervisor,				__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,		__uuidof(ITVESupervisor_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEService,					__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,			__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,				__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement_Helper,		__uuidof(ITVEEnhancement_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,				__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVETrigger,					__uuidof(ITVETrigger));

_COM_SMARTPTR_TYPEDEF(ITVEMCastManager,				__uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager_Helper,		__uuidof(ITVEMCastManager_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEMCast,					__uuidof(ITVEMCast));
		
_COM_SMARTPTR_TYPEDEF(ITVECBAnnc,					__uuidof(ITVECBAnnc));
_COM_SMARTPTR_TYPEDEF(ITVECBDummy,					__uuidof(ITVECBDummy));
_COM_SMARTPTR_TYPEDEF(ITVEAttrMap,					__uuidof(ITVEAttrMap));
_COM_SMARTPTR_TYPEDEF(IGlobalInterfaceTable,		__uuidof(IGlobalInterfaceTable));

_COM_SMARTPTR_TYPEDEF(_ITVEEvents,					__uuidof(_ITVEEvents));
_COM_SMARTPTR_TYPEDEF(ITVEAttrTimeQ,				__uuidof(ITVEAttrTimeQ));
	
STDMETHODIMP CTVESupervisor::DumpToBSTR(BSTR *pBstrBuff)
{
	const int kMaxChars = 1024;
	TCHAR tBuff[kMaxChars];
	int iLen;
	CComBSTR bstrOut;
	CComBSTR bstrTmp;
	bstrOut.Empty();

//	CSmartLock spLock(&m_sLk);

	bstrOut.Append(_T("TVE Supervisor: \n"));
	bstrOut.Append(_T("   Multicasts:\n"));
	m_spMCastManager->DumpStatsToBSTR(0, &bstrTmp);
	bstrOut.Append(bstrTmp);
	bstrOut.Append(_T("   -- -- -- -- -- -- -- -- -- -- -- -- \n"));

	iLen = m_spbsDesc.Length()+12;
	if(iLen < kMaxChars) {
		_stprintf(tBuff,_T("Description    : %s\n"),m_spbsDesc);
		bstrOut.Append(tBuff);
	}

	if(NULL == m_spServices) {
		_stprintf(tBuff,_T("<<< Uninitialized Services >>>\n"));
		bstrOut.Append(tBuff);
	} else {
		long cServices;
		m_spServices->get_Count(&cServices);	
		_stprintf(tBuff,_T("%d Services\n"), cServices);
		bstrOut.Append(tBuff);

		for(long i = 0; i < cServices; i++) 
		{
	        bstrOut.Append(_T("   -- -- -- -- -- -- -- -- -- -- -- --\n"));
			_stprintf(tBuff,_T(">>> Service %d <<<\n"), i);
			bstrOut.Append(tBuff);

			CComVariant var(i);
			ITVEServicePtr spService;
			HRESULT hr = m_spServices->get_Item(var, &spService);			// does AddRef!  - 1 base?

			if(S_OK == hr)
			{
				CComQIPtr<ITVEService_Helper> spServiceHelper = spService;
				if(!spServiceHelper) {bstrOut.Append(_T("*** Error in Service\n")); break;}

				CComBSTR bstrService;
				spServiceHelper->DumpToBSTR(&bstrService);
				bstrOut.Append(bstrService);
			} else {
				bstrOut.Append(_T("*** Invalid, wasn't able to get_Item on it\n")); 
			}
		}
	}

	bstrOut.CopyTo(pBstrBuff);


	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTVESupervisor

STDMETHODIMP CTVESupervisor::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVESupervisor,
		&IID_ITVESupervisor_Helper
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

// --------------------------------------------------
// nasty globals 
// ---------------------------------------------------
extern CCacheManager	g_CacheManager;
IGlobalInterfaceTable *g_pIGlobalInterfaceTable = NULL;		// lifetime managed by smart pointer in supervisor

// ----------------------------------------------------
// real code
// ----------------------------------------------------

HRESULT 
CTVESupervisor::FinalConstruct()								// create internal objects
{
	DBG_SET_LOGFLAGS(_T("c:\\TveDbg.log"),

	// bank 1
		CDebugLog::DBG_SEV1 | 			// Basic Structure
		CDebugLog::DBG_SEV2	|			// Error Conditions
		CDebugLog::DBG_SEV3	|			// Warning Conditions
//		CDebugLog::DBG_SEV4	|			// Generic Info 
		CDebugLog::DBG_EVENT |			// Outgoing events 
//		CDebugLog::DBG_PACKET_RCV |		// each packet received..
		CDebugLog::DBG_MCASTMNGR |		// multicast manager
//		CDebugLog::DBG_MCAST |			// multicast object (multiple ones)
/* 		CDebugLog::DBG_SUPERVISOR |		// TVE Supervisor
		CDebugLog::DBG_SERVICE |		// Services
		CDebugLog::DBG_ENHANCEMENT |	// Enhancements
		CDebugLog::DBG_VARIATION |		// Variations
		CDebugLog::DBG_TRACK |			// Tracks
		CDebugLog::DBG_TRIGGER |		// Triggers
*/
//		CDebugLog::DBG_UHTTP |			// UHTTP methods
//		CDebugLog::DBG_UHTTPPACKET |	// detailed dump on each packet
//		CDebugLog::DBG_WSRECV |
		CDebugLog::DBG_FCACHE |			// file caching stuff
		CDebugLog::DBG_EVENT |			// each event sent

//		CDebugLog::DBG_other |			// headers of DBG2-DBG4 logs

		CDebugLog::DBG_GSEG |
		CDebugLog::DBG_TRIGGERCTRL |	// CTVETriggerCtrl
		CDebugLog::DBG_FEATURE |		// CTVEFeature
		CDebugLog::DBG_FEAT_EVENTS |	// events from CTVEFeatlre
		CDebugLog::DBG_NAVAID |			// CTVENavAid U/I helper

		0,								// terminating value for '|'


	// bank 2
		CDebugLog::DBG2_DUMP_PACKAGES |
		CDebugLog::DBG2_DUMP_MISSPACKET |		// missing packets
		0,								// terminating value for '|'

	// bank 3
		0,

	// bank 4									// need one of these last two flags
		CDebugLog::DBG4_WRITELOG |		// write to a fresh log file (only need 0 or 1 of these last two flags)
//		CDebugLog::DBG4_APPENDLOG |		// append to existing to log file, 
//		CDebugLog::DBG4_ATLTRACE |		// atl interface count tracing
//		CDebugLog::DBG4_TRACE |			// trace enter/exit methods

		0,								// terminating value for '|'

	// Default Level
		5);								// verbosity level... (0-5, higher means more verbose)
	
	HRESULT hr = S_OK;

	DBG_HEADER(CDebugLog::DBG_SUPERVISOR, _T("CTVESupervisor::FinalConstruct"));

	CSmartLock spLock(&m_sLk, WriteLock);

#ifdef _USE_FTM
	hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_spUnkMarshaler.p);	// CComPtr<IUnknown>
	if(FAILED(hr)) {
		_ASSERT(FALSE);
		return hr;
	}
#endif

	m_dwSuperGITProxyCookie = 0;
	
							// proxy object for intenal refcounts on the supervisor
	CComObject<CTVESupervisorGITProxy> *pGITProxy;
	hr = CComObject<CTVESupervisorGITProxy>::CreateInstance(&pGITProxy);
	if(FAILED(hr))
		return hr;
	hr = pGITProxy->QueryInterface(&m_spTVESupervisorGITProxy);
	if(FAILED(hr))
	{
		delete pGITProxy;
		return hr;
	}

	m_spTVESupervisorGITProxy->put_Supervisor(this);

	CComObject<CTVEServices> *pServices;
	hr = CComObject<CTVEServices>::CreateInstance(&pServices);
	if(FAILED(hr))
		return hr;
	hr = pServices->QueryInterface(&m_spServices);		
	if(FAILED(hr)) {
		delete pServices;
		return hr;
	}

#ifdef _DEBUG
		this->AddRef();
		int i1 = this->Release();
#endif


	hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, 
		             IID_IGlobalInterfaceTable, (void**) &m_spIGlobalInterfaceTable);
	if(FAILED(hr)) {
		return hr;
	}

	g_pIGlobalInterfaceTable = m_spIGlobalInterfaceTable;		// puts it into global pointer
	
	try
	{

		{
			hr = m_spIGlobalInterfaceTable->RegisterInterfaceInGlobal(m_spTVESupervisorGITProxy, 
								__uuidof(m_spTVESupervisorGITProxy), &m_dwSuperGITProxyCookie);
			_ASSERT(!FAILED(hr)); 

		}


	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = TYPE_E_LIBNOTREGISTERED;			// didn't register the proxy-stub DLL (see Prof ATL Com Prog.  Pg 395)
		_ASSERTE(TYPE_E_LIBNOTREGISTERED);
	}

	if(FAILED(hr))
		return hr;

//	_ASSERT(1 == m_dwRef);				// paranoia.... Expect this to be true

#ifdef _DEBUG
	this->AddRef();
	int i2 = this->Release();
#endif


			// --------------------------------------------------------------
					// multicast listener manager
	try {
		CComObject<CTVEMCastManager> *pMCastManager;
		hr = CComObject<CTVEMCastManager>::CreateInstance(&pMCastManager);
		if(FAILED(hr))
			return hr;
		hr = pMCastManager->QueryInterface(&m_spMCastManager);	
		if(FAILED(hr)) {
			delete pMCastManager;
			return hr;
		}

		LONG lHaltFlags;									// initalize the halt flags....
		get_HaltFlags(&lHaltFlags);
		m_spMCastManager->put_HaltFlags(lHaltFlags);

														// save un-refcounted back pointer in the mcast manager
		ITVESupervisorPtr spSuperThis(this);  
													// this adds Supervisor to GIT, does MCastManager stuff
		hr = m_spMCastManager->put_Supervisor(spSuperThis);	
	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
// ------

#ifdef _DEBUG
	int iA = this->AddRef();
	int i3 = this->Release();				// is this m_dwRef?
//	_ASSERT(1 == i3);						// paranoia.... Expect this to be true
			// Ignore this count... It's actually 3, but it's working
#endif

	return hr;
}


				// major routine - need to to this right to avoid leaks and hangs.
				//  kill Multicast listeners first, since they have references into subgraphs...
HRESULT CTVESupervisor::FinalRelease()
{
	DBG_HEADER(CDebugLog::DBG_SUPERVISOR, _T("CTVESupervisor::FinalRelease"));
	HRESULT hr = S_OK;							// a place to hang a breakpoint...

	CSmartLock spLock(&m_sLk, WriteLock);


	TVEDebugLog((CDebugLog::DBG_SUPERVISOR, 4, _T("Turning off ATVEF")));
	m_fInFinalRelease = true;					// hack to avoid error when signaling an event 
	hr = TuneTo(NULL, NULL);					// make sure it's turned off
	_ASSERT(!FAILED(hr));

	TVEDebugLog((CDebugLog::DBG_SUPERVISOR, 4, _T("Stopping Multicast Manager")));
												// Stop all Multicast listening
	
	if(m_spMCastManager)						// and Null out the MCast managers parent pointers
		m_spMCastManager->put_Supervisor(NULL);	// this does LeaveAll() too, killing all listener threads
	m_spMCastManager = NULL;

	


	TVEDebugLog((CDebugLog::DBG_SUPERVISOR, 4, _T("Nulling out Service back pointers")));
										// null out children's parent pointers
	if(NULL != m_spServices)
	{
		long cServices;
		hr = m_spServices->get_Count(&cServices);
		if(S_OK == hr) 
		{
			for(int iServ = 0; iServ < cServices; iServ++)
			{
				CComVariant cv(iServ);
				ITVEServicePtr spServ;
				hr = m_spServices->get_Item(cv, &spServ);
				_ASSERT(S_OK == hr);

				ITVEAttrTimeQPtr		spAttrTimeQ;			// kill all items in the expire queue..
				hr = spServ->get_ExpireQueue(&spAttrTimeQ);
				if(S_OK == hr)
				{
					spAttrTimeQ->RemoveAll();
				}
				ITVEService_HelperPtr spServHelper(spServ);
				spServHelper->ConnectParent(NULL);				// this kills the back pointer...
			}
		}
	}
	TVEDebugLog((CDebugLog::DBG_SUPERVISOR, 4, _T("Nulling out Services (and hence their children)")));
	m_spServices = NULL;				

			
				// just in case someone used it..
	m_pUnkParent = NULL;

		TVEDebugLog((CDebugLog::DBG_SUPERVISOR, 4, _T("Killing Global Interface Pointers")));
												// Inverse RefCount Fix...
												//    The FinalConstruct did an extra Release in the GIT calls
												//    So do an extra AddRef here..

	if(m_dwSuperGITProxyCookie && g_pIGlobalInterfaceTable) {
		hr = g_pIGlobalInterfaceTable->RevokeInterfaceFromGlobal(m_dwSuperGITProxyCookie);
		m_dwSuperGITProxyCookie = 0;
	}
	if(FAILED(hr))
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 2, _T("RevokeInterfaceFromGlobal failed (hr=0x%08x). May leak"),hr));
	}

	g_pIGlobalInterfaceTable = NULL;
	m_spIGlobalInterfaceTable = NULL;			// force smart pointers to null for better debugging...

						// wipe out the GIT proxy... (Should be no references left on it...)
	m_spTVESupervisorGITProxy = NULL;

#ifdef _USE_FTM	
	m_spUnkMarshaler = NULL;
#endif


	TVEDebugLog((CDebugLog::DBG_SUPERVISOR, 4, _T("Remaining stuff")));
	return hr;								
}

STDMETHODIMP CTVESupervisor::get_Services(ITVEServices **ppVal)
{
	HRESULT hr = S_OK;

	try {
		CheckOutPtr<ITVEServices*>(ppVal);
		CSmartLock spLock(&m_sLk);
		hr = m_spServices->QueryInterface(ppVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}


		// returns S_FALSE  (and NULL) if there is no server...
STDMETHODIMP CTVESupervisor::GetActiveService(ITVEService **ppActiveService)
{
	HRESULT hr = S_OK;
	
	try {
		CheckOutPtr<ITVEService*>(ppActiveService);
		long cServices;
		*ppActiveService = NULL;

		CSmartLock spLock(&m_sLk);		// this really needs the lock...
		hr = m_spServices->get_Count(&cServices);
		if(FAILED(hr))
			return hr;
		if(cServices == 0) 
			return S_FALSE;

		CComVariant cv0(0);
		hr = m_spServices->get_Item(cv0, ppActiveService);		// active one is the first one...
	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}


STDMETHODIMP CTVESupervisor::GetMCastManager(ITVEMCastManager **ppVal)
{
	HRESULT hr = S_OK;
	try {
		CheckOutPtr<ITVEMCastManager *>(ppVal);
		CSmartLock spLock(&m_sLk);	

		*ppVal = NULL;

		hr = m_spMCastManager->QueryInterface(ppVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}


STDMETHODIMP CTVESupervisor::get_Description(BSTR *ppVal)
{
	HRESULT hr = S_OK;
	try {
		CheckOutPtr<BSTR>(ppVal);

		CSmartLock spLock(&m_sLk);
		hr = m_spbsDesc.CopyTo(ppVal);
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}

STDMETHODIMP CTVESupervisor::put_Description(BSTR newVal)
{
	CSmartLock spLock(&m_sLk, WriteLock);
	m_spbsDesc = newVal;
	return S_OK;
}


static DATE 
DateNow()
{		SYSTEMTIME SysTimeNow;
		GetSystemTime(&SysTimeNow);									// initialize with currrent time.
		DATE dateNow;
		SystemTimeToVariantTime(&SysTimeNow, &dateNow);
		return dateNow;
}

STDMETHODIMP CTVESupervisor::ExpireForDate(DATE dateToExpire)
{
	DBG_HEADER(CDebugLog::DBG_SUPERVISOR, _T("CTVESupervisor::ExpireForDate"));
	
	HRESULT hr = S_OK;
	try {

		CSmartLock spLock(&m_sLk);							// ? lock here perhaps dangerous, - yep, seems so
		hr = S_OK;									        //  - this method called by timer thread
															//  - EventQueue calls Service::ExpireForDate
		if(0.0 == dateToExpire) {
			dateToExpire = DateNow();
		}

		ITVEServicePtr spService;
		long cServices;
		hr = m_spServices->get_Count(&cServices);
		if(FAILED(hr)) 
			return hr;
		
		for(int iService = 0; iService < cServices; iService++)
		{
			CComVariant cv(iService);
			hr = m_spServices->get_Item(cv, &spService);
			_ASSERT(S_OK == hr);

			spService->ExpireForDate(dateToExpire);			// caution this could possibly remove current service... 
		}
	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}


void CTVESupervisor::Initialize(TCHAR * strDesc)
{
	CSmartLock spLock(&m_sLk, WriteLock);
	m_spbsDesc = strDesc;
}

// OK to set NULL parent here...
STDMETHODIMP CTVESupervisor::ConnectParent(IUnknown *pUnkParent)
{
	CSmartLock spLock(&m_sLk, WriteLock);
	m_pUnkParent = pUnkParent;		// not smart pointer add ref here, I hope.  (Should I AddRef this?)
	return S_OK;
}


// ----------------------------------------------------------------------------------
//  CTVESupervisor::ConnectAnncListener
//
//			Sets adapter for file and trigger multicast readers the same as
//			the announcement... This could change...
//
//		if ppMCAnnc is non-null, returns an add-refed version of the
//		 newly created (but not-joined) MCast listener object in it.
// ------------------------------------------------------------------------------------

HRESULT 
CTVESupervisor::SetAnncListener(ITVEService *pService, BSTR bstrIPAdapter, BSTR bstrIPAddress, long lPort, ITVEMCast **ppMCAnnc)
{
	DBG_HEADER(CDebugLog::DBG_SUPERVISOR, _T("SetAnncListener"));
	
	HRESULT hr = S_OK;
							// store the values of the announcement into the service (so we can kill it later!)
	ITVEService_HelperPtr spServiceHelper(pService);
	hr = spServiceHelper->SetAnncIPValues(bstrIPAdapter, bstrIPAddress, lPort);

	// look for a Service node on the given IP adapter by looking for the announcement multicast listener
	// If can't find it (which is likely - assert if exists?) then we need to create one.

	ITVEServicePtr spService;					
	ITVEMCastPtr spMCastMatch;
	long cMatches = 0;

	if(m_spMCastManager)
		hr = m_spMCastManager->FindMulticast(bstrIPAdapter, bstrIPAddress, lPort, &spMCastMatch, &cMatches);
	if(FAILED(hr)) 
		return hr;

	if(S_FALSE == hr)		//  FindMulticast returns S_FALSE when can't find one
		hr = S_OK;

	if(0 == cMatches) 		// couldn't find one...
	{	
	} else {
		_ASSERT("This code not done yet");		// find service associated with this adapter
	}

	return hr;
}

// ----------------------------------------------------------
//	 SetATVEFAnncListener - 
//	 SetAnncListener -
//
//		Sets IP addr for ATVEF announcement lister...
//		Call Activate to make it go live...
// -----------------------------------------------------------
HRESULT CTVESupervisor::SetATVEFAnncListener(ITVEService *pService, BSTR bstrIPAdapter)
{
	ITVEMCastPtr spMCAnnc;
	DBG_HEADER(CDebugLog::DBG_SUPERVISOR, _T("SetATVEFAnncListener"));

	if(NULL == pService) 
		return E_POINTER;

	HRESULT hr = SetAnncListener(pService, bstrIPAdapter, L"224.0.1.113", 2670, &spMCAnnc);
	
	return hr;
}


HRESULT CTVESupervisor::RemoveAllListeners()
{
	DBG_HEADER(CDebugLog::DBG_SUPERVISOR, _T("RemoveAllListeners"));

	HRESULT hr = m_spMCastManager->LeaveAll();
	_ASSERT(!FAILED(hr));
	return hr;
}

STDMETHODIMP CTVESupervisor::RemoveAllListenersOnAdapter(BSTR bstrAdapter)		// on helper interface
{
	DBG_HEADER(CDebugLog::DBG_SUPERVISOR, _T("RemoveAllListenersOnAdapter"));

	if(NULL == bstrAdapter)					// for null input, remove *everything*!!!
		return RemoveAllListeners();

	ITVEServicePtr spService;
	long cServices;
	HRESULT hr = m_spServices->get_Count(&cServices);
	if(FAILED(hr)) 
		return hr;
	
	int iDeactivated = 0;

	for(int iService = 0; iService < cServices; iService++)
	{
		CComVariant cv(iService);
		hr = m_spServices->get_Item(cv, &spService);
		_ASSERT(S_OK == hr);
		if(spService) {
			ITVEService_HelperPtr spServHelper(spService);
			CComBSTR spbsAdapter;
			CComBSTR spbsIPAddr;
			LONG lPort;
			spServHelper->GetAnncIPValues(&spbsAdapter, &spbsIPAddr, &lPort);

			if(spbsAdapter == bstrAdapter)
			{
                hr = spService->Deactivate();
                if(S_OK == hr)
                    iDeactivated++;
            }
        }
    }

    return hr;
}


// -------------------------------------------------------------------------------------------------

//Get the IP address of the network adapter.
//  returns unidirectional adapters followed by bi-directional adapters
#include <Iphlpapi.h>		// GetAdaptersInfo, GetUniDirectionalAdaptersInfo
const int kWsz32SizeX = 32;
const int kcMaxIpAdaptsX = 10;
typedef WCHAR Wsz32X[kWsz32SizeX];		// simple fixed length string class for IP adapters

static HRESULT
ListIPAdaptersX(int *pcAdaptersUniDi, int *pcAdaptersBiDi, int cAdapts, Wsz32X *rrgIPAdapts)
{
    try{

        HRESULT				hr				=	 E_FAIL;
        BSTR				bstrIP			= 0;
        PIP_ADAPTER_INFO	pAdapterInfo;
        ULONG				Size			= NULL;
        DWORD				Status;
        WCHAR				wszIP[16];
        int					cAdapters		= 0;
        int					cAdaptersUni	= 0;

        memset((void *) rrgIPAdapts, 0, cAdapts*sizeof(Wsz32X));


        memset(wszIP, 0, sizeof(wszIP));

        // staticly allocate a buffer to store the data
        const int kMaxAdapts = 20;
        const int kSize = sizeof (IP_UNIDIRECTIONAL_ADAPTER_ADDRESS) + kMaxAdapts * sizeof(IPAddr);
        char szBuff[kSize];
        IP_UNIDIRECTIONAL_ADAPTER_ADDRESS *pPIfInfo = (IP_UNIDIRECTIONAL_ADAPTER_ADDRESS *) szBuff;

        // get the data..
        ULONG ulSize = kSize;
        hr =  GetUniDirectionalAdapterInfo(pPIfInfo, &ulSize);
        if(S_OK == hr)
        {
            USES_CONVERSION;
            while(cAdaptersUni < (int) pPIfInfo->NumAdapters) {
                in_addr inadr;
                inadr.s_addr = pPIfInfo->Address[cAdaptersUni];
                char *szApAddr = inet_ntoa(inadr);
                WCHAR *wApAddr = A2W(szApAddr);
                wcscpy(rrgIPAdapts[cAdaptersUni++], wApAddr);
            }
        }


        if ((Status = GetAdaptersInfo(NULL, &Size)) != 0)
        {
            if (Status != ERROR_BUFFER_OVERFLOW)
            {
                return 0;
            }
        }

        // Allocate memory from sizing information
        pAdapterInfo = (PIP_ADAPTER_INFO) GlobalAlloc(GPTR, Size);
        if(pAdapterInfo)
        {
            // Get actual adapter information
            Status = GetAdaptersInfo(pAdapterInfo, &Size);

            if (!Status)
            {
                PIP_ADAPTER_INFO pinfo = pAdapterInfo;

                while(pinfo && (cAdapters < cAdapts))
                {
                    MultiByteToWideChar(CP_ACP, 0, pinfo->IpAddressList.IpAddress.String, -1, wszIP, 16);
                    if(wszIP)
                        wcscpy(rrgIPAdapts[cAdaptersUni + cAdapters++], wszIP);
                    pinfo = pinfo->Next;
                }

            }
            GlobalFree(pAdapterInfo);
        }

        *pcAdaptersUniDi = cAdaptersUni;
        *pcAdaptersBiDi  = cAdapters;
        return hr;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}

// returns known adapter addresses in a fixed static string.  Client shouldn't free it.
//  This is a bogus routine - test use only...

static HRESULT
GetIPAdapterAddresses(/*[out]*/ int *pcAdaptersUniDi, /*[out]*/ int *pcAdaptersBiDi, 
								   /*[out]*/ Wsz32X **rgAdaptersUniDi,  /*[out]*/ Wsz32X **rgAdaptersBiDi)
{
	HRESULT hr = S_OK;

	if(NULL == pcAdaptersUniDi || NULL == pcAdaptersBiDi)
		return E_POINTER;

    static Wsz32X grgAdapters[kcMaxIpAdaptsX];	// array of possible IP adapters
    hr = ListIPAdaptersX(pcAdaptersUniDi, pcAdaptersBiDi, kcMaxIpAdaptsX, grgAdapters);

    if(NULL != rgAdaptersUniDi)
        *rgAdaptersUniDi = grgAdapters;
    if(NULL != rgAdaptersBiDi)
        *rgAdaptersBiDi = grgAdapters + *pcAdaptersUniDi;

    return hr;
}
// hacky method to find possible IPSink adapter address.
//  iAdapter is 0-N - gives the N'th possible adapter
//   (first ones are unidirection, second ones are bidirectional)
STDMETHODIMP CTVESupervisor::get_PossibleIPAdapterAddress(int iAdapter, BSTR *pbstrAdapter)		// on helper interface
{
    HRESULT hr = S_OK;

    int cAdaptersUniDi=0;
    int cAdaptersBiDi=0;

    Wsz32X *rgAdaptersUniDi, *rgAdaptersBiDi;

    hr = GetIPAdapterAddresses(&cAdaptersUniDi, &cAdaptersBiDi, 
        &rgAdaptersUniDi, &rgAdaptersBiDi);
    if(iAdapter < 0 || iAdapter > cAdaptersUniDi + cAdaptersUniDi)
        return S_FALSE;
    CComBSTR bstrAdapter;
    if(iAdapter < cAdaptersUniDi)
        bstrAdapter = rgAdaptersUniDi[iAdapter];
    else 
        bstrAdapter = rgAdaptersBiDi[iAdapter - cAdaptersUniDi];

    return bstrAdapter.CopyTo(pbstrAdapter);
}

// ----------------------------------------------------------------------------------------------

static HRESULT 
CheckIPAdapterSyntax(BSTR bstrIPAdapter)
{
    try{
        USES_CONVERSION;
        HRESULT hr = S_OK;
        ULONG ipAdaptAddr = inet_addr(W2A(bstrIPAdapter));
        if(ipAdaptAddr == INADDR_NONE) 
            return E_INVALIDARG;

        if(0 == ipAdaptAddr)						// allow '0.0.0.0' 
            return S_OK;

        static int cAdaptersUniDi=0;
        static int cAdaptersBiDi=0;
        static ULONG gulAdapters[kcMaxIpAdaptsX];	// array of possible IP adapters
        int fJustGened = false;

        while(true)
        {
            if(0 == cAdaptersUniDi + cAdaptersBiDi)
            {
                Wsz32X *rgAdaptersUniDi, *rgAdaptersBiDi;
                // generate a static list of IP adapters...
                if(0 == cAdaptersUniDi + cAdaptersBiDi)
                {
                    hr = GetIPAdapterAddresses(&cAdaptersUniDi, &cAdaptersBiDi, 
                        &rgAdaptersUniDi,  &rgAdaptersBiDi);
                    if(FAILED(hr))
                        return hr;

                    int i;
                    for(i = 0; i < cAdaptersUniDi; i++)
                        gulAdapters[i] = inet_addr(W2A(rgAdaptersUniDi[i]));

                    for(i = 0; i < cAdaptersBiDi; i++)
                        gulAdapters[i+cAdaptersUniDi] = inet_addr(W2A(rgAdaptersBiDi[i]));
                    fJustGened = true;
                }
            }

            for(int j = 0; j < cAdaptersUniDi + cAdaptersBiDi; j++)
            {
                if(gulAdapters[j] == ipAdaptAddr)					// found it...  Yeah!
                    return S_OK;
            }
            if(fJustGened == false)			// if didn't just generate the adapter list, regenerate it and try again.
            {
                cAdaptersUniDi = 0;
                cAdaptersBiDi = 0;
            } else {
                return E_INVALIDARG;								// else not in the list...
            }
        }

        return S_OK;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}

			// if told to retune to a currently active service, returns S_FALSE
			// if told to tune to a service that isn't on the supervisor's collection, returns E_NOIN
STDMETHODIMP CTVESupervisor::ReTune(ITVEService *pServiceToActivate)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_SUPERVISOR, _T("CTVESupervisor::ReTune"));
    if(!pServiceToActivate){
        return E_POINTER;
    }

	ITVEServicePtr spService;
	ITVEServicePtr spServiceToDeactivate;
	IUnknownPtr spServiceToActivePunk(pServiceToActivate);
	if(NULL == spServiceToActivePunk)
		return E_NOINTERFACE;

	long cServices;
	hr = m_spServices->get_Count(&cServices);
	if(FAILED(hr))
		return hr;

	int iService;
	BOOL fFoundIt = false;
    if(cServices > 0)
    {
	    for( iService = cServices-1; iService >= 0; --iService)     // count backwards since we may remove objects here
	    {
		    CComVariant cv(iService);
		    hr = m_spServices->get_Item(cv, &spService);
		    IUnknownPtr spServicePunk(spService);

		    if(spServicePunk == spServiceToActivePunk)
		    {
			    fFoundIt = TRUE;
		    } else {
			    VARIANT_BOOL fActive;
			    spService->get_IsActive(&fActive);
			    if(fActive) {
				    _ASSERTE(NULL == spServiceToDeactivate);		// more than one existing active service
				    spServiceToDeactivate = spService;
				    spService->Deactivate();						// when allow multiple active services, this line has to go...
                            
                                                                    // efficency fix
                                                                    // if havent seen any atvef traffic on this service we just
                                                                    // deactivated, pull it out of the Services collection
                    long cEnhancements = 0;
                    {
                        ITVEEnhancementsPtr spEnhancementsD;
                        hr = spService->get_Enhancements(&spEnhancementsD);
                        if(!FAILED(hr)) {
                            spEnhancementsD->get_Count(&cEnhancements);
                            _ASSERT(!FAILED(hr));
                        }
                    }
                    if(0 == cEnhancements)
                    {
                        IUnknownPtr spServPunk(spService);
                        CComVariant cvServPunk((IUnknown *) spServPunk);
                        hr = m_spServices->Remove(cvServPunk);
                        _ASSERT(!FAILED(hr));
                    }
			    }	
		    }
	    }
    }

	if(!fFoundIt)
		return E_INVALIDARG;									// not there to reactivate
	
	VARIANT_BOOL fActive = false;
	CComBSTR spbsDescription;
	if(pServiceToActivate)
	{
		pServiceToActivate->get_IsActive(&fActive);
		pServiceToActivate->get_Description(&spbsDescription);
	}

	if(!fActive)												// told to tune to currently inactive enhancement
	{

		TVEDebugLog((CDebugLog::DBG_SUPERVISOR,2,L"\t\t - Reactivating Inactive Service '%s'\n",spbsDescription));

		hr = pServiceToActivate->Activate();				// restart it
		NotifyTune(FAILED(hr) ? NTUN_Fail :NTUN_Reactivate, pServiceToActivate, spbsDescription,L"");
		return hr;
	} 
	else													// found and active one
	{
		TVEDebugLog((CDebugLog::DBG_SUPERVISOR,2,L"\t\t - Service already active '%s'\n",spbsDescription));
		return S_FALSE;
	}
}
			// either finds an existing or creates a new service, and tunes to it.
			//  If both values are null, turns off ATVEF.
STDMETHODIMP CTVESupervisor::TuneTo(BSTR bstrDescription, BSTR bstrIPAdapter)
{
	USES_CONVERSION;
	DBG_HEADER(CDebugLog::DBG_SUPERVISOR, _T("CTVESupervisor::TuneTo"));

	HRESULT hr = S_OK;
	try 
	{
		long cServices;
		if(NULL == m_spServices)			// not setup correctly....
			return S_FALSE;

		hr = m_spServices->get_Count(&cServices);
		if(FAILED(hr)) 
		{
			NotifyTune(NTUN_Fail, NULL, _T(""), _T("")); 
			return hr;
		}


		if((NULL == bstrDescription  || NULL == bstrDescription[0])&& 
		   (NULL == bstrIPAdapter    || NULL == bstrIPAdapter[0]))		// turn off ATVEF
		{
			TVEDebugLog((CDebugLog::DBG_SUPERVISOR, 3, _T("\t\t  -  Turning Off ATVEF\n")));
			if(cServices > 0)		  // BUGBUG - what if no active service?
			{

				ITVEServicePtr spService;
				CComVariant cv0(0);								// ONLY active service is the first one
				hr = m_spServices->get_Item(cv0, &spService);		// (need to change is support more active services)
				if(!FAILED(hr))
					hr = spService->Deactivate();				// returns S_FALSE if already deactiaved
		
										// now go and remove all the services... (new JB 03/08... According to spec, I'm supposed to do this..)
				m_spServices->RemoveAll();
			}

			if(cServices > 0 && hr == S_OK && !m_fInFinalRelease)
				NotifyTune(NTUN_Turnoff, NULL, bstrDescription, bstrIPAdapter);  

			HRESULT hr2 = S_OK;
			if(NULL != m_spMCastManager)
				hr2 = m_spMCastManager->LeaveAll();			// just for paranoia (shouldn't be any with only one active service)

			g_CacheManager.SetTVESupervisor(NULL);			// kill the back pointer

			if(FAILED(hr2))
				NotifyTune(NTUN_Fail, NULL, bstrDescription, bstrIPAdapter); 
			return FAILED(hr) ? hr : hr2;
		}

		if(FAILED(hr = CheckIPAdapterSyntax(bstrIPAdapter)))
		{
			NotifyTune(NTUN_Fail, NULL, bstrDescription, bstrIPAdapter);  // (seems to crash)
			return hr; 
		}

					// must specify a unique description field - used to identify service space..
		if(NULL == bstrDescription || NULL == bstrDescription[0])
		{
			NotifyTune(NTUN_Fail, NULL, _T(""), _T(""));  // (seems to crash)
			return E_INVALIDARG;
		}

					// QueueTheread may of been turned off (in TuneTo(NULL,NULL)
					//    restart it (OK to do this if already running, just returns S_FALSE)
		ITVEMCastManager_HelperPtr spMCHelper(m_spMCastManager);
		hr = spMCHelper->CreateQueueThread();
		_ASSERT(!FAILED(hr));			

					// augment the description field by the IP adapater, so don't create
					// same service if name on different IP adapters happens to be the same.
		CComBSTR spDescriptionAug(bstrDescription);
		spDescriptionAug.Append(_T("("));
		spDescriptionAug.Append(bstrIPAdapter);
		spDescriptionAug.Append(_T(")"));

		ITVEServicePtr spService;
		ITVEServicePtr spServiceToActivate;
		ITVEServicePtr spServiceToDeactivate;
		int iService;
		int iServiceFound = -1;
        if(cServices > 0)
        {
		    for( iService = cServices-1; iService >= 0; --iService)     // count backwards since we may remove service with no atvef data here
		    {
			    CComVariant cv(iService);
			    hr = m_spServices->get_Item(cv, &spService);
			    _ASSERT(S_OK == hr);
			    CComBSTR bstrN_Description;
			    CComBSTR bstrN_IPAdapter;
			    spService->get_Description(&bstrN_Description);
			    if(bstrN_Description == spDescriptionAug)
			    {
				    spServiceToActivate = spService;
				    iServiceFound = iService;
			    } else {
				    VARIANT_BOOL fActive;
				    spService->get_IsActive(&fActive);
				    if(fActive) {
					    _ASSERTE(NULL == spServiceToDeactivate);		// more than one existing active service
					    spServiceToDeactivate = spService;
					    spService->Deactivate();						// when allow multiple active services, this line has to go...

                                                                        // efficency fix
                                                                        // if havent seen any atvef traffic on this service we just
                                                                        // deactivated, pull it out of the Services collection
                        long cEnhancements = 0;
                        {
                            ITVEEnhancementsPtr spEnhancementsD;
                            hr = spService->get_Enhancements(&spEnhancementsD);
                            if(!FAILED(hr)) {
                                spEnhancementsD->get_Count(&cEnhancements);
                                _ASSERT(!FAILED(hr));
                            }
                        }
                        if(0 == cEnhancements)
                        {
                            IUnknownPtr spServPunk(spService);
                            CComVariant cvServPunk((IUnknown *) spServPunk);
                            hr = m_spServices->Remove(cvServPunk);
                            _ASSERT(!FAILED(hr));
                        }
				    }	
			    }
		    }
        }

		const int kC=1023;
		WCHAR wszBuff[kC+1];
		VARIANT_BOOL fActive = false;
		if(spServiceToActivate)
			spServiceToActivate->get_IsActive(&fActive);

		if(fActive)
		{
			if(DBG_FSET(CDebugLog::DBG_SUPERVISOR))
			{	
				_snwprintf(wszBuff,kC,L"\t\t - Service already active '%s' adapter %s\n",bstrDescription,bstrIPAdapter);
				DBG_WARN(CDebugLog::DBG_SUPERVISOR, W2T(wszBuff));
			}
			return S_FALSE;
		}
		else if(NULL != spServiceToActivate)			// found an old one
		{
			if(DBG_FSET(CDebugLog::DBG_SUPERVISOR))
			{	
				_snwprintf(wszBuff,kC,L"\t\t -  Retune to an Inactive Service '%s' adapter %s\n",bstrDescription,bstrIPAdapter);
				DBG_WARN(CDebugLog::DBG_SUPERVISOR, W2T(wszBuff));
			}
			{
		//		CSmartLock spLock(&m_sLk, WriteLock);
				hr = spServiceToActivate->Activate();					// turn it back on...
			}
						// don't put Notifies inside a WriteLock - leads to a deadlock	
			NotifyTune(FAILED(hr) ? NTUN_Fail : NTUN_Retune, spService, bstrDescription, bstrIPAdapter);
			return hr;
		} 
		else										// need to create a new one
		{
			if(DBG_FSET(CDebugLog::DBG_SUPERVISOR))
			{	
				_snwprintf(wszBuff,kC,L"Creating A New Service '%s' adapter %s\n",bstrDescription,bstrIPAdapter);
				DBG_WARN(CDebugLog::DBG_SUPERVISOR, W2T(wszBuff));
			}
													// create a new service node
			CComObject<CTVEService> *pService;
			hr = CComObject<CTVEService>::CreateInstance(&pService);
			if(!FAILED(hr)) 
				hr = pService->QueryInterface(&spService);			

			if(!FAILED(hr)) 
			{
				ITVEService_HelperPtr	spServHelper(spService);

					// various ways to get the same thing
	//		ITVESupervisor *spI = (ITVESupervisor *)(this);					// this doesn't work
	//		ITVESupervisorPtr spSuper(this);								// ????		this doesn't seem to work...
	//		ITVESupervisor* pSuper2 = static_cast<ITVESupervisor *>(this);
				CComPtr<ITVESupervisor> spSuperThis(this);  
				hr = spServHelper->ConnectParent(spSuperThis);				// store the back pointer...

				if(!FAILED(hr))
					hr = SetATVEFAnncListener(spService, bstrIPAdapter);
		
				{
					CSmartLock spLock(&m_sLk, WriteLock);

					if(!FAILED(hr))
						hr = m_spServices->Insert(0,spService);					// add it to the begining of the list...

					IUnknownPtr	spUnkThis(this);
					if(!FAILED(hr)) 
						hr = g_CacheManager.SetTVESupervisor(spUnkThis);		// set the backpointer for file-events - not a smart pointer
				}

				if(!FAILED(hr)) {
					hr = spService->Activate();								// turn it on
				}
			}

													// save away the description (used for searching)
			if(!FAILED(hr)) 
				pService->put_Description(spDescriptionAug);

			NotifyTune(FAILED(hr) ? NTUN_Fail : NTUN_New, spService, bstrDescription, bstrIPAdapter);
		}
    } catch(_com_error e) {
        hr = e.Error();
    } catch(HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}


STDMETHODIMP CTVESupervisor::NewXOverLink(BSTR bstrLine21Trigger)
{
	ITVESupervisor_HelperPtr spSuperHelper(this);
	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NewXOverLink"));

		// call method on running service...
	HRESULT hr = S_OK;
	try {
		ITVEServicePtr	spActiveService;
		hr = spSuperHelper->GetActiveService(&spActiveService);
		if(FAILED(hr))
			return hr;
		if(NULL == spActiveService)			// forgot an inital TuneTo command.
			return E_POINTER;
		hr =  spActiveService->NewXOverLink(bstrLine21Trigger);	
		if(!FAILED(hr))
		{
			m_tveStats.m_cXOverLinks++;		// keep tracks of XOverLinks specially
			m_tveStats.m_cTriggers--;
		}
	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}
// ---------------------------------------------------------------------------------
//   Notifications
//
//			In many langauges (javascript), events appear to need to be triggered
///		out of the the same thread the calling routine is running in. 
//		However, most work in the supervisor is actually done in the 'Queue' thread,
//		which was spawned off to keep the UI thread resposive.  Each of the multicast
//		listeners sends it data over to the queue thread, which then parses it and adds
//		it to the TVE data structure tree.  When this parsing is done, it sends events
//		up to the U/I, but because it is not the main calling thread, the events need
//		to be marshelled.
//
//			The proxying is done via the globlal interface table.  An interface into the
//		main thread is retrived via it, and then the event is resent with the (_XProxy
//		method) on that interface.	ATL does it's magic, and that event is fired in
//		the main supervisor thread. 
//	
// ---------------------------------------------------------------------------------
#define USE_PROXY				// needed.. 

								// lChangedFlags is combination of NENH_grfDiff
STDMETHODIMP CTVESupervisor::NotifyEnhancement(NENH_Mode enMode, ITVEEnhancement *pEnhancement, long lChangedFlags)
{
//	CSmartLock spLock(&m_sLk);		// don't lock the notifies...

#ifdef USE_PROXY 
	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NotifyEnhancement"));

	ITVESupervisorGITProxyPtr spGITProxy;
	HRESULT hr = m_spIGlobalInterfaceTable->GetInterfaceFromGlobal(m_dwSuperGITProxyCookie,
																__uuidof(spGITProxy),  
																reinterpret_cast<void**>(&spGITProxy));
	ITVESupervisorPtr spSuperMainThread;
	if(!FAILED(hr))
	{
		hr = spGITProxy->get_Supervisor(&spSuperMainThread);
	}

	if(!FAILED(hr))
	{
		ITVESupervisor_HelperPtr spSuperHelperMainThread(spSuperMainThread);
		if(NULL == spSuperHelperMainThread)
			return E_NOINTERFACE;
		hr = spSuperHelperMainThread->NotifyEnhancement_XProxy(enMode, pEnhancement, lChangedFlags);

		return hr;
	}
	return hr;

#else
	return NotifyEnhancement_XProxy(enMode, pEnhancement, lChangedFlags);
#endif
}

STDMETHODIMP CTVESupervisor::NotifyEnhancement_XProxy(NENH_Mode enMode, ITVEEnhancement *pEnhancement, long lChangedFlags)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NotifyEnhancement_XProxy"));

                // shutdown all events in final release 
    if(m_fInFinalRelease) 
        return S_OK;

	if(DBG_FSET(CDebugLog::DBG_EVENT)) 
	{
		USES_CONVERSION;

		const int kC=1023;
		WCHAR wszBuff[kC+1];
		CComBSTR spbsName("???");
		LONG lSessionId = 0;
		LONG lSessionVer = 0;
		if(pEnhancement) {
			pEnhancement->get_SessionName(&spbsName);
			pEnhancement->get_SessionId(&lSessionId);
			pEnhancement->get_SessionVersion(&lSessionVer);

			ITVEAttrMapPtr   spAttrs;
			pEnhancement->get_Attributes(&spAttrs);
			CComBSTR spbsAttrs;
			spAttrs->DumpToBSTR(&spbsAttrs);
			CComBSTR spbsDump;
			ITVEEnhancement_HelperPtr	spEnhHelper(pEnhancement);
			spEnhHelper->DumpToBSTR(&spbsDump);
		}
		switch(enMode)
		{
		case NENH_New:		
			_snwprintf(wszBuff,kC,L"New Enhancement: '%s' : Id %d Ver %d\n",spbsName, lSessionId, lSessionVer);
			break;
		case NTRK_Duplicate:				// don't pass the Resend Upward.
			_snwprintf(wszBuff,kC,L"Duplicate Enhancement: '%s' : Id %d Ver %d\n",spbsName, lSessionId, lSessionVer);
			break;
		case NENH_Updated:
			_snwprintf(wszBuff,kC,L"Updated Enhancement: '%s' : Id %d Ver %d\n",spbsName, lSessionId, lSessionVer);
			break;
		case NENH_Starting:
			_snwprintf(wszBuff,kC,L"Starting Enhancement: '%s' : Id %d Ver %d\n",spbsName, lSessionId, lSessionVer);
			break;
		case NENH_Expired:
			_snwprintf(wszBuff,kC,L"Expired Enhancement: '%s' : Id %d Ver %d\n",spbsName, lSessionId, lSessionVer);
			break;
		}
			
		TVEDebugLog((CDebugLog::DBG_EVENT, 2, W2T(wszBuff)));
	}

	m_tveStats.m_cEnhancements++;
	switch(enMode)
	{
	case NENH_New:
//		Fire_NotifyTVEEnhancementNew(NULL);
		Fire_NotifyTVEEnhancementNew(pEnhancement);
		break;
	case NTRK_Duplicate:									// nothing changed... tell UI anyway
		Fire_NotifyTVEEnhancementUpdated(pEnhancement, 0);		// (multiple annoying painful times due to not knowing about duplicates!)
		break;
	case NENH_Updated:
		Fire_NotifyTVEEnhancementUpdated(pEnhancement, lChangedFlags);
		break;
	case NENH_Starting:
		Fire_NotifyTVEEnhancementStarting(pEnhancement);
		break;
	case NENH_Expired:
		Fire_NotifyTVEEnhancementExpired(pEnhancement);
		break;
	default:
		_ASSERT(false);
	}

	return S_OK;
}

// --------------------------------------------------------------------

			// lChangedFlags is combination of NTRK_grfDiff
STDMETHODIMP CTVESupervisor::NotifyTrigger(NTRK_Mode enMode, ITVETrack *pTrack, long lChangedFlags)
{
//	CSmartLock spLock(&m_sLk);			// don't lock the notifies (always called from lower in tree)

#ifdef USE_PROXY
	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NotifyTrigger"));
	ITVESupervisorGITProxyPtr spGITProxy;
	HRESULT hr = m_spIGlobalInterfaceTable->GetInterfaceFromGlobal(m_dwSuperGITProxyCookie,
																__uuidof(spGITProxy),  
																reinterpret_cast<void**>(&spGITProxy));
	ITVESupervisorPtr spSuperMainThread;
	if(!FAILED(hr))
	{
		hr = spGITProxy->get_Supervisor(&spSuperMainThread);
	}

	if(!FAILED(hr))
	{
		ITVESupervisor_HelperPtr spSuperHelperMainThread(spSuperMainThread);
		if(NULL == spSuperHelperMainThread)
			return E_NOINTERFACE;
		return spSuperHelperMainThread->NotifyTrigger_XProxy(enMode, pTrack, lChangedFlags);
	}
	return hr;
#else
	return NotifyTrigger_XProxy(enMode, pTrack, lChangedFlags);
#endif
}

STDMETHODIMP CTVESupervisor::NotifyTrigger_XProxy(NTRK_Mode enMode, ITVETrack *pTrack, long lChangedFlags)
{

	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NotifyTrigger_XProxy"));
	BOOL fActive = false;			// TODO: need to write code to support this

                // shutdown all events in final release 
    if(m_fInFinalRelease) 
        return S_OK;

	HRESULT hr;
	if(NULL == pTrack) 
	{
		return E_INVALIDARG;
	} 
	else 
	{
		ITVETriggerPtr spTrig;
		hr = pTrack->get_Trigger(&spTrig);
		if(!FAILED(hr)) {

			if(DBG_FSET(CDebugLog::DBG_EVENT)) 
			{
				USES_CONVERSION;

				const kC = 2047;
				WCHAR wszBuff[kC+1];
				CComBSTR spbsName;
				CComBSTR spbsURL;
				spTrig->get_Name(&spbsName);
				spTrig->get_URL(&spbsURL);
				CComBSTR spbsActive;
				if(fActive)
					spbsActive = L"(Active)";
				else
					spbsActive = L"";

				switch(enMode)
				{
				case NTRK_New:
					_snwprintf(wszBuff, kC, L"New Trigger%s: %s <%s>\n",spbsActive,spbsName,spbsURL);
					break;
				case NTRK_Duplicate:
					_snwprintf(wszBuff, kC, L"Duplicate Trigger%s: %s <%s>(no event)\n",spbsActive,spbsName,spbsURL);
					break;
				case NTRK_Updated:
					_snwprintf(wszBuff, kC, L"Updated Trigger%s: %s <%s>(0x%08x)\n",spbsActive,spbsName,spbsURL,lChangedFlags);
					break;
				case NTRK_Expired:
					_snwprintf(wszBuff, kC, L"Expired Trigger%s: %s <%s>\n",spbsActive,spbsName,spbsURL);
					break;
				default:
					_snwprintf(wszBuff, kC, L"*** Error *** Unknown NotifyTrigger Mode (%d)\n",enMode);
					break;
				}
				DBG_WARN(CDebugLog::DBG_EVENT, W2T(wszBuff));
			}


			m_tveStats.m_cTriggers++;
			switch(enMode)
			{
			case NTRK_New:
				Fire_NotifyTVETriggerNew(spTrig, fActive);
				break;
			case NTRK_Duplicate:				// don't pass the Resend Upward.
				Fire_NotifyTVETriggerUpdated(spTrig, fActive, (DWORD) 0);			// no change
				break;
			case NTRK_Updated:
				Fire_NotifyTVETriggerUpdated(spTrig, fActive, lChangedFlags);
				break;
			case NTRK_Expired:
				Fire_NotifyTVETriggerExpired(spTrig, fActive);
				break;
			default:
				_ASSERT(false);
				break;
			}
		}
	}

	return S_OK;
}

// ------------------------------------------------------------------------------


STDMETHODIMP CTVESupervisor::NotifyPackage(NPKG_Mode eMode, ITVEVariation *pVariation, BSTR bstrPackageUUID, long cBytesTotal, long cBytesReceived)
{
//	CSmartLock spLock(&m_sLk);			// don't lock the notifies (always called from lower in tree)

#ifdef USE_PROXY
	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NotifyPackage"));
	ITVESupervisorGITProxyPtr spGITProxy;
	HRESULT hr = m_spIGlobalInterfaceTable->GetInterfaceFromGlobal(m_dwSuperGITProxyCookie,
																__uuidof(spGITProxy),  
																reinterpret_cast<void**>(&spGITProxy));
	ITVESupervisorPtr spSuperMainThread;
	if(!FAILED(hr))
	{
		hr = spGITProxy->get_Supervisor(&spSuperMainThread);
	}

	if(!FAILED(hr))
	{
		ITVESupervisor_HelperPtr spSuperHelperMainThread(spSuperMainThread);
		if(NULL == spSuperHelperMainThread)
			return hr;

		CComBSTR bstrPackageUUIDProx(bstrPackageUUID);			// seems important all strings are real CComBSTRs,
															// (rather than static string buffers) else they die in marshalling
		hr = spSuperHelperMainThread->NotifyPackage_XProxy(eMode, pVariation, bstrPackageUUIDProx, cBytesTotal, cBytesReceived);
	}
	return hr;
#else
	return NotifyPackage_XProxy(eMode, pVariation, bstrPackageUUID, cBytesTotal, cBytesReceived);
#endif
}

STDMETHODIMP CTVESupervisor::NotifyPackage_XProxy(NPKG_Mode eMode, ITVEVariation *pVariation, BSTR bstrPackageUUID, long cBytesTotal, long cBytesReceived)
{
	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NotifyPackage_XProxy"));

                    // shutdown all events in final release 
    if(m_fInFinalRelease) 
        return S_OK;

	if(DBG_FSET(CDebugLog::DBG_EVENT)) 
	{
		USES_CONVERSION;

		CComBSTR spbsType;
		switch(eMode)
		{
		case NPKG_Starting:  spbsType = "Starting";  break;
		case NPKG_Received:  spbsType = "Finished";  break;
		case NPKG_Duplicate: spbsType = "Duplicate"; break;	// only sent on packet 0
		case NPKG_Resend:    spbsType = "Resend";    break; // only sent on packet 0
		case NPKG_Expired:   spbsType = "Expired";   break;
		default: spbsType = "Unknown";
		}
		const int kC = 1023;
		WCHAR wszBuff[kC+1];
		_snwprintf(wszBuff, kC, L"Package %s: %s (%8.2f KBytes)\n",spbsType, bstrPackageUUID, cBytesTotal/1024.0f);
		DBG_WARN(CDebugLog::DBG_EVENT, W2T(wszBuff));
	}

	m_tveStats.m_cPackages++;
	Fire_NotifyTVEPackage(eMode, pVariation, bstrPackageUUID, cBytesTotal, cBytesReceived);

	return S_OK;
}

// ------------------------------------------------------------------------------

STDMETHODIMP CTVESupervisor::NotifyFile(NFLE_Mode enMode, ITVEVariation *pVariation, BSTR bstrURLName, BSTR bstrFileName)
{
//	CSmartLock spLock(&m_sLk);			// don't lock the notifies (always called from lower in tree)

#ifdef USE_PROXY
	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NotifyFile"));
	ITVESupervisorGITProxyPtr spGITProxy;
	HRESULT hr = m_spIGlobalInterfaceTable->GetInterfaceFromGlobal(m_dwSuperGITProxyCookie,
																__uuidof(spGITProxy),  
																reinterpret_cast<void**>(&spGITProxy));
	ITVESupervisorPtr spSuperMainThread;
	if(!FAILED(hr))
	{
		hr = spGITProxy->get_Supervisor(&spSuperMainThread);
	}

	if(!FAILED(hr))
	{
		ITVESupervisor_HelperPtr spSuperHelperMainThread(spSuperMainThread);
		if(NULL == spSuperHelperMainThread)
			return E_NOINTERFACE;

		CComBSTR bstrFileNameProx(bstrFileName);	
		CComBSTR bstrURLNameProx(bstrURLName);				// seems important all strings are real CComBSTRs,
														// (rather than static string buffers) else they die in marshalling

		return spSuperHelperMainThread->NotifyFile_XProxy(enMode, pVariation, bstrURLNameProx, bstrFileNameProx);
	}
	return hr;
#else
	return NotifyFile_XProxy(enMode, pVariation, bstrURLName, bstrFileName);
#endif
}


STDMETHODIMP CTVESupervisor::NotifyFile_XProxy(NFLE_Mode enMode, ITVEVariation *pVariation, BSTR bstrURLName, BSTR bstrFileName)
{
	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NotifyFile_XProxy"));

                // shutdown all events in final release 
    if(m_fInFinalRelease) 
        return S_OK;

	if(DBG_FSET(CDebugLog::DBG_EVENT)) 
	{
		USES_CONVERSION;
		const int kC=1023;
		WCHAR wszBuff[kC+1];
		_snwprintf(wszBuff,kC,L"%s File: %s -> %s\n", 
					  (enMode == NFLE_Received) ? _T("Received") :
					   ((enMode == NFLE_Expired) ? _T("Expired") : _T("Unknown Mode")),
				bstrURLName, bstrFileName);
		DBG_WARN(CDebugLog::DBG_EVENT, W2T(wszBuff));
	}	 

	m_tveStats.m_cFiles++;
	Fire_NotifyTVEFile(enMode, pVariation, bstrURLName, bstrFileName);

	return S_OK;
}

// -------------------------------------------------------

STDMETHODIMP CTVESupervisor::NotifyTune(NTUN_Mode engTuneMode, ITVEService *pService, BSTR bstrDescription, BSTR bstrIPAdapter)
{
//	CSmartLock spLock(&m_sLk);			// don't lock the notifies (always called from lower in tree)

#ifdef USE_PROXY
	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NotifyTune"));
	ITVESupervisorGITProxyPtr spGITProxy;
	HRESULT hr = m_spIGlobalInterfaceTable->GetInterfaceFromGlobal(m_dwSuperGITProxyCookie,
																__uuidof(spGITProxy),  
																reinterpret_cast<void**>(&spGITProxy));
	ITVESupervisorPtr spSuperMainThread;
	if(!FAILED(hr))
	{
		hr = spGITProxy->get_Supervisor(&spSuperMainThread);
	}

	if(FAILED(hr)) {
		if(NTUN_Turnoff != engTuneMode)	
			_ASSERT(false);		// don't bother with ASSERT when turning off (in Supers FinalRelease())
		return hr;
	}

	if(!FAILED(hr))
	{
		ITVESupervisor_HelperPtr spSuperHelperMainThread(spSuperMainThread);
		if(NULL == spSuperHelperMainThread)
			return E_NOINTERFACE;
		CComBSTR bstrDescriptionProx(bstrDescription);	
		CComBSTR bstrIPAdapterProx(bstrIPAdapter);	

		return spSuperHelperMainThread->NotifyTune_XProxy(engTuneMode, pService, bstrDescriptionProx, bstrIPAdapterProx);
	}
	return hr;
#else
	return NotifyTune_XProxy(engTuneMode, pService, bstrDescription, bstrIPAdapter);
#endif
}

// -------------------------------------------------------

STDMETHODIMP CTVESupervisor::NotifyTune_XProxy(NTUN_Mode engTuneMode, ITVEService *pService, BSTR bstrDescription, BSTR bstrIPAdapter)
{
	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NotifyTune_XProxy"));

                    // shutdown all events in final release 
    if(m_fInFinalRelease) 
        return S_OK;

	if(DBG_FSET(CDebugLog::DBG_EVENT)) 
	{
		USES_CONVERSION;
		const int kC=1023;
		WCHAR wszBuff[kC+1];

		CComBSTR bstrWhat;
		switch(engTuneMode) {
		case NTUN_New:			bstrWhat = L"New"; break;
		case NTUN_Retune:		bstrWhat = L"Retune"; break;
		case NTUN_Reactivate:	bstrWhat = L"Reactivate"; break;
		case NTUN_Turnoff:		bstrWhat = L"Turn off"; break;
		default:
		case NTUN_Fail:			bstrWhat = L"Fail"; break;
		}

		_snwprintf(wszBuff,kC,L"%s Tune: %s -> %s\n", bstrWhat, bstrDescription, bstrIPAdapter);
		DBG_WARN(CDebugLog::DBG_EVENT, W2T(wszBuff));
	}	 

	m_tveStats.m_cTunes++;
	Fire_NotifyTVETune(engTuneMode, pService, bstrDescription, bstrIPAdapter);

	return S_OK;
}

// -------------------------------------------------------

STDMETHODIMP CTVESupervisor::NotifyAuxInfo(NWHAT_Mode engAuxInfoMode, BSTR bstrAuxInfoString, long lgrfWhatDiff, long lErrorLine)
{
//	CSmartLock spLock(&m_sLk);			// don't lock the notifies (always called from lower in tree)

#ifdef USE_PROXY
	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NotifyAuxInfo"));
	ITVESupervisorGITProxyPtr spGITProxy;
	HRESULT hr = m_spIGlobalInterfaceTable->GetInterfaceFromGlobal(m_dwSuperGITProxyCookie,
																__uuidof(spGITProxy),  
																reinterpret_cast<void**>(&spGITProxy));
	ITVESupervisorPtr spSuperMainThread;
	if(!FAILED(hr))
	{
		hr = spGITProxy->get_Supervisor(&spSuperMainThread);
	}

	if(!FAILED(hr))
	{
		ITVESupervisor_HelperPtr spSuperHelperMainThread(spSuperMainThread);
		if(NULL == spSuperHelperMainThread)
			return E_NOINTERFACE;

		int cwAnc = wcslen(bstrAuxInfoString);
		CComBSTR bstrAuxInfoStringProx(cwAnc, bstrAuxInfoString);			// need to add length to work over possible zero bytes (NULL character added auto'ly).

		return spSuperHelperMainThread->NotifyAuxInfo_XProxy(engAuxInfoMode, bstrAuxInfoStringProx, lgrfWhatDiff, lErrorLine);
	}
	return hr;
#else
	return NotifyAuxInfo_XProxy(engAuxInfoMode, bstrAuxInfoString, lgrfWhatDiff, lErrorLine);
#endif
}

// -------------------------------------------------------

STDMETHODIMP CTVESupervisor::NotifyAuxInfo_XProxy(NWHAT_Mode enAuxInfoMode, BSTR bstrAuxInfoString, long lgrfWhatDiff, long lErrorLine)
{
				// note string may be a Announcement, with 0 bytes in SAP header.
	DBG_HEADER(CDebugLog::DBG_EVENT, _T("CTVESupervisor::NotifyAuxInfo_XProxy"));
                
                // shutdown all events in final release 
    if(m_fInFinalRelease) 
        return S_OK;
   
	WCHAR *pwString = (WCHAR *) bstrAuxInfoString;

	if(DBG_FSET(CDebugLog::DBG_EVENT)) {
		USES_CONVERSION;
		CComBSTR bstrWhat;
		switch(enAuxInfoMode) {

		case NWHAT_Announcement: bstrWhat = L"Annc"; 
			/* don't clean up any more, not sending the SAP header
			if(bstrAuxInfoString && bstrAuxInfoString[0])			// see CTVEEnhancement::ParseSAPHeader
			{
				WCHAR *pwString = (WCHAR *) bstrAuxInfoString;

				BYTE  ucSAPHeaderBits = (BYTE) *pwString; pwString++;
				BYTE  ucSAPAuthLength = (BYTE) *pwString; pwString++;		// number of 32bit words that contain Auth data
				USHORT usSAPMsgIDHash = (USHORT) (*pwString | ((*(pwString+1))<<8));  pwString+=2;
				ULONG  ulSAPSendingIP = *(pwString+0) | ((*(pwString+1))<<8) | ((*(pwString+2))<<16)| ((*(pwString+3))<<24); pwString += 4;
				pwString += ucSAPAuthLength;

				int cBytes = pwString - bstrAuxInfoString;
				for(int i = 0; i < cBytes; i++)				// hack to avoid zero byte data
					bstrAuxInfoString[i] |= 0x100;			//  always work, 'cause SAP was byte data orginally
			}
			*/
			break;
		case NWHAT_Trigger:		 bstrWhat = L"Trigger"; break;
		case NWHAT_Data:		 bstrWhat = L"Data"; break;
		default:
		case NWHAT_Other:		 bstrWhat = L"Other"; break;
		}
		const int kChars = 1023;
		WCHAR wszBuff[kChars+1];
		_snwprintf(wszBuff, kChars, L"AuxInfo %s(%d): (line %d 0x%08x) %s", 
			bstrWhat, enAuxInfoMode, 
			lErrorLine, lgrfWhatDiff, 
			pwString);
		DBG_WARN(CDebugLog::DBG_EVENT,W2T(wszBuff));
	}

	m_tveStats.m_cAuxInfos++;
	Fire_NotifyTVEAuxInfo(enAuxInfoMode, bstrAuxInfoString, lgrfWhatDiff, lErrorLine);

	return S_OK;
}

// -------------------------------------------------------------------------------------------
//  Unpacks a buffer of data recieved in UHTTP_Package::Unpack().   
//	This takes the full package, 
//		Un GZip it
//		writes out each of the files
//		Kicks of the Package Notify event when done...
 
HRESULT UnpackBuffer(IUnknown *pVariation, LPBYTE pBuffer, ULONG ulSize);

STDMETHODIMP CTVESupervisor::UnpackBuffer(/*[in]*/IUnknown *pVariation, /*[in]*/ unsigned char *rgbData, /*[in]*/ int cBytes)
{
	ITVEVariationPtr spVariation(pVariation);

//	CSmartLock spLock(&m_sLk);	-- don't lock?? 

	HRESULT hr = ::UnpackBuffer(pVariation, rgbData, cBytes);
	if(!FAILED(hr))
		return hr;

	return hr;
}


// --------------------------------------------------------------------------------

STDMETHODIMP CTVESupervisor::InitStats()
{

	m_tveStats.Init();
	return S_OK;
}


		// returns the current stats converted into a BSTR.   Need to cast them
		//   back to a CTVEStats* structure to make sense out of them.  (Cast done
		//   to make marshelling a private data structure easy..)
STDMETHODIMP CTVESupervisor::GetStats(BSTR *bstrBuff)			
{
	CComBSTR bstrStats(sizeof(CTVEStats));

	memcpy(bstrStats.m_str, (void *) &m_tveStats, sizeof(CTVEStats));  // marshel by converting to a BSTR

	bstrStats.CopyTo(bstrBuff);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvesuper.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVESupervisor.h : Declaration of the CTVESupervisor

#ifndef __TVESUPERVISOR_H_
#define __TVESUPERVISOR_H_

#include "resource.h"       // main symbols
#include "TVEServis.h"		// supervisor
#include "TVEMCMng.h"		// multicast manager
#include "MSTvECP.h"
#include "TveStats.h"		// private stats structure...

#include <atlctl.h>			// for IObjectSafety  (see pg 445 Grimes: Professional ATL Com programming)

#include "fcache.h"

_COM_SMARTPTR_TYPEDEF(ITVEMCastManager,			__uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEServices,				__uuidof(ITVEServices)); 
_COM_SMARTPTR_TYPEDEF(ITVESupervisorGITProxy,	__uuidof(ITVESupervisorGITProxy));  
// ------------------------------------------------------------------
//  forwards and externs...

extern IGlobalInterfaceTable	*g_pIGlobalInterfaceTable;		


#define	_USE_FTM			// use the free threaded masheller...  Needed.
#define _DO_AS_SINGLETON	// do the singleton thing...



// --------------------------------------------------------
//  SupervisorGITProxy
//
//		Simple little holding object to hand out to internal objects
//		that want to refcount the supervisor (such as the GIT).
//		They refcount this one instead.  This avoid's internal refcounts
//		on the supervisor itself, letting client objects manage its
//		lifetime.
// --------------------------------------------------------
class ATL_NO_VTABLE CTVESupervisorGITProxy : 
	public CComObjectRootEx<CComMultiThreadModel>,	
//	public CComCoClass<CTVESupervisor, &CLSID_TVESupervisorGITProxy>,
	public ITVESupervisorGITProxy
{
public:

DECLARE_GET_CONTROLLING_UNKNOWN()
//DECLARE_REGISTRY_RESOURCEID(IDR_TVESUPERVISORGITPROXY)

BEGIN_COM_MAP(CTVESupervisorGITProxy)
	COM_INTERFACE_ENTRY(ITVESupervisorGITProxy)
END_COM_MAP()

public:
	CTVESupervisorGITProxy()
	{
		m_pTVESupervisor = NULL;
	}

	~CTVESupervisorGITProxy()
	{
		m_pTVESupervisor = NULL;
	}
	
	STDMETHOD(get_Supervisor)(ITVESupervisor **ppSuper)
	{
		if(NULL == ppSuper)
			return E_POINTER;

		if(NULL != m_pTVESupervisor)
		{
			*ppSuper = m_pTVESupervisor;
			(*ppSuper)->AddRef();
			return S_OK;
		} else {
			*ppSuper = NULL;
			return E_FAIL;
		}
	}

	STDMETHOD(put_Supervisor)(ITVESupervisor *pSuper)
	{
	
		m_pTVESupervisor = pSuper;
		return S_OK;
	}
private:
	ITVESupervisor		*m_pTVESupervisor;
};


/////////////////////////////////////////////////////////////////////////////
// CTVESupervisor
class ATL_NO_VTABLE CTVESupervisor : 
//	public CComObjectRootEx<CComMultiThreadModel>,					// for fun, move to the end to fix ATL static cast debug bug
	public CComObjectRootEx<CComSingleThreadModel>,					// for fun, move to the end to fix ATL static cast debug bug
	public CComCoClass<CTVESupervisor, &CLSID_TVESupervisor>,
	public ITVESupervisor_Helper,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CTVESupervisor>,
	public IDispatchImpl<ITVESupervisor, &IID_ITVESupervisor, &LIBID_MSTvELib>,
	public CProxy_ITVEEvents< CTVESupervisor>,
	public IProvideClassInfo2Impl<&CLSID_TVESupervisor, &DIID__ITVEEvents, &LIBID_MSTvELib>,
#ifdef _DO_AS_SINGLETON
//	public	Singleton<CTVESupervisor>,
#endif
	public IObjectSafetyImpl<CTVESupervisor, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
	CTVESupervisor()
	{
#ifdef _USE_FTM	
		m_spUnkMarshaler		= NULL;
#endif
		m_cActiveServices		= 0;
		m_pUnkParent			= NULL;								// up pointer, not reference counted
		m_spbsDesc				= L"Main TVE Supervisor";
		m_dwGrfHaltFlags		= 0;
		m_fInFinalRelease		= false;
	} 

	HRESULT FinalConstruct();
	HRESULT FinalRelease();

								// make it a singleton..
#ifdef _DO_AS_SINGLETON
//	DECLARE_CLASSFACTORY_EX(CComClassFactorySingleton<CTVESupervisor>)
	DECLARE_NOT_AGGREGATABLE(CTVESupervisor)
	DECLARE_CLASSFACTORY_SINGLETON(CTVESupervisor)
#endif


DECLARE_REGISTRY_RESOURCEID(IDR_TVESUPERVISOR)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVESupervisor)
	COM_INTERFACE_ENTRY(ITVESupervisor)
	COM_INTERFACE_ENTRY(ITVESupervisor_Helper)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
#ifdef _USE_FTM	
//	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler)		// IUnknownPtr
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)		// CComPtr<IUnknown>
#endif
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CTVESupervisor)
CONNECTION_POINT_ENTRY(DIID__ITVEEvents)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	CComPtr<IUnknown>	 m_spUnkMarshaler;

// ITVESupervisor
public:

	STDMETHOD(ExpireForDate)(/*[in]*/ DATE expireDate);	// if 0.0, use NOW
	STDMETHOD(TuneTo)(/*[in]*/ BSTR bstrDescription, /*[in]*/ BSTR bstrIPAdapter);
	STDMETHOD(ReTune)(/*[in]*/ ITVEService *ITVEService);
	STDMETHOD(NewXOverLink)(/*[in]*/ BSTR bstrLine21Trigger);
	STDMETHOD(get_Services)(/*[out, retval]*/ ITVEServices **ppVal);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *ppVal);
	STDMETHOD(put_Description)(/*[in]*/ BSTR newVal);

	STDMETHOD(InitStats)();
	STDMETHOD(GetStats)(BSTR *pbstrBuff);			// cast to CTVEStats...

	// ITVESupervisor_Helper
public:
	STDMETHOD(NotifyFile)(NFLE_Mode enMode, ITVEVariation *pVariation, BSTR bstrURLName, BSTR bstrFileName);
	STDMETHOD(NotifyPackage)(NPKG_Mode enMode, ITVEVariation *pVariation, BSTR bstrFileName, long cBytesTotal, long cBytesReceived);
	STDMETHOD(NotifyTrigger)(NTRK_Mode enMode, ITVETrack *pTrack, long lChangedFlags);					// changedFlags NTRK_grfDiff					
	STDMETHOD(NotifyEnhancement)(NENH_Mode enMode, ITVEEnhancement *pEnhancement, long lChangedFlags); // changedFlags NENH_grfDiff
	STDMETHOD(NotifyTune)(NTUN_Mode tuneMode, ITVEService *pService, BSTR bstrDescription, BSTR bstrIPAdapter);
	STDMETHOD(NotifyAuxInfo)(NWHAT_Mode enAuxInfoMode, BSTR bstrAuxInfoString, long lgrfWhatDiff, long lErrorLine);

	STDMETHOD(NotifyFile_XProxy)(NFLE_Mode enMode, ITVEVariation *pVariation, BSTR bstrURLName, BSTR bstrFileName);
	STDMETHOD(NotifyPackage_XProxy)(NPKG_Mode enMode, ITVEVariation *pVariation, BSTR bstrFileName, long cBytesTotal, long cBytesReceived);
	STDMETHOD(NotifyTrigger_XProxy)(NTRK_Mode enMode, ITVETrack *pTrack, long lChangedFlags); // changedFlags NTRK_grfDiff					
	STDMETHOD(NotifyEnhancement_XProxy)(NENH_Mode enMode, ITVEEnhancement *pEnhancement, long lChangedFlags); // changedFlags NENH_grfDiff
	STDMETHOD(NotifyTune_XProxy)(NTUN_Mode tuneMode, ITVEService *pService, BSTR bstrDescription, BSTR bstrIPAdapter);
	STDMETHOD(NotifyAuxInfo_XProxy)(NWHAT_Mode enAuxInfoMode, BSTR bstrAuxInfoString, long lgrfWhatDiff, long lErrorLine);

	STDMETHOD(GetActiveService)(ITVEService **ppActiveService);						// returns the first service
	
	STDMETHOD(ConnectParent)(IUnknown * pUnk);
	STDMETHOD(GetMCastManager)(/*[out]*/ ITVEMCastManager **pMCastManager);

	STDMETHOD(RemoveAllListeners)();
	STDMETHOD(RemoveAllListenersOnAdapter)(BSTR bstrAdapter);
	STDMETHOD(get_PossibleIPAdapterAddress)(/*[in]*/ int iAdapter, /*[out,retval]*/ BSTR *pbstrIPAdapterAddr);

	STDMETHOD(UnpackBuffer)(/*[in]*/ IUnknown *pTVEVariation,/*[in]*/ unsigned char *m_rgbData, /*[in]*/ int cBytes);

	STDMETHOD(put_HaltFlags)(LONG lGrfHaltFlags)		{m_dwGrfHaltFlags = (DWORD) lGrfHaltFlags;			// turn CC decoding on and off
														 if(m_spMCastManager) 
															 m_spMCastManager->put_HaltFlags(lGrfHaltFlags); 
														 return S_OK;}	
	STDMETHOD(get_HaltFlags)(LONG *plGrfHaltFlags)	{if(NULL == plGrfHaltFlags) return E_POINTER; *plGrfHaltFlags = (LONG) m_dwGrfHaltFlags; return S_OK;}

	STDMETHOD(DumpToBSTR)(BSTR *pbstrBuff);

	STDMETHOD(get_SupervisorGITProxy)(ITVESupervisorGITProxy **ppGITProxy) 
	{	if(NULL==ppGITProxy) return E_POINTER; 
		*ppGITProxy = m_spTVESupervisorGITProxy; 
		if(*ppGITProxy) (*ppGITProxy)->AddRef();
		return S_OK;
	}


public:	// local methods
	void Initialize(TCHAR * strDesc);		// debug
	HRESULT SetAnncListener(ITVEService *pService, BSTR bstrIPAdapter, BSTR bstrIPAddress, long lPort, ITVEMCast **ppMCAnnc);
	HRESULT SetATVEFAnncListener(ITVEService *pService, BSTR bstrIPAdapter);

private:
	CTVESmartLock		m_sLk;

private:
	ITVESupervisorGITProxyPtr		m_spTVESupervisorGITProxy;	// todo - move GIT stuff below into this object
	CComPtr<IGlobalInterfaceTable>	m_spIGlobalInterfaceTable;
	DWORD							m_dwSuperGITProxyCookie;	// cookie to supervisor GIT Proxy object registered in the global interface table

	IUnknown *						m_pUnkParent;		// some random back pointer.. not add-refed (should it be?)

	CComBSTR						m_spbsDesc;
	ITVEServicesPtr					m_spServices;		// down tree collection pointer
	ITVEMCastManagerPtr				m_spMCastManager;	// multicast thread manager object...

	long							m_cActiveServices;	// number of attached adapters (used in AddRef hack)

	CTVEStats						m_tveStats;
	DWORD							m_dwGrfHaltFlags;	// if !zero bits, avoid running various sections of code - see enum NFLT_grfHaltFlags


	BOOL							m_fInFinalRelease;		// set to true when exiting  - needed to avoid TuneTo blowup
public:

};



#endif //__TVESUPERVISOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvesmartlock.cpp ===
// ---------------------------------------------------------------------------
// SmartLock.cpp
//
//			Read-Many/Write-Once critical section code.
//
// This code adapted from
//   file://index2a/nt/base/ntdll/resource.c 
//	 f:\nt\public\sdk\inc\ntuSL.h
//	 
//
//      To use, declare the following variable in the class to protect:
//              CTVESmartLock m_sLk
//      Then in scope of code method to protect, create the
//              CSmartLock spLock(&m_sLk [,ReadLock|WriteLock]);	(defaults to ReadLock)	
//
//	Grungy Internal Routines
//		OID SLInitializeResource(IN PSL_RESOURCE Resource)
//		BOOLEAN SLAcquireResourceShared(PSL_RESOURCE Resource,  BOOLEAN Wait)
//		BOOLEAN SLAcquireResourceExclusive(PSL_RESOURCE Resource, BOOLEAN Wait);
//		VOID SLReleaseResource(PSL_RESOURCE Resource);
//		VOID SLConvertSharedToExclusive(PSL_RESOURCE Resource);
//		VOID SLConvertExclusiveToShared(PSL_RESOURCE Resource);
//		VOID SLDeleteResource(PSL_RESOURCE Resource);
//
//
//	The following cases work:
//		multiple read locks on same thread
//		multiple write locks on same thread
//		write lock followed by read lock
//
//	The following doesn't work
//		read lock followed by write lock
// ----------------------------------------------------------------------------

#include "Stdafx.h"
#include "TveSmartLock.h"
#include "Windows.h"

#ifdef _DEBUG
static ULONG gSLpTimeout = 5000;		// default timeout wait time in Milliseconds
static ULONG gSLCycles   = 4;
#else
const ULONG gSLpTimeout = 500;
const ULONG gSLCycles   = 4;
#endif

VOID
SLRaiseStatus (
    IN DWORD dwExceptionCode
    )

/*++

Routine Description:

    This function raises an exception with the specified status value. The
    exception is marked as continuable with no parameters.

Arguments:

    Status - Supplies the status value to be used as the exception code
        for the exception that is to be raised.

Return Value:

    None.

--*/

{
	RaiseException( dwExceptionCode, EXCEPTION_NONCONTINUABLE,  0, (ULONG_PTR *) NULL);
}

VOID
SLInitializeResource(
    IN PSL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine initializes the input resource variable

Arguments:

    Resource - Supplies the resource variable being initialized

Return Value:

    None

--*/

{
//    PSL_RESOURCE_DEBUG ResourceDebugInfo;

    //
    //  Initialize the lock fields, the count indicates how many are waiting
    //  to enter or are in the critical section, LockSemaphore is the object
    //  to wait on when entering the critical section.  SpinLock is used
    //  for the add interlock instruction.
    //
  // BOOL fOK = InitializeCriticalSectionAndSpinCount( &Resource->CriticalSection, 1000 );
    BOOL fOK = true; 
	InitializeCriticalSection( &Resource->CriticalSection );
    if ( !fOK ){
        SLRaiseStatus(GetLastError());
        }

    //
    //  Initialize flags so there is a default value.
    //  (Some apps may set RTL_RESOURCE_FLAGS_LONG_TERM to affect timeouts.)
    //

    Resource->Flags = 0;


    //
    //  Initialize the shared and exclusive waiting counters and semaphore.
    //  The counters indicate how many are waiting for access to the resource
    //  and the semaphores are used to wait on the resource.  Note that
    //  the semaphores can also indicate the number waiting for a resource
    //  however there is a race condition in the alogrithm on the acquire
    //  side if count if not updated before the critical section is exited.
    //

	SECURITY_ATTRIBUTES sAttrs;
	sAttrs.nLength = sizeof(SECURITY_ATTRIBUTES);
	sAttrs.lpSecurityDescriptor = NULL;
	sAttrs.bInheritHandle = false;			// true ???

    Resource->SharedSemaphore = 
		CreateSemaphore(
                 &sAttrs,
                 0,							// initial count
                 MAXLONG,					// maximum count
				 NULL						// name..
                 );
    if ( NULL == Resource->SharedSemaphore )
	{
        DeleteCriticalSection (&Resource->CriticalSection);
 //       RtlpFreeDebugInfo( Resource->DebugInfo );
        SLRaiseStatus(GetLastError());
    }

    Resource->NumberOfWaitingShared = 0;

   Resource->ExclusiveSemaphore = CreateSemaphore(
                &sAttrs,
                 0,							// initial count
                 MAXLONG,					// maximum count
				 NULL						// name..
                 );
    if ( NULL == Resource->SharedSemaphore ){
        DeleteCriticalSection (&Resource->CriticalSection);
        // RtlpFreeDebugInfo( Resource->DebugInfo );
        SLRaiseStatus(	GetLastError());
        }

    Resource->NumberOfWaitingExclusive = 0;

    //
    //  Initialize the current state of the resource
    //

    Resource->NumberOfActive = 0;
    Resource->dwExclusiveOwnerThreadId = NULL;

    return;
}

BOOLEAN
SLAcquireResourceShared(
    IN PSL_RESOURCE Resource,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The routine acquires the resource for shared access.  Upon return from
    the procedure the resource is acquired for shared access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    DWORD dwStatus;
    ULONG TimeoutCount = 0;
    ULONG TimeoutTime = gSLpTimeout;
    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If it is not currently acquired for exclusive use then we can acquire
    //  the resource for shared access.  Note that this can potentially
    //  starve an exclusive waiter however, this is necessary given the
    //  ability to recursively acquire the resource shared.  Otherwise we
    //  might/will reach a deadlock situation where a thread tries to acquire
    //  the resource recusively shared but is blocked by an exclusive waiter.
    //
    //  The test to reanable not starving an exclusive waiter is:
    //
    //      if ((Resource->NumberOfWaitingExclusive == 0) &&
    //          (Resource->NumberOfActive >= 0)) {
    //

    if (Resource->NumberOfActive >= 0) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section
        //

        Resource->NumberOfActive += 1;

       LeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise check to see if this thread is the one currently holding
    //  exclusive access to the resource.  And if it is then we change
    //  this shared request to an exclusive recusive request and grant
    //  access to the resource.
    //

    } else if (Resource->dwExclusiveOwnerThreadId == GetCurrentThreadId()) {

        //
        //  The resource is ours (recusively) so indicate that we have it
        //  and exit the critial section
        //

        Resource->NumberOfActive -= 1;

        LeaveCriticalSection(&Resource->CriticalSection);

    //
    //  Otherwise we'll have to wait for access.
    //

    } else {

        //
        //  Check if we are allowed to wait or must return immedately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            LeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting shared,
        //  release the lock, and wait on the shared semaphore
        //

        Resource->NumberOfWaitingShared += 1;

        LeaveCriticalSection(&Resource->CriticalSection);

rewait:
        if ( Resource->Flags & SL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = 0;
        }
        dwStatus = WaitForSingleObject(
                    Resource->SharedSemaphore,
                    TimeoutTime
                    );
        if ( dwStatus == WAIT_TIMEOUT ) {
 /*           DbgPrint("SL: Acquire Shared Sem Timeout %d(%I64u secs)\n",
                     TimeoutCount, TimeoutTime->QuadPart / (-10000000));
            DbgPrint("SL: Resource at %p\n",Resource);
*/
            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
                //
                // Raise an exception and try to get to the user popup..
                    DWORD dwExceptionCode = STATUS_POSSIBLE_DEADLOCK;
                    DWORD dwExceptionFlags = 0;
                  //  DWORD dwNumberParameters = 1;
                  //  DWORD dwExceptionInformation[0] = (ULONG_PTR)Resource;
                    RaiseException( dwExceptionCode, dwExceptionFlags, 0, (ULONG_PTR *) NULL );
					
					// if find yourself in this exception, do the following:
					//  look at: Resource.dwExclusiveOwnerThread
					//  look at that tread's stack trace
					//  find out who 
                }
//            DbgPrint("SL: Re-Waiting\n");
            goto rewait;
        }
        if ( dwStatus == WAIT_FAILED ) {
            SLRaiseStatus(GetLastError());				// failed...
            }
    }

    //
    //  Now the resource is ours, for shared access
    //

    return TRUE;

}


BOOLEAN
SLAcquireResourceExclusive(
    IN PSL_RESOURCE Resource,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The routine acquires the resource for exclusive access.  Upon return from
    the procedure the resource is acquired for exclusive access.

Arguments:

    Resource - Supplies the resource to acquire

    Wait - Indicates if the call is allowed to wait for the resource
        to become available for must return immediately

Return Value:

    BOOLEAN - TRUE if the resource is acquired and FALSE otherwise

--*/

{
    DWORD dwStatus;
    ULONG TimeoutCount = 0;
    ULONG TimeoutTime = gSLpTimeout;

    //
    //  Loop until the resource is ours or exit if we cannot wait.
    //

    while (TRUE) {

        //
        //  Enter the critical section
        //

        EnterCriticalSection(&Resource->CriticalSection);

        //
        //  If there are no shared users and it is not currently acquired for
        //  exclusive use then we can acquire the resource for exclusive
        //  access.  We also can acquire it if the resource indicates exclusive
        //  access but there isn't currently an owner.
        //

        if ((Resource->NumberOfActive == 0)

                ||

            ((Resource->NumberOfActive == -1) &&
             (Resource->dwExclusiveOwnerThreadId == NULL))) {

            //
            //  The resource is ours, so indicate that we have it and
            //  exit the critical section
            //

            Resource->NumberOfActive = -1;

            Resource->dwExclusiveOwnerThreadId = GetCurrentThreadId();

            LeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Otherwise check to see if we already have exclusive access to the
        //  resource and can simply recusively acquire it again.
        //

        if (Resource->dwExclusiveOwnerThreadId == GetCurrentThreadId()) {

            //
            //  The resource is ours (recusively) so indicate that we have it
            //  and exit the critial section
            //

            Resource->NumberOfActive -= 1;

            LeaveCriticalSection(&Resource->CriticalSection);

            return TRUE;

        }

        //
        //  Check if we are allowed to wait or must return immedately, and
        //  indicate that we didn't acquire the resource
        //

        if (!Wait) {

            LeaveCriticalSection(&Resource->CriticalSection);

            return FALSE;

        }

        //
        //  Otherwise we need to wait to acquire the resource.
        //  To wait we will increment the number of waiting exclusive,
        //  release the lock, and wait on the exclusive semaphore
        //

        Resource->NumberOfWaitingExclusive += 1;
//        Resource->DebugInfo->ContentionCount++;

        LeaveCriticalSection(&Resource->CriticalSection);

rewait:
        if ( Resource->Flags & SL_RESOURCE_FLAG_LONG_TERM ) {
            TimeoutTime = NULL;
        }
        dwStatus = WaitForSingleObject(
                    Resource->ExclusiveSemaphore,
                    TimeoutTime
                    );
        if ( dwStatus == WAIT_TIMEOUT ) {
/*            DbgPrint("SL: Acquire Exclusive Sem Timeout %d (%I64u secs)\n",
                     TimeoutCount, TimeoutTime->QuadPart / (-10000000));
            DbgPrint("SL: Resource at %p\n",Resource); */
            TimeoutCount++;
            if ( TimeoutCount > 2 ) {
 
                //
                // raise an exception

                DWORD dwExceptionCode = STATUS_POSSIBLE_DEADLOCK;
                DWORD dwExceptionFlags = 0;
             //   DWORD dwNumberParameters = 1;
             //   ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR)Resource;

				RaiseException(dwExceptionCode, dwExceptionFlags, 0, (ULONG_PTR *) 0);
              }
//            DbgPrint("SL: Re-Waiting\n");
            goto rewait;
        }
        if ( WAIT_FAILED == dwStatus ) {
            SLRaiseStatus(GetLastError());
            }
    }
}


VOID
SLReleaseResource(
    IN PSL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine release the input resource.  The resource can have been
    acquired for either shared or exclusive access.

Arguments:

    Resource - Supplies the resource to release

Return Value:

    None.

--*/

{
    LONG PreviousCount;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  Test if the resource is acquired for shared or exclusive access
    //

    if (Resource->NumberOfActive > 0) {

        //
        //  Releasing shared access to the resource, so decrement
        //  the number of shared users
        //

        Resource->NumberOfActive -= 1;

        //
        //  If the resource is now available and there is a waiting
        //  exclusive user then give the resource to the waiting thread
        //

        if ((Resource->NumberOfActive == 0) &&
            (Resource->NumberOfWaitingExclusive > 0)) {

            //
            //  Set the resource state to exclusive (but not owned),
            //  decrement the number of waiting exclusive, and release
            //  one exclusive waiter
            //

            Resource->NumberOfActive = -1;
            Resource->dwExclusiveOwnerThreadId = NULL;

            Resource->NumberOfWaitingExclusive -= 1;

            BOOL fOK = ReleaseSemaphore(
                         Resource->ExclusiveSemaphore,
                         1,
                         &PreviousCount
                         );
            if ( !fOK ) 
			{
                SLRaiseStatus(GetLastError());
            }
        }

    } else if (Resource->NumberOfActive < 0) {

        //
        //  Releasing exclusive access to the resource, so increment the
        //  number of active by one.  And continue testing only
        //  if the resource is now available.
        //

        Resource->NumberOfActive += 1;

        if (Resource->NumberOfActive == 0) {

            //
            //  The resource is now available.  Remove ourselves as the
            //  owner thread
            //

            Resource->dwExclusiveOwnerThreadId = NULL;

            //
            //  If there is another waiting exclusive then give the resource
            //  to it.
            //

            if (Resource->NumberOfWaitingExclusive > 0) {

                //
                //  Set the resource to exclusive, and its owner undefined.
                //  Decrement the number of waiting exclusive and release one
                //  exclusive waiter
                //

                Resource->NumberOfActive = -1;
                Resource->NumberOfWaitingExclusive -= 1;

                BOOL fOK = ReleaseSemaphore(
                             Resource->ExclusiveSemaphore,
                             1,
                             &PreviousCount
                             );
                if ( !fOK ) {
                    SLRaiseStatus(GetLastError());
                    }

            //
            //  Check to see if there are waiting shared, who should now get
            //  the resource
            //

            } else if (Resource->NumberOfWaitingShared > 0) {

                //
                //  Set the new state to indicate that all of the shared
                //  requesters have access and there are no more waiting
                //  shared requesters, and then release all of the shared
                //  requsters
                //

                Resource->NumberOfActive = Resource->NumberOfWaitingShared;

                Resource->NumberOfWaitingShared = 0;

                BOOL fOK = ReleaseSemaphore(
                             Resource->SharedSemaphore,
                             Resource->NumberOfActive,
                             &PreviousCount
                             );
                if ( !fOK ) {
                    SLRaiseStatus(GetLastError());
                    }
            }
        }

#if DBG
    } else {

        //
        //  The resource isn't current acquired, there is nothing to release
        //  so tell the user the mistake
        //
		_ASSERT(false);

//        DbgPrint("NTDLL - Resource released too many times %lx\n", Resource);
//        DbgBreakPoint();
#endif
    }

    //
    //  Exit the critical section, and return to the caller
    //

    LeaveCriticalSection(&Resource->CriticalSection);

    return;
}


VOID
SLConvertSharedToExclusive(
    IN PSL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for shared access into
    one acquired for exclusive access.  Upon return from the procedure
    the resource is acquired for exclusive access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for shared access

Return Value:

    None

--*/

{
    DWORD dwStatus;
    ULONG TimeoutCount = 0;

    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == 1) {

        //
        //  The resource is ours, so indicate that we have it and
        //  exit the critical section, and return
        //

        Resource->NumberOfActive = -1;

        Resource->dwExclusiveOwnerThreadId = GetCurrentThreadId();

        LeaveCriticalSection(&Resource->CriticalSection);

        return;
    }

    //
    //  If the resource is currently acquired exclusive and it's us then
    //  we already have exclusive access
    //

    if ((Resource->NumberOfActive < 0) &&
        (Resource->dwExclusiveOwnerThreadId == GetCurrentThreadId())) {

        //
        //  We already have exclusive access to the resource so we'll just
        //  exit the critical section and return
        //

        LeaveCriticalSection(&Resource->CriticalSection);

        return;
    }

    //
    //  If the resource is acquired by more than one shared then we need
    //  to wait to get exclusive access to the resource
    //

    if (Resource->NumberOfActive > 1) {

        //
        //  To wait we will decrement the fact that we have the resource for
        //  shared, and then loop waiting on the exclusive lock, and then
        //  testing to see if we can get exclusive access to the resource
        //

        Resource->NumberOfActive -= 1;

        while (TRUE) {

            //
            //  Increment the number of waiting exclusive, exit and critical
            //  section and wait on the exclusive semaphore
            //

            Resource->NumberOfWaitingExclusive += 1;
//            Resource->DebugInfo->ContentionCount++;

            LeaveCriticalSection(&Resource->CriticalSection);
rewait:
        dwStatus = WaitForSingleObject(
                    Resource->ExclusiveSemaphore,
                    gSLpTimeout
                    );
        if ( dwStatus == WAIT_TIMEOUT ) {
/*            DbgPrint("SL: Convert Exclusive Sem Timeout %d (%I64u secs)\n",
                     TimeoutCount, SLpTimeout.QuadPart / (-10000000));
            DbgPrint("SL: Resource at %p\n",Resource); */
            TimeoutCount++;
            if ( TimeoutCount > gSLCycles ) {
                //
                // If the image is a Win32 image, then raise an exception and try to get to the
                // uae popup
                //
                    DWORD dwExceptionCode = STATUS_POSSIBLE_DEADLOCK;
                    DWORD dwExceptionFlags = 0;
                   // DWORD dwNumberParameters = 1;
                   // ExceptionRecord.ExceptionInformation[0] = (ULONG_PTR)Resource;
                    RaiseException(dwExceptionCode, dwExceptionFlags, 0, (ULONG_PTR *) 0);
                }
   //         DbgPrint("SL: Re-Waiting\n");
            goto rewait;
        }
            if ( dwStatus == WAIT_FAILED ) {
                SLRaiseStatus(GetLastError());
                }

            //
            //  Enter the critical section
            //

           EnterCriticalSection(&Resource->CriticalSection);

            //
            //  If there are no shared users and it is not currently acquired
            //  for exclusive use then we can acquire the resource for
            //  exclusive access.  We can also acquire it if the resource
            //  indicates exclusive access but there isn't currently an owner
            //

            if ((Resource->NumberOfActive == 0)

                    ||

                ((Resource->NumberOfActive == -1) &&
                 (Resource->dwExclusiveOwnerThreadId == NULL))) {

                //
                //  The resource is ours, so indicate that we have it and
                //  exit the critical section and return.
                //

                Resource->NumberOfActive = -1;

                Resource->dwExclusiveOwnerThreadId = GetCurrentThreadId();

                LeaveCriticalSection(&Resource->CriticalSection);

                return;
            }

            //
            //  Otherwise check to see if we already have exclusive access to
            //  the resource and can simply recusively acquire it again.
            //

            if (Resource->dwExclusiveOwnerThreadId == GetCurrentThreadId()) {

                //
                //  The resource is ours (recusively) so indicate that we have
                //  it and exit the critical section and return.
                //

                Resource->NumberOfActive -= 1;

                LeaveCriticalSection(&Resource->CriticalSection);

                return;
            }
        }

    }

    //
    //  The resource is not currently acquired for shared so this is a
    //  spurious call
    //

#if DBG
  //  DbgPrint("NTDLL:  Failed error - SHARED_RESOURCE_CONV_ERROR\n");
		_ASSERT(false);
#endif
}


VOID
SLConvertExclusiveToShared(
    IN PSL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine converts a resource acquired for exclusive access into
    one acquired for shared access.  Upon return from the procedure
    the resource is acquired for shared access

Arguments:

    Resource - Supplies the resource to acquire for shared access, it
        must already be acquired for exclusive access

Return Value:

    None

--*/

{
    LONG PreviousCount;
    //
    //  Enter the critical section
    //

    EnterCriticalSection(&Resource->CriticalSection);

    //
    //  If there is only one shared user (it's us) and we can acquire the
    //  resource for exclusive access.
    //

    if (Resource->NumberOfActive == -1) {

        Resource->dwExclusiveOwnerThreadId = NULL;

        //
        //  Check to see if there are waiting shared, who should now get the
        //  resource along with us
        //

        if (Resource->NumberOfWaitingShared > 0) {

            //
            //  Set the new state to indicate that all of the shared requesters
            //  have access including us, and there are no more waiting shared
            //  requesters, and then release all of the shared requsters
            //

            Resource->NumberOfActive = Resource->NumberOfWaitingShared + 1;

            Resource->NumberOfWaitingShared = 0;

            BOOL fOK = ReleaseSemaphore(
                         Resource->SharedSemaphore,
                         Resource->NumberOfActive - 1,
                         &PreviousCount
                         );
            if ( !fOK ) {
                SLRaiseStatus(GetLastError());
                }

        } else {

            //
            //  There is no one waiting for shared access so it's only ours
            //

            Resource->NumberOfActive = 1;

        }

        LeaveCriticalSection(&Resource->CriticalSection);

        return;

    }

    //
    //  The resource is not currently acquired for exclusive, or we've
    //  recursively acquired it, so this must be a spurious call
    //

#if DBG
   // DbgPrint("NTDLL:  Failed error - SHARED_RESOURCE_CONV_ERROR\n");
		_ASSERT(false);

#endif
}


VOID
SLDeleteResource (
    IN PSL_RESOURCE Resource
    )

/*++

Routine Description:

    This routine deletes (i.e., uninitializes) the input resource variable


Arguments:

    Resource - Supplies the resource variable being deleted

Return Value:

    None

--*/

{
    DeleteCriticalSection( &Resource->CriticalSection );

    CloseHandle(Resource->SharedSemaphore);
    CloseHandle(Resource->ExclusiveSemaphore);


//	SLpFreeDebugInfo( Resource->DebugInfo );
    memset((void *) Resource, 0, sizeof( *Resource ) );

    return;
}


VOID
SLDumpResource(
    IN PSL_RESOURCE Resource
    )

{
	/*
    DbgPrint("Resource @ %lx\n", Resource);

    DbgPrint(" NumberOfWaitingShared = %lx\n", Resource->NumberOfWaitingShared);
    DbgPrint(" NumberOfWaitingExclusive = %lx\n", Resource->NumberOfWaitingExclusive);

    DbgPrint(" NumberOfActive = %lx\n", Resource->NumberOfActive);
*/
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvetrack.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVETrack.cpp : Implementation of CTVETrack
#include "stdafx.h"
#include <stdio.h>

#include "MSTvE.h"
#include "TVETrack.h"
#include "TveSmartLock.h"

#include "TveDbg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,		__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement_Helper,	__uuidof(ITVEEnhancement_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEVariation_Helper,		__uuidof(ITVEVariation_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrack,				__uuidof(ITVETrack));
_COM_SMARTPTR_TYPEDEF(ITVETrack_Helper,			__uuidof(ITVETrack_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrigger,				__uuidof(ITVETrigger));
_COM_SMARTPTR_TYPEDEF(ITVETrigger_Helper,		__uuidof(ITVETrigger_Helper));



/////////////////////////////////////////////////////////////////////////////
// CTVETrigger_Helper
	
HRESULT 
CTVETrack::FinalRelease()
{
	DBG_HEADER(CDebugLog::DBG_TRACK, _T("CTVETrack::FinalRelease"));
									// remove up pointers if there are any
	if(m_spTrigger) {
		CComQIPtr<ITVETrigger_Helper> spTriggerHelper = m_spTrigger;
		if(spTriggerHelper)
			spTriggerHelper->ConnectParent(NULL);
	}
	m_spTrigger = NULL;
	m_pUnkMarshaler = NULL;
	return S_OK;					// a place to hang a breakpoint
}


STDMETHODIMP CTVETrack::ConnectParent(ITVEVariation *pVariation)
{
	DBG_HEADER(CDebugLog::DBG_TRACK, _T("CTVETrack::ConnectParent"));
	if(!pVariation) return E_POINTER;
	CSmartLock spLock(&m_sLk);

	m_pVariation = pVariation;			// not smart pointer add ref here, I hope.
	return S_OK;
}


STDMETHODIMP CTVETrack::RemoveYourself()
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_TRACK, _T("CTVETrack::RemoveYourself"));

	CSmartLock spLock(&m_sLk);

	if(NULL == m_pVariation) {			
									// if NO up pointer, then not much to do...
		return S_OK;
	}
		
									// remove parent's pointer down to this item

	CComPtr<ITVETracks> spTracks;
	hr = m_pVariation->get_Tracks(&spTracks);
	if(S_OK == hr) {
		ITVETrackPtr	spTrackThis(this);
		IUnknownPtr		spPunkThis(spTrackThis);
		CComVariant		cvThis((IUnknown *) spPunkThis);

		hr = spTracks->Remove(cvThis);			// remove the ref-counted down pointer from the collection
	}
	
									// for lack of anything else, send a bogus event up...

/*						-- don't bother with the bogus event, get a TriggerExpire event instead.
	ITVEServicePtr spServi;
	get_Service(&spServi);
	if(spServi) {
		IUnknownPtr spUnkSuper;
		hr = spServi->get_Parent(&spUnkSuper);
		if(S_OK == hr) {
			ITVESupervisor_HelperPtr spSuperHelper(spUnkSuper);
			spSuperHelper->NotifyAuxInfo(NWHAT_Other,L"Deleting Track",0,0);
		}
	}
*/


	m_pVariation = NULL;				// remove the non ref-counted up pointer
										
	return S_OK;
}

STDMETHODIMP CTVETrack::DumpToBSTR(BSTR *pBstrBuff)
{
	HRESULT hr = S_OK;

	try {
		CheckOutPtr<BSTR>(pBstrBuff);
		const int kMaxChars = 2048;
		TCHAR tBuff[kMaxChars];
		int iLen;
		CComBSTR bstrOut;
		bstrOut.Empty();

		CSmartLock spLock(&m_sLk);

		bstrOut.Append(_T("Track\n"));
		iLen = m_spbsDesc.Length()+12;
		if(iLen < kMaxChars) {
			_stprintf(tBuff,_T("Description    : %s\n"),m_spbsDesc);
			bstrOut.Append(tBuff);
		}

		if(!m_spTrigger) {
			_stprintf(tBuff,_T("*** Error: Uninitialized Trigger\n"));
			bstrOut.Append(tBuff);
		} else {
			CComBSTR bstrTrigger;
			CComQIPtr<ITVETrigger_Helper> spTriggerHelper = m_spTrigger;
			if(!spTriggerHelper) 
			{
				bstrOut.Append(_T("*** Error: Trigger Helper\n")); 
			} else {
				spTriggerHelper->DumpToBSTR(&bstrTrigger);
				bstrOut.Append(bstrTrigger);
			}
		}
		hr = bstrOut.CopyTo(pBstrBuff);
	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_UNEXPECTED;
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CTVETrack

STDMETHODIMP CTVETrack::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVETrack,
		&IID_ITVETrack_Helper
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CTVETrack::get_Parent(IUnknown **ppVal)
{
	HRESULT hr = S_OK;
    try {
		CheckOutPtr<IUnknown*>(ppVal);
		CSmartLock spLock(&m_sLk);		
		if(m_pVariation) {
			IUnknownPtr spPunk(m_pVariation);
			spPunk->AddRef();
			*ppVal = spPunk;	
		}
		else 
			*ppVal = NULL;
    } catch(_com_error e) {
        hr = e.Error();
    } catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
        hr = E_UNEXPECTED;
    }
	return hr;
}

STDMETHODIMP CTVETrack::get_Service(ITVEService **ppVal)
{
 	CHECK_OUT_PARAM(ppVal);

	if(NULL == m_pVariation)
	{
		*ppVal = NULL;
		return S_OK;
	}

	return m_pVariation->get_Service(ppVal);
}

STDMETHODIMP CTVETrack::get_Trigger(ITVETrigger **ppVal)
{
	HRESULT hr;
	DBG_HEADER(CDebugLog::DBG_TRACK, _T("CTVETrack::get_Trigger"));

	if (ppVal == NULL)
		return E_POINTER;

	CSmartLock spLock(&m_sLk);		
    try {
		if(m_spTrigger)
		{
			hr = m_spTrigger->QueryInterface(ppVal);
		} else {
			*ppVal = NULL;
			hr = S_FALSE;
		}
    } catch(...) {
        return E_POINTER;
    }
	return hr;
}


// --------------------------------------------------------------------------
STDMETHODIMP CTVETrack::AttachTrigger(ITVETrigger *pTrigger)
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_TRACK, _T("CTVETrack::AttachTrigger"));

	if(pTrigger == NULL) 
		return E_POINTER;
								// should verify we can QI pTrigger for ITrigger
	CComQIPtr<ITVETrigger_Helper> spTrigHelper = pTrigger;
	if(!spTrigHelper) return E_NOINTERFACE;

	CComPtr<ITVETrack> spTrackThis(this);

	CSmartLock spLock(&m_sLk);	
	spTrigHelper->ConnectParent(spTrackThis);	// do back pointer (non ref counted)

	m_spTrigger = pTrigger;						// do downward pointer (ref counted)



												// set the trigger in the expire queue...
	IUnknownPtr spUnkVaria;
	hr = spTrackThis->get_Parent(&spUnkVaria);
	if(S_OK == hr) {
		ITVEVariationPtr spVaria(spUnkVaria);
		if(spVaria) {
			IUnknownPtr spUnkEnh;
			hr = spVaria->get_Parent(&spUnkEnh);
			if(S_OK == hr) {
				ITVEEnhancementPtr spEnh(spUnkEnh);
				if(spEnh) {
					IUnknownPtr spUnkService;
					hr = spEnh->get_Parent(&spUnkService);
					if(S_OK == hr) {
						ITVEService_HelperPtr spServiHelper(spUnkService);
						if(spServiHelper) {
							DATE dateExpires;
							pTrigger->get_Expires(&dateExpires);
							spServiHelper->AddToExpireQueue(dateExpires, pTrigger);
						}
					}
				}
			}
		}
	}

	return S_OK;
}

STDMETHODIMP CTVETrack::ReleaseTrigger()
{
	DBG_HEADER(CDebugLog::DBG_TRACK, _T("CTVETrack::ReleaseTrigger"));
	if(m_spTrigger) {
		CComQIPtr<ITVETrigger_Helper> spTrigHelper = m_spTrigger;
		spTrigHelper->RemoveYourself();
	}

	m_spTrigger = NULL;							// kill downward pointer (smartpointer ref counted)
	return S_OK;
}


_COM_SMARTPTR_TYPEDEF(ITVETrigger, __uuidof(ITVETrigger));

		// like AttachTrigger, but does the parsing too.  Easier to call.
STDMETHODIMP CTVETrack::CreateTrigger(const BSTR rVal)
{
	DBG_HEADER(CDebugLog::DBG_TRACK, _T("CTVETrack::CreateTrigger"));
	HRESULT hr;
	ITVETriggerPtr	spTrig;
		// spTrig = ITVETriggerPtr(CLSID_TVETrigger);
	CComObject<CTVETrigger> *pTrig;
	hr = CComObject<CTVETrigger>::CreateInstance(&pTrig);
	if(FAILED(hr))
		return hr;
	hr = pTrig->QueryInterface(&spTrig);			// typesafe QI
	if(FAILED(hr)) {
		delete pTrig;
		return hr;
	}
								
	hr = spTrig->ParseTrigger(rVal);
	if(FAILED(hr)) 
		return hr;

	return AttachTrigger(spTrig);			// lock done in this call
}


		// temp interfaces for debugging...
STDMETHODIMP CTVETrack::get_Description(BSTR *pVal)
{
	CHECK_OUT_PARAM(pVal);
	CSmartLock spLock(&m_sLk);
	return m_spbsDesc.CopyTo(pVal);
}

STDMETHODIMP CTVETrack::put_Description(BSTR newVal)
{
	CSmartLock spLock(&m_sLk);
	m_spbsDesc = newVal;
	return S_OK;
}

void CTVETrack::Initialize(TCHAR * strDesc)
{
	DBG_HEADER(CDebugLog::DBG_TRACK, _T("CTVETrack::Initialize"));
	m_spbsDesc = strDesc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvetracks.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVETracks.cpp : Implementation of CTVETracks
#include "stdafx.h"
#include "MSTvE.h"
#include "TVETrack.h"
#include "TVETracks.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
// --------------
//  test initialization code

// --------------

/////////////////////////////////////////////////////////////////////////////
// CTVETracks


STDMETHODIMP CTVETracks::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVETracks
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/* ------------------------------  implemented by ICollectionOnSTLImpl<> base class
STDMETHODIMP CTVETracks::get_Count(long *pVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CTVETracks::get__NewEnum(LPUNKNOWN *pVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP CTVETracks::get_Item(long lIndex, VARIANT *pVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

*/
/*
STDMETHODIMP CTVETracks::Add(VARIANT var)
{
	// TODO: Add your implementation code here
	return S_OK;
}

STDMETHODIMP CTVETracks::Remove(long lIndex)
{

	// TODO: Add your implementation code here
	return S_OK;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvetrack.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVETrack.h : Declaration of the CTVETrack

#ifndef __TVETRACK_H_
#define __TVETRACK_H_

#include "resource.h"       // main symbols

#include "TVETrigg.h"
#include "TveSmartLock.h"
/////////////////////////////////////////////////////////////////////////////
// CTVETrack
class ATL_NO_VTABLE CTVETrack : 
	public CComObjectRootEx<CComMultiThreadModel>,		// CComSingleThreadModel
	public CComCoClass<CTVETrack, &CLSID_TVETrack>,
	public ITVETrack_Helper,
	public ISupportErrorInfo,
	public IDispatchImpl<ITVETrack, &IID_ITVETrack, &LIBID_MSTvELib>
{
public:
	CTVETrack()
	{
		m_pUnkMarshaler		= NULL;
		m_pVariation		= NULL;							// up pointer, not reference counted
	} 

	HRESULT FinalConstruct()								// create internal objects
	{
		HRESULT hr;
		hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pUnkMarshaler.p);
		if(FAILED(hr)) {
			_ASSERT(FALSE);
			return hr;
		}
		
		CComObject<CTVETrigger> *pTrigger;
		hr = CComObject<CTVETrigger>::CreateInstance(&pTrigger);
		if(FAILED(hr))
			return hr;
		hr = pTrigger->QueryInterface(&m_spTrigger);		// typesafe QI
		if(FAILED(hr))
			delete pTrigger; 
		return hr;
	}

	HRESULT FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_TVETRACK)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVETrack)
	COM_INTERFACE_ENTRY(ITVETrack)
	COM_INTERFACE_ENTRY(ITVETrack_Helper)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	CComPtr<IUnknown> m_pUnkMarshaler;

// ITVETrack
public:
	STDMETHOD(get_Parent)(/*[out, retval]*/ IUnknown* *pVal);			// may return NULL!
	STDMETHOD(get_Service)(/*[out, retval]*/ ITVEService* *pVal);			// may return NULL!
	STDMETHOD(get_Trigger)(/*[out, retval]*/ ITVETrigger* *pVal);

	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Description)(/*[in]*/ BSTR newVal);
	void Initialize(TCHAR * strDesc);		// debug

	STDMETHOD(AttachTrigger)(ITVETrigger *pTrigger);

// ITVETrack_Helper
public:
	STDMETHOD(CreateTrigger)(const BSTR rVal);

	STDMETHOD(ConnectParent)(ITVEVariation * pVariation);
	STDMETHOD(ReleaseTrigger)();
	STDMETHOD(RemoveYourself)();
	STDMETHOD(DumpToBSTR)(BSTR *pbstrBuff);

private:
	CTVESmartLock		m_sLk;

private:
	ITVEVariation			*m_pVariation;		// up pointer - non add'refed.
	CComPtr<ITVETrigger>	m_spTrigger;

	CComBSTR m_spbsDesc;

};

#endif //__TVETRACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvetracks.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVETracks.h : Declaration of the CTVETracks

#ifndef __TVETRACKS_H_
#define __TVETRACKS_H_

#include "resource.h"       // main symbols

// --------------------------------------------------------------
#include "TVECollect.h"

class CTVEVariation;
class CTVETrack;
class CTVETrigger;


class CTVETracks : public TVECollection<ITVETrack, ITVETracks>,
//	public CComCoClass<CTVETracks, &CLSID_TVETracks>,		// no class factory
	public ISupportErrorInfo
{
public:
	DECLARE_REGISTRY_RESOURCEID(IDR_TVETRACKS);
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

#endif //__TVETRACKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvetrigctrl.h ===
// TveTrigCtrl.h : Declaration of the CTVETriggerCtrl


#ifndef __TVETRIGGERCTRL_H__
#define __TVETRIGGERCTRL_H__

#include "resource.h"       // main symbols
#include "TveSmartLock.h"

#include "MSTvEcp.h"

#include <exdisp.h>			// IE4 Interfaces
#include <mshtml.h>

#include <atlctl.h>			// for IObjectSafety  (see pg 445 Grimes: Professional ATL Com programming)

_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,		__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement_Helper,	__uuidof(ITVEEnhancement_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVETrigger,				__uuidof(ITVETrigger));
/////////////////////////////////////////////////////////////////////////////
// CTVETriggerCtrl

class ATL_NO_VTABLE CTVETriggerCtrl : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CTVETriggerCtrl, &CLSID_TVETriggerCtrl>,
    public IDispatchImpl<ITVETriggerCtrl, &IID_ITVETriggerCtrl, &LIBID_MSTvELib>,
 //  public IDispatchImpl<ITVETriggerCtrlConnectionEvents, &IID_ITVETriggerCtrlConnectionEvents, &LIBID_MSTvELib>,
    public IObjectWithSiteImpl<CTVETriggerCtrl>,
    public IConnectionPointContainerImpl<CTVETriggerCtrl>,
 	public CProxy_ITVETriggerCtrlEvents< CTVETriggerCtrl >,
	public IObjectSafetyImpl<CTVETriggerCtrl, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
	public IProvideClassInfo2Impl<&CLSID_TVETriggerCtrl, &DIID__ITVETriggerCtrlEvents, &LIBID_MSTvELib>,
	public IPersistPropertyBag,
	public ITVETriggerCtrl_Helper,
	public ISupportErrorInfo
{
public:
    CTVETriggerCtrl()
	{
	}

	HRESULT FinalConstruct();
	HRESULT FinalRelease();

    ~CTVETriggerCtrl()
	{
	}


DECLARE_REGISTRY_RESOURCEID(IDR_TVETRIGGERCTRL)
DECLARE_GET_CONTROLLING_UNKNOWN()
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVETriggerCtrl)
    COM_INTERFACE_ENTRY(ITVETriggerCtrl)
	COM_INTERFACE_ENTRY(ITVETriggerCtrl_Helper)
//	COM_INTERFACE_ENTRY(ITVETriggerCtrlConnectionEvents)

//    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY2(IDispatch, ITVETriggerCtrl)

    COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()


BEGIN_CONNECTION_POINT_MAP(CTVETriggerCtrl)
    CONNECTION_POINT_ENTRY(DIID__ITVETriggerCtrlEvents)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IObjectWithSite
public:
    STDMETHOD(SetSite)(LPUNKNOWN pUnk);

// IObjectSafety
public:
	/*
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, 
					    DWORD *pdwSupportedOptions, 
					    DWORD *pdwEnabledOptions);
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, 
					    DWORD dwOptionSetMask, 
					    DWORD dwEnabledOptions);
	*/
// IPersistPropertyBag
public:
    STDMETHOD(GetClassID)(CLSID* pClassID);
    STDMETHOD(InitNew)();
    STDMETHOD(Load)(IPropertyBag* pPropBag,
		    IErrorLog* pErrorLog);
    STDMETHOD(Save)(IPropertyBag* pPropBag,
		    BOOL fClearDirty,
		    BOOL fSaveAllProperties);

// ITVETriggerCtrl

public:
  //  STDMETHOD(Connect)(BSTR bstrData,  LPUNKNOWN pUnk);
 //   STDMETHOD(Disconnect)();
//    STDMETHOD(NavTarget)(BSTR bstrName, BSTR bstrURL, BOOL* pbHandled);
 //   STDMETHOD(NavBase)(BSTR bstrURL, BOOL* pbHandled);
 //   STDMETHOD(ExecScript)(BSTR bstrScript, BOOL* pbHandled);
 //   STDMETHOD(get_TargetSync)(BSTR bstrName, BOOL *pbSync);
 //   STDMETHOD(put_TargetSync)(BSTR bstrName, BOOL bSync);
  //  STDMETHOD(ClearTargets)();
  //  STDMETHOD(VChipRating)(long lRating, BOOL* pbHandled);
  //  STDMETHOD(VChipOverride)();
 //

				// The Trigger Receiver Object
    STDMETHOD(put_enabled)(VARIANT_BOOL newVal);
    STDMETHOD(get_enabled)(VARIANT_BOOL* pVal);
    STDMETHOD(get_sourceID)(BSTR* pbstrID);
    STDMETHOD(put_releasable)(VARIANT_BOOL newVal);
    STDMETHOD(get_releasable)(VARIANT_BOOL* pVal);
    STDMETHOD(get_backChannel)(BSTR* pVal);
    STDMETHOD(get_contentLevel)(double* pVal);

// ITVETriggerCtrl_Helper
				// sets Active Enhancement via this one
	STDMETHOD(get_TopLevelPage)(BSTR *pVal);
    STDMETHOD(put_sourceID)(BSTR  bstrID);					// cache the ID of the (a=) field

private:  
				// IE Browser Specific
//    CComPtr<IWebBrowser2>	m_pTopBrowser;

	IHTMLWindow2Ptr			m_spTopHTMLWindow2;
	IHTMLDocument2		  * m_pTopHTMLDocument2;		// can't be a smart pointer - causes circular reference
	
protected: // ATVEF Related
    BOOL					m_fEnabled;					// Indicating if triggers are enabled (default is true = read/write)
    BOOL					m_fReleasable;				// True if top level page associate with active enhancement can be auto-tuned away from (default = false)
	DOUBLE					m_rContentLevel;			// Content level of the receiver - (default = 1.0)
	CComBSTR				m_spbsSourceID;				// local storate for the UUID(a=) field of the enhancement

protected: // URL Completion, Navigation
    BOOL					m_bLocalDir;
    CComBSTR				m_spbsWorkingDir;
 //   virtual	CComBSTR	CompleteURL(BSTR bstrRelativeURL);
 //   virtual	BOOL		ValidNavigate(BSTR bstrURL);

protected:  // Base Page Navigation  
    CComBSTR				m_spbsBasePage;
    struct _stat			m_statBaseURL;
    BOOL					m_bHasBaseStat;

  //  STDMETHOD(OnNavBase)(BSTR bstrURL, BOOL bValidate);
public:
   // STDMETHOD(NavBase)(BSTR bstrURL, BOOL bValidate = TRUE);

};

#endif // __TVETRIGGERCTRL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvetrigctrl.cpp ===
// ------------------------------------------------------------------------------
//   TveTrigCtrl.cpp
//
//		Implementation of the <OBJECT TYPE="application/tve-trigger"></OBJECT>
//
//		to hook TVE stuff into a web page
// ------------------------------------------------------------------------------
//
//  BUG
//		the SourceID field not working.
//		Trouble is twofold.
//			1) the code to set the value in CTVENavAid::NotifyDocumentComplete
//			   occurs after the page is loaded and displayed via a TriggerNav
//			2) When the TriggerCtrl gets reloaded and the
//			   page gets refreshed, so any current value gets trashed.
//			   Persistance doesn't seem to be working, .. it's not really
//			   implemented, but the Save/Load methods aren't getting called.

#include "stdafx.h"

#include "MSTvE.h"				// MIDL generated file...
#include "TveTrigCtrl.h"

#include "TveDbg.h"
#include "Wininet.h"			// internet status
#include "ShlGuid.h"			// SID_STopLevelBrowswer among others
#include "ShlObj.h"				// IShellBrowswer 

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*
_COM_SMARTPTR_TYPEDEF(IServiceProvider,	__uuidof(IServiceProvider));
_COM_SMARTPTR_TYPEDEF(IWebBrowser2,		__uuidof(IWebBrowser2));
*/

_COM_SMARTPTR_TYPEDEF(IShellBrowser,	__uuidof(IShellBrowser));
/////////////////////////////////////////////////////////////////////////////
// CTVETriggerCtrl


HRESULT 
CTVETriggerCtrl::FinalConstruct()
{ 
	m_fEnabled		= true;			// Default values per the Atvef Spec
	m_fReleasable	= false;
	m_rContentLevel = 1.0;

	m_pTopHTMLDocument2 = NULL;	

	m_bLocalDir		= false;		// not sure what these are...
	m_bHasBaseStat	= false;


#if 0
	DBG_SET_LOGFLAGS(_T("c:\\TveDbg.log"),
	// section 1
		CDebugLog::DBG_SEV1 | 			// Basic Structure
		CDebugLog::DBG_SEV2	|			// Error Conditions
		CDebugLog::DBG_SEV3	|			// Warning Conditions
/*		CDebugLog::DBG_SEV4	|			// Generic Info 
*/		CDebugLog::DBG_EVENT |			// Outgoing events 
/*		CDebugLog::DBG_PACKET_RCV |		// each packet received..
*/		CDebugLog::DBG_MCASTMNGR |		// multicast manager
		CDebugLog::DBG_MCAST |			// multicast object (multiple ones)
		CDebugLog::DBG_SUPERVISOR |		// TVE Supervisor
		CDebugLog::DBG_SERVICE |		// Services
		CDebugLog::DBG_ENHANCEMENT |	// Enhancements
		CDebugLog::DBG_VARIATION |		// Variations
		CDebugLog::DBG_TRACK |			// Tracks
		CDebugLog::DBG_TRIGGER |		// Triggers
		CDebugLog::DBG_TRIGGERCTRL |	// Triggers

/*		CDebugLog::DBG_UHTTP |			// UHTTP methods
		CDebugLog::DBG_UHTTPPACKET |	// detailed dump on each packet
		CDebugLog::DBG_WSRECV |
		CDebugLog::DBG_FCACHE |
		CDebugLog::DBG_MIME	 | 
*/		CDebugLog::DBG_MISSPACKET |		// missing packets
		CDebugLog::DBG_EVENT |			// each event sent

	// bank 2
		0,								// terminating value for '|'

	// bank 3
		0,

	// bank 4									// need one of these last two flags
//		CDebugLog::DBG4_ATLTRACE |		// atl interface count tracing
		CDebugLog::DBG4_WRITELOG |		// write to a fresh log file (only need 0 or 1 of these last two flags)
//		CDebugLog::DBG4_APPENDLOG |		// append to existing to log file, 
		0,	

	// Default Level
		5);								// verbosity level... (0-5, higher means more verbose)
#endif

	return S_OK;
}


HRESULT 
CTVETriggerCtrl::FinalRelease()
{
   DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::FinalRelease"));
	m_pTopHTMLDocument2 = NULL;			// not needed since smart pointers, but makes debugging easier
	m_spTopHTMLWindow2 = NULL;

	return S_OK;
}

STDMETHODIMP CTVETriggerCtrl::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVETriggerCtrl
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

			// ignore parameters and framgment identifiers (i.e. characters in the URL
			//   including and following the first "?" or "#" character) 
HRESULT
CleanupURL(BSTR bstrURL, BSTR *pBstrOut)
{
	CComBSTR bstrTmp(bstrURL);
	WCHAR *pChar = bstrTmp.m_str;
	
	while(*pChar)
	{
		if(*pChar == '?' || *pChar == '#')
		{
			*pChar = 0;
			break;
		}
		pChar++;
	}
	bstrTmp.CopyTo(pBstrOut);
	return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
// CEnhCtrl - IObjectWithSite
STDMETHODIMP CTVETriggerCtrl::SetSite(LPUNKNOWN pUnk)
{
    DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::SetSite"));

	HRESULT hr = S_OK;

		// ---------------------------------------------------------------------
							// disconnecting...
    if (NULL == pUnk)
    {
		TVEDebugLog((CDebugLog::DBG_TRIGGERCTRL, 3,_T("Doing SetSite of NULL")));	

							//  remove from the IMPL class
		hr = IObjectWithSiteImpl<CTVETriggerCtrl>::SetSite(pUnk);
		return hr;
    } 


		// ---------------------------------------------------------------------
							// connecting

							// set the site down in the Impl class
    hr = IObjectWithSiteImpl<CTVETriggerCtrl>::SetSite(pUnk);
    if (FAILED(hr))
		return hr;

	// Attempt to get IWebBrowser2 from the Site 
	// - we want our sourceID property we
	IServiceProviderPtr	spServiceProvider(pUnk);
	CComBSTR spbsSourceID;
	if(spServiceProvider)
	{
		IWebBrowser2Ptr spWebBrowser;
		hr = spServiceProvider->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void **) &spWebBrowser);
		if(!FAILED(hr) && NULL != spWebBrowser)
		{
			CComVariant	cv;		// put in CTVENavAid::CacheTriggerToExecAfterNav() 
			hr = spWebBrowser->GetProperty(L"MSTvE.TVENavAid.SourceID", &cv);
			if(!FAILED(hr) && (VT_EMPTY != cv.vt) )
				spbsSourceID = cv.bstrVal;
		}
	}

	// Attempt to get the IHTMLWindow2 from the site.
	// nasty walk of the object model to do so...
	//
	//		Does this by QI'ing the site passed in on the SetSite for IOleClientSitePtr
	//		gets the IOleContainer from the ClientSite->GetContainer() 
	//		QI's the container for the IHTMLDocument2Ptr
	//		gets the IHTMLWindow2 from the IHTMLDocument2->get_ParentWindow2()

	IOleContainerPtr spContainer;
	IOleClientSitePtr spClientSite(m_spUnkSite);
	if(NULL == spClientSite)
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 1,_T("Unable to QI UnkSite for IOleClientSite")));	
		return E_NOINTERFACE;
	} 


	hr = spClientSite->GetContainer(&spContainer);
	if(FAILED(hr) || NULL == spContainer)
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 1,_T("Unable to GetContainer of IOleClientSite hr=0x%08x"),hr));	
		return E_FAIL;
	}
		
	IHTMLDocument2Ptr spDoc2(spContainer);
	if(NULL == spDoc2)
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 1,_T("Unable to QI Container for IHTMLDocument2")));	
		return E_NOINTERFACE;
	}

	IHTMLWindow2Ptr spParentWindow2;
	hr = spDoc2->get_parentWindow(&spParentWindow2);
	if(FAILED(hr) || NULL == spParentWindow2)
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 1,_T("Unable to get_parentWindow of HTMLDocument2 hr=0x%08x"),hr));	
		return E_FAIL;
	}
	
								// remember the top windows
	m_pTopHTMLDocument2		= spDoc2;			// can't make a smart pointer - causes a circular reference to this
	m_spTopHTMLWindow2		= spParentWindow2;
	m_spbsSourceID			= spbsSourceID;		// save that SourceID -- wow, what a pain it was to get this...

	CComBSTR spURL;				// am I where I expect to be?
	spDoc2->get_URL(&spURL);
	
								// ignore characters including or after the first "?" or "#"
	CleanupURL(spURL, &m_spbsBasePage);

	

								// TODO - remove Temp Hack - change the text color of the Atvef window...
#ifdef _DEBUG
	CComVariant cvColor(0x008B0000);
	spDoc2->put_fgColor(cvColor);
#endif

//	m_spTopHTMLWindow2->execScript("");

/*----
					// walk code comes from Q172763 "Accessing the Object Model from Within an ActiveX Control" 
					//     and from CIE4NavCtrl::Connect()		enhtrig/ie4ctrl.cpp
 	//   Idea is to 
	//	  Get the WebBrowserApp from its Containing HTML page
	//	  Then get the Document property from the IWebBrowser App
	//	  Then get the script property of the document.
	//		This puts us at the top level (window) object in the object model
	
	IWebBrowser2Ptr spWebBrowser;

	IServiceProviderPtr spServProv(m_spUnkSite);
	if(NULL == spServProv)
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 1,_T("Unable to QI Site for ServiceProvider")));	
		return E_NOINTERFACE;
	}

 //   CComPtr<IShellBrowser>  spShellBrowser;
	IShellBrowserPtr		spShellBrowser;

			// see  "HOWTO: Retrieve the Top-Level IWebBrowser2 Interface from an ActiveX Control"
			//   get a reference to the topmost IWebBrowser2, the one containing the frameset itself. 

    hr = spServProv->QueryService(SID_STopLevelBrowser,
								 IID_IShellBrowser,
								 (LPVOID*) &spShellBrowser);
	if(FAILED(hr) || spShellBrowser == NULL)
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 1,_T("Unable to locate TopLevelBrowser service from ServiceProvider - hr=0x%08x")));	
		return hr ? hr : E_NOINTERFACE;
	}

 //   CComQIPtr<IServiceProvider, &IID_IServiceProvider> pServProv2(pShellBrowser);
	IServiceProviderPtr spServProv2(spShellBrowser);
	if(NULL == spServProv2)
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 1,_T("Unable to QI TopLevelBrowser for ServiceProvider")));	
		return E_NOINTERFACE;
	}
 
    hr = spServProv2->QueryService(SID_SInternetExplorer,
								  IID_IWebBrowser2,
								  (LPVOID*) &spWebBrowser);
	if(NULL == spWebBrowser)
	{
		TVEDebugLog((CDebugLog::DBG_SEV2, 1,_T("Unable to locate WebBrowser2 service from ServiceProvider2 - hr=0x%08x")));	
		return hr ? hr : E_NOINTERFACE;
	}
----- */

				// ------------------------------------------------------

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CEnhCtrl - IObjectSafety
				// don't think I need following implementations, since have an IMPL in the class def
/*STDMETHODIMP 
CTVETriggerCtrl::GetInterfaceSafetyOptions(REFIID riid, 
						    DWORD *pdwSupportedOptions, 
						    DWORD *pdwEnabledOptions)
{
    DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CEnhCtrl::GetInterfaceSafetyOptions"));

    CHECK_OUT_PARAM(pdwSupportedOptions);
    CHECK_OUT_PARAM(pdwEnabledOptions);

    HRESULT hr = IObjectSafetyImpl<CTVETriggerCtrl>::GetInterfaceSafetyOptions(riid,
									pdwSupportedOptions,
									pdwEnabledOptions);
    if ((FAILED(hr)) &&
	    (IID_IPersistPropertyBag == riid))
    {
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		hr = S_OK;
    }

    return hr;
}

STDMETHODIMP 
CTVETriggerCtrl::SetInterfaceSafetyOptions(REFIID riid, 
						 DWORD dwOptionSetMask, 
						 DWORD dwEnabledOptions)
{
    DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::SetInterfaceSafetyOptions"));

    HRESULT hr = IObjectSafetyImpl<CTVETriggerCtrl>::SetInterfaceSafetyOptions(riid,
									dwOptionSetMask,
									dwEnabledOptions);
    if ((FAILED(hr)) &&
	     (IID_IPersistPropertyBag == riid))
    {
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		hr = S_OK;
    }

    return hr;
}
*/
/////////////////////////////////////////////////////////////////////////////
// CTVETriggerCtrl - IPersistPropertyBag
STDMETHODIMP 
CTVETriggerCtrl::GetClassID(CLSID* pClassID)
{
    DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::GetClassID"));
    CHECK_OUT_PARAM(pClassID);
 
    *pClassID = CLSID_TVETriggerCtrl;

    return S_OK;
}

STDMETHODIMP CTVETriggerCtrl::InitNew()
{
    DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::InitNew"));
	HRESULT hr = S_OK;
//    hr = InitTVESupervisor();  // done on the back end of SetSite
    return hr;
}

STDMETHODIMP 
CTVETriggerCtrl::Load(IPropertyBag* pPropBag,
			          IErrorLog* pErrorLog)
{
    DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::Load"));
    USES_CONVERSION;

    if (NULL == pPropBag)
		return E_INVALIDARG;

    HRESULT hr = S_OK;
    return hr;
}

STDMETHODIMP CTVETriggerCtrl::Save(IPropertyBag* pPropBag,
			    BOOL fClearDirty,
			    BOOL fSaveAllProperties)
{
    DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::Save"));
    return E_NOTIMPL;
}

// ----------------------------------------------------------------------
// ITVETriggerCtrl
STDMETHODIMP CTVETriggerCtrl::put_enabled(VARIANT_BOOL newVal)
{
	DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::put_enabled"));

	m_fEnabled = newVal;
	return S_OK;
}

STDMETHODIMP CTVETriggerCtrl::get_enabled(VARIANT_BOOL* pVal)
{
	DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::get_enabled"));
	CHECK_OUT_PARAM(pVal);

	*pVal = m_fEnabled ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

		// returns a NULL guid and S_FALSE if no active enhancement is set..	(UUID / a= field from the SAP announcement)

STDMETHODIMP CTVETriggerCtrl::get_sourceID(BSTR* pbstrID)
{
	DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::get_sourceID"));
	CHECK_OUT_PARAM(pbstrID);
	HRESULT hr = S_OK;

	if(0 == m_spbsSourceID.Length())
	{
		*pbstrID = NULL;
		return S_FALSE;			// not really there...
	}
    return m_spbsSourceID.CopyTo(pbstrID);
}

STDMETHODIMP CTVETriggerCtrl::put_sourceID(BSTR bstrID)						// this method on the Helper interface
{
	DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::put_sourceID"));

    m_spbsSourceID = bstrID;		// Null value better be ok

	return S_OK;
}


STDMETHODIMP CTVETriggerCtrl::put_releasable(VARIANT_BOOL newVal)
{
	DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::put_releasable"));

    m_fReleasable = newVal;
	return S_OK;
}

STDMETHODIMP CTVETriggerCtrl::get_releasable(VARIANT_BOOL* pVal)
{
	DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::get_releasable"));
	CHECK_OUT_PARAM(pVal);

	*pVal = m_fReleasable ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CTVETriggerCtrl::get_backChannel(BSTR* pbstrVal)
{
	DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::get_backChannel"));
	CHECK_OUT_PARAM(pbstrVal);


    CComBSTR bstrConnectedState;

    DWORD dwState;
    if (FALSE == InternetGetConnectedState(&dwState, NULL))
    {
			//   Local system has a valid connection to the Internet, but it may or may not be currently connected. 
		if(dwState & INTERNET_CONNECTION_CONFIGURED)
			bstrConnectedState = "disconnected";	// may take some time to reconnect
		else
			bstrConnectedState = "unavailable";
    }
    else
    {
		//   Local system uses a local area network to connect to the Internet. 
		if(dwState & INTERNET_CONNECTION_LAN) 
			bstrConnectedState = "permanent";
		else
			bstrConnectedState = "connected";		// currently connected
    }
/*   other parameters
	if(dwState & INTERNET_CONNECTION_MODEM)
	//   Local system uses a modem to connect to the Internet. 
	if(dwState & INTERNET_CONNECTION_MODEM_BUSY) 
	//   No longer used. 
	if(dwState & INTERNET_CONNECTION_OFFLINE) 
	//   Local system is in offline mode. 
	if(dwState & INTERNET_CONNECTION_PROXY) 
	//   Local system uses a proxy server to connect to the Internet. 
	if(dwState & INTERNET_RAS_INSTALLED)
	//   Local system has RAS installed. 
*/

    return bstrConnectedState.CopyTo(pbstrVal);
}

STDMETHODIMP CTVETriggerCtrl::get_contentLevel(double* pVal)
{
	DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::get_contentLevel"));
	CHECK_OUT_PARAM(pVal);
	
	*pVal = m_rContentLevel;

	return S_OK;
}


// --------------------------------------------------------------------------
//   ITVETriggerCtrl_Helper
//
//		Uses a trigger to set the Active Enhancement.
//		(Needed for the get_sourceID method to work.)



STDMETHODIMP CTVETriggerCtrl::get_TopLevelPage(BSTR* pbstrVal)
{
	DBG_HEADER(CDebugLog::DBG_TRIGGERCTRL, _T("CTVETriggerCtrl::get_TopLevelPage"));
	CHECK_OUT_PARAM(pbstrVal);

	return m_spbsBasePage.CopyTo(pbstrVal);
}
// ---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvetrigg.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// -----------------------------------------------------------------
//  TVETrigger.cpp : Implementation of CTVETrigger
//
//	Parses ATVEF triggers.
//
//		Major method is ParseTrigger(), which takes a string of the
//		form:	<URL>[x:xxx][y:yyy][z:zzz][CODE]
//
//			where [CODE] is a optional 4 hex digit CRC code.
//			Magic value of 'XXXX' for code, causes it to compute
//			the CRC value and store it.
//   
//
// -----------------------------------------------------------------

#include "stdafx.h"
#include <stdio.h>

#define _CRTDBG_MAP_ALLOC 
#include "crtdbg.h"
#include "DbgStuff.h"

#include "MSTvE.h"
#include "TVETrigg.h"

#include "TveDbg.h"
#include "MSTveMsg.h"
#include "shlwapi.h"			// URLUnescape

#include "..\Common\address.h"
#include "..\Common\enhurl.h"
#include "..\Common\isotime.h"


#define ABS(x) (((x)>0) ? (x) : -(x))

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,		__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement_Helper,	__uuidof(ITVEEnhancement_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEVariation_Helper,		__uuidof(ITVEVariation_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrack,				__uuidof(ITVETrack));
_COM_SMARTPTR_TYPEDEF(ITVETrack_Helper,			__uuidof(ITVETrack_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrigger,				__uuidof(ITVETrigger));
_COM_SMARTPTR_TYPEDEF(ITVETrigger_Helper,		__uuidof(ITVETrigger_Helper));


_COM_SMARTPTR_TYPEDEF(ITVEAttrTimeQ,			__uuidof(ITVEAttrTimeQ));

/////////////////////////////////////////////////////////////////////////////
// CTVETrigger_Helper

HRESULT 
CTVETrigger::FinalRelease()
{
	DBG_HEADER(CDebugLog::DBG_TRIGGER, _T("CTVETrigger::FinalRelease"));
	m_pTrack = NULL;				// kill back pointer for giggles...
	return S_OK;
}


STDMETHODIMP CTVETrigger::ConnectParent(ITVETrack *pTrack)
{
	DBG_HEADER(CDebugLog::DBG_TRIGGER, _T("CTVETrigger::ConnectParent"));
	if(!pTrack) return E_POINTER;
	CSmartLock spLock(&m_sLk);

	m_pTrack = pTrack;			// not smart pointer add ref here, I hope.
	return S_OK;
}


STDMETHODIMP CTVETrigger::RemoveYourself()
{
	HRESULT hr = S_OK;
	DBG_HEADER(CDebugLog::DBG_TRIGGER, _T("CTVETrigger::RemoveYourself"));

	CSmartLock spLock(&m_sLk);

	if(NULL ==  m_pTrack) {
		return S_FALSE;			// already removed...
	}
	
	ITVEServicePtr spServi;				// get the service holding this track
	hr = get_Service(&spServi);
	
	ITVETriggerPtr spTrigger(this);		// keep an extra reference to this trigger.

	ITVETrack *pTrack = m_pTrack;		// keep track of this for a second, to avoid a circular ref 
	m_pTrack = NULL;					// remove the unref'ed up pointer 
	
	ITVETrack_HelperPtr spTrackHelper(pTrack);
	spTrackHelper->RemoveYourself();

										// indicate trigger is being expired..

	if(spServi) {
		HRESULT hr2 = S_OK;
	/*	{								// don't need this code, it's done in the Service remove code
			ITVEAttrTimeQPtr spExpireQueue;
			spServi->get_ExpireQueue(&spExpireQueue);
			IUnknownPtr spPunkThis(this);
			CComVariant  cvThis((IUnknown *) spPunkThis);
			hr2 = spExpireQueue->Remove(cvThis);
		} */

		IUnknownPtr spUnkSuper;
		hr = spServi->get_Parent(&spUnkSuper);
		if(S_OK == hr) {
			ITVESupervisor_HelperPtr spSuperHelper(spUnkSuper);
			spSuperHelper->NotifyTrigger(NTRK_Expired, pTrack, 0);
		}
	}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTVETrigger

STDMETHODIMP CTVETrigger::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVETrigger,
		&IID_ITVETrigger_Helper
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CTVETrigger::get_IsValid(VARIANT_BOOL *pVal)
{
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }

 	CHECK_OUT_PARAM(pVal);

//	CSmartLock spLock(&m_sLk);
	*pVal = m_fIsValid ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CTVETrigger::get_URL(BSTR *pVal)
{
	DBG_HEADER(CDebugLog::DBG_TRIGGER, _T("CTVETrigger::get_URL"));
 	CHECK_OUT_PARAM(pVal);
    try {
//		CSmartLock spLock(&m_sLk);
        return m_spbsURL.CopyTo(pVal);
    } catch(...) {
        return E_POINTER;
    }
}

STDMETHODIMP CTVETrigger::get_Name(BSTR *pVal)
{
 	DBG_HEADER(CDebugLog::DBG_TRIGGER, _T("CTVETrigger::get_Name"));
	CHECK_OUT_PARAM(pVal);
    try {
//		CSmartLock spLock(&m_sLk);
		return m_spbsName.CopyTo(pVal);
    } catch(...) {
        return E_POINTER;
    }
}

STDMETHODIMP CTVETrigger::get_Expires(DATE *pVal)
{
 	DBG_HEADER(CDebugLog::DBG_TRIGGER, _T("CTVETrigger::get_Expires"));
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
	CHECK_OUT_PARAM(pVal);

//	CSmartLock spLock(&m_sLk);
	*pVal = m_dateExpires;

	return S_OK;
}

STDMETHODIMP CTVETrigger::get_TVELevel(float *pVal)
{
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
	CHECK_OUT_PARAM(pVal);

//	CSmartLock spLock(&m_sLk);

	*pVal = m_rTVELevel;

	if(!m_fTVELevelPresent)
		return S_FALSE;	

	return S_OK;
}

STDMETHODIMP CTVETrigger::get_Executes(DATE *pVal)
{
    if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
	CHECK_OUT_PARAM(pVal);
	
//	CSmartLock spLock(&m_sLk);
	*pVal = m_dateExecutes;

	return S_OK;
}

STDMETHODIMP CTVETrigger::get_Script(BSTR *pVal)
{
  	DBG_HEADER(CDebugLog::DBG_TRIGGER, _T("CTVETrigger::get_Script"));
	CHECK_OUT_PARAM(pVal);
    try {
//		CSmartLock spLock(&m_sLk);
		return m_spbsScript.CopyTo(pVal);
    } catch(...) {
        return E_POINTER;
    }
	return S_OK;
}

STDMETHODIMP CTVETrigger::get_Rest(BSTR *pVal)
{
 	CHECK_OUT_PARAM(pVal);
    try {
//		CSmartLock spLock(&m_sLk);        
		return m_spbsRest.CopyTo(pVal);
    } catch(...) {
        return E_POINTER;
    }
	return S_OK;
}

STDMETHODIMP CTVETrigger::get_Parent(IUnknown **ppVal)
{
	if (!m_fInit) {
        return CO_E_NOTINITIALIZED;
    }
 	CHECK_OUT_PARAM(ppVal);
		
    try {
		if(m_pTrack) {
			IUnknownPtr spPunk(m_pTrack);
			spPunk->AddRef();
			*ppVal = spPunk;
		} else {
			*ppVal = NULL;
		}
    } catch(...) {
        return E_POINTER;
    }
	return S_OK;
}

STDMETHODIMP CTVETrigger::get_Service(ITVEService **ppVal)
{
	
 	CHECK_OUT_PARAM(ppVal);

	if(NULL == m_pTrack)
	{
		*ppVal = NULL;
		return S_OK;
	}

	return m_pTrack->get_Service(ppVal);
}

STDMETHODIMP CTVETrigger::get_CRC(const BSTR bstrTrigger, BSTR *pbstrCRC)  
{
	if(NULL == bstrTrigger)
		return E_INVALIDARG;			

	if (pbstrCRC == NULL)
		return E_POINTER;

	USES_CONVERSION;
	CSmartLock spLock(&m_sLk);

			// Convert string to Ascii 
    TCHAR* pcData = NULL; 
	pcData = W2T(bstrTrigger);

	CComBSTR bstrCRC;
	BOOL fHasChkSum;
	BOOL fValidChkSum = DiscoverValidateAndRemoveChkSum(pcData, &fHasChkSum, &bstrCRC);

	*pbstrCRC = bstrCRC;
	return S_OK;
}

STDMETHODIMP CTVETrigger::ParseTrigger(const BSTR bstrTrigger)  
{
    try{
        DBG_HEADER(CDebugLog::DBG_TRIGGER, _T("CTVETrigger::ParseTrigger"));

        m_fIsValid = false;
        if(NULL == bstrTrigger)
        {
            Error(GetTVEError(MSTVE_E_INVALIDTRIGGER), IID_ITVETrigger);
            return MSTVE_E_INVALIDTRIGGER;			
        }

        if(m_fInit) 
        {
            Error(GetTVEError(MSTVE_E_PARSEDALREADY), IID_ITVETrigger);
            return MSTVE_E_PARSEDALREADY;			// already been here, dun that.
        }

        USES_CONVERSION;
        DBG_WARN(CDebugLog::DBG_TRIGGER, W2T(bstrTrigger));

        // Parse the Data 
        char* pcData = NULL; pcData = W2A(bstrTrigger);
        int iLen = sizeof(char) * (strlen(pcData) + 1);

        //	LOG_EVAL(A2T(pcData));

        if ('<' != *pcData)
        {
            Error(GetTVEError(MSTVE_E_INVALIDURL), IID_ITVETrigger);
            return MSTVE_E_INVALIDURL;
        }

        BOOL fHasChkSum = true;

        //#define SKIP_CHECKSUM_TEST
#ifdef SKIP_CHECKSUM_TEST
        BOOL fValidChkSum = true; 
#else
        BOOL fValidChkSum = DiscoverValidateAndRemoveChkSum(A2T(pcData), &fHasChkSum);
#endif

        if(fHasChkSum && !fValidChkSum)
        {
            Error(GetTVEError(MSTVE_E_INVALIDCHKSUM), IID_ITVETrigger);
            return MSTVE_E_INVALIDCHKSUM;
        }

        HRESULT hr = S_OK;
        char* pcURL = NULL; pcURL = (char*) _alloca(iLen);
        char* pcAttrs = NULL; pcAttrs = (char*) _alloca(iLen);

        if (0 == sscanf(pcData, "<%[^>]> %[^\0]", pcURL, pcAttrs))
        {
            Error(GetTVEError(MSTVE_E_INVALIDURL), IID_ITVETrigger);
            return MSTVE_E_INVALIDURL;
        }

        char* pcName = NULL; pcName = (char*) _alloca(iLen); *pcName = NULL;
        char* pcExpire = NULL; pcExpire = (char*) _alloca(iLen); *pcExpire = NULL;
        char* pcScript = NULL; pcScript = (char*) _alloca(iLen); *pcScript = NULL;
        char* pcTVELevel = NULL; pcTVELevel = (char*) _alloca(iLen); *pcTVELevel = NULL;
        char* pcRest = NULL; pcRest = (char *) _alloca(iLen); *pcRest = NULL;
        char* pcR = pcRest;

        while (NULL != *pcAttrs)
        {
            pcAttrs++;	// Skip leading [
            switch (*pcAttrs)
            {
            case 'n':
            case 'N':
                {
                    if ((':' == pcAttrs[1]) || (0 == _strnicmp(pcAttrs, "name:", 5)))
                    {
                        if (0 == sscanf(pcAttrs, "%*[^:]:%[^]]", pcName))
                        {
                            Error(GetTVEError(MSTVE_E_INVALIDNAME), IID_ITVETrigger);
                            return MSTVE_E_INVALIDNAME;
                        }
                    }
                }
                break;
            case 'e':
            case 'E':
                {
                    if ((':' == pcAttrs[1]) || (0 == _strnicmp(pcAttrs, "expires:", 8)))
                    {
                        if (0 == sscanf(pcAttrs, "%*[^:]:%[^]]", pcExpire))
                        {
                            Error(GetTVEError(MSTVE_E_INVALIDEXPIREDATE), IID_ITVETrigger);
                            return MSTVE_E_INVALIDEXPIREDATE;
                        }
                    }
                }
                break;
            case 's':
            case 'S':
                {
                    if ((':' == pcAttrs[1]) || (0 == _strnicmp(pcAttrs, "script:", 7)))
                    {
                        if (0 == sscanf(pcAttrs, "%*[^:]:%[^]]", pcScript))
                        {
                            Error(GetTVEError(MSTVE_E_INVALIDSCRIPT), IID_ITVETrigger);
                            return MSTVE_E_INVALIDSCRIPT;
                        }
                    }
                }
                break;
            case 'v':			// v: or tve: are the same
            case 'V':
                {
                    if (0 == _strnicmp(pcAttrs, "v:", 2))
                    {
                        if (0 == sscanf(pcAttrs, "%*[^:]:%[^]]", pcTVELevel))
                        {
                            Error(GetTVEError(MSTVE_E_INVALIDTVELEVEL), IID_ITVETrigger);
                            return MSTVE_E_INVALIDTVELEVEL;
                        }
                    }
                }
                break;
            case 't':
            case 'T':
                {
                    if (0 == _strnicmp(pcAttrs, "tve:", 4))
                    {
                        if (0 == sscanf(pcAttrs, "%*[^:]:%[^]]", pcTVELevel))
                        {
                            Error(GetTVEError(MSTVE_E_INVALIDTVELEVEL), IID_ITVETrigger);
                            return MSTVE_E_INVALIDTVELEVEL;
                        }
                    }
                }
                break;
            default:
                *pcR++ = '[';
                while((NULL != *pcAttrs) && (']' != *pcAttrs))
                    *pcR++ = *pcAttrs++;
                *pcR++ = ']';
                break;
            }
            // skip to the begining of the next '['
            while ((NULL != *pcAttrs) && ('[' != *pcAttrs))
                pcAttrs++;
        }

        *pcR++ = NULL;


        // Should have Name string, script string, expires string, and view string
        DBG_WARN(CDebugLog::DBG_SEV4, A2T(pcURL));
        DBG_WARN(CDebugLog::DBG_SEV4, A2T(pcName));
        DBG_WARN(CDebugLog::DBG_SEV4, A2T(pcExpire));
        DBG_WARN(CDebugLog::DBG_SEV4, A2T(pcScript));
        DBG_WARN(CDebugLog::DBG_SEV4, A2T(pcTVELevel));
        DBG_WARN(CDebugLog::DBG_SEV4, A2T(pcRest));

        DWORD dwLen;
        m_spbsURL = pcURL; dwLen = m_spbsURL.Length();
        UrlUnescape(m_spbsURL, NULL, &dwLen, URL_UNESCAPE_INPLACE);

        if (NULL != *pcName) {
            m_spbsName = pcName; dwLen = m_spbsName.Length();
            UrlUnescape(m_spbsName, NULL, &dwLen, URL_UNESCAPE_INPLACE);
        }

        if (NULL != *pcScript) {
            m_spbsScript = pcScript; dwLen = m_spbsScript.Length();
            UrlUnescape(m_spbsScript, NULL, &dwLen, URL_UNESCAPE_INPLACE);
        }

        if (NULL != *pcRest) {
            m_spbsRest = pcRest; dwLen = m_spbsRest.Length();
            UrlUnescape(m_spbsRest, NULL, &dwLen, URL_UNESCAPE_INPLACE);
        }

        // Get Received Time
        DATE dateNow = 0;
        SYSTEMTIME SysTime;
        GetSystemTime(&SysTime);
        SystemTimeToVariantTime(&SysTime, &dateNow);

        // Verify Expires Time  
        m_dateExpires = 0;
        if (NULL != *pcExpire) 
        {
            m_dateExpires = ISOTimeToDate(pcExpire, /*fZuluTime*/ true);  // (by default, date expressed in UTC/ZULU time)
            if(0 == m_dateExpires)
            {
                DBG_WARN(CDebugLog::DBG_SEV2, _T("Expire Date is Zero"));
            }
        }

        if (0 == m_dateExpires) {
            m_dateExpires = kDateMax;	// If defaulting or error, set expire in the year 9999
            //#ifdef _DEBUG
            //		Error(GetTVEError(MSTVE_E_PASTDUEEXPIREDATE),IID_ITVETrigger);
            //		return MSTVE_E_PASTDUEEXPIREDATE;	
            //#endif
        }

        if (NULL != *pcTVELevel)
        {
            int iFields = sscanf(pcTVELevel,"%f",&m_rTVELevel);
            if(iFields != 1) {
                TVEDebugLog((CDebugLog::DBG_SEV2, 3, _T("Invalid TVE Level : %s"),pcTVELevel));
                Error(GetTVEError(MSTVE_E_INVALIDTVELEVEL), IID_ITVETrigger);
                return MSTVE_E_INVALIDTVELEVEL;
            }
        }


        if (m_dateExpires < dateNow)
        {
            TVEDebugLog((CDebugLog::DBG_SEV2,3,  _T("Expire time already past")));
            Error(GetTVEError(MSTVE_E_PASTDUEEXPIREDATE),IID_ITVETrigger);
            return MSTVE_E_PASTDUEEXPIREDATE;
        }

        m_dateExecutes = dateNow;					//TODO - make work better

        /*
        DWORD dwTriggerFlags = NULL;
        if (DATA_CC_BASED == (DATA_CC_BASED & dwFlags))
        {
        if (NULL == *pcTVELevel)	// ATVEF Crossover links
        {
        CComBSTR bstrEmpty = "";
        return CrossoverLink(bstrURL, bstrEmpty, bstrName, bstrEmpty, pbHandled);
        }

        if ((0 != strcmp(pcTVELevel, "1")) && (0 != strcmp(pcTVELevel, "1.0")))
        return E_INVALIDARG;

        dwTriggerFlags = DATA_CC_BASED;
        }
        else if (NULL != *pcTVELevel)
        {
        if ((0 != strcmp(pcTVELevel, "1")) && (0 != strcmp(pcTVELevel, "1.0")))
        return E_INVALIDARG;
        }

        if ((NULL == m_pNav.p) ||(FALSE != *pbHandled))
        return E_UNEXPECTED;

        DBG_WARN(CDebugLog::DBG_SEV4, W2A(m_bstrIntent));
        if (0 == strcmp(W2A(m_bstrIntent), "FULL_SCREEN_VIDEO"))
        {
        DBG_WARN(CDebugLog::DBG_SEV4, "Setting PRIMARY bit");
        dwTriggerFlags |= DATA_PRIMARY;
        }

        */
        m_fInit = true;				// we have filled the data structures
        m_fIsValid = true;			// -- wrong... Need to verify this
        return S_OK;
    }
    catch(...){
        return E_UNEXPECTED;
    }
}

STDMETHODIMP 
CTVETrigger::UpdateFrom(ITVETrigger *trigNew, long *plgrfTRKChanged)
{
	DBG_HEADER(CDebugLog::DBG_TRIGGER, _T("CTVETrigger::UpdateFrom"));

	CComBSTR spbsURL, spbsPName,spbsPScript,spbsPRest;
	DATE datePExpires;
	float rTVELevel;

	CSmartLock spLock(&m_sLk);

	trigNew->get_URL(&spbsURL);
	trigNew->get_Name(&spbsPName);			// humm, should really lock trigNew on all fields...
	trigNew->get_Script(&spbsPScript);
	trigNew->get_Rest(&spbsPRest);
	trigNew->get_Expires(&datePExpires);
	HRESULT hrLevelExists = trigNew->get_TVELevel(&rTVELevel);

	long lgrfNTRK = 0;						// caution CComBSTR doesn't support != operator

	if(!(m_spbsURL == spbsURL))			// this should never happen - a new trigger is created instead.  Be safe.
	{
		m_spbsURL = spbsURL;			lgrfNTRK |= (long) NTRK_grfURL; 
	}

	if(!(m_spbsName == spbsPName))		
	{
		if(spbsPName.Length() > 0)			// ATVEF Spec - don't overwrite NULL names...
		{
			m_spbsName = spbsPName;			lgrfNTRK |= (long) NTRK_grfName; 
		}
	}
	if(!(m_spbsScript == spbsPScript))	
	{		
// BUG 264141  was
//	    if(m_spbsScript.Length() > 0 && spbsPScript.Length() > 0)	// avoid NULL string vs. "" being declared as != 
//		if(spbsPScript.Length() > 0)	// avoid NULL string vs. "" being declared as != 
		{
			m_spbsScript = spbsPScript;			lgrfNTRK |= (long) NTRK_grfScript; 
		}
	}

	if(!(m_spbsRest == spbsPRest))
	{		
//  also BUG 26414
		if(m_spbsRest.Length() > 0 && spbsPRest.Length() > 0)
		if(spbsPRest.Length() > 0)
		{
			m_spbsRest = spbsPRest;				lgrfNTRK |= (long) NTRK_grfRest; 
		}
	}

	if(ABS(m_dateExpires - datePExpires) > 5.0 / (24.0 * 60.0 * 60))				// 5 seconds
	{		
		m_dateExpires = datePExpires;		lgrfNTRK |= (long) NTRK_grfDate; 
	}

	if((S_OK == hrLevelExists) && !m_fTVELevelPresent &&
		!(m_rTVELevel == rTVELevel))
	{
		m_rTVELevel = rTVELevel;			lgrfNTRK |= (long) NTRK_grfTVELevel; 
	}


	if(plgrfTRKChanged)
		*plgrfTRKChanged = lgrfNTRK;
	
	return S_OK;
}
/*

STDMETHODIMP CEnhCtrl::ATVEFData(BSTR bstrData,
				 BSTR bstrNetCard,
				 BOOL bHasChkSum,
				 DWORD dwFlags,
				 BOOL* pbHandled)
{
    DBG_HEADER(CDebugLog::DBG_ENHCTRL, "CEnhCtrl::ATVEFData");
    USES_CONVERSION;

    // Parse the Data 
    int iLen = sizeof(char) * (strlen(W2A(bstrData)) + 1);
    char* pcData = NULL; pcData = W2A(bstrData);

#ifdef _DEBUG
    if (iLen < 256)
#endif
    LOG_EVAL(pcData);

    if ('<' != *pcData)
	return E_INVALIDARG;

    if ((FALSE != bHasChkSum) && 
	(FALSE == ValidateAndRemoveChkSum(pcData)))
    {
	DBG_WARN_ID(CDebugLog::DBG_SEV2, IDS_INVALIDCHKSUM);
	return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    char* pcURL = NULL; pcURL = (char*) _alloca(iLen);
    char* pcAttrs = NULL; pcAttrs = (char*) _alloca(iLen);

    if (0 == sscanf(pcData, "<%[^>]> %[^\0]", pcURL, pcAttrs))
    {
	DBG_WARN_ID(CDebugLog::DBG_SEV2, IDS_DATAPARSE);
	return E_INVALIDARG;
    }

    char* pcName = NULL; pcName = (char*) _alloca(iLen); *pcName = NULL;
    char* pcExpire = NULL; pcExpire = (char*) _alloca(iLen); *pcExpire = NULL;
    char* pcScript = NULL; pcScript = (char*) _alloca(iLen); *pcScript = NULL;
    char* pcTVELevel = NULL; pcTVELevel = (char*) _alloca(iLen); *pcTVELevel = NULL;

    while (NULL != *pcAttrs)
    {
	pcAttrs++;	// Skip leading [
	switch (*pcAttrs)
	{
	case 'n':
	case 'N':
	    {
		if ((':' == pcAttrs[1]) || (0 == _strnicmp(pcAttrs, "name:", 5)))
		{
		    if (0 == sscanf(pcAttrs, "%*[^:]:%[^]]", pcName))
			return E_INVALIDARG;
		}
	    }
	    break;
	case 'e':
	case 'E':
	    {
		if ((':' == pcAttrs[1]) || (0 == _strnicmp(pcAttrs, "expires:", 8)))
		{
		    if (0 == sscanf(pcAttrs, "%*[^:]:%[^]]", pcExpire))
			return E_INVALIDARG;
		}
	    }
	    break;
	case 's':
	case 'S':
	    {
		if ((':' == pcAttrs[1]) || (0 == _strnicmp(pcAttrs, "script:", 7)))
		{
		    if (0 == sscanf(pcAttrs, "%*[^:]:%[^]]", pcScript))
			return E_INVALIDARG;
		}
	    }
	    break;
	case 'v':
	case 'V':
	    {
		if (0 == _strnicmp(pcAttrs, "v:", 2))
		{
		    if (0 == sscanf(pcAttrs, "%*[^:]:%[^]]", pcTVELevel))
			return E_INVALIDARG;
		}
	    }
	    break;
	case 't':
	case 'T':
	    {
		if (0 == _strnicmp(pcAttrs, "tve:", 4))
		{
		    if (0 == sscanf(pcAttrs, "%*[^:]:%[^]]", pcTVELevel))
			return E_INVALIDARG;
		}
	    }
	    break;
	}
	while ((NULL != *pcAttrs) && ('[' != *pcAttrs))
	    pcAttrs++;
    }

    // Should have Name string, script string, expires string, and view string
    DBG_WARN(CDebugLog::DBG_SEV4, pcURL);
    DBG_WARN(CDebugLog::DBG_SEV4, pcName);
    DBG_WARN(CDebugLog::DBG_SEV4, pcExpire);
    DBG_WARN(CDebugLog::DBG_SEV4, pcScript);

    CComBSTR bstrURL = pcURL;	// Required Field
    bstrURL = ReplaceEscapeSequences(bstrURL);

    CComBSTR bstrName;
    if (NULL != *pcName)
    {
	bstrName = pcName;
	bstrName = ReplaceEscapeSequences(bstrName);
    }
    
    CComBSTR bstrScript;
    if (NULL != *pcScript)
    {
	bstrScript = pcScript;
	bstrScript = ReplaceEscapeSequences(bstrScript);
    }

    // Get Received Time
    DATE dateNow = 0;
    SYSTEMTIME SysTime;
    GetSystemTime(&SysTime);
    SystemTimeToVariantTime(&SysTime, &dateNow);

    // Verify Expires Time
    DATE dateExpires = 0;
    if (NULL != *pcExpire)
    {

	// Determine actual dateExpires from bstrExpires
	memset(&SysTime, 0, sizeof(SYSTEMTIME));

	char strValue[5]; int iValue;
	int iLen = strlen(pcExpire);
	switch(iLen)
	{
	case 15:
	    // Seconds
	    strValue[0] = pcExpire[13];
	    strValue[1] = pcExpire[14];
	    strValue[2] = 0;
	    sscanf(strValue, "%i", &iValue);
	    SysTime.wSecond = iValue;
	case 13:
	    // Minutes
	    strValue[0] = pcExpire[11];
	    strValue[1] = pcExpire[12];
	    strValue[2] = 0;
	    sscanf(strValue, "%i", &iValue);
	    SysTime.wMinute = iValue;
	case 11:
	    // Hours
	    strValue[0] = pcExpire[9];
	    strValue[1] = pcExpire[10];
	    strValue[2] = 0;
	    sscanf(strValue, "%i", &iValue);
	    SysTime.wHour = iValue;
	case 8:
	    // Year
	    strValue[0] = pcExpire[0];
	    strValue[1] = pcExpire[1];
	    strValue[2] = pcExpire[2];
	    strValue[3] = pcExpire[3];
	    strValue[4] = 0;
	    sscanf(strValue, "%i", &iValue);
	    SysTime.wYear = iValue;
	    
	    // Month
	    strValue[0] = pcExpire[4];
	    strValue[1] = pcExpire[5];
	    strValue[2] = 0;
	    sscanf(strValue, "%i", &iValue);
	    SysTime.wMonth = iValue;

	    // Day
	    strValue[0] = pcExpire[6];
	    strValue[1] = pcExpire[7];
	    strValue[2] = 0;
	    sscanf(strValue, "%i", &iValue);
	    SysTime.wDay = iValue;
	    break;
	default:
	    return E_INVALIDARG;
	}

	SystemTimeToVariantTime(&SysTime, &dateExpires);
    }
    if (0 == dateExpires)
	dateExpires = dateNow + (1.0 / 48.0);	// Good for a half hour
    if (dateExpires < dateNow)
	return E_UNEXPECTED;

    DWORD dwTriggerFlags = NULL;
    if (DATA_CC_BASED == (DATA_CC_BASED & dwFlags))
    {
	if (NULL == *pcTVELevel)	// ATVEF Crossover links
	{
	    CComBSTR bstrEmpty = "";
	    return CrossoverLink(bstrURL, bstrEmpty, bstrName, bstrEmpty, pbHandled);
	}

	if ((0 != strcmp(pcTVELevel, "1")) && (0 != strcmp(pcTVELevel, "1.0")))
	    return E_INVALIDARG;

	dwTriggerFlags = DATA_CC_BASED;
    }
    else if (NULL != *pcTVELevel)
    {
	if ((0 != strcmp(pcTVELevel, "1")) && (0 != strcmp(pcTVELevel, "1.0")))
	    return E_INVALIDARG;
    }

    if ((NULL == m_pNav.p) ||
	(FALSE != *pbHandled))
	return E_UNEXPECTED;

    DBG_WARN(CDebugLog::DBG_SEV4, W2A(m_bstrIntent));
    if (0 == strcmp(W2A(m_bstrIntent), "FULL_SCREEN_VIDEO"))
    {
	DBG_WARN(CDebugLog::DBG_SEV4, "Setting PRIMARY bit");
	dwTriggerFlags |= DATA_PRIMARY;
    }

    return m_pNav->ATVEFTrigger(bstrURL, bstrName, dateExpires, bstrScript, dwTriggerFlags, pbHandled);
}

*/

void
VariantTimeToBstr(DATE pDate, BSTR bstrBuff)
{
	SYSTEMTIME SysTime;
	VariantTimeToSystemTime(pDate, &SysTime);		// not done!
//	time_t t;
//	sprintf(pBuff, "
}

STDMETHODIMP 
CTVETrigger::DumpToBSTR(BSTR *pBstrBuff)
{
	const int kMaxChars = 2408;
	TCHAR tBuff[kMaxChars];
	int iLen;
	CComBSTR bstrOut;
	bstrOut.Empty();

	_stprintf(tBuff,_T("Trigger\n"));
	bstrOut.Append(tBuff);

	if(!m_fInit) {
		_stprintf(tBuff,_T("Uninitialized Trigger\n"));
		bstrOut.Append(tBuff);
		bstrOut.CopyTo(pBstrBuff);
		return E_INVALIDARG;
	}

	CSmartLock spLock(&m_sLk);
	
	iLen = m_spbsName.Length()+12;
	if(iLen < kMaxChars) {
		_stprintf(tBuff, _T("Name    : %s\n"),m_spbsName);
		bstrOut.Append(tBuff);
	}

	iLen = m_spbsURL.Length()+12;
	if(iLen < kMaxChars) {
		_stprintf(tBuff, _T("URL     : %s\n"),m_spbsURL);
		bstrOut.Append(tBuff);
	}


	iLen = m_spbsRest.Length()+12;
	if(iLen < kMaxChars) {
		_stprintf(tBuff, _T("Rest    : %s\n"),m_spbsRest);
		bstrOut.Append(tBuff);
	}

	iLen = 32;
	if(iLen < kMaxChars) { 
		_stprintf(tBuff, _T("Executes: %s (%s)\n"),DateToBSTR(m_dateExecutes), DateToDiffBSTR(m_dateExecutes));
		bstrOut.Append(tBuff);
	}
	iLen = 32;
	if(iLen < kMaxChars) { 
		_stprintf(tBuff, _T("Expires : %s (%s)\n"),DateToBSTR(m_dateExpires), DateToDiffBSTR(m_dateExpires));
		bstrOut.Append(tBuff);
	}
	
	iLen = m_spbsScript.Length()+12;;
	if(iLen < kMaxChars) {
		_stprintf(tBuff, _T("Script  : %s\n"),m_spbsScript);
		bstrOut.Append(tBuff);
	}

	bstrOut.CopyTo(pBstrBuff);
 
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tveunpak.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEDecomUnpak.h

#ifndef __TVEDECOMUNPAK_H_
#define __TVEDECOMUNPAK_H_

HRESULT UnpackBuffer(IUnknown *pVariation, LPBYTE pBuffer, ULONG ulSize);

#endif //__TVEDECOMUNPAK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvetrigg.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVETrigger.h : Declaration of the CTVETrigger
//


#ifndef __TVETRIGGER_H_
#define __TVETRIGGER_H_

#include "resource.h"       // main symbols
#include "TveSmartLock.h"

/////////////////////////////////////////////////////////////////////////////
// CTVETrigger
class ATL_NO_VTABLE CTVETrigger : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTVETrigger, &CLSID_TVETrigger>,
	public ITVETrigger_Helper,
	public ISupportErrorInfo,
	public IDispatchImpl<ITVETrigger, &IID_ITVETrigger, &LIBID_MSTvELib>
{
public:
	CTVETrigger()
	{
		m_fInit = false;
		m_fIsValid = false;
		m_fTVELevelPresent = false;
		m_rTVELevel = 0.0f;
		m_pTrack = NULL;
	}

	~CTVETrigger()
	{
		m_pTrack = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVETRIGGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVETrigger)
	COM_INTERFACE_ENTRY(ITVETrigger)
	COM_INTERFACE_ENTRY(ITVETrigger_Helper)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	HRESULT FinalConstruct()								// create internal objects
	{
		HRESULT hr = S_OK;
		return hr;
	}

	HRESULT FinalRelease();

// ITVETrigger
public:
	STDMETHOD(get_Parent)(/*[out, retval]*/ IUnknown* *pVal);			// may return NULL!
	STDMETHOD(get_Service)(/*[out, retval]*/ ITVEService* *pVal);			// may return NULL!

	STDMETHOD(get_TVELevel)(/*[out, retval]*/ float *pVal);		// returns S_FALSE if not present.. (required in TransportA)
	STDMETHOD(get_Rest)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Script)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Executes)(/*[out, retval]*/ DATE *pVal);
	STDMETHOD(get_Expires)(/*[out, retval]*/ DATE *pVal);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_URL)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_IsValid)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(ParseTrigger)(/*[in]*/ const BSTR bstrVal);

// ITVETrigger_Helper
public:
	STDMETHOD(ConnectParent)(/*[in]*/ ITVETrack *pTrack);
	STDMETHOD(UpdateFrom)(/*[in*]*/ ITVETrigger *pTrigger, /*out*/ long *plgrfChanged);
	STDMETHOD(get_CRC)(/*[in]*/ const BSTR bstrVal, /*[out, retval]*/ BSTR *pbstrCRC);		// gets correct CRC of current string
	STDMETHOD(RemoveYourself)();
	STDMETHOD(DumpToBSTR)(/*[in]*/ BSTR *pbstrBuff);

private:
	CTVESmartLock		m_sLk;
 
private:
	BOOL		m_fInit;
	BOOL		m_fIsValid;
	BOOL		m_fTVELevelPresent;

	CComBSTR	m_spbsURL;			// intro ATL, Chap 5, pg 20.
	CComBSTR	m_spbsName;
	DATE		m_dateExpires;
	DATE		m_dateExecutes;
	CComBSTR	m_spbsScript;
	CComBSTR	m_spbsRest;
	ITVETrack	*m_pTrack;		// non reference counted back pointer
	FLOAT		m_rTVELevel;


};

#endif //__TVETRIGGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\zconf.h ===
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-1996 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* $Id: zconf.h,v 1.20 1996/07/02 15:09:28 me Exp $ */

#ifndef _ZCONF_H
#define _ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_	z_deflateInit_
#  define deflate	z_deflate
#  define deflateEnd	z_deflateEnd
#  define inflateInit_ 	z_inflateInit_
#  define inflate	z_inflate
#  define inflateEnd	z_inflateEnd
#  define deflateInit2_	z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy	z_deflateCopy
#  define deflateReset	z_deflateReset
#  define deflateParams	z_deflateParams
#  define inflateInit2_	z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync	z_inflateSync
#  define inflateReset	z_inflateReset
#  define compress	z_compress
#  define uncompress	z_uncompress
#  define adler32	z_adler32
#  define crc32		z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte		z_Byte
#  define uInt		z_uInt
#  define uLong		z_uLong
#  define Bytef	        z_Bytef
#  define charf		z_charf
#  define intf		z_intf
#  define uIntf		z_uIntf
#  define uLongf	z_uLongf
#  define voidpf	z_voidpf
#  define voidp		z_voidp
#endif

#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
#  ifndef __32BIT__
#    define __32BIT__
#  endif
#endif
#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#if defined(MSDOS) && !defined(__32BIT__)
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
#  define STDC
#endif
#if (defined(__STDC__) || defined(__cplusplus)) && !defined(STDC)
#  define STDC
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            1 << (windowBits+2)   +  1 << (memLevel+9)
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
   /* MSC small or medium model */
#  define SMALL_MEDIUM
#  ifdef _MSC_VER
#    define FAR __far
#  else
#    define FAR far
#  endif
#endif
#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
#  ifndef __32BIT__
#    define SMALL_MEDIUM
#    define FAR __far
#  endif
#endif
#ifndef FAR
#   define FAR
#endif

typedef unsigned char  Byte;  /* 8 bits */
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#if defined(__BORLANDC__) && defined(SMALL_MEDIUM)
   /* Borland C/C++ ignores FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void FAR *voidpf;
   typedef void     *voidp;
#else
   typedef Byte FAR *voidpf;
   typedef Byte     *voidp;
#endif


/* Compile with -DZLIB_DLL for Windows DLL support */
#if (defined(_WINDOWS) || defined(WINDOWS)) && defined(ZLIB_DLL)
#  include <windows.h>
#  define EXPORT  WINAPI
#else
#  define EXPORT
#endif

#endif /* _ZCONF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvevaria.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEVariation.h : Declaration of the CTVEVariation

#ifndef __TVEVARIATION_H_
#define __TVEVARIATION_H_

#include "resource.h"       // main symbols

#include "TVEAttrM.h"
#include "TVETracks.h"
#include "TveSmartLock.h"

_COM_SMARTPTR_TYPEDEF(ITVEAttrMap,		__uuidof(ITVEAttrMap));
_COM_SMARTPTR_TYPEDEF(ITVETrack,		__uuidof(ITVETrack));
_COM_SMARTPTR_TYPEDEF(ITVETrack_Helper, __uuidof(ITVETrack_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETracks,		__uuidof(ITVETracks));

/////////////////////////////////////////////////////////////////////////////
// CTVEVariation
class ATL_NO_VTABLE CTVEVariation : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CTVEVariation, &CLSID_TVEVariation>,
	public ITVEVariation_Helper,
	public ISupportErrorInfo,
	public IDispatchImpl<ITVEVariation, &IID_ITVEVariation, &LIBID_MSTvELib>
{
friend class CTVEEnhancement;
public:
	CTVEVariation()
	{
		m_pEnhancement	= NULL;
		m_fIsValid		= false;
		m_dwFilePort	= 0;
		m_dwTriggerPort = 0;
		m_ulBandwidth	= 0;
		m_fFileMedia	= false;
		m_fTriggerMedia	= false;
	}

	HRESULT FinalConstruct()								// create internal objects
	{
		HRESULT hr;
		hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_spUnkMarshaler.p);
		if(FAILED(hr)) {
			_ASSERT(FALSE);
			return hr;
		}

		CComObject<CTVETracks> *pTracks;
		hr = CComObject<CTVETracks>::CreateInstance(&pTracks);
		if(FAILED(hr))
			return hr;
		hr = pTracks->QueryInterface(&m_spTracks);			// typesafe QI
		if(FAILED(hr)) {
			delete pTracks;
			return hr;
		}

		/*										// 	this way doesn't work - CoClass on Tracks
		m_spTracks = ITVETracksPtr(CLSID_TVETracks);
		if(!m_spTracks) return E_OUTOFMEMORY;
		*/

		CComObject<CTVEAttrMap> *pMap;
		hr = CComObject<CTVEAttrMap>::CreateInstance(&pMap);
		if(FAILED(hr))
			return hr;
		hr = pMap->QueryInterface(&m_spamAttributes);			// typesafe QI
		if(FAILED(hr)) {
			delete pMap;
			return hr;
		}

		CComObject<CTVEAttrMap> *pMap2;
		hr = CComObject<CTVEAttrMap>::CreateInstance(&pMap2);
		if(FAILED(hr))
			return hr;
		hr = pMap2->QueryInterface(&m_spamLanguages);			// typesafe QI
		if(FAILED(hr)) {
			delete pMap2;
			return hr;
		}

		CComObject<CTVEAttrMap> *pMap3;
		hr = CComObject<CTVEAttrMap>::CreateInstance(&pMap3);
		if(FAILED(hr))
			return hr;
		hr = pMap3->QueryInterface(&m_spamSDPLanguages);			// typesafe QI
		if(FAILED(hr)) {
			delete pMap3;
			return hr;
		}

		CComObject<CTVEAttrMap> *pMap4;
		hr = CComObject<CTVEAttrMap>::CreateInstance(&pMap4);
		if(FAILED(hr))
			return hr;
		hr = pMap4->QueryInterface(&m_spamRest);			// typesafe QI
		if(FAILED(hr)) {
			delete pMap4;
			return hr;
		}
						// can't do it this way.  Doesn't work in multi-threaded creation
/*		ITVEAttrMapPtr spAttrMap = ITVEAttrMapPtr(CLSID_TVEAttrMap);
		if(NULL == spAttrMap) {
			m_spamAttributes = NULL;	
			return E_OUTOFMEMORY;
		} else {		
			m_spamAttributes = spAttrMap;
		}


		ITVEAttrMapPtr spAttrMap2 = ITVEAttrMapPtr(CLSID_TVEAttrMap);
		if(NULL == spAttrMap2) {
			m_spamLanguages = NULL;	
			return E_OUTOFMEMORY;
		} else {		
			m_spamLanguages = spAttrMap2;
		}
*/		
		return hr;
	}

	HRESULT FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_TVEVARIATION)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVEVariation)
	COM_INTERFACE_ENTRY(ITVEVariation)
	COM_INTERFACE_ENTRY(ITVEVariation_Helper)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	CComPtr<IUnknown> m_spUnkMarshaler;
// ITVEVariation
public:
	STDMETHOD(get_Parent)(/*[out, retval]*/ IUnknown* *ppVal);				// may return NULL!
	STDMETHOD(get_Service)(/*[out, retval]*/ ITVEService* *pVal);			// may return NULL!
	STDMETHOD(get_Tracks)(/*[out, retval]*/ ITVETracks* *ppVal);
	
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Description)(/*[in]*/ BSTR newVal);

	STDMETHOD(get_IsValid)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_MediaName)(/*[out, retval]*/ BSTR *newVal);
	STDMETHOD(get_MediaTitle)(/*[out, retval]*/ BSTR *newVal);
	STDMETHOD(get_FilePort)(/*[out, retval]*/ LONG *plPort);
	STDMETHOD(get_FileIPAddress)(/*[out, retval]*/ BSTR *newVal);
	STDMETHOD(get_FileIPAdapter)(/*[out, retval]*/ BSTR *newVal);
	STDMETHOD(get_TriggerPort)(/*[out, retval]*/ LONG *plPort);
	STDMETHOD(get_TriggerIPAddress)(/*[out, retval]*/ BSTR *newVal);
	STDMETHOD(get_TriggerIPAdapter)(/*[out, retval]*/ BSTR *newVal);
	STDMETHOD(get_Languages)(/*[out, retval]*/ ITVEAttrMap* *ppVal);
	STDMETHOD(get_SDPLanguages)(/*[out, retval]*/ ITVEAttrMap* *ppVal);
	STDMETHOD(get_Bandwidth)(/*[out, retval]*/ LONG *plVal);
	STDMETHOD(get_BandwidthInfo)(/*[out, retval]*/ BSTR *pbsVal);

	STDMETHOD(get_Attributes)(/*[out, retval]*/ ITVEAttrMap* *ppVal);
	STDMETHOD(get_Rest)(/*[out, retval]*/ ITVEAttrMap* *ppVal);

// ITVEVariation_Helper
public:
	STDMETHOD(UpdateVariation)(ITVEVariation *pVarNew, LONG *plgrfChanged);
	STDMETHOD(ParseCBTrigger)(BSTR bstrTrig);
	STDMETHOD(Initialize)(/*[in]*/ BSTR newVal);
	STDMETHOD(DefaultTo)(ITVEVariation *pVariationBase);
	STDMETHOD(DumpToBSTR)(BSTR *pbstrBuff);
	STDMETHOD(ConnectParent)(ITVEEnhancement *pEnhancement);
	STDMETHOD(SetFileIPAdapter)(BSTR bstrAdapter);
	STDMETHOD(SetTriggerIPAdapter)(BSTR bstrAdapter);
	STDMETHOD(SubParseSDP)(const BSTR *pbstrSDP, BOOL *pfMissingMedia);
	STDMETHOD(FinalParseSDP)();

	STDMETHOD(InitAsXOver)();
	STDMETHOD(NewXOverLink)(/*[in]*/ BSTR bstrLine21Trigger);
	STDMETHOD(RemoveYourself)();

	STDMETHOD(put_MediaTitle)(/*[in]*/ BSTR newVal);
	STDMETHOD(put_IsValid)(/*[in]*/  VARIANT_BOOL fVal);

private:
	HRESULT ParseMedia(const wchar_t *wszArg,  BOOL *pfFileMedia, BOOL *pfTriggerMedia);
	HRESULT ParseConnection(const wchar_t *wszArg, BOOL fFileMedia, BOOL fTriggerMedia);
	HRESULT ParseBandwidth(const wchar_t *wszArg);

private:
	CTVESmartLock		m_sLk;

private:
	ITVEEnhancement			*m_pEnhancement;		// up tree pointer, no addref
	ITVETracksPtr			m_spTracks;				// down tree pointer


	BOOL					m_fFileMedia;				// used between 'm' and 'c' parsers
	BOOL					m_fTriggerMedia;

	CComBSTR				m_spbsDescription;
	BOOL					m_fIsValid;
	CComBSTR				m_spbsMediaName;
	CComBSTR				m_spbsMediaTitle;
	DWORD					m_dwFilePort;
	CComBSTR				m_spbsFileIPAddress;
	CComBSTR				m_spbsFileIPAdapter;
	DWORD					m_dwTriggerPort;
	CComBSTR				m_spbsTriggerIPAddress;
	CComBSTR				m_spbsTriggerIPAdapter;
	ITVEAttrMapPtr			m_spamLanguages;
	ITVEAttrMapPtr			m_spamSDPLanguages;
	ULONG					m_ulBandwidth;
	CComBSTR				m_spbsBandwidthInfo;

	ITVEAttrMapPtr			m_spamAttributes;	// a: parameters
	ITVEAttrMapPtr			m_spamRest;
};

#endif //__TVEVARIATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\zutil.c ===
/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-1996 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* $Id: zutil.c,v 1.17 1996/07/24 13:41:12 me Exp $ */

#include <stdio.h>

#include "zutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

struct internal_state      {int dummy;}; /* for buggy compilers */

#ifndef STDC
extern void exit OF((int));
#endif

const char *z_errmsg[10] = {
"need dictionary",     /* Z_NEED_DICT       2  */
"stream end",          /* Z_STREAM_END      1  */
"",                    /* Z_OK              0  */
"file error",          /* Z_ERRNO         (-1) */
"stream error",        /* Z_STREAM_ERROR  (-2) */
"data error",          /* Z_DATA_ERROR    (-3) */
"insufficient memory", /* Z_MEM_ERROR     (-4) */
"buffer error",        /* Z_BUF_ERROR     (-5) */
"incompatible version",/* Z_VERSION_ERROR (-6) */
""};


const char *zlibVersion()
{
    return ZLIB_VERSION;
}

#ifdef DEBUG
void z_error (m)
    char *m;
{
    fprintf(stderr, "%s\n", m);
    exit(1);
}
#endif

#ifndef HAVE_MEMCPY

void zmemcpy(dest, source, len)
    Bytef* dest;
    Bytef* source;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = *source++; /* ??? to be unrolled */
    } while (--len != 0);
}

int zmemcmp(s1, s2, len)
    Bytef* s1;
    Bytef* s2;
    uInt  len;
{
    uInt j;

    for (j = 0; j < len; j++) {
        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
    }
    return 0;
}

void zmemzero(dest, len)
    Bytef* dest;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = 0;  /* ??? to be unrolled */
    } while (--len != 0);
}
#endif

#ifdef __TURBOC__
#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) && !defined(__32BIT__)
/* Small and medium model in Turbo C are for now limited to near allocation
 * with reduced MAX_WBITS and MAX_MEM_LEVEL
 */
#  define MY_ZCALLOC

/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */

#define MAX_PTR 10
/* 10*64K = 640K */

local int next_ptr = 0;

typedef struct ptr_table_s {
    voidpf org_ptr;
    voidpf new_ptr;
} ptr_table;

local ptr_table table[MAX_PTR];
/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    voidpf buf = opaque; /* just to make some compilers happy */
    ulg bsize = (ulg)items*size;

    /* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */
    if (bsize < 65520L) {
        buf = farmalloc(bsize);
        if (*(ush*)&buf != 0) return buf;
    } else {
        buf = farmalloc(bsize + 16L);
    }
    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
    table[next_ptr].org_ptr = buf;

    /* Normalize the pointer to seg:0 */
    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
    *(ush*)&buf = 0;
    table[next_ptr++].new_ptr = buf;
    return buf;
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    int n;
    if (*(ush*)&ptr != 0) { /* object < 64K */
        farfree(ptr);
        return;
    }
    /* Find the original pointer */
    for (n = 0; n < next_ptr; n++) {
        if (ptr != table[n].new_ptr) continue;

        farfree(table[n].org_ptr);
        while (++n < next_ptr) {
            table[n-1] = table[n];
        }
        next_ptr--;
        return;
    }
    ptr = opaque; /* just to make some compilers happy */
    Assert(0, "zcfree: ptr not found");
}
#endif
#endif /* __TURBOC__ */


#if defined(M_I86) && !defined(__32BIT__)
/* Microsoft C in 16-bit mode */

#  define MY_ZCALLOC

#if (!defined(_MSC_VER) || (_MSC_VER < 600))
#  define _halloc  halloc
#  define _hfree   hfree
#endif

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    return _halloc((long)items, size);
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    _hfree(ptr);
}

#endif /* MSC */


#ifndef MY_ZCALLOC /* Any system without a special alloc function */

#ifndef STDC
extern voidp  calloc OF((uInt items, uInt size));
extern void   free   OF((voidpf ptr));
#endif

voidpf zcalloc (opaque, items, size)
    voidpf opaque;
    unsigned items;
    unsigned size;
{
    if (opaque) items += size - size; /* make compiler happy */
    return (voidpf)calloc(items, size);
}

void  zcfree (opaque, ptr)
    voidpf opaque;
    voidpf ptr;
{
    free(ptr);
    if (opaque) return; /* make compiler happy */
}

#endif /* MY_ZCALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\zutil.h ===
/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-1996 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* $Id: zutil.h,v 1.16 1996/07/24 13:41:13 me Exp $ */

#ifndef _Z_UTIL_H
#define _Z_UTIL_H

#include "zlib.h"

#if defined(MSDOS)||defined(VMS)||defined(CRAY)||defined(WIN32)||defined(RISCOS)
#   include <stddef.h>
#   include <errno.h>
#else
    extern int errno;
#endif
#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#endif

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = (char*)ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

        /* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

        /* target dependencies */

#ifdef MSDOS
#  define OS_CODE  0x00
#  ifdef __TURBOC__
#    include <alloc.h>
#  else /* MSC or DJGPP */
#    include <malloc.h>
#  endif
#endif

#ifdef OS2
#  define OS_CODE  0x06
#endif

#ifdef WIN32 /* Window 95 & Windows NT */
#  define OS_CODE  0x0b
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#  define FOPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#ifdef AMIGA
#  define OS_CODE  0x01
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif

#ifdef MACOS
#  define OS_CODE  0x07
#endif

#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0F
#endif

#ifdef TOPS20
#  define OS_CODE  0x0a
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

        /* Common defaults */

#ifndef OS_CODE
#  define OS_CODE  0x03  /* assume Unix */
#endif

#ifndef FOPEN
#  define FOPEN(name, mode) fopen((name), (mode))
#endif

         /* functions */

#ifdef HAVE_STRERROR
   extern char *strerror OF((int));
#  define zstrerror(errnum) strerror(errnum)
#else
#  define zstrerror(errnum) ""
#endif

#if defined(pyr)
#  define NO_MEMCPY
#endif
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(_MSC_VER)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
   extern void zmemcpy  OF((Bytef* dest, Bytef* source, uInt len));
   extern int  zmemcmp  OF((Bytef* s1,   Bytef* s2, uInt len));
   extern void zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#ifdef DEBUG
#  include <stdio.h>
#  ifndef verbose
#    define verbose 0
#  endif
   extern void z_error    OF((char *m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) fprintf x
#  define Tracev(x) {if (verbose) fprintf x ;}
#  define Tracevv(x) {if (verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif


typedef uLong (*check_func) OF((uLong check, const Bytef *buf, uInt len));

voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
void   zcfree  OF((voidpf opaque, voidpf ptr));

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

#endif /* _Z_UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvevaria.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEVariation.cpp : Implementation of CTVEVariation
#include "stdafx.h"
#include "MSTvE.h"

#include "TVEEnhan.h"
#include "TVEVaria.h"
#include "TVETrack.h"
#include "TVETrigg.h"


#include "TveDbg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

_COM_SMARTPTR_TYPEDEF(ITVEMCastManager,			__uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCast,				__uuidof(ITVEMCast));

_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,		__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement_Helper,	__uuidof(ITVEEnhancement_Helper));

_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEVariation_Helper,		__uuidof(ITVEVariation_Helper));

_COM_SMARTPTR_TYPEDEF(ITVETrack,				__uuidof(ITVETrack));
_COM_SMARTPTR_TYPEDEF(ITVETrack_Helper,			__uuidof(ITVETrack_Helper));
_COM_SMARTPTR_TYPEDEF(ITVETrigger,				__uuidof(ITVETrigger));
_COM_SMARTPTR_TYPEDEF(ITVETrigger_Helper,		__uuidof(ITVETrigger_Helper));

_COM_SMARTPTR_TYPEDEF(ITVEAttrTimeQ,			__uuidof(ITVEAttrTimeQ));

_COM_SMARTPTR_TYPEDEF(ITVECBFile,				__uuidof(ITVECBFile));
_COM_SMARTPTR_TYPEDEF(ITVECBTrig,				__uuidof(ITVECBTrig));
_COM_SMARTPTR_TYPEDEF(ITVECBDummy,				__uuidof(ITVECBDummy));

#define ABS(x) (((x)>0)?(x):(-x))
/////////////////////////////////////////////////////////////////////////////
// CTVEVariation_Helper


HRESULT 
CTVEVariation::FinalRelease()								// remove internal objects
{
														
	HRESULT hr;
	
														// NULL out all of children's up pointers to me..	
	if(m_spTracks) {
		long cTracks;
		hr = m_spTracks->get_Count(&cTracks);
		if(hr == S_OK) 
		{
			for(long i = 0; i < cTracks; i++)
			{
				CComVariant var(i);
				ITVETrackPtr spTrack;
				hr = m_spTracks->get_Item(var, &spTrack);
				_ASSERT(S_OK == hr);
				CComQIPtr<ITVETrack_Helper> spTrackHelper = spTrack;

				spTrackHelper->ConnectParent(NULL);
			}
		}
	}

	m_spTracks = NULL;				// calls release
	m_pEnhancement = NULL;			// null out up pointer
	m_spamAttributes = NULL;
	m_spamRest = NULL;

	m_spUnkMarshaler = NULL;
	return S_OK;
}


STDMETHODIMP CTVEVariation::ConnectParent(ITVEEnhancement *pEnhancement)
{
	if(!pEnhancement) return E_POINTER;
	CSmartLock spLock(&m_sLk);
	m_pEnhancement = pEnhancement;			// not smart pointer add ref here, I hope.
	return S_OK;
}

STDMETHODIMP CTVEVariation::RemoveYourself()
{
	CSmartLock spLock(&m_sLk);
	DBG_HEADER(CDebugLog::DBG_VARIATION, _T("CTVEVariation::RemoveYourself"));

	HRESULT hr;

	if(!m_pEnhancement)						// no up-pointer left.
	{
		return S_OK;
	}
		

	ITVEServicePtr spServi;
	get_Service(&spServi);
	if(spServi) {
		IUnknownPtr spUnkSuper;
		hr = spServi->get_Parent(&spUnkSuper);
		if(S_OK == hr) {
											// for lack of anything else, send an AuxInfo event up...

            CComBSTR spbsBuff;
            spbsBuff.LoadString(IDS_AuxInfo_DeletingVariation);	// L"Deleting Variation"

			ITVESupervisor_HelperPtr spSuperHelper(spUnkSuper);
			spSuperHelper->NotifyAuxInfo(NWHAT_Other,spbsBuff,0,0);


											// remove the MCasts object that are writing to this Variation
			ITVEMCastManagerPtr spManager;
			hr = spSuperHelper->GetMCastManager(&spManager);

			ITVEMCastPtr spMCastFile;
			long cMatches;
			hr = spManager->FindMulticast(m_spbsFileIPAdapter, m_spbsFileIPAddress, m_dwFilePort, &spMCastFile, &cMatches);
			if(hr == S_OK)
			{
				_ASSERT(cMatches == 1);			// paranoia check...
				spManager->RemoveMulticast(spMCastFile);
			}

			ITVEMCastPtr spMCastTrigger;
			hr = spManager->FindMulticast(m_spbsTriggerIPAdapter, m_spbsTriggerIPAddress, m_dwTriggerPort, &spMCastTrigger, &cMatches);
			if(hr == S_OK)
			{
				spManager->RemoveMulticast(spMCastTrigger);
			}
		}
	}

	CComPtr<ITVEVariations> spVariations;
	hr = m_pEnhancement->get_Variations(&spVariations);	// remove the ref counted link down from it's parents
	if(S_OK == hr && spVariations)
	{

		ITVEVariationPtr	spVariationThis(this);
		IUnknownPtr			spPunkThis(spVariationThis);
		CComVariant			cvThis((IUnknown *) spPunkThis);

		if(spVariations)
			hr = spVariations->Remove(cvThis);	
	}

	m_pEnhancement = NULL;								// remove the non ref-counted up pointer

	return hr;

}
/////////////////////////////////////////////////////////////////////////////
// CTVEVariation

STDMETHODIMP CTVEVariation::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVEVariation,
		&IID_ITVEVariation_Helper
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CTVEVariation::get_Parent(IUnknown **pVal)
{
	// TODO: Add your implementation code here

	if (pVal == NULL)
		return E_POINTER;
		
    try {
		CSmartLock spLock(&m_sLk);
		if(m_pEnhancement) {
			IUnknownPtr spUnk(m_pEnhancement);
			spUnk->AddRef();
			*pVal = spUnk;
		} else {
			*pVal = NULL;
		}
    } catch(...) {
        return E_POINTER;
    }
	return S_OK;
}

STDMETHODIMP CTVEVariation::get_Service(ITVEService **ppVal )
{

 	CHECK_OUT_PARAM(ppVal);

	if(NULL == m_pEnhancement)
	{
		*ppVal = NULL;
		return S_OK;
	}

	return m_pEnhancement->get_Service(ppVal);
}

STDMETHODIMP CTVEVariation::get_Tracks(ITVETracks **ppVal)
{
	HRESULT hr;
	CHECK_OUT_PARAM(ppVal);

	if(NULL == ppVal)
		return E_POINTER;

    try {
		CSmartLock spLock(&m_sLk);
        hr = m_spTracks->QueryInterface(ppVal);
    } catch(...) {
		*ppVal = NULL;
        return E_POINTER;
    }

	return hr;
}


_COM_SMARTPTR_TYPEDEF(ITVETrack, __uuidof(ITVETrack));


STDMETHODIMP CTVEVariation::DumpToBSTR(BSTR *pBstrBuff)
{
	const int kMaxChars = 1024;
	TCHAR tBuff[kMaxChars];
	CComBSTR bstrOut, spbstrTmp;
	bstrOut.Empty();

	CSmartLock spLock(&m_sLk);		

	bstrOut.Append(_T("Variation:\n"));

	_stprintf(tBuff,_T("Description        : %s\n"),m_spbsDescription);		bstrOut.Append(tBuff);
	_stprintf(tBuff,_T("Media Name         : %s\n"),m_spbsMediaName);		bstrOut.Append(tBuff);
	_stprintf(tBuff,_T("Media Title        : %s\n"),m_spbsMediaTitle);		bstrOut.Append(tBuff);
	_stprintf(tBuff,_T("File IP Adapter    : %s\n"),m_spbsFileIPAdapter);   bstrOut.Append(tBuff);
	_stprintf(tBuff,_T("File IP Address    : %s\n"),m_spbsFileIPAddress);   bstrOut.Append(tBuff);
	_stprintf(tBuff,_T("File Port          : %d\n"),m_dwFilePort);			bstrOut.Append(tBuff);
	_stprintf(tBuff,_T("Trigger IP Adapter : %s\n"),m_spbsTriggerIPAdapter); bstrOut.Append(tBuff);
	_stprintf(tBuff,_T("Trigger IP Address : %s\n"),m_spbsTriggerIPAddress); bstrOut.Append(tBuff);
	_stprintf(tBuff,_T("Trigger Port       : %d\n"),m_dwTriggerPort);		bstrOut.Append(tBuff);

	spbstrTmp.Empty();
	m_spamSDPLanguages->DumpToBSTR(&spbstrTmp);
	_stprintf(tBuff,_T("SDP Languages      : %s\n"),spbstrTmp);             bstrOut.Append(tBuff);
	spbstrTmp.Empty();
	m_spamLanguages->DumpToBSTR(&spbstrTmp);
	_stprintf(tBuff,_T("Languages          : %s\n"),spbstrTmp);             bstrOut.Append(tBuff);

	_stprintf(tBuff,_T("Bandwidth          : %d\n"),m_ulBandwidth);         bstrOut.Append(tBuff);
	_stprintf(tBuff,_T("BandwidthInfo      : %s\n"),m_spbsBandwidthInfo);   bstrOut.Append(tBuff);
// transport protocol
// format codes
	spbstrTmp.Empty();
	m_spamAttributes->DumpToBSTR(&spbstrTmp);
	_stprintf(tBuff,_T("Attributes         : %s\n"),spbstrTmp);				bstrOut.Append(tBuff);
	spbstrTmp.Empty();
	m_spamRest->DumpToBSTR(&spbstrTmp);
	_stprintf(tBuff,_T("** Rest **         :\n%s  ---------------\n"),spbstrTmp);	bstrOut.Append(tBuff);

	if(NULL == m_spTracks) {
		_stprintf(tBuff,_T("<<< Uninitialized Tracks >>>\n"));
		bstrOut.Append(tBuff);
	} else {
		long cTracks;
		m_spTracks->get_Count(&cTracks);	
		_stprintf(tBuff,_T("%d Tracks\n"), cTracks);
		bstrOut.Append(tBuff);

		for(long i = 0; i < cTracks; i++) 
		{
			_stprintf(tBuff,_T("Track %d\n"), i);
			bstrOut.Append(tBuff);

			CComVariant var(i);
			ITVETrackPtr spTrack;
			HRESULT hr = m_spTracks->get_Item(var, &spTrack);			// does AddRef!  - 1 base?

		//	ITVETrack_Helper *spTrackHelper;
			if(S_OK == hr)
			{
				CComQIPtr<ITVETrack_Helper> spTrackHelper = spTrack;
				if(!spTrackHelper) {bstrOut.Append(_T("*** Error in Track\n")); break;}

				CComBSTR bstrTrack;
				spTrackHelper->DumpToBSTR(&bstrTrack);
				bstrOut.Append(bstrTrack);
			} else {
				bstrOut.Append(_T("*** Invalid, wasn't able to get_Item on it\n")); 
			}
		}
/* ---- method 2 - using enumerator */

/*		CComObject<AVarEnum> *pEnum;
		HRESULT hr = get__NewEnum(&pEnum);
		do(pEnum) {
			pEnum->Next();
		} */


/*		ITrackCollection* pEnum = new ITrackCollection;
		pEnum->Init(); */

//		CComObject<VarEnum>* pEnum;
//		pEnum = new CComObject<VarEnum>;

//		VarVector pv = m_spTracks->

	}

	bstrOut.CopyTo(pBstrBuff);

	return S_OK;
}

STDMETHODIMP CTVEVariation::get_Description(BSTR *pVal)
{
	CHECK_OUT_PARAM(pVal);

    try {
		CSmartLock spLock(&m_sLk);
		return m_spbsDescription.CopyTo(pVal);
    } catch(...) {
		*pVal = NULL;
        return E_POINTER;
    }
}

STDMETHODIMP CTVEVariation::put_Description(BSTR newVal)
{
	CSmartLock spLock(&m_sLk);
	m_spbsDescription = newVal;
	return S_OK;
}

  // ----------

STDMETHODIMP CTVEVariation::get_IsValid(/*[out, retval]*/ VARIANT_BOOL *pVal)
{
	CHECK_OUT_PARAM(pVal);
	CSmartLock spLock(&m_sLk);
	*pVal = m_fIsValid ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

			// helper interface
STDMETHODIMP CTVEVariation::put_IsValid(/*[out, retval]*/ VARIANT_BOOL fVal)
{
	CSmartLock spLock(&m_sLk);
	m_fIsValid = (fVal == VARIANT_FALSE) ? false : true;
	return S_OK;
}

	// ---------


STDMETHODIMP CTVEVariation::get_MediaName(/*[out, retval]*/ BSTR *pVal)
{
	CHECK_OUT_PARAM(pVal);

    try {
		CSmartLock spLock(&m_sLk);
		return m_spbsMediaName.CopyTo(pVal);
    } catch(...) {
		*pVal = NULL;
        return E_POINTER;
    }
}


	// ---------

STDMETHODIMP CTVEVariation::get_MediaTitle(/*[out, retval]*/ BSTR *pVal)
{
	CHECK_OUT_PARAM(pVal);
    try {
		CSmartLock spLock(&m_sLk);
		return m_spbsMediaTitle.CopyTo(pVal);
    } catch(...) {
		*pVal = NULL;
        return E_POINTER;
    }
}

STDMETHODIMP CTVEVariation::put_MediaTitle(BSTR newVal)
{
	CSmartLock spLock(&m_sLk);
	m_spbsMediaTitle = newVal;
	return S_OK;
}
		// -----------------
STDMETHODIMP CTVEVariation::get_FilePort(/*[out, retval]*/ LONG *plPort)
{
	CHECK_OUT_PARAM(plPort);
	CSmartLock spLock(&m_sLk);
	*plPort = (LONG) m_dwFilePort;
	return S_OK;
}

STDMETHODIMP CTVEVariation::get_FileIPAddress(/*[out, retval]*/ BSTR *pVal)
{
	CHECK_OUT_PARAM(pVal);

    try {
		CSmartLock spLock(&m_sLk);
		return m_spbsFileIPAddress.CopyTo(pVal);
    } catch(...) {
		*pVal = NULL;
        return E_POINTER;
    }
}

STDMETHODIMP CTVEVariation::get_FileIPAdapter(/*[out, retval]*/ BSTR *pVal)
{
	CHECK_OUT_PARAM(pVal);

    try {
		CSmartLock spLock(&m_sLk);
		return m_spbsFileIPAdapter.CopyTo(pVal);
    } catch(...) {
		*pVal = NULL;
        return E_POINTER;
    }
}

STDMETHODIMP CTVEVariation::SetFileIPAdapter(/*[in*/ BSTR bstrVal)		// ITVEVariation_Helper
{
	CSmartLock spLock(&m_sLk);		
	m_spbsFileIPAdapter = bstrVal;
	return S_OK;
}
		// ------------------
STDMETHODIMP CTVEVariation::get_TriggerPort(/*[out, retval]*/ LONG *plPort)
{
	CHECK_OUT_PARAM(plPort);
	CSmartLock spLock(&m_sLk);
	*plPort = (LONG) m_dwTriggerPort;
	return S_OK;
}

STDMETHODIMP CTVEVariation::get_TriggerIPAddress(/*[out, retval]*/ BSTR *pVal)
{
	CHECK_OUT_PARAM(pVal);

    try {
		CSmartLock spLock(&m_sLk);
		return m_spbsTriggerIPAddress.CopyTo(pVal);
    } catch(...) {
		*pVal = NULL;
        return E_POINTER;
    }
}

STDMETHODIMP CTVEVariation::get_TriggerIPAdapter(/*[out, retval]*/ BSTR *pVal)
{
	CHECK_OUT_PARAM(pVal);
    try {
		CSmartLock spLock(&m_sLk);
		return m_spbsTriggerIPAdapter.CopyTo(pVal);
    } catch(...) {
		*pVal = NULL;
        return E_POINTER;
    }
}

STDMETHODIMP CTVEVariation::SetTriggerIPAdapter(/*[in*/ BSTR bstrVal)	// ITVEVariation_Helper
{
	CSmartLock spLock(&m_sLk);	
	m_spbsTriggerIPAdapter = bstrVal;
	return S_OK;
}
		// ----------------
STDMETHODIMP CTVEVariation::get_Languages(/*[out, retval]*/ ITVEAttrMap* *ppVal)
{
	HRESULT hr;
	CHECK_OUT_PARAM(ppVal);

    try {
		CSmartLock spLock(&m_sLk);
        hr = m_spamLanguages->QueryInterface(ppVal);
    } catch(...) {
		*ppVal = NULL;
        return E_POINTER;
    }
	return hr;
}

		// ----------------
STDMETHODIMP CTVEVariation::get_SDPLanguages(/*[out, retval]*/ ITVEAttrMap* *ppVal)
{
	HRESULT hr;
	CHECK_OUT_PARAM(ppVal);

    try {
		CSmartLock spLock(&m_sLk);
        hr = m_spamSDPLanguages->QueryInterface(ppVal);
    } catch(...) {
		*ppVal = NULL;
        return E_POINTER;
    }
	return hr;
}


STDMETHODIMP CTVEVariation::get_Bandwidth(/*[out, retval]*/ LONG *plVal)
{
	CHECK_OUT_PARAM(plVal);
	CSmartLock spLock(&m_sLk);
    *plVal = (LONG) m_ulBandwidth;
	return S_OK;
}

STDMETHODIMP CTVEVariation::get_BandwidthInfo(/*[out, retval]*/ BSTR *pVal)
{
	CHECK_OUT_PARAM(pVal);
    try {
		CSmartLock spLock(&m_sLk);
		return m_spbsBandwidthInfo.CopyTo(pVal);
    } catch(...) {
		*pVal = NULL;
        return E_POINTER;
    }
	return E_FAIL;
}

STDMETHODIMP CTVEVariation::get_Attributes(ITVEAttrMap* *ppVal)
{
	HRESULT hr;
	CHECK_OUT_PARAM(ppVal);

    try {
		CSmartLock spLock(&m_sLk);
        hr = m_spamAttributes->QueryInterface(ppVal);
    } catch(...) {
		*ppVal = NULL;
        return E_POINTER;
    }
	return hr;
}

STDMETHODIMP CTVEVariation::get_Rest(/*[out, retval]*/ ITVEAttrMap* *ppVal)
{
	CHECK_OUT_PARAM(ppVal);
	HRESULT hr = S_OK;

	try {
		CSmartLock spLock(&m_sLk);
        hr = m_spamRest->QueryInterface(ppVal);
   } catch(...) {
		*ppVal = NULL;
        return E_POINTER;
    }
	return hr;

}
// ----------------------------------------------------------------------------------
// SubParseSDP
//
//		This method parses media type (variation) subfields out of the SAP announcement.
//		It is called by the full CTVEEnhancement::ParseSAP routine with substrings
//		devoted to just a particular variation.
//
//		Accepts following parameters
//			c=
//			b=
//			a=
//			m=
//		    i=
//
//		Any other arguements are added to the 'Rest' field (it's up to the Enhancement parser
//		to not pass them to this routine.)
//
//		If it gets one of the m= tve-file   or tve-trigger (as opposed to the tve-file/tve-trigger combo)
//		it returns *pfMissingMedia as true.   A later call can fill in the other media type..
//
//		Will return 
//			E_INVALIDARG - invalid parameter
//			
STDMETHODIMP CTVEVariation::SubParseSDP(const BSTR *pbstrSDP, BOOL *pfMissingMedia)
{
	DBG_HEADER(CDebugLog::DBG_VARIATION, _T("CTVEVariation::SubParseSDP"));
	HRESULT hr = S_OK;
	
	if(NULL == pbstrSDP) return E_INVALIDARG;

	wchar_t *wszSDP = *pbstrSDP;
		// parse substrings...
    while (*wszSDP)
	{
		while(wszSDP && iswspace(*wszSDP)) wszSDP++;	// skip spaces before keyword. caution - standard may not want this fix

        wchar_t wchCmd = *wszSDP++;						// keyword
        wchar_t *wszArg = wszSDP;						// "=<value>' ...

        wchar_t *wszNL = wcschr(wszSDP, '\n');			// find the <CR> that terminates each field
        BOOL fCRLF = false;

        if (wszNL != NULL)								// if found <CR>, null it out..
        {
            *wszNL = '\0';					           
            if ((wszNL > wszSDP) && (wszNL[-1] == '\r'))	// Ignore CR immediately before LF
            {
                fCRLF = true;
                wszNL[-1] = '\0';
            }
            wszSDP = wszNL + 1;							// bounce wszSDP to end of this field
            if (*wszSDP == '\r')						// Ignore CR immediately after LF
                wszSDP++;
        }
        
        if (*wszArg++ == '=')							
        {
 			const wchar_t *wszArgStart = wszArg-2;				// get the 'x=' part too.
            switch (wchCmd)
            {
           case 'm':
			   {
					BOOL fFileMedia = false;
					BOOL fTriggerMedia = false;
					hr = ParseMedia(wszArg, &fFileMedia, &fTriggerMedia);
					if((fTriggerMedia && m_fTriggerMedia) ||
					   (fFileMedia && m_fFileMedia)) 
					{
						hr = E_FAIL;							// multiple m= fields of the same type
						break;
					}
					if(pfMissingMedia)
						*pfMissingMedia = (!(m_fFileMedia || fFileMedia)) ||
										  (!(m_fTriggerMedia || fTriggerMedia));

					m_fFileMedia    = fFileMedia;
					m_fTriggerMedia = fTriggerMedia;
    
			   }
				break;
			
		    case 'i':
				if(0 != m_spbsMediaTitle.Length())
				{
					hr = E_FAIL;
					break;
				}
				m_spbsMediaTitle =  wszArg;
								// for fun, add to description field too..
				m_spbsDescription = wszArg;
				break;
			case 'c':
				if(!m_fFileMedia && !m_fTriggerMedia)			// 'c' before 'm'  (except after 'i' unless sounds like 'a' in neighbor or weigh)
					return E_FAIL;
                hr = ParseConnection(wszArg, m_fFileMedia, m_fTriggerMedia);
                break;
			
            case 'b':
				hr = ParseBandwidth(wszArg);
                break;

/*			case 'i':		// should have this here, instead Enhancement
				m_spbsMediaTitle =  wszArg Pa;
                break;
*/

 			case 'a':
				{
					wchar_t *wszCo = wcschr(wszArg, ':');			// find the <:> that divides each field
					if(wszCo != NULL) {
						CComBSTR bsKey, bsValue;					// parse into <key> ':' <value>
						int cLenKey = wszCo - wszArg;
						bsKey.Append(wszArg, cLenKey);
						bsValue.Append(wszCo+1, wcslen(wszArg) - cLenKey - 1);

																		//    simply append new languages to existing one with list with ','
						if(0 == wcscmp(bsKey,L"lang") ||
						   0 == wcscmp(bsKey,L"sdplang"))
						{
							CComBSTR bsValCurr;
							CComVariant cvKey(bsKey);
							m_spamAttributes->get_Item(cvKey, &bsValCurr);
							if(bsValCurr.Length() > 0)
							{
								bsValCurr.Append(",");
								bsValCurr.Append(bsValue);
								m_spamAttributes->Replace(bsKey, bsValCurr);
								break;
							}
						}

						m_spamAttributes->Replace(bsKey, bsValue);
					} else {
						m_spamAttributes->Replace(wszArg,L"");			// no parameters
					}
				}
				break;

			default:
				{
					CComBSTR bstrX(wszArgStart);
					m_spamRest->Add1(bstrX);					// fakes a unique key
				}
				break;


       //    case 'a':
       //         panncCur->AddAttr(szArg);
       //         break;
			}				// end switch
		}
        
        if (NULL == wszNL)
            break;

        // Restore the newline.
        *wszNL = '\n';

        // Restore the CR (if any)
        if (fCRLF)
            wszNL[-1] = '\r';
    }

    return hr;
}

// --------------------------------------
//  ParseMedia
//
//  parses the m= field
//
//		m=data portvalue tve-file
//	or	m=data portvalue tve-trigger
//	or	m=data portvalue/2 tve-file/tve-trigger
//	or	m=data portvalue/2 tve-trigger/tve-file
//	or  m=data portvalue/N .../.../...				// N different ports
//					
//

HRESULT 
CTVEVariation::ParseMedia(const wchar_t *wszArg,  BOOL *pfFileMedia, BOOL *pfTriggerMedia)
{
	*pfFileMedia = FALSE;
	*pfTriggerMedia = FALSE;

    if (0 == wcsncmp(wszArg, kbstrData, wcslen(kbstrData)))			// "data"
	{
    
		wszArg += wcslen(kbstrData);
		if (!iswspace(*wszArg))
			return E_INVALIDARG;
 
		while(wszArg && iswspace(*wszArg)) wszArg++;

		int countPorts = 1;

		long lPort = _wtol(wszArg);									// initial port
		int cb = wcsspn(wszArg, L"0123456789");
		if (cb == 0 || wszArg[cb] == '\0')
			return S_OK;
    
		wszArg += cb;		
    
		if (*wszArg == '/')											// number of ports
		{
			wszArg++;
			countPorts = _wtoi(wszArg);
			cb = wcsspn(wszArg, L"0123456789");
			if (cb == 0 || wszArg[cb] == '\0')
				return S_OK;
        
			wszArg += cb;
		}
		if(countPorts > 100) 
			return E_INVALIDARG;

		if (*wszArg++ != ' ')
			return E_INVALIDARG;

		for (int i= 0; i < countPorts; i++)
		{
			wchar_t wchT = ' ';
			wchar_t *wszT = wcschr(wszArg, '/');			// look for AAA BBB...  or AAA/BBB...
			if (wszT == NULL)
				wszT = wcschr(wszArg, ' ');
			if (wszT != NULL)
			{
				wchT = *wszT;
				*wszT = '\0';
			}
        
			if (0 == wcsncmp(wszArg, kbstrTveFile, wcslen(kbstrTveFile)))				// "tve-file"
			{
				m_dwFilePort = lPort + i;
				if(m_spbsMediaName.Length() > 0) m_spbsMediaName.Append(L"/");
				m_spbsMediaName.Append(kbstrTveFile);
				*pfFileMedia = TRUE;
			}
			else if (0 == wcsncmp(wszArg, kbstrTveTrigger, wcslen(kbstrTveTrigger)))	// "tve-trigger"
			{
				m_dwTriggerPort = lPort + i;
				if(m_spbsMediaName.Length() > 0) m_spbsMediaName.Append(L"/");
				m_spbsMediaName.Append(kbstrTveTrigger);
				*pfTriggerMedia = TRUE;
			}
									// we could add more generic code here to handle different media names.... (e.g. tve-foobar)

			if (wszT != NULL)
				*wszT = wchT;

			if (wchT == ' ')								// if space deliminator, stop parsing
				break;

			wszArg = wszT + 1;
		}
	} else {
		return E_INVALIDARG;
	}

	return S_OK;
}


// --------------------------------------
//   ParseConnection
//
//	parses the c= field
//
//			c=IN IP4 N.N.N.N/ttl  (time to live)
//
//		Sets the appropriate IP address for data or trigger (or both) 
//			if fFileMedia set, sets m_spbsFileIPAddress
//			if fTriggerMedia set, sets m_spbsTriggerIPAddress
//

HRESULT WSZtoDW(const wchar_t *wszArg, DWORD *pdwVal);

HRESULT 
CTVEVariation::ParseConnection(const wchar_t *wszArg, BOOL fFileMedia, BOOL fTriggerMedia)
{
	if (0 == wcsncmp(wszArg, kbstrConnection, wcslen(kbstrConnection)))	// "IN IP4 "
	{
		wszArg += wcslen(kbstrConnection);			// skip over prolog
        wchar_t *wszT = wcschr(wszArg, '/');			// look for '/' giving port address

		if (NULL != wszT)
			*wszT = NULL;

//		DWORD dwIPAddress;
//		hr = WSZtoDW(wszT,&dwIPAddress);
//		if(FAILED(hr)) return hr;

        if (fFileMedia)    m_spbsFileIPAddress    = wszArg;
        if (fTriggerMedia) m_spbsTriggerIPAddress = wszArg;
   
		if (NULL != wszT)						// replace the '/'
			*wszT = '/';

		wszArg = wszT+1;			// time to live
		
		DWORD dwTTL = 0;
		if(wszArg) dwTTL = _wtol(wszArg);		// ignores this value...

	} else {
		return E_INVALIDARG;
	} 
	return S_OK;       
}

		// converts string format internet number (e.g "123.45.123.1") to a DWord
HRESULT WSZtoDW(const wchar_t *wszArg, DWORD *pdwVal)
{
	if(!pdwVal) return E_POINTER;
	*pdwVal = 0;

	DWORD dwVal = 0;
	for(int i = 0; i < 4; i++)
	{
		wchar_t *wszT = wcschr(wszArg,'.');
		if(NULL == wszT && i != 3)
			return E_INVALIDARG;
		wszT = 0;
		dwVal = dwVal * 256 + _wtol(wszArg);
		if(wszT) *wszT = '.';
		wszArg = wszT+1;
	}
	*pdwVal = dwVal;
	return S_OK;
}


// --------------------------------------
//  ParseBandwidth
//
//		parses the b= field
//
//		b=CT:n
//  or  b=AT:n
//
//		BUG -- Doesn't do bandwidth for trigger and data seperatly - takes last one

HRESULT CTVEVariation::ParseBandwidth(const wchar_t *wszArg)
{
   if (0 == wcsncmp(wszArg, kbstrATVEFBandwithCT, wcslen(kbstrATVEFBandwithCT)))		// "CT:";
   {
	   m_spbsBandwidthInfo = kbstrATVEFBandwithCT;
       m_ulBandwidth	   = _wtol(wszArg + wcslen(kbstrATVEFBandwithCT));
	   return S_OK;
   }
   else if (0 == wcsncmp(wszArg, kbstrATVEFBandwithAS, wcslen(kbstrATVEFBandwithAS)))	// "AS:";
   {
	   m_spbsBandwidthInfo = kbstrATVEFBandwithAS;
       m_ulBandwidth	   = _wtol(wszArg + wcslen(kbstrATVEFBandwithAS));
	   return S_OK;
   } else {
	   return E_INVALIDARG;
   }
	return S_OK;
}
// ----------------------------------------------------------
//  FinalParseSDP
//
//		Deals with standard a: attributes, moving them to 
//		designated fields in the variation.  Called after all 
//		elements have been added to the variation .
//
//		Modified elements are:
//
//			a=lang:<languages> (separated by ',')
//			a=sdplang:<languages> (separated by ',')
//				removes any default languages that may be there.
//
// ------------------------------------------------------------

STDMETHODIMP CTVEVariation::FinalParseSDP()
{
	DBG_HEADER(CDebugLog::DBG_VARIATION, _T("CTVEVariation::FinalParseSDP"));
	HRESULT hr = S_OK;
	CComBSTR bstrValue;

	CSmartLock spLock(&m_sLk);		

	CComVariant cvLang(L"lang");
	if(S_OK == m_spamAttributes->get_Item(cvLang,&bstrValue)) 
	{	
							// if media level language specified, overwrite any current base languages
		hr = m_spamLanguages->RemoveAll();

		wchar_t *pb = bstrValue;			
		while(*pb) {
						// extract a language  - perhaps change to use wcstok()
			while(*pb && (iswspace(*pb) || *pb == ',')) pb++;		// skip spaces
			wchar_t *pbs = pb;
			while(*pb && !iswspace(*pb) && *pb != ',') pb++;		// skip over the language
			wchar_t wcsLang[100];
			wcsncpy(wcsLang, pbs, pb-pbs+1);  
			wcsLang[pb-pbs] = 0;						// null terminate..

						// overwrite any current base languages
			hr = m_spamLanguages->Add1(wcsLang);		// sort will fail if > 1000 languages (need %2d)
		}
		m_spamAttributes->Remove(cvLang);						// remove from general list
	}

	CComVariant cvLangSDP(L"sdplang");
	if(S_OK == m_spamAttributes->get_Item(cvLangSDP,&bstrValue)) 
	{	
							// if media level language specified, overwrite any current base languages
		hr = m_spamSDPLanguages->RemoveAll();

		wchar_t *pb = bstrValue;			
		while(*pb) {
						// extract a language  - perhaps change to use wcstok()
			while(*pb && (iswspace(*pb) || *pb == ',')) pb++;		// skip spaces
			wchar_t *pbs = pb;
			while(*pb && !iswspace(*pb) && *pb != ',') pb++;		// skip over the language
			wchar_t wcsLang[100];
			wcsncpy(wcsLang, pbs, pb-pbs+1);
			wcsLang[pb-pbs] = 0;						// null terminate..

						// overwrite any current base languages
			hr = m_spamSDPLanguages->Add1(wcsLang);		// sort will fail if > 1000 languages (need %2d)
		}
		m_spamAttributes->Remove(cvLangSDP);						// remove from general list
	}
	return hr;
}

// ----------------------------------------------------------
//  DefaultTo
//		Copy routine, fills the elements with those in *pVariationBase
//

STDMETHODIMP CTVEVariation::DefaultTo(ITVEVariation *pVariationBase)
{
	DBG_HEADER(CDebugLog::DBG_VARIATION, _T("CTVEVariation::DefaultTo"));
	CSmartLock spLock(&m_sLk);		// should really lock pVariationsBase here too.
//	pVariationBase->lock_();
    LONG lVal;

	m_spbsDescription.Empty(); pVariationBase->get_Description(&m_spbsDescription);
	m_spbsMediaName.Empty();   pVariationBase->get_MediaName(&m_spbsMediaName);
	m_spbsMediaTitle.Empty();  pVariationBase->get_MediaTitle(&m_spbsMediaTitle);

	m_spbsFileIPAdapter.Empty(); pVariationBase->get_FileIPAdapter(&m_spbsFileIPAdapter);
	m_spbsFileIPAddress.Empty(); pVariationBase->get_FileIPAddress(&m_spbsFileIPAddress);
	pVariationBase->get_FilePort(&lVal);  m_dwFilePort = (DWORD) lVal;

	m_spbsTriggerIPAdapter.Empty(); pVariationBase->get_TriggerIPAdapter(&m_spbsTriggerIPAdapter);
	m_spbsTriggerIPAddress.Empty(); pVariationBase->get_TriggerIPAddress(&m_spbsTriggerIPAddress);
	pVariationBase->get_TriggerPort(&lVal); m_dwTriggerPort = (DWORD) lVal;

	pVariationBase->get_Bandwidth(&lVal); m_ulBandwidth = (DWORD) lVal;
	pVariationBase->get_BandwidthInfo(&m_spbsBandwidthInfo);

						// copy over the maps... this is slow implementation for large sets
	ITVEAttrMapPtr spAttrsFrom;
	long cAttrs = 0;

	HRESULT hr = pVariationBase->get_Rest(&spAttrsFrom);
	{
		if(NULL == spAttrsFrom) return E_NOINTERFACE;		// this would be bad...
		spAttrsFrom->get_Count(&cAttrs);
		for(int i = 0; i < cAttrs; i++) {
			CComBSTR bstrKey, bstrItem;
			CComVariant id(i);
			spAttrsFrom->get_Key(id, &bstrKey);
			spAttrsFrom->get_Item(id, &bstrItem);
			m_spamRest->Replace(bstrKey, bstrItem);
		}
	}

	hr = pVariationBase->get_Attributes(&spAttrsFrom);		
	if(S_OK == hr) 
	{
		if(NULL == spAttrsFrom) return E_NOINTERFACE;		// this would be bad...
		spAttrsFrom->get_Count(&cAttrs);
		for(int i = 0; i < cAttrs; i++) {
			CComBSTR bstrKey, bstrItem;
			CComVariant id(i);
			spAttrsFrom->get_Key(id, &bstrKey);
			spAttrsFrom->get_Item(id, &bstrItem);
			m_spamAttributes->Replace(bstrKey, bstrItem);
		}
	}

	hr = pVariationBase->get_Languages(&spAttrsFrom);		
	if(S_OK == hr) 
	{
		if(NULL == spAttrsFrom) return E_NOINTERFACE;		// this would also be bad...
		spAttrsFrom->get_Count(&cAttrs);
		for(int i = 0; i < cAttrs; i++) {
			CComBSTR bstrKey, bstrItem;
			CComVariant id(i);
			spAttrsFrom->get_Key(id, &bstrKey);
			spAttrsFrom->get_Item(id, &bstrItem);
			m_spamLanguages->Replace(bstrKey, bstrItem);
		}
	}

	hr = pVariationBase->get_SDPLanguages(&spAttrsFrom);		
	if(S_OK == hr) 
	{
		if(NULL == spAttrsFrom) return E_NOINTERFACE;		// this would also be bad...
		spAttrsFrom->get_Count(&cAttrs);
		for(int i = 0; i < cAttrs; i++) {
			CComBSTR bstrKey, bstrItem;
			CComVariant id(i);
			spAttrsFrom->get_Key(id, &bstrKey);
			spAttrsFrom->get_Item(id, &bstrItem);
			m_spamSDPLanguages->Replace(bstrKey, bstrItem);
		}
	}
//	pVariationBase->unlock_();

	return S_OK;
}

STDMETHODIMP CTVEVariation::Initialize(BSTR bstrDesc)
{
	CSmartLock spLock(&m_sLk);
	m_spbsDescription = bstrDesc;

	m_dwFilePort = 0;
	m_dwTriggerPort = 0;
	m_fFileMedia = false;
	m_fIsValid = false;
	m_fTriggerMedia = false;
	m_pEnhancement = NULL;		// parent pointer
	m_spamAttributes->RemoveAll();
	m_spamLanguages->RemoveAll();
	m_spamSDPLanguages->RemoveAll();
	m_spbsBandwidthInfo.Empty();
	m_spamRest->RemoveAll();

	m_spbsFileIPAdapter.Empty();
	m_spbsFileIPAddress.Empty();
	m_spbsMediaName.Empty();
	m_spbsTriggerIPAdapter.Empty();
	m_spbsTriggerIPAddress.Empty();
	m_spTracks->RemoveAll();
	m_ulBandwidth = 0;

	return S_OK;
}

// -------------------------------------------------------
//   ParseCBTrigger
//
//		This accepts unparsed triggers from a callback, and does the following:
//
//			- Takes an string containing an trigger
//			- Parses the data fields out of it (converts it to an ITVETrigger object)
//			- Looks in list of existing tracks under the enhancement to see if its already there
//				-- matches on 
//					1) trigger base page (URL)
//			- If it's a new trigger (no matching URL), 
//				 - If it has a non-null name, 
//					  - creates a new track object to contain it of that name
//				      - signals a NotifyTrigger event
//				 - Else if it has a Null name 
//					  - drops the trigger in the bit-bucket (missed original trigger)
//		    - If there is a matching URL in the list of tracks
//				 - if the Name is the same as that URL
//					  - Updates the changed fields (script, name(?), expires)
//					  - signals an event 
//				 - if different Name (?)
//
STDMETHODIMP CTVEVariation::ParseCBTrigger(BSTR bstrTrig)
{
	DBG_HEADER(CDebugLog::DBG_VARIATION, _T("CTVEVariation::ParseCBTrigger"));
	HRESULT hr;
	CSmartLock spLock(&m_sLk);		

														// get pointers all the way up to the supervisor
	_ASSERT(m_pEnhancement);							// need to call ConnectParent first...
	IUnknownPtr spUnk;
	hr = m_pEnhancement->get_Parent(&spUnk);	
	if(FAILED(hr))
		return hr;
	ITVEServicePtr spService(spUnk);
	if(NULL == spService)
		return E_NOINTERFACE;

	hr = spService->get_Parent(&spUnk);
	if(FAILED(hr))
		return hr;
	ITVESupervisorPtr spSuper(spUnk);				// really don't need this - QI for Super Helper directly
	if(NULL == spSuper)
		return E_NOINTERFACE;
	ITVESupervisor_HelperPtr spSuperHelper(spSuper);
	if(NULL == spSuperHelper)
		return E_NOINTERFACE;


	ITVETriggerPtr spTrigParsed;
	CComObject<CTVETrigger> *pTrig;
	hr = CComObject<CTVETrigger>::CreateInstance(&pTrig);
	if(FAILED(hr))
		return hr;
	hr = pTrig->QueryInterface(&spTrigParsed);			// typesafe QI
	if(FAILED(hr)) {
		delete pTrig;
		return hr;
	}	

						// parse this trigger string we just received (does all interesting work here)
	hr = spTrigParsed->ParseTrigger(bstrTrig);
	if(FAILED(hr))
	{
		ATLTRACE("Invalid Trigger : %s\n",bstrTrig);
		DWORD grfError = 0;
		if(hr == MSTVE_E_INVALIDTRIGGER)	grfError |= NTRK_grfRest;		// strange one..
		if(hr == MSTVE_E_INVALIDTVELEVEL)	grfError |= NTRK_grfTVELevel;
		if(hr == MSTVE_E_INVALIDCHKSUM)		grfError |= NTRK_grfRest;
		if(hr == MSTVE_E_INVALIDEXPIREDATE) grfError |= NTRK_grfDate;
		if(hr == MSTVE_E_INVALIDURL)		grfError |= NTRK_grfURL;
		if(hr == MSTVE_E_INVALIDNAME)		grfError |= NTRK_grfName;
		if(hr == MSTVE_E_PASTDUEEXPIREDATE) grfError |= NTRK_grfExpired;
		if(hr == MSTVE_E_INVALIDSCRIPT)		grfError |= NTRK_grfScript;
		if(grfError == 0)					grfError = NTRK_grfRest;
		spSuperHelper->NotifyAuxInfo(NWHAT_Trigger, bstrTrig, grfError, 0);
		return hr;
	}
						// if it's ok (valid, hasn't run out of time) get pieces of it
	CComBSTR spbsPURL;
	spTrigParsed->get_URL(&spbsPURL);

						// now look for any existing track of the same URL
	long cTracks;
	hr = m_spTracks->get_Count(&cTracks);
	if(FAILED(hr)) return hr;

	CComBSTR spbsURL;
	ITVETrackPtr spTrackFound;
	ITVETriggerPtr spTriggerFound;

	long iTrack = 0;
	for(iTrack = 0; iTrack < cTracks; iTrack++)
	{
		ITVETrackPtr spTrack;
		CComVariant cv(iTrack);
		m_spTracks->get_Item(cv, &spTrack);
		
		ITVETriggerPtr spTrigger;
		hr = spTrack->get_Trigger(&spTrigger);
		if(FAILED(hr)) {
			_ASSERT(false);
			return hr;
		}

		spTrigger->get_URL(&spbsURL);

		if(spbsPURL == spbsURL)				// match just on the URL (base page)
		{
			spTriggerFound = spTrigger;		// found a match
			spTrackFound = spTrack;			
			break;				
		}
	}
					
	if(iTrack != cTracks)					// did we find a matching trigger ?
	{		

		long lgrfNTRK;

		ITVETrigger_HelperPtr spTrigFoundHelper(spTriggerFound);
		spTrigFoundHelper->UpdateFrom(spTrigParsed, &lgrfNTRK);	// compare and modify based on new data

		if(lgrfNTRK == (ULONG) NTRK_grfNone)
			spSuperHelper->NotifyTrigger(NTRK_Duplicate, spTrackFound, lgrfNTRK);
		else 
		{
						// If the expire date changed on the trigger, update it in the expire queue
			if(0 != (lgrfNTRK & (NTRK_grfExpired | NTRK_grfDate) ))
			{
				DATE dateExpires;
				spTriggerFound->get_Expires(&dateExpires);
				ITVEAttrTimeQPtr spExpireQueue;
				hr = spService->get_ExpireQueue(&spExpireQueue);
				if(!FAILED(hr) && NULL != spExpireQueue)
				{
					IUnknownPtr spPunkTrigger(spTriggerFound);
					spExpireQueue->Update(dateExpires, spPunkTrigger);
				}
			}
						// tell the U/I things changed
			spSuperHelper->NotifyTrigger(NTRK_Updated, spTrackFound, lgrfNTRK);

		}
	} 
	else													// nope, need to create a new one
	{				
		ITVETrackPtr spTrackParsed;
		CComObject<CTVETrack> *pTrack;
		hr = CComObject<CTVETrack>::CreateInstance(&pTrack);
		if(FAILED(hr))
			return hr;
		hr = pTrack->QueryInterface(&spTrackParsed);			// typesafe QI
		if(FAILED(hr)) {
			delete pTrack;
			return hr;
		}	
								// Create a new track for this trigger
		ITVETrack_HelperPtr spTrackHelper(spTrackParsed);
		if(NULL == spTrackHelper)
			return E_OUTOFMEMORY;
		ITVETrigger_HelperPtr spTriggerHelper(spTrigParsed);
		if(NULL == spTriggerHelper)
			return E_OUTOFMEMORY;

	//	spTrackParsed->AddRef();  -- bogus addref I think (JB 01-11-01)
		hr = m_spTracks->Add(spTrackParsed);				// down pointer
		if(FAILED(hr))
			return hr;
		
		hr = spTrackParsed->AttachTrigger(spTrigParsed);	// down pointer
		if(FAILED(hr))
			return hr;


		CComPtr<ITVEVariation> spVariationThis(this);
									// interface pointer to stuff into parent-pointers

		hr = spTrackHelper->ConnectParent(spVariationThis);			// Don't use SmartPTR's (CComPtr<ITVEVariation>) for ConnectParent calls (ATLDebug Blow's it)	
		if(FAILED(hr))
			return hr;


						// add the trigger into the expire queue
		{
			ITVETriggerPtr spTrigger;
			hr = spTrackParsed->get_Trigger(&spTrigger);

			if(!FAILED(hr) && spTrigger != NULL) 
			{
				DATE dateExpires;
				spTrigger->get_Expires(&dateExpires);
				ITVEAttrTimeQPtr spExpireQueue;
				hr = spService->get_ExpireQueue(&spExpireQueue);
				if(!FAILED(hr) && NULL != spExpireQueue)
				{
					IUnknownPtr spPunkTrigger(spTrigger);
					spExpireQueue->Add(dateExpires, spPunkTrigger);
				}
			} else {
				_ASSERT(false);			// totally unexpected
			}
		}
						// tell the U/I we have a new trigger

		spSuperHelper->NotifyTrigger(NTRK_New, spTrackParsed, (long) NTRK_grfAll);

	}
	
	return S_OK;
}

	// this modifies an existing Variation, or if it's IP parameters, just indicates it needs changing
STDMETHODIMP CTVEVariation::UpdateVariation(ITVEVariation *pVarNew, long *plgrf_EVARChanged)
{
	long lgrfChanged = 0;

	CComBSTR spbsNew;
	CComBSTR spbsOld;
    LONG     lNew;
	ULONG	 ulNew;
	DWORD	 dwNew;
	IUnknownPtr		spUnk;
	IDispatchPtr	spDsp;

	CSmartLock spLock(&m_sLk);				// should really lock pVarNew here.	

											// caution, CComBSTR doesn't support '!=' operator
	pVarNew->get_FilePort(&lNew); dwNew = (DWORD) lNew;			
	if(!(m_dwFilePort == dwNew))
		{			    	lgrfChanged |= NVAR_grfFilePort;}		// don't actually change IP port, address, or adapter
																	// instead, just flag it, 'cause major reparse needs to occur
	spbsNew.Empty();
	pVarNew->get_FileIPAddress(&spbsNew);			
	if(!(m_spbsFileIPAddress == spbsNew))
		{			lgrfChanged |= NVAR_grfFileIPAddress;}

	spbsNew.Empty();
	pVarNew->get_FileIPAdapter(&spbsNew);			
	if(!(m_spbsFileIPAdapter == spbsNew))
		{			lgrfChanged |= NVAR_grfFileIPAdapter;}

	pVarNew->get_TriggerPort(&lNew); dwNew = (DWORD) lNew;				
	if(!(m_dwTriggerPort == dwNew))
		{				lgrfChanged |= NVAR_grfTriggerPort;}

	spbsNew.Empty();
	pVarNew->get_TriggerIPAddress(&spbsNew);			
	if(!(m_spbsTriggerIPAddress == spbsNew))
		{		lgrfChanged |= NVAR_grfTriggerIPAddress;}

	spbsNew.Empty();
	pVarNew->get_TriggerIPAdapter(&spbsNew);			
	if(!(m_spbsTriggerIPAdapter == spbsNew))
		{		lgrfChanged |= NVAR_grfTriggerIPAdapter;}
	

	spbsNew.Empty();
	pVarNew->get_Description(&spbsNew);			
	if(!(m_spbsDescription == spbsNew))
		{m_spbsDescription = spbsNew;			lgrfChanged |= NVAR_grfDescription;}

	spbsNew.Empty();
	pVarNew->get_MediaName(&spbsNew);			
	if(!(m_spbsMediaName == spbsNew))
		{m_spbsMediaName = spbsNew;				lgrfChanged |= NVAR_grfMediaName;}

	spbsNew.Empty();
	pVarNew->get_MediaTitle(&spbsNew);			
	if(!(m_spbsMediaTitle == spbsNew))
		{m_spbsMediaTitle = spbsNew;			lgrfChanged |= NVAR_grfMediaTitle;}

	ITVEAttrMapPtr spamAttributes;  
	pVarNew->get_Attributes(&spamAttributes);  
	spbsNew.Empty();
	spamAttributes->DumpToBSTR(&spbsNew);
	spbsOld.Empty();
	m_spamAttributes->DumpToBSTR(&spbsOld); 
	if(!(spbsOld == spbsNew))					
	{	m_spamAttributes = spamAttributes;		lgrfChanged |= NVAR_grfAttributes;}

	ITVEAttrMapPtr spamLanguages;  
	pVarNew->get_Languages(&spamLanguages);  
	spbsNew.Empty();
	spamLanguages->DumpToBSTR(&spbsNew);
	spbsOld.Empty();
	m_spamLanguages->DumpToBSTR(&spbsOld); 
	if(!(spbsOld == spbsNew))					
	{	m_spamLanguages = spamLanguages;		lgrfChanged |= NVAR_grfLanguages;}

	ITVEAttrMapPtr spamSDPLanguages;  
	pVarNew->get_SDPLanguages(&spamSDPLanguages);  
	spbsNew.Empty();
	spamSDPLanguages->DumpToBSTR(&spbsNew);
	spbsOld.Empty();
	m_spamSDPLanguages->DumpToBSTR(&spbsOld); 
	if(!(spbsOld == spbsNew))					
	{	m_spamSDPLanguages = spamSDPLanguages;	lgrfChanged |= NVAR_grfLanguages;}

	pVarNew->get_Bandwidth(&lNew); ulNew = (ULONG) lNew;				
	if(!(m_ulBandwidth == ulNew))
		{m_ulBandwidth = ulNew;					lgrfChanged |= NVAR_grfBandwidth;}

	spbsNew.Empty();
	pVarNew->get_BandwidthInfo(&spbsNew);			
	if(!(m_spbsBandwidthInfo == spbsNew))
		{m_spbsBandwidthInfo = spbsNew;			lgrfChanged |= NVAR_grfBandwidthInfo;}

	ITVEAttrMapPtr spamRest;  
	pVarNew->get_Rest(&spamRest);
	spbsNew.Empty();
	spamRest->DumpToBSTR(&spbsNew);
	spbsOld.Empty();
	m_spamRest->DumpToBSTR(&spbsOld); 
	if(!(spbsOld == spbsNew))
		{m_spamRest = spamRest;					lgrfChanged |= NVAR_grfRest;}

	if(plgrf_EVARChanged)
		*plgrf_EVARChanged = lgrfChanged;

	return S_OK;
}

	// initializes this one enhancement as the one that takes Crossover links...
STDMETHODIMP CTVEVariation::InitAsXOver()
{
	HRESULT hr = S_OK;

	Initialize(L"CrossOver Links");

	m_fIsValid = true;
	m_spbsMediaName =  L"CrossOver Links";
	m_spbsMediaTitle = L"XOver Links";

	return hr;
}

	// initializes this one enhancement as the one that takes Crossover links...
STDMETHODIMP CTVEVariation::NewXOverLink(BSTR bstrLine21Trigger)
{
	return ParseCBTrigger(bstrLine21Trigger);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvevarias.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEVariations.cpp : Implementation of CTVEVariations
#include "stdafx.h"
#include "MSTvE.h"
#include "TVEVarias.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTVEVariations

STDMETHODIMP CTVEVariations::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ITVEVariations
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\unpack.cpp ===
// Copyright (c) 1999,2000,2001  Microsoft Corporation.  All Rights Reserved.
//+----------------------------------------------------------------------------
//
// unpack:
//
// The code provided here is used to unpack the MIME multipart package send
// as part of an ATVEF broadcast.  The package is passed into this code via
// the UnpackBuffer function.  No other entry point should be called.
//
//	1-28-99		ChrisK		merged code into single module.
//  2-10-99     DanE        updated to reflect changes in the CCacheManager
//                          interface.

#include "stdafx.h"
#include "MSTvE.h"

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include "TVEUnpak.h"
#include "zlib.h"
#include "fcache.h"
#include "TVEDbg.h"
#include "TVESuper.h"
#include "TVEFile.h"
#include "DbgStuff.h"
#include "..\common\isotime.h"

#include "ZUtil.h"		// get DEF_WBITS for decompressor (GZip Bug)

#define ALLOW_FUZZY_ATVEF		// if set, don't require strict interpretation of Atvef spec (Greek show problems)


_COM_SMARTPTR_TYPEDEF(ITVEFile,					__uuidof(ITVEFile));

_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));

_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,		__uuidof(ITVEService_Helper));

_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MAX_HEADER_ITEM_LENGTH 50
#define MAX_TOKEN_LENGTH	1024
#define CRLF "\r\n"
#define PACKAGE_TYPE "multipart/related"
#define PACKAGE_BOUNDARY "boundary"
#define MyDelete(x) if (NULL != x) delete x;
#define GZIP_ENCODING "gzip"
#define OUTPUT_BUFFER_SIZE 80000

// Cache manager
CCacheManager g_CacheManager;			// creates the one and only cache manager...

class CTVEBuffer {
public:
	CTVEBuffer(LPBYTE pbStart, ULONG ulLength);

	BOOL GetNextByte(BYTE *pbRC);
	BOOL MoveNextByte();
	BOOL GetCurByte(LPBYTE pByte);
	BOOL Copy(LPVOID pDest, ULONG uLen);
	BOOL FindBoundary(LPSTR lpstrBoundary, BOOL bEndBoundary);
	BOOL GetByteAtOffset(ULONG ulOffset,LPBYTE pByte);
	BOOL MoveTo (ULONG uOffset);	
	LPBYTE GetCurrent() { return m_pbCurrent;}
	BOOL SetCurrent(LPBYTE pLoc) { m_pbCurrent = pLoc; return true;}       // should really do error checking here


private:
	LPBYTE	m_pbStart;
	LPBYTE	m_pbEnd;
	LPBYTE	m_pbCurrent;
	ULONG	m_ulLength;
	BOOL	m_bMoreDataAvailable;
};

class CPackage_Header
{
public:
	CPackage_Header();
	~CPackage_Header();

	CHAR	*pcContent_Base;
	CHAR	*pcBoundary;
	ULONG	ulLength;
	DATE	dateExpires;			// default expire date
};

class CSection_Header
{
public:
	CSection_Header();
	~CSection_Header();

	CHAR	*pcLocation;
	CHAR	*pcType;
	CHAR	*pcLanguage;
	CHAR	*pcStyleType;
	CHAR	*pcEncoding;
	DATE	dDate;
	DATE	dExpires;
	DATE	dLastModified;
	ULONG	ulLength;

	ULONG	ulFullContentSize;
};

typedef BOOL (*HEADER_PARSING_FUNC)(CTVEBuffer * pBuffer, CPackage_Header* pPHead);
								   
typedef struct _Parsing_MapTag {
	CHAR sHeader[MAX_HEADER_ITEM_LENGTH];
	HEADER_PARSING_FUNC func;
} Parsing_Map;

typedef BOOL (*HEADER_PARSING_FUNC2)(CTVEBuffer * pBuffer, CSection_Header* pPHead);
								   
typedef struct _Parsing_Map2Tag {
	CHAR sHeader[MAX_HEADER_ITEM_LENGTH];
	HEADER_PARSING_FUNC2 func;
} Parsing_Map2;

BOOL GetNextToken(CTVEBuffer *pBuffer, CHAR *pcToken, INT iLength, BOOL bScanToCRLF = FALSE);
BOOL WriteToCache(CSection_Header* pHeader);

BYTE rgHeader[] = {	0x1f,	// magic number
					0x8B,	// magic number
					0x08,	// deflate compression
					0x00,	// flags
					0x00,	// file modification time
					0x00,	// file modification time
					0x00,	// file modification time
					0x00,	// file modification time
					0x00,	// extra flags (for compression)
					0x0B};	// OS type 0x0B = Win32



// ----------------------------------------------------------------
static DATE 
DateNow()
{		SYSTEMTIME SysTimeNow;
		GetSystemTime(&SysTimeNow);									// initialize with currrent time.
		DATE dateNow;
		SystemTimeToVariantTime(&SysTimeNow, &dateNow);
		return dateNow;
}
//+----------------------------------------------------------------------------
//
//	Function:	DebugSz
//
//	Synopsus:	Log debug string
//
//	Arguments:	psz - pointer to output string
//
//	Returns:	none
//
//	History:	9/2/97	ChrisK	Refitted for JCDialer
//
//-----------------------------------------------------------------------------
void DebugSz(LPCSTR psz)
{
#if defined(_DEBUG)
	OutputDebugStringA(psz);
	OutputDebugStringA("\r\n");
#endif	
} // DebugSz

//+----------------------------------------------------------------------------
//
//	Function:	Dprintf
//
//	Synopsis:	Format and output debug string
//
//	Arguments:	pcsz - format string
//				... - variable number of arguments
//
//	Returns:	none
//
//	History:	9/2/97	ChrisK	Refitted for JCDialer
//
//-----------------------------------------------------------------------------
void Dprintf(LPCSTR pcsz, ...)
{
#ifdef _DEBUG
	va_list	argp;
	char	szBuf[1024];
	
	va_start(argp, pcsz);

	wvsprintfA(szBuf, pcsz, argp);

	DebugSz(szBuf);
	va_end(argp);
#endif
} // Dprintf()

			// parses Date strings of teh form "Mon, 06 Oct 2003 07:55:30 GMT" into DATES (UTC)

int SzDayToInt(char *szDayL)
{		
	char szDay[4];
	int i = 0;
	for(; i < 3; i++)
	{
		if(0 == szDayL[i]) break;
		szDay[i] = (char) tolower(szDayL[i]);
	}
	szDay[i] = 0;

	if(0 == strncmp("sun",szDay,3)) return 0;
	else if(0 == strncmp("mon",szDay,3)) return 1;
	else if(0 == strncmp("tue",szDay,3)) return 2;
	else if(0 == strncmp("wed",szDay,3)) return 3;
	else if(0 == strncmp("thu",szDay,3)) return 4;
	else if(0 == strncmp("fri",szDay,3)) return 5;
	else if(0 == strncmp("sat",szDay,3)) return 6;
	else return -1;
}


BOOL ParseDate(char *szDate, DATE *pDate)
{
	// try it the easy way
	CComVariant vDateIn(szDate);

	CComVariant vDateOut;
	HRESULT hr = VariantChangeType( &vDateOut, &vDateIn, NULL, VT_DATE);
	if(FAILED(hr) && !isdigit(szDate[0]))		// try skipping over the day in the week
	{
		char *lpDate = szDate;
		while(*lpDate && !isdigit(*lpDate))
			lpDate++;
		if(isdigit(*lpDate))
		{
			int iLen = strlen(lpDate);	// if time zone on end, skip it too
			char *pDateEnd = iLen + lpDate-1;
			while(pDateEnd > lpDate && !isdigit(*pDateEnd))
				--pDateEnd;
			if(pDateEnd > lpDate) {
				char tChar = *(pDateEnd+1);
				*(pDateEnd+1) = NULL;
				CComVariant vDateIn2(lpDate);
				hr = VariantChangeType(&vDateOut, &vDateIn2, NULL, VT_DATE);
				*(pDateEnd+1) = tChar;
			}
		}
	}

	if(!FAILED(hr))
	{
		*pDate = vDateOut.date;
		return TRUE;
	} else {
		*pDate = 0;			// unable to parse the date format...
		return FALSE;
	}
}
//+----------------------------------------------------------------------------
//
//	Function:	FAssertProc
//
//	Synopsis:	Handle asserts
//
//	Arguments:	szFile - name of file containing assert code
//				dwLine - line number that assert appears on
//				szMsg - debugging message
//				dwFlags - unused
//
//	Returns:	TRUE if the application should assert into the debugger
//
//	History:	9/2/97	ChrisK	Refitted for JCDialer
//
//-----------------------------------------------------------------------------
BOOL FAssertProc(LPCSTR szFile,  DWORD dwLine, LPCSTR szMsg, DWORD dwFlags)
{
	static LONG lInDebugger = 0;
	BOOL fAssertIntoDebugger = FALSE;
	char szMsgEx[1024], szTitle[255], szFileName[MAX_PATH];
	int id;
	UINT fuStyle;
	LPTSTR pszCommandLine = GetCommandLine();
	CHAR	szTime[80];
	HANDLE	hAssertTxt;
	SYSTEMTIME st;
	DWORD	cbWritten;
	
	// no recursive asserts
	InterlockedIncrement(&lInDebugger);
	if (1 != lInDebugger)
	{
		DebugSz("***Recursive Assert***\r\n");
		InterlockedDecrement(&lInDebugger);
		return(FALSE);
	}

	// Read the information about the file that is asserting and format the 
	// text and title of the assert message.
	GetModuleFileNameA(NULL, szFileName, MAX_PATH);
	wsprintfA(szMsgEx,"file: %s\r\nline: %d\r\nProcess ID: %d %s, Thread ID: %d\r\n%s",
		szFile,dwLine,GetCurrentProcessId(),szFileName,GetCurrentThreadId(),szMsg);
	wsprintfA(szTitle,"Assertion Failed");

	fuStyle = MB_APPLMODAL | MB_ABORTRETRYIGNORE | MB_SETFOREGROUND;
	fuStyle |= MB_ICONSTOP;

	DebugSz(szTitle);
	DebugSz(szMsgEx);

	// dump the assert into ASSERT.TXT
	hAssertTxt = CreateFileA("assert.txt", GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_WRITE_THROUGH, NULL);
	if (INVALID_HANDLE_VALUE != hAssertTxt) 
	{
		SetFilePointer(hAssertTxt, 0, NULL, FILE_END);
		GetLocalTime(&st);   
		wsprintfA(szTime, "\r\n\r\n%02d/%02d/%02d %d:%02d:%02d\r\n", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond);
		WriteFile(hAssertTxt, szTime, lstrlenA(szTime), &cbWritten, NULL);
		WriteFile(hAssertTxt, szMsgEx, lstrlenA(szMsgEx), &cbWritten, NULL);
		CloseHandle(hAssertTxt);
	}

    id = MessageBoxA(NULL, szMsgEx, szTitle, fuStyle);
    switch (id)
    {
    case IDABORT:
    	ExitProcess(0);
    	break;
    case IDCANCEL:
    case IDIGNORE:
    	break;
    case IDRETRY:
    	fAssertIntoDebugger = TRUE;
    	break;
    }
			
	InterlockedDecrement(&lInDebugger);
	
	return(fAssertIntoDebugger);
} // AssertProc()

/////////////////////////////////////////////////////////////////////////////
// 

/*   a small random test program  */
/*
HRESULT Test()
{
	DWORD dwFileSize = 0;
	DWORD dwNumRead = 0;
	LPBYTE lpFileContents = NULL;
	HANDLE hFile = CreateFile(
		_T("d:\\winnt\\profiles\\chrisk\\local settings\\Temp\\cp77E.tmp"),
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,				//security
		OPEN_EXISTING,
		FILE_FLAG_SEQUENTIAL_SCAN,
		NULL);				//template

	dwFileSize = GetFileSize(hFile,NULL);
	lpFileContents = new BYTE[dwFileSize];

	if (NULL == lpFileContents) DebugBreak();
	ReadFile(hFile,lpFileContents,dwFileSize,&dwNumRead,NULL);

	CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;

	UnpackBuffer(NULL, lpFileContents,dwNumRead);

	return S_OK;
}

*/
/////////////////////////////////////////////////////////////////////////////
BOOL ValidateCRLFToken (CTVEBuffer *pBuffer)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ValidateCRLFToken"));
	CHAR cToken[1024];
	BOOL bRC = FALSE;

	if (GetNextToken(pBuffer,cToken,sizeof(cToken)))
	{
		if (0 == lstrcmpiA(cToken,"\r\n"))
		{
			bRC = TRUE;
		}
	}

	return bRC;
}

///////////////////////////////////////////////////////////////////////////////
//	CPackage_Header

CPackage_Header::CPackage_Header()
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("CPackage_Header::CPackage_Header"));
	pcContent_Base	= NULL;
	pcBoundary		= NULL;
	ulLength		= 0;
	dateExpires		= 0;			// zero means ???
}

CPackage_Header::~CPackage_Header()
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("CPackage_Header::~CPackage_Header"));
	MyDelete(pcBoundary);
	MyDelete(pcContent_Base);
}

///////////////////////////////////////////////////////////////////////////////
//	CSection_Header
CSection_Header::CSection_Header()
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("CSection_Header::CSection_Header"));
	pcLocation = NULL;
	pcType = NULL;
	pcLanguage = NULL;
	pcStyleType = NULL;
	pcEncoding = NULL;
	dDate = 0;
	dExpires = 0;
	dLastModified = 0;
	ulLength = 0;
}

CSection_Header::~CSection_Header()
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("CSection_header::~CSection_Header"));
	MyDelete(pcLocation);	
	MyDelete(pcType);
	MyDelete(pcLanguage);
	MyDelete(pcStyleType);
	MyDelete(pcEncoding);
}

///////////////////////////////////////////////////////////////////////////////

BOOL VerifyColon(CTVEBuffer *pBuffer)
{
//    DBG_HEADER(CDebugLog::DBG_MIME, "VerifyColon");
	CHAR cToken[MAX_TOKEN_LENGTH];
	BOOL bRC = FALSE;

	//
	// find colon
	//
	if (GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
	{
		if (0 == lstrcmpiA(":",cToken))
		{
			bRC = TRUE;
		}
	}

	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParsePackageHeaderType(CTVEBuffer * pBuffer, CPackage_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParsePackageHeaderType"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto ParsePackageHeaderTypeExit;
	}

	//
	// find multipart/related
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
	{
		goto ParsePackageHeaderTypeExit;
	}

	if (0 != lstrcmpiA(PACKAGE_TYPE,cToken))
	{
		goto ParsePackageHeaderTypeExit;
	}

	//
	// find semicolon
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
	{
		goto ParsePackageHeaderTypeExit;
	}

	if (0 != lstrcmpiA(";",cToken))
	{
		goto ParsePackageHeaderTypeExit;
	}

	//
	// find "boundary"
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
	{
		goto ParsePackageHeaderTypeExit;
	}

	if (0 != lstrcmpiA(PACKAGE_BOUNDARY,cToken))
	{
		goto ParsePackageHeaderTypeExit;
	}

	//
	// find = sign
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
	{
		goto ParsePackageHeaderTypeExit;
	}

	if (0 != lstrcmpiA("=",cToken))
	{
		goto ParsePackageHeaderTypeExit;
	}

	//
	// find actual boundary
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH,TRUE))
	{
		goto ParsePackageHeaderTypeExit;
	}

	if (0 < lstrlenA(cToken))
	{
		pPHead->pcBoundary = new CHAR[lstrlenA(cToken)+1];
		if (NULL != pPHead->pcBoundary)
		{
			lstrcpyA(pPHead->pcBoundary ,cToken);
			bRC = TRUE;
		}
	}

ParsePackageHeaderTypeExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParsePackageHeaderLength(CTVEBuffer * pBuffer, CPackage_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParsePackageHeaderLength"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];
	LONG lTemp;

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto ParsePackageHeaderLengthExit;
	}

	//
	// find the length
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
	{
		goto ParsePackageHeaderLengthExit;
	}

	lTemp = atol(cToken);
	if (0 < lTemp)
	{
		pPHead->ulLength = lTemp;
		bRC = TRUE;
	}

ParsePackageHeaderLengthExit:
	return bRC;
}

BOOL ParsePackageHeaderExpires(CTVEBuffer * pBuffer, CPackage_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParsePackageHeaderExpires"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];
	CComVariant v;

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto PParsePackageHeaderExpiresExit;
	}

	//
	// find the length
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH,TRUE))
	{
		goto PParsePackageHeaderExpiresExit;
	}
				// need to parse strings like "Mon, 06 Oct 2003 07:55:30 GMT"
	DATE dateExpired;
	BOOL fOk = ParseDate(cToken, &dateExpired);
	if (!fOk)
	{
		goto PParsePackageHeaderExpiresExit;
	}

	pPHead->dateExpires = dateExpired;
	bRC = TRUE;

PParsePackageHeaderExpiresExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParsePackageHeaderBase(CTVEBuffer * pBuffer, CPackage_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParsePackageHeaderBase"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];
	CComVariant v;

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto ParsePackageHeaderBaseExit;
	}

	//
	// find content base
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH,TRUE))
	{
		goto ParsePackageHeaderBaseExit;
	}

	if (0 < lstrlenA(cToken))
	{
		pPHead->pcContent_Base = new CHAR[lstrlenA(cToken)+1];
		if (NULL != pPHead->pcContent_Base)
		{
			lstrcpyA(pPHead->pcContent_Base ,cToken);
			bRC = TRUE;
		}
	}

ParsePackageHeaderBaseExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParsePackageHeader(CPackage_Header *pHeader, CTVEBuffer *pBuffer)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParsePackageHeader"));
	BOOL bRC = FALSE;
	BOOL bEndOfHeader = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];
	INT idx;
	BOOL bFoundCRLF = FALSE;

	Parsing_Map pMap[] = {
		{"Content-type",ParsePackageHeaderType},
		{"Content-length",ParsePackageHeaderLength},
		{"Content-base",ParsePackageHeaderBase},
		{"Expires",ParsePackageHeaderExpires}
	};

	while (FALSE == bEndOfHeader)
	{
		if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
		{
			bEndOfHeader = TRUE;
		}
		else
		{

			//
			// Check for the double CRLF at the end of the header
			//
			if (0 == lstrcmpA(CRLF,cToken))
			{
				if (TRUE == bFoundCRLF)
				{
					//
					// Found the second CRLF
					//
					bEndOfHeader = TRUE;
				}
				else
				{
					//
					// Found the first CRLF
					//
					bFoundCRLF = TRUE;
				}
			}
			else
			{
				bFoundCRLF = FALSE;
			}

			//
			// Identify and parse header
			//
			for (idx = 0; idx < (sizeof(pMap) / sizeof(Parsing_Map)); idx++)
			{			/// This comparison is not case sensitive
				if (0 == lstrcmpiA(pMap[idx].sHeader,cToken))
				{
					bRC = (*pMap[idx].func)(pBuffer,pHeader);
					break;
				}
			}
		}
	};

	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParseSectionHeaderLength(CTVEBuffer * pBuffer, CSection_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParseSectionHeaderLength"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];
	LONG lTemp;

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto ParseSectionHeaderLengthExit;
	}

	//
	// find the length
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
	{
		goto ParseSectionHeaderLengthExit;
	}

	lTemp = atol(cToken);
	if (0 < lTemp)
	{
		pPHead->ulLength = lTemp;
		bRC = TRUE;
	}

ParseSectionHeaderLengthExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParseSectionHeaderType(CTVEBuffer * pBuffer, CSection_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParseSectionHeaderType"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto ParseSectionHeaderTypeExit;
	}

	//
	// find type string
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
	{
		goto ParseSectionHeaderTypeExit;
	}

	if (0 < lstrlenA(cToken))
	{
		pPHead->pcType = new CHAR[lstrlenA(cToken)+1];
		if (NULL != pPHead->pcType)
		{
			lstrcpyA(pPHead->pcType ,cToken);
			bRC = TRUE;
		}
	}

ParseSectionHeaderTypeExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParseSectionHeaderLanguage(CTVEBuffer * pBuffer, CSection_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParseSectionHeaderLanguage"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto ParseSectionHeaderLanguageExit;
	}

	//
	// find language
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
	{
		goto ParseSectionHeaderLanguageExit;
	}

	if (0 < lstrlenA(cToken))
	{
		pPHead->pcLanguage = new CHAR[lstrlenA(cToken)+1];
		if (NULL != pPHead->pcLanguage)
		{
			lstrcpyA(pPHead->pcLanguage ,cToken);
			bRC = TRUE;
		}
	}
ParseSectionHeaderLanguageExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParseSectionHeaderLocation(CTVEBuffer * pBuffer, CSection_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParseSectionHeaderLocation"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto ParseSectionHeaderLocationExit;
	}

	//
	// find location
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH,TRUE))
	{
		goto ParseSectionHeaderLocationExit;
	}

	if (0 < lstrlenA(cToken))
	{
		pPHead->pcLocation = new CHAR[lstrlenA(cToken)+1];
		if (NULL != pPHead->pcLocation)
		{
			lstrcpyA(pPHead->pcLocation ,cToken);
			bRC = TRUE;

			Dprintf("Content-Location: %s",cToken);
		}
	}
ParseSectionHeaderLocationExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParseSectionHeaderStyleType(CTVEBuffer * pBuffer, CSection_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParseSectionHeaderStyleType"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto ParseSectionHeaderStyleTypeExit;
	}

	//
	// find style type string
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
	{
		goto ParseSectionHeaderStyleTypeExit;
	}

	if (0 < lstrlenA(cToken))
	{
		pPHead->pcStyleType = new CHAR[lstrlenA(cToken)+1];
		if (NULL != pPHead->pcStyleType)
		{
			lstrcpyA(pPHead->pcStyleType ,cToken);
			bRC = TRUE;
		}
	}
ParseSectionHeaderStyleTypeExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParseSectionHeaderEncoding(CTVEBuffer * pBuffer, CSection_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParseSectionHeaderEncoding"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto ParseSectionHeaderEncodingExit;
	}

	//
	// find encoding
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
	{
		goto ParseSectionHeaderEncodingExit;
	}

	if (0 < lstrlenA(cToken))
	{
		pPHead->pcEncoding = new CHAR[lstrlenA(cToken)+1];
		if (NULL != pPHead->pcEncoding)
		{
			lstrcpyA(pPHead->pcEncoding ,cToken);
			bRC = TRUE;
		}
	}
ParseSectionHeaderEncodingExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParseSectionHeaderDate(CTVEBuffer * pBuffer, CSection_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParseSectionHeaderDate"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];
	CComVariant v;

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto ParseSectionHeaderDateExit;
	}

	//
	// find date string
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH,TRUE))
	{
		goto ParseSectionHeaderDateExit;
	}

	v = cToken;

	if (FAILED(v.ChangeType(VT_DATE,NULL)))
	{
		goto ParseSectionHeaderDateExit;
	}

	pPHead->dDate = v.date;
	bRC = TRUE;

ParseSectionHeaderDateExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParseSectionHeaderExpires(CTVEBuffer * pBuffer, CSection_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParseSectionHeaderExpires"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];
	CComVariant v;

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto ParseSectionHeaderExpiresExit;
	}

	//
	// find date string
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH,TRUE))
	{
		goto ParseSectionHeaderExpiresExit;
	}

				// need to parse strings like "Mon, 06 Oct 2003 07:55:30 GMT"
	DATE dateExpired;
	BOOL fOk = ParseDate(cToken, &dateExpired);
	if (!fOk)
	{
		goto ParseSectionHeaderExpiresExit;
	}

	pPHead->dExpires = dateExpired;
	bRC = TRUE;

ParseSectionHeaderExpiresExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParseSectionHeaderLastModified(CTVEBuffer * pBuffer, CSection_Header* pPHead)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParseSectionHeaderLastModified"));
	BOOL bRC = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];
	CComVariant v;

	//
	// find colon
	//
	if (FALSE == VerifyColon(pBuffer))
	{
		goto ParseSectionHeaderLastModifiedExit;
	}

	//
	// find date string
	//
	if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH,TRUE))
	{
		goto ParseSectionHeaderLastModifiedExit;
	}

	v = cToken;

	if (FAILED(v.ChangeType(VT_DATE,NULL)))
	{
#ifndef ALLOW_FUZZY_ATVEF
		goto ParseSectionHeaderLastModifiedExit;
#else
		DATE dateNTP = ISOTimeToDate(cToken,/*zulu*/ true);
		v = dateNTP;
#endif
	}

	pPHead->dLastModified = v.date;
	bRC = TRUE;

ParseSectionHeaderLastModifiedExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ParseSectionHeader(CSection_Header *pHeader, CTVEBuffer *pBuffer)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ParseSectionHeader"));
	BOOL bRC = FALSE;
	BOOL bEndOfHeader = FALSE;
	CHAR cToken[MAX_TOKEN_LENGTH];
	INT idx;
	BOOL bFoundCRLF = FALSE;

	Parsing_Map2 pMap[] = {
		{"Content-type",ParseSectionHeaderType},
		{"date",ParseSectionHeaderDate},
		{"expires",ParseSectionHeaderExpires},
		{"Last-Modified",ParseSectionHeaderLastModified},
		{"Content-Language",ParseSectionHeaderLanguage},
		{"Content-Location",ParseSectionHeaderLocation},
		{"Content-Style-Type",ParseSectionHeaderStyleType},
		{"Content-encoding",ParseSectionHeaderEncoding},
		{"Content-length",ParseSectionHeaderLength},
	};

	while (FALSE == bEndOfHeader)
	{
		if (FALSE == GetNextToken(pBuffer,cToken,MAX_TOKEN_LENGTH))
		{
			bEndOfHeader = TRUE;
		}
		else
		{
			//
			// Check for the double CRLF at the end of the header
			//
			if (0 == lstrcmpA(CRLF,cToken))
			{
				if (bFoundCRLF)
				{
					//
					// Found the second CRLF
					//
                    bEndOfHeader = TRUE;
                }
                else
                {
                    //
                    // Found the first CRLF
                    //
                    bFoundCRLF = TRUE;
                }
            }
            else
            {
                bFoundCRLF = FALSE;
            }

            //
            // Identify and parse header
            //
            for (idx = 0; idx < (sizeof(pMap) / sizeof(Parsing_Map)); idx++)
            {
                if (0 == lstrcmpiA(pMap[idx].sHeader,cToken))
                {
                    bRC = (*pMap[idx].func)(pBuffer,pHeader);
                    break;
                }
            }
        }
    };

    return bRC;
}
/////////////////////////////////////////////////////////////////////////////
//
//	Called by UHTTP_Package::Unpack(), which calls through supervisor::UnpackBuffer()
//		::UnpackBuffer, and finally ::ExtractContents.


BOOL GetCacheFile(CSection_Header* pHeader, CCachedFile*& pCachedFile)
{
    try{
        USES_CONVERSION;

        DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::GetCacheFile"));
        FILETIME ftExpires, ftLastModified;

        SYSTEMTIME stime;

        ZeroMemory(&ftExpires,sizeof(ftExpires));
        if (VariantTimeToSystemTime(pHeader->dExpires,&stime))
        {
            if (FALSE == SystemTimeToFileTime(&stime,&ftExpires))
            {
                ZeroMemory(&ftExpires,sizeof(ftExpires));
            }
        }

        ZeroMemory(&ftLastModified,sizeof(ftLastModified));
        if (VariantTimeToSystemTime(pHeader->dLastModified,&stime))
        {
            if (FALSE == SystemTimeToFileTime(&stime,&ftLastModified))
            {
                ZeroMemory(&ftLastModified,sizeof(ftLastModified));
            }
        }

        return (S_OK == g_CacheManager.OpenCacheFile(
            A2T(pHeader->pcLocation),
            pHeader->ulFullContentSize,
            ftExpires,
            ftLastModified,
            A2T(pHeader->pcLanguage),
            A2T(pHeader->pcType),
            pCachedFile));
    }
    catch(...){
        return false;           // things failed...
    }
}

BOOL NotifyCacheFile(IUnknown *pTVEVariation, CSection_Header* pHeader, CCachedFile*& pCachedFile, ULONG ulError)
{
    try{
        DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::NotifyCacheFile"));
        USES_CONVERSION;

        LPCTSTR szName;
        pCachedFile->GetName(&szName);
        CComBSTR spbsLoc(pHeader->pcLocation); 
        CComBSTR spbsName(szName); 


        ITVEVariationPtr	spVariation(pTVEVariation);


        // notify the U/I we have a new file
        HRESULT hr;
        if(NULL != g_CacheManager.m_pTVESuper) 
        {
            ITVESupervisor_HelperPtr spSuperHelper(g_CacheManager.m_pTVESuper); // don't really like this...

            if(NULL != spSuperHelper && NULL != spVariation)
                if(S_OK == ulError)
                {
                    hr = spSuperHelper->NotifyFile(NFLE_Received, spVariation, spbsLoc, spbsName);
                }
                else {
                    const int kChars=256;
                    WCHAR wbuff[kChars]; wbuff[kChars-1]=0;
                    CComBSTR spbsBuff;
                    spbsBuff.LoadString(IDS_AuxInfo_ErrorDecodingMIMEFile); //" *** Error Decoding MIME File: %s"
                    wnsprintf(wbuff,kChars-1,A2W(pHeader->pcLocation));
                    hr = spSuperHelper->NotifyAuxInfo(NWHAT_Data, wbuff, 0, 0);
                }
        }
        // simply ignore hr here, the Notifies returned by Notify don't mean much
        hr = S_OK;
        // add the file to the expire queue...
        //  (do after the FLE_Received notice, since out of date files may quickly expire.)
        if(S_OK == ulError && NULL != spVariation)
        {
            ITVEServicePtr spServi;
            hr = spVariation->get_Service(&spServi);
            ITVEService_HelperPtr spServiHelper(spServi);
            if(!FAILED(hr) && NULL != spServiHelper)
            {
                // create a ITVEFile object for the ExpireQueue to hold this file
                CComObject<CTVEFile> *pTVEFile;
                hr = CComObject<CTVEFile>::CreateInstance(&pTVEFile);
                if(!FAILED(hr))
                {
                    ITVEFilePtr spTVFile;
                    hr = pTVEFile->QueryInterface(&spTVFile);		
                    if(FAILED(hr)) {
                        delete pTVEFile;
                        _ASSERT(false);
                    } else {
                        DATE dateExpires = pHeader->dExpires;
                        if(dateExpires == 0.0)
                            dateExpires = 	DateNow() + 1.0;							// expire in 1 day if not set.
                        hr = spTVFile->InitializeFile(spVariation, spbsName, spbsLoc, dateExpires);
                        if(!FAILED(hr))
                            spServiHelper->AddToExpireQueue(dateExpires, spTVFile);
                    }
                }
            }
        }


        return TRUE;
    }
    catch(...){
        return FALSE;
    }
}
/////////////////////////////////////////////////////////////////////////////
BOOL FindFullSize(CSection_Header* pHeader, CTVEBuffer *pBuffer)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::FindFullSize"));
	BOOL bRC = FALSE;
	BYTE byte;

	//
	// See if we can find the uncompressed length information
	//
/*	if (pHeader->ulLength > 4)
	{
		if (FALSE == pBuffer->GetByteAtOffset(pHeader->ulLength - 4,&byte))		// PBUG - Backwards?
		{
			goto FindFullSizeExit;
		}
		pHeader->ulFullContentSize = byte << 24;

		if (FALSE == pBuffer->GetByteAtOffset(pHeader->ulLength - 3,&byte))
		{
			goto FindFullSizeExit;
		}
		pHeader->ulFullContentSize += byte << 16;

		if (FALSE == pBuffer->GetByteAtOffset(pHeader->ulLength - 2,&byte))
		{
			goto FindFullSizeExit;
		}
		pHeader->ulFullContentSize += byte << 8;

		if (FALSE == pBuffer->GetByteAtOffset(pHeader->ulLength - 1,&byte))
		{
			goto FindFullSizeExit;
		}
		pHeader->ulFullContentSize += byte;

		bRC = TRUE;
	}
*/

	if (pHeader->ulLength > 4)
	{
		if (FALSE == pBuffer->GetByteAtOffset(pHeader->ulLength - 1,&byte))		// PBUG - Byte order backward
		{
			goto FindFullSizeExit;
		}
		pHeader->ulFullContentSize = byte << 24;

		if (FALSE == pBuffer->GetByteAtOffset(pHeader->ulLength - 2,&byte))
		{
			goto FindFullSizeExit;
		}
		pHeader->ulFullContentSize += byte << 16;

		if (FALSE == pBuffer->GetByteAtOffset(pHeader->ulLength - 3,&byte))
		{
			goto FindFullSizeExit;
		}
		pHeader->ulFullContentSize += byte << 8;

		if (FALSE == pBuffer->GetByteAtOffset(pHeader->ulLength - 4,&byte))
		{
			goto FindFullSizeExit;
		}
		pHeader->ulFullContentSize += byte;

		bRC = TRUE;
	}

FindFullSizeExit:
	return bRC;
}

BOOL 
FindCRC(CSection_Header* pHeader, CTVEBuffer *pBuffer, ULONG *pcrc)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::FindCRC"));
	BOOL bRC = FALSE;
	BYTE byte;
	ULONG crc = 0;

	if (pHeader->ulLength > 4)
	{
		if (FALSE == pBuffer->GetByteAtOffset(pHeader->ulLength - 5,&byte))		// PBUG - Byte order backward
		{
			goto FindCRCExit;
		}
		crc = byte << 24;

		if (FALSE == pBuffer->GetByteAtOffset(pHeader->ulLength - 6,&byte))
		{
			goto FindCRCExit;
		}
		crc += byte << 16;

		if (FALSE == pBuffer->GetByteAtOffset(pHeader->ulLength - 7,&byte))
		{
			goto FindCRCExit;
		}
		crc += byte << 8;

		if (FALSE == pBuffer->GetByteAtOffset(pHeader->ulLength - 8,&byte))
		{
			goto FindCRCExit;
		}
		crc += byte;

		bRC = TRUE;
	}

FindCRCExit:
	if(*pcrc) *pcrc = crc;
	return bRC;
}
/////////////////////////////////////////////////////////////////////////////
BOOL VerifyGZipHeader(CTVEBuffer *pBuffer, long *plBytesHeader)			// Major GZIP bug... Handle flags...
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::VerifyGZipHeader"));
	BOOL bRC = TRUE;
	BYTE byte = 0;
	INT idx = 0;
	if(plBytesHeader) *plBytesHeader = 0;

	struct GZipHead
	{
		BYTE bMagic1;				// 0x1f,	// magic number
		BYTE bMagic2;				// 0x8B,	// magic number
		BYTE bCompression;			// 0x08,	// deflate compression
		BYTE bFlags;				// 0x00,	// flags
		BYTE bTime0;				// 0x00,	// file modification time
		BYTE bTime1;				// 0x00,	// file modification time
		BYTE bTime2;				// 0x00,	// file modification time
		BYTE bTime3;				// 0x00,	// file modification time
		BYTE bExtraFlags;			// 0x00,	// extra flags (for compression)
		BYTE bOSType;				// 0x0B};	// OS type 0x0B = Win32
	};


	CHAR szBuff[sizeof(GZipHead)];
	GZipHead *pgzHead = (GZipHead *) szBuff;

	if(pBuffer->GetCurByte(&byte)) {
		szBuff[idx++] = byte;
	} else {
		DBG_WARN(CDebugLog::DBG_SEV2, _T("*** VerifyGZipHeader Failed - Bad first Byte"));
		return FALSE;
	}

	while(pBuffer->GetNextByte(&byte) && idx < sizeof(GZipHead))
	{
		szBuff[idx++] = byte;
	}

	if(idx != sizeof(GZipHead))
	{
		DBG_WARN(CDebugLog::DBG_SEV2, _T("*** VerifyGZipHeader Failed - Wrong Length"));
		return FALSE;
	}

	if(0x1f != pgzHead->bMagic1 ||
	   0x8B != pgzHead->bMagic2 ||
	   0x08 != pgzHead->bCompression)
	{
		DBG_WARN(CDebugLog::DBG_SEV2, _T("*** VerifyGZipHeader Failed - Invalid Magic or Compression"));
		return FALSE;
	}

	long cBytesHeader = sizeof(GZipHead);
	if(0 != pgzHead->bFlags)
	{
		BOOL ftext    = (pgzHead->bFlags & 0x01) != 0;
		BOOL fhcrc    = (pgzHead->bFlags & 0x02) != 0;
		BOOL fextra   = (pgzHead->bFlags & 0x04) != 0;
		BOOL fname    = (pgzHead->bFlags & 0x08) != 0;
		BOOL fcomment = (pgzHead->bFlags & 0x10) != 0;
		BOOL fother   = (pgzHead->bFlags & ~(0x1F)) != 0;

		if(fother)		
		{																//  see RFC 1952
			DBG_WARN(CDebugLog::DBG_SEV2, _T("*** VerifyGZipHeader Failed - Unsupported Bits"));
			return FALSE;
		}
		
		if(fextra)
		{
			unsigned long cBytes=0;
			if(!pBuffer->GetNextByte(&byte)) 
				bRC = FALSE;
			cBytes = byte;							// stored lsb first
			if(!bRC || !pBuffer->GetNextByte(&byte))
				bRC = FALSE;
			cBytes |= (byte<<8);

			for(int i = 0; i < cBytes && bRC; i++)	// skip over all this data
			{
				if(!pBuffer->GetNextByte(&byte))
					bRC = FALSE;
			}
			if(!bRC) {
				DBG_WARN(CDebugLog::DBG_SEV2, _T("*** VerifyGZipHeader Failed - Invalid Extra Field"));
				return FALSE;
			}
			cBytesHeader += (2 + cBytes);
		}

		if(fname)
		{
			while((bRC = pBuffer->GetNextByte(&byte)) && byte != 0)
			{
				cBytesHeader++;
			};
			if(!bRC) {
				DBG_WARN(CDebugLog::DBG_SEV2, _T("*** VerifyGZipHeader Failed - FName"));
				return FALSE;
			}
			cBytesHeader++;		// count the trailing zero byte
		}

		if(fcomment)
		{
			while((bRC = pBuffer->GetNextByte(&byte)) && byte != 0)
			{
				cBytesHeader++;
			};
			if(!bRC) {
				DBG_WARN(CDebugLog::DBG_SEV2, _T("*** VerifyGZipHeader Failed - FComment"));
				return FALSE;
			}	
			cBytesHeader++;		// count the trailing zero byte
		}

		if(fhcrc)						// note - not implementing this check
		{	
			bRC = pBuffer->GetNextByte(&byte);
			if(bRC) bRC = pBuffer->GetNextByte(&byte);
			if(!bRC) {
				DBG_WARN(CDebugLog::DBG_SEV2, _T("*** VerifyGZipHeader Failed - FCRC"));
				return FALSE;
			}
			cBytesHeader += 2;
		}


	}

	if(plBytesHeader) *plBytesHeader = cBytesHeader;
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL ExtractContent(IUnknown *pVariation, CSection_Header* pHeader, CTVEBuffer *pBuffer)
{
    try{
        DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::ExtractContent"));
        BOOL bRC = FALSE;
        z_stream stream;
        INT iRC = 0;
        LPBYTE lpvOutBuffer = NULL;
        HANDLE hFile = INVALID_HANDLE_VALUE;
        DWORD dwWritten = 0;
        CCachedFile* pCachedFile = NULL;
        //int iInflateFlag = 0;

        ULONG crc = crc32(0, Z_NULL, 0);
        ULONG crcTest = -1;

		BOOL fActuallyGZipped = (pHeader->pcEncoding != NULL && 0 == lstrcmpiA(pHeader->pcEncoding,GZIP_ENCODING));

#ifdef ALLOW_FUZZY_ATVEF
		if(!fActuallyGZipped)
		{
            BYTE* lpStart = pBuffer->GetCurrent();
         	long cBytesHeader;
            BOOL fB = FindFullSize(pHeader, pBuffer);					// Read Size, CRC from end of compressed area		
            if(fB) fB = FindCRC(pHeader, pBuffer, &crcTest);
            if(fB) fB = VerifyGZipHeader(pBuffer, &cBytesHeader);		
            if(fB) fActuallyGZipped = true;

            ULONG lpOffset = pBuffer->GetCurrent() - lpStart;

            pBuffer->SetCurrent(lpStart);                                 // back to the begining 
  		}
#endif

        if (fActuallyGZipped)
        {
            DBG_WARN(CDebugLog::DBG_MIME,_T("\t\t-Contents are compressed"));
            //
            // Get the uncompressed size
            //

            long cBytesHeader;
            BOOL fB = FindFullSize(pHeader, pBuffer);					// Read Size, CRC from end of compressed area		
            if(fB) fB = FindCRC(pHeader, pBuffer, &crcTest);
            if(fB) fB = VerifyGZipHeader(pBuffer, &cBytesHeader);		// GZip Bug - possibly different sized headers	(bumps current address)		
            if(fB)
            {
                //
                // Allocate output
                //

                lpvOutBuffer = new BYTE[OUTPUT_BUFFER_SIZE];
                if ((NULL != lpvOutBuffer) &&
                    (GetCacheFile(pHeader, pCachedFile)))
                {
                    _ASSERT(NULL != pCachedFile);
                    ZeroMemory(&stream,sizeof(stream));

                    //
                    // Take into account the four byte for the uncompressed size at the
                    // end of the data and header at begining.
                    //
                    stream.avail_in = pHeader->ulLength - 4 - cBytesHeader;		// GZip Bug  - need better header size
                    stream.next_in = pBuffer->GetCurrent();

                    stream.next_out = lpvOutBuffer;
                    stream.avail_out = OUTPUT_BUFFER_SIZE;

                    //	iRC = inflateInit(&stream);			// GZip BUG
                    iRC = inflateInit2(&stream, -DEF_WBITS);
                    if (Z_OK == iRC)
                    {
                        //iInflateFlag = Z_PARTIAL_FLUSH;
                        do
                        {
                            //iRC = inflate(&stream,iInflateFlag);
                            iRC = inflate(&stream,Z_PARTIAL_FLUSH);

                            if (Z_OK == iRC || Z_STREAM_END == iRC)
                            {
                                crc = crc32(crc, lpvOutBuffer, OUTPUT_BUFFER_SIZE-stream.avail_out);
                                //
                                // check for writable output
                                //
                                if (stream.avail_out < OUTPUT_BUFFER_SIZE)
                                {
                                    if (FALSE == WriteFile(pCachedFile->Handle( ),
                                        lpvOutBuffer,
                                        (OUTPUT_BUFFER_SIZE-stream.avail_out),
                                        &dwWritten,NULL))
                                    {
                                        break;
                                    }
                                    stream.next_out = lpvOutBuffer;
                                    stream.avail_out = OUTPUT_BUFFER_SIZE;
                                }
                            }

                        } while (stream.total_in < (pHeader->ulLength - 4 - cBytesHeader) && S_OK == iRC);	// GZIP bug 

                        if (Z_STREAM_END == iRC)
                        {
                            bRC = pBuffer->MoveTo(pHeader->ulLength - cBytesHeader);						// GZIP bug 
                        }
                    }

                    // PBUG - don't handle bad iRC from inflateInit
                    delete [] lpvOutBuffer;
                    lpvOutBuffer = NULL;

                    int iRC2 = inflateEnd(&stream);
                    pCachedFile->Close( );

                    {											// debug message stuff
                        USES_CONVERSION;
                        TCHAR *tBuff = A2T(pHeader->pcLocation);
                        DBG_WARN(CDebugLog::DBG_MIME, tBuff);
                    }

                    if(Z_STREAM_END == iRC) iRC = Z_OK;

                    if(Z_OK != iRC || Z_OK != iRC2)
                    {
                        DBG_WARN(CDebugLog::DBG_MIME,_T("\t\t-Error un zipping compressed file"));
                    }
                    if(crc != crcTest)
                    {
                        DBG_WARN(CDebugLog::DBG_MIME,_T("\t\t-CRC error in compressed file"));
                    }

                    fB = (Z_OK == iRC && Z_OK == iRC2 && crc == crcTest);
                }

                // tell the world about it...
                NotifyCacheFile(pVariation, pHeader, pCachedFile, fB ? S_OK : S_FALSE);

                bRC = fB;	
            }
        }
        else
        {
            DBG_WARN(CDebugLog::DBG_MIME,_T("\t\t-Contents not compressed"));
            //
            // Not compressed
            //
            pHeader->ulFullContentSize = pHeader->ulLength;
            if (GetCacheFile(pHeader, pCachedFile))
            {
                _ASSERT(NULL != pCachedFile);

                if (WriteFile(pCachedFile->Handle( ),
                    pBuffer->GetCurrent(),
                    pHeader->ulLength,
                    &dwWritten,
                    NULL))
                {
                    bRC = pBuffer->MoveTo(pHeader->ulLength);
                }

                pCachedFile->Close();

                NotifyCacheFile(pVariation, pHeader, pCachedFile, 0);
            }
        }
        return bRC;
    }
    catch(...){
        return FALSE;
    }
}

/////////////////////////////////////////////////////////////////////////////
HRESULT UnpackBuffer(IUnknown *pVariation, LPBYTE pBuffer, ULONG ulSize)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("MIME::UnpackBuffer"));
	HRESULT hr = E_FAIL;

	//
	// Allocate objects
	//
	CTVEBuffer cContentBuffer(pBuffer,ulSize);
	CPackage_Header cPackageHeader;

	CSection_Header *pcSectionHeader = NULL;

	//
	// Parse the header
	//
	if (ParsePackageHeader(&cPackageHeader, &cContentBuffer))
	{
		do
		{
			pcSectionHeader = new CSection_Header;
			if (NULL == pcSectionHeader)
			{
				DBG_WARN(CDebugLog::DBG_SEV2, _T("MIME::Error allocating new CSection_Header"));
				break;
			}
									// default the files expire date to that of the package
			pcSectionHeader->dExpires = cPackageHeader.dateExpires;
			if (FALSE == cContentBuffer.FindBoundary(cPackageHeader.pcBoundary,FALSE))
			{
				//
				// Check for closing boundary
				//
				if (FALSE == cContentBuffer.FindBoundary(cPackageHeader.pcBoundary,TRUE))
				{
					DBG_WARN(CDebugLog::DBG_SEV3, _T("MIME::Final Boundary Located"));
					hr = S_OK;
				}
				break;
			}

			if (FALSE == ParseSectionHeader(pcSectionHeader, &cContentBuffer))
			{
				DBG_WARN(CDebugLog::DBG_SEV3, _T("MIME::ParseSectonHeader Failed"));
				break;
			}

			if (FALSE == ExtractContent(pVariation, pcSectionHeader, &cContentBuffer))
			{
				DBG_WARN(CDebugLog::DBG_SEV3, _T("MIME::ExtractContent Failed"));
				break;
			}

			if (FALSE == ValidateCRLFToken(&cContentBuffer))
			{
				DBG_WARN(CDebugLog::DBG_SEV3, _T("MIME::ValidateCRLFToken Failed"));
				break;
			}

			delete pcSectionHeader;
			pcSectionHeader = NULL;
		} while (1);
	}

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// CTVEBuffer 
CTVEBuffer::CTVEBuffer(LPBYTE pbStart, ULONG ulLength)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("CTVEBuffer::CTVEBuffer"));
	m_pbStart = pbStart;
	m_ulLength = ulLength;
	m_pbEnd = m_pbStart + ulLength;
	m_pbCurrent = pbStart;
	m_bMoreDataAvailable = (ulLength > 0);
}

BOOL CTVEBuffer::GetNextByte(BYTE *pbRC)
{
//    DBG_HEADER(CDebugLog::DBG_MIME, "CTVEBuffer:GetNextByte");
	BOOL bRC = FALSE;
	if ((NULL != pbRC) && ((m_pbCurrent+1) < m_pbEnd))
	{
		*pbRC = *(++m_pbCurrent);
		bRC = TRUE;
	}
	else
	{
		m_bMoreDataAvailable = FALSE;
	}
	return bRC;
}

BOOL CTVEBuffer::MoveTo(ULONG uOffset)
{
//    DBG_HEADER(CDebugLog::DBG_MIME, "CTVEBuffer:MoveTo");
	BOOL bRC = FALSE;
	if ((m_pbCurrent+uOffset) < m_pbEnd)
	{
		m_pbCurrent += uOffset;
		bRC = TRUE;
	}
	else
	{
		m_bMoreDataAvailable = FALSE;
	}
	return bRC;
}

BOOL CTVEBuffer::MoveNextByte()
{
//    DBG_HEADER(CDebugLog::DBG_MIME, "CTVEBuffer::MoveNextByte");
	return MoveTo(1);
}

BOOL CTVEBuffer::GetCurByte(LPBYTE pByte)
{
//    DBG_HEADER(CDebugLog::DBG_MIME, "CTVEBuffer::GetCurByte");
	if (m_bMoreDataAvailable && NULL != pByte)
	{
		*pByte = *m_pbCurrent;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CTVEBuffer::Copy(LPVOID pDest, ULONG uLen)
{
//    DBG_HEADER(CDebugLog::DBG_MIME, "CTVEBuffer::Copy");
	if (uLen > (ULONG)(m_pbEnd - m_pbCurrent))
	{
		return FALSE;
	}
	else
	{
		CopyMemory(pDest,m_pbCurrent,uLen);
		m_pbCurrent += uLen;
		return TRUE;
	}
}

BOOL CTVEBuffer::GetByteAtOffset(ULONG ulOffset,LPBYTE pByte)
{
//    DBG_HEADER(CDebugLog::DBG_MIME, "CTVEBuffer::GetByteAtOffset");
	if (( m_pbCurrent+ulOffset ) < m_pbEnd)
	{
		*pByte = m_pbCurrent[ulOffset];
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

///////////////////////////////////////////////////////////////////////////////

BOOL SkipWhiteSpace(CTVEBuffer *pBuffer)
{
//    DBG_HEADER(CDebugLog::DBG_MIME, "SkipWhiteSpace");
	BYTE byte;
	BOOL bRC = TRUE;

	//
	// Keep reading characters until there are no more spaces, or tabs.
	// Also stop when there are no more characters in the buffer
	//
	bRC = pBuffer->GetCurByte(&byte);
	while (bRC && (0x20 == byte || 0x09 == byte))
	{
		bRC = pBuffer->GetNextByte(&byte);			// j.b. 9/14/99  was '=='
	};
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL GetNextToken(CTVEBuffer *pBuffer, CHAR *pcToken, INT iLength, BOOL bScanToCRLF)
{
//    DBG_HEADER(CDebugLog::DBG_MIME, "GetNextToken");
	BOOL bRC = TRUE;
	BYTE bCurrent = 0;
	BOOL fQuit = FALSE;
	BOOL bQuoted = FALSE;

	enum TokenTypes {
		ttNone = 0x100,
		ttSingle,
		ttCRLF,
		ttText
	} eTType = ttNone;

	//
	// Validate Parameter
	//
	if (NULL == pcToken)
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		bRC = FALSE;
		goto GetNextTokenExit;
	}

	//
	// Check for leading white space
	//
	if (FALSE == pBuffer->GetCurByte(&bCurrent))
	{
		SetLastError(ERROR_NO_MORE_ITEMS);
		bRC = FALSE;
		goto GetNextTokenExit;
	}


	if (0x20 == bCurrent || 0x09 == bCurrent)
	{
		if (FALSE == SkipWhiteSpace(pBuffer))
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			bRC = FALSE;
			goto GetNextTokenExit;
		}
	}

	//
	// Read characters until we get to the end of a token
	//
	// Token types
	// ttSingle	found a single character token
	// ttCRLF	found a CR looking for a LF
	// ttText	found a string

	bRC = pBuffer->GetCurByte(&bCurrent);
	while (bRC && FALSE == fQuit)
	{
		//
		// Out of buffer space
		//
		if (0 == iLength)
		{
			fQuit = TRUE;
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		}
		else
		{
			switch (eTType)
			{
			case ttNone:
				*pcToken++ = bCurrent;
				iLength--;
				//
				// Single character token
				if (':' == bCurrent || 
					';' == bCurrent || 
					'=' == bCurrent || 
					',' == bCurrent)
				{
					eTType = ttSingle;
					fQuit = TRUE;
				}
				//
				// Check for start of CRLF
				//
				else if (0x0d == bCurrent)
				{
					eTType = ttCRLF;
				}
				//
				// Otherwise it is text
				//
				else
				{
					eTType = ttText;
					if ('"' == bCurrent)
					{
						bQuoted = TRUE;
						pcToken--;	// throw out the opening quote mark
					}
				}

				//
				// Move forward one character (if you can).
				//
				bRC = pBuffer->GetNextByte(&bCurrent);

				break;
			case ttCRLF:
				//
				// did we get the LF for the CR that we found?
				//
				if (0x0a == bCurrent)
				{
					*pcToken++ = bCurrent;
					iLength--;
					fQuit = TRUE;
					bRC = pBuffer->MoveNextByte();
				}
				else
				{
					//
					// CR not followed by a LF to token is illegal and ill formed.
					//
					fQuit = TRUE;
					bRC = FALSE;
				}
				break;
			case ttText:
				if (0x0d == bCurrent ||	// CR
					(!bScanToCRLF && (
					0x20 == bCurrent || // space
					0x09 == bCurrent ||	// tab
					';' == bCurrent || 
					'=' == bCurrent || 
					':' == bCurrent ||
					',' == bCurrent)))
				{
					//
					// We found the end of the string
					//
					fQuit = TRUE;

					if (bQuoted)
					{
						pcToken--; // throw out closing quote mark
					}
				}
				else
				{
					*pcToken++ = bCurrent;
					iLength--;
					bRC = pBuffer->GetNextByte(&bCurrent);
				}
				break;
			case ttSingle:
			default:
				break;
			}
		}
	}

	//
	// Fix return value for various type
	// This applies almost exclusively to the case where we read to the end of
	// the buffer
	//
	if (FALSE == bRC && (ttText == eTType || fQuit))
	{
		//
		// If we have a valid token then the end of file is a valid terminator
		//
		bRC = TRUE;
	}

	//
	// add NULL terminator
	//
	if (0 < iLength)
	{
		*pcToken = '\0'; 
	}

GetNextTokenExit:
	return bRC;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CTVEBuffer::FindBoundary(LPSTR lpstrBoundary, BOOL bEndBoundary)
{
    DBG_HEADER(CDebugLog::DBG_MIME, _T("CTVEBuffer::FindBoundary"));
	BOOL bRC = FALSE;
	LPBYTE lpNextStartingChar = NULL;
	LPSTR lpCurrentBChar = NULL;
	BOOL bMatchMode = FALSE;
	BOOL fQuit = FALSE;
	CHAR *pcFullBoundary = new CHAR[lstrlenA(lpstrBoundary) + 7];

	LPBYTE lpRestoreCurrentOnFailed = m_pbCurrent;

	if (NULL == pcFullBoundary)
	{
		//
		// not enough memory
		//
		return FALSE;
	}

	//
	// Create full boundar name with preceeding and post characters
	//
	if (bEndBoundary)
	{
		wsprintfA(pcFullBoundary,"--%s--",lpstrBoundary);
		DBG_WARN(CDebugLog::DBG_MIME,_T(" --Final Boundary--"));
	}
	else
	{
		wsprintfA(pcFullBoundary,"--%s\r\n",lpstrBoundary);
	}
	lpCurrentBChar = pcFullBoundary;

	while (m_pbCurrent < m_pbEnd && FALSE == fQuit)
	{
		//
		// To find the next starting point if the current search fails
		//
		if (bMatchMode)
		{
			if (NULL == lpNextStartingChar)
			{
				if (*(CHAR *)m_pbCurrent == *pcFullBoundary)
				{
					lpNextStartingChar = m_pbCurrent;
				}
			}

			//
			// Move to the next character of the boundary
			//
			lpCurrentBChar++;
		}

		//
		// Have we reached the end of the boundary?
		//
		if (NULL != *lpCurrentBChar)
		{
			//
			// Does the next character match
			//
			if (*(CHAR *)m_pbCurrent == *lpCurrentBChar)
			{
				bMatchMode = TRUE;
			}
			else
			{
				//
				// The characters do not match, reset the search
				//
				if (bMatchMode)
				{
					bMatchMode = FALSE;
					if (NULL != lpNextStartingChar)
					{
						m_pbCurrent = lpNextStartingChar;
						lpNextStartingChar = NULL;
					}
					lpCurrentBChar = pcFullBoundary;
				}
			}
			m_pbCurrent++;
		}
		else
		{
			//
			// End of boundary reached
			//
			bRC = bMatchMode;
			fQuit = TRUE;
		}
	};

	delete [] pcFullBoundary;

	if (FALSE == bRC)
	{
		m_pbCurrent = lpRestoreCurrentOnFailed;
	}

	return bRC;
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\tvevarias.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TVEVariations.h : Declaration of the CTVEVariations

#ifndef __TVEVARIATIONS_H_
#define __TVEVARIATIONS_H_

#include "resource.h"       // main symbols
#include "TVECollect.h"

/////////////////////////////////////////////////////////////////////////////
// CTVEVariations
class ATL_NO_VTABLE CTVEVariations : public TVECollection<ITVEVariation, ITVEVariations>,
	public ISupportErrorInfo
{
public:
	DECLARE_REGISTRY_RESOURCEID(IDR_TVEVARIATIONS);
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

#endif //__TVEVARIATIONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testevents2\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\uhttp.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.

//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MSTvE.h"

#include "UHTTP.h"
#include <mpegcrc.h>
#include "tveUnpak.h"

#include "TveDbg.h"
#include "TveReg.h"

#include "TVESuper.h"
#include "TveFile.h"
#include "DbgStuff.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

_COM_SMARTPTR_TYPEDEF(ITVEFile,					__uuidof(ITVEFile));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,		__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));

_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));

// --------------------
#ifdef UHTTP_TestHooks
#include "stdio.h"
#include "io.h"
#include "fcntl.h"
#include "sys\stat.h"

HRESULT DumpBuffer(REFIID uuid, BYTE *pb, ULONG cb);

class UHTTP_Dumper
{
public:
    UHTTP_Dumper()
        {
        DWORD flags;
		USES_CONVERSION;
		m_fEnabled = false;
        }
    
    HRESULT DumpBuffer(REFIID uuid, BYTE *pb, ULONG cb)
        {
		m_fEnabled = DBG_FSET2(CDebugLog::DBG2_DUMP_PACKAGES);
        return m_fEnabled ? ::DumpBuffer(uuid, pb, cb) : S_OK;
        }
    
    void SetEnabled(boolean fEnabled)
        {
        m_fEnabled = fEnabled;
        }

    boolean m_fEnabled;
};

UHTTP_Dumper g_dumper;

int g_iFileCur = -1;
TCHAR **g_rgszOutFileName;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
static DATE 
DateNow()
{		SYSTEMTIME SysTimeNow;
		GetSystemTime(&SysTimeNow);									// initialize with currrent time.
		DATE dateNow;
		SystemTimeToVariantTime(&SysTimeNow, &dateNow);
		return dateNow;
}

UHTTP_Receiver::UHTTP_Receiver()
{
    DBG_HEADER(CDebugLog::DBG_UHTTP, _T("UHTTP_Receiver::UHTTP_Receiver"));

    m_rgppackages = NULL;
    m_cPackages = 0;
    m_cPackagesMax = 0;
	m_cSecLastPurge = 0;
}

UHTTP_Receiver::~UHTTP_Receiver()
{
    DBG_HEADER(CDebugLog::DBG_UHTTP, _T("UHTTP_Receiver::~UHTTP_Receiver"));

    // Free all the pending packages.
    for (int i = 0; i < m_cPackages; i++)
        {
        if (m_rgppackages[i] != NULL)
            {
            delete m_rgppackages[i];
            m_rgppackages[i] = NULL;
            }
        }
    
    if (m_rgppackages != NULL)
        delete [] m_rgppackages;
}

				// pTVESupervisor pointer used in call when actually create full package
HRESULT UHTTP_Receiver::NewPacket(int cbPacket, UHTTP_Packet *ppacket, IUnknown *pTVEVariation)
{
    DBG_HEADER(CDebugLog::DBG_UHTTP, _T("UHTTP_Receiver::NewPacket"));

    if (ppacket->Version() != 0)
        return E_INVALIDARG;

    HRESULT hr;
    UUID uuid;
    ppacket->GetResourceID(&uuid);
    UHTTP_Package *ppackage = FindPackage(uuid);

    if (ppackage == NULL)
        {
        // Create a new package.
        ppackage = new UHTTP_Package(uuid, pTVEVariation);
        if (ppackage == NULL)
            {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Out of memory allocating UHTTP_Package."));
            return E_OUTOFMEMORY;
            }
        hr = AddPackage(ppackage);
        if (FAILED(hr))
            {
            delete ppackage;
            return hr;
            }
        }
    
    hr = ppackage->NewPacket(cbPacket, ppacket);
    if (FAILED(hr))
        {
        //UNDONE: What to do?  Assume it was just this packet in error?
        //UNDONE  Assume this packet is good, and some previous packet was bad?
        }

    // Purge anything that will not receive any more packets.
			// don't really want to do this here, but rather via the expire queue.
			// -- however, that's on a different thread I suspect...
    ULONG cSecNow = time(NULL);
	if(cSecNow - m_cSecLastPurge > 5)
	{
		PurgeExpiredPackages();
		m_cSecLastPurge = cSecNow;
	}
    
    return S_OK;
}

UHTTP_Package * UHTTP_Receiver::FindPackage(UUID & uuid)
{
    DBG_HEADER(CDebugLog::DBG_UHTTP, _T("UHTTP_Receiver::FindPackage"));

    //TODO: Better algorithm than linear search?
    for (int i = 0; i < m_cPackages; i++)
        {
        if (uuid == m_rgppackages[i]->GetUUID())
            return m_rgppackages[i];
        }
    
    return NULL;
}

// simple little test routine that dumps out all packets in packages when:
//		- the package is not complete
//		- and the number of packets in the package is different than last time we looked... 

HRESULT UHTTP_Receiver::DumpPackagesWithMissingPackets(DWORD mode)
{
    DBG_HEADER(CDebugLog::DBG_UHTTP, _T("UHTTP_Receiver::DumpPackagesWithMissingPackets"));

	if(!DBG_FSET(CDebugLog::DBG2_DUMP_MISSPACKET))
		return S_OK;

    for (int i = 0; i < m_cPackages; i++)
    {
		ULONG cTotalPackets;
		ULONG cMissingPackets;
		if(!m_rgppackages[i]->ReceivedOk() || !m_rgppackages[i]->DumpedAtLeastOnce())
		{
			m_rgppackages[i]->DumpMissingPackets(&cTotalPackets, &cMissingPackets);
		}
    }
    
    return S_OK;
}

HRESULT UHTTP_Receiver::AddPackage(UHTTP_Package *ppackage)
{
    DBG_HEADER(CDebugLog::DBG_UHTTP, _T("UHTTP_Receiver::AddPackage"));

	DumpPackagesWithMissingPackets(0);		// for the fun of it..

    if (m_cPackages == m_cPackagesMax)
        {
        UHTTP_Package **rgppackages = new UHTTP_Package * [m_cPackagesMax + 10];
        if (rgppackages == NULL)
            {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Out of memory in AddPackage()."));
            return E_OUTOFMEMORY;
            }

        if (m_rgppackages != NULL)
            {
            memcpy(rgppackages, m_rgppackages, m_cPackagesMax*sizeof(UHTTP_Package *));
            delete [] m_rgppackages;
            }
        m_rgppackages = rgppackages;
        m_cPackagesMax += 10;
        }

    m_rgppackages[m_cPackages++] = ppackage;

    return S_OK;
}

HRESULT UHTTP_Receiver::PurgeExpiredPackages()
{
    DBG_HEADER(CDebugLog::DBG_UHTTP, _T("UHTTP_Receiver::PurgeExpiredPackages"));

    ULONG cSecNow = time(NULL);

    UHTTP_Package **pppackageSrc = m_rgppackages;
    UHTTP_Package **pppackageDst = pppackageSrc;
    int cPackages = m_cPackages;

    while (cPackages--)
		{
		if ((*pppackageSrc)->FExpired(cSecNow))
           {

				HRESULT hr = (*pppackageSrc)->RemoveFromExpireQueue();

				time_t timeNow = time(NULL);
				DATE dateExpires = (*pppackageSrc)->DateExpires();
				DATE dateNow = VariantTimeFromTime(timeNow);

				CComBSTR bstrDate = DateToDiffBSTR(dateExpires);
				CComBSTR bstrNow = DateToDiffBSTR(dateNow);

 				DBG_WARN(CDebugLog::DBG_SEV3,_T( "Purging expired package."));
 				ITVESupervisor_HelperPtr spSuperHelper;
				hr = (*pppackageSrc)->get_SupervisorHelper(&spSuperHelper);		// wonder if this is marshelled correctly?
				_ASSERT(spSuperHelper != NULL);
				if(S_OK == hr && NULL != spSuperHelper)
				{

					WCHAR wzBuff[128];
					LPOLESTR polestr;
					UUID uuid = (*pppackageSrc)->GetUUID();
					StringFromCLSID(ntoh_uuid(uuid), &polestr);
					swprintf(wzBuff,L"%s",polestr);
					CoTaskMemFree(polestr);

					ITVEVariationPtr spVar = (*pppackageSrc)->GetVariation();
					int nBytes = (*pppackageSrc)->IResourceSize();
					spSuperHelper->NotifyPackage(NPKG_Expired, spVar, wzBuff, nBytes, 0);
				} else {
					DBG_WARN(CDebugLog::DBG_SEV3, _T("Couldn't get SupervisorPtr - NotifyPackage Expire not done."));
				}

            delete *pppackageSrc;
            pppackageSrc++;
            m_cPackages--;
            }
        else if (pppackageSrc != pppackageDst)
            {
            *pppackageDst++ = *pppackageSrc++;
            }
        }
    
    return S_OK;
}

UHTTP_Package::~UHTTP_Package()
{
    DBG_HEADER(CDebugLog::DBG_UHTTP, _T("UHTTP_Package::~UHTTP_Package"));

#ifdef _DEBUG
    if (!m_fReceivedOk)
		DumpMissingPackets();
#endif
	if(m_pUnkTVEFilePackage)					// remove from the ExpireQueue
	{
		HRESULT hr = RemoveFromExpireQueue();
	}
	m_pUnkTVEFilePackage = NULL;				// a non ref-counted back pointer...

    if (m_rgbData != NULL)
        CoTaskMemFree((void *) m_rgbData);
    if (m_rgbXORData != NULL)
        CoTaskMemFree((void *) m_rgbXORData);
    if (m_rgfHavePacket != NULL)
        CoTaskMemFree((void *) m_rgfHavePacket);
}

 
	// prints a little chart of bad packages...
HRESULT UHTTP_Package::DumpMissingPackets(ULONG *pcTotalPackets, ULONG *pcMissingPackets)
{
    DBG_HEADER(CDebugLog::DBG_other, _T("UHTTP_Package::DumpMissingPackets"));
	USES_CONVERSION;

    LPOLESTR polestr;

	if(pcTotalPackets )  *pcTotalPackets = 0;
	if(pcMissingPackets) *pcMissingPackets = 0;
	if(NULL == m_rgfHavePacket)
		return S_OK;

    StringFromCLSID(ntoh_uuid(m_uuid), &polestr);
    TCHAR *szUUID = OLE2T(polestr);
    CoTaskMemFree(polestr);

	TCHAR szMsg[256];
 	if(DBG_FSET(CDebugLog::DBG2_DUMP_MISSPACKET)) 
	{	
		if(m_cDataPacketsCur != m_cDataPackets) {
			wsprintf(szMsg, _T("Incomplete Package (%d/%d): %s"), m_cDataPacketsCur,  m_cDataPackets, szUUID);
			TVEDebugLog2((CDebugLog::DBG2_DUMP_MISSPACKET, 3, szMsg));
		}
	}

    ULONG cPacketsTotal = m_cDataPackets;
    ULONG cBlocks = DivRoundUp(m_cDataPackets, m_cDataPacketsPerBlock);

    if (m_cXORPacketsPerBlock > 0)
        cPacketsTotal = cBlocks*(m_cDataPacketsPerBlock + m_cXORPacketsPerBlock);
	long cMP = 0;


    for (ULONG b = 0; b < cBlocks; b++)
    {
        for (ULONG i = 0; i < m_cDataPacketsPerBlock + m_cXORPacketsPerBlock; i++)
		{
			int fHP =  FHavePacket(b, i);
			if(!fHP) cMP++;
		}
	}
	if(cMP == m_cMissingPackets_LastDump)
	{
		if(pcTotalPackets )  *pcTotalPackets = cPacketsTotal;
		if(pcMissingPackets) *pcMissingPackets = cMP;
	}

	if(DBG_FSET(CDebugLog::DBG2_DUMP_MISSPACKET)) {
		wsprintf(szMsg, _T("Missing Packets : %d of %d (%5.1f percent)"), cMP, cPacketsTotal, float(cMP)/cPacketsTotal);
		TVEDebugLog2((CDebugLog::DBG2_DUMP_MISSPACKET, 3, szMsg));
	}

    for (b = 0; b < cBlocks; b++)
    {
		if(DBG_FSET(CDebugLog::DBG2_DUMP_MISSPACKET)) {	
			wsprintf(szMsg, _T("\t\t%-03d:\t"), b);
		}

        for (ULONG i = 0; i < m_cDataPacketsPerBlock + m_cXORPacketsPerBlock; i++)
		{
			int fHP =  FHavePacket(b, i);

			if(DBG_FSET(CDebugLog::DBG2_DUMP_MISSPACKET)) 
			{	
				wsprintf(szMsg + _tcslen(szMsg), _T("%c"), fHP ? '*' : '.');
			}

		}
		if(DBG_FSET(CDebugLog::DBG2_DUMP_MISSPACKET)) {	
			TVEDebugLog2((CDebugLog::DBG2_DUMP_MISSPACKET, 5, szMsg));
		}
    }



	m_cMissingPackets_LastDump = cMP;

	if(pcTotalPackets )  *pcTotalPackets = cPacketsTotal;
	if(pcMissingPackets) *pcMissingPackets = m_cMissingPackets_LastDump;
	
	{
		ITVESupervisor_HelperPtr spSuperHelper;
		HRESULT hr = get_SupervisorHelper(&spSuperHelper);
		if(S_OK == hr)
		{
			
            const int kChars=256;
			WCHAR wzBuff[kChars]; wzBuff[kChars-1] = 0;   
			LPOLESTR polestr;

			StringFromCLSID(ntoh_uuid(m_uuid), &polestr);
            CComBSTR spbsBuff;
            spbsBuff.LoadString(IDS_AuxInfo_MissingPackets);      // L"%s\n\t\tMissing %d of %d packets (%5.1f %%)"

			if(cPacketsTotal == 0) cPacketsTotal = 1;
			wnsprintf(wzBuff, kChars-1, spbsBuff,
				polestr, m_cMissingPackets_LastDump, cPacketsTotal, 100.0 * m_cMissingPackets_LastDump / cPacketsTotal);

			CoTaskMemFree(polestr);
			ITVEVariationPtr spVar(m_spUnkTVEVariation);

			spSuperHelper->NotifyAuxInfo(NWHAT_Other, wzBuff, 0, 0);
		}			// ok to fail here, simply a notify
	}
	
	return S_OK;
}

HRESULT UHTTP_Package::NewPacket(int cbPacket, UHTTP_Packet *ppacket)
{
    DBG_HEADER(CDebugLog::DBG_UHTTP, _T("UHTTP_Package::NewPacket"));

  
	if (m_fReceivedOk)		// already finished this package, so ignore further packets
	{					
							// notify as Duplicate if we are getting it again (only packet 0)		
		if(0 == ppacket->SegStartByte())		
        {
			ITVESupervisor_HelperPtr spSuperHelper;
			HRESULT hr = get_SupervisorHelper(&spSuperHelper);
			if(S_OK == hr)
			{

				WCHAR wzBuff[128];
				LPOLESTR polestr;
				StringFromCLSID(ntoh_uuid(m_uuid), &polestr);
				swprintf(wzBuff,L"%s",polestr);
				CoTaskMemFree(polestr);

				ITVEVariationPtr spVar(m_spUnkTVEVariation);
				long nBytes = ppacket->ResourceSize();
				spSuperHelper->NotifyPackage(NPKG_Duplicate, spVar, wzBuff, nBytes, 0);
			} else {
				DBG_WARN(CDebugLog::DBG_SEV3, _T("Couldn't get SupervisorPtr - NotifyPackage Duplicate not done."));
			}
		}
		return S_OK;
	}

							// notify as Resend if we are getting packet 0 again, but package isn't finished		
	if(0 == ppacket->SegStartByte() && 
		(m_cDataPacketsCur != 0))	
	{
		ITVESupervisor_HelperPtr spSuperHelper;
		HRESULT hr = get_SupervisorHelper(&spSuperHelper);
		if(S_OK == hr)
		{

			WCHAR wzBuff[128];
			LPOLESTR polestr;
			StringFromCLSID(ntoh_uuid(m_uuid), &polestr);
			swprintf(wzBuff,L"%s",polestr);
			CoTaskMemFree(polestr);

			ITVEVariationPtr spVar(m_spUnkTVEVariation);
			spSuperHelper->NotifyPackage(NPKG_Resend, spVar, wzBuff, ppacket->ResourceSize(), 0);
		} else {
			DBG_WARN(CDebugLog::DBG_SEV3, _T("Couldn't get SupervisorPtr - NotifyPackage Resend not done."));
		}
	}

    
    int cbHeader = ppacket->CbHeader(cbPacket);
    if (cbHeader == 0)
        return E_INVALIDARG;

    cbPacket -= cbHeader;
    BYTE *pbData = ((BYTE *)ppacket) + cbHeader;

    // Ignore packets that have no data.
    if (cbPacket == 0)
        return S_OK;

    if (m_cbPacket == 0)
        {
        // This is the first packet.
        // Allocate everything we will need, and save away
        // anything we need for the following packets.

        m_cbPacket = cbPacket;
        if (m_cbPacket == 0)
            {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Bad Packet: cbPacket == 0"));
            return E_INVALIDARG;
            }
        m_cbResource = ppacket->ResourceSize();
        if (m_cbResource == 0)
            {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Bad Packet: cbResource == 0"));
            // Pretend we never got this first packet.
            m_cbPacket = 0;
            return E_INVALIDARG;
            }
        m_cDataPackets = DivRoundUp(m_cbResource, m_cbPacket);

        m_fCRCFollows = ppacket->CRCFollows();

        m_rgbData = (BYTE *) CoTaskMemAlloc(m_cDataPackets*m_cbPacket);
        if (m_rgbData == NULL)
            {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Out of memory allocating m_rgbData."));
            // Pretend we never got this first packet.
            m_cbPacket = 0;
            return E_OUTOFMEMORY;
            }

        m_PacketsInXORBlock = ppacket->PacketsInXORBlock();
        if (m_PacketsInXORBlock > 1)
            {
            m_cDataPacketsPerBlock = m_PacketsInXORBlock - 1;
            m_cXORPacketsPerBlock = 1;
            }
        else
            {
            // If no XOR packets then there's just one big block.
            m_cDataPacketsPerBlock = m_cDataPackets;
            m_cXORPacketsPerBlock = 0;
            }

        ULONG cPacketsTotal = m_cDataPackets;
        ULONG cBlocks = DivRoundUp(m_cDataPackets, m_cDataPacketsPerBlock);

        if (m_cXORPacketsPerBlock > 0)
            {
            m_rgbXORData = (BYTE*) CoTaskMemAlloc(cBlocks*m_cbPacket);
            if (m_rgbXORData == NULL)
                {
                DBG_WARN(CDebugLog::DBG_SEV3, _T("Out of memory allocating m_rgbXORData."));
                // Pretend we never got this first packet.
                m_cbPacket = 0;
                CoTaskMemFree((void*) m_rgbData);
                m_rgbData = NULL;
                return E_OUTOFMEMORY;
                }
            
            cPacketsTotal = cBlocks*(m_cDataPacketsPerBlock + m_cXORPacketsPerBlock);
            }

        int cbFlags = DivRoundUp(cPacketsTotal, (ULONG) 8);
        m_rgfHavePacket = (BYTE *) CoTaskMemAlloc(cbFlags);
        if (m_rgfHavePacket == NULL)
            {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Out of memory allocating m_rgfHavePacket."));
            // Pretend we never got this first packet.
            m_cbPacket = 0;
            CoTaskMemFree((void*) m_rgbData);
            m_rgbData = NULL;
            if (m_rgbXORData != NULL)
                {
                CoTaskMemFree(m_rgbXORData);
                m_rgbXORData = NULL;
                }
            return E_OUTOFMEMORY;
            }

        // Initialize to "don't have packet".
        memset(m_rgfHavePacket, 0, cbFlags);

        if ((m_cXORPacketsPerBlock > 0) && (m_cDataPackets % m_cDataPacketsPerBlock) != 0)
            {
            // We don't save the packets that pad out the last block, but
            // we DO want to mark them as "have packet".
            ULONG iPacket = (cBlocks - 1)*(m_cDataPacketsPerBlock + m_cXORPacketsPerBlock)
                        + (m_cDataPackets % m_cDataPacketsPerBlock);
            while (iPacket < (cPacketsTotal - 1))
                GotPacket(iPacket++);
            }

			{ 
				ITVESupervisor_HelperPtr spSuperHelper;
				HRESULT hr = get_SupervisorHelper(&spSuperHelper);
				if(S_OK == hr)
				{

					USES_CONVERSION;
                    const int kChars=256;
					WCHAR wzBuff[kChars]; wzBuff[kChars-1]=0;


					LPOLESTR polestr;
					StringFromCLSID(ntoh_uuid(m_uuid), &polestr);

#ifdef _DEBUG
//				UUID uuid;
//				ppacket->GetResourceID(&uuid);

					{
						StringFromCLSID(ntoh_uuid(m_uuid), &polestr);
                        CComBSTR spbsBuff;
                        spbsBuff.LoadString(IDS_AuxInfoD_NewPackage);   // L"New Package: %s   KBytes %8.2f, Packets %d, Blocks %d, Data: %d, XOR: %d"
						wnsprintf(wzBuff,kChars-1, spbsBuff,
							polestr, 
							ppacket->ResourceSize() / 1024.0,
							cPacketsTotal, cBlocks, 
							m_cDataPacketsPerBlock, m_cXORPacketsPerBlock);
						spSuperHelper->NotifyAuxInfo(NWHAT_Other,wzBuff, 0, 0);
					}
#endif	

					wnsprintf(wzBuff,kChars-1,L"%s",polestr);           // put string rep into wide buffer (used in the package starting event)
					CoTaskMemFree(polestr);
					ITVEVariationPtr spVar(m_spUnkTVEVariation);


							// create a ITVEFile object for the ExpireQueue to hold this new package...
					CComObject<CTVEFile> *pTVEPackageFile;
					hr = CComObject<CTVEFile>::CreateInstance(&pTVEPackageFile);
					if(FAILED(hr))
						return hr;
					ITVEFilePtr spTVEPackageFile;
					hr = pTVEPackageFile->QueryInterface(&spTVEPackageFile);		
					if(FAILED(hr)) {
						delete pTVEPackageFile;
						_ASSERT(false);
					} else {
						DATE dateExpires = 	DateNow() + ppacket->RetransmitExpiration() / (24.0 * 60 * 60);

//						IUnknownPtr spPunkEnh;
						ITVEServicePtr spServi;
						hr = spVar->get_Service(&spServi);

//						if(!FAILED(hr) && NULL != spPunkEnh)		// Clairbel Bug fix 2/20 - packages not getting into exp queue correctly 
						if(!FAILED(hr))	
						{
							hr = spTVEPackageFile->InitializePackage(spVar, wzBuff, wzBuff, dateExpires);
						}


						IUnknownPtr spPunkPackageFile(spTVEPackageFile);
						if(!FAILED(hr) && NULL != spServi && NULL != spPunkPackageFile)
						{
							ITVEService_HelperPtr spServiHelper(spServi);

							hr = spServiHelper->AddToExpireQueue(dateExpires, spPunkPackageFile);
						}
						m_pUnkTVEFilePackage = spPunkPackageFile;		// set the back pointer   - non ref-counted
					}

												// fire off the event to the U/I
					spSuperHelper->NotifyPackage(NPKG_Starting, spVar, wzBuff, ppacket->ResourceSize(), 0);

				} else {
					DBG_WARN(CDebugLog::DBG_SEV3, _T("Couldn't get SupervisorPtr - NotifyPackage Starting not done."));
				}
			}
    }
    else
    {
        // Verify that this packet header matches what we saved from the first packet.

        if ((cbPacket > (int) m_cbPacket)
                || (m_cbResource != ppacket->ResourceSize())
                || (m_PacketsInXORBlock != ppacket->PacketsInXORBlock())
                || (m_fCRCFollows != ppacket->CRCFollows())
                )
        {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Packet header does not match first."));
            return E_INVALIDARG;
        }
    }

    ULONG ibPacket = ppacket->SegStartByte();

    // Sanity check: packet address must be a multiple of packet size.
    if ((ibPacket % m_cbPacket) != 0)
    {
        DBG_WARN(CDebugLog::DBG_SEV3, _T("Packet address is not a multiple of the packet size."));
        return E_INVALIDARG;
    }

    ULONG iPacket = ibPacket/m_cbPacket;
    ULONG iBlock = iPacket/(m_cDataPacketsPerBlock + m_cXORPacketsPerBlock);
    ULONG iPacketInBlock = iPacket % (m_cDataPacketsPerBlock + m_cXORPacketsPerBlock);

    // Sanity check: make sure iBlock is valid
    if (iBlock >= DivRoundUp(m_cDataPackets, m_cDataPacketsPerBlock))
    {
        DBG_WARN(CDebugLog::DBG_SEV3, _T("Packet address is past the end."));
        return E_INVALIDARG;
    }

#ifdef DEBUG
	/*{
        TCHAR tszMsg[256];
        _stprintf(tszMsg, _T("Received Packet %4d/%-04d - (Block %d-%d)\n"), iPacket, m_cDataPackets, iBlock,iPacketInBlock);
        DBG_WARN(CDebugLog::DBG_UHTTPPACKET, tszMsg);
	}*/
#endif

#if 0
		ITVESupervisor_HelperPtr spSuperHelper;
		hr = get_SupervisorHelper(spSuperHelper);
		if(S_OK == hr)
		{
			ULONG cPacketsTotal = m_cDataPackets;
			ULONG cBlocks = DivRoundUp(m_cDataPackets, m_cDataPacketsPerBlock);
            cPacketsTotal = cBlocks*(m_cDataPacketsPerBlock + m_cXORPacketsPerBlock);

			int iPercent = (100*iPacket)/cPacketsTotal;
			int iMod = (cPacketsTotal < 10) ? 50 : ((cPacketsTotal < 100) ? 25 : ((cPacketsTotal < 1000) ? 10 : 5));
			int iX = (cPacketsTotal * iMod) / 100;
			if(cPacketsTotal > 10 && (iPacket % iX) == 0) 
			{
                const kChars=256;
				WCHAR wzBuff[kChars];  wzBuff[kChars-1] = 0;

				LPOLESTR polestr;
				StringFromCLSID(ntoh_uuid(m_uuid), &polestr);

                CComBSTR spbsBuff;
                spbsBuff.LoadString(IDS_AuxInfoD_GotPacket);    // L"%s : Packet %d of %d (%d percent)"
				wnsprintf(wzBuff,kChars-1,spbsBuff,
					polestr, iPacket, cPacketsTotal,iPercent);

				CoTaskMemFree(polestr);
				spSuperHelper->NotifyAuxInfo(NWHAT_Other,wzBuff, 0, 0);
			}
		} else {
			DBG_WARN(CDebugLog::DBG_SEV3, _T("Couldn't get SupervisorPtr - NotifyAuxInfo Other not done."));
		}
#endif	

    // Save away the new RetransmitExpire time (if it's been a bit since we last changed it.)
	time_t cNewSecExpires = time(NULL) + ppacket->RetransmitExpiration();
	if(cNewSecExpires < m_cSecExpires)		// very weird case - should never ever happen, but let's be safe 
		m_cSecExpires = cNewSecExpires;
    if((long) cNewSecExpires - (long) m_cSecExpires > kSecsRetransmitExpirationDelta)	// (kSecsRetransmitExpirationDelta = 5-60 sec)
	{
		if(NULL != m_spUnkTVEVariation)		// update the expire queue object
		{
			HRESULT hr = S_OK;
			ITVEVariationPtr spVar(m_spUnkTVEVariation);
			ITVEServicePtr spService;
			if(spVar)
				hr = spVar->get_Service(&spService);
			if(!FAILED(hr) && NULL != spVar)
			{
				DATE dateExpires = DateNow() + ppacket->RetransmitExpiration() / (24.0 * 60 * 60);
				ITVEService_HelperPtr spServiceHelper(spService);
				if(spServiceHelper)
				{
					_ASSERT(NULL != m_pUnkTVEFilePackage);
					spServiceHelper->ChangeInExpireQueue(dateExpires, m_pUnkTVEFilePackage);
				}
			}	
		}
		m_cSecExpires = cNewSecExpires;			
	}

    BOOL fAlreadyHavePacket = GotPacket(iPacket);

    BYTE *pb = NULL;

    // Now save the packet data to the appropriate place.
    if (iPacketInBlock < m_cDataPacketsPerBlock)
    {
        // This is a content packet.
    
        ULONG iDataPacket = IDataPacket(iBlock, iPacketInBlock);

        if (iDataPacket >= m_cDataPackets)
        {
            // Ignore filler packets... they should be all zeros anyway.
#ifdef _DEBUG
            TCHAR tszMsg[256];
            _stprintf(tszMsg, _T("Skipping filler packet %d."), iPacket);
            DBG_WARN(CDebugLog::DBG_SEV3, tszMsg);
#endif
            //UNDONE: Validate the data is all zeros.
            return S_OK;
        }

        pb = PDataPacket(iDataPacket);
        if (!fAlreadyHavePacket)
            m_cDataPacketsCur++;
    }
    else
    {
        // This is an XOR packet
        pb = PXORPacket(iBlock);
    }
    
//    ASSERT(pb != NULL);

    if (fAlreadyHavePacket)
    {
#ifdef _DEBUG
        TCHAR tszMsg[256];
        _stprintf(tszMsg, _T("Packet %d received again."), iPacket);
        DBG_WARN(CDebugLog::DBG_SEV3, tszMsg);
#endif
        if (m_fVerifyPackets  && (memcmp(pb, pbData, cbPacket) != 0))
        {
            DBG_WARN(CDebugLog::DBG_SEV3, _T("Packet not the same as before."));
            return E_INVALIDARG;
        }
        return S_OK;
    }

    // Copy the data
    memcpy(pb, pbData, cbPacket);
    if (cbPacket < (int) m_cbPacket)
    {
        // Zero fill the rest of the packet.
        memset(pb + cbPacket, 0, m_cbPacket - cbPacket);
    }
    
    // If we have the XOR packet for this block, and only one packet is missing,
    // then we can recreate the missing packet now.

    if ((m_cXORPacketsPerBlock > 0) && FHavePacket(iBlock, m_cDataPacketsPerBlock))
    {
        int cMissingPackets = 0;
        int iMissingPacket;
        for (ULONG i = 0; i < m_cDataPacketsPerBlock; i++)
        {
            if (!FHavePacket(iBlock, i))
            {
                cMissingPackets++;
                iMissingPacket = i;
            }
        }
        
        if (cMissingPackets == 1)
        {
            if (SUCCEEDED(RecoverPacket(iBlock, iMissingPacket)))
            {
                GotPacket(IPacket(iBlock, iMissingPacket));
                m_cDataPacketsCur++;
            }
        }
    }

    HRESULT hr = S_OK;
    if (m_cDataPacketsCur == m_cDataPackets)			// got the full thing
	{
		USES_CONVERSION;
		WCHAR wzBuff[128];
		LPOLESTR polestr;
		StringFromCLSID(ntoh_uuid(m_uuid), &polestr);
		swprintf(wzBuff,L"%s",polestr);
		CoTaskMemFree(polestr);

		ITVEVariationPtr spVar(m_spUnkTVEVariation);

// new code start
													// if package already expired, don't bother unpacking it
		ULONG cSecNow = time(NULL);
		if(cSecNow > m_cSecExpires)
		{
			ITVESupervisor_HelperPtr spSuperHelper;
			hr = get_SupervisorHelper(&spSuperHelper);
			if(S_OK == hr)
			{
                const int kChars=256;
				WCHAR wszAuxInfoBuff[kChars]; wszAuxInfoBuff[kChars-1] = 0;
                CComBSTR spbsBuff;
                spbsBuff.LoadString(IDS_AuxInfo_ReceivedExpiredPackage); // L"Received Expired Package: %s"

				wnsprintf(wszAuxInfoBuff,kChars-1,spbsBuff,wzBuff);
				spSuperHelper->NotifyAuxInfo(NWHAT_Data,wszAuxInfoBuff, 0, 0);
				m_fReceivedOk = true;		// say we already finished this package, so ignore further packets

				CoTaskMemFree((void *) m_rgbData);			// wipe out any memory it may have...
				m_rgbData = NULL;
				CoTaskMemFree((void *) m_rgbXORData) ;
				m_rgbXORData = NULL;
				CoTaskMemFree((void *) m_rgfHavePacket);
				m_rgfHavePacket = NULL;
		
						// should wipe this out of the list of packages being managed...
			}
			return hr;
		}
// new code end...
        hr = Unpack();									// does all the decompression and file writing.
														//   eventually calls UnPackBuffer() in unpack.cpp
						
						// We received the package, take it out of the expire queue
		ITVEServicePtr spServi;

		if(S_OK == hr)	
		{
			hr = RemoveFromExpireQueue();
		}

						// Finally fire off an event saying we received the package
		ITVESupervisor_HelperPtr spSuperHelper;
		hr = get_SupervisorHelper(&spSuperHelper);
		if(S_OK == hr)
		{
			ITVEVariationPtr spVar(m_spUnkTVEVariation);
			spSuperHelper->NotifyPackage(NPKG_Received, spVar, wzBuff,ppacket->ResourceSize(), 0 );
		} else {
			DBG_WARN(CDebugLog::DBG_SEV3, _T("Couldn't get SupervisorPtr - NotifyPackage Received not done."));
		} 
	}
    
    return hr;
}

template<class T> inline boolean OnBoundary(void *p)
{
    return ((short(p) % sizeof(T)) == 0);
}

inline void memxor(BYTE *pbDst, BYTE *pbSrc, int cb)
{
    // First line up on big chunk boundary
    while ((cb > 0) && !OnBoundary<ULONG>(pbDst))
        {
        *pbDst++ ^= *pbSrc++;
        cb--;
        }

    // Then XOR in big chunks
    if (OnBoundary<ULONG>(pbDst) && OnBoundary<ULONG>(pbSrc))
        {
        while (cb >= sizeof(ULONG))
            {
            *((ULONG *)pbDst) ^= *((ULONG *)pbSrc);
            pbDst += sizeof(ULONG);
            pbSrc += sizeof(ULONG);
            cb -= sizeof(ULONG);
            }
        }

    // Then XOR whatever is left over in little chunks
    while (cb > 0)
        {
        *pbDst++ ^= *pbSrc++;
        cb--;
        }
}

HRESULT UHTTP_Package::RecoverPacket(int iBlock, int iPacketInBlock)
{
    DBG_HEADER(CDebugLog::DBG_UHTTP, _T("UHTTP_Package::RecoverPacket"));

    int iDataPacket = IDataPacket(iBlock, 0);
    int iLastDataPacket = min(iDataPacket + m_cDataPacketsPerBlock, m_cDataPackets);
    int iMissingDataPacket = iDataPacket + iPacketInBlock;

    BYTE *pbDst =  PDataPacket(iMissingDataPacket);
    memcpy(pbDst, PXORPacket(iBlock), m_cbPacket);

    while (iDataPacket < iLastDataPacket)
        {
        if (iDataPacket != iMissingDataPacket)
            memxor(pbDst, PDataPacket(iDataPacket), m_cbPacket);
        iDataPacket++;
        }

#ifdef _DEBUG
    TCHAR tszMsg[256];

    _stprintf(tszMsg, _T("Recovered packet %d (%d:%d)."), IDataPacket(iBlock, iPacketInBlock),
            iBlock, iPacketInBlock);
    
    DBG_WARN(CDebugLog::DBG_SEV3, tszMsg);
#endif

    return S_OK;
}

HRESULT UHTTP_Package::Unpack()
{
    DBG_HEADER(CDebugLog::DBG_UHTTP, _T("UHTTP_Package::Unpack"));

    int cb = m_cbResource;

	HRESULT hr;
	ITVESupervisor_HelperPtr spSuperHelper;
	hr = get_SupervisorHelper(&spSuperHelper);

#define IGNORE_CRC_ERROR		// TODO - remove, this is for SB test - GREEK show

    if (m_fCRCFollows)
    {
        MPEGCRC crc;

        cb -= sizeof(ULONG);
        if (crc.Update(m_rgbData, cb) != ntohl(*((ULONG *)(m_rgbData + cb))))
        {
            DBG_WARN(CDebugLog::DBG_SEV2, _T("Dropping Package - invalid CRC."));
            if(spSuperHelper)
            {
                const int kChars = 256;
                WCHAR wszAuxInfoBuff[kChars]; wszAuxInfoBuff[kChars-1]=0;
                LPOLESTR polestr;
                StringFromCLSID(ntoh_uuid(m_uuid), &polestr);

                CComBSTR spbsBuff;

#ifndef IGNORE_CRC_ERROR
                spbsBuff.LoadString(IDS_AuxInfo_CRCInvaild_Dropping); // L" *** CRC invalid, Dropping Package: %s"
                _snwprintf(wszAuxInfoBuff,kChars-1,spbsBuff,polestr);
#else
                spbsBuff.LoadString(IDS_AuxInfo_CRCInvaild_NotDropping); // L" *** CRC invalid, but ignoring error. Should drop package: %s"
                _snwprintf(wszAuxInfoBuff,kChars-1,spbsBuff,polestr);
#endif
                spSuperHelper->NotifyAuxInfo(NWHAT_Data,wszAuxInfoBuff, 0, 0);
                CoTaskMemFree(polestr);
            }
#ifndef IGNORE_CRC_ERROR
            return E_INVALIDARG;
#endif
        }
    }

	// -------------------------------------------------------------------
	// -------------------------------------------------------------------

				// Got full package, now Un GZip it and dump it 
				//   to the files


	if(S_OK != hr || NULL == spSuperHelper)
	{
		_ASSERT(false);		// forgot to setup this link (but this should work anyway..)
		hr = UnpackBuffer(m_spUnkTVEVariation, m_rgbData, cb);
	} else {
		hr = spSuperHelper->UnpackBuffer(m_spUnkTVEVariation, m_rgbData, cb);  // same call as above, but get event stuff too
	}
  
	// -------------------------------------------------------------------
	// -------------------------------------------------------------------
#ifdef UHTTP_TestHooks
    hr = g_dumper.DumpBuffer(m_uuid, m_rgbData, cb);
#endif
    if (SUCCEEDED(hr))
        {
        m_fReceivedOk = TRUE;

        // No need to save the data... it's been successfully received.
        CoTaskMemFree((void *) m_rgbData);
        m_rgbData = NULL;
        CoTaskMemFree((void *) m_rgbXORData) ;
        m_rgbXORData = NULL;
        CoTaskMemFree((void *) m_rgfHavePacket);
        m_rgfHavePacket = NULL;

#if 0
        // Hack for WinHEC and NAB demo
        static int iMsg = 0;
        if (iMsg == 0)
            iMsg = ::RegisterWindowMessage("UHTTP_ReceiveComplete");
        ::PostMessage(HWND_BROADCAST, iMsg, m_uuid.Data1, m_uuid.Data2);
#endif
        }
    
    return hr;
}

#ifdef UHTTP_TestHooks
extern "C"
{

__declspec(dllexport) void UHTTP_Test(HWND hwnd, HINSTANCE hinst, LPSTR szCmdLine, int nCmdShow)
{
	USES_CONVERSION;

    char szMsg[256];
    FILE *pfileInput = NULL;
    FILE *pfileSkip = NULL;

    g_dumper.SetEnabled(TRUE);

    char *szInputFileName = szCmdLine;
    char *szSkipFileName = strchr(szCmdLine, ',');
    if (szSkipFileName != NULL)
        {
        *szSkipFileName++ = '\0';
        while (*szSkipFileName == ' ')
            szSkipFileName++;

        pfileSkip = fopen(szSkipFileName, "rt");

        if (pfileSkip == NULL)
            {
            sprintf(szMsg, "Can't open skip file: %s", szSkipFileName);
            MessageBox(hwnd, A2T(szMsg), _T("UHTTP_Test"), MB_OK);
            return;
            }
        }

    pfileInput = fopen(szInputFileName, "rb");

    if (pfileInput == NULL)
        {
        sprintf(szMsg, "Can't open file: %s", szInputFileName);
        MessageBox(hwnd, A2T(szMsg), _T("UHTTP_Test"), MB_OK);
        return;
        }
    
    ULONG cbPacket;

    if (fread((void *) &cbPacket, sizeof(cbPacket), 1, pfileInput) != 1)
        {
        MessageBox(hwnd, _T("Can't read packet size"), _T("UHTTP_Test"), MB_OK);
        fclose(pfileInput);
        return;
        }

    cbPacket += sizeof(UHTTP_Header);
    
    BYTE *ppacket = new BYTE[cbPacket];

    if (ppacket == NULL)
        {
        sprintf(szMsg, "Can't allocate packet buffer of size: %d", cbPacket);
        MessageBox(hwnd, A2T(szMsg), _T("UHTTP_Test"), MB_OK);
        fclose(pfileInput);
        return;
        }
    
    UHTTP_Receiver rec;
    int iPacket = 0;
    int iSkipPacket = -1;
    ULONG cbRead;

    if (pfileSkip != NULL)
        {
        fscanf(pfileSkip, " %d", &iSkipPacket);
        }
    while ((cbRead = fread((void *) ppacket, 1, cbPacket, pfileInput)) == cbPacket)
        {
        if (iPacket != iSkipPacket)
            {
            rec.NewPacket(cbPacket, (UHTTP_Packet *) ppacket, NULL);
            }
        else
            {
            if (fscanf(pfileSkip, " %d", &iSkipPacket) != 1)
                iSkipPacket = -1;
            }
        iPacket++;
        }
    
    delete [] ppacket;
    
    fclose(pfileInput);
    if (pfileSkip != NULL)
        fclose(pfileSkip);
}

__declspec(dllexport) void UHTTP_MergeTest(HWND hwnd, HINSTANCE hinst, LPSTR szCmdLine, int nCmdShow)
{
    char szMsg[256];
    FILE *pfileControl = NULL;
	USES_CONVERSION;

    g_dumper.SetEnabled(TRUE);

    pfileControl = fopen(szCmdLine, "rt");

    if (pfileControl == NULL)
        {
        sprintf(szMsg, "Can't open file: %s", szCmdLine);
        MessageBox(hwnd, A2T(szMsg), _T("UHTTP_MergeTest"), MB_OK);
        return;
        }

    int cFiles;
    if (fscanf(pfileControl, " Files: %d", &cFiles) != 1)
        {
        sprintf(szMsg, "Error in file: %s\n'File:' not specified.", szCmdLine);
        MessageBox(hwnd, A2T(szMsg), _T("UHTTP_MergeTest"), MB_OK);
        return;
        }
    
    if (cFiles <= 0)
        return;
    
    ULONG *rgcbPacket = new ULONG [cFiles];
    FILE **rgpfileIn = new FILE * [cFiles];

    g_rgszOutFileName = new TCHAR *[cFiles];

    if (g_rgszOutFileName == NULL)
        {
        sprintf(szMsg, "Can't allocate g_rgszOutFileName[%d]", cFiles);
        MessageBox(hwnd, A2T(szMsg), _T("UHTTP_MergeTest"), MB_OK);
        return;
        }

    ULONG cbMaxPacket = 0;

    for (int i = 0; i < cFiles; i++)
        {
        char szInFileName[256];
        char szOutFileName[256];
        if (fscanf(pfileControl, " %255s %255s", szInFileName, szOutFileName) != 2)
            {
            sprintf(szMsg, "Error in file: %s\nFile %d not specified.", szCmdLine, i);
            MessageBox(hwnd, A2T(szMsg), _T("UHTTP_MergeTest"), MB_OK);
            return;
            }
        
        g_rgszOutFileName[i] = _tcsdup(A2T(szOutFileName));

        rgpfileIn[i] = fopen(szInFileName, "rb");

        if (rgpfileIn[i] == NULL)
            {
            sprintf(szMsg, "Can't open file: %s", szInFileName);
            MessageBox(hwnd, A2T(szMsg), _T("UHTTP_MergeTest"), MB_OK);
            return;
            }

        if (fread((void *) &rgcbPacket[i], sizeof(rgcbPacket[i]), 1, rgpfileIn[i]) != 1)
            {
            sprintf(szMsg, "Can't read packet size for %s", szInFileName);
            MessageBox(hwnd, A2T(szMsg), _T("UHTTP_MergeTest"), MB_OK);
            return;
            }

        rgcbPacket[i] += sizeof(UHTTP_Header);
        if (rgcbPacket[i] >  cbMaxPacket)
            cbMaxPacket = rgcbPacket[i];
        }
    
    BYTE *ppacket = new BYTE[cbMaxPacket];

    if (ppacket == NULL)
        {
        sprintf(szMsg, "Can't allocate packet buffer of size: %d", cbMaxPacket);
        MessageBox(hwnd, A2T(szMsg), _T("UHTTP_MergeTest"), MB_OK);
        return;
        }
    
    UHTTP_Receiver rec;
    char cCommand;

    while (fscanf(pfileControl, " %d %c", &g_iFileCur, &cCommand) == 2)
        {
        FILE * pfile = rgpfileIn[g_iFileCur];
        int cb = rgcbPacket[g_iFileCur];

        switch (cCommand)
            {
            case 'r':
                // Read command
                {
                int cPackets;

                if (fscanf(pfileControl, " %d", &cPackets) != 1)
                    {
                    sprintf(szMsg, "Expected cPackets after \"%d r\".", g_iFileCur);
                    MessageBox(hwnd, A2T(szMsg), _T("UHTTP_MergeTest"), MB_OK);
                    return;
                    }

                while (cPackets--)
                    {
                    int cbRead = fread((void *) ppacket, 1, cb, pfile);
                    if (cbRead > 0)
                        {
                        // Read Command
                        rec.NewPacket(cbRead, (UHTTP_Packet *) ppacket, NULL);
                        }
                    else
                        {
                        cPackets = 0;
                        }
                    }
                }
                break;

            case 's':
                // Seek command
                {
                char ch;
                int cPackets;
                int origin;
                int cbComp = 0;

                if (fscanf(pfileControl, "%c", &ch) != 1)
                    {
                    sprintf(szMsg, "Expected character after \"%d s\".", g_iFileCur);
                    MessageBox(hwnd, A2T(szMsg), _T("UHTTP_MergeTest"), MB_OK);
                    return;
                    }

                switch (ch)
                    {
                    default:
                        origin = SEEK_CUR;
                        break;
                    case '>':
                        origin = SEEK_SET;
                        cbComp = sizeof(ULONG);
                        break;
                    case '<':
                        origin = SEEK_END;
                        break;
                    }

                if (fscanf(pfileControl, " %d", &cPackets) != 1)
                    {
                    sprintf(szMsg, "Expected cPackets after \"%d s\".", g_iFileCur);
                    MessageBox(hwnd, A2T(szMsg), _T("UHTTP_MergeTest"), MB_OK);
                    return;
                    }

                fseek(pfile, cb*cPackets + cbComp, origin);
                }
                break;
            }
        }
    
    delete [] ppacket;

    for (i = 0; i < cFiles; i++)
        {
        fclose(rgpfileIn[i]);
        delete [] g_rgszOutFileName[i];
        }
    
    delete [] g_rgszOutFileName;
    
    fclose(pfileControl);
}

}

HRESULT DumpBuffer(REFIID uuid, BYTE *pb, ULONG cb)
{
    USES_CONVERSION;
	DBG_HEADER(CDebugLog::DBG_MIME, _T("DumpBuffer"));

    LPOLESTR polestr;
 
    StringFromCLSID(ntoh_uuid(uuid), &polestr);
    CComBSTR spbsFileName = polestr;
    CoTaskMemFree(polestr);

	WCHAR szBuff[256];
	swprintf(szBuff,L"c:\\TVE-%s",spbsFileName);

    int fh = _open(W2A(szBuff), _O_BINARY | _O_WRONLY | _O_CREAT | _O_TRUNC, _S_IREAD | _S_IWRITE);

    if (fh == -1)
    {
 		TVEDebugLog2(( CDebugLog::DBG2_DUMP_PACKAGES, 1, _T("Couldn't create %d byte Package Dump File : %s"), cb, szBuff));
        return S_OK;
	} 

 	TVEDebugLog2(( CDebugLog::DBG2_DUMP_PACKAGES, 1, _T("Dumping %d byte Package To File : %s"), cb, szBuff));
   
    _write(fh, pb, cb);

    _close(fh);

    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\uhttp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// UHTTP.h: interface for the UHTTP class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_UHTTP_H__A04BF465_B157_11D2_BE91_006097D26649__INCLUDED_)
#define AFX_UHTTP_H__A04BF465_B157_11D2_BE91_006097D26649__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "time.h"
#include "..\common\isotime.h"		// my time code


#define SUPPORT_UHTTP_EXT           // support extension headers if defined

//#include "TveSuper.h"
_COM_SMARTPTR_TYPEDEF(IUnknown,					__uuidof(IUnknown));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,		__uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor,			__uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,	__uuidof(ITVESupervisor_Helper));


#if !defined(UHTTP_TestHooks) && defined(_DEBUG)
#define UHTTP_TestHooks
#endif

class UHTTP_Receiver;
class UHTTP_Header;
class UHTTP_ExtensionHeader;
class UHTTP_Packet;
class UHTTP_Package;

template<class T>
T DivRoundUp(T numer, T denom)
{
    return (numer + denom - 1)/denom;
}

inline UUID ntoh_uuid(UUID uuid)
{
    // converts UUID from network order
    uuid.Data1 = ntohl(uuid.Data1);
    uuid.Data2 = ntohs(uuid.Data2);
    uuid.Data3 = ntohs(uuid.Data3);

    return uuid;
}

class UHTTP_Receiver
{
public:
    UHTTP_Receiver();

    ~UHTTP_Receiver();
							//  pTVEVariation pointer used in call when actually create full package
    HRESULT NewPacket(int cb, UHTTP_Packet *ppacket, IUnknown *pTVEVariation);

    UHTTP_Package * FindPackage(UUID & uuid);

    HRESULT AddPackage(UHTTP_Package *ppackage);

    HRESULT PurgeExpiredPackages();

	HRESULT DumpPackagesWithMissingPackets(DWORD mode);

protected:
    UHTTP_Package **m_rgppackages;
    int m_cPackages;
    int m_cPackagesMax;

	LONG m_cSecLastPurge;			// to avoid trying to purge packages too often..
};

class UHTTP_ExtensionHeader
{
public:
    boolean ExtensionHeaderFollows()
        {
        USHORT n = ntohs(m_ExtensionHeaderType);
        return ((n & 0x8000) != 0);
        }
    
    USHORT ExtensionHeaderType()
        {
        USHORT n = ntohs(m_ExtensionHeaderType);
        return (n & ~0x8000);
        }
    
    USHORT ExtensionHeaderDataSize()
        {
        return ntohs(m_ExtensionHeaderDataSize);
        }
protected:
    USHORT m_ExtensionHeaderType; //High bit indicates another ExtensionHeader follows.
    USHORT m_ExtensionHeaderDataSize;
};

class UHTTP_Header
{
public:
    int Version()
        {
        return m_Version;
        }
    boolean HTTPHeadersPrecede()
        {
        return (m_HTTPHeadersPrecede != 0);
        }
    
    boolean CRCFollows()
        {
        return (m_CRCFollows != 0);
        }
    UINT PacketsInXORBlock()
        {
        return m_PacketsInXORBlock;
        }
    
    ULONG RetransmitExpiration()
        {
/*
#ifndef SUPPORT_UHTTP_EXT
        ULONG n = m_RetransmitExpiration[0];
        n = (n << 8) + m_RetransmitExpiration[1];
        return (n << 8) + m_RetransmitExpiration[2];
#else */
        ULONG n = ntohs(m_RetransmitExpiration);
        return n;
/* #endif */
        }
    
    void GetResourceID(UUID *puuid)
        {
        *puuid = m_ResourceID;
        }
    
    ULONG ResourceSize()
        {
        return ntohl(m_ResourceSize);
        }
    
    ULONG SegStartByte()
        {
        return ntohl(m_SegStartByte);
        }

    int CbHeader(int cbMax)
        {
        int cb = sizeof(*this);
        if (cb >= cbMax)
            return 0;
#ifdef SUPPORT_UHTTP_EXT
        if (m_ExtensionHeader)
            {
            UHTTP_ExtensionHeader *pext = (UHTTP_ExtensionHeader *)(this + 1);
            int cbExt = pext->ExtensionHeaderDataSize() + sizeof(UHTTP_ExtensionHeader);
            cb += cbExt;
            if (cb >= cbMax)
                return 0;
            while (pext->ExtensionHeaderFollows())
                {
                pext = (UHTTP_ExtensionHeader *)(((BYTE *)pext) + cbExt);
                cbExt = pext->ExtensionHeaderDataSize() + sizeof(UHTTP_ExtensionHeader);
                cb += cbExt;
                if (cb >= cbMax)
                    return 0;
                }
            }
#endif
        return cb;
        }
protected:
    // NOTE: This is the order when bits are allocated starting
    // with the least significant bit (like with MS C).
    // It is the reverse of what the UHTTP spec says.
    BYTE m_CRCFollows:1;
    BYTE m_HTTPHeadersPrecede:1;

#ifndef SUPPORT_UHTTP_EXT
    BYTE m_Reserved:5;
    BYTE m_Version:1;
#else
    BYTE m_ExtensionHeader:1;
    BYTE m_Version:5;
#endif
    BYTE m_PacketsInXORBlock;

/* #ifdef UHTTP_R19
    BYTE m_RetransmitExpiration[3];
#else
    USHORT m_RetransmitExpiration;
#endif */

    USHORT m_RetransmitExpiration;

    UUID m_ResourceID;
    ULONG m_ResourceSize;
    ULONG m_SegStartByte;
};

class UHTTP_Packet : public UHTTP_Header
{
public:
    BYTE *PBData(int cbPacket)
        {
        return ((BYTE *)this) + CbHeader(cbPacket);
        }
};

						//  Interesting constant - prevents packets that arrive close to each other
						//   from changing the expire time of the package too often.
						//   Used in NewPacket()
const int kSecsRetransmitExpirationDelta = 30;			// don't update restranmit time at intervals less than this.

class UHTTP_Package
{
public:
    UHTTP_Package(UUID & uuid, IUnknown *pUnkTVEVariation)			// ITVESupervisor pointer..
        {
        m_uuid				= uuid;
        m_cbPacket			= 0;
        m_cDataPackets		= 0;
        m_cDataPacketsCur	= 0;
        m_PacketsInXORBlock	= 0;
        m_cDataPacketsPerBlock = 0;
        m_cXORPacketsPerBlock = 0;	
        m_rgbData			= NULL;
        m_rgbXORData		= NULL;
        m_rgfHavePacket		= NULL;
        m_fCRCFollows		= FALSE;
        m_fValidatePackets	= TRUE;
        m_fReceivedOk		= FALSE;
        m_fVerifyPackets	= TRUE;
		m_spUnkTVEVariation	= pUnkTVEVariation;
		m_pUnkTVEFilePackage = NULL;

		m_cMissingPackets_LastDump = -1;				// dump missing packets...
        }

    ~UHTTP_Package();

    UUID & GetUUID()
        {
        return m_uuid;
        }

	ITVEVariation *GetVariation()						// returns and AddRef'ed pointer 
	{
		if(m_spUnkTVEVariation) {
			ITVEVariationPtr spVar(m_spUnkTVEVariation);
			if(spVar)
				spVar->AddRef();
			return spVar;
		} 
		return NULL;	
	}

	HRESULT RemoveFromExpireQueue()						// removes service from queue in the service
	{
		HRESULT hr = S_FALSE;
		if(m_spUnkTVEVariation) {
			ITVEVariationPtr spVar(m_spUnkTVEVariation);
			ITVEServicePtr spService;
			spVar->get_Service(&spService);
			if(NULL != spService)
			{
				ITVEService_HelperPtr spServHelper(spService);
				if(NULL != spServHelper && NULL != m_pUnkTVEFilePackage)
					hr = spServHelper->RemoveFromExpireQueue(m_pUnkTVEFilePackage);
				m_pUnkTVEFilePackage = NULL;
			}
		}
		return hr;
	}
    HRESULT NewPacket(int cbPacket, UHTTP_Packet *ppacket);
    HRESULT RecoverPacket(int iBlock, int iMissingPacket);
	HRESULT DumpMissingPackets(ULONG *pcTotalPackets=NULL, ULONG *pcMissingPackets=NULL);
    HRESULT Unpack();

    int IPacket(int iBlock, int iPacketInBlock)
        {
        return iBlock*(m_cDataPacketsPerBlock + m_cXORPacketsPerBlock) + iPacketInBlock;
        }

    int IDataPacket(int iBlock, int iPacketInBlock)
        {
        return iBlock*m_cDataPacketsPerBlock + iPacketInBlock;
        }
    
	int IResourceSize()
	{
		return m_cbResource;
	}

	DATE DateExpires()
	{
		return VariantTimeFromTime(m_cSecExpires); 
	}

    BYTE *PDataPacket(int iDataPacket)
    {
		return (m_rgbData + iDataPacket*m_cbPacket);
    }
    
    BYTE *PXORPacket(int iBlock)
    {
		return (m_rgbXORData + iBlock*m_cbPacket);
    }

    boolean FHavePacket(int iPacket)
        {
        int ib = iPacket/8;
        int ibit = iPacket % 8;
        BYTE mask = 1 << ibit;
        return (m_rgfHavePacket[ib] & mask) != 0;
        }
    
    boolean FHavePacket(int iBlock, int iPacketInBlock)
        {
        return FHavePacket(IPacket(iBlock, iPacketInBlock));
        }
    
    boolean GotPacket(int iPacket)
        {
        int ib = iPacket/8;
        int ibit = iPacket % 8;
        BYTE mask = 1 << ibit;
        boolean fAlreadyHavePacket = (m_rgfHavePacket[ib] & mask) != 0;
        m_rgfHavePacket[ib] |= mask;

        return fAlreadyHavePacket;
        }
    
    boolean FExpired(ULONG cSecs)
        {
        return !m_fReceivedOk && (cSecs > m_cSecExpires);
        }

	boolean ReceivedOk()
	{
		return m_fReceivedOk;
	}

	boolean DumpedAtLeastOnce()
	{
		return (-1 != m_cMissingPackets_LastDump);
	}

	HRESULT get_SupervisorHelper(ITVESupervisor_Helper **ppSuperHelper)		// goes up tree from variation to supervisor
	{																		//   used in all the event firing code
		if(NULL == ppSuperHelper)
			return E_POINTER;

		*ppSuperHelper = NULL;			// error case, null it out 
		if(NULL == m_spUnkTVEVariation)
			return E_FAIL;

		HRESULT hr = S_OK;
		ITVEVariationPtr spVar(m_spUnkTVEVariation);
		ITVEServicePtr spService;
		if(spVar)
			hr = spVar->get_Service(&spService);
		if(FAILED(hr)) 
			return hr;
		IUnknownPtr spPunkSuper;
		hr = spService->get_Parent(&spPunkSuper);
		if(FAILED(hr))
			return hr;
		ITVESupervisor_HelperPtr spSuperHelper(spPunkSuper);
		if(spSuperHelper)
		{
			*ppSuperHelper = spSuperHelper;
			spSuperHelper->AddRef();				// client required to release()
		} else {
			return E_FAIL;
		}
		return hr;
	}
protected:
    ULONG m_cbPacket;
    ULONG m_cbResource;
    ULONG m_PacketsInXORBlock;
    UUID m_uuid;

    BYTE *m_rgbData;
    BYTE *m_rgbXORData;
    BYTE *m_rgfHavePacket;
    ULONG m_cDataPackets;
    ULONG m_cDataPacketsCur;
    ULONG m_cDataPacketsPerBlock;
    ULONG m_cXORPacketsPerBlock;
    ULONG m_cSecExpires;
    boolean m_fCRCFollows;
    boolean m_fValidatePackets;
    boolean m_fReceivedOk;
    boolean m_fVerifyPackets;

	ULONG m_cMissingPackets_LastDump;

	IUnknownPtr m_spUnkTVEVariation;
	IUnknownPtr m_pUnkTVEFilePackage;			// non ref-counted back pointer to a containing object used in Expire Queue
};

#endif // !defined(AFX_UHTTP_H__A04BF465_B157_11D2_BE91_006097D26649__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testevents2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__BB57915C_3516_4724_8F07_89FDF8FF1C5B__INCLUDED_)
#define AFX_STDAFX_H__BB57915C_3516_4724_8F07_89FDF8FF1C5B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BB57915C_3516_4724_8F07_89FDF8FF1C5B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\mstve\zlib.h ===
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.0.4, Jul 24th, 1996.

  Copyright (C) 1995-1996 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  gzip@prep.ai.mit.edu    madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

#ifdef __cplusplus
extern "C" {
#endif

#include "zconf.h"
#include <stdio.h>

#define ZLIB_VERSION "1.0.4"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms may be added later and will have the same
  stream interface.

     For compression the application must provide the output buffer and
  may optionally provide the input buffer for optimization. For decompression,
  the application must provide the input buffer and may optionally provide
  the output buffer for optimization.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library does not install any signal handler. It is recommended to
  add at least a handler for SIGSEGV when decompressing; the library checks
  the consistency of the input data whenever possible but may go nuts
  for some forms of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

extern const char * EXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
extern int EXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


extern int EXPORT deflate OF((z_streamp strm, int flush));
/*
  Performs one or both of the following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_PARTIAL_FLUSH, the current compression
  block is terminated and flushed to the output buffer so that the
  decompressor can get all input data available so far. For method 9, a future
  variant on method 8, the current block will be flushed but not terminated.
  Z_SYNC_FLUSH has the same effect as partial flush except that the compressed
  output is byte aligned (the compressor can clear its internal bit buffer)
  and the current block is always terminated; this can be useful if the
  compressor has to be restarted from scratch after an interruption (in which
  case the internal state of the compressor may be lost).
    If flush is set to Z_FULL_FLUSH, the compression block is terminated, a
  special marker is output and the compression dictionary is discarded; this
  is useful to allow the decompressor to synchronize if one compressed block
  has been damaged (see inflateSync below).  Flushing degrades compression and
  so should be used only when necessary.  Using Z_FULL_FLUSH too often can
  seriously degrade the compression. If deflate returns with avail_out == 0,
  this function must be called again with the same value of the flush
  parameter and more output space (updated avail_out), until the flush is
  complete (deflate returns with non-zero avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible.
*/


extern int EXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
extern int EXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.  If
   zalloc and zfree are set to Z_NULL, inflateInit updates them to use default
   allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_VERSION_ERROR if the zlib library version is incompatible
   with the version assumed by the caller.  msg is set to null if there is no
   error message. inflateInit does not perform any decompression: this will be
   done by inflate().
*/


extern int EXPORT inflate OF((z_streamp strm, int flush));
/*
  Performs one or both of the following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_PARTIAL_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_PARTIAL_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

    inflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if the end of the
  compressed data has been reached and all uncompressed output has been
  produced, Z_NEED_DICT if a preset dictionary is needed at this point (see
  inflateSetDictionary below), Z_DATA_ERROR if the input data was corrupted,
  Z_STREAM_ERROR if the stream structure was inconsistent (for example if
  next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,
  Z_BUF_ERROR if no progress is possible or if there was not enough room in
  the output buffer when Z_FINISH is used. In the Z_DATA_ERROR case, the
  application may then call inflateSync to look for a good compression block.
  In the Z_NEED_DICT case, strm->adler is set to the Adler32 value of the
  dictionary chosen by the compressor.
*/


extern int EXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
extern int EXPORT deflateInit2 OF((z_streamp strm,
                                   int  level,
                                   int  method,
                                   int  windowBits,
                                   int  memLevel,
                                   int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library. (Method 9 will allow a 64K history buffer and
   partial block flushes.)

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library (the value 16 will be allowed for method 9). Larger
   values of this parameter result in better compression at the expense of
   memory usage. The default value is 15 if deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

     If next_in is not null, the library will use this buffer to hold also
   some history information; the buffer must either hold the entire input
   data, or have at least 1<<(windowBits+1) bytes and be writable. If next_in
   is null, the library will allocate its own history buffer (and leave next_in
   null). next_out need not be provided here but must be provided by the
   application for the next call of deflate().

     If the history buffer is provided by the application, next_in must
   must never be changed by the application since the compressor maintains
   information inside this buffer from call to call; the application
   must provide more input only by increasing avail_in. next_in is always
   reset by the library in this case.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
   an invalid method). msg is set to null if there is no error message.
   deflateInit2 does not perform any compression: this will be done by
   deflate(). 
*/
                            
extern int EXPORT deflateSetDictionary OF((z_streamp strm,
                                           const Bytef *dictionary,
				           uInt  dictLength));
/*
     Initializes the compression dictionary (history buffer) from the given
   byte sequence without producing any compressed output. This function must
   be called immediately after deflateInit or deflateInit2, before any call
   of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).
     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and
   can be predicted with good accuracy; the data can then be compressed better
   than with the default empty dictionary. In this version of the library,
   only the last 32K bytes of the dictionary are used.
     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state
   is inconsistent (for example if deflate has already been called for this
   stream). deflateSetDictionary does not perform any compression: this will
   be done by deflate(). 
*/

extern int EXPORT deflateCopy OF((z_streamp dest,
                                  z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.  If
   the source stream is using an application-supplied history buffer, a new
   buffer is allocated for the destination stream.  The compressed output
   buffer is always application-supplied. It's the responsibility of the
   application to provide the correct values of next_out and avail_out for the
   next call of deflate.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

extern int EXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

extern int EXPORT deflateParams OF((z_streamp strm, int level, int strategy));
/*
     Dynamically update the compression level and compression strategy.
   This can be used to switch between compression and straight copy of
   the input data, or to switch to a different kind of input data requiring
   a different strategy. If the compression level is changed, the input
   available so far is compressed with the old level (and may be flushed);
   the new level will take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
extern int EXPORT inflateInit2 OF((z_streamp strm,
                                   int  windowBits));

     This is another version of inflateInit with more compression options. The
   fields next_out, zalloc, zfree and opaque must be initialized before by
   the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library (the value 16 will be allowed soon). The
   default value is 15 if inflateInit is used instead. If a compressed stream
   with a larger window size is given as input, inflate() will return with
   the error code Z_DATA_ERROR instead of trying to allocate a larger window.

     If next_out is not null, the library will use this buffer for the history
   buffer; the buffer must either be large enough to hold the entire output
   data, or have at least 1<<windowBits bytes.  If next_out is null, the
   library will allocate its own buffer (and leave next_out null). next_in
   need not be provided here but must be provided by the application for the
   next call of inflate().

     If the history buffer is provided by the application, next_out must
   never be changed by the application since the decompressor maintains
   history information inside this buffer from call to call; the application
   can only reset next_out to the beginning of the history buffer when
   avail_out is zero and all output has been consumed.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
   windowBits < 8). msg is set to null if there is no error message.
   inflateInit2 does not perform any decompression: this will be done by
   inflate().
*/

extern int EXPORT inflateSetDictionary OF((z_streamp strm,
				           const Bytef *dictionary,
					   uInt  dictLength));
/*
     Initializes the decompression dictionary (history buffer) from the given
   uncompressed byte sequence. This function must be called immediately after
   a call of inflate if this call returned Z_NEED_DICT. The dictionary chosen
   by the compressor can be determined from the Adler32 value returned by this
   call of inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

extern int EXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until the special marker (see deflate()
  above) can be found, or until all available input is skipped. No output
  is provided.

    inflateSync returns Z_OK if the special marker has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no marker has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

extern int EXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level, window size,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

extern int EXPORT compress OF((Bytef *dest,   uLongf *destLen,
			       const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

extern int EXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
				 const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

extern gzFile EXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9").  gzopen can be used to read a file which is not in gzip format;
   in this case gzread will directly read from the file without decompression.
     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).
*/

extern gzFile EXPORT gzdopen  OF((int fd, const char *mode));
extern gzFile EXPORT gzoverlay  OF((FILE *fp, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

extern int EXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

extern int EXPORT    gzwrite OF((gzFile file, const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

extern int EXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

extern int EXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

extern const char * EXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

extern uLong EXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

extern uLong EXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
extern int EXPORT deflateInit_ OF((z_streamp strm, int level,
			           const char *version, int stream_size));
extern int EXPORT inflateInit_ OF((z_streamp strm,
				   const char *version, int stream_size));
extern int EXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
				    int windowBits, int memLevel, int strategy,
				    const char *version, int stream_size));
extern int EXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
				    const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
		      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))

#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

const uLongf *get_crc_table OF((void)); /* can be used by asm versions of crc32() */

#ifdef __cplusplus
}
#endif

#endif /* _ZLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testevents2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TestEvents2.rc
//
#define IDS_PROJNAME                    100
#define IDB_TVETESTCONTROL              101
#define IDR_TVETESTCONTROL              102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testgseg2\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testevents2\testevents2.cpp ===
// TestEvents2.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f TestEvents2ps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TestEvents2.h"

#include "TestEvents2_i.c"
#include "TVETestControl.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TVETestControl, CTVETestControl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TESTEVENTS2Lib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testevents2\tvetestcontrol.cpp ===
// TVETestControl.cpp : Implementation of CTVETestControl

#include "stdafx.h"
#include "TestEvents2.h"
#include "TVETestControl.h"

/////////////////////////////////////////////////////////////////////////////
// CTVETestControl


#include <stdio.h>

#import  "..\..\TveContr\objd\i386\TveContr.tlb" no_namespace, raw_interfaces_only

//#include "TVETracks.h"


#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// ------------------------------------------
//		 helper functions
// -------------------------------------------


static DATE 
DateNow()
{		SYSTEMTIME SysTimeNow;
		GetSystemTime(&SysTimeNow);									// initialize with currrent time.
		DATE dateNow;
		SystemTimeToVariantTime(&SysTimeNow, &dateNow);
		return dateNow;
}


HRESULT 
CTVETestControl::AddToOutput(TCHAR *pszIn, BOOL fClear)
{
	const TCHAR CR = '\r';
	const TCHAR NL = '\n';

	if(NULL == pszIn) {
		return NULL;
	}

	if(fClear) {
		m_cszCurr = 0;
		m_cLines = 0;
	}

	if(m_cszMax < _tcslen(pszIn) + m_cszCurr  || m_cLines > m_kMaxLines) {
		if(m_szBuff) free(m_szBuff);
		m_cszMax = (_tcslen(pszIn) + m_cszCurr)*2 + 100;
		m_cLines = 0;
	}

	if(m_cLines == 0)
		memset((void*) m_rgszLineBuff, 0, sizeof(m_rgszLineBuff));

	if(!m_szBuff) m_szBuff = (TCHAR *) malloc(m_cszMax * sizeof(TCHAR));
	TCHAR *pb = m_szBuff + m_cszCurr;

	int nChars = 0;
	while(int c = *pszIn++)
	{
		if(c == 0x09)
			break;

		if(c == NL) 
			*pb++ = NL;
		else 
			*pb++ = (TCHAR) c;

		nChars++;

		if(c == NL) {
			m_rgszLineBuff[m_cLines++] = pb;
		}
	}
	if(nChars > 0 && *(pszIn-1) != NL) {			// auto tailing NL if not supplied
		*pb++ = NL;
		m_rgszLineBuff[m_cLines++] = pb;
	}

	*pb = '\0';

	m_cszCurr = pb - m_szBuff;

	FireViewChange();			// cause screen to be updated...

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CTVEControl

HRESULT 
CTVETestControl::FinalConstruct()
{
	HRESULT hr = S_OK;

	m_szBuff = NULL;					// Output buffer and it's size..
	m_cszCurr = 0;
	m_cszMax = 100*1024;


	AddToOutput(_T("*** TVE Events Test ***\n"), 0);


										// create a supervisor object...
	ITVESupervisorPtr spSuper;
	try
	{
		spSuper = ITVESupervisorPtr(CLSID_TVESupervisor);
	} catch (...) {
		return REGDB_E_CLASSNOTREG;
	}


	if(NULL == spSuper) 
		return E_OUTOFMEMORY;

	m_spSuper = spSuper;


#ifdef _USE_DISPEVENT
	hr = DispEventAdvise(m_spSuper);
#endif

										// start it running (muliticast adapter on Johnbrad11 here)
	try
	{
		hr = m_spSuper->put_Description(L"TVE Test Control");
		if(FAILED(hr)) return hr;

		hr = m_spSuper->TuneTo(L"BogusChannel",L"157.59.19.54");
		if(FAILED(hr)) return hr;
	} catch (...) {
		return E_FAIL;
	}

	return hr;
}

HRESULT 
CTVETestControl::InPlaceActivate(LONG iVerb, const RECT *prcPosRect)
{
	HRESULT hr = S_OK;
	hr = CComControlBase::InPlaceActivate(iVerb, prcPosRect);

	if(FAILED(hr) || iVerb != OLEIVERB_SHOW)
		return hr;

		// for this way to work, sink object needs to support ITVEEvents.
		//   which it doesn't with DispEvent stuff.
		// Need to create out of the Final Constructor?
#ifndef _USE_DISPEVENT
	if(SUCCEEDED(hr))
	{
										// get the events...
		IUnknownPtr spPunkSuper(m_spSuper);			// the event source
		IUnknownPtr spPunkSink(GetUnknown());		// this new event sink...

		if(m_dwTveEventsAdviseCookie) {
			spPunkSink->AddRef();					// circular reference count bug. fix.
			hr = AtlUnadvise(spPunkSuper,
							 DIID__ITVEEvents,
							 m_dwTveEventsAdviseCookie);		// need to pass to AtlUnadvise...
			m_dwTveEventsAdviseCookie = 0;
		}


		if(NULL == spPunkSuper)
			return E_NOINTERFACE;

		{
			IUnknownPtr spPunk = NULL;
			IUnknownPtr spPunk2 = NULL;
			hr = spPunkSink->QueryInterface(DIID__ITVEEvents, (void **) &spPunk);
			hr = spPunkSink->QueryInterface(__uuidof(TVEContrLib::_ITVEEvents), (void **)  &spPunk2);
			if(FAILED(hr))
			{
				AddToOutput(_T("Error : Sink doesn't support DIID__ITVEEvents Interface"), 0);
				return hr;
			}
		}

		hr = AtlAdvise(spPunkSuper,				// event source (TveSupervisor)
					   spPunkSink,				// event sink (gseg event listener...)
					   DIID__ITVEEvents,		// <--- hard line
					   &m_dwTveEventsAdviseCookie);	 // need to pass to AtlUnad	if(FAILED(hr))
		spPunkSink->Release();					// circular reference count bug..
	}
#endif

	if(FAILED(hr))
	{
		AddToOutput(_T("Error : Unable to create event sink"), 0);
	} else {
		AddToOutput(_T("Created Event Sink"), 0);
	}

	return hr;
}

//------------

void 
CTVETestControl::FinalRelease()
{

#ifndef _USE_DISPEVENT
	HRESULT hr;
	if(0 != m_dwTveEventsAdviseCookie)
	{
		if(m_spSuper) {

			IUnknownPtr spPunkSuper(m_spSuper);

			IUnknownPtr spPunkSink(GetUnknown());		// this new event sink...
			spPunkSink->AddRef();					// circular reference count bug. fix.
			hr = AtlUnadvise(spPunkSuper,
							 DIID__ITVEEvents,
							 m_dwTveEventsAdviseCookie);		// need to pass to AtlUnadvise...
			m_dwTveEventsAdviseCookie = 0;
		}
	}  
#else
	DispEventUnadvise(m_spSuper);
#endif

	if(m_szBuff) free(m_szBuff); m_szBuff=NULL;
}


// ========================================================================

HRESULT 
CTVETestControl::OnDraw(ATL_DRAWINFO& di)
{
	const TCHAR NL = '\n';

	RECT& rc = *(RECT*)di.prcBounds;
	Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

	SetTextAlign(di.hdcDraw, TA_LEFT|TA_TOP);

	int cLineSpacing = 16; 
	int cLines = (rc.bottom - rc.top)/cLineSpacing;
	if(cLines < 0) cLines = -cLines;

	int iLineStart = m_cLines - cLines;
	if(iLineStart < 0) iLineStart = 0;


	TCHAR *pIn = m_rgszLineBuff[iLineStart];

	TCHAR szOutBuff[1024];
	TCHAR *pOut = szOutBuff;
	int nLine = 0;

	while(*pIn != 0)
	{
		if(*pIn != NL) 
			*pOut++ = *pIn++;
		else {
			*pOut = 0;
			ExtTextOut(di.hdcDraw, rc.left+ 2, 2 + rc.top + nLine * cLineSpacing,
					   ETO_CLIPPED, &rc,
					   szOutBuff, pOut - szOutBuff, NULL);
			nLine++;
			pIn++;
			pOut = szOutBuff;
		}
	}

	return S_OK;
}


// ----------------------------------


STDMETHODIMP CTVETestControl::NotifyTVETune(/*[in]*/ NTUN_Mode tuneMode,/*[in]*/ ITVEService *pService,/*[in]*/ BSTR bstrDescription,/*[in]*/ BSTR bstrIPAdapter)
{

	TCHAR tzBuff[1024];

	CComBSTR bstrWhat;
	switch(tuneMode) {
	case NTUN_New:			bstrWhat = L"New"; break;
	case NTUN_Retune:		bstrWhat = L"Retune"; break;
	case NTUN_Reactivate:	bstrWhat = L"Reactivate"; break;
	case NTUN_Turnoff:		bstrWhat = L"Turn off"; break;
	default:
	case NTUN_Fail:			bstrWhat = L"Fail"; break;
	}

	_stprintf(tzBuff,_T("%S Tune: %S -> %S\n"), bstrWhat, bstrDescription, bstrIPAdapter);

	AddToOutput(tzBuff);
	return S_OK;
}

STDMETHODIMP CTVETestControl::NotifyTVEEnhancementNew(/*[in]*/ ITVEEnhancement *pEnh)
{
	TCHAR tzBuff[1024];
	
	CComBSTR bstrSessionName;
	CComBSTR bstrDescription;
	CComBSTR bstrUserName;

	pEnh->get_SessionName(&bstrSessionName);
	pEnh->get_Description(&bstrDescription);
	pEnh->get_UserName(&bstrUserName);

	_stprintf(tzBuff,_T("New Enhancement '%S' Desc '%S' userName '%S'"),bstrSessionName, bstrDescription, bstrUserName);
	AddToOutput(tzBuff);
	return S_OK;
}

		// changedFlags : NENH_grfDiff
STDMETHODIMP CTVETestControl::NotifyTVEEnhancementUpdated(/*[in]*/ ITVEEnhancement *pEnh, /*[in]*/ long lChangedFlags)
{

	TCHAR tzBuff[1024];

	CComBSTR bstrSessionName;
	CComBSTR bstrDescription;
	CComBSTR bstrUserName;

	pEnh->get_SessionName(&bstrSessionName);
	pEnh->get_Description(&bstrDescription);
	pEnh->get_UserName(&bstrUserName);

	_stprintf(tzBuff,_T("Updated Enhancement '%S' Desc '%S' userName '%S'"),bstrSessionName, bstrDescription, bstrUserName);

	AddToOutput(tzBuff);
	return S_OK;
}
	
STDMETHODIMP CTVETestControl::NotifyTVEEnhancementStarting(/*[in]*/ ITVEEnhancement *pEnh)
{
	TCHAR tzBuff[1024];

	CComBSTR bstrSessionName;
	CComBSTR bstrDescription;
	CComBSTR bstrUserName;

	pEnh->get_SessionName(&bstrSessionName);
	pEnh->get_Description(&bstrDescription);
	pEnh->get_UserName(&bstrUserName);

	_stprintf(tzBuff,_T("Starting Enhancement '%S' Desc '%S' userName '%S'"),bstrSessionName, bstrDescription, bstrUserName);

	AddToOutput(tzBuff);
	return S_OK;
}

STDMETHODIMP CTVETestControl::NotifyTVEEnhancementExpired(/*[in]*/ ITVEEnhancement *pEnh)
{
	TCHAR tzBuff[1024];

	CComBSTR bstrSessionName;
	CComBSTR bstrDescription;
	CComBSTR bstrUserName;

	pEnh->get_SessionName(&bstrSessionName);
	pEnh->get_Description(&bstrDescription);
	pEnh->get_UserName(&bstrUserName);

	_stprintf(tzBuff,_T("Expired Enhancement '%S' Desc '%S' userName '%S'"),bstrSessionName, bstrDescription, bstrUserName);

	AddToOutput(tzBuff);
	return S_OK;
}

STDMETHODIMP CTVETestControl::NotifyTVETriggerNew(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive)
{
	TCHAR tzBuff[1024];
	CComBSTR bstrName;
	CComBSTR bstrURL;
	CComBSTR bstrScript;

	pTrigger->get_Name(&bstrName);
	pTrigger->get_URL(&bstrURL);
	pTrigger->get_Script(&bstrScript);

	_stprintf(tzBuff,_T("New Trigger  %S:%S %S"),bstrName, bstrURL, bstrScript);

	AddToOutput(tzBuff);
	return S_OK;
}

		// changedFlags : NTRK_grfDiff
STDMETHODIMP CTVETestControl::NotifyTVETriggerUpdated(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive, /*[in]*/ long lChangedFlags)
{
	TCHAR tzBuff[1024];
	CComBSTR bstrName;
	CComBSTR bstrURL;
	CComBSTR bstrScript;

	pTrigger->get_Name(&bstrName);
	pTrigger->get_URL(&bstrURL);
	pTrigger->get_Script(&bstrScript);

	_stprintf(tzBuff,_T("Updated Trigger  %S:%S %S"),bstrName, bstrURL, bstrScript);

	AddToOutput(tzBuff);
	return S_OK;
}
	
STDMETHODIMP CTVETestControl::NotifyTVETriggerExpired(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive)
{
	TCHAR tzBuff[1024];
	CComBSTR bstrName;
	CComBSTR bstrURL;
	CComBSTR bstrScript;

	pTrigger->get_Name(&bstrName);
	pTrigger->get_URL(&bstrURL);
	pTrigger->get_Script(&bstrScript);

	_stprintf(tzBuff,_T("Expired Trigger %S:%S %S"),bstrName, bstrURL, bstrScript);

	AddToOutput(tzBuff);
	return S_OK;
}

STDMETHODIMP CTVETestControl::NotifyTVEPackage(/*[in]*/ NPKG_Mode engPkgMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUUID, /*[in]*/ long  cBytesTotal, /*[in]*/ long  cBytesReceived)
{
	TCHAR tzBuff[1024];
	
	CComBSTR spbsType;
	switch(engPkgMode)
	{
	case NPKG_Starting:  spbsType = "Starting";  break;
	case NPKG_Received:  spbsType = "Finished";  break;
	case NPKG_Duplicate: spbsType = "Duplicate"; break;	// only sent on packet 0
	case NPKG_Resend:    spbsType = "Resend";    break; // only sent on packet 0
	case NPKG_Expired:   spbsType = "Expired";   break;
	default: spbsType = "Unknown";
	}
	_stprintf(tzBuff,_T("Package %S: %S (%8.2f KBytes)"),spbsType, bstrUUID, cBytesTotal/1024.0f);

	AddToOutput(tzBuff);
	return S_OK;
}

STDMETHODIMP CTVETestControl::NotifyTVEFile(/*[in]*/ NFLE_Mode engFileMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUrlName, /*[in]*/ BSTR bstrFileName)
{
	TCHAR tzBuff[1024];
	_stprintf(tzBuff,_T("%s File: %S -> %S"), 
				  (engFileMode == NFLE_Received) ? _T("Received") :
				   ((engFileMode == NFLE_Expired) ? _T("Expired") : _T("Unknown Mode")),
				bstrUrlName, bstrFileName);

	AddToOutput(tzBuff);
	return S_OK;
}

		// WhatIsIt is NWHAT_Mode - lChangedFlags is NENH_grfDiff or NTRK_grfDiff treated as error bits
STDMETHODIMP CTVETestControl::NotifyTVEAuxInfo(/*[in]*/ NWHAT_Mode engAuxInfoMode, /*[in]*/ BSTR bstrAuxInfoString, /*[in]*/ long lChangedFlags, /*[in]*/ long lErrorLine)
{
	TCHAR tzBuff[1024];
	CComBSTR bstrWhat;
	switch(engAuxInfoMode) {
	case NWHAT_Announcement: bstrWhat = L"Annc"; break;
	case NWHAT_Trigger:		 bstrWhat = L"Trigger"; break;
	case NWHAT_Data:		 bstrWhat = L"Data"; break;
	default:
	case NWHAT_Other:		 bstrWhat = L"Other"; break;
	}
	_stprintf(tzBuff,_T("AuxInfo %S(%d): (line %d 0x%08x) %S\n"), 
		bstrWhat, engAuxInfoMode, lErrorLine, lChangedFlags, bstrAuxInfoString);
	AddToOutput(tzBuff);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testsend\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testevents2\tvetestcontrol.h ===
// TVETestControl.h : Declaration of the CTVETestControl

#ifndef __TVETESTCONTROL_H_
#define __TVETESTCONTROL_H_

#include "resource.h"       // main symbols
#include <atlctl.h>

							// Beginning ATL Com (pg 317)
#ifdef _USE_DISPEVENT

#import "..\..\tvecontr\objd\i386\TveContr.tlb" no_namespace, named_guids, raw_interfaces_only, raw_native_types		
const int CID_TVEEvents = 16661;			// totally arbitrary number

#else

#import "..\..\tvecontr\objd\i386\TveContr.tlb" named_guids, raw_interfaces_only, raw_native_types		

#endif


_COM_SMARTPTR_TYPEDEF(ITVESupervisor,           __uuidof(ITVESupervisor));

/////////////////////////////////////////////////////////////////////////////
// CTVETestControl
class ATL_NO_VTABLE CTVETestControl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CStockPropImpl<CTVETestControl, ITVETestControl, &IID_ITVETestControl, &LIBID_TESTEVENTS2Lib>,
	public CComControl<CTVETestControl>,
	public IPersistStreamInitImpl<CTVETestControl>,
	public IOleControlImpl<CTVETestControl>,
	public IOleObjectImpl<CTVETestControl>,
	public IOleInPlaceActiveObjectImpl<CTVETestControl>,
	public IViewObjectExImpl<CTVETestControl>,
	public IOleInPlaceObjectWindowlessImpl<CTVETestControl>,
	public IPersistStorageImpl<CTVETestControl>,
	public ISpecifyPropertyPagesImpl<CTVETestControl>,
	public IQuickActivateImpl<CTVETestControl>,
	public IDataObjectImpl<CTVETestControl>,
	public IProvideClassInfo2Impl<&CLSID_TVETestControl, NULL, &LIBID_TESTEVENTS2Lib>,
#ifdef _USE_DISPEVENT
	public IDispEventImpl<CID_TVEEvents, CTVETestControl, &DIID__ITVEEvents, &LIBID_TVEContrLib, 1, 0>, 
#else
//	public _ITVEEvents,
#endif
	public CComCoClass<CTVETestControl, &CLSID_TVETestControl>
{
public:
	CTVETestControl() : m_dwTveEventsAdviseCookie(0), m_cLines(0)
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVETESTCONTROL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTVETestControl)
	COM_INTERFACE_ENTRY(ITVETestControl)
#ifdef _USE_DISPEVENT
	COM_INTERFACE_ENTRY(IDispatch)
#else
	COM_INTERFACE_ENTRY2(IDispatch, ITVETestControl)
	                // magic line of code, support _ITVEEvents as IDispatch...
	COM_INTERFACE_ENTRY_IID(__uuidof(TVEContrLib::_ITVEEvents), IDispatch) // TVEContrLib::DIID__ITVEEvents, IDispatch)	
#endif

	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_PROP_MAP(CTVETestControl)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	PROP_ENTRY("ForeColor", DISPID_FORECOLOR, CLSID_StockColorPage)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CTVETestControl)
	CHAIN_MSG_MAP(CComControl<CTVETestControl>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

#ifdef _USE_DISPEVENT
BEGIN_SINK_MAP(CTVETestControl)
	SINK_ENTRY_EX(CID_TVEEvents, DIID__ITVEEvents, 2101, NotifyTVETune)
	SINK_ENTRY_EX(CID_TVEEvents, DIID__ITVEEvents, 2102, NotifyTVEEnhancementNew)
	SINK_ENTRY_EX(CID_TVEEvents, DIID__ITVEEvents, 2103, NotifyTVEEnhancementUpdated)
	SINK_ENTRY_EX(CID_TVEEvents, DIID__ITVEEvents, 2104, NotifyTVEEnhancementStarting)
	SINK_ENTRY_EX(CID_TVEEvents, DIID__ITVEEvents, 2105, NotifyTVEEnhancementExpired)
	SINK_ENTRY_EX(CID_TVEEvents, DIID__ITVEEvents, 2106, NotifyTVETriggerNew)
	SINK_ENTRY_EX(CID_TVEEvents, DIID__ITVEEvents, 2107, NotifyTVETriggerUpdated)
	SINK_ENTRY_EX(CID_TVEEvents, DIID__ITVEEvents, 2108, NotifyTVETriggerExpired)
	SINK_ENTRY_EX(CID_TVEEvents, DIID__ITVEEvents, 2109, NotifyTVEPackage)
	SINK_ENTRY_EX(CID_TVEEvents, DIID__ITVEEvents, 2110, NotifyTVEFile)
	SINK_ENTRY_EX(CID_TVEEvents, DIID__ITVEEvents, 2111, NotifyTVEAuxInfo)
END_SINK_MAP() 
#endif

// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)


public:
// ITVETestControl
	HRESULT FinalConstruct();
	HRESULT InPlaceActivate(LONG iVerb, const RECT *prcPosRect);

	void FinalRelease();

	HRESULT OnDraw(ATL_DRAWINFO& di);
	OLE_COLOR m_clrForeColor;

// Events
public:

	HRESULT AddToOutput(TCHAR *pszIn, BOOL fClear = false);


	// _ITVEEvents
	STDMETHOD(NotifyTVETune)(/*[in]*/ NTUN_Mode tuneMode,/*[in]*/ ITVEService *pService,/*[in]*/ BSTR bstrDescription,/*[in]*/ BSTR bstrIPAdapter);
	STDMETHOD(NotifyTVEEnhancementNew)(/*[in]*/ ITVEEnhancement *pEnh);
		// changedFlags : NENH_grfDiff
	STDMETHOD(NotifyTVEEnhancementUpdated)(/*[in]*/ ITVEEnhancement *pEnh, /*[in]*/ long lChangedFlags);	
	STDMETHOD(NotifyTVEEnhancementStarting)(/*[in]*/ ITVEEnhancement *pEnh);
	STDMETHOD(NotifyTVEEnhancementExpired)(/*[in]*/ ITVEEnhancement *pEnh);
	STDMETHOD(NotifyTVETriggerNew)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive);
		// changedFlags : NTRK_grfDiff
	STDMETHOD(NotifyTVETriggerUpdated)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive, /*[in]*/ long lChangedFlags);	
	STDMETHOD(NotifyTVETriggerExpired)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive);
	STDMETHOD(NotifyTVEPackage)(/*[in]*/ NPKG_Mode engPkgMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUUID, /*[in]*/ long  cBytesTotal, /*[in]*/ long  cBytesReceived);
	STDMETHOD(NotifyTVEFile)(/*[in]*/ NFLE_Mode engFileMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUrlName, /*[in]*/ BSTR bstrFileName);
		// WhatIsIt is NWHAT_Mode - lChangedFlags is NENH_grfDiff or NTRK_grfDiff treated as error bits
	STDMETHOD(NotifyTVEAuxInfo)(/*[in]*/ NWHAT_Mode engAuxInfoMode, /*[in]*/ BSTR bstrAuxInfoString, /*[in]*/ long lChangedFlags, /*[in]*/ long lErrorLine);	

private:
	ITVESupervisorPtr			m_spSuper;					// main supervisor object

//	_ITVEEventsPtr				m_spTVEEvents;
	DWORD						m_dwTveEventsAdviseCookie;

	TCHAR						*m_szBuff;					// Output buffer and it's size..
	UINT						m_cszCurr;
	UINT						m_cszMax;

	enum						{m_kMaxLines  = 1000};
	TCHAR						*m_rgszLineBuff[m_kMaxLines];
	UINT						m_cLines;

};

#endif //__TVETESTCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testgseg2\gsegdlg.cpp ===
// GSegDlg.cpp : Implementation of CGSegDlg
#include "stdafx.h"
#include "GSegDlg.h"
#include <stdio.h>		// needed in the release build..
#include <Oleauto.h>	// IErrorInfo

//#include <comdef.h>  // causes bad things to happen when included...


namespace TVEGSegLib {
//#include "..\TveGSeg\objd\i386\TveGSeg.h" 
//#include "..\TveGSeg\objd\i386\TveGSeg_i.c"
}
						// use the #include or no 'no_namespace' here due to UINT_PTR redef problem 
//#import "..\..\TveGSeg\objd\i386\TveGSeg.tlb"  named_guids raw_interfaces_only 

						// don't want 'no_namespace' here because of conflicts with GSeg
						// if use this::: get SegDlg.obj : fatal error LNK1179: invalid or corrupt file: duplicate comdat "_IID_ITVEVariation"
//#import "..\..\TveContr\objd\i386\TveContr.tlb" named_guids raw_interfaces_only 

#include "F:\nt\multimedia\Published\DXMDev\dshowdev\idl\objd\i386\msvidctl.h" 
//#include "..\..\..\VidCtl\TveGSeg\objd\i386\TveGSeg.h" 

// -------------------
#include <initguid.h>
/*
#include "..\TveContr\objd\i386\TveContr.h"				// can't namespace this since used in TveGSeg
#include "..\TveContr\objd\i386\TveContr_i.c"			
*/



// ---------------

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


void __stdcall _com_issue_error(HRESULT hr)
{
	TCHAR tzbuff[256];
	_tprintf(tzbuff,_T("Error 0x%0x8\n"),hr);
	MessageBox(NULL,tzbuff,_T("Caption"),MB_OK);
}

// ----------------------------------------------------------------------

UINT	  g_cszCurr = 0;
UINT	  g_cszMax = 1024*128;
TCHAR	 *g_tszBuff = NULL;

TCHAR * AddCR(TCHAR *pszIn);
void ResetCR()
{
	g_cszCurr = 0;
}
// -------------------------------------------------------------------------
				// dialog texts seems to require \CR\NL ...
TCHAR * 
AddCR(TCHAR *pszIn)		// edit window must be marked multi-line/want return
{
	const TCHAR CR = '\r';
	const TCHAR NL = '\n';
	if(g_cszMax < _tcslen(pszIn)) {
		if(g_tszBuff) free(g_tszBuff);
		g_cszMax = _tcslen(pszIn) + 10000;
		g_cszCurr = 0;			// auto start over again...
	}

	if(!g_tszBuff) g_tszBuff = (TCHAR *) malloc(g_cszMax * sizeof(TCHAR));
	TCHAR *pb = g_tszBuff + g_cszCurr;

	
	while(int c = *pszIn++)
	{
		if(c == NL) *pb++ = CR;
		*pb++ = (TCHAR) c;
	}
	*pb = '\0';
	g_cszCurr = _tcslen(g_tszBuff);
	return g_tszBuff;
}
// /////////////////////////////////////////////////////////////////////////
//
//   DoErrorMsg;
// ---------------------------------
HRESULT 
CGSegDlg::DoErrorMsg(HRESULT hrIn, BSTR bstrMsg)
{
	USES_CONVERSION;
	CComBSTR bstrError;					// Professional ATL COM programming (pg 322) with mods
	bstrError += bstrMsg;
	bstrError += L"\n";
	{
		static WCHAR wbuff[1024];
		HMODULE hMod = GetModuleHandleA("AtvefSend");

		if(0 == FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
								hMod, 
								hrIn,
								0, //LANG_NEUTRAL,
								 wbuff,
								 sizeof(wbuff) / sizeof(wbuff[0]) -1,
								 NULL))
		{
			if(0 == FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
									NULL, 
									hrIn,
									0, //LANG_NEUTRAL,
									wbuff,
									sizeof(wbuff) / sizeof(wbuff[0]) -1,
									NULL))
			{

				int err = GetLastError();
				swprintf(wbuff,L"Unknown Error");
			}
		}
		bstrError += wbuff;
		swprintf(wbuff, L"\nError 0x%08x\n",hrIn);
		bstrError += wbuff;
	}
/*
	CComPtr<ISupportErrorInfo> pSEI;
	HRESULT hr1 = pUnk->QueryInterface(&pSEI);
	if(SUCCEEDED(hr1))
	{
		hr1 = pSEI->InterfaceSupportsErrorInfo(rUUID);
		if(S_OK == hr1)
		{
										// try to get the error object
			CComPtr<IErrorInfo> pEI;
			if(S_OK == GetErrorInfo(0, &pEI))
			{
				CComBSTR bstrDesc, bstrSource;
				pEI->GetDescription(&bstrDesc);
				bstrError += bstrDesc;
				bstrError += L" In ";
				pEI->GetSource(&bstrSource);
				bstrError += bstrSource;
			}
		}

	}
*/
	MessageBox(W2T(bstrError),_T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CTestDlg

_COM_SMARTPTR_TYPEDEF(IMSVidTVEGSeg,				__uuidof(IMSVidTVEGSeg));


//TVEGSegLib::IMSVidTVEGSegPtr g_spGSeg=NULL;				// global GSeg to test with
IMSVidTVEGSegPtr g_spGSeg=NULL;				// global GSeg to test with


LRESULT 
CGSegDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	USES_CONVERSION;

	return 1;			// Let the system set the focus
}

LRESULT 
CGSegDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

	g_spGSeg = NULL;	// make sure to release our GSeg if if we created it...

	if(g_tszBuff) {
		delete g_tszBuff;
		g_tszBuff = 0;
	}
	DestroyWindow();
	PostQuitMessage(0);

//	EndDialog(wID);		// wrong - needs non-modal destroy
	return 0;
}


LRESULT 
CGSegDlg::OnTest1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	try 
	{
		HRESULT hr = S_OK;
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Test1\n");
	
		TVEGSegLib::IMSVidTVEGSegPtr spGSeg;
		spGSeg = TVEGSegLib::IMSVidTVEGSegPtr(TVEGSegLib::CLSID_MSVidTVEGSeg);
		if(NULL == spGSeg) {
			SetDlgItemText(IDC_EDIT1, AddCR(_T("Unable to create graph segment")));
			return E_FAIL;
		}

//		TVEGSegLib::ITVESupervisorPtr spSuper;
//		hr = spGSeg->get_Supervisor(&spSuper);

//		if(FAILED(hr)) {
//			SetDlgItemText(IDC_EDIT1, AddCR(_T("Unable to get Supervisor")));
//			return hr;
//		} else {
//			SetDlgItemText(IDC_EDIT1, AddCR(_T("Succsessfully got Supervisor")));
//		}

				// do the put_StationID after making sure there is a supervisor...
		hr = spGSeg->put_StationID(L"TestGSeg2 Station");
		if(FAILED(hr)) {
			SetDlgItemText(IDC_EDIT1, AddCR(_T("Failed put_StationID - no Filter/Supervisor")));
			return hr;
		} 

/*		CComBSTR bstrAdapterAddr;
		hr = spGSeg->get_IPAdapterAddress(&bstrAdapterAddr);
		hr = spGSeg->put_IPAdapterAddress(bstrAdapterAddr);

		hr = spGSeg->ReTune();
		if(FAILED(hr))
		{
			SetDlgItemText(IDC_EDIT1, AddCR(_T("TuneTo Failed")));
			return hr;
		}

*/
		TVEGSegLib::ITVESupervisorPtr spSuper;
		hr = spGSeg->get_Supervisor(&spSuper);
		if(FAILED(hr)) {
			SetDlgItemText(IDC_EDIT1, AddCR(_T("Unable to get Supervisor")));
			return hr;
		}

		TVEGSegLib::ITVESupervisor_HelperPtr spSuperHelper(spSuper);
		spSuperHelper->DumpToBSTR(&bstrDump);
		
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	}
//	catch (_com_error e)  
	catch (...)  
	{
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Tossed an Error\n"));
//		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
//				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
//		_stprintf(tszBuff,
//				 _T("Error (%08x) in %s: \n\n%s"), e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description()
//				 _T("Error (%08x) "),e.Error()
//				 );

		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	} 

	return 0;
}




LRESULT 
CGSegDlg::OnTest2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	try 
	{
		HRESULT hr = S_OK;
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Test2\n");

		if(NULL == g_spGSeg)
		{
			g_spGSeg = TVEGSegLib::IMSVidTVEGSegPtr(TVEGSegLib::CLSID_MSVidTVEGSeg);
			if(NULL == g_spGSeg) {
				SetDlgItemText(IDC_EDIT1, AddCR(_T("Unable to create graph segment")));
				return E_FAIL;
			}

			SetDlgItemText(IDC_EDIT1, AddCR(_T("Created TVE Graph Segment")));

		}

		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	}
	catch (...)  
	{
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Tossed an Error\n"));
		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	} 

	return 0;
}

LRESULT 
CGSegDlg::OnTest3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	try 
	{
		HRESULT hr = S_OK;
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Test3\n");
	
		if(g_spGSeg)
		{
			TVEGSegLib::ITVESupervisorPtr spSuper;
			hr = g_spGSeg->get_Supervisor(&spSuper);
			if(FAILED(hr)) {
				SetDlgItemText(IDC_EDIT1, AddCR(_T("Unable to get Supervisor")));
				return hr;
			}

			TVEGSegLib::ITVESupervisor_HelperPtr spSuperHelper(spSuper);
			spSuperHelper->DumpToBSTR(&bstrDump);
			
			ResetCR();
			SetDlgItemText(IDC_EDIT1, AddCR(_T("    vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n")));
			SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		} else {
			SetDlgItemText(IDC_EDIT1, AddCR(_T("Use Test2 to create a GSeg first\n")));
		}

	}
//	catch (_com_error e)  
	catch (...)  
	{
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Tossed an Error\n"));
		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	} 
	return 0;
}

LRESULT 
CGSegDlg::OnTest4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	try 
	{
		HRESULT hr = S_OK;
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Test4\n");
	
		if(g_spGSeg)
		{
			CComVariant varResult;
			CComVariant* pvars = new CComVariant[0];

			IDispatchPtr spDispatch(g_spGSeg);
	//		TVEGSegLib::IMSVidTVEGSegPtr spDispatchGS(g_spGSeg);
	//		CComPtr<TVEGSegLib::IMSVidTVEGSeg> spDispatchGS;
	//		hr = g_spGSeg->QueryInterface(&spDispatchGS);
			

			if (spDispatch != NULL)
			{
				VariantClear(&varResult);
				DISPPARAMS disp = { pvars, NULL, 0, 0 };
							// this should call 'About'
								// first one fails, wrong interface (no about)

				FILE *fp = fopen("test.txt","w+");
				for(int i = 0; i < 2500; i++) {
					hr = spDispatch->Invoke(i, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);			
					if(0x80020003 != hr)
						fprintf(fp,"%8d : 0x%08x %s\n",i,hr, hr==S_OK ? "<<<<<<" : "");
				}
				fclose(fp);
			}
		}
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (...)  
	{
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Tossed an Error\n"));
		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	} 

	return 0;
}

LRESULT 
CGSegDlg::OnTest5(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	try 
	{
		HRESULT hr = S_OK;
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Test5\n");

		TVEGSegLib::NWHAT_Mode engAuxInfoMode = TVEGSegLib::NWHAT_Other;
		BSTR bstrAuxInfoString(L"AuxInfo String");
		LONG lChangedFlags = 0x12345;
		LONG lErrorLine = 12345;
	
		if(g_spGSeg)
		{
			CComVariant varResult;
			CComVariant* pvars = new CComVariant[4];

			IDispatchPtr spDispatch(g_spGSeg);
	
			if (spDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[3] = engAuxInfoMode;
				pvars[2] = bstrAuxInfoString;
				pvars[1] = lChangedFlags;
				pvars[0] = lErrorLine;
						// a bogus event
				DISPPARAMS disp = { pvars, NULL, 4, 0 };
				spDispatch->Invoke(2111, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	}
	catch (...)  
	{
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Tossed an Error\n"));
		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	} 

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testgseg2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TestGSeg2.rc
//
#define IDS_PROJNAME                    100
#define IDR_TestGSeg2                   100
#define IDD_GSEGDLG                     101
#define IDC_EDIT1                       201
#define IDC_TEST1                       203
#define IDC_TEST2                       204
#define IDC_TEST3                       205
#define IDC_TEST4                       206
#define IDC_TEST5                       207

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         204
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testgseg2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__33B0C007_FB46_4710_A73E_158E46B9D527__INCLUDED_)
#define AFX_STDAFX_H__33B0C007_FB46_4710_A73E_158E46B9D527__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__33B0C007_FB46_4710_A73E_158E46B9D527__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testgseg2\gsegdlg.h ===
// GSegDlg.h : Declaration of the CGSegDlg

#ifndef __GSEGDLG_H_
#define __GSEGDLG_H_

#include "resource.h"       // main symbols
#include <atlhost.h>
//#include "CommCtrl.h"
//#include "comdef.h"

/////////////////////////////////////////////////////////////////////////////
// CGSegDlg
class CGSegDlg : 
	public CAxDialogImpl<CGSegDlg>
{
public:
	CGSegDlg()
	{
	}

	~CGSegDlg()
	{
	}

	HRESULT DoErrorMsg(HRESULT hrIn, BSTR bstrMsg);

	enum { IDD = IDD_GSEGDLG };

BEGIN_MSG_MAP(CGSegDlg)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	COMMAND_ID_HANDLER(IDC_TEST1, OnTest1)
	COMMAND_ID_HANDLER(IDC_TEST2, OnTest2)
	COMMAND_ID_HANDLER(IDC_TEST3, OnTest3)
	COMMAND_ID_HANDLER(IDC_TEST4, OnTest4)
	COMMAND_ID_HANDLER(IDC_TEST5, OnTest5)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest5(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

#endif //__GSEGDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testsend\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TestSend.rc
//
#define IDS_PROJNAME                    100
#define IDR_TestSend                    100
#define IDD_TESTDLG                     201
#define IDC_EDIT1                       202
#define IDC_README                      203
#define IDC_TESTA_ANNC1                 210
#define IDC_TESTA_ANNC2                 211
#define IDC_TESTA_TRIGA1                212
#define IDC_TESTA_TRIGA2                213
#define IDC_TESTA_FILEA1                214
#define IDC_TESTA_FILEA2                215
#define IDC_TESTA_DIRA1                 216
#define IDC_TESTA_DIRA2                 217
#define IDC_TESTA_L21TRIG1              218
#define IDC_TESTA_L21TRIG2              219
#define IDC_AnncID1                     220
#define IDC_AnncID2                     221
#define IDC_AnncID3                     222
#define IDC_AnncID4                     223
#define IDC_ChannelID1                  224
#define IDC_ChannelID2                  225
#define IDC_ChannelID3                  226
#define IDC_ChannelID4                  227
#define IDC_TrackID1                    228
#define IDC_TrackID2                    229
#define IDC_TrackID3                    230
#define IDC_TrackID4                    231
#define IDC_EnhncID1                    232
#define IDC_EnhncID2                    233
#define IDC_EnhncID3                    234
#define IDC_EnhncID4                    235
#define IDC_CVariaID1                   236
#define IDC_CVariaID2                   237
#define IDC_CVariaID3                   238
#define IDC_CVariaID4                   239
#define IDC_VariaID1                    240
#define IDC_VariaID2                    241
#define IDC_VariaID3                    242
#define IDC_VariaID4                    243
#define IDC_TESTA_TRIGG                 244
#define IDC_TESTA_L21TRIGG              245
#define IDC_TrigID1                     247
#define IDC_TrigID2                     248
#define IDC_TrigID3                     249
#define IDC_InsIPADDRESS                250
#define IDC_InsPORT                     251
#define IDC_InsCHECK                    252
#define IDC_TrigID4                     253
#define IDC_EDITFRAMENAME               254
#define IDC_IPADDRESS1                  256
#define IDC_EDIT2                       257
#define IDC_EDITURL                     257
#define IDC_EDITSCRIPT                  258
#define IDC_EDITBASEURL                 259
#define IDC_CHECKNONAME                 260
#define IDC_COMBO_EXTHEADERS            261
#define IDC_EDITDIRPATH                 262

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        205
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         262
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testgseg2\testgseg2.cpp ===
// TestGSeg2.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f TestGSeg2ps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"

#include "GSegDlg.h"
#include "commctrl.h"

#include <initguid.h>
#include "TestGSeg2.h"
#include "TestGSeg2_i.c"

const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, 
	LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
	xcvxcv
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif
    _ASSERTE(SUCCEEDED(hRes));
    _Module.Init(ObjectMap, hInstance, &LIBID_TESTGSEG2Lib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_TestGSeg2, FALSE);
            nRet = _Module.UnregisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_TestGSeg2, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

#ifdef _DEBUG
	_CrtMemState s1, s2, s3;
#endif
		// Store a memory checkpoint in the s1 memory-state structure
	 _CrtMemCheckpoint( &s1 );

    if (bRun)
    {
        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

		INITCOMMONCONTROLSEX icce;
		icce.dwSize = sizeof(INITCOMMONCONTROLSEX);
		icce.dwICC = ICC_INTERNET_CLASSES;
		BOOL fOK = InitCommonControlsEx(&icce); 

		{
              CGSegDlg dlg;                           // display the dialog...
              if(!dlg.Create(NULL))
              {
                      MessageBox(NULL,_T("Failed To Create Dialog"),_T("This Sucks"),MB_OK);
                      goto exit_this;
              }
              dlg.ShowWindow(SW_SHOWNORMAL);

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);
		}

exit_this:
        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish
    }

#ifdef _DEBUG
	 _CrtMemCheckpoint( &s2 );
	 if ( _CrtMemDifference( &s3, &s1, &s2 ) ) 
	 {
		_RPT0(_CRT_WARN, "*** Detected Memory Memory Leaks ***\n");
		
        if(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_LEAK_CHECK_DF)
		{
			_CrtMemDumpAllObjectsSince(&s1);
		}
	 } else {
		_RPT0(_CRT_WARN, "*** No Memory Leaks Detected\n");
	 }
	 _CrtMemDumpStatistics( &s3 );
 	 _CrtSetDbgFlag(0);		// turn off more memory leaks, this exe leaks 40+ objects
#endif

    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testsend\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D512BEB9_2CD0_4184_B00D_D23372649809__INCLUDED_)
#define AFX_STDAFX_H__D512BEB9_2CD0_4184_B00D_D23372649809__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D512BEB9_2CD0_4184_B00D_D23372649809__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testsend\testsend.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TestSend.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f TestSendps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TestSend.h"

#include "TestSend_i.c"
#include "TestDlg.h"

#include "commctrl.h"

const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/){
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif
    _ASSERTE(SUCCEEDED(hRes));
    _Module.Init(ObjectMap, hInstance, &LIBID_TESTSENDLib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_TestSend, FALSE);
            nRet = _Module.UnregisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_TestSend, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

#ifdef _DEBUG
	_CrtMemState s1, s2, s3;
#endif
		// Store a memory checkpoint in the s1 memory-state structure
	 _CrtMemCheckpoint( &s1 );

	 if (bRun)
    {
        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

		INITCOMMONCONTROLSEX icce;
		icce.dwSize = sizeof(INITCOMMONCONTROLSEX);
		icce.dwICC = ICC_INTERNET_CLASSES;
		BOOL fOK = InitCommonControlsEx(&icce);

		{
 			CTestDlg dlg;				// display the dialog...
			if(!dlg.Create(NULL))
			{
				MessageBox(NULL,_T("Failed To Create Dialog"),_T("This Sucks"),MB_OK);
				goto exit_this;
			}
			dlg.ShowWindow(SW_SHOWNORMAL);

			MSG msg;
			while (GetMessage(&msg, 0, 0, 0))
			{
				TranslateMessage(&msg);
				DispatchMessage(&msg);
			}
		}
exit_this:
        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish
    }

			// Store another memory checkpoint in the s2 memory-state structure
#ifdef _DEBUG
	 _CrtMemCheckpoint( &s2 );
	 if ( _CrtMemDifference( &s3, &s1, &s2 ) ) 
	 {
		_RPT0(_CRT_WARN, "*** Detected Memory Memory Leaks ***\n");
		
        if(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_LEAK_CHECK_DF)
		{
			_CrtMemDumpAllObjectsSince(&s1);
		}
	 } else {
		_RPT0(_CRT_WARN, "*** No Memory Leaks Detected\n");
	 }
	 _CrtMemDumpStatistics( &s3 );
 	 _CrtSetDbgFlag(0);		// turn off more memory leaks, this exe leaks 40+ objects
#endif

    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testsend\testdlg.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TestDlg.h : Declaration of the CTestDlg

#ifndef __TESTDLG_H_
#define __TESTDLG_H_

#include "resource.h"       // main symbols
#include <atlhost.h>
#include "CommCtrl.h"

struct IATVEFAnnouncement;
/////////////////////////////////////////////////////////////////////////////
// CTestDlg
class CTestDlg : 
	public CAxDialogImpl<CTestDlg>
{
public:
	CTestDlg()
	{
		m_iChannel = 1;
		m_iAnnc  = 1;
		m_iEnhnc = 1;
		m_iVaria = 1;
		m_iTrack = 1;
		m_iTrig  = 1;
		m_cVaria  = 1;
		m_fNoName = false;

		m_iSAPMsgIDHash = 1;
		m_iAnncVer = 1;
	}

	~CTestDlg()
	{
	}

	enum { IDD = IDD_TESTDLG };

	int m_iChannel;
	int m_iAnnc;
	int m_iEnhnc;
	int m_iVaria;
	int m_iTrack;
	int m_iTrig;
	BOOL m_fNoName;

	int m_iSAPMsgIDHash;
	int m_iAnncVer;
	int m_cVaria;
	

	DWORD m_dwInsIPAddr;
	USHORT m_usInsIPPort;
	bool m_fInsUse;

BEGIN_MSG_MAP(CTestDlg)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)

	COMMAND_ID_HANDLER(IDC_TESTA_ANNC1,		OnTestA_Annc1)

	COMMAND_ID_HANDLER(IDC_TESTA_DIRA1,		OnTestA_DirA1)
	COMMAND_ID_HANDLER(IDC_TESTA_DIRA2,		OnTestA_DirA2)
	COMMAND_ID_HANDLER(IDC_TESTA_TRIGA1,	OnTestA_TrigA1)
	COMMAND_ID_HANDLER(IDC_TESTA_FILEA1,	OnTestA_FileA1)

	COMMAND_ID_HANDLER(IDC_TESTA_FILEA2,	OnTestA_FileA2)


	COMMAND_ID_HANDLER(IDC_TESTA_L21TRIG1,	OnTestA_L21Trig1)

	COMMAND_ID_HANDLER(IDC_TESTA_TRIGG,		OnTestA_TrigG)
	COMMAND_ID_HANDLER(IDC_TESTA_L21TRIGG,	OnTestA_L21TrigG)

	COMMAND_HANDLER(IDC_ChannelID1, BN_CLICKED,			OnChannelID1)
	COMMAND_HANDLER(IDC_ChannelID2, BN_CLICKED,			OnChannelID2)
	COMMAND_HANDLER(IDC_ChannelID3, BN_CLICKED,			OnChannelID3)
	COMMAND_HANDLER(IDC_ChannelID4, BN_CLICKED,			OnChannelID4)

	COMMAND_HANDLER(IDC_AnncID1,	BN_CLICKED,			OnAnncID1)
	COMMAND_HANDLER(IDC_AnncID2,	BN_CLICKED,			OnAnncID2)
	COMMAND_HANDLER(IDC_AnncID3,	BN_CLICKED,			OnAnncID3)
	COMMAND_HANDLER(IDC_AnncID4,	BN_CLICKED,			OnAnncID4)

	COMMAND_HANDLER(IDC_EnhncID1,	BN_CLICKED,			OnEnhncID1)
	COMMAND_HANDLER(IDC_EnhncID2,	BN_CLICKED,			OnEnhncID2)
	COMMAND_HANDLER(IDC_EnhncID3,	BN_CLICKED,			OnEnhncID3)
	COMMAND_HANDLER(IDC_EnhncID4,	BN_CLICKED,			OnEnhncID4)

	COMMAND_HANDLER(IDC_CVariaID1,	BN_CLICKED,			OnCVariaID1)
	COMMAND_HANDLER(IDC_CVariaID2,	BN_CLICKED,			OnCVariaID2)
	COMMAND_HANDLER(IDC_CVariaID3,	BN_CLICKED,			OnCVariaID3)
	COMMAND_HANDLER(IDC_CVariaID4,	BN_CLICKED,			OnCVariaID4)

	COMMAND_HANDLER(IDC_VariaID1,	BN_CLICKED,			OnVariaID1)
	COMMAND_HANDLER(IDC_VariaID2,	BN_CLICKED,			OnVariaID2)
	COMMAND_HANDLER(IDC_VariaID3,	BN_CLICKED,			OnVariaID3)
	COMMAND_HANDLER(IDC_VariaID4,	BN_CLICKED,			OnVariaID4)

	COMMAND_HANDLER(IDC_TrackID1,	BN_CLICKED,			OnTrackID1)
	COMMAND_HANDLER(IDC_TrackID2,	BN_CLICKED,			OnTrackID2)
	COMMAND_HANDLER(IDC_TrackID3,	BN_CLICKED,			OnTrackID3)
	COMMAND_HANDLER(IDC_TrackID4,	BN_CLICKED,			OnTrackID4)

	COMMAND_HANDLER(IDC_TrigID1,	BN_CLICKED,			OnTrigID1)
	COMMAND_HANDLER(IDC_TrigID2,	BN_CLICKED,			OnTrigID2)
	COMMAND_HANDLER(IDC_TrigID3,	BN_CLICKED,			OnTrigID3)
	COMMAND_HANDLER(IDC_TrigID4,	BN_CLICKED,			OnTrigID4)

	COMMAND_HANDLER(IDC_InsCHECK,	BN_CLICKED,			OnInsCheckID)

	COMMAND_ID_HANDLER(IDC_README, OnReadMe) 

	COMMAND_HANDLER(IDC_InsPORT, EN_KILLFOCUS, OnKillfocusInsPort)
	COMMAND_HANDLER(IDC_InsPORT, EN_SETFOCUS, OnSetfocusInsPort)

	NOTIFY_HANDLER(IDC_IPADDRESS1, IPN_FIELDCHANGED, OnFieldchangedIPAddress1)
	COMMAND_HANDLER(IDC_CHECKNONAME, BN_CLICKED, OnClickedCheckNoName)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
	//	EndDialog(wID);
		return 0;
	}

	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnRun(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnTestA_Annc1 (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTestA_DirA1 (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTestA_DirA2 (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTestA_TrigA1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTestA_FileA1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTestA_FileA2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnTestA_L21Trig1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnTestA_TrigG(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTestA_L21TrigG(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTestA_PutURL(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnChannelID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnChannelID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnChannelID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnChannelID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnAnncID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnAnncID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnAnncID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnAnncID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnEnhncID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnEnhncID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnEnhncID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnEnhncID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnCVariaID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCVariaID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCVariaID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCVariaID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnVariaID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnVariaID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnVariaID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnVariaID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnTrackID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTrackID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTrackID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTrackID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnTrigID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTrigID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTrigID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTrigID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	
	
	LRESULT OnInsCheckID(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnReadMe(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
	HRESULT ConfigAnnc(IATVEFAnnouncement *pAnnc, int nVariations=1);
	LRESULT OnSelchangeCombo_CEnhnc(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	void	EnableVariaButtons();
	void	EnableInserterAddr();
	void	PutURL();

	HRESULT DoErrorMsg(HRESULT hrIn, BSTR bstrMsg);
	HRESULT	CreateTestFile(BSTR bstrFileName, int nLines);
	LRESULT OnKillfocusInsPort(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnSetfocusInsPort(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);


	LRESULT OnFieldchangedIPAddress1(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
	{
		// TODO : Add Code for control notification handler.
		return 0;
	}
	LRESULT OnClickedCheckNoName(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

#endif //__TESTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testtve2\anncexamp.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// ---------------------------------
//  AnncExamp.h
//

#ifndef __ANNCEXAMP_H__
#define __ANNCEXAMP_H__
// --------------------------------------------------------------------
//	SzGetAnnounce(char *szId)
//			Various example SAP announcement strings
//
//			szID is either:
//				"a"			- return string from ATVEF sped
//				"b"			- a more complicate string
//				?			- ... more exmaples ...
//				<filename>	- returns string read from the specified file
// ------------------------------------

char * SzGetAnnounce(char *szId);

#endif	// __ANNCEXAMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testtve2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TestTVE2.rc
//
#define IDS_PROJNAME                    100
#define IDR_TestTVE2                    100
#define IDD_TESTDLG                     201
#define IDC_EDIT1                       202
#define IDC_README                      203
#define IDC_TEST1                       204
#define IDC_TEST2                       205
#define IDC_TEST3                       206
#define IDC_TEST4                       207
#define IDC_TEST5                       208
#define IDC_TEST6                       209
#define IDC_TEST7                       210
#define IDC_TEST8                       211
#define IDC_TEST9                       212
#define IDC_TESTA                       213
#define IDC_TESTB                       214
#define IDC_TESTC                       215

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         258
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testsend\testdlg.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TestDlg.cpp : Implementation of CTestDlg
#include "stdafx.h"
#include "TestDlg.h"

#include "..\..\Common\IsoTime.h"
#include "time.h"

#import  "..\..\ATVEFSend\objd\i386\ATVEFSend.tlb" no_namespace named_guids raw_interfaces_only
//#import  "..\TveContr\TveContr.tlb" no_namespace named_guids

//#include "TVETracks.h"

#include <stdio.h>		// needed in the release build...
#include <Oleauto.h>	// IErrorInfo

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

char * SzGetAnnounce(char *szId);

UINT	  g_cszCurr = 0;
UINT	  g_cszMax = 1024*128;
UINT	  g_nLoops = 2;
TCHAR	 *g_tszBuff = NULL;

TCHAR * AddCR(TCHAR *pszIn);
// /////////////////////////////////////////////////////////////////////////
//
//   DoErrorMsg;
// ---------------------------------
HRESULT 
CTestDlg::DoErrorMsg(HRESULT hrIn, BSTR bstrMsg)
{
	USES_CONVERSION;
	CComBSTR bstrError;					// Professional ATL COM programming (pg 322) with mods
	bstrError += bstrMsg;
	bstrError += L"\n";
	{
		static WCHAR wbuff[1024];
		HMODULE hMod = GetModuleHandleA("AtvefSend");

		if(0 == FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
								hMod, 
								hrIn,
								0, //LANG_NEUTRAL,
								 wbuff,
								 sizeof(wbuff) / sizeof(wbuff[0]) -1,
								 NULL))
		{
			if(0 == FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
									NULL, 
									hrIn,
									0, //LANG_NEUTRAL,
									wbuff,
									sizeof(wbuff) / sizeof(wbuff[0]) -1,
									NULL))
			{

				int err = GetLastError();
				swprintf(wbuff,L"Unknown Error");
			}
		}
		bstrError += wbuff;
		swprintf(wbuff, L"\nError 0x%08x\n",hrIn);
		bstrError += wbuff;
	}
/*
	CComPtr<ISupportErrorInfo> pSEI;
	HRESULT hr1 = pUnk->QueryInterface(&pSEI);
	if(SUCCEEDED(hr1))
	{
		hr1 = pSEI->InterfaceSupportsErrorInfo(rUUID);
		if(S_OK == hr1)
		{
										// try to get the error object
			CComPtr<IErrorInfo> pEI;
			if(S_OK == GetErrorInfo(0, &pEI))
			{
				CComBSTR bstrDesc, bstrSource;
				pEI->GetDescription(&bstrDesc);
				bstrError += bstrDesc;
				bstrError += L" In ";
				pEI->GetSource(&bstrSource);
				bstrError += bstrSource;
			}
		}

	}
*/
	MessageBox(W2T(bstrError),_T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	return S_OK;
}

LRESULT 
CTestDlg::OnReadMe(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	CComBSTR bstrDump;
	bstrDump.Empty();
	bstrDump.Append("AtvefSend Test Dlg\n\n");
	bstrDump.Append("\n");
	bstrDump.Append("If Use Inserter checked, sends to Insterter at given IP:port\n");
	bstrDump.Append("  else sends using Multicast broadcast.\n");
	bstrDump.Append("\n");
	bstrDump.Append("A) Set Channel 1-4\n");
	bstrDump.Append(" -  Set Announcement (e.g. show on channel) of 1-4\n");
	bstrDump.Append(" -   Set Enhancement on that announcement of 1-4\n");
	bstrDump.Append(" -    Set # of variations on that Enhancement to 1-4\n");
	bstrDump.Append(" -     Send the announcement A1 or A1.\n");
	bstrDump.Append("B) Set which variation to send data/triggers on of 1-4.\n");
	bstrDump.Append(" -  Set track in that variation to send data/triggers down.\n");
	bstrDump.Append(" -   Send data file, directory of files, or triggers\n");


	SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	return 0;
}
// /////////////////////////////////////////////////////////////////////////
static DATE 
DateNow()
{		SYSTEMTIME SysTimeNow;
		GetSystemTime(&SysTimeNow);									// initialize with currrent time.
		DATE dateNow;
		SystemTimeToVariantTime(&SysTimeNow, &dateNow);
		return dateNow;
}

/////////////////////////////////////////////////////////////////////////////
// CTestDlg
LRESULT 
CTestDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	USES_CONVERSION;

	CheckRadioButton(IDC_ChannelID1,IDC_ChannelID4,	IDC_ChannelID1);
	CheckRadioButton(IDC_AnncID1,	IDC_AnncID4,	IDC_AnncID1);
	CheckRadioButton(IDC_EnhncID1,	IDC_EnhncID4,	IDC_EnhncID1);
	CheckRadioButton(IDC_CVariaID1,	IDC_CVariaID4,	IDC_CVariaID1);
	CheckRadioButton(IDC_VariaID1,	IDC_VariaID4,	IDC_VariaID1);
	CheckRadioButton(IDC_TrackID1,	IDC_TrackID4,	IDC_TrackID1);
	CheckRadioButton(IDC_TrigID1,	IDC_TrigID4,	IDC_TrigID1);

	HWND hwIPAddr = GetDlgItem(IDC_InsIPADDRESS);
	HWND hwIPPort = GetDlgItem(IDC_InsPORT);
	
	m_fInsUse = false;

//	m_dwInsIPAddr = ntohl(inet_addr("157.59.17.208"));		// johnbrad10
//	m_usInsIPPort = 1234;

			// Channel 44
	m_dwInsIPAddr = ntohl(inet_addr("157.59.16.44"));
//	m_dwInsIPAddr = ntohl(inet_addr("157.59.16.43"));
	m_usInsIPPort = 2000;									// CC module

//	m_dwInsIPAddr = ntohl(inet_addr("157.59.16.43"));		
//	m_usInsIPPort = 3000;									// NABTS module

	struct in_addr inA;
	inA.S_un.S_addr = htonl(m_dwInsIPAddr);

	TCHAR tszBuffPort[64];
	_stprintf(tszBuffPort,_T("%d"),m_usInsIPPort);

	SetDlgItemText(IDC_InsIPADDRESS, 	A2T(inet_ntoa( inA )));
	SetDlgItemText(IDC_InsPORT,			tszBuffPort);  


    HWND hWndExtHeaders = GetDlgItem(IDC_COMBO_EXTHEADERS);
	SendMessage(hWndExtHeaders, CB_RESETCONTENT, 0, 0);		// init the list
    for(int i = 0; i < 4; i++)
    {
        TCHAR tzBuff[16];
        _stprintf(tzBuff,"%d",i);
		SendMessage(hWndExtHeaders, CB_INSERTSTRING,  -1, (LPARAM) tzBuff);
		SendMessage(hWndExtHeaders, LB_SETITEMDATA,  i, (LPARAM) i);
     }
	SendMessage(hWndExtHeaders, CB_SETCURSEL, 0, 0);

	::EnableWindow(hwIPAddr, m_fInsUse);
	::EnableWindow(hwIPPort, m_fInsUse);

	EnableVariaButtons();
	PutURL();

    SetDlgItemText(IDC_EDITBASEURL, _T("LID:\\\\TestSend"));
    SetDlgItemText(IDC_EDITDIRPATH, _T("c:\\Public\\TestDir"));

	return 1;  // Let the system set the focus
}

LRESULT 
CTestDlg::OnChannelID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iChannel = 1; 	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnChannelID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iChannel = 2; 	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnChannelID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iChannel = 3; 	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnChannelID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iChannel = 4; 	PutURL();
	return 0;
}

LRESULT 
CTestDlg::OnAnncID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iAnnc = 1; 	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnAnncID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iAnnc = 2; 	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnAnncID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iAnnc = 3; 	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnAnncID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iAnnc = 4; 	PutURL();
	return 0;
}


// --------------

LRESULT 
CTestDlg::OnEnhncID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iEnhnc = 1; 	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnEnhncID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iEnhnc = 2; 	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnEnhncID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iEnhnc = 3; 	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnEnhncID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iEnhnc = 4; 	PutURL();
	return 0;
}
// -----------------
void 
CTestDlg::EnableVariaButtons()
{
	::EnableWindow(GetDlgItem(IDC_VariaID1),m_cVaria >= 1);
	::EnableWindow(GetDlgItem(IDC_VariaID2),m_cVaria >= 2);
	::EnableWindow(GetDlgItem(IDC_VariaID3),m_cVaria >= 3);
	::EnableWindow(GetDlgItem(IDC_VariaID4),m_cVaria >= 4);
}

void 
CTestDlg::EnableInserterAddr()
{
	USES_CONVERSION;

	if(m_fInsUse)
	{
		const int kSz = 256;
		TCHAR tsPort[kSz];
		TCHAR tsAddr[kSz];
		GetDlgItemText(IDC_InsPORT,	 	 tsPort, kSz);  
		GetDlgItemText(IDC_InsIPADDRESS, tsAddr, kSz);

		m_dwInsIPAddr = ntohl(inet_addr(T2A(tsAddr)));
		m_usInsIPPort = (USHORT) atol(T2A(tsPort));	
	}

}

LRESULT 
CTestDlg::OnCVariaID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_cVaria = 1;
	EnableVariaButtons();
	m_iVaria = 1;
	CheckRadioButton(IDC_VariaID1,	IDC_VariaID4,	IDC_VariaID1);  	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnCVariaID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_cVaria = 2;
	EnableVariaButtons();
	m_iVaria = 1;
	CheckRadioButton(IDC_VariaID1,	IDC_VariaID4,	IDC_VariaID1);  	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnCVariaID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_cVaria = 3;
	EnableVariaButtons();
	m_iVaria = 1;
	CheckRadioButton(IDC_VariaID1,	IDC_VariaID4,	IDC_VariaID1);  	PutURL();
	return 0;
}

LRESULT 
CTestDlg::OnCVariaID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_cVaria= 4;
	EnableVariaButtons();
	m_iVaria = 1;
	CheckRadioButton(IDC_VariaID1,	IDC_VariaID4,	IDC_VariaID1);  	PutURL();
	return 0;
}

// --------------
LRESULT 
CTestDlg::OnVariaID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	if(m_cVaria < 1) return 1;
	m_iVaria = 1;  	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnVariaID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	if(m_cVaria < 2) return 1;
	m_iVaria = 2;  	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnVariaID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	if(m_cVaria < 3) return 1;
	m_iVaria = 3;  	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnVariaID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	if(m_cVaria < 4) return 1;
	m_iVaria = 4;  	PutURL();
	return 0;
}

// ---       
LRESULT 
CTestDlg::OnTrackID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iTrack = 1;  	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnTrackID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iTrack = 2;  	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnTrackID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iTrack = 3;  	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnTrackID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iTrack = 4;  	PutURL();
	return 0;
}
// ---       
LRESULT 
CTestDlg::OnTrigID1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iTrig = 1;  	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnTrigID2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iTrig = 2;  	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnTrigID3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iTrig = 3;  	PutURL();
	return 0;
}
LRESULT 
CTestDlg::OnTrigID4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_iTrig = 4;  	PutURL();
	return 0;
}
// ----------------------------
LRESULT  
CTestDlg::OnClickedCheckNoName(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_fNoName = (BST_CHECKED == IsDlgButtonChecked(IDC_CHECKNONAME));
	return 0;
}
// ----------------------------
LRESULT 
CTestDlg::OnInsCheckID(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	m_fInsUse = !m_fInsUse;

	::EnableWindow(GetDlgItem(IDC_InsIPADDRESS),m_fInsUse);
	::EnableWindow(GetDlgItem(IDC_InsPORT),m_fInsUse);

	return 0;
}

// -----------------------------
LRESULT 
CTestDlg::OnKillfocusInsPort(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	// TODO : Add Code for control notification handler.
	return 0;
}
LRESULT 
CTestDlg::OnSetfocusInsPort(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	// TODO : Add Code for control notification handler.
	return 0;
}
// -----------------------------
LRESULT 
CTestDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	if(g_tszBuff) {
		delete g_tszBuff;
		g_tszBuff = 0;
	}
	DestroyWindow();
	PostQuitMessage(0);
//		EndDialog(wID);
	return 0;
}

				// dialog texts seems to require \CR\NL ...
TCHAR * 
AddCR(TCHAR *pszIn)
{
	const TCHAR CR = '\r';
	const TCHAR NL = '\n';
	if(g_cszMax < _tcslen(pszIn)) {
		if(g_tszBuff) free(g_tszBuff);
		g_cszMax = _tcslen(pszIn) + 100;
	}

	if(!g_tszBuff) g_tszBuff = (TCHAR *) malloc(g_cszMax * sizeof(TCHAR));
	TCHAR *pb = g_tszBuff;

	
	while(int c = *pszIn++)
	{
		if(c == NL) *pb++ = CR;
		*pb++ = (TCHAR) c;
	}
	*pb = '\0';
	return g_tszBuff;
}

// -----------------------------------------------------------------------------
// ----------------------------------------------------------------------------


/*--------

// -------------------------------------------
//  Test3:  Test Inserter
// ----------------------------------------------
LRESULT 
CTestDlg::OnTest3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	HRESULT hr = S_OK;
	char *szAnc = NULL;

	USES_CONVERSION;
	try 
	{
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Testing IATVEFInserterSession Interface\n");

		IATVEFInserterSessionPtr	spIS;
		IATVEFAnnouncementPtr		spAnnc; 
		IATVEFPackagePtr			spPkg; 

		spIS = IATVEFInserterSessionPtr(CLSID_ATVEFInserterSession);
				// channel 47 bridge in Bldg 27
		hr = spIS->Initialize(ntohl(inet_addr("157.59.16.44")), 3000);
				// srv session on Johnbrad3
//		hr = spIS->Initialize(ntohl(inet_addr("157.59.16.251")), 2000);
				// srv session on Johnbrad10
//		hr = spIS->Initialize(ntohl(inet_addr("157.59.17.208")), 2000);

				// get the announcement
		IDispatchPtr spIDP;
		hr = spIS->get_Announcement(&spIDP);
		spAnnc = spIDP;							// do the QI
		if(NULL == spAnnc) { MessageBox("Failed To Create TVEAnnouncement","Error"); goto error_exit; }

		spPkg = IATVEFPackagePtr(CLSID_ATVEFPackage);
		if(NULL == spPkg) { MessageBox("Failed To Create ATVEFPackage","Error"); goto error_exit;; }

		// v=0	SDP version
		// o= username sid version IN IP4 ipaddress
		hr = spAnnc->put_UserName(L"JohnBradTest3");		// "-" is default
		hr = spAnnc->put_SessionID(12345);
		hr = spAnnc->put_SessionVersion(678);
		hr = spAnnc->put_SendingIP( ntohl(inet_addr("157.59.17.208")));

		// s=name
		hr = spAnnc->put_SessionName(L"TestSend Test3 Announcement");

		// i=, u=
		hr = spAnnc->put_SessionLabel(L"ATVEFSend Show Label");
		hr = spAnnc->put_SessionURL(L"http:\\this.is.a.url");
		// e=, p=
		hr = spAnnc->AddEmailAddress(L"John Bradstreet",L"JohnBrad@Microsoft.com");
		hr = spAnnc->AddPhoneNumber(L"John Bradstreet",L"(425)703-3697");

		// t=start stop
		hr = spAnnc->AddStartStopTime(DateNow() -9/24.0, DateNow() + 100.0);

		// a=UUID:uuid
		hr = spAnnc->put_UUID(L"15E8C5AA-3C5F-47aa-9C57-D206546E9F19");


		// a=lang, a=sdplang			(default)
		hr = spAnnc->put_LangID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US)); 
		hr = spAnnc->put_SDPLangID(MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT));

		// a=tve-size:kBytes
		hr = spAnnc->put_MaxCacheSize(1234);

		// a=tve-level:x		(optional, default is 1.0)
		hr = spAnnc->put_ContentLevelID(1.0f);

		// a=tve-ends:seconds
		hr = spAnnc->put_SecondsToEnd(60*60*24*10);

		hr = spAnnc->ConfigureDataAndTriggerTransmission(
			ntohl(inet_addr("234.11.12.13")), 14000, 4, 9600);		// ip port scope max-bitrate

		hr = spAnnc->ConfigureDataTransmission(
			ntohl(inet_addr("234.11.12.13")), 14000, 4, 9600);		// ip port scope max-bitrate

		hr = spAnnc->ConfigureTriggerTransmission(
		ntohl(inet_addr("234.11.12.13")), 14001, 4, 9600);		// ip port scope max-bitrate

		spAnnc->DumpToBSTR(&bstrTemp);
		bstrDump.Append(bstrTemp);
		try 
		{		
			bstrDump.Append(L"---------------Announcement------------\n");
			hr = spAnnc->AnncToBSTR(&bstrTemp);
			bstrDump.Append(bstrTemp);
			bstrDump.Append(L"---------------------------------------\n");
		} 	catch (_com_error e) 
		{
			bstrDump.Append("*** Bad Announcement Data ***\n");
		}

		hr = spPkg->Initialize(DateNow()+1000.0);
		hr = spPkg->AddFile(L"TestSend.cpp", L".", L"lid:\\\\JohnBradShow", L"", 
						    DateNow()+100, MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT), false);
		hr = spPkg->Close();

		try 
		{	
			for(UINT i = 0; i < g_nLoops; i++) {
				Sleep(2000);
				bstrDump.Append("Connecting...\n");
				hr = spIS->Connect();
				bstrDump.Append("Sending Announcement..\n");
				hr = spIS->SendAnnouncement();
				bstrDump.Append("Sending Package...\n");
				hr = spIS->SendPackage(spPkg);
				bstrDump.Append("Sending Trigger...\n");
				hr = spIS->SendTrigger(L"http:\\\\www.msn.com",L"MSN",L"",DateNow()+1.0f);
				bstrDump.Append("Disconnect...\n");
				hr = spIS->Disconnect();
				SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
				AtlTrace("Loop %d of %d\n",i,g_nLoops);
			}
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Error in Session ***\n");
		}
		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n");
		bstrDump.Append(bstrTemp);
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		return S_OK;
error_exit:
		bstrDump.Append(L"Bad Stuff Happened");
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, "Error", MB_OK | MB_ICONEXCLAMATION);
		if(szAnc) delete szAnc; szAnc = NULL;
	}

	return 0;
}
*/

/*
LRESULT 
CTestDlg::OnRun(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;
	try 
	{
		HRESULT hr;
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Testing IATVEFMulticastSession Interface\n");

		ULONG ulIpSendingAddr;
		IATVEFMulticastSessionPtr	spMS;
		IATVEFAnnouncementPtr		spAnnc; 
		IATVEFPackagePtr			spPkg; 

				// channel 47 bridge in Bldg 27
		spMS = IATVEFMulticastSessionPtr(CLSID_ATVEFMulticastSession);
		hr = spMS->Initialize(0);		// use session any...

				// get the announcement
		IDispatchPtr spIDP;
		hr = spMS->get_Announcement(&spIDP);
		spAnnc = spIDP;							// do the QI
		if(NULL == spAnnc) { MessageBox("Failed To Create TVEAnnouncement","Error"); goto error_exit; }


		// v=0	SDP version
		// o= username sid version IN IP4 ipaddress
		spAnnc->put_UserName(L"JohnBrad");
		spAnnc->put_SessionID(12345);
		spAnnc->put_SessionVersion(678);
		ulIpSendingAddr = ntohl(inet_addr("157.59.17.208"));
		spAnnc->put_SendingIP(ulIpSendingAddr);

		// s=name
		spAnnc->put_SessionName(L"ATVEF TestSend Run Announcement");

		// i=, u=
		spAnnc->put_SessionLabel(L"ATVEFSend Show Label");
		spAnnc->put_SessionURL(L"http:\\\\this.is.a.url");

		// e=, p=
		spAnnc->AddEmailAddress(L"John Bradstreet",L"JohnBrad@Microsoft.com");
		spAnnc->AddPhoneNumber(L"John Bradstreet",L"(425)703-3697");

		// t=start stop
		spAnnc->AddStartStopTime(DateNow(), DateNow() + 100.0);

		// a=UUID:uuid
		spAnnc->put_UUID(L"15E8C5AA-3C5F-47aa-9C57-D206546E9F19");


		// a=lang, a=sdplang			(default)
		spAnnc->put_LangID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US)); 
		spAnnc->put_SDPLangID(MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT));

		// a=tve-size:kBytes
		spAnnc->put_MaxCacheSize(12345);

		// a=tve-level:x		(optional, default is 1.0)
		spAnnc->put_ContentLevelID(1.0f);

		// a=tve-ends:seconds
		spAnnc->put_SecondsToEnd(60*60*24*100);

		spAnnc->ConfigureDataAndTriggerTransmission(
			ntohl(inet_addr("234.11.12.13")), 14000, 4, 12345);		// ip port scope max-bitrate


		try 
		{		
			bstrDump.Append(L"-----------Announcement--------------\n");
			spAnnc->AnncToBSTR(&bstrTemp);
			bstrDump.Append(bstrTemp);
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Bad Announcement Data ***\n");
		}

		spPkg = IATVEFPackagePtr(CLSID_ATVEFPackage);
		if(NULL == spPkg) { MessageBox("Failed To Create ATVEFPackage","Error"); goto error_exit; }

		hr = spPkg->Initialize(DateNow()+1000.0);
		hr = spPkg->AddFile(L"TestSend.cpp", L".", L"lid://JohnBradShow", L"", 
						    DateNow()+100, MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT), false);
		hr = spPkg->Close();
		bstrDump.Append(L"\n------------ Package ------------------\n");
		spPkg->DumpToBSTR(&bstrTemp);
		bstrDump.Append(bstrTemp);
		bstrDump.Append(L"\n------------ End Package --------------\n");

		try 
		{		
			bstrDump.Append("Connecting...\n");
			hr = spMS->Connect();

			bstrDump.Append("Sending Announcement...\n");
			hr = spMS->SendAnnouncement();

			bstrDump.Append("Sending Package...\n");
			hr = spMS->SendPackage(spPkg);

			bstrDump.Append("Sendinging Trigger...\n");
			hr = spMS->SendTrigger(L"http:\\\\www.msn.com",L"MSN",L"",DateNow()+1.0f);

			bstrDump.Append("Disconnect...\n");
			hr = spMS->Disconnect();

			{
				int id, iv;
				hr = spAnnc->get_SessionID(&id);
				hr = spAnnc->put_SessionID(id);

				hr = spAnnc->get_SessionVersion(&iv);
				hr = spAnnc->put_SessionVersion(iv);
			}
		//	spAnnc->put_SessionID(spAnnc->GetSessionID()+1);
		//	spAnnc->put_SessionVersion(spAnnc->GetSessionVersion()+1);
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Could Not Connect ***\n");
		}
		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n");
		bstrDump.Append(bstrTemp);
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		return S_OK;
error_exit:
		bstrDump.Append(L"Bad Stuff Happened");
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, "Error", MB_OK | MB_ICONEXCLAMATION); 
	}

	return 0;
}
*/
/*--------------
LRESULT 
CTestDlg::OnTest5(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;
	try {
		HRESULT hr;
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Testing IATVEFRouterSessionPtr Interface\n");

		ULONG ulIpSendingAddr;
		IATVEFRouterSessionPtr		spRS;
		IATVEFAnnouncementPtr		spAnnc; 
		IATVEFPackagePtr			spPkg; 


		spRS = IATVEFRouterSessionPtr(CLSID_ATVEFRouterSession);
				// rjames-dell  
		hr = spRS->Initialize(L"RJames-Dell");		// use session any...
				// 233.43.17.32

				// get the announcement
		IDispatchPtr spIDP;
		hr = spRS->get_Announcement(&spIDP);
		spAnnc = spIDP;							// do the QI
		if(NULL == spAnnc) { MessageBox("Failed To Create TVEAnnouncement","Error"); goto error_exit; }


		// v=0	SDP version
		// o= username sid version IN IP4 ipaddress
		spAnnc->put_UserName(L"JohnBradTest5");
		spAnnc->put_SessionID(12345);
		spAnnc->put_SessionVersion(678);
		ulIpSendingAddr = ntohl(inet_addr("157.59.17.208"));
		spAnnc->put_SendingIP(ulIpSendingAddr);

		// s=name
		spAnnc->put_SessionName(L"TestSend Test4 Announcement");

		// i=, u=
		spAnnc->put_SessionLabel(L"ATVEFSend Show Label");
		spAnnc->put_SessionURL(L"http:\\\\this.is.a.url");

		// e=, p=
		spAnnc->AddEmailAddress(L"John Bradstreet",L"JohnBrad@Microsoft.com");
		spAnnc->AddPhoneNumber(L"John Bradstreet",L"(425)703-3697");

		// t=start stop
		spAnnc->AddStartStopTime(DateNow(), DateNow() + 100.0);

		// a=UUID:uuid
		spAnnc->put_UUID(L"15E8C5AA-3C5F-47aa-9C57-D206546E9F19");


		// a=lang, a=sdplang			(default)
		spAnnc->put_LangID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US)); 
		spAnnc->put_SDPLangID(MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT));

		// a=tve-size:kBytes
		spAnnc->put_MaxCacheSize(12345);

		// a=tve-level:x		(optional, default is 1.0)
		spAnnc->put_ContentLevelID(1.0f);

		// a=tve-ends:seconds
		spAnnc->put_SecondsToEnd(60*60*24*100);

		spAnnc->ConfigureDataAndTriggerTransmission(
			ntohl(inet_addr("234.11.12.13")), 14000, 4, 12345);		// ip port scope max-bitrate


		try 
		{		
			bstrDump.Append(L"-----------Announcement--------------\n");
			spAnnc->AnncToBSTR(&bstrTemp);
			bstrDump.Append(bstrTemp);
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Bad Announcement Data ***\n");
		}

		spPkg = IATVEFPackagePtr(CLSID_ATVEFPackage);
		if(NULL == spPkg) { MessageBox("Failed To Create ATVEFPackage","Error"); goto error_exit; }

		hr = spPkg->Initialize(DateNow()+1000.0);
		hr = spPkg->AddFile(L"TestSend.cpp", L".", L"lid://JohnBradShow5", L"", 
						    DateNow()+100, MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT), false);
		hr = spPkg->Close();
		bstrDump.Append(L"\n------------ Package ------------------\n");
		spPkg->DumpToBSTR(&bstrTemp);
		bstrDump.Append(bstrTemp);
		bstrDump.Append(L"\n------------ End Package --------------\n");

		try 
		{		
			bstrDump.Append("Connecting...\n");
			hr = spRS->Connect();

			bstrDump.Append("Sending Announcement...\n");
			hr = spRS->SendAnnouncement();

			bstrDump.Append("Sending Package...\n");
			hr = spRS->SendPackage(spPkg);

			bstrDump.Append("Sendinging Trigger...\n");
			hr = spRS->SendTrigger(L"http:\\\\www.msn.com",L"MSN",L"",DateNow()+1.0f);

			bstrDump.Append("Disconnect...\n");
			hr = spRS->Disconnect();

			{
				int id, iv;
				hr = spAnnc->get_SessionID(&id);
				hr = spAnnc->put_SessionID(id);

				hr = spAnnc->get_SessionVersion(&iv);
				hr = spAnnc->put_SessionVersion(iv);
			}
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Could Not Connect ***\n");
		}
		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n");
		bstrDump.Append(bstrTemp);
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		return S_OK;
error_exit:
		bstrDump.Append(L"Bad Stuff Happened");
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, "Error", MB_OK | MB_ICONEXCLAMATION); 
	}

	return 0;
}
*/

// -------------------------------------------------------------------------------
// -------------------------------------------------------------------------------

HRESULT
CTestDlg::ConfigAnnc(IATVEFAnnouncement *pAnnc, int nVariations)
{
	WCHAR wbuff[256];
	if(pAnnc == NULL) return E_FAIL;

	ULONG ulIpSendingAddr;

	// v=0	SDP version
	// o= username sid version IN IP4 ipaddress
	pAnnc->put_SAPMessageIDHash(m_iSAPMsgIDHash++);
	pAnnc->put_UserName(L"JohnBrad_TestAnncA");
	pAnnc->put_SessionID(10000 + m_iChannel*10 + m_iAnnc);

	pAnnc->put_SessionVersion(m_iAnncVer++);
	ulIpSendingAddr = ntohl(inet_addr("157.59.17.208"));
	pAnnc->put_SendingIP(ulIpSendingAddr);

	// a=tool:...
	pAnnc->AddExtraAttribute(L"tool",L"ATVEFSend 1.2");
	pAnnc->AddExtraAttribute(L"Foo",NULL);						// null item(value) should be ok...
	pAnnc->AddExtraFlag(L"B",L"Bogus");
	pAnnc->AddExtraFlag(L"C",L"Also Bogus");

	// s=name
	swprintf(wbuff,L"TestSend Show %d Annc %d Enhancement %d",
					m_iChannel,m_iAnnc, m_iEnhnc);
	pAnnc->put_SessionName(wbuff);

	// i=, u=
	swprintf(wbuff,L"ATVEFSend TestAnnc Show %d Annc %d Enhancement %d (%d variations)",
					m_iChannel,m_iAnnc, m_iEnhnc, nVariations);
	pAnnc->put_SessionLabel(wbuff);
	pAnnc->put_SessionURL(L"http:\\\\this.is.ATVEFSend.url");

	// e=, p=
	pAnnc->AddEmailAddress(L"John Bradstreet",L"JohnBrad@Microsoft.com");
	pAnnc->AddPhoneNumber(L"John Bradstreet",L"(425)703-3697");

	// t=start stop   -- need to specify, else get a 
//	pAnnc->AddStartStopTime(DateNow()-1, DateNow() + 100.0);
	pAnnc->AddStartStopTime(DateNow()-1, DateNow() -0.1);
//	pAnnc->AddStartStopTime(0, 0);

	// a=UUID:uuid
	pAnnc->put_UUID(L"15E8C5AA-3C5F-47aa-9C57-D206546E9F19");


	// a=lang, a=sdplang			(default)
	pAnnc->put_LangID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US)); 
	pAnnc->put_SDPLangID(MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT));

	pAnnc->AddExtraAttribute(L"lang",L"GR");

	// a=tve-size:kBytes
	pAnnc->put_MaxCacheSize(223344);

	// a=tve-level:x		(optional, default is 1.0)
	pAnnc->put_ContentLevelID(1.0f);

	// a=tve-ends:seconds
//	pAnnc->put_SecondsToEnd(60*60*24*100);			// stop in 100 days...
	pAnnc->put_SecondsToEnd(60*60);					// stop in 1 hour

			// create as many variations as desired...
	DWORD x = inet_addr("235.0.0.0");
	DWORD y = ntohl(x);
	int xx = ntohl(x);
	for(int i = 0; i < nVariations; i++) {
		char buff[256];
		IATVEFMediaPtr spMedia;
		HRESULT hr = pAnnc->get_Media(i,&spMedia);
		if(!FAILED(hr))
			if(i >= 1)
			{
				sprintf(buff,"%d.%d.%d.%d",230+m_iChannel, m_iAnnc, m_iEnhnc, i*10);
				spMedia->ConfigureDataAndTriggerTransmission(
						ntohl(inet_addr(buff)), 1000, 4, 1000000);		// ip port scope max-bitrate
			} else {
				sprintf(buff,"%d.%d.%d.%d",230+m_iChannel, m_iAnnc, m_iEnhnc, i+1);
				spMedia->ConfigureDataTransmission(
						ntohl(inet_addr(buff)), 1000, 4, 1000000);		// ip port scope max-bitrate
				sprintf(buff,"%d.%d.%d.%d",230+m_iChannel, m_iAnnc+10,m_iEnhnc,i+1);
				spMedia->ConfigureTriggerTransmission(
						ntohl(inet_addr(buff)), 2000, 4, 1000000);		// ip port scope max-bitrate
			}

			sprintf(buff,"Varia %d",i);
			CComBSTR spBuff(buff);
			spMedia->put_MediaLabel(spBuff);

			spMedia->AddExtraAttribute(L"Bogus",L"1");
			spMedia->AddExtraFlag(L"B",L"Bogus");
			spMedia->AddExtraFlag(L"C",L"Bogus2");

	}
	
	return S_OK;
}

LRESULT 
CTestDlg::OnTestA_Annc1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;
	try 
	{
		HRESULT hr;
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Testing Announcement A \n");

		IDispatchPtr spIDP;
 
		IATVEFMulticastSessionPtr	spMS;
		IATVEFInserterSessionPtr	spIns;
		if(m_fInsUse) {
            EnableInserterAddr();  
			spIns = IATVEFInserterSessionPtr(CLSID_ATVEFInserterSession);
			if(spIns) hr = spIns->Initialize(m_dwInsIPAddr, m_usInsIPPort);		// use session any...
            if(FAILED(hr))
            {
 		    	MessageBox(_T("Unable to initialize inserter - Bad IP addr or port?"),_T("Error"));       
            } else {
			    hr = spIns->get_Announcement(&spIDP);
            }
		} else {
			spMS = IATVEFMulticastSessionPtr(CLSID_ATVEFMulticastSession);
			hr = spMS->Initialize(0);		// use session any...
			hr = spMS->get_Announcement(&spIDP);
		}


				// get the announcement

		IATVEFAnnouncementPtr spAnnc(spIDP);							// do the QI
		if(NULL == spAnnc) { 
			MessageBox(_T("Failed To Create TVEAnnouncement"),_T("Error")); 
			goto error_exit; 
		}

		ConfigAnnc(spAnnc, m_cVaria);

		try 
		{		
			bstrDump.Append(L"-----------Announcement--------------\n");
			spAnnc->AnncToBSTR(&bstrTemp);
			bstrDump.Append(bstrTemp);
	//		spAnnc->DumpToBSTR(&bstrTemp);
	//		bstrDump.Append(bstrTemp);
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Bad Announcement Data ***\n");
		}

		try 
		{
			if(spMS)
			{
				bstrDump.Append("Connecting to Multicast Seessino...\n");
				hr = spMS->Connect();
				if(FAILED(hr))
					bstrDump.Append("*** Failed to Connect ***\n");

				bstrDump.Append("Sending Announcement...\n");
				hr = spMS->SendAnnouncement();
				if(FAILED(hr))
					bstrDump.Append("*** Failed to SendAnnouncement ***\n");

				bstrDump.Append("Disconnect...\n");
				hr = spMS->Disconnect();
			} else if (spIns) {
				bstrDump.Append("Connecting to Inserter Seessino...\n");
				hr = spIns->Connect();
				if(FAILED(hr))
					bstrDump.Append("*** Failed to Connect ***\n");

				bstrDump.Append("Sending Announcement...\n");
				hr = spIns->SendAnnouncement();
				if(FAILED(hr))
					bstrDump.Append("*** Failed to SendAnnouncement ***\n");

				bstrDump.Append("Disconnect...\n");
				hr = spIns->Disconnect();
			}
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Threw - Could Not Connect ***\n");
		}

		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n");
		bstrDump.Append(bstrTemp);
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		return S_OK;
error_exit:
		bstrDump.Append(L"Bad Stuff Happened");
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	}

	return 0;
}



HRESULT
CTestDlg::CreateTestFile(BSTR bstrFileName, int nLines)
{
	USES_CONVERSION;

	FILE *fp;
	fp = fopen(W2A(bstrFileName),"r");
	if(NULL == fp)
	{
		fp = fopen(W2A(bstrFileName),"w");
		if(NULL == fp) {
			TCHAR tszBuff[256];		
			_stprintf(tszBuff,_T("Unable to create '%S':  Error %s\n"),
				bstrFileName, strerror(errno));
			MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
			return E_FAIL;
		}
		fprintf(fp,"<HTML>\n");
		fprintf(fp,"<TITLE>%S%</TITLE>",bstrFileName);
		fprintf(fp,"<BODY>\n");
		fprintf(fp,"-------------------------------------<br></br>\n");
		fprintf(fp,"<h2>  %d line TestSend Dump File <i>%S</i></h2>\n",nLines, bstrFileName);
		fprintf(fp,"-------------------------------------<br></br>\n");
		for(int l = 0; l < nLines; l++)
		{
			for(char c = 'A'; c <= 'z'; c++)
				fputc(c,fp);
			fprintf(fp,"<br></br>\n");
		}

		fprintf(fp,"</BODY>\n");
		fprintf(fp,"</HTML>\n");
	}
	fclose(fp);
	return S_OK;
}

HRESULT AddExtensionHeaders(IATVEFPackage *pPkg, USHORT iHeaderType, long cHeaders)
{        
    if(NULL == pPkg) return E_POINTER;
    IATVEFPackage_TestPtr spPkgTest(pPkg);
    if(NULL == spPkgTest)
        return E_NOINTERFACE;
    
    WCHAR wszBuff[128];
    for(int i = 0; i < cHeaders; i++)
    {
        swprintf(wszBuff,L"%d-%d-Extension Header-%d-%d",i,i, i,i);
        USHORT cChars = wcslen(wszBuff);
        spPkgTest->AddExtensionHeader( /*morefollows*/i != cHeaders-1, 
                                     iHeaderType, 
                                     cChars, wszBuff);
    
    }
    return S_OK;
}

LRESULT 
CTestDlg::OnTestA_FileA1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    const int kChars=256;
	static int iCalls = 0;
	iCalls++;

	USES_CONVERSION;
	try 
	{
		HRESULT hr;
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Sending File A1\n");

				// get the announcement

		IDispatchPtr spIDP;
		IATVEFMulticastSessionPtr	spMS;
		IATVEFInserterSessionPtr	spIns;
		IATVEFPackagePtr			spPkg;

		if(m_fInsUse) {
            EnableInserterAddr();      
			spIns = IATVEFInserterSessionPtr(CLSID_ATVEFInserterSession);
			if(spIns) hr = spIns->Initialize(m_dwInsIPAddr, m_usInsIPPort);		// use session any...
            if(FAILED(hr))
            {
 		    	MessageBox(_T("Unable to initialize inserter - Bad IP addr or port?"),_T("Error"));       
            } else {
			    hr = spIns->get_Announcement(&spIDP);
            }
		} else {
			spMS = IATVEFMulticastSessionPtr(CLSID_ATVEFMulticastSession);
			hr = spMS->Initialize(0);		// use session any...
			hr = spMS->get_Announcement(&spIDP);
		}
		IATVEFAnnouncementPtr spAnnc(spIDP);							// do the QI
		if(NULL == spAnnc) { MessageBox(_T("Failed To Create TVEAnnouncement"),_T("Error")); goto error_exit; }

 
		ConfigAnnc(spAnnc, m_cVaria);

		spPkg = IATVEFPackagePtr(CLSID_ATVEFPackage);
		{
			static CComBSTR gBstrPackageGuid;
			hr = spPkg->InitializeEx(DateNow()+1000.0,0,gBstrPackageGuid);
	
            long cExtHeaders = GetDlgItemInt(IDC_COMBO_EXTHEADERS);
            AddExtensionHeaders(spPkg, 0, cExtHeaders);

			{
				bstrDump.Append("Creating Package : ");
				CComBSTR spPkgUUID;
				spPkg->get_PackageUUID(&spPkgUUID);	
				gBstrPackageGuid = spPkgUUID;				// keep around so we don't regen it
				bstrDump.Append(spPkgUUID);
				bstrDump.Append("\n");
			}
		}

// -------------------


// -------------------

		CreateTestFile(L"c:\\Bogus1.htm",15);				// small file

        TCHAR tszEditBaseURLBuff[kChars];
        GetDlgItemText(IDC_EDITBASEURL, tszEditBaseURLBuff, kChars);

		hr = spPkg->AddFile(L"Bogus1.htm", L"c:\\", T2W(tszEditBaseURLBuff), L"", 
						    DateNow()+100, MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT), false);

		if(FAILED(hr)) { MessageBox(_T("Failed To Add File To Package"),_T("Error")); goto error_exit; }
		hr = spPkg->Close();

		try 
		{	
			if(spMS)
			{
				hr = spMS->SetCurrentMedia(m_iVaria-1);	
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed SetCurrentMedia ***\n");

				bstrDump.Append("Connecting...\n");
				hr = spMS->Connect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Connect ***\n");

				bstrDump.Append("Sending Package 1...\n");
				hr = spMS->SendPackage(spPkg);

				bstrDump.Append("Disconnect...\n");
				hr = spMS->Disconnect();
			} else if (spIns) {
				hr = spIns->SetCurrentMedia(m_iVaria-1);	
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed SetCurrentMedia ***\n");

				bstrDump.Append("Connecting To Inserter...\n");
				hr = spIns->Connect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Connect ***\n");

				bstrDump.Append("Sending Package 1...\n");
				hr = spIns->SendPackage(spPkg);

				bstrDump.Append("Disconnect...\n");
				hr = spIns->Disconnect();
			}
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Threw - Could Not Connect ***\n");
		}

		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n");
		bstrDump.Append(bstrTemp);
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		return S_OK;

error_exit:
		bstrDump.Append(L"Bad Stuff Happened");
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	}

	return 0;
}

LRESULT 
CTestDlg::OnTestA_FileA2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

    const int kChars=256;
    static int iCalls = 0;
	iCalls++;

	USES_CONVERSION;
	try 
    {
        HRESULT hr;
        CComBSTR bstrDump;
        CComBSTR bstrTemp;
        bstrDump.Append(L"Sending File A2\n");
        
        IDispatchPtr spIDP;
        IATVEFMulticastSessionPtr	spMS;
        IATVEFInserterSessionPtr	spIns;
        IATVEFPackagePtr			spPkg;
        long cExtHeaders = 0;
        
        if(m_fInsUse) {
            EnableInserterAddr();      
            spIns = IATVEFInserterSessionPtr(CLSID_ATVEFInserterSession);
            if(spIns) hr = spIns->Initialize(m_dwInsIPAddr, m_usInsIPPort);		// use session any...
            if(FAILED(hr))
            {
 		    	MessageBox(_T("Unable to initialize inserter - Bad IP addr or port?"),_T("Error"));       
            } else {
			    hr = spIns->get_Announcement(&spIDP);
            }
        } else {
            spMS = IATVEFMulticastSessionPtr(CLSID_ATVEFMulticastSession);
            if(spMS) hr = spMS->Initialize(0);		// use session any...
            if(spMS) hr = spMS->get_Announcement(&spIDP);
        }
        IATVEFAnnouncementPtr spAnnc(spIDP);							// do the QI
        if(NULL == spAnnc) { MessageBox(_T("Failed To Create TVEAnnouncement"),_T("Error")); goto error_exit; }
        
        ConfigAnnc(spAnnc, m_cVaria);
        
        spPkg = IATVEFPackagePtr(CLSID_ATVEFPackage);
        
        hr = spPkg->Initialize(DateNow()+1000.0);
        cExtHeaders = GetDlgItemInt(IDC_COMBO_EXTHEADERS);
        AddExtensionHeaders(spPkg, 0, cExtHeaders);

        CreateTestFile(L"c:\\Bogus2.htm", 500);				// big file

        TCHAR tszEditBaseURLBuff[kChars];
        GetDlgItemText(IDC_EDITBASEURL, tszEditBaseURLBuff, kChars);

        hr = spPkg->AddFile(L"Bogus2.htm", L"c:\\", T2W(tszEditBaseURLBuff), L"", 
                            DateNow()+100, MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT), /*compressed*/ true);
        if(FAILED(hr)) { MessageBox(_T("Failed To Add File To Package"),_T("Error")); goto error_exit; }
        hr = spPkg->Close();
        
		try 
		{		
			hr = spMS->SetCurrentMedia(m_iVaria-1);	
			if(FAILED(hr)) 
				bstrDump.Append("*** Failed SetCurrentMedia ***\n");

			bstrDump.Append("Connecting To Inserter...\n");
			hr = spMS->Connect();
			if(FAILED(hr)) 
				bstrDump.Append("*** Failed Connect ***\n");

			bstrDump.Append("Sending Package 1...\n");
			hr = spMS->SendPackage(spPkg);

			bstrDump.Append("Disconnect...\n");
			hr = spMS->Disconnect();
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Could Not Connect ***\n");
		}

		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n");
		bstrDump.Append(bstrTemp);
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		return S_OK;
error_exit:
		bstrDump.Append(L"Bad Stuff Happened");
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	}

	return 0;
}
// ------------------------

LRESULT 
CTestDlg::OnTestA_DirA1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    
    const int kChars=256;
    static int iCalls = 0;
    iCalls++;
    
    USES_CONVERSION;
    try 
    {
        HRESULT hr;
        CComBSTR bstrDump;
        CComBSTR bstrTemp;
        bstrDump.Append(L"Sending Dir A1\n");
        
        IDispatchPtr spIDP;
        IATVEFMulticastSessionPtr	spMS;
        IATVEFInserterSessionPtr	spIns;
        IATVEFPackagePtr			spPkg;
        long cExtHeaders = 0;
        
        if(m_fInsUse) {
            EnableInserterAddr();      
            spIns = IATVEFInserterSessionPtr(CLSID_ATVEFInserterSession);
            if(spIns) hr = spIns->Initialize(m_dwInsIPAddr, m_usInsIPPort);		// use session any...
            if(FAILED(hr))
            {
 		    	MessageBox(_T("Unable to initialize inserter - Bad IP addr or port?"),_T("Error"));       
            } else {
			    hr = spIns->get_Announcement(&spIDP);
            }
        } else {
            spMS = IATVEFMulticastSessionPtr(CLSID_ATVEFMulticastSession);
            if(spMS) hr = spMS->Initialize(0);		// use session any...
            if(spMS) hr = spMS->get_Announcement(&spIDP);
        }
		IATVEFAnnouncementPtr spAnnc(spIDP);							// do the QI
		if(NULL == spAnnc) { MessageBox(_T("Failed To Create TVEAnnouncement"),_T("Error")); goto error_exit; }

		ConfigAnnc(spAnnc, m_cVaria);

		spPkg = IATVEFPackagePtr(CLSID_ATVEFPackage);

		hr = spPkg->Initialize(DateNow()+1000.0);
        cExtHeaders = GetDlgItemInt(IDC_COMBO_EXTHEADERS);
        AddExtensionHeaders(spPkg, 0, cExtHeaders);
        
        TCHAR tszDirPathBuff[kChars],tszEditBaseURLBuff[kChars];
		GetDlgItemText(IDC_EDITDIRPATH, tszDirPathBuff, kChars);
        GetDlgItemText(IDC_EDITBASEURL, tszEditBaseURLBuff, kChars);

        hr = spPkg->AddDir(T2W(tszDirPathBuff), T2W(tszEditBaseURLBuff),
						    DateNow()+100, MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT), false);
		if(FAILED(hr)) { MessageBox(_T("Failed To Add Dir To Package"),_T("Error")); goto error_exit; }
		hr = spPkg->Close();

		try 
		{	
			if(spMS)
			{
				hr = spMS->SetCurrentMedia(m_iVaria-1);	
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed SetCurrentMedia ***\n");

				bstrDump.Append("Connecting...\n");
				hr = spMS->Connect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Connect ***\n");

				bstrDump.Append("Sending Package 1...\n");
				hr = spMS->SendPackage(spPkg);

				bstrDump.Append("Disconnect...\n");
				hr = spMS->Disconnect();
			} else if (spIns) {
				hr = spIns->SetCurrentMedia(m_iVaria-1);	
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed SetCurrentMedia ***\n");

				bstrDump.Append("Connecting To Inserter...\n");
				hr = spIns->Connect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Connect ***\n");

				bstrDump.Append("Sending Package 1...\n");
				hr = spIns->SendPackage(spPkg);

				bstrDump.Append("Disconnect...\n");
				hr = spIns->Disconnect();
			}
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Could Not Connect ***\n");
		}

		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n");
		bstrDump.Append(bstrTemp);
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		return S_OK;
error_exit:
		bstrDump.Append(L"Bad Stuff Happened");
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	}

	return 0;
}

LRESULT 
CTestDlg::OnTestA_DirA2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    const int kChars=256;
    static int iCalls = 0;
    iCalls++;
    
    USES_CONVERSION;
    try 
    {
        HRESULT hr;
        CComBSTR bstrDump;
        CComBSTR bstrTemp;
        bstrDump.Append(L"Sending Dir A1\n");
        
        IDispatchPtr spIDP;
        IATVEFMulticastSessionPtr	spMS;
        IATVEFInserterSessionPtr	spIns;
        IATVEFPackagePtr			spPkg;
        long cExtHeaders = 0;
        
        if(m_fInsUse) {
            EnableInserterAddr();      
            spIns = IATVEFInserterSessionPtr(CLSID_ATVEFInserterSession);
            if(spIns) hr = spIns->Initialize(m_dwInsIPAddr, m_usInsIPPort);		// use session any...
            if(FAILED(hr))
            {
 		    	MessageBox(_T("Unable to initialize inserter - Bad IP addr or port?"),_T("Error"));       
            } else {
			    hr = spIns->get_Announcement(&spIDP);
            }
        } else {
            spMS = IATVEFMulticastSessionPtr(CLSID_ATVEFMulticastSession);
            if(spMS) hr = spMS->Initialize(0);		// use session any...
            if(spMS) hr = spMS->get_Announcement(&spIDP);
        }
        IATVEFAnnouncementPtr spAnnc(spIDP);							// do the QI
        if(NULL == spAnnc) { MessageBox(_T("Failed To Create TVEAnnouncement"),_T("Error")); goto error_exit; }
        
        ConfigAnnc(spAnnc, m_cVaria);
        
        spPkg = IATVEFPackagePtr(CLSID_ATVEFPackage);
        
        hr = spPkg->Initialize(DateNow()+1000.0);
        cExtHeaders = GetDlgItemInt(IDC_COMBO_EXTHEADERS);
        AddExtensionHeaders(spPkg, 0, cExtHeaders);

        TCHAR tszDirPathBuff[kChars],tszEditBaseURLBuff[kChars];
		GetDlgItemText(IDC_EDITDIRPATH, tszDirPathBuff, kChars);
        GetDlgItemText(IDC_EDITBASEURL, tszEditBaseURLBuff, kChars);

        hr = spPkg->AddDir(T2W(tszDirPathBuff), T2W(tszEditBaseURLBuff), 
                            DateNow()+100, MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT), false);
        if(FAILED(hr)) { MessageBox(_T("Failed To Add Dir To Package"),_T("Error")); goto error_exit; }
        hr = spPkg->Close();

        try 
        {		
            if(spMS) {			
                hr = spMS->SetCurrentMedia(m_iVaria-1);	
                if(FAILED(hr)) 
                    bstrDump.Append("*** Failed SetCurrentMedia ***\n");
                
                bstrDump.Append("Connecting...\n");
                hr = spMS->Connect();
                if(FAILED(hr)) 
                    bstrDump.Append("*** Failed Connect ***\n");
                
                bstrDump.Append("Sending Package 1...\n");
                hr = spMS->SendPackage(spPkg);
                
                bstrDump.Append("Disconnect...\n");
                hr = spMS->Disconnect();
            } else if (spIns) {
                hr = spIns->SetCurrentMedia(m_iVaria-1);	
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed SetCurrentMedia ***\n");

				bstrDump.Append("Connecting To Inserter...\n");
				hr = spIns->Connect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Connect ***\n");

				bstrDump.Append("Sending Package 1...\n");
				hr = spIns->SendPackage(spPkg);

				bstrDump.Append("Disconnect...\n");
				hr = spIns->Disconnect();
			}

		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Could Not Connect ***\n");
		}

		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n");
		bstrDump.Append(bstrTemp);
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		return S_OK;
error_exit:
		bstrDump.Append(L"Bad Stuff Happened");
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

    }
    catch (_com_error e) {
        TCHAR tszBuff[2048];
        _stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
            e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
        MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
    }

	return 0;
}
// -------------------------------------------
LRESULT 
CTestDlg::OnTestA_TrigA1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    
    static int iCalls = 0;
    
    USES_CONVERSION;
    try 
    {
        HRESULT hr;
        CComBSTR bstrDump;
        CComBSTR bstrTemp;
        bstrDump.Append(L"Sending Trig A1\n");
        
        
        IDispatchPtr spIDP;
        IATVEFMulticastSessionPtr	spMS;
        IATVEFInserterSessionPtr	spIns;
        if(m_fInsUse) {
            EnableInserterAddr();      
            spIns = IATVEFInserterSessionPtr(CLSID_ATVEFInserterSession);
            if(spIns) hr = spIns->Initialize(m_dwInsIPAddr, m_usInsIPPort);		// use session any...
            if(FAILED(hr))
            {
 		    	MessageBox(_T("Unable to initialize inserter - Bad IP addr or port?"),_T("Error"));       
            } else {
			    hr = spIns->get_Announcement(&spIDP);
            }
        } else {
            spMS = IATVEFMulticastSessionPtr(CLSID_ATVEFMulticastSession);
            if(spMS) hr = spMS->Initialize(0);		// use session any...
            if(spMS) hr = spMS->get_Announcement(&spIDP);
        }
        IATVEFAnnouncementPtr spAnnc(spIDP);							// do the QI
		if(NULL == spAnnc) { MessageBox(_T("Failed To Create TVEAnnouncement"),_T("Error")); goto error_exit; }

		ConfigAnnc(spAnnc, m_cVaria);

		try 
		{		
			if(spMS) {
				hr = spMS->SetCurrentMedia(m_iVaria-1);	
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed SetCurrentMedia ***\n");

				bstrDump.Append("Connecting...\n");
				hr = spMS->Connect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Connect ***\n");

				bstrDump.Append("Sending Trigger: ");
				TCHAR tBuffURL[256];
				WCHAR wBuffName[256];

//				swprintf(wBuffURL,L"\\\\johnbrad10\\public\\TVE\\Chan%d\\Enh%d\\Varia%d\\Track%d.html",m_iChannel,m_iEnhnc, m_iVaria, m_iTrack);
				GetDlgItemText(IDC_EDITURL, tBuffURL, sizeof(tBuffURL) / sizeof(tBuffURL[0]));
				CComBSTR wBuffURL = T2W(tBuffURL);

				swprintf(wBuffName,L"Track%d",m_iTrack);
				if(m_fNoName)
					wBuffName[0] = 0;
				

				TCHAR tFrameName[256];
				GetDlgItemText(IDC_EDITFRAMENAME, tFrameName, sizeof(tFrameName) / sizeof(tFrameName[0]));
				CComBSTR wFrameName(tFrameName);
				if(wFrameName.Length() > 0) wFrameName += L".";

				WCHAR wScript[256];
				swprintf(wScript,L"%sspanX.innerHTML='%sspanX.innerHTML= Name %s Track %d, Trig%d'", wFrameName, wFrameName, wBuffName, m_iTrack, m_iTrig);
				SetDlgItemText(IDC_EDITSCRIPT, OLE2T(wScript));

				hr = spMS->SendTrigger(wBuffURL,wBuffName,wScript,DateNow()+1.0);
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed SendTrigger ***\n");

				bstrDump += wBuffURL;
				bstrDump += " ";
				bstrDump += wBuffName;
				bstrDump += "\n";


				bstrDump.Append("Disconnect...\n");
				hr = spMS->Disconnect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Disconnect ***\n");
			} else if (spIns) {
				bstrDump.Append("Connecting To Inserter...\n");
				hr = spIns->Connect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Connect ***\n");

				bstrDump.Append("Sending Trigger: ");
				TCHAR tBuffURL[256];
				WCHAR wBuffName[256];
//				swprintf(wBuffURL,L"\\\\johnbrad10\\public\\TVE\\Chan%d\\Enh%d\\Varia%d\\Track%d.html",m_iChannel,m_iEnhnc, m_iVaria, m_iTrack);
				GetDlgItemText(IDC_EDITURL, tBuffURL, sizeof(tBuffURL) / sizeof(tBuffURL[0]));
				CComBSTR wBuffURL = T2W(tBuffURL);

				swprintf(wBuffName,L"Track%d",m_iTrack);
				if(m_fNoName)
					wBuffName[0] = 0;

				TCHAR tFrameName[256];
				GetDlgItemText(IDC_EDITFRAMENAME, tFrameName, sizeof(tFrameName) / sizeof(tFrameName[0]));
				CComBSTR wFrameName(tFrameName);
				if(wFrameName.Length() > 0) wFrameName += L".";

				WCHAR wScript[256];
				swprintf(wScript,L"%sspanX.innerHTML='%sspanX.innerHTML= Name %s Track %d, Trig%d'",wFrameName, wFrameName, wBuffName, m_iTrack, m_iTrig);

				SetDlgItemText(IDC_EDITSCRIPT, OLE2T(wScript));
				hr = spIns->SendTrigger(wBuffURL,wBuffName,wScript,DateNow()+1.0);
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed SendTrigger ***\n");

				bstrDump += wBuffURL;
				bstrDump += " ";
				bstrDump += wBuffName;
				bstrDump += "\n";


				bstrDump.Append("Disconnect...\n");
				hr = spIns->Disconnect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Disconnect ***\n");
			}

		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Could Not Connect ***\n");
		}

		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n");
		bstrDump.Append(bstrTemp);
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		return S_OK;
error_exit:
		bstrDump.Append(L"Bad Stuff Happened");
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	}

	return 0;
}

void
CTestDlg::PutURL()
{
	USES_CONVERSION;
	WCHAR wBuffURL[256];
	swprintf(wBuffURL,L"\\\\johnbrad10\\public\\TVE\\Chan%d\\Enh%d\\Varia%d\\Track%d.html",m_iChannel,m_iEnhnc, m_iVaria, m_iTrack);
	SetDlgItemText(IDC_EDITURL, OLE2T(wBuffURL));
}

LRESULT 
CTestDlg::OnTestA_PutURL(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	PutURL();
	return 0;
}


LRESULT 
CTestDlg::OnTestA_TrigG(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

	static int iCalls = 0;

	USES_CONVERSION;
	try 
	{
		HRESULT hr;
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Sending Trigger-General\n");


		IDispatchPtr spIDP;
		IATVEFMulticastSessionPtr	spMS;
		IATVEFInserterSessionPtr	spIns;
		if(m_fInsUse) {
            EnableInserterAddr();      
			spIns = IATVEFInserterSessionPtr(CLSID_ATVEFInserterSession);
			if(spIns) hr = spIns->Initialize(m_dwInsIPAddr, m_usInsIPPort);		// use session any...
            if(FAILED(hr))
            {
 		    	MessageBox(_T("Unable to initialize inserter - Bad IP addr or port?"),_T("Error"));       
            } else {
			    hr = spIns->get_Announcement(&spIDP);
            }
		} else {
			spMS = IATVEFMulticastSessionPtr(CLSID_ATVEFMulticastSession);
			if(spMS) hr = spMS->Initialize(0);		// use session any...
			if(spMS) hr = spMS->get_Announcement(&spIDP);
		}
		IATVEFAnnouncementPtr spAnnc(spIDP);							// do the QI
		if(NULL == spAnnc) { MessageBox(_T("Failed To Create TVEAnnouncement"),_T("Error")); goto error_exit; }

		ConfigAnnc(spAnnc, m_cVaria);


		try 
		{		
			if(spMS) {
				hr = spMS->SetCurrentMedia(m_iVaria-1);	
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed SetCurrentMedia ***\n");

				bstrDump.Append("Connecting...\n");
				hr = spMS->Connect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Connect ***\n");

				bstrDump.Append("Sending Trigger: ");
				
				CComBSTR bstrURL;
				CComBSTR bstrScript;
				GetDlgItemText( IDC_EDITURL, bstrURL.m_str);
				GetDlgItemText( IDC_EDITSCRIPT, bstrScript.m_str);

				WCHAR wBuffName[256];
				swprintf(wBuffName,L"Track%d",m_iTrack);
				hr = spMS->SendTrigger(bstrURL,wBuffName,bstrScript,DateNow()+1.0);
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed SendTrigger ***\n");

				bstrDump += bstrURL;
				bstrDump += " ";
				bstrDump += wBuffName;
				bstrDump += "\n";
				bstrDump += "    script:";
				bstrDump += bstrScript;
				bstrDump += "\n";

				bstrDump.Append("Disconnect...\n");
				hr = spMS->Disconnect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Disconnect ***\n");
			} else if (spIns) {
				hr = spIns->SetCurrentMedia(m_iVaria-1);	
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed SetCurrentMedia ***\n");

				bstrDump.Append("Connecting To Inserter...\n");
				hr = spIns->Connect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Connect ***\n");

				bstrDump.Append("Sending Trigger: ");
				TCHAR tBuff[256];
				GetDlgItemText( IDC_EDITURL, tBuff, sizeof(tBuff)/sizeof(tBuff[0]));
				CComBSTR bstrURL(tBuff);
				GetDlgItemText( IDC_EDITSCRIPT, tBuff, sizeof(tBuff)/sizeof(tBuff[0]));
				CComBSTR bstrScript(tBuff);

				WCHAR wBuffName[256];
				swprintf(wBuffName,L"Track%d",m_iTrack);
				hr = spIns->SendTrigger(bstrURL,wBuffName,bstrScript,DateNow()+1.0);
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed SendTrigger ***\n");

				bstrDump += bstrURL;
				bstrDump += " ";
				bstrDump += wBuffName;
				bstrDump += "\n";
				bstrDump += "    script:";
				bstrDump += bstrScript;
				bstrDump += "\n";

				bstrDump.Append("Disconnect...\n");
				hr = spIns->Disconnect();
				if(FAILED(hr)) 
					bstrDump.Append("*** Failed Disconnect ***\n");
			}
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Could Not Connect ***\n");
		}

		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n");
		bstrDump.Append(bstrTemp);
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		return S_OK;
error_exit:
		bstrDump.Append(L"Bad Stuff Happened");
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	}

	return 0;
}

// -------------------------------------------
LRESULT 
CTestDlg::OnTestA_L21Trig1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	EnableInserterAddr();
	static int iCalls = 0;

	USES_CONVERSION;
	try 
	{
		HRESULT hr;
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Sending Trig A1\n");

		IATVEFLine21SessionPtr	spL21;

				// channel 47 bridge in Bldg 27
		spL21 = IATVEFLine21SessionPtr(CLSID_ATVEFLine21Session);
		hr = spL21->Initialize(m_dwInsIPAddr, m_usInsIPPort);		// use session any...
		if(FAILED(hr))
			return DoErrorMsg(hr, L"Couldn't Initialize L21 Connection");


		try 
		{		
			bstrDump.Append("Connecting...\n");
			hr = spL21->Connect();

			bstrDump.Append("Sending Line21 Trigger: ");
			TCHAR tBuffURL[256];
			WCHAR wBuffName[256];
//				swprintf(wBuffURL,L"\\\\johnbrad10\\public\\TVE\\Chan%d\\Enh%d\\Varia%d\\Track%d.html",m_iChannel,m_iEnhnc, m_iVaria, m_iTrack);
			GetDlgItemText(IDC_EDITURL, tBuffURL, sizeof(tBuffURL) / sizeof(tBuffURL[0]));
			CComBSTR wBuffURL = T2W(tBuffURL);

			for(int i = 0; i < 4; i++) {
				Sleep(2000);
				swprintf(wBuffName,L"Track%d",m_iTrack);
				if(m_fNoName)
					wBuffName[0] = 0;

				TCHAR tFrameName[256];
				GetDlgItemText(IDC_EDITFRAMENAME, tFrameName, sizeof(tFrameName) / sizeof(tFrameName[0]));
				CComBSTR wFrameName(tFrameName);
				if(wFrameName.Length() > 0) wFrameName += L".";

				WCHAR wScript[256];
				swprintf(wScript,L"%sspanX.innerHTML='%sspanX.innerHTML= Name %d Track %d, Trig%d, Loop%d'", wFrameName, wFrameName, m_fNoName, m_iTrack, m_iTrig, i);
				SetDlgItemText(IDC_EDITSCRIPT, OLE2T(wScript));

				hr = spL21->SendTrigger(wBuffURL,wBuffName,wScript,DateNow()+1.0);
				if(FAILED(hr))
					 DoErrorMsg(hr, L"Error in SendTrigger");
			}
			bstrDump += wBuffURL;
			bstrDump += " ";
			bstrDump += wBuffName;
			bstrDump += "\n";
	
			bstrDump.Append("Disconnect...\n");
			hr = spL21->Disconnect();
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Could Not Connect ***\n");
		}

		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n");
		bstrDump.Append(bstrTemp);
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		return S_OK;
//error_exit:
		bstrDump.Append(L"Bad Stuff Happened");
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	}

	return 0;
}

LRESULT 
CTestDlg::OnTestA_L21TrigG(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	EnableInserterAddr();
	static int iCalls = 0;

	USES_CONVERSION;
	try 
	{
		HRESULT hr;
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
		bstrDump.Append(L"Sending Trig A1\n");

		IATVEFLine21SessionPtr	spL21;

				// channel 47 bridge in Bldg 27
		spL21 = IATVEFLine21SessionPtr(CLSID_ATVEFLine21Session);
		hr = spL21->Initialize(m_dwInsIPAddr, m_usInsIPPort);		// use session any...
		if(FAILED(hr))
			return DoErrorMsg(hr, L"Couldn't Initialize L21 Connection");


		try 
		{		
			bstrDump.Append("Connecting...\n");
			hr = spL21->Connect();

			bstrDump.Append("Sending Line21 Trigger: ");

			CComBSTR bstrURL;
			CComBSTR bstrScript;
			GetDlgItemText( IDC_EDITURL, bstrURL.m_str);
			GetDlgItemText( IDC_EDITSCRIPT, bstrScript.m_str);

			WCHAR wBuffName[256];
			swprintf(wBuffName,L"Track%d",m_iTrack);
			hr = spL21->SendTrigger(bstrURL,wBuffName,bstrScript,DateNow()+1.0);
			if(FAILED(hr)) 
				bstrDump.Append("*** Failed SendTrigger ***\n");

			bstrDump += bstrURL;
			bstrDump += " ";
			bstrDump += wBuffName;
			bstrDump += "\n";
			bstrDump += "    script:";
			bstrDump += bstrScript;
			bstrDump += "\n";
	
			bstrDump.Append("Disconnect...\n");
			hr = spL21->Disconnect();
		} 	
		catch (_com_error e) 
		{
			bstrDump.Append("*** Could Not Connect ***\n");
		}

		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n");
		bstrDump.Append(bstrTemp);
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		return S_OK;
//error_exit:
		bstrDump.Append(L"Bad Stuff Happened");
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("Error"), MB_OK | MB_ICONEXCLAMATION); 
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testtve2\stdafx.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include <comdef.h>
#include "valid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\isotime.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// isotime.h

#ifndef __ISOTIME_H__
#define __ISOTIME_H__

#include "wtypes.h"
#include "limits.h"
#include "time.h"

// converst a time_ type time into 
DATE VariantTimeFromTime(time_t theTime);

// converts system times to/from local time in date format  (AVOID USING - Assume Variant Times in UTC)
HRESULT SystemTimeToLocalVariantTime(const SYSTEMTIME *psysTime, DATE *pDate);
HRESULT LocalVariantTimeToSystemTime(DATE date, SYSTEMTIME *pSysTime);

// converts UTC Variant times to local (in current time zone) system times
HRESULT LocalSystemTimeToVariantTime(const SYSTEMTIME *psysTime, DATE *pDate);
HRESULT VariantTimeToLocalSystemTime(DATE date, SYSTEMTIME *pSysTime);

// converts ISO-8601 time to date, if fZuluTimeZone is false, assumes in local time
DATE ISOTimeToDate(char *pcTime, BOOL fZuluTimeZone=false);

// converts date to string, or to difference string from 'now'.
CComBSTR DateToBSTR(DATE date);
CComBSTR DateToDiffBSTR(DATE date);

// Offset in seconds from NTP time representation 
// to seconds since 1 Jan 1970 (UNIX Time)
typedef unsigned __int64 ULONG64;
const unsigned __int64   g_ul64NTPOffset = 2208988800UL;

inline DATE NtpToDate(ULONG64 Ntp)
{
	LONG64 NtpS = Ntp;
	NtpS +=  ((__int64) 25569 * 24 * 60 * 60) - g_ul64NTPOffset;			// COleDateTime(1970,1,1,0,0,0) - seconds since 1 Jan 1970 (UNIX Time)
											
	__int64 timeC = (__int64) NtpS;
	if(NtpS > ULONG_MAX) timeC = ULONG_MAX;
	if(NtpS < LONG_MIN)  timeC = LONG_MIN;

	DATE date = timeC / (24.0 * 60.0 * 60.0);		// days since 1 Jan 1970

//	date = date + 25569.000000000;					// COleDateTime(1970,1,1,0,0,0);

//	date = date + 365.25 * (1970 - 1900);			// days since 1 Jan 1900
//	date += 1.5;									// days since 30 December 1899
	return date;
}

inline ULONG64 DateToNtp(DATE date)
{
	date -= 25569.000000000;
	time_t time = (time_t) (0.5 + date * (24.0 * 60.0 * 60.0));
	
	ULONG64 Ntp = time;
	Ntp += g_ul64NTPOffset;
	return Ntp; 
}

#endif //#define __ISOTIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testtve2\anncexamp.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// ---------------------------------
//  AnncExamp.cpp
//
//			Various example SAP announcement strings
//
//			szID is either:
//				"a"			- return string from ATVEF sped
//				"b"			- a more complicate string
//				?			- ... more exmaples ...
//				<filename>	- returns string read from the specified file
// ------------------------------------

#include "stdafx.h"
#include <stdio.h>



/////////////////////////////////////////////////////////////////////////////
//  SAP header (http://www.ietf.org/internet-drafts/draft-ietf-mmusic-sap-v2-02.txt)

struct SAPHeaderBits				// first 8 bits in the SAP header (comments indicate ATVEF state)
{
	union {
		struct {
			unsigned Compressed:1;		// if 1, SAP packet is compressed (0 only) 
			unsigned Encrypted:1;		// if 1, SAP packet is encrypted (0 only) 
			unsigned MessageType:1;		// if 0, session announcement packet, if 1, session deletion packet (0 only)
			unsigned Reserved:1;		// must be 0, readers ignore this	(ignored)
			unsigned AddressType:1;		// if 0, 32bit IPv4 address, if 1, 128-bit IPv6 (0 only)
			unsigned Version:3;			// must be 1  (1 only)
		} s; 
		unsigned char uc;
	};
};


char * 
SzGetAnnounce(char *szId)
{
	char *psz;
	if(1 == strlen(szId)) 
	{
		switch(szId[0]) 
		{
		default:
		case 'a':			// example fro the ATVEF spec
			psz = strdup(
"XXXXXXXX\
v=0\n\
 o=- 2890844526 2990842807 IN IP4 tve.niceBroadcaster.com\n\
 s=Day & Night & Day Again\n\
 i=A very long Soap Opera\n\
 e=help@niceBroadcaster.com\n\
 a=UUID:f81d4ae-7dec-11d0-a765-00a9c81e6bf6\n\
 a=type:tve\n\
 a=tve-level:1.0\n\
 t=2873397496 0\n\
 a=tve-ends:3600\n\
 a=tve-type:primary\n\
 m=data 52127/2 tve-file/tve-trigger\n\
 c=IN IP4 224.0.1.112/127\n\
 b=CT:100\n\
 a=tve-size:1024\n\
 m=data 52127/2 tve-file/tve-trigger\n\
 c=IN IP4 224.0.1.1/127\n\
 b=CT:1024\n\
 a=tve-size:4096\n\
 "); 
		break;

		case 'b':				// variation 2 should have lang of 'en'
			psz = strdup(
"XXXXXXXX\
v=0\n\
 o=- 2890844526 2990842807 IN IP4 tve.packRat.com\n\
 s=Lots of Languages\n\
 i=A study in attributes\n\
 e=help@nohelp.com\n\
 a=UUID:f81d4ae-7dec-11d0-a765-00a9c81e6bf6\n\
 a=type:tve\n\
 a=tve-level:1.0\n\
 t=2873397496 0\n\
 a=tve-ends:3600\n\
 a=tve-type:primary\n\
 a=attr1:bogus1\n\
 a=attr2:bogus2\n\
 a=attr3:bogus3\n\
 a=lang:en\n\
 m=data 52127/2 tve-file/tve-trigger\n\
 c=IN IP4 224.0.1.112/127\n\
 b=CT:100\n\
 a=tve-size:1024\n\
 a=attrA1:bogus4\n\
 m=data 52127/2 tve-file/tve-trigger\n\
 c=IN IP4 224.0.1.1/127\n\
 b=CT:1024\n\
 a=tve-size:4096\n\
 a=attrA2:bogus5\n\
 a=lang:el, it\n\
 "); 
			break;

		}	// end switch
	} else {
		FILE *fp = fopen(szId,"r");
		if(!fp) return NULL;

		int cc = 0;
		int c;
		while(EOF != (c = fgetc(fp)))	// how big?
			cc++;
		fseek(fp, 0, SEEK_SET);
		char *szRet = (char *) malloc(cc+8);
		char *pszX = szRet+8;
		
		while(EOF != (c = fgetc(fp))) 
			*pszX++ = c;
		pszX = NULL;

		psz = szRet;
	}
	SAPHeaderBits spH;
	spH.s.Compressed    = 0;
	spH.s.Encrypted     = 0;
	spH.s.MessageType   = 0;
	spH.s.Reserved      = 0;
	spH.s.AddressType   = 0;
	spH.s.Version		= 1;

	psz[0] = spH.uc;
	psz[1] = 0;
	psz[2] = 0;
	psz[3] = 0;
	psz[4] = 1;		// sending IP address
	psz[5] = 2;
	psz[6] = 3;
	psz[7] = 4;

	return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testtve2\stdafx.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D5783B11_24EA_11D3_BF62_00C04F8EC1B5__INCLUDED_)
#define AFX_STDAFX_H__D5783B11_24EA_11D3_BF62_00C04F8EC1B5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D5783B11_24EA_11D3_BF62_00C04F8EC1B5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testtve2\testdlg.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TestDlg.cpp : Implementation of CTestDlg
#include "stdafx.h"
#include "TestDlg.h"
#include <stdio.h>

#import  "..\..\MsTve\objd\i386\MsTve.dll" no_namespace named_guids

//#include "TVETracks.h"


#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

char * SzGetAnnounce(char *szId);

UINT	  g_cszCurr = 0;
UINT	  g_cszMax = 1024*128;
TCHAR	 *g_szBuff = NULL;

static DATE 
DateNow()
{		SYSTEMTIME SysTimeNow;
		GetSystemTime(&SysTimeNow);									// initialize with currrent time.
		DATE dateNow;
		SystemTimeToVariantTime(&SysTimeNow, &dateNow);
		return dateNow;
}


ITVESupervisorPtr g_spSuper;
/////////////////////////////////////////////////////////////////////////////
// CTestDlg

LRESULT 
CTestDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	if(g_szBuff) {
		delete g_szBuff;
		g_szBuff = 0;
	}

	if(g_spSuper)
		g_spSuper = NULL;

	DestroyWindow();
	PostQuitMessage(0);
//		EndDialog(wID);
	return 0;
}

				// dialog texts seems to require \CR\NL ...
TCHAR * 
AddCR(TCHAR *pszIn)
{
	const TCHAR CR = '\r';
	const TCHAR NL = '\n';
	if(NULL == pszIn) {
		return NULL;
	}

	if(g_cszMax < _tcslen(pszIn)) {
		if(g_szBuff) free(g_szBuff);
		g_cszMax = _tcslen(pszIn) + 100;
	}

	if(!g_szBuff) g_szBuff = (TCHAR *) malloc(g_cszMax * sizeof(TCHAR));
	TCHAR *pb = g_szBuff;

	
	while(int c = *pszIn++)
	{
		if(c == NL) *pb++ = CR;
		*pb++ = (TCHAR) c;
	}
	*pb = '\0';
	return g_szBuff;
}

LRESULT 
CTestDlg::OnTest1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;
	try {

		ITVETriggerPtr	spTrig;
		spTrig = ITVETriggerPtr(CLSID_TVETrigger);
		if(NULL == spTrig) { MessageBox(_T("Failed To Create TVETrigger"),_T("This Sucks")); return 0; }

		HRESULT hr = spTrig->ParseTrigger(_T("<aaa>[n:a][e:20001011T060504][foobar:123][XXXX]"));

		CComBSTR bstrDump;
		CComQIPtr<ITVETrigger_Helper> spTriggerHelper = spTrig;
		spTriggerHelper->DumpToBSTR(&bstrDump);
		TCHAR *tDump = OLE2T(bstrDump);
		SetDlgItemText(IDC_EDIT1, AddCR(tDump));

		ITVETrackPtr spTrack;
		spTrack = ITVETrackPtr(CLSID_TVETrack);
		if(NULL == spTrack) { MessageBox(_T("Failed to Create TVETrack"),_T("This Sucks")); return 0; }

		spTrack->AttachTrigger(spTrig);
		
		ITVETrack_HelperPtr spTrackHelper(spTrack);
		hr = spTrackHelper->RemoveYourself();
	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}

			// Test2 - Variations and TVECollection class

LRESULT 
CTestDlg::OnTest2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;
	try 
	{
		CComBSTR bstrDump;
		CComBSTR bstrTemp;
#if 0
		ITVEVariationPtr pVariation;					// smart pointer	
		pVariation = ITVEVariationPtr(CLSID_TVEVariation);
		if(NULL == pVariation) { MessageBox(_T("Failed to Create ITVEVariation"),_T("This Sucks")); return 0; } 
		pVariation->put_Description(L"Test2 Variation");

		IDispatchPtr spD;
		HRESULT hr = pVariation->get_Tracks(&spD);		
		if(NULL == spD) { MessageBox(_T("Failed to Create IDispatch Interface"),_T("This Sucks")); return 0; }
		ITVETracksPtr spTracks = spD;
		if(NULL == spTracks) { MessageBox(_T("Failed to Create ITVETracks Interface"),_T("This Sucks")); return 0; }
		

		for(int x = 0; x < 5; x++) 
		{
			ITVETrackPtr spTrack;
			spTrack  = ITVETrackPtr(CLSID_TVETrack);			// create a new track
//			CComQIPtr<ITVETrack_Helper> spTrackHelper = spTrack;

			TCHAR buff[256];
			_stprintf(buff,_T("This is Track %d"),x);
			spTrack->put_Description(T2OLE(buff));


			_stprintf(buff,_T("<zzz>[n:a][e:1999100%dT060504][Bogus%04d:%4d]]"),x,x,x);
			BSTR bstrTrigger(T2W(buff));

/*			ITVETriggerPtr	spTrig;
			spTrig = ITVETriggerPtr(CLSID_TVETrigger);
			HRESULT hr = spTrig->ParseTrigger(bstrTrigger);
			spTrack->AttachTrigger(spTrig); */

			spTrack->CreateTrigger(bstrTrigger);


			if(S_OK != spTracks->Add(spTrack))
				MessageBox(_T("Error adding a track"),_T("This Sucks"));
		} 

		CComQIPtr<ITVEVariation_Helper> spVariationHelper = pVariation;
		spVariationHelper->DumpToBSTR(&bstrTemp);
		bstrTemp.Append(L"----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);


					// create an enumerator
		CComQIPtr<IEnumVARIANT> speEnum; 
		hr = spTracks->get__NewEnum((IUnknown **) &speEnum);

		{
			IEnumVARIANT *peEnum; 
			hr = spTracks->get__NewEnum((IUnknown **) &peEnum);
			peEnum->Release();
		}

		
					// Test cloning
		{
			IEnumVARIANT *peEnum2; 
			hr = speEnum->Clone(&peEnum2);
			peEnum2->Release();
		}

		int ix = 0;

		VARIANT v;
		unsigned long cReturned;

		while(S_OK == speEnum->Next(1, &v, &cReturned))
		{
			if(1 != cReturned) break;

			IUnknown *pUnk = v.punkVal;

			CComQIPtr<ITVETrack> spTrack = pUnk;
			if(!spTrack) break;

			WCHAR buff[256];
			BSTR bstrDesc = spTrack->GetDescription();
			swprintf(buff,L"Track %d %s\n",ix++,bstrDesc);	


			if(ix == 2)				// check to see if enumerator changes when add something to collection...
									//  shouldn't see this new track...
			{
				ITVETrackPtr spTrack;
				spTrack  = ITVETrackPtr(CLSID_TVETrack);			// create a new track
				WCHAR buff[256];
				swprintf(buff,L"This track shouldn't appear %d",ix-2);
				spTrack->put_Description(buff);

				swprintf(buff,L"<qqq>[n:a][e:1999090%dT060504][Also Bogus%04d:%4d]]",ix,ix,ix);
				BSTR bstrTrigger(buff);

				spTrack->CreateTrigger(bstrTrigger);

				if(S_OK != spTracks->Add(spTrack))
					MessageBox(_T("Error adding a track"),_T("This Sucks"));			
			}

			bstrDump.Append(buff);
			pUnk->Release();				// need this...  how do we smartpointer'ize this?

		}

		bstrTemp.Empty();
		bstrTemp.Append("---------------------------------------------- \n\n After Add\n");
		bstrDump.Append(bstrTemp);
									// redump the original list - should have new one
		spVariationHelper->DumpToBSTR(&bstrTemp);
		bstrDump.Append(bstrTemp);

		bstrTemp.Empty();
		bstrTemp.Append("----------------------------------------------\n\n Removing Item 3\n");
		bstrDump.Append(bstrTemp);

		CComVariant id(3);
		spTracks->Remove(id);

		spVariationHelper->DumpToBSTR(&bstrTemp);
		bstrDump.Append(bstrTemp);

#endif
		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	
	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}

LRESULT 
CTestDlg::OnTest3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;
	try 
	{
		CComBSTR bstrDump;
		CComBSTR bstrTemp;


		ITVEEnhancementPtr pEnhancement;					// smart pointer	
		pEnhancement = ITVEEnhancementPtr(CLSID_TVEEnhancement);
		if(NULL == pEnhancement) { MessageBox(_T("Failed to Create ITVEVariation"),_T("This Sucks")); return 0; } 
		pEnhancement->put_Description(L"Test3 Enhancement");

		CComQIPtr<ITVEEnhancement_Helper> spEnhancementHelper = pEnhancement;
		spEnhancementHelper->DumpToBSTR(&bstrTemp);
		bstrTemp.Append("----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);

		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}

LRESULT 
CTestDlg::OnTest4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	HRESULT hr;
	char *szAnc = NULL;

	USES_CONVERSION;
	try 
	{
		CComBSTR bstrDump;
		CComBSTR bstrTemp;

		szAnc = SzGetAnnounce("b");							// need to delete
		if(!szAnc) return E_INVALIDARG;
		
		ITVEEnhancementPtr pEnhancement;					// smart pointer	
		pEnhancement = ITVEEnhancementPtr(CLSID_TVEEnhancement);
		if(NULL == pEnhancement) { MessageBox(_T("Failed to Create ITVEVariation"),_T("This Sucks")); return 0; } 
		pEnhancement->put_Description(L"Test3 Enhancement");

														// convert - 
		int cAnnc = 8 + strlen(szAnc+8) ;				//   trouble is Annc has 8 bytes of 
		WCHAR *wszAnc = new WCHAR[cAnnc + 1];					//   non char SAP header data at it's front

		char *psz = szAnc;	
		WCHAR *wsz = wszAnc;
		for(int i = 0; i < cAnnc; i++)
			*wsz++ = *psz++;
		*wsz++ = 0;		


		CComBSTR bstrAdapter("123.123.210.210");
		long grfParseError;
		long lLineError;
		hr = pEnhancement->ParseAnnouncement(bstrAdapter.m_str, &wszAnc, &grfParseError, &lLineError);

		CComQIPtr<ITVEEnhancement_Helper> spEnhancementHelper = pEnhancement;
		spEnhancementHelper->DumpToBSTR(&bstrTemp);
		bstrTemp.Append("----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);


		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
		if(szAnc) delete[] szAnc; szAnc = NULL;
		if(wszAnc) delete[] wszAnc; wszAnc = NULL;

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}


LRESULT 
CTestDlg::OnTest5a(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;
	try 
	{
		CComBSTR bstrDump("");
		CComBSTR bstrTemp;

		ITVEAttrMapPtr pAttrMap;					// smart pointer	
		pAttrMap = ITVEAttrMapPtr(CLSID_TVEAttrMap);

		pAttrMap->Add("Hi","There");
		pAttrMap->Add("How","Now");
		pAttrMap->Add("Brown","Cow");
		pAttrMap->Add("Vladee","Dog");
		pAttrMap->Add("Vali","Is Lovely");

		long c;
		pAttrMap->get_Count(&c);
		for(long i = 0; i < c; i++)
		{
			WCHAR buff[256];
			CComBSTR spK, spV;
			CComVariant id(i);
			pAttrMap->get_Item(id, &spV);
			pAttrMap->get_Key(id, &spK);
			swprintf(buff,L"%4d : %s - %s\n",i, spK, spV);
			bstrDump.Append(buff);
		}

		{
			CComVariant var(L"Hi");
			pAttrMap->Remove(var);

			pAttrMap->get_Count(&c);
			for(long i = 0; i < c; i++)
			{
				WCHAR buff[256];
				CComBSTR spK, spV;
				CComVariant id(i);
				pAttrMap->get_Item(id, &spV);
				pAttrMap->get_Key(id, &spK);
				swprintf(buff,L"%4d : %s - %s\n",i, spK, spV);
				bstrDump.Append(buff);
			}
		}
		
		CComVariant var2(0);
		pAttrMap->Remove(var2);
		
					// test enumerator
		{

					// create an enumerator
			CComQIPtr<IEnumVARIANT> speEnum; 
			HRESULT hr = pAttrMap->get__NewEnum((IUnknown **) &speEnum);
	
			VARIANT v;
			unsigned long cReturned;

			WCHAR buff[256];
			i = 0;
			while(S_OK == speEnum->Next(1, &v, &cReturned))
			{
				if(1 != cReturned) break;

				CComBSTR spbstrValue = v.bstrVal;	
				swprintf(buff,L"%4d : %s\n", i, spbstrValue);
		
				bstrDump.Append(buff);
				i++;
			}
		
					// Test cloning
			{
				IEnumVARIANT *peEnum2; 
				hr = speEnum->Clone(&peEnum2);
				peEnum2->Release();
			}
		}

		pAttrMap->RemoveAll();
		pAttrMap->get_Count(&c);

		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}

LRESULT 
CTestDlg::OnTest5(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;
	try 
	{
		CComBSTR bstrDump("");
		CComBSTR bstrTemp;

		ITVEAttrTimeQPtr pAttrTimeQ;					// smart pointer	
		pAttrTimeQ = ITVEAttrTimeQPtr(CLSID_TVEAttrTimeQ);
	
		bstrTemp.Empty();
		bstrTemp.Append("----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);

		IUnknown *pUnk = NULL;

		ITVETriggerPtr pTrig;
		pTrig = ITVETriggerPtr(CLSID_TVETrigger);
		HRESULT hr = pTrig->QueryInterface(IID_IUnknown,(void**) &pUnk);
		pTrig.AddRef();	// try to leak

		pAttrTimeQ->Add(DateNow(),    ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+2,  ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+1,  ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+3,  ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+5,  ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+22, ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+21, ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+23, ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+25, ITVETriggerPtr(CLSID_TVETrigger));		
		pAttrTimeQ->Add(DateNow()+12, ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+11, ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+13, ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+35, ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+32, ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+31, ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+33, ITVETriggerPtr(CLSID_TVETrigger));
		pAttrTimeQ->Add(DateNow()+35, ITVETriggerPtr(CLSID_TVETrigger));

		bstrTemp.Empty();
		bstrTemp.Append(" Everything ----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);

		bstrTemp.Empty();
		pAttrTimeQ->DumpToBSTR(&bstrTemp);
		bstrDump.Append(bstrTemp);

		bstrTemp.Empty();
		bstrTemp.Append(" > 10 ----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);

		DATE dateKill = DateNow()+10;
		CComVariant cvKill(dateKill);
											// remove by item (although get_Item gets first < date)
		while(S_OK == pAttrTimeQ->get_Item(cvKill,&pUnk))
		{
			CComVariant cvZero(0);
			pAttrTimeQ->Remove(cvZero);		// remove head of list
			pUnk->Release();				// remove the get_Item object 
//			pAttrTimeQ->Remove(cvKill);
		}

		bstrTemp.Empty();
		pAttrTimeQ->DumpToBSTR(&bstrTemp);
		bstrDump.Append(bstrTemp);

		bstrTemp.Empty();
		bstrTemp.Append(" > 20 ----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);

		CComVariant cvKill2(DateNow()+20);	// remove up to this date...
		pAttrTimeQ->Remove(cvKill2);			// remove everything

		bstrTemp.Empty();
		pAttrTimeQ->DumpToBSTR(&bstrTemp);
		bstrDump.Append(bstrTemp);

		bstrTemp.Empty();
		bstrTemp.Append(" None ----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);


		pAttrTimeQ->RemoveAll();

		bstrTemp.Empty();
		pAttrTimeQ->DumpToBSTR(&bstrTemp);
		bstrDump.Append(bstrTemp);

		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));

	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}
				// simple test to create/delete an object
LRESULT 
CTestDlg::OnTest6(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	HRESULT hr = S_OK;
	try 
	{
		CComBSTR bstrDump;
		CComBSTR bstrTemp("Test7\n");
		
		ITVESupervisorPtr	spSuper;
		spSuper = ITVESupervisorPtr(CLSID_TVESupervisor);
		if(NULL == spSuper) { 
			MessageBox(_T("Failed To Create Supervisor"),_T("This Sucks")); 
			return 0; 
		}

//		CComBSTR bstrDump;
//		ITVESupervisor_HelperPtr spSuperHelper(spSuper);
//		spSuperHelper->DumpToBSTR(&bstrDump);
//		TCHAR *tDump = OLE2T(bstrDump);
//		SetDlgItemText(IDC_EDIT1, AddCR(tDump));


//		spSuperHelper->Release();
		spSuper = NULL;				// this should call the FinalRelease!

		bstrTemp.Append("----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);

		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}

				// simple test to create/delete an object
LRESULT 
CTestDlg::OnTest7(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	HRESULT hr = S_OK;
	try 
	{
		CComBSTR bstrDump;
		CComBSTR bstrTemp("Test7\n");

		if(NULL == g_spSuper) {

			ITVESupervisorPtr	spSuper;
			spSuper = ITVESupervisorPtr(CLSID_TVESupervisor);
			if(NULL == spSuper) { 
				MessageBox(_T("Failed To Create Supervisor"),_T("This Sucks")); 
				return 0; 
			}
			g_spSuper = spSuper;

			spSuper->TuneTo(L"TestTVE2 Station",L"157.59.19.54"); 

			bstrTemp.Append("Created the supervisor\n");	
		} else {
			bstrTemp.Append("Already created the supervisor\n");	
		}

		bstrTemp.Append("----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);

		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}


				// simple test to create/delete an object
LRESULT 
CTestDlg::OnTest8(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	HRESULT hr = S_OK;
	try 
	{
		CComBSTR bstrDump;
		CComBSTR bstrTemp("Test8\n");

		if(NULL != g_spSuper) {
			CComBSTR bstrDump;
			ITVESupervisor_HelperPtr spSuperHelper(g_spSuper);
			spSuperHelper->DumpToBSTR(&bstrDump);
			TCHAR *tDump = OLE2T(bstrDump);
			SetDlgItemText(IDC_EDIT1, AddCR(tDump));
		} else {
			bstrTemp.Append("Haven't created supervisor (Do Test6)\n");	
			SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));		
		}
		bstrDump.Empty();
	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}


				// simple test to create/delete an object
LRESULT 
CTestDlg::OnTest9(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	HRESULT hr = S_OK;
	try 
	{
		CComBSTR bstrDump;
		CComBSTR bstrTemp("Test9\n");

		if(NULL != g_spSuper) {
			g_spSuper = NULL;			// should defref it...
			bstrTemp.Append("Deleted the supervisor\n");	
		} else {
			bstrTemp.Append("Supervisor not created\n");	
		}

		bstrTemp.Append("----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);

		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}


				// simple test to create/delete an object
LRESULT 
CTestDlg::OnTestA(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	HRESULT hr = S_OK;
	try 
	{
		CComBSTR bstrDump;
		CComBSTR bstrTemp("TestA\n");

		ITVESupervisorPtr	spSuper;
		spSuper = ITVESupervisorPtr(CLSID_TVESupervisor);
		if(NULL == spSuper) { 
			MessageBox(_T("Failed To Create Supervisor"),_T("This Sucks")); 
			return 0; 
		}

		spSuper = NULL;				// this should call the FinalRelease!

		bstrTemp.Append("----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);

		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}


				// simple test to create/delete an object
LRESULT 
CTestDlg::OnTestB(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	HRESULT hr = S_OK;
	try 
	{
		CComBSTR bstrDump;
		CComBSTR bstrTemp("TestB\n");

		ITVESupervisorPtr	spSuper;
		spSuper = ITVESupervisorPtr(CLSID_TVESupervisor);
		if(NULL == spSuper) { 
			MessageBox(_T("Failed To Create Supervisor"),_T("This Sucks")); 
			return 0; 
		}

		spSuper = NULL;				// this should call the FinalRelease!

		bstrTemp.Append("----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);

		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}


				// simple test to create/delete an object
LRESULT 
CTestDlg::OnTestC(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	USES_CONVERSION;

	HRESULT hr = S_OK;
	try 
	{
		CComBSTR bstrDump;
		CComBSTR bstrTemp("TestC\n");

		ITVESupervisorPtr	spSuper;
		spSuper = ITVESupervisorPtr(CLSID_TVESupervisor);
		if(NULL == spSuper) { 
			MessageBox(_T("Failed To Create Supervisor"),_T("This Sucks")); 
			return 0; 
		}

		spSuper = NULL;				// this should call the FinalRelease!

		bstrTemp.Append("----------------------------------------------\n\n");
		bstrDump.Append(bstrTemp);

		SetDlgItemText(IDC_EDIT1, AddCR(OLE2T(bstrDump)));
	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}

/*

				// simple test to copy file into the dlg window
LRESULT 
CTestDlg::OnTest6(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	try 
	{
		const TCHAR CR = '\r';
		const TCHAR NL = '\n';
		FILE *fp = fopen("TestDlg.cpp","r");
		if(fp)
		{
			if(!g_szBuff) g_szBuff = (TCHAR *) malloc(g_cszMax*sizeof(TCHAR));
			TCHAR *pb = g_szBuff;
			memset(g_szBuff,0,g_cszMax);	// debug paranoia
			int c;
			int j = 0;

			while((pb < (g_szBuff + g_cszMax-2)) && (EOF != (c = getc(fp))))
			{
				if(c == NL) *pb++ = CR;
				*pb++ = (TCHAR) c;
			}
			*pb = '\0';
			g_cszCurr = j;
			fclose(fp);
			SetDlgItemText(IDC_EDIT1, g_szBuff);
		} else {
			SetDlgItemText(IDC_EDIT1, _T("Unable to open file\n"));
		}
	}
	catch (_com_error e) {
		TCHAR tszBuff[2048];
		_stprintf(tszBuff,_T("Error (%08x) in %s: \n\n%s"),
				e.Error(), (LPCSTR)e.Source(), (LPCSTR) e.Description());
		MessageBox(tszBuff, _T("This Sucks"), MB_OK | MB_ICONEXCLAMATION);
	}

	return 0;
}

  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testtve2\testtve2.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TestTVE2.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f TestTVE2ps.mk in the project directory.


#include "stdafx.h"
#include "DbgStuff.h"
#include "resource.h"

#include "TestTVE2_i.c"
#include "TestDlg.h"

#include <initguid.h>
#include "TestTVE2.h"


const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif
    _ASSERTE(SUCCEEDED(hRes));
    _Module.Init(ObjectMap, hInstance, &LIBID_TESTTVE2Lib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

	if(1) 
	{
	// Get current flag
		int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );

		// Turn on leak-checking bit
		tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

		// Set flag to the new value
		_CrtSetDbgFlag( tmpFlag );
	}

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_TestTVE2, FALSE);
            nRet = _Module.UnregisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_TestTVE2, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {
        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

       
		CTestDlg dlg;				// display the dialog...
		if(!dlg.Create(NULL))
		{
			MessageBox(NULL,_T("Failed To Create Dialog"),_T("This Sucks"),MB_OK);
			goto exit_this;
		}
		dlg.ShowWindow(SW_SHOWNORMAL);

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
		{
			TranslateMessage(&msg);
            DispatchMessage(&msg);
		}

exit_this:
       _Module.RevokeClassObjects();

        Sleep(dwPause); //wait for any threads to finish
    }

    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\testtve2\testdlg.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// TestDlg.h : Declaration of the CTestDlg

#ifndef __TESTDLG_H_
#define __TESTDLG_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

/////////////////////////////////////////////////////////////////////////////
// CTestDlg
class CTestDlg : 
	public CAxDialogImpl<CTestDlg>
{
public:
	CTestDlg()
	{
	}

	~CTestDlg()
	{
	}

	enum { IDD = IDD_TESTDLG };

BEGIN_MSG_MAP(CTestDlg)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	COMMAND_ID_HANDLER(IDC_TEST1, OnTest1)
	COMMAND_ID_HANDLER(IDC_TEST2, OnTest2)
	COMMAND_ID_HANDLER(IDC_TEST3, OnTest3)
	COMMAND_ID_HANDLER(IDC_TEST4, OnTest4)
	COMMAND_ID_HANDLER(IDC_TEST5, OnTest5)
	COMMAND_ID_HANDLER(IDC_TEST6, OnTest6)
	COMMAND_ID_HANDLER(IDC_TEST7, OnTest7)
	COMMAND_ID_HANDLER(IDC_TEST8, OnTest8)
	COMMAND_ID_HANDLER(IDC_TEST9, OnTest9)
	COMMAND_ID_HANDLER(IDC_TESTA, OnTestA)
	COMMAND_ID_HANDLER(IDC_TESTB, OnTestB)
	COMMAND_ID_HANDLER(IDC_TESTC, OnTestC)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		return 1;  // Let the system set the focus
	}

	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
	//	EndDialog(wID);
		return 0;
	}

	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnTest1(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest4(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest5(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest5a(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest6(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest6a(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest7(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest8(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTest9(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTestA(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTestB(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnTestC(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

};

#endif //__TESTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TveTreeView.rc
//
#define IDB_TOOL                        1
#define IDS_PROJNAME                    100
#define LB_GRFTRUNC_CHANGED             100
#define IDB_TVETREE                     101
#define IDR_TVETREE                     102
#define IDS_TITLEPPEnhancement          103
#define IDS_HELPFILEPPEnhancement       104
#define IDS_DOCSTRINGPPEnhancement      105
#define IDS_TITLETveTreePP              113
#define IDS_HELPFILETveTreePP           114
#define IDS_DOCSTRINGTveTreePP          115
#define IDR_TVETREEPP                   116
#define IDD_TVETREEPP                   117
#define IDR_TVEVIEWSUPERVISOR           120
#define IDD_TVEVIEWSUPERVISOR           120
#define IDR_TVEVIEWSERVICE              121
#define IDD_TVEVIEWSERVICE              121
#define IDR_TVEVIEWENHANCEMENT          122
#define IDD_TVEVIEWENHANCEMENT          122
#define IDR_TVEVIEWVARIATION            123
#define IDD_TVEVIEWVARIATION            123
#define IDR_TVEVIEWTRACK                124
#define IDD_TVEVIEWTRACK                124
#define IDR_TVEVIEWTRIGGER              125
#define IDD_TVEVIEWTRIGGER              125
#define IDD_TVEVIEWEQUEUE               130
#define IDR_TVEVIEWEQUEUE               130
#define IDD_TVEVIEWFILE                 131
#define IDR_TVEVIEWFILE                 131
#define IDD_TVEVIEWMCASTMANAGER         132
#define IDR_TVEVIEWMCASTMANAGER         132
#define IDC_TRUNC_E                     201
#define IDB_IMAGER                      202
#define IDC_TRUNC_V                     202
#define IDB_SELECT                      203
#define IDC_TRUNC_T                     203
#define IDC_TRUNC_S                     204
#define IDC_TRUNC_X                     205
#define IDB_IMAGES                      206
#define IDC_TRUNC_EQ                    206
#define IDB_IMAGEE                      207
#define IDB_IMAGEV                      208
#define IDB_IMAGET                      209
#define IDB_IMAGEE_T                    210
#define IDB_IMAGER_T                    211
#define IDB_IMAGES_T                    212
#define IDB_IMAGEV_T                    213
#define IDB_IMAGET_T                    214
#define IDC_RESETCOUNTS                 225
#define IDC_LIST1                       226
#define IDC_EQ_LIST                     226
#define IDC_MC_LIST                     226
#define IDC_EDIT1                       228
#define IDC_EQ_ITEMS                    228
#define IDC_EQ_OFFSET                   229
#define IDC_EQ_CHANGECOUNT              230
#define IDC_MC_ITEMS                    231
#define IDC_MC_RESETCOUNT               232
#define IDC_MC_PKTS_TOTAL               233
#define IDC_MC_PKTS_DROPPED             234
#define IDC_DATA0                       300
#define IDC_DATA1                       301
#define IDC_DATA2                       302
#define IDC_DATA3                       303
#define IDC_DATA4                       304
#define IDC_DATA5                       305
#define IDC_DATA6                       306
#define IDC_DATA7                       307
#define IDC_DATA8                       308
#define IDC_DATA9                       309
#define IDC_DATA10                      310
#define IDC_DATA11                      311
#define IDC_DATA12                      312
#define IDC_DATA13                      313
#define IDC_DATA14                      314
#define IDC_DATA15                      315
#define IDC_DATA16                      316
#define IDC_DATA17                      317
#define IDC_DATA18                      318
#define IDC_DATA19                      319
#define IDC_DATA20                      320
#define IDC_LABEL0                      400
#define IDC_LABEL1                      401
#define IDC_LABEL2                      402
#define IDC_LABEL3                      403
#define IDC_LABEL4                      404
#define IDC_LABEL5                      405
#define IDC_LABEL6                      406
#define IDC_LABEL7                      407
#define IDC_LABEL8                      408
#define IDC_LABEL9                      409
#define IDC_LABEL10                     410
#define IDC_LABEL11                     411
#define IDC_LABEL12                     412
#define IDC_LABEL13                     413
#define IDC_LABEL14                     414
#define IDC_LABEL15                     415
#define IDC_LABEL16                     416
#define IDC_LABEL17                     417
#define IDC_LABEL18                     418
#define IDC_LABEL19                     419
#define IDC_LABEL20                     420
#define IDB_IMAGEEQ                     500
#define IDB_IMAGEEQ_T                   501
#define IDB_IMAGET_TUNED                502
#define IDB_SELECT_TUNED                503
#define IDB_IMAGEEP                     504
#define IDB_IMAGEMM_T                   506
#define IDB_IMAGEMM                     507

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        508
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         233
#define _APS_NEXT_SYMED_VALUE           133
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__17BEC439_9911_41D3_8CD8_C713054918AB__INCLUDED_)
#define AFX_STDAFX_H__17BEC439_9911_41D3_8CD8_C713054918AB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__17BEC439_9911_41D3_8CD8_C713054918AB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveevents.cpp ===
// TveEvents.cpp : Implementation of CTveTree

#include "stdafx.h"
#include "TveTreeView.h"
#include "TveTree.h"

extern HRESULT AddToOutput(TCHAR *tBuff);

STDMETHODIMP CTveTree::NotifyTVETune(/*[in]*/ NTUN_Mode tuneMode,/*[in]*/ ITVEService *pService,/*[in]*/ BSTR bstrDescription,/*[in]*/ BSTR bstrIPAdapter)
{

	TCHAR tzBuff[1024];

	CComBSTR bstrWhat;
	switch(tuneMode) {
	case NTUN_New:			bstrWhat = L"New"; break;
	case NTUN_Retune:		bstrWhat = L"Retune"; break;
	case NTUN_Reactivate:	bstrWhat = L"Reactivate"; break;
	case NTUN_Turnoff:		bstrWhat = L"Turn off"; break;
	default:
	case NTUN_Fail:			bstrWhat = L"Fail"; break;
	}

	_stprintf(tzBuff,_T("%S Tune: %S -> %S\n"), bstrWhat, bstrDescription, bstrIPAdapter);

	AddToOutput(tzBuff);

	UT_EnMode utMode = (NTUN_New == tuneMode ? UT_New : ( NTUN_Turnoff == tuneMode ? UT_Deleted : UT_Updated));

	if(NTUN_Turnoff == tuneMode)
	{
		Fire_NotifyTVETreeTuneTrigger(NULL, NULL);						// untune the current trigger
		Fire_NotifyTVETreeTuneService(NULL, NULL);						// untune the current service
	}

	IUnknownPtr spPunk(pService);
	UpdateTree(utMode, spPunk);

	return S_OK;
}

STDMETHODIMP CTveTree::NotifyTVEEnhancementNew(/*[in]*/ ITVEEnhancement *pEnh)
{
	TCHAR tzBuff[1024];
	
	CComBSTR bstrSessionName;
	CComBSTR bstrDescription;
	CComBSTR bstrSessionUserName;

	pEnh->get_SessionName(&bstrSessionName);
	pEnh->get_Description(&bstrDescription);
	pEnh->get_SessionUserName(&bstrSessionUserName);

	_stprintf(tzBuff,_T("New Enhancement '%S' Desc '%S' userName '%S'"),bstrSessionName, bstrDescription, bstrSessionUserName);
	AddToOutput(tzBuff);

	IUnknownPtr spPunk(pEnh);
	UpdateTree(UT_New, spPunk);

	return S_OK;
}

		// changedFlags : NENH_grfDiff
STDMETHODIMP CTveTree::NotifyTVEEnhancementUpdated(/*[in]*/ ITVEEnhancement *pEnh, /*[in]*/ long lChangedFlags)
{

	TCHAR tzBuff[1024];

	CComBSTR bstrSessionName;
	CComBSTR bstrDescription;
	CComBSTR bstrSessionUserName;

	pEnh->get_SessionName(&bstrSessionName);
	pEnh->get_Description(&bstrDescription);
	pEnh->get_SessionUserName(&bstrSessionUserName);

	_stprintf(tzBuff,_T("Updated Enhancement '%S' Desc '%S' userName '%S'"),bstrSessionName, bstrDescription, bstrSessionUserName);
	AddToOutput(tzBuff);
	
	IUnknownPtr spPunk(pEnh);
	UpdateTree(UT_Updated, spPunk);

	return S_OK;
}
	
STDMETHODIMP CTveTree::NotifyTVEEnhancementStarting(/*[in]*/ ITVEEnhancement *pEnh)
{
	TCHAR tzBuff[1024];

	CComBSTR bstrSessionName;
	CComBSTR bstrDescription;
	CComBSTR bstrSessionUserName;

	pEnh->get_SessionName(&bstrSessionName);
	pEnh->get_Description(&bstrDescription);
	pEnh->get_SessionUserName(&bstrSessionUserName);

	_stprintf(tzBuff,_T("Starting Enhancement '%S' Desc '%S' userName '%S'"),bstrSessionName, bstrDescription, bstrSessionUserName);
	AddToOutput(tzBuff);

	IUnknownPtr spPunk(pEnh);
	UpdateTree(UT_StartStop, spPunk);

	return S_OK;
}

STDMETHODIMP CTveTree::NotifyTVEEnhancementExpired(/*[in]*/ ITVEEnhancement *pEnh)
{
	TCHAR tzBuff[1024];

	CComBSTR bstrSessionName;
	CComBSTR bstrDescription;
	CComBSTR bstrSessionUserName;

	pEnh->get_SessionName(&bstrSessionName);
	pEnh->get_Description(&bstrDescription);
	pEnh->get_SessionUserName(&bstrSessionUserName);

	_stprintf(tzBuff,_T("Expired Enhancement '%S' Desc '%S' userName '%S'"),bstrSessionName, bstrDescription, bstrSessionUserName);

	AddToOutput(tzBuff);


	IUnknownPtr spPunk(pEnh);
	UpdateTree(UT_Deleted, spPunk);

	return S_OK;
}

STDMETHODIMP CTveTree::NotifyTVETriggerNew(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive)
{
	TCHAR tzBuff[1024];
	CComBSTR bstrName;
	CComBSTR bstrURL;
	CComBSTR bstrScript;

	pTrigger->get_Name(&bstrName);
	pTrigger->get_URL(&bstrURL);
	pTrigger->get_Script(&bstrScript);

	_stprintf(tzBuff,_T("New Trigger  %S:%S %S"),bstrName, bstrURL, bstrScript);
	AddToOutput(tzBuff);


	IUnknownPtr spPunk(pTrigger);
	UpdateTree(UT_New, spPunk);

	return S_OK;
}

		// changedFlags : NTRK_grfDiff
STDMETHODIMP CTveTree::NotifyTVETriggerUpdated(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive, /*[in]*/ long lChangedFlags)
{
	TCHAR tzBuff[1024];
	CComBSTR bstrName;
	CComBSTR bstrURL;
	CComBSTR bstrScript;

	pTrigger->get_Name(&bstrName);
	pTrigger->get_URL(&bstrURL);
	pTrigger->get_Script(&bstrScript);

	_stprintf(tzBuff,_T("Updated Trigger  %S:%S %S"),bstrName, bstrURL, bstrScript);
	AddToOutput(tzBuff);

	IUnknownPtr spPunk(pTrigger);
	UpdateTree(UT_Updated, spPunk);

	return S_OK;
}
	
STDMETHODIMP CTveTree::NotifyTVETriggerExpired(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive)
{
	TCHAR tzBuff[1024];
	CComBSTR bstrName;
	CComBSTR bstrURL;
	CComBSTR bstrScript;

	pTrigger->get_Name(&bstrName);
	pTrigger->get_URL(&bstrURL);
	pTrigger->get_Script(&bstrScript);

	_stprintf(tzBuff,_T("Expired Trigger %S:%S %S"),bstrName, bstrURL, bstrScript);
	AddToOutput(tzBuff);

	IUnknownPtr spPunk(pTrigger);
	UpdateTree(UT_Deleted, spPunk);

	return S_OK;
}

STDMETHODIMP CTveTree::NotifyTVEPackage(/*[in]*/ NPKG_Mode engPkgMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUUID, /*[in]*/ long  cBytesTotal, /*[in]*/ long  cBytesReceived)
{
	TCHAR tzBuff[1024];
	
	CComBSTR spbsType;
	switch(engPkgMode)
	{
	case NPKG_Starting:  spbsType = "Starting";  break;
	case NPKG_Received:  spbsType = "Finished";  break;
	case NPKG_Duplicate: spbsType = "Duplicate"; break;	// only sent on packet 0
	case NPKG_Resend:    spbsType = "Resend";    break; // only sent on packet 0
	case NPKG_Expired:   spbsType = "Expired";   break;
	default: spbsType = "Unknown";
	}
	_stprintf(tzBuff,_T("Package %S: %S (%8.2f KBytes)"),spbsType, bstrUUID, cBytesTotal/1024.0f);
	AddToOutput(tzBuff);

	IUnknownPtr spPunk(pVariation);
	UpdateTree(UT_Data, spPunk);

	return S_OK;
}

STDMETHODIMP CTveTree::NotifyTVEFile(/*[in]*/ NFLE_Mode engFileMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUrlName, /*[in]*/ BSTR bstrFileName)
{
	TCHAR tzBuff[1024];
	_stprintf(tzBuff,_T("%s File: %S -> %S"), 
			  (engFileMode == NFLE_Received) ? _T("Received") :
				   ((engFileMode == NFLE_Expired) ? _T("Expired") : _T("Unknown Mode")),
				bstrUrlName, bstrFileName);

	AddToOutput(tzBuff);

	IUnknownPtr spPunk(pVariation);
	UpdateTree(UT_Data, spPunk);
	
	return S_OK;
}

		// WhatIsIt is NWHAT_Mode - lChangedFlags is NENH_grfDiff or NTRK_grfDiff treated as error bits
STDMETHODIMP CTveTree::NotifyTVEAuxInfo(/*[in]*/ NWHAT_Mode engAuxInfoMode, /*[in]*/ BSTR bstrAuxInfoString, /*[in]*/ long lChangedFlags, /*[in]*/ long lErrorLine)
{
	TCHAR tzBuff[1024];
	CComBSTR bstrWhat;
	switch(engAuxInfoMode) {
	case NWHAT_Announcement: bstrWhat = L"Annc"; break;
	case NWHAT_Trigger:		 bstrWhat = L"Trigger"; break;
	case NWHAT_Data:		 bstrWhat = L"Data"; break;
	default:
	case NWHAT_Other:		 bstrWhat = L"Other"; break;
	}
	int iSDPHeaderLength = 8;		// works for now, need to parse and do it correctly at some point..

	_stprintf(tzBuff,_T("AuxInfo %S(%d): (line %d 0x%08x) %S\n"), 
			  bstrWhat, engAuxInfoMode, lErrorLine, lChangedFlags, 
			  (NWHAT_Announcement == engAuxInfoMode) ? bstrAuxInfoString+iSDPHeaderLength : bstrAuxInfoString);
	AddToOutput(tzBuff);

	UpdateTree(UT_Info, NULL);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\isotime.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// ----------------------------------------------------------------------
//  isotime.cpp
//
//		Convert ISO-8601 standard time to DATE format, except that it is assumed to
//		be UTC (Z) unless the time zone is specified.
//		
//                            012345678901234             
//
//		This will return 0 if error in parsing
//
//
//		In this system, 'DATES' are passed out of interfaces in local time zone
//		(not in UTC 'Z' time).
//		
//
//		see http://www.cl.cam.ac.uk/~mgkt25/iso-time.html		// overview
//			http://wwww.iso.ch.markete/8601.pdf					// full spec
//
//
//	Remarks:
//		J.B  08/28/2000
// -------------------------------------------------------------------------
//

#include "stdafx.h"
//#include <atlbase.h>
#include <time.h>
#include <stdio.h>
#include <math.h>

#include "isotime.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

				// converts a time_t format time into a variant time 
DATE 
VariantTimeFromTime(time_t theTime)
{
				// yecko - this is really nasty code - should be a way to make it nicer..
				//   (CTime or COleDateTime would make this easy, but they are in MFC).
		// m_cSecExpires is UNIX-style time and display as number and string. */
		//    Time in seconds since UTC 1/1/70 (or 
		SYSTEMTIME stimeNow;			// big structure
		time_t cSecNow;					// time now...
		GetSystemTime(&stimeNow);
		time(&cSecNow);

		DATE dateNow;					// 8-byte real value (double), days from January 1, 1753 and December 31, 2078, inclusive. 
		SystemTimeToVariantTime(&stimeNow, &dateNow);
		int cSecTheTimeFromNow;
		if(theTime > cSecNow)
			cSecTheTimeFromNow = (int) (theTime - cSecNow);
		else 
			cSecTheTimeFromNow = -((int) (cSecNow - theTime));

		DATE dateTheTime = dateNow + cSecTheTimeFromNow / (24.0 * 60 * 60);
		return dateTheTime;
}


							// local routine that tries to find out
							// local offset from UTC.   (needed 'cause _daylite, _tm don't work in dynamic dll's) 
							//   BUG - because caches value, will be an hour off on nights timezone changes
							//         on the other hand, only used in debug print code, so who really cares?

static DATE DateLocalToGM()
{
	const DATE kBadValue = -7734;			// a very unlikely value
	static DATE gDateLocalToGM = kBadValue;
	static DATE gDateLocalToGM2 = kBadValue;

	if(gDateLocalToGM == kBadValue)		// just do calc's once and never change afterwards
	{
	
				// Set time zone from TZ environment variable. If TZ is not set,
				// the operating system is queried to obtain the default value 
				// for the _daylight and _timezone. 
		_tzset();

		time_t lNow, lNowGM, lNowLocal;

		time(&lNow);				// start with any random time (like now)
		struct tm *tmNow;

		tmNow = gmtime(&lNow);		// get value in GMT
		lNowGM = mktime(tmNow);		// convert back to long values... (secs)

		tmNow = localtime(&lNow);	// get value in local timezone
		lNowLocal = mktime(tmNow);

		long lSecsGMToLocal = (long) (lNowGM - lNowLocal);	// find difference
		gDateLocalToGM = lSecsGMToLocal / (60.0 * 60.0 * 24.0);

		TIME_ZONE_INFORMATION timeZoneInfo;
		DWORD dwTz = GetTimeZoneInformation(&timeZoneInfo);
		long bias = timeZoneInfo.Bias;
		if(TIME_ZONE_ID_STANDARD == dwTz) {
			bias += timeZoneInfo.StandardBias;
		} else if(TIME_ZONE_ID_DAYLIGHT == dwTz) {
			bias += timeZoneInfo.DaylightBias;
		}

				// UTC = local + bias
		gDateLocalToGM2 = bias / (60.0  * 24.0);			// bias time is in minutes...
		_ASSERT(gDateLocalToGM2 == gDateLocalToGM);

	}
	return gDateLocalToGM;				// returns positive values such as 7/24 for seattle summer...
}


// ---------------------------------------------------------------------------
//	SystemTimeToLocalVariantTime()
//	LocalVariantTimeToSystemTime()
//	
//		These routines return variant times (DATES) in local time zone units
//		adjusted for daylight savings time.
//
//		Avoid using these - try to adopt convention that Variant times are
//		  in UTC.  VB probably screws this up...
// ---------------------------------------------------------------------------



HRESULT 
SystemTimeToLocalVariantTime(const SYSTEMTIME *psysTime, DATE *pDate)
{
		
		HRESULT hr = SystemTimeToVariantTime(const_cast<SYSTEMTIME*>(psysTime), pDate);
		if(FAILED(hr)) return hr;		// note - it seems to be returning S_FALSE for OK times
				//   
//		*pDate -= DateLocalToGM();
/*
		*pDate -= _timezone / (24.0 * 60 * 60);			// adjust for time zone
		if(_daylight)
			*pDate += 1.0 / (24.0);						// add 1 hour if in daylight savings time
*/
		return S_OK;
}

HRESULT 
LocalVariantTimeToSystemTime(DATE date, SYSTEMTIME *pSysTime)
{
		_tzset();
//		date += DateLocalToGM();

/*		date += _timezone / (24.0 * 60 * 60);			// adjust for time zone
		if(_daylight)
			date -= 1.0 / (24.0);						// add 1 hour if in daylight savings time
*/
		return VariantTimeToSystemTime(date, pSysTime);	// this is UTC time
}


// -------------------------------------------------------------
// LocalSystemTimeToVariantTime()
// VariantTimeToLocalSystemTime()
//
//  These assume variant time is in UTC, and System time is in LTZ (local time zone).
//
HRESULT 
LocalSystemTimeToVariantTime(const SYSTEMTIME *psysTime, DATE *pDate)
{
		
		HRESULT hr = SystemTimeToVariantTime(const_cast<SYSTEMTIME*>(psysTime), pDate);
		if(FAILED(hr)) return hr;		// note - it seems to be returning S_FALSE for OK times

				// Set time zone from TZ environment variable. If TZ is not set,
				// the operating system is queried to obtain the default value 
				// for the _daylight and _timezone. 
	
/*		_tzset();

		*pDate += _timezone / (24.0 * 60 * 60);			// adjust for time zone
		if(_daylight)
			*pDate -= 1.0 / (24.0);						// add 1 hour if in daylight savings time
*/

				// Here, variant time in UTC, Local system time in LTZ (local time zone).
				//  Converting from LTZ to UTC
				// 8 pm in england is 12 noon here in winter, 1 pm in summer.
				//   so in summer, need to add 7 hours ...
		*pDate += DateLocalToGM();
		return S_OK;
}

HRESULT 
VariantTimeToLocalSystemTime(DATE date, SYSTEMTIME *pSysTime)
{
		_tzset();

/*		date -= _timezone / (24.0 * 60 * 60);			// adjust for time zone
		if(_daylight)
			date += 1.0 / (24.0);	*/					// add 1 hour if in daylight savings time

						// 8 pm england back to noon or 1 pm here in.  So subtract 7 hours.

		date -= DateLocalToGM();	
		return VariantTimeToSystemTime(date, pSysTime);	// this is UTC time
}



// --------------------------------------------------
// ISOTimeZToDate
//		Converts ISO-8601 time to a DATE in local time zone.
//
//		It time zone is not passed in, the ISO times are assumed to be in 
//		UTC zero time zone (Z) if fZuluTimeZone is true, local time zone if false.
//		
//                            012345678901234   
//		Recommended ussage is yyyymmddThhmmssZzzzzz, where the captial letter "T" separates
//		the date from the time.  The time zone fields are optional. If missing the 
//		time zone is assumed to be in 'Z' time if fZuluTimeZone is true, else it's
//		assumed be be in local time zone.  
//		Z is either '+' or '-', and zzzzz is hh:mm, hhmm, or hh
//
//
//		If fZuluTimeZone is true
//			if did not enter a timezone offset	- assumes time is in Zulu coordiantes
//			if entered a timezone offset	- assumes time is in Zulu, offset by time zone
//		If fZuluTimeZone is false
//			If did not enter a timezone offset - assumes time in local timezone
//			if entered a timezone offset	   - assumes time in in Zulu, offset by the time zone
//
//		All 'dates' are returned in UTC time zone.
//
//
//	Possible Bug - problem with TimeZone
//	  I'm assuming that
//		19990901T110102-08:00		- is 11:01:02 local seattle time regardless of daylite savings time.
//									   Does the -8:00 change to -7:00 during the summer?
//
//		Returns a date of 0 if there is a parse error
// -----------------------------------------------------------------------

DATE
ISOTimeToDate(char *pcTime, BOOL fZuluTimeZone /*=false*/)
{ 
  // Get Received Time
 	DATE date = 0;						// 0 return value also indicates error

	SYSTEMTIME sysTime, sysTimeNow;
    GetSystemTime(&sysTimeNow);			// initialize with currrent time.

	BOOL fParseError = false;
	BOOL fEnteredTZ  = false;
					
	if(NULL == *pcTime) {				// parse the time
		fParseError = true;	
	} else {
		char strValue[5]; 
		int iValue;
		unsigned short usValue;

		// timezone parsing
		int itzSign = 1;
		int tzMinutes = 0;
		int cTZ = 0;
		char *pcTZ = strchr(pcTime,'+');
		if(!pcTZ) 
		{
			pcTZ = strchr(pcTime,'-'); 
			itzSign = -1;
		}
		if(pcTZ) {
			cTZ = *pcTZ;			// remember values so we can restore it...
			*pcTZ = NULL;
			pcTZ += 1;				// (bump up by one to skip '+/-')

			fEnteredTZ = true;

			int iLen = strlen(pcTZ);
			switch(iLen)
			{
			default:
				fParseError = true;
				break;
			case 2:		// 'hh' form
				if(1 != sscanf(pcTZ, "%d", &iValue))
					fParseError = true;
				else
					tzMinutes = iValue * 60 * itzSign;
				break;
			case 4:		// 'hhmm' form
				strValue[0] = pcTZ[0];
				strValue[1] = pcTZ[1];
				strValue[2] = 0;
				if(1 != sscanf(strValue, "%d", &iValue))
					fParseError = true;
				else {
					tzMinutes = iValue * 60;
					strValue[0] = pcTZ[2];
					strValue[1] = pcTZ[3];
					strValue[2] = 0;
					if(1 != sscanf(strValue, "%d", &iValue))
						fParseError = true;
					else {
						tzMinutes += iValue;
						tzMinutes *= itzSign;
					}
				}
				break;
			case 5:		// 'hh:mm' form
				strValue[0] = pcTZ[0];
				strValue[1] = pcTZ[1];
				strValue[2] = 0;
				if(1 != sscanf(strValue, "%d", &iValue) || pcTZ[2] != ':')
					fParseError = true;
				else {
					tzMinutes = iValue * 60;
					strValue[0] = pcTZ[3];
					strValue[1] = pcTZ[4];
					strValue[2] = 0;
					if(1 != sscanf(strValue, "%d", &iValue))
						fParseError = true;
					else {
						tzMinutes += iValue;
						tzMinutes *= itzSign;
					}
				}
				break;
			}
		}

		memset(&sysTime, 0, sizeof(SYSTEMTIME));		// initalize time to '00:00:00 hours/minutes/seconds ('beginning of current day)

		int iLen = strlen(pcTime);
		switch(iLen)
		{
		case 15:
			// Seconds
			strValue[0] = pcTime[13];
			strValue[1] = pcTime[14];
			strValue[2] = 0;
			if(1 != sscanf(strValue, "%d", &usValue))
				fParseError = true;
			else
				sysTime.wSecond = usValue;
		case 13:
			// Minutes
			strValue[0] = pcTime[11];
			strValue[1] = pcTime[12];
			strValue[2] = 0;
			if(1 != sscanf(strValue, "%d", &usValue))
				fParseError = true;
			else
				sysTime.wMinute = usValue;
		case 11:
			// Hours
			strValue[0] = pcTime[9];
			strValue[1] = pcTime[10];
			strValue[2] = 0;
			if(1 != sscanf(strValue, "%d", &usValue))
				fParseError = true;
			else
				sysTime.wHour = usValue;

			if(pcTime[8] != 'T')			// object if not 'T' in the middle according to spec.
				fParseError = true;
	
		case 8:
			// Year
			strValue[0] = pcTime[0];
			strValue[1] = pcTime[1];
			strValue[2] = pcTime[2];
			strValue[3] = pcTime[3];
			strValue[4] = 0;
			if(1 != sscanf(strValue, "%d", &usValue))
				fParseError = true;
			else
				sysTime.wYear = usValue;
			
			// Month
			strValue[0] = pcTime[4];
			strValue[1] = pcTime[5];
			strValue[2] = 0;
			if(1 != sscanf(strValue, "%d", &usValue))
				fParseError = true;
			else
				sysTime.wMonth = usValue;

			// Day
			strValue[0] = pcTime[6];
			strValue[1] = pcTime[7];
			strValue[2] = 0;
			if(1 != sscanf(strValue, "%d", &usValue))
				fParseError = true;
			else
				sysTime.wDay = usValue;
			break;

		default:
			fParseError = true;
		}

				// Set time zone from TZ environment variable. If TZ is not set,
				// the operating system is queried to obtain the default value 
				// for the variable. 
		_tzset();

		
		if(!fParseError) {
/*			if(fEnteredTZ) {
				SystemTimeToLocalVariantTime(&sysTime, &date);
				date -= tzMinutes / (60.0 * 24.0);
			} else {
				if(!fZuluTimeZone) 
					SystemTimeToVariantTime(&sysTime, &date);
				else {
					SystemTimeToLocalVariantTime(&sysTime, &date);
				}
			} 
			if(_daylight) date -= 1.0 / (24.0);			// is this right???
			*/

			if(fEnteredTZ) {
				SystemTimeToVariantTime(&sysTime, &date);
				date -= tzMinutes / (60.0 * 24.0);
			} else {
				if(fZuluTimeZone) 
					SystemTimeToVariantTime(&sysTime, &date);
				else {
					LocalSystemTimeToVariantTime(&sysTime, &date);		// 
				}
			}

		}
										// reset string if we mucked with it.
		if(pcTZ) pcTZ[-1] = (char) cTZ;
    }
	return date;
}

// -----------------------------------------------------------------------
//   converts date to a string in local time zone 
//		date must be in UTC.

CComBSTR 
DateToBSTR(DATE date)
{
	USES_CONVERSION;

	static WCHAR *RgDay[] = {L"Sun",L"Mon",L"Tue",L"Wed",L"Thu",L"Fri",L"Sat"};

    /* Set time zone from TZ environment variable. If TZ is not set,
     * the operating system is queried to obtain the default value 
     * for the variable. 
     */
    _tzset();

 
//	time_t aclock;
//	time( &aclock );					// current time
//	struct tm *nowTime = localtime( &aclock );
	
				// this whole sections is bad since ComOleDate doesn't work
	const int kMaxSize = 256;
	CComBSTR spBstr(kMaxSize);

	if(0.0 == date) 
	{
		swprintf(spBstr,L"<Not Set>");
	} else {
/*
		date -= _timezone / (24.0 * 60 * 60);			// adjust for time zone
		if(_daylight)
			date += 1.0 / (24.0);						// add 1 hour if in daylight savings time
*/
		SYSTEMTIME sysTime;
//		BOOL fOk = VariantTimeToSystemTime(date, &sysTime);				// this is UDC time
		HRESULT hr = VariantTimeToLocalSystemTime(date, &sysTime);		// this is local time
		if(FAILED(hr))
		{
			swprintf(spBstr,L"<Invalid>");
		} else {

			TIME_ZONE_INFORMATION timeZoneInfo;							// get timezone name
			DWORD dwTz = GetTimeZoneInformation(&timeZoneInfo);
			

			WCHAR *pwszZone = 0;
            CComBSTR spbsZoneUnknown="Unknown Time Zone";    //-> UTZ

			if(TIME_ZONE_ID_STANDARD == dwTz) {
				pwszZone = timeZoneInfo.StandardName;
			} else if(TIME_ZONE_ID_DAYLIGHT == dwTz) {
				pwszZone = timeZoneInfo.DaylightName;
            } else {
                pwszZone = timeZoneInfo.StandardName;
            }
            if(NULL == pwszZone)
            {
                pwszZone = spbsZoneUnknown.m_str;
            }

			WCHAR wszTZoneShort[16]; 

			if(wcslen(pwszZone) < 9) {									// if it's long, abbreviate it.
				wcscpy(wszTZoneShort, pwszZone);
			} else {
				WCHAR *ptz = wszTZoneShort; ptz++;
				wszTZoneShort[0] = *pwszZone;
				while(*(++pwszZone))				// abbreviate name name
				{
					if(*pwszZone == ' ') {
						*pwszZone++;
						if(*pwszZone) *ptz++ = *pwszZone;
					}
				}
				*ptz = NULL;
			}

			swprintf(spBstr,L"%s %02d/%02d/%d %02d:%02d:%02d %s %s (LTZ)",
				RgDay[sysTime.wDayOfWeek],
				sysTime.wMonth, sysTime.wDay, sysTime.wYear, 
				sysTime.wHour % 12, sysTime.wMinute, sysTime.wSecond,
				((sysTime.wHour/12)==0 ? L"AM":L"PM"), wszTZoneShort);
		}
	}
	return spBstr;
//	char *cs = time.Format(_T("%a %b %d %I:%m:%S %p"));
}

CComBSTR 
DateToDiffBSTR(DATE date)				// Date is in UTC (Variant Time), not local time
{
	const int kMaxSize = 256;
	CComBSTR spBstr(kMaxSize);

	if(0.0 == date) 
	{
		swprintf(spBstr,L"<Undefined>");
	} else {
		SYSTEMTIME SysTimeNow;
		GetSystemTime(&SysTimeNow);									// initialize with currrent time.
		DATE dateNow;
		SystemTimeToVariantTime(&SysTimeNow, &dateNow);

		SYSTEMTIME sysTime;
		BOOL fOk = VariantTimeToSystemTime(date, &sysTime);			// this is UTC time
		if(!fOk)
		{
			swprintf(spBstr,L"<Invalid>");
		} else {
			DATE dateDel = dateNow - date;
			WCHAR *pszDiff;
			if(dateDel < 0) {
				pszDiff = L"From Now";
				dateDel = -dateDel;
			} else
				pszDiff = L"Before Now";

			if(dateDel > 365/4.0)
				swprintf(spBstr,L"%6.2f Years %s",dateDel/365.25, pszDiff);
			else if(dateDel > 1.0)
				swprintf(spBstr,L"%5.1f Days %s",int(10*dateDel + 0.5)/10.0, pszDiff);
			else if (dateDel > 1.0 / 24)
				swprintf(spBstr,L"%5.1f Hours %s", int(10*dateDel * 24 + 0.5)/10.0, pszDiff);
			else if (dateDel > 1.0 / (24*60))
				swprintf(spBstr,L"%5.1f Minutes %s",int(10*dateDel * 24 * 60 + 0.5)/10.0, pszDiff);
			else if (dateDel > 2.0 / (24*60*60))
				swprintf(spBstr,L"%5.1f Seconds %s", int(dateDel * 24 * 60 * 60 + 0.5)/10.0, pszDiff);
			else
				swprintf(spBstr,L"Now");
		}	
	}

//	COleDateTimeSpan spanElapsed = timeThen - timeStart;
	return spBstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tvetree.cpp ===
// TveTree.cpp : Implementation of CTveTree

#include "stdafx.h"
//#include "winsock2.h"
#include "TveTreeView.h"
#include "TveTree.h"
#include "TveTreePP.h"

#include <wchar.h>
#include <Iphlpapi.h>		// GetAdapterInfo, needs Iphlpapi.lib

#pragma comment(lib, "comctl32.lib")

#include "windowsx.h" 
#include "winsock.h"

#include "dbgstuff.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// forwards
void DeleteAllDescStrings(HWND hWnd, HTREEITEM hRoot);	
/////////////////////////////////////////////////////////////////////////////
// IObjectSafety


/////////////////////////////////////////////////////////////////////////////
// ISpecifyPropertyPages

/*STDMETHODIMP
CTveTree::GetPages (
    CAUUID * pPages
    )
{
 	HRESULT hr = S_OK;

	if(1)
	{
		pPages->cElems = 1 ;
		pPages->pElems = (GUID *) CoTaskMemAlloc(pPages->cElems * sizeof GUID) ;

		if (pPages->pElems == NULL)
		{
			pPages->cElems = 0;
			return E_OUTOFMEMORY;
		}
		(pPages->pElems)[0] = CLSID_TveTreePP;
	} else {
		pPages->cElems = 0;
		pPages->pElems = NULL;
	}

    return S_OK;
}
*/
/////////////////////////////////////////////////////////////////////////////
// CTveTree
HRESULT 
CTveTree::AddToTop(TCHAR *tbuff)
{
	TCHAR szTbuff[1024];
	_stprintf(szTbuff,_T("Top : %s\n"),tbuff);
//	OutputDebugString(szTbuff);
	m_ctlTop.SetWindowText(tbuff);
	return S_OK;
}


HRESULT 
CTveTree::AddToOutput(TCHAR *tbuff)
{
	TCHAR szTbuff[1024];
	_stprintf(szTbuff,_T("Bot : %s\n"),tbuff);
//	OutputDebugString(szTbuff);
	m_ctlEdit.SetWindowText(tbuff);
	return S_OK;
}

HRESULT 
CTveTree::FinalConstruct()
{
	HRESULT hr = S_OK;
				// ---------- U/I Elements --------------

	try 
	{
		m_spTVEViewSupervisor	= ITVEViewSupervisorPtr(CLSID_TVEViewSupervisor);
		m_spTVEViewService		= ITVEViewServicePtr(CLSID_TVEViewService);
		m_spTVEViewEnhancement	= ITVEViewEnhancementPtr(CLSID_TVEViewEnhancement);
		m_spTVEViewVariation	= ITVEViewVariationPtr(CLSID_TVEViewVariation);
		m_spTVEViewTrack		= ITVEViewTrackPtr(CLSID_TVEViewTrack);
		m_spTVEViewTrigger		= ITVEViewTriggerPtr(CLSID_TVEViewTrigger);
		m_spTVEViewEQueue		= ITVEViewEQueuePtr(CLSID_TVEViewEQueue);
		m_spTVEViewMCastManager	= ITVEViewMCastManagerPtr(CLSID_TVEViewMCastManager);

	} catch (...) {
		return REGDB_E_CLASSNOTREG;
	}
	if( NULL == m_spTVEViewSupervisor ||
		NULL == m_spTVEViewService ||
		NULL == m_spTVEViewEnhancement ||
		NULL == m_spTVEViewVariation ||
		NULL == m_spTVEViewTrack ||
		NULL == m_spTVEViewTrigger ||
		NULL == m_spTVEViewEQueue ||
		NULL == m_spTVEViewMCastManager)
		return E_OUTOFMEMORY;

	m_spTVEViewEQueue->put_TveTree(this);



				// ----------- good stuff ------------
										// create/get a supervisor object...(there is only one, it's a singleton)
	ITVESupervisorPtr spSuper;
	try
	{
		spSuper = ITVESupervisorPtr(CLSID_TVESupervisor);
	} catch (...) {
		return REGDB_E_CLASSNOTREG;
	}


	if(NULL == spSuper) 
		return E_OUTOFMEMORY;

	m_spSuper = spSuper;

//#define DO_INITIAL_TUNETO
#ifdef DO_INITIAL_TUNETO
	
	// HACKY CODE - since IP Sink doesn't work!
	CComBSTR bstrTmp(_T("c:\\IPSinkAdapter.txt"));
	m_bstrPersistFile = bstrTmp;

	ReadAdapterFromFile();			// try reading it from file

										// start it running 
	try
	{
		hr = m_spSuper->put_Description(L"TVE Test Control");
		if(FAILED(hr)) return hr;

		int cAdaptersUnDi, cAdaptersBiDi;
		Wsz32 *rgAdapters;
		if(0 == m_spbsIPAdapterAddr.Length())			// attempt to get a Multicast Addr if haven't set it yet.
		{
			get_IPAdapterAddresses(&cAdaptersUnDi, &cAdaptersBiDi, &rgAdapters);
			_ASSERT(cAdaptersUnDi + cAdaptersBiDi > 0);		// no IP ports...
			if(cAdaptersUnDi + cAdaptersBiDi == 0) {
				hr = E_FAIL;
				OutputDebugString(_T("***ERROR*** No IP adapters found at all!!!!\n"));
				return hr;
			}
			if(cAdaptersUnDi == 0) {
				hr = E_FAIL;
				OutputDebugString(_T("***Warning*** No Unidirectional IP adapters found.  Using BiDirectional one\n"));
			}


						// set default values and Tune to it...
			CComBSTR bstrTmp(rgAdapters[0]);
			m_spbsIPAdapterAddr = bstrTmp;
	
			TCHAR tzBuff[256];
			_stprintf(tzBuff, _T("Fakening IP address to %ls\n"), m_spbsIPAdapterAddr);
			OutputDebugString(tzBuff);
			hr = S_OK;
		}

		hr = m_spSuper->TuneTo(L"InitialChannel", m_spbsIPAdapterAddr);


	} catch (HRESULT hrCatch) {
		hr = hrCatch;
	} catch (...) {
		hr = E_FAIL;
	}
#endif

	return hr;
}

HRESULT 
CTveTree::InPlaceActivate(LONG iVerb, const RECT *prcPosRect)
{
	HRESULT hr = S_OK;
	hr = CComControlBase::InPlaceActivate(iVerb, prcPosRect);

//	if(FAILED(hr) || iVerb != OLEIVERB_SHOW)
	if(FAILED(hr) || iVerb != OLEIVERB_INPLACEACTIVATE)
		return hr;

		// for this way to work, sink object needs to support ITVEEvents.
		//   which it doesn't with DispEvent stuff.
		// Need to create out of the Final Constructor?
	if(SUCCEEDED(hr))
	{
										// get the events...
		IUnknownPtr spPunkSuper(m_spSuper);			// the event source
		IUnknownPtr spPunkSink(GetUnknown());		// this new event sink...

		if(m_dwTveEventsAdviseCookie) {
			hr = AtlUnadvise(spPunkSuper,
							 DIID__ITVEEvents,
							 m_dwTveEventsAdviseCookie);		// need to pass to AtlUnadvise...
			m_dwTveEventsAdviseCookie = 0;
		}


		if(NULL == spPunkSuper)
			return E_NOINTERFACE;

		{
			IUnknownPtr spPunk = NULL;
			IUnknownPtr spPunk2 = NULL;
			hr = spPunkSink->QueryInterface(DIID__ITVEEvents, (void **) &spPunk);
			hr = spPunkSink->QueryInterface(__uuidof(_ITVEEvents), (void **)  &spPunk2);
			if(FAILED(hr))
			{
				AddToOutput(_T("Error : Sink doesn't support DIID__ITVEEvents Interface"));
				return hr;
			}
		}

		hr = AtlAdvise(spPunkSuper,				// event source (TveSupervisor)
					   spPunkSink,				// event sink (gseg event listener...)
					   DIID__ITVEEvents,		// <--- hard line
					   &m_dwTveEventsAdviseCookie);	 // need to pass to AtlUnad	if(FAILED(hr))

		spPunkSink->Release();					// magic code here (Forward)
	}


	return hr;
}

//------------

void 
CTveTree::FinalRelease()
{

	m_spTVEViewEQueue->put_TveTree(NULL);

	if(m_spTVEViewSupervisor)	m_spTVEViewSupervisor->put_Visible(false);
	if(m_spTVEViewService)		m_spTVEViewService->put_Visible(false);
	if(m_spTVEViewEnhancement)	m_spTVEViewEnhancement->put_Visible(false);
	if(m_spTVEViewVariation)	m_spTVEViewVariation->put_Visible(false);
	if(m_spTVEViewTrack)		m_spTVEViewTrack->put_Visible(false);
	if(m_spTVEViewTrigger)		m_spTVEViewTrigger->put_Visible(false);
	if(m_spTVEViewEQueue)		m_spTVEViewEQueue->put_Visible(false);
	if(m_spTVEViewMCastManager)	m_spTVEViewMCastManager->put_Visible(false);


	if(m_ctlSysTreeView32.m_hWnd)
	{
		int cItems = TreeView_GetCount(m_ctlSysTreeView32.m_hWnd);
		if(cItems > 0) {													// if any items, clean them out...
			HTREEITEM hRoot = TreeView_GetRoot(m_ctlSysTreeView32.m_hWnd);
			DeleteAllDescStrings(m_ctlSysTreeView32.m_hWnd, hRoot);			// delete all .lparam strings we 'newed'
			TreeView_DeleteAllItems(m_ctlSysTreeView32.m_hWnd);				// delete the entire existig tree.
		}
	}

	m_MapH2P.erase(m_MapH2P.begin(), m_MapH2P.end());					// delete the maps too... 
	m_MapP2H.erase(m_MapP2H.begin(), m_MapP2H.end());			

	HRESULT hr;
	if(0 != m_dwTveEventsAdviseCookie)
	{
		if(m_spSuper) {

			IUnknownPtr spPunkSuper(m_spSuper);

			IUnknownPtr spPunkSink(GetUnknown());		// this new event sink...
			spPunkSink->AddRef();					// magic code here (inverse)

			hr = AtlUnadvise(spPunkSuper,
							 DIID__ITVEEvents,
							 m_dwTveEventsAdviseCookie);		// need to pass to AtlUnadvise...
			if(FAILED(hr))
				spPunkSink->Release();

			m_dwTveEventsAdviseCookie = 0;
		}
	}  

}

//------------------------------------------------------------------
LRESULT 
CTveTree::OnClose(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
	HTREEITEM hRoot;													//  (could be far smarter here!)
	int cItems = TreeView_GetCount(m_ctlSysTreeView32.m_hWnd);
	if(cItems > 0) {													// if any items, clean them out...
		hRoot = TreeView_GetRoot(m_ctlSysTreeView32.m_hWnd);
		DeleteAllDescStrings(m_ctlSysTreeView32.m_hWnd, hRoot);			// delete all .lparam strings we 'newed'
		TreeView_DeleteAllItems(m_ctlSysTreeView32.m_hWnd);				// delete the entire existig tree.
	}
																
	m_MapH2P.erase(m_MapH2P.begin(), m_MapH2P.end());					// delete the maps too... (very inefficent!)
	m_MapP2H.erase(m_MapP2H.begin(), m_MapP2H.end());			

	return 0;
}

LRESULT 
CTveTree::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HTREEITEM hRoot;													//  (could be far smarter here!)
	int cItems = TreeView_GetCount(m_ctlSysTreeView32.m_hWnd);
	if(cItems > 0) {													// if any items, clean them out...
		hRoot = TreeView_GetRoot(m_ctlSysTreeView32.m_hWnd);
		DeleteAllDescStrings(m_ctlSysTreeView32.m_hWnd, hRoot);			// delete all .lparam strings we 'newed'
		TreeView_DeleteAllItems(m_ctlSysTreeView32.m_hWnd);				// delete the entire existig tree.
	}
																
	m_MapH2P.erase(m_MapH2P.begin(), m_MapH2P.end());					// delete the maps too... (very inefficent!)
	m_MapP2H.erase(m_MapP2H.begin(), m_MapP2H.end());			
	return 0;
}

BOOL 
CTveTree::PreTranslateAccelerator(LPMSG pMsg, HRESULT& hRet)
{
	if(pMsg->message == WM_KEYDOWN && 
		(pMsg->wParam == VK_LEFT || 
		pMsg->wParam == VK_RIGHT ||
		pMsg->wParam == VK_UP ||
		pMsg->wParam == VK_DOWN))
	{
		hRet = S_FALSE;
		return TRUE;
	}
	//TODO: Add your additional accelerator handling code here
	return FALSE;
}

LRESULT 
CTveTree::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	LRESULT lRes = CComControl<CTveTree>::OnSetFocus(uMsg, wParam, lParam, bHandled);
	if (m_bInPlaceActive)
	{
		DoVerbUIActivate(&m_rcPos,  NULL);
		if(!IsChild(::GetFocus()))
			m_ctlSysTreeView32.SetFocus();
	}
	return lRes;
}

LRESULT 
CTveTree::OnLButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    NMHDR *pnmh = (NMHDR *) (&lParam); 

    HWND hwndFrom = pnmh->hwndFrom; 
    UINT idFrom = pnmh->idFrom; 
    UINT code = pnmh->code; 
    
	return 0;
}

LRESULT 
CTveTree::OnRButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    NMHDR *pnmh = (NMHDR *) (&lParam); 

    HWND hwndFrom = pnmh->hwndFrom; 
    UINT idFrom = pnmh->idFrom; 
    UINT code = pnmh->code; 
/*	if(!m_pdlgTveTreePP) 
		return 1;

	if(m_pdlgTveTreePP->m_hWnd == NULL)			// Prof ATL Com Programing, page 526
//		m_pdlgTveTreePP->Create(m_hWnd);
		m_pdlgTveTreePP->Create(::GetActiveWindow());

	m_pdlgTveTreePP->InitTruncLevel(m_grfTruncatedLevels);
	if(m_pdlgTveTreePP->IsWindowVisible())
		m_pdlgTveTreePP->ShowWindow(SW_HIDE);
	else {
		RECT rect;
		rect.top = 20; rect.left = 20; rect.bottom = 400; rect.right = 400;
		m_pdlgTveTreePP->CenterWindow(::GetActiveWindow());
		m_pdlgTveTreePP->ShowWindow(SW_SHOW);
	}
*/

	return 0;
}

LRESULT 
CTveTree::OnRButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    NMHDR *pnmh = (NMHDR *) (&lParam); 
	TVHITTESTINFO tvhinfo;
	const int kMaxLen = 128;
	
	long xPos = GET_X_LPARAM(lParam); 
	long yPos = GET_Y_LPARAM(lParam); 
	tvhinfo.pt.x = xPos;
	tvhinfo.pt.y = yPos;

					// strange, need to do own hitTest here to figure out item..
	TreeView_HitTest(m_ctlSysTreeView32.m_hWnd, &tvhinfo);
	if(0 != tvhinfo.hItem)
	{
		TVITEM tvItem;
		tvItem.mask = TVIF_TEXT | TVIF_TEXT | TVIF_CHILDREN | TVIF_HANDLE;
		tvItem.hItem = tvhinfo.hItem;
		tvItem.cchTextMax = kMaxLen;
		TCHAR tcBuff[kMaxLen];
		tvItem.pszText = tcBuff; 

						// get string and associated flags
		BOOL fOK = TreeView_GetItem(m_ctlSysTreeView32.m_hWnd,&tvItem);

		IUnknown *pUnk = m_MapH2P[tvItem.hItem];		// map from HItem to PUnk
		if(NULL != pUnk) 
		{
			TVE_EnClass enClass = (TVE_EnClass) GetTVEClass(pUnk);

			try {
				switch(enClass) {
				case TVE_EnSupervisor:
					{
						ITVESupervisorPtr spSupervisor(pUnk);
						if(spSupervisor)
						{
							m_spTVEViewSupervisor->put_Supervisor(spSupervisor);
							m_spTVEViewSupervisor->put_Visible(VARIANT_TRUE);
						}
					}
					break;
				case TVE_EnService:
					{
						ITVEServicePtr spService(pUnk);
						if(spService)
						{
							m_spTVEViewService->put_Service(spService);
							m_spTVEViewService->put_Visible(VARIANT_TRUE);
						}
					}
					break;
				case TVE_EnEnhancement:
					{
						ITVEEnhancementPtr spEnhancement(pUnk);
						if(spEnhancement)
						{
							m_spTVEViewEnhancement->put_Enhancement(spEnhancement);
							m_spTVEViewEnhancement->put_Visible(VARIANT_TRUE);
						}
					}
					break;
				case TVE_EnVariation:
					{
						ITVEVariationPtr spVariation(pUnk);
						if(spVariation)
						{
							m_spTVEViewVariation->put_Variation(spVariation);
							m_spTVEViewVariation->put_Visible(VARIANT_TRUE);
						}
					}
					break;
				case TVE_EnTrack:
					{
						ITVETrackPtr spTrack(pUnk);
						if(spTrack)
						{
							m_spTVEViewTrack->put_Track(spTrack);
							m_spTVEViewTrack->put_Visible(VARIANT_TRUE);
						}
					}
					break;
				case TVE_EnTrigger:
					{
						ITVETriggerPtr spTrigger(pUnk);
						if(spTrigger)
						{
							m_spTVEViewTrigger->put_Trigger(spTrigger);
							m_spTVEViewTrigger->put_Visible(VARIANT_TRUE);
						}
					}
					break;
				case TVE_EnEQueue:
					{
						ITVEAttrTimeQPtr spEQueue(pUnk);
						if(spEQueue)
						{
                                // need to set a service pointer... To get, search
                                //   through all services for one with this expire queue.  
                                //   Ugly, but what else can we do?
                            {
                                m_spTVEViewEQueue->put_Service(NULL);
                                ITVEServicesPtr spServices;
                                HRESULT hr2 = m_spSuper->get_Services(&spServices);
                                if(!FAILED(hr2) && NULL != spServices)
                                {
                                    long cServices;
                                    hr2 = spServices->get_Count(&cServices);
                                    _ASSERT(!FAILED(hr2));
                                    for(int i = 0; i < cServices; i++)
                                    {
                                        CComVariant cv(i);
                                        ITVEServicePtr spService;
                                        hr2 = spServices->get_Item(cv, &spService);
                                        if(!FAILED(hr2) && NULL != spService)
                                        {
                                            ITVEAttrTimeQPtr spEQueue2;
                                            spService->get_ExpireQueue(&spEQueue2);
                                            if(spEQueue2)
                                            {
                                               m_spTVEViewEQueue->put_Service(spService);
                                               break;
                                            }
                                        }
                                    }       // in bad case, may drop out of here without setting service...
                                }           //   - only difficult is that it won't show Expire Offset in U/I
                             }
							m_spTVEViewEQueue->put_ExpireQueue(spEQueue);
							m_spTVEViewEQueue->put_Visible(VARIANT_TRUE);
						}
					}
					break;
				case TVE_EnFile:
					{
						ITVEFilePtr spFile(pUnk);
						if(spFile)
						{
							m_spTVEViewFile->put_File(spFile);
							m_spTVEViewFile->put_Visible(VARIANT_TRUE);
						}
					}
			    case TVE_EnMCastManager:
					{
						ITVEMCastManagerPtr spMCastManager(pUnk);
						if(spMCastManager)
						{
							m_spTVEViewMCastManager->put_MCastManager(spMCastManager);
							m_spTVEViewMCastManager->put_Visible(VARIANT_TRUE);
						}
					}
				case TVE_EnUnknown:
				default:
					break;
				} // end switch
			}
			catch (...)
			{
				// something bad happened
			}
		}	// end had item	
	}	// end hit test

	return 0;
}


LRESULT 
CTveTree::OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
	RECT rc;
	int iTotalHeight, iTotalWidth;
	GetWindowRect(&rc);
	InitCommonControls();

	iTotalWidth  = rc.right - rc.left;		// absolute size of rectangle
	iTotalHeight = rc.bottom - rc.top;

	rc.top = rc.left = 0;					// set origin to zero (change RC to window units)
	rc.right = iTotalWidth;
	rc.bottom = m_tmHeight;			
	m_ctlTop.Create(m_hWnd, rc, NULL, WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL);

	rc.top = rc.bottom;
	rc.bottom = iTotalHeight - m_tmHeight;
	m_ctlSysTreeView32.Create(m_hWnd, rc, NULL, WS_CHILD | WS_VISIBLE | WS_BORDER | 
												TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS);
	rc.top = iTotalHeight - m_tmHeight;
	rc.bottom = m_tmHeight;
	m_ctlEdit.Create(m_hWnd, rc, NULL, WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL);

	HBITMAP hBitmap;
	m_hImageList = ImageList_Create(16,16, ILC_COLOR, 20, 5);	

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGER));
	m_iImageR = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGES));
	m_iImageS = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGEE));
	m_iImageE = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGEEP));
	m_iImageEP = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);


	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGEV));
	m_iImageV = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGET));
	m_iImageT = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);
		
	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGEEQ));
	m_iImageEQ = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGEMM));
	m_iImageMM = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

            // ---------

    hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGER_T));
	m_iImageR_T = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGES_T));
	m_iImageS_T = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGEE_T));
	m_iImageE_T = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGEV_T));
	m_iImageV_T = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGET_T));
	m_iImageT_T = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGEMM_T));
	m_iImageMM_T = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

            // ------------
    
    hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGET_TUNED));
	m_iImageT_Tuned = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_IMAGEEQ_T));
	m_iImageEQ_T = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);
		
		
	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_SELECT));
	m_iSelect = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);

	hBitmap = LoadBitmap(_Module.GetTypeLibInstance(), MAKEINTRESOURCE(IDB_SELECT_TUNED));
	m_iSelect_Tuned = ImageList_Add(m_hImageList, hBitmap, (HBITMAP) 0);
	DeleteObject(hBitmap);


	TreeView_SetImageList(m_ctlSysTreeView32.m_hWnd, m_hImageList, TVSIL_NORMAL);

	ClearAndFillTree();

	return 0;
}

STDMETHODIMP 
CTveTree::SetObjectRects(LPCRECT prcPos,LPCRECT prcClip)
{
	IOleInPlaceObjectWindowlessImpl<CTveTree>::SetObjectRects(prcPos, prcClip);
	int cx, cy;
	cx = prcPos->right - prcPos->left;
	cy = prcPos->bottom - prcPos->top;
	
	int iys, iyh;

	iys = 0;  	iyh = m_tmHeight;
	::SetWindowPos(m_ctlTop.m_hWnd, NULL,		    0,	iys, cx, iyh, SWP_NOZORDER | SWP_NOACTIVATE);

	iys = iyh;  	iyh = cy - 2*m_tmHeight;
	::SetWindowPos(m_ctlSysTreeView32.m_hWnd, NULL, 0,	iys, cx, iyh, SWP_NOZORDER | SWP_NOACTIVATE);

	iys = cy - m_tmHeight;  iyh = m_tmHeight;
	::SetWindowPos(m_ctlEdit.m_hWnd,          NULL, 0,	iys, cx, iyh, SWP_NOZORDER | SWP_NOACTIVATE);
	return S_OK;
}


LRESULT 
CTveTree::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(m_tmHeight == 0)				// set to height of a line of text
	{
		HDC hdc = m_ctlEdit.GetDC();
		TEXTMETRIC tm;
		::GetTextMetrics(hdc, &tm);
		ReleaseDC(hdc);
		m_tmHeight = tm.tmHeight;
	}
	WORD nWidth = LOWORD(lParam);
	WORD nHeight = HIWORD(lParam);
	int iys, iyh;

	iys = 0;  	iyh = m_tmHeight;
	::SetWindowPos(m_ctlTop.m_hWnd,		      NULL, 0, iys, nWidth, iyh, SWP_NOZORDER | SWP_NOACTIVATE);

	iys = iyh;  	iyh = nHeight - 2*m_tmHeight;
	::SetWindowPos(m_ctlSysTreeView32.m_hWnd, NULL, 0, iys, nWidth, iyh, SWP_NOZORDER | SWP_NOACTIVATE);

	iys = nHeight - m_tmHeight;  iyh = m_tmHeight;
	::SetWindowPos(m_ctlEdit.m_hWnd,		  NULL, 0, iys, nWidth, iyh, SWP_NOZORDER | SWP_NOACTIVATE);
	return 0;
}


HRESULT 
CTveTree::OnDraw(ATL_DRAWINFO& di)
{	
	int caps = GetDeviceCaps(di.hdcDraw, TECHNOLOGY);  	// see Beginning ATL COM Programming, pg 466
	if(caps != DT_RASDISPLAY) 
	{
		RECT& rc = *(RECT*)di.prcBounds;
		Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

					// ---------
		int len = m_ctlTop.GetWindowTextLength();
		LPTSTR strC = new TCHAR[len+1];
		m_ctlTop.GetWindowText(strC, len);

		SIZE size;
		::GetTextExtentPoint32(di.hdcDraw, strC, len, &size);
		if(size.cx > (rc.right - rc.left))
			size.cx = rc.left;
		else
			size.cx = (rc.left + rc.right - size.cx) / 2;

		if(size.cy > (rc.bottom - rc.top))
			size.cy = rc.top;
		else
			size.cy = (rc.top + rc.bottom - size.cy) / 2;

		ExtTextOut(di.hdcDraw, size.cx, size.cy, ETO_CLIPPED, &rc, strC, lstrlen(strC), NULL);
		delete [] strC;

		
					// ---------
		len = m_ctlEdit.GetWindowTextLength();
		LPTSTR str = new TCHAR[len+1];
		m_ctlEdit.GetWindowText(str, len);

		size;
		::GetTextExtentPoint32(di.hdcDraw, str, len, &size);
		if(size.cx > (rc.right - rc.left))
			size.cx = rc.left;
		else
			size.cx = (rc.left + rc.right - size.cx) / 2;

		if(size.cy > (rc.bottom - rc.top))
			size.cy = rc.top;
		else
			size.cy = (rc.top + rc.bottom - size.cy) / 2;

		ExtTextOut(di.hdcDraw, size.cx, size.cy, ETO_CLIPPED, &rc, str, lstrlen(str), NULL);
		delete [] str;
	}
	return S_OK;
}


LRESULT 
CTveTree::OnSelChanged(int idCtrl, LPNMHDR pnmh, BOOL &bHandled)
{
	USES_CONVERSION;
	NMTREEVIEW* pnmtv = (NMTREEVIEW*) pnmh;
	TVITEM tvi = pnmtv->itemNew;
	tvi.mask = TVIF_HANDLE | TVIF_PARAM;
	if(!TreeView_GetItem(m_ctlSysTreeView32.m_hWnd, &tvi))
		return 0;
	m_ctlEdit.SetWindowText(A2T((LPSTR) tvi.lParam));			// updates text string..


												// What did we select ?
	HRESULT hr = S_OK;

	IUnknown *pUnk = m_MapH2P[tvi.hItem];		// map from HItem to PUnk
	if(NULL != pUnk) 
	{
		TVE_EnClass enClass = (TVE_EnClass) GetTVEClass(pUnk);

		switch(enClass) {
		case TVE_EnService:
			{
				ITVEServicePtr spService_To(pUnk);
				ITVEServicePtr spService_From;
				if(m_spTriggerSel)							// this is the old cached trigger, switching away from it
				{
					hr = m_spTriggerSel->get_Service(&spService_From);
				}
				if(spService_From != spService_To)
				{
					ITVETriggerPtr spTrigger_From = m_spTriggerSel;
					m_spTriggerSel = NULL;
					Fire_NotifyTVETreeTuneTrigger(m_spTriggerSel, NULL);			// untune the current trigger
					Fire_NotifyTVETreeTuneService(spService_From, spService_To);	// say we changed services
				}
			}
			break;
		case TVE_EnEnhancement:
			{
				ITVEEnhancementPtr spEnhancement_To(pUnk);
				ITVEEnhancementPtr spEnhancement_From;
				if(m_spTriggerSel)							// this is the old cached trigger, switching away from it
				{
					IUnknownPtr spPunkTrack;
					IUnknownPtr spPunkEnh;
					IUnknownPtr spPunkVariation;

					hr = m_spTriggerSel->get_Parent(&spPunkTrack);
					if(!FAILED(hr) && NULL != spPunkTrack) {
						ITVETrackPtr spTrackSel(spPunkTrack);
						if(spTrackSel)
							hr = spTrackSel->get_Parent(&spPunkVariation);
					}
					if(!FAILED(hr) && NULL != spPunkVariation) {
						ITVEVariationPtr spVarSel(spPunkVariation);
						if(spVarSel)
							hr = spVarSel->get_Parent(&spPunkEnh);
					}

					if(!FAILED(hr) && NULL != spPunkEnh) {
						ITVEEnhancementPtr spEnhancementSel(spPunkEnh);
						if(spPunkEnh)
							spEnhancement_From = spEnhancementSel;
					}
				}
				if(spEnhancement_From != spEnhancement_To)
				{
					ITVETriggerPtr spTrigger_From = m_spTriggerSel;
					m_spTriggerSel = NULL;
					Fire_NotifyTVETreeTuneTrigger(m_spTriggerSel, NULL);						// untune from selected trigger
					Fire_NotifyTVETreeTuneEnhancement(spEnhancement_From, spEnhancement_To);	// say we changed it
				}
			}
			break;

		case TVE_EnVariation:
			{
				ITVEVariationPtr spVariation_To(pUnk);
				ITVEVariationPtr spVariation_From;
				if(m_spTriggerSel)
				{
					IUnknownPtr spPunkTrack;
					IUnknownPtr spPunkVariation;

					hr = m_spTriggerSel->get_Parent(&spPunkTrack);
					if(!FAILED(hr) && NULL != spPunkTrack) {
						ITVETrackPtr spTrackSel(spPunkTrack);
						if(spTrackSel)
							hr = spTrackSel->get_Parent(&spPunkVariation);
					}
					if(!FAILED(hr) && NULL != spPunkVariation) {
						ITVEVariationPtr spVarSel(spPunkVariation);
						if(spVarSel)
							spVariation_From = spVarSel;
					}
				}
				if(spVariation_From != spVariation_To)
				{
					ITVETriggerPtr spTrigger_From = m_spTriggerSel;
					m_spTriggerSel = NULL;
					Fire_NotifyTVETreeTuneTrigger(m_spTriggerSel, NULL);				// untune the current trigger
					Fire_NotifyTVETreeTuneVariation(spVariation_From, spVariation_To);	// say we changed variations
				}

			}
			break;

		case TVE_EnTrack:
		case TVE_EnTrigger:
			{
				ITVETriggerPtr spTrigger_To(pUnk);				// did we click on a track ?
				if(spTrigger_To)
				{
				//	if(m_spTriggerSel != spTrigger_To)			// is it different than our selected one?
					{
						ITVETriggerPtr spTrigger_From = m_spTriggerSel;
						m_spTriggerSel = spTrigger_To;

						Fire_NotifyTVETreeTuneTrigger(spTrigger_From, spTrigger_To);
					}
				}
			}
			break;
		}			// end switch
		UpdateTree(UT_Updated, pUnk);			// redraw the tree

	}			// end NULL selection 

	return 0;
}


LRESULT 
CTveTree::OnGrfTruncChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	if(m_grfTruncatedLevels != wParam)
		ClearAndFillTree();
	m_grfTruncatedLevels = wParam;
	return 0;
}

STDMETHODIMP 
CTveTree::get_Supervisor(ITVESupervisor **ppTVESuper)
{
	if(NULL == ppTVESuper) return E_POINTER;
	*ppTVESuper = NULL;
	if(NULL == m_spSuper) return S_FALSE;

	return m_spSuper->QueryInterface(ppTVESuper);
}

STDMETHODIMP 
CTveTree::get_TVENode(VARIANT *pVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}

STDMETHODIMP 
CTveTree::put_TVENode(VARIANT newVal)
{
	// TODO: Add your implementation code here

	return S_OK;
}


STDMETHODIMP 
CTveTree::get_GrfTrunc(/*[out, retval]*/ int *pVal)		
{	
	*pVal = m_grfTruncatedLevels; return S_OK;
}

STDMETHODIMP 
CTveTree::put_GrfTrunc(/*[in]*/ int newVal)				
{
	BOOL fThingsChanged = (m_grfTruncatedLevels != newVal);
	m_grfTruncatedLevels = newVal; 

	if(fThingsChanged)
		ClearAndFillTree();
	return S_OK;
}


STDMETHODIMP 
CTveTree::UpdateTree(IUnknown *pUnk)
{
	if(NULL == pUnk) 
	{
		ClearAndFillTree();
		HTREEITEM hRoot = TreeView_GetRoot(m_ctlSysTreeView32.m_hWnd);
		TreeView_EnsureVisible(m_ctlSysTreeView32.m_hWnd, hRoot);
	}
	else
		TVEnsureVisible(pUnk);
	return S_OK;
}

STDMETHODIMP 
CTveTree::UpdateView(IUnknown *pUnk)
{
	if(NULL == pUnk) return E_POINTER;

	TVE_EnClass enClass = (TVE_EnClass) GetTVEClass(pUnk);
	switch(enClass)
	{
	case TVE_EnSupervisor:
		{
			ITVESupervisorPtr spSuper(pUnk);
			ITVESupervisorPtr spSuperView;
			VARIANT_BOOL fVisible;
			if(NULL != m_spTVEViewSupervisor && !FAILED(m_spTVEViewSupervisor->get_Supervisor(&spSuperView)))
			{
				if(spSuper == spSuperView)
					if(!FAILED(m_spTVEViewSupervisor->get_Visible(&fVisible)) && fVisible)
						m_spTVEViewSupervisor->UpdateFields();
			}
		}
		break;
	case TVE_EnService:
		{
			ITVEServicePtr spService(pUnk);
			ITVEServicePtr spServiceView;
			VARIANT_BOOL fVisible;
			if(NULL != m_spTVEViewService && !FAILED(m_spTVEViewService->get_Service(&spServiceView)))
			{
				if(spService == spServiceView)
					if(!FAILED(m_spTVEViewService->get_Visible(&fVisible)) && fVisible)
						m_spTVEViewService->UpdateFields();
			}
		}
		break;
	case TVE_EnEnhancement:
		{
			ITVEEnhancementPtr spEnhancement(pUnk);
			ITVEEnhancementPtr spEnhancementView;
			VARIANT_BOOL fVisible;
			if(NULL != m_spTVEViewEnhancement && !FAILED(m_spTVEViewEnhancement->get_Enhancement(&spEnhancementView)))
			{
				if(spEnhancement == spEnhancementView)
					if(!FAILED(m_spTVEViewEnhancement->get_Visible(&fVisible)) && fVisible)
						m_spTVEViewEnhancement->UpdateFields();
			}
		}
		break;
	case TVE_EnVariation:
		{
			ITVEVariationPtr spVariation(pUnk);
			ITVEVariationPtr spVariationView;
			VARIANT_BOOL fVisible;
			if(NULL != m_spTVEViewVariation && !FAILED(m_spTVEViewVariation->get_Variation(&spVariationView)))
			{
				if(spVariation == spVariationView)
					if(!FAILED(m_spTVEViewVariation->get_Visible(&fVisible)) && fVisible)
						m_spTVEViewVariation->UpdateFields();
			}			
		}
		break;
	case TVE_EnTrack:
		{
			ITVETrackPtr spTrack(pUnk);
			ITVETrackPtr spTrackView;
			VARIANT_BOOL fVisible;
			if(NULL != m_spTVEViewTrack && !FAILED(m_spTVEViewTrack->get_Track(&spTrackView)))
			{
				if(spTrack == spTrackView)
					if(!FAILED(m_spTVEViewTrack->get_Visible(&fVisible)) && fVisible)
						m_spTVEViewTrack->UpdateFields();
			}			
		}
		break;
	case TVE_EnTrigger:
		{
			ITVETriggerPtr spTrigger(pUnk);
			ITVETriggerPtr spTriggerView;
			VARIANT_BOOL fVisible;
			if(NULL != m_spTVEViewTrigger && !FAILED(m_spTVEViewTrigger->get_Trigger(&spTriggerView)))
			{
				if(spTrigger == spTriggerView)
					if(!FAILED(m_spTVEViewTrigger->get_Visible(&fVisible)) && fVisible)
						m_spTVEViewTrigger->UpdateFields();
			}	
		}
		break;
	case TVE_EnEQueue:
/*		{
			ITVEAttrTimeQPtr spEQueue(pUnk);
			ITVEAttrTimeQPtr spEQueueView;
			VARIANT_BOOL fVisible;
			if(NULL != m_spTVEViewEQueue && !FAILED(m_spTVEViewEQueue->get_ExpireQueue(&spEQueueView)))
			{
				if(spEQueue == spEQueueView)
					if(!FAILED(m_spTVEViewEQueue->get_Visible(&fVisible)) && fVisible)
						m_spTVEViewEQueue->UpdateFields();
			}	
		} */
		break;
 /*   case TVE_EnMCastManager:
		{
			ITVEMCastManagerPtr spMCastManager(pUnk);
			ITVEMCastManagerPtr spMCastManagerView;
			VARIANT_BOOL fVisible;
			if(NULL != m_spTVEViewMCastManager && !FAILED(m_spTVEViewMCastManager->get_MCastManager(&spMCastManagerView)))
			{
				if(spMCastManager == spMCastManagerView)
					if(!FAILED(m_spTVEViewMCastManager->get_Visible(&fVisible)) && fVisible)
						m_spTVEViewMCastManager->UpdateFields();
			}	
		}
*/
		break;
	default:
		return S_FALSE;
		break;
	}
					// expire queue may change...
	if(NULL != m_spTVEViewEQueue)
	{
		VARIANT_BOOL fVisible;
		if(!FAILED(m_spTVEViewEQueue->get_Visible(&fVisible)) && fVisible)
			m_spTVEViewEQueue->UpdateFields();
	}	

	if(NULL != m_spTVEViewMCastManager)
	{
		VARIANT_BOOL fVisible;
		if(!FAILED(m_spTVEViewMCastManager->get_Visible(&fVisible)) && fVisible)
			m_spTVEViewMCastManager->UpdateFields();
	}
    
	return S_OK;
}
// --------------------------------------------

TVE_EnClass
GetTVEClass(IUnknown *pUnk)
{
	try 
	{
		ITVESupervisorPtr spSuper(pUnk);
		if(spSuper) {
			return TVE_EnSupervisor;
		}

		ITVEServicePtr spServi(pUnk);
		if(spServi) {
			return TVE_EnService;
		}

		ITVETrackPtr spTrack(pUnk);
		if(spTrack) {
			return TVE_EnTrack;
		}

		ITVETriggerPtr spTrigger(pUnk);
		if(spTrigger) {
			return TVE_EnTrigger;
		}

		ITVEAttrTimeQPtr spEQueue(pUnk);
		if(spEQueue) {
			return TVE_EnEQueue;
		}

		ITVEEnhancementPtr spEnhancement(pUnk);
		if(spEnhancement) {
			return TVE_EnEnhancement;
		}

		ITVEVariationPtr spVari(pUnk);
		if(spVari) {
			return TVE_EnVariation;
		}

		ITVEFilePtr spFile(pUnk);
		if(spFile) {
			return TVE_EnFile;
		}

		ITVEMCastManagerPtr spMCastManager(pUnk);
		if(spMCastManager) {
			return TVE_EnMCastManager;
		}

	}
	catch (...)			// bad things happened...
	{
	}

	return TVE_EnUnknown;
}


// ---------------------------------------------------
// ------------------------------------------------------------------------
//  local functions
// ------------------------------------------------------------------------
		
		//Get the IP address of the network adapter.
		//  returns unidirectional adapters followed by bi-directional adapters

static HRESULT
ListIPAdapters(int *pcAdaptersUniDi, int *pcAdaptersBiDi, int cAdapts, Wsz32 *rrgIPAdapts)
{

    HRESULT				hr				=	 E_FAIL;
    BSTR				bstrIP			= 0;
    PIP_ADAPTER_INFO	pAdapterInfo;
    ULONG				Size			= NULL;
    DWORD				Status;
    WCHAR				wszIP[16];
	int					cAdapters		= 0;
	int					cAdaptersUni	= 0;

	memset((void *) rrgIPAdapts, 0, cAdapts*sizeof(Wsz32));


				// staticly allocate a buffer to store the data
	const int kMaxAdapts = 10;
	const int kSize = sizeof (IP_UNIDIRECTIONAL_ADAPTER_ADDRESS) + kMaxAdapts * sizeof(IPAddr);
	char szBuff[kSize];
	IP_UNIDIRECTIONAL_ADAPTER_ADDRESS *pPIfInfo = (IP_UNIDIRECTIONAL_ADAPTER_ADDRESS *) szBuff;

				// get the data..
	ULONG ulSize = kSize;
	hr =  GetUniDirectionalAdapterInfo(pPIfInfo, &ulSize);
	if(S_OK == hr)
	{
		USES_CONVERSION;
		while(cAdaptersUni < (int) pPIfInfo->NumAdapters) {
			in_addr inadr;
			inadr.s_addr = pPIfInfo->Address[cAdaptersUni];
			char *szApAddr = inet_ntoa(inadr);
			WCHAR *wApAddr = A2W(szApAddr);
			wcscpy(rrgIPAdapts[cAdaptersUni++], wApAddr);
		}
	}
		
		

    if ((Status = GetAdaptersInfo(NULL, &Size)) != 0)
    {
        if (Status != ERROR_BUFFER_OVERFLOW)
        {
            return 0;
        }
    }

    // Allocate memory from sizing information
    pAdapterInfo = (PIP_ADAPTER_INFO) GlobalAlloc(GPTR, Size);
    if(pAdapterInfo)
    {
        // Get actual adapter information
        Status = GetAdaptersInfo(pAdapterInfo, &Size);

        if (!Status)
        {
            PIP_ADAPTER_INFO pinfo = pAdapterInfo;

            while(pinfo && (cAdapters < cAdapts))
            {
				MultiByteToWideChar(CP_ACP, 0, pinfo->IpAddressList.IpAddress.String, -1, wszIP, 16);
                if(wszIP)
					wcscpy(rrgIPAdapts[cAdaptersUni + cAdapters++], wszIP);
                pinfo = pinfo->Next;
            }
			
        }
        GlobalFree(pAdapterInfo);
    }

	*pcAdaptersUniDi = cAdaptersUni;
	*pcAdaptersBiDi  = cAdapters;
    return hr;
}

		// returns known adapter addresses in a fixed static array of strings.  Client shouldn't free it.
		//   Both unidirectional and bi-directional adapters returned in the same array, unidirectional
		//   ones first.
		//  
		//  This is a bogus routine - test use only...

HRESULT
CTveTree::get_IPAdapterAddresses(/*[out]*/ int *pcAdaptersUniDi, /*[out]*/ int *pcAdaptersBiDi, /*[out]*/ Wsz32 **rgAdapters)
{
	HRESULT hr = S_OK;

	static Wsz32 grgAdapters[kcMaxIpAdapts];	// array of possible IP adapters
	hr = ListIPAdapters(pcAdaptersUniDi, pcAdaptersBiDi, kcMaxIpAdapts, grgAdapters);
	*rgAdapters = grgAdapters;

	return hr;
}


HRESULT
CTveTree::ReadAdapterFromFile()
{
	USES_CONVERSION;
	FILE *fp = fopen(W2A(m_bstrPersistFile),"r+");
	if(0 != fp)
	{
		char szBuff[256];
		int i = 0;
		int c;
		while(EOF != (c = fgetc(fp)))
		{
			if(c == '\n' || c == '\r') break;
			szBuff[i++] = char(c);
			if(i > 256) return E_FAIL;
		}
		szBuff[i++] = 0;
		fclose(fp);
		CComBSTR bstrTmp(szBuff);
		m_spbsIPAdapterAddr = bstrTmp;
	} else {
		return E_FAIL;
	}
	return S_OK;
}

// ------------------------------------------------------------------------
//  local functions 
// ------------------------------------------------------------------------

// recursive method to delete strings stored in .lparams of the tree structure

void 
DeleteAllDescStrings(HWND hWnd, HTREEITEM hRoot)		// makes a TVE Class visible in the tree view
{
	TVITEM tvi;
	tvi.hItem = hRoot;
	tvi.mask  = TVIF_CHILDREN | TVIF_PARAM;
	TreeView_GetItem(hWnd, &tvi);

	if(tvi.lParam) {
		delete ((void *) tvi.lParam);
		tvi.lParam = (LPARAM) NULL;
	}

	HTREEITEM hChild;
	hChild = TreeView_GetChild(hWnd, hRoot);
	int iChilds = tvi.cChildren;
	while(hChild)
	{
		DeleteAllDescStrings(hWnd, hChild);				// recursive call
		hChild = TreeView_GetNextSibling(hWnd, hChild);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tvetreegen.cpp ===
// -------------------------------------------------------------------
//   TveTreeGen.cpp
//
//		This method walks the Tve Supervisor's tree and generates
//		a graph TreeView nodes for it.  It also creates and manages
//		a pair of maps that provide access of the TreeView nodes given
//		the TVE IUnknowns, and visa versa.
//
//		This is not very optimal code - changing one node requires regenerating
//		the whole TreeView.  This should be updated.
//		
// -------------------------------------------------------------------

#include "stdafx.h"
#include "TveTreeView.h"
#include "TveTree.h"
#include <wchar.h>

#include "dbgstuff.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,       __uuidof(ITVESupervisor_Helper));

// forwards
void DeleteAllDescStrings(HWND hWnd, HTREEITEM hRoot);	
/////////////////////////////////////////////////////////////////////////////

void 
CTveTree::UpdateTree(UT_EnMode utMode, IUnknown *pUnk)
{
	TVE_EnClass enClass = (TVE_EnClass) GetTVEClass(pUnk);
	switch(utMode)
	{
	case UT_New:
	case UT_Updated:
	case UT_Deleted:
	case UT_Data:
		ClearAndFillTree();
		TVEnsureVisible(pUnk);		// make it display itself...
		UpdateView(pUnk);			// magic call to update the dialogs...
		break;
	case UT_StartStop:
	case UT_Info:
	default:
		break;
	}
}

void 
CTveTree::ClearAndFillTree()
{

	HTREEITEM hRoot;
	int cItems = TreeView_GetCount(m_ctlSysTreeView32.m_hWnd);
	if(cItems > 0) {													// if any items, clean them out...
		hRoot = TreeView_GetRoot(m_ctlSysTreeView32.m_hWnd);
		DeleteAllDescStrings(m_ctlSysTreeView32.m_hWnd, hRoot);			// delete all .lparam strings we 'newed'
		TreeView_DeleteAllItems(m_ctlSysTreeView32.m_hWnd);				// delete the entire existig tree.
	}
																	//  (could be far smarter here!)
	m_MapH2P.erase(m_MapH2P.begin(), m_MapH2P.end());			// delete the maps too... (very inefficent!)
	m_MapP2H.erase(m_MapP2H.begin(), m_MapP2H.end());			

													// create the TreeView root
	hRoot = TreeView_GetRoot(m_ctlSysTreeView32.m_hWnd);

	
	CComBSTR bstrName(L"TVE");
	CComBSTR bstrDesc;
	m_spSuper->get_Description(&bstrDesc);

	IUnknownPtr spPunk(m_spSuper);					// put TVESuper at the root...
	HTREEITEM hSuper = TVAddItem(spPunk, hRoot,bstrName, bstrDesc,  m_iImageR, m_iSelect);

	m_ctlTop.SetWindowText(_T("TVE Tree View"));	
	DumpTree(m_spSuper, hSuper, 0);					// semi-recursive call to create rest of tree
	TreeView_Expand(m_ctlSysTreeView32.m_hWnd, hSuper, TVE_EXPAND);

	m_ctlEdit.SetWindowText(_T(">"));

}



HRESULT 
CTveTree::DumpTree(ITVESupervisor *pSuper, HTREEITEM hRoot, int cTruncParent)
{
    HRESULT hr = S_OK;
    if(NULL == pSuper)
        return E_INVALIDARG;

                       // multicast manager
    ITVESupervisor_HelperPtr spSuperHelper(pSuper);
	ITVEMCastManagerPtr spMCastMng;
	hr = spSuperHelper->GetMCastManager(&spMCastMng);
	if(!FAILED(hr) && spMCastMng != NULL)
	{
        ITVEMCastsPtr spMCasts;
		spMCastMng->get_MCasts(&spMCasts);
		if(!FAILED(hr) && spMCasts != NULL)
		{
        long cItems;
			spMCasts->get_Count(&cItems);
			if(!FAILED(hr))
			{
				if(!FTruncLevel(TVE_LVL_EXPIREQUEUE)) {
					const kChars = 256;
					WCHAR wszbuff[kChars+1];
					_snwprintf(wszbuff,kChars,L"Multicast Manager");
					CComBSTR bstrName(wszbuff);
					_snwprintf (wszbuff,kChars,L"MCast Listeners - %d",cItems);
					CComBSTR bstrDesc(wszbuff);

					IUnknownPtr spPunk(spMCastMng);

					HTREEITEM hEQueue;
					hEQueue = TVAddItem(spPunk, hRoot, bstrName, bstrDesc,
										cTruncParent ? m_iImageMM_T : m_iImageMM, m_iSelect);
				}
			}
		}
	}
    
                    // service collection
    
    
    ITVEServicesPtr spServices;
	hr = pSuper->get_Services(&spServices);
	_ASSERT(!FAILED(hr));
	if(FAILED(hr))
		return hr;
               
	long cServices = 0;
	
						// non-thread safe way
	spServices->get_Count(&cServices);	

						// thread safe way...
	IUnknownPtr spEnPunk;
	hr = spServices->get__NewEnum(&spEnPunk);
	IEnumVARIANTPtr spEnVServices(spEnPunk);

	CComVariant varService;
	ULONG ulFetched;
	int cServi = 0;
	while(S_OK == spEnVServices->Next(1, &varService, &ulFetched))
		cServi++;


	hr = spEnVServices->Reset();			// reset the enumerator to the start again.
	if(FAILED(hr))
		return hr;

	int cTruncParentR = cTruncParent;
	while(S_OK == spEnVServices->Next(1, &varService, &ulFetched))
	{
		ITVEServicePtr  spService(varService.punkVal);

		CComBSTR bstrName(L"Service");
		CComBSTR bstrDesc;
		spService->get_Description(&bstrDesc);
		IUnknownPtr spPunk(spService);
	
		VARIANT_BOOL fActive;
		spService->get_IsActive(&fActive);

		HTREEITEM hService = hRoot;
		if(!FTruncLevel(TVE_LVL_SERVICE) || cServi != 1) {
			hService = TVAddItem(spPunk, hRoot, bstrDesc, bstrDesc, 
								 cTruncParentR ? 
								    (fActive ? m_iSelect_Tuned : m_iImageS_T) : 
									(fActive ? m_iSelect_Tuned : m_iImageS), 
								  fActive ? m_iSelect_Tuned : m_iSelect);
			cTruncParent = 0;
		} else {
			cTruncParent++;
		}
		DumpTree(spService, hService, cTruncParent);
		TreeView_Expand(m_ctlSysTreeView32.m_hWnd, hService, TVE_EXPAND);

		cServices++; 
	}
	return hr;
}


HRESULT 
CTveTree::DumpTree(ITVEService *pService, HTREEITEM hRoot, int cTruncParent)
{
	HRESULT hr = S_OK;

                        // expire queue

	ITVEAttrTimeQPtr spEQueue;
	hr = pService->get_ExpireQueue(&spEQueue);
	if(!FAILED(hr))
	{
		DATE dtOff;
		hr = pService->get_ExpireOffset(&dtOff);
		long cItems;
		hr = spEQueue->get_Count(&cItems);
		if(!FAILED(hr))
		{
			if(!FTruncLevel(TVE_LVL_EXPIREQUEUE)) {
				const kChars = 256;
				WCHAR wszbuff[kChars+1];
				_snwprintf(wszbuff,kChars,L"Expire Queue[%d]",cItems);
				CComBSTR bstrName(wszbuff);
				_snwprintf (wszbuff,kChars,L"%d Items, Offset of %d days %02d:%02d:%02d",
					cItems,
					int(dtOff), int(dtOff*24), int(dtOff*24*60), int(dtOff*24*60*60)
					);
				CComBSTR bstrDesc(wszbuff);

				IUnknownPtr spPunk(spEQueue);

				HTREEITEM hEQueue;
				hEQueue = TVAddItem(spPunk, hRoot, bstrName, bstrDesc,
								    cTruncParent ? m_iImageEQ_T : m_iImageEQ, m_iSelect);
			}
		}
	}
   
                    // cross over enhancement
	ITVEEnhancementPtr spXOverEnhancement;
	hr = pService->get_XOverEnhancement(&spXOverEnhancement);
	_ASSERT(!FAILED(hr));
	if(FAILED(hr))
		return hr;
	 
	{
		CComBSTR bstrName;
		CComBSTR bstrDesc;
		spXOverEnhancement->get_SessionName(&bstrName);
		spXOverEnhancement->get_Description(&bstrDesc);
		IUnknownPtr spPunk(spXOverEnhancement);

		HTREEITEM hXOverEnh = hRoot;
		int cTruncParentE = cTruncParent;
		if(!FTruncLevel(TVE_LVL_ENHANCEMENT_XOVER)) {
			hXOverEnh = TVAddItem(spPunk, hRoot, bstrName, bstrDesc,
								   cTruncParentE ? m_iImageE_T : m_iImageE, m_iSelect);
			cTruncParentE = 0;
		} else {
			cTruncParentE++;
		}

		DumpTree(spXOverEnhancement, hXOverEnh, cTruncParentE);
		TreeView_Expand(m_ctlSysTreeView32.m_hWnd, hXOverEnh, TVE_EXPAND);
	}

	ITVEEnhancementsPtr spEnhancements;
	hr = pService->get_Enhancements(&spEnhancements);
	_ASSERT(!FAILED(hr));
	if(FAILED(hr))
		return hr;
               
	long cEnhancements=0;

						// thread safe way...
	IUnknownPtr spEnPunk;
	hr = spEnhancements->get__NewEnum(&spEnPunk);
	IEnumVARIANTPtr spEnVspEnhancements(spEnPunk);
	CComVariant varspEnhancement;
	ULONG ulFetched;

	int cEnh = 0;
	while(S_OK == spEnVspEnhancements->Next(1, &varspEnhancement, &ulFetched))
		cEnh++;

	hr = spEnVspEnhancements->Reset();
	if(FAILED(hr))
		return hr;

	int cTruncParentR = cTruncParent;
	while(S_OK == spEnVspEnhancements->Next(1, &varspEnhancement, &ulFetched))
	{
		ITVEEnhancementPtr spEnhancement(varspEnhancement.punkVal);

		CComBSTR bstrName;
		CComBSTR bstrDesc;
		spEnhancement->get_SessionName(&bstrName);
		spEnhancement->get_Description(&bstrDesc);
		VARIANT_BOOL vfIsPrimary;
		spEnhancement->get_IsPrimary(&vfIsPrimary);
		BOOL fIsPrimary = (vfIsPrimary == VARIANT_TRUE);		// exactly what is a VARIANT_TRUE?

		IUnknownPtr spPunk(spEnhancement);
		HTREEITEM hEnhancement = hRoot;
		if(!FTruncLevel(TVE_LVL_ENHANCEMENT) || cEnh != 1) {
			hEnhancement = TVAddItem(spPunk, hRoot, bstrName, bstrDesc, 
									 cTruncParentR ? 
									    (fIsPrimary ? m_iImageEP : m_iImageE_T) : 
										(fIsPrimary ? m_iImageEP : m_iImageE), 
									 m_iSelect);
			cTruncParent = 0;
		} else {
			cTruncParent++;
		}
		
		DumpTree(spEnhancement, hEnhancement, cTruncParent);		// recurse down into next level
		TreeView_Expand(m_ctlSysTreeView32.m_hWnd, hEnhancement, TVE_EXPAND);

		cEnhancements++;
	}
	return hr;
}


HRESULT 
CTveTree::DumpTree(ITVEEnhancement *pEnhancement, HTREEITEM hRoot, int cTruncParent)
{
	HRESULT hr = S_OK;
	ITVEVariationsPtr spVariations;
	hr = pEnhancement->get_Variations(&spVariations);
	_ASSERT(!FAILED(hr));
	if(FAILED(hr))
		return hr;
               
	long cVariations=0;

						// thread safe way...
	IUnknownPtr spEnPunk;
	hr = spVariations->get__NewEnum(&spEnPunk);
	if(FAILED(hr)) 
		return hr;

	IEnumVARIANTPtr spEnVspVariations(spEnPunk);
	CComVariant varspVariation;
	ULONG ulFetched;

	int cVars = 0;
	while(S_OK == spEnVspVariations->Next(1, &varspVariation, &ulFetched))
		cVars++;

	hr = spEnVspVariations->Reset();
	if(FAILED(hr)) 
		return hr;	

	int cTruncParentR = cTruncParent;
	while(S_OK == spEnVspVariations->Next(1, &varspVariation, &ulFetched))
	{
		ITVEVariationPtr spVariation(varspVariation.punkVal);

		CComBSTR bstrName;
		CComBSTR bstrDesc;
		CComBSTR bstrIPFile, bstrIPTrigger;
		LONG lFilePort, lTriggerPort;

		spVariation->get_FileIPAddress(&bstrIPFile);
		spVariation->get_TriggerIPAddress(&bstrIPTrigger);

		spVariation->get_FilePort(&lFilePort);
		spVariation->get_TriggerPort(&lTriggerPort);
		
		WCHAR wBuff[256];
		swprintf(wBuff,L"File %s:%d Trigger %s:%d",bstrIPFile,lFilePort,bstrIPTrigger,lFilePort);
		spVariation->get_Description(&bstrName);

		IUnknownPtr spPunk(spVariation);

		HTREEITEM hVariation = hRoot;
		if(!FTruncLevel(TVE_LVL_VARIATION) || cVars != 1) {
			hVariation = TVAddItem(spPunk, hRoot, bstrName, wBuff, 
								cTruncParentR ? m_iImageV_T : m_iImageV, m_iSelect);
			cTruncParent = 0;
		} else {
			cTruncParent++;
		}

		DumpTree(spVariation, hVariation, cTruncParent);		// recursive dump
		TreeView_Expand(m_ctlSysTreeView32.m_hWnd, hVariation, TVE_EXPAND);

		cVariations++;
	}
	return hr;
}



HRESULT 
CTveTree::DumpTree(ITVEVariation *pVariation, HTREEITEM hRoot, int cTruncParent)
{
	HRESULT hr = S_OK;
	ITVETracksPtr spTracks;
	hr = pVariation->get_Tracks(&spTracks);
	_ASSERT(!FAILED(hr));
	if(FAILED(hr))
		return hr;
               
	long cTracks=0;

						// thread safe way...
	IUnknownPtr spEnPunk;
	hr = spTracks->get__NewEnum(&spEnPunk);
	IEnumVARIANTPtr spEnVspTracks(spEnPunk);
	CComVariant varspTrack;
	ULONG ulFetched;

	int cTrks = 0;
	while(S_OK == spEnVspTracks->Next(1, &varspTrack, &ulFetched))
		cTrks++;


	hr = spEnVspTracks->Reset();
	if(FAILED(hr))
		return hr;

	int cTruncParentR = cTruncParent;
	while(S_OK == spEnVspTracks->Next(1, &varspTrack, &ulFetched))
	{
		ITVETrackPtr spTrack(varspTrack.punkVal);

		CComBSTR bstrName;
		CComBSTR bstrDesc;
	
		ITVETriggerPtr spTrigger;		// only one trigger per track, so display it directly...
		spTrack->get_Trigger(&spTrigger);
		if(NULL != spTrigger)
		{

			spTrigger->get_Name(&bstrName);
			spTrigger->get_URL(&bstrDesc);

			IUnknownPtr spPunk(spTrigger);
			BOOL fSelTrig = (spTrigger == m_spTriggerSel);

			HTREEITEM hTrack = TVAddItem(spPunk, hRoot, bstrName, bstrDesc, 
										 fSelTrig ? m_iImageT_Tuned : m_iImageT, 
										 fSelTrig ? m_iSelect_Tuned : m_iSelect);
//			TreeView_Expand(m_ctlSysTreeView32.m_hWnd, hTrack, TVE_EXPAND);

		} else {
		//	_ASSERT(false);		// null trigger - someone stomped something...
			HTREEITEM hTrack = TVAddItem(NULL, hRoot, L"Stomped Track", L"Stomped Track", m_iImageT,m_iSelect);

		}
		cTracks++;
	}
	return hr;
}



HTREEITEM 
CTveTree::TVAddItem(IUnknown *pUnk, HTREEITEM hParent, LPWSTR strName, LPWSTR strDesc, int iImage, int iSelect)
{
	USES_CONVERSION;

	TVITEM tvi;
	tvi.mask = TVIF_TEXT;
	tvi.pszText = W2T(strName);

	// update the max size memmber
	// this member is used to creat strings large enough to hold the text for any of the itmes
	int cbSize = wcslen(strDesc) + 1;
	if(cbSize > m_cbMaxSize)
		m_cbMaxSize = cbSize;
	if(strDesc) {
		tvi.mask |= TVIF_PARAM;
		cbSize = wcslen(strDesc) + 1;
		LPTSTR newStr = new TCHAR[cbSize];  // see DeleteAllDescStrings() for how these are deleted
		lstrcpy(newStr, W2T(strDesc));
		tvi.lParam = (LPARAM) newStr;
	}

	if(iImage != -1) {
		tvi.mask |= TVIF_IMAGE;				// image label is valid
		tvi.iImage = iImage;
	}

	if(iSelect != -1) {
		tvi.mask |= TVIF_SELECTEDIMAGE;		// selected image labl is valid	
		tvi.iSelectedImage = iSelect;
	}

/*	if(iOverlay != -1) {
		tvi.mask |= TVIF_OVERLAYMASK ;		// selected image labl is valid	
		tvi.iOverlayImage = iOverlay;
	}
*/


	TVINSERTSTRUCT tvins;
	tvins.item = tvi;
	tvins.hInsertAfter = TVI_LAST;
	tvins.hParent = hParent;

	HTREEITEM hItem = TreeView_InsertItem(m_ctlSysTreeView32.m_hWnd, &tvins);

	IUnknownPtr spPunk(pUnk);		// make sure it's really an IUnknown pointer..
	if(spPunk) {
		m_MapP2H[spPunk] = hItem;
		m_MapH2P[hItem]  = spPunk;
	} else {
		m_MapH2P[hItem] = NULL;			// this wouuld be bad...
	}

	return hItem;


}


void 
CTveTree::TVEnsureVisible(IUnknown *pUnk)		// makes a TVE Class visible in the tree view
{
	IUnknownPtr spPunk(pUnk);		// make sure it's really an IUnknown pointer..
	HTREEITEM hItem = m_MapP2H[pUnk];
	if(hItem)
		TreeView_EnsureVisible(m_ctlSysTreeView32.m_hWnd, hItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tvetree.h ===
// TveTree.h : Declaration of the CTveTree

#ifndef __TVETREE_H_
#define __TVETREE_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <commctrl.h>

//#include "MSTvE.h"

#include "TveTreeView.h"
#include "TveTreePP.h"


#include <map>			// STL associated container
#include "TveTreeViewCP.h"

//#import "..\..\MSTvE\$(O)\MSTve.dll" named_guids, raw_interfaces_only 
		// this one for BUILD
#import "..\..\MSTvE\objd\i386\MSTve.dll" named_guids, raw_interfaces_only 
		// this one for building in the IDE... 
//#import "..\..\MSTvE\debug\MSTve.dll" named_guids, raw_interfaces_only 



_COM_SMARTPTR_TYPEDEF(ITVESupervisor,           __uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVEServices,				__uuidof(ITVEServices));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancements,			__uuidof(ITVEEnhancements));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEVariations,			__uuidof(ITVEVariations));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVETracks,				__uuidof(ITVETracks));
_COM_SMARTPTR_TYPEDEF(ITVETrack,				__uuidof(ITVETrack));
_COM_SMARTPTR_TYPEDEF(ITVETrigger,				__uuidof(ITVETrigger));
_COM_SMARTPTR_TYPEDEF(ITVEFile,					__uuidof(ITVEFile));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager,	   	    __uuidof(ITVEMCastManager));
_COM_SMARTPTR_TYPEDEF(ITVEMCast,	    	    __uuidof(ITVEMCast));
_COM_SMARTPTR_TYPEDEF(ITVEMCasts,	    	    __uuidof(ITVEMCasts));

_COM_SMARTPTR_TYPEDEF(ITVEAttrMap,				__uuidof(ITVEAttrMap));
_COM_SMARTPTR_TYPEDEF(ITVEAttrTimeQ,			__uuidof(ITVEAttrTimeQ));


_COM_SMARTPTR_TYPEDEF(ITVEViewSupervisor,       __uuidof(ITVEViewSupervisor));
_COM_SMARTPTR_TYPEDEF(ITVEViewService,			__uuidof(ITVEViewService));
_COM_SMARTPTR_TYPEDEF(ITVEViewEnhancement,		__uuidof(ITVEViewEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEViewVariation,		__uuidof(ITVEViewVariation));
_COM_SMARTPTR_TYPEDEF(ITVEViewTrack,			__uuidof(ITVEViewTrack));
_COM_SMARTPTR_TYPEDEF(ITVEViewTrigger,			__uuidof(ITVEViewTrigger));
_COM_SMARTPTR_TYPEDEF(ITVEViewEQueue,			__uuidof(ITVEViewEQueue));
_COM_SMARTPTR_TYPEDEF(ITVEViewFile,				__uuidof(ITVEViewFile));
_COM_SMARTPTR_TYPEDEF(ITVEViewMCastManager,		__uuidof(ITVEViewMCastManager));

_COM_SMARTPTR_TYPEDEF(ITveTree,					__uuidof(ITveTree));

///----------------------------
//	bogus params for get_IPAdapterAddresses() method
const int kWsz32Size = 32;
const int kcMaxIpAdapts = 10;
typedef WCHAR Wsz32[kWsz32Size];		// simple fixed length string class for IP adapters


typedef enum TVE_EnClass {			// To convert IUnknown* to particular types...
	TVE_EnUnknown = -1,
	TVE_EnSupervisor = 0,
	TVE_EnService,
	TVE_EnEnhancement,
	TVE_EnVariation,	
	TVE_EnTrack,		
	TVE_EnTrigger,
	TVE_EnEQueue,
	TVE_EnFile,
	TVE_EnMCastManager,
	TVE_EnMCast
} TVE_EnClass;

extern TVE_EnClass	GetTVEClass(IUnknown *pUnk);

/////////////////////////////////////////////////////////////////////////////
// CTveTree
class ATL_NO_VTABLE CTveTree : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ITveTree, &IID_ITveTree, &LIBID_TveTreeViewLib>,
	public CComControl<CTveTree>,
	public IPersistStreamInitImpl<CTveTree>,
	public IOleControlImpl<CTveTree>,
	public IOleObjectImpl<CTveTree>,
	public IOleInPlaceActiveObjectImpl<CTveTree>,
	public IViewObjectExImpl<CTveTree>,
	public IOleInPlaceObjectWindowlessImpl<CTveTree>,
	public IPersistStorageImpl<CTveTree>,
	public ISpecifyPropertyPagesImpl<CTveTree>,
	public IQuickActivateImpl<CTveTree>,
	public IDataObjectImpl<CTveTree>,
	public IProvideClassInfo2Impl<&CLSID_TveTree, NULL, &LIBID_TveTreeViewLib>,
	public IObjectSafetyImpl<CTveTree, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,					// SO IE can deal with it
	public CComCoClass<CTveTree, &CLSID_TveTree>,
	public CProxy_ITVETreeEvents< CTveTree >,
	public IConnectionPointContainerImpl<CTveTree>
{
public:
	CContainedWindow m_ctlTop;
	CContainedWindow m_ctlSysTreeView32;
	CContainedWindow m_ctlEdit;
	

	CTveTree() :	
		m_ctlTop(_T("Edit"), this, 1),
		m_ctlSysTreeView32(_T("SysTreeView32"), this, 2),
		m_ctlEdit(_T("Edit"), this, 3)
	{
		m_bWindowOnly = TRUE;
		m_tmHeight = 0;
		m_dwTveEventsAdviseCookie = 0;

		m_hImageList = NULL;
		m_iImageR = -1; m_iImageS = -1; m_iImageE = -1; m_iImageV = -1; m_iImageT  = -1; m_iImageMM = -1; m_iImageEQ  = -1; 
		m_iImageR_T = -1; m_iImageS_T = -1; m_iImageE_T = -1; m_iImageV_T = -1; m_iImageT_T  = -1; m_iImageMM_T = -1; m_iImageEQ_T  = -1;
		m_iImageT_Tuned  = -1, m_iSelect_Tuned = -1; m_iImageEP = -1;

		m_iSelect = -1;
		m_cbMaxSize = 256;		// Default Desc Size

		m_grfTruncatedLevels = 0; //TVE_LVL_VARIATION | TVE_LVL_ENHANCEMENT_XOVER;	
		
		m_pdlgTveTreePP = NULL;
	}

	~CTveTree() 
	{
		m_spTriggerSel	= NULL;
		m_spSuper		= NULL;			// null here to force dealloc, easier to find leaks
		if(NULL != m_pdlgTveTreePP) {
			if(m_pdlgTveTreePP->m_hWnd)
				m_pdlgTveTreePP->DestroyWindow();
			delete m_pdlgTveTreePP;
			m_pdlgTveTreePP = NULL;
		}
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVETREE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTveTree)
	COM_INTERFACE_ENTRY(ITveTree)
//	COM_INTERFACE_ENTRY(IDispatch)
	                // magic lines of code, support _ITVEEvents as IDispatch...
	COM_INTERFACE_ENTRY2(IDispatch, ITveTree)
	COM_INTERFACE_ENTRY_IID(__uuidof(_ITVEEvents), IDispatch) // DIID__ITVEEvents, IDispatch)	

	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IObjectSafety)			// (see pg 445 Grimes: Professional ATL Com programming)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CATEGORY_MAP(CCAResDenialTree)			// (see ATL Com Programmer's Reference, pg 130)
	IMPLEMENTED_CATEGORY(CATID_Insertable)
	IMPLEMENTED_CATEGORY(CATID_Control)
END_CATEGORY_MAP()

BEGIN_PROP_MAP(CTveTree)
	PROP_PAGE(CLSID_TveTreePP)
//	PROP_ENTRY("GrfTrunc", 2, CLSID_TveTreePP)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
END_PROP_MAP()

BEGIN_MSG_MAP(CTveTree)
	MESSAGE_HANDLER(WM_CREATE,				OnCreate)
	MESSAGE_HANDLER(WM_CLOSE,				OnClose)
	MESSAGE_HANDLER(WM_DESTROY,				OnDestroy)
    MESSAGE_HANDLER(WM_SIZE,				OnSize)
	NOTIFY_CODE_HANDLER(TVN_SELCHANGED,		OnSelChanged)
	MESSAGE_HANDLER(WM_SETFOCUS,			OnSetFocus)
	MESSAGE_HANDLER(LB_GRFTRUNC_CHANGED,	OnGrfTruncChanged)

	CHAIN_MSG_MAP(CComControl<CTveTree>)

	//  message map entries for superclassed Edit Box
  ALT_MSG_MAP(1)

	//  message map entries for superclassed SysTreeView32
  ALT_MSG_MAP(2)
	MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDblClk)
	MESSAGE_HANDLER(WM_RBUTTONDOWN,   OnRButtonDown)
	MESSAGE_HANDLER(WM_RBUTTONDBLCLK, OnRButtonDblClk)  
 	//  message map entries for superclassed Edit Box  (Watch it, class wizard puts stuff here...)
 ALT_MSG_MAP(3)

END_MSG_MAP()

BEGIN_CONNECTION_POINT_MAP(CTveTree)
	CONNECTION_POINT_ENTRY(DIID__ITVETreeEvents)
END_CONNECTION_POINT_MAP()

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hRet);
	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
	STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip);
	LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
	LRESULT OnGrfTruncChanged(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClose(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
    LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);

	LRESULT OnSelChanged(int idCtrl, LPNMHDR pnmh, BOOL &bHandled);
	LRESULT OnLButtonDblClk(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
	LRESULT OnRButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
	LRESULT OnRButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

// IViewObjectEx
	DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// ITveTree
public:
	HRESULT FinalConstruct();
	HRESULT InPlaceActivate(LONG iVerb, const RECT *prcPosRect);

	void FinalRelease();
	HRESULT OnDraw(ATL_DRAWINFO& di);


	HRESULT AddToTop(TCHAR *tbuff);
	HRESULT AddToOutput(TCHAR *tbuff);

	STDMETHOD(get_TVENode)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_TVENode)(/*[in]*/ VARIANT newVal);

	STDMETHOD(get_GrfTrunc)(/*[out, retval]*/ int *pVal);
	STDMETHOD(put_GrfTrunc)(/*[in]*/ int newVal);

	STDMETHOD(get_Supervisor)(ITVESupervisor **ppTVESuper);
	STDMETHOD(UpdateView)(/*[in]*/ IUnknown *pUnk);					// updates one of the view windows
	STDMETHOD(UpdateTree)(/*[in]*/ IUnknown *pUnk);					// updates the treeview

	// _ITVEEvents
	STDMETHOD(NotifyTVETune)(/*[in]*/ NTUN_Mode tuneMode,/*[in]*/ ITVEService *pService,/*[in]*/ BSTR bstrDescription,/*[in]*/ BSTR bstrIPAdapter);
	STDMETHOD(NotifyTVEEnhancementNew)(/*[in]*/ ITVEEnhancement *pEnh);
		// changedFlags : NENH_grfDiff
	STDMETHOD(NotifyTVEEnhancementUpdated)(/*[in]*/ ITVEEnhancement *pEnh, /*[in]*/ long lChangedFlags);	
	STDMETHOD(NotifyTVEEnhancementStarting)(/*[in]*/ ITVEEnhancement *pEnh);
	STDMETHOD(NotifyTVEEnhancementExpired)(/*[in]*/ ITVEEnhancement *pEnh);
	STDMETHOD(NotifyTVETriggerNew)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive);
		// changedFlags : NTRK_grfDiff
	STDMETHOD(NotifyTVETriggerUpdated)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive, /*[in]*/ long lChangedFlags);	
	STDMETHOD(NotifyTVETriggerExpired)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive);
	STDMETHOD(NotifyTVEPackage)(/*[in]*/ NPKG_Mode engPkgMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUUID, /*[in]*/ long  cBytesTotal, /*[in]*/ long  cBytesReceived);
	STDMETHOD(NotifyTVEFile)(/*[in]*/ NFLE_Mode engFileMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUrlName, /*[in]*/ BSTR bstrFileName);
		// WhatIsIt is NWHAT_Mode - lChangedFlags is NENH_grfDiff or NTRK_grfDiff treated as error bits
	STDMETHOD(NotifyTVEAuxInfo)(/*[in]*/ NWHAT_Mode enAuxInfoMode, /*[in]*/ BSTR bstrAuxInfoString, /*[in]*/ long lChangedFlags, /*[in]*/ long lErrorLine);	

// ---------------

	HRESULT DumpTree(ITVESupervisor  *pSuper,		HTREEITEM hRoot, int cTruncParent=0);
	HRESULT DumpTree(ITVEService     *pService,	HTREEITEM hRoot, int cTruncParent=0);
	HRESULT DumpTree(ITVEEnhancement *pEnhancement,HTREEITEM hRoot, int cTruncParent=0);
	HRESULT DumpTree(ITVEVariation   *pVariation,	HTREEITEM hRoot, int cTruncParent=0);

	typedef enum TVE_LEVEL_ENUM 
	{
		TVE_LVL_MCAST   			= 0x400,
		TVE_LVL_MCASTMANGER			= 0x200,
		TVE_LVL_EXPIREQUEUE			= 0x100,
		TVE_LVL_ENHANCEMENT_XOVER	= 0x80,
		TVE_LVL_SUPERVISOR			= 0x20,
		TVE_LVL_SERVICE				= 0x10,
		TVE_LVL_ENHANCEMENT			= 0x08,
		TVE_LVL_VARIATION			= 0x04,
		TVE_LVL_TRACK				= 0x02,
		TVE_LVL_TRIGGER				= 0x01
	};

	BOOL	FTruncLevel(ULONG grfLevel)		{return (0 != (m_grfTruncatedLevels & grfLevel));}


	// ISpecifyPropertyPages	  --------------------------------------------

//   STDMETHOD(GetPages)(CAUUID * pPages) ;

public:


private:	
	enum UT_EnMode {			// change modes for UpdateTree
		UT_New,
		UT_Updated,
		UT_Deleted,
		UT_Data,				// new data - doesn't effect treeview
		UT_Info,				// some informative message, doesn't effect treeview
		UT_StartStop,			// something starting/stoping, doesn't effect treeview
	};



	typedef std::map<HTREEITEM, IUnknown *>	MapT_H2P;
	MapT_H2P									m_MapH2P;

	typedef std::map<IUnknown *, HTREEITEM >	MapT_P2H;
	MapT_P2H									m_MapP2H;

	ITVESupervisorPtr		m_spSuper;					// main supervisor object being displayed
	DWORD								m_dwTveEventsAdviseCookie;	// AtlAdvise cookie to use in AtlUnadvise

	int m_tmHeight;
									// creates node in the treeview and association in the map
	HTREEITEM TVAddItem(IUnknown * pUnk, HTREEITEM hParent, LPWSTR strName, LPWSTR strDesc, int iImage=-1, int iSelect=-1);

									// uses map association to make given TVE node visible
	void TVEnsureVisible(IUnknown *pUnk);

									// update smallest part of tree possible
	void UpdateTree(UT_EnMode utMode, IUnknown *pUnk);

	void ClearAndFillTree();		// drastic - start over from scratch.

	HIMAGELIST m_hImageList;		// array of bitmaps used in the U/I
	int m_iImageR;					//   indexes into the above array for particular images
	int m_iImageS;
	int m_iImageE;
	int m_iImageEP;					// primary enhancement
	int m_iImageV;
	int m_iImageT;
	int m_iImageMM;                 // Multicast Manager                           
	int m_iImageEQ;
	int m_iImageR_T;				//   indexes into the above array for particular images
	int m_iImageS_T;
	int m_iImageE_T;
	int m_iImageV_T;
	int m_iImageT_T;
	int m_iImageMM_T;               // Multicast Manager                           
	int m_iImageT_Tuned;
	int	m_iSelect_Tuned;
	int m_iImageEQ_T;
	int m_iSelect;
	int m_cbMaxSize;

	BOOL	m_grfTruncatedLevels;

	CComBSTR m_bstrPersistFile;
	CComBSTR m_spbsIPAdapterAddr;
	HRESULT CTveTree::get_IPAdapterAddresses(/*[out]*/ int *pcAdaptersUniDi, /*[out]*/ int *pcAdaptersBiDi, /*[out]*/ Wsz32 **rgAdapters);
	HRESULT ReadAdapterFromFile();


	ITVETriggerPtr			m_spTriggerSel;

// --- property page and view dialogs
	CTveTreePP		*m_pdlgTveTreePP;

	ITVEViewSupervisorPtr	m_spTVEViewSupervisor;
	ITVEViewServicePtr		m_spTVEViewService;
	ITVEViewEnhancementPtr	m_spTVEViewEnhancement;
	ITVEViewVariationPtr	m_spTVEViewVariation;
	ITVEViewTrackPtr		m_spTVEViewTrack;
	ITVEViewTriggerPtr		m_spTVEViewTrigger;
	ITVEViewEQueuePtr		m_spTVEViewEQueue;
	ITVEViewFilePtr			m_spTVEViewFile;
	ITVEViewMCastManagerPtr	m_spTVEViewMCastManager;

public :



};

#endif //__TVETREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tvetreeppage.cpp ===
// TveTreePPage.cpp : Implementation of CTveTreePPage
#include "stdafx.h"
#include "TveTreeView.h"
#include "TveTreePPage.h"

/////////////////////////////////////////////////////////////////////////////
// CTveTreePPage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tvetreepp.cpp ===
// TveTreePP.cpp : Implementation of CTveTreePP
#include "stdafx.h"
#include "TveTree.h"
#include "TveTreeView.h"
#include "TveTreePP.h"

/////////////////////////////////////////////////////////////////////////////
// CTveTreePP

STDMETHODIMP 
CTveTreePP::Apply(void)
{ 
	ATLTRACE(_T("CTveTreePP::Apply\n"));
	for (UINT i = 0; i < m_nObjects; i++)
	{
		// Do something interesting here
		CComPtr<ITveTree> spTveTree;
		HRESULT hr = m_ppUnk[i]->QueryInterface(IID_ITveTree, reinterpret_cast<void**>(&spTveTree));
		if(!FAILED(hr)) {
			spTveTree->put_GrfTrunc(m_grfTruncLevel);
		}
	}
	m_bDirty = FALSE;
	m_grfTruncLevelInitial = m_grfTruncLevel;
	return S_OK;
}

LRESULT 
CTveTreePP::OnClickedResetEventCounts(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)

{ 
	ATLTRACE(_T("CTveTreePP::OnClickedResetEventCounts\n"));
	for (UINT i = 0; i < m_nObjects; i++)
	{
		// Do something interesting here
		CComPtr<ITveTree> spTveTree;
		HRESULT hr = m_ppUnk[i]->QueryInterface(IID_ITveTree, reinterpret_cast<void**>(&spTveTree));
		if(!FAILED(hr)) {
			ITVESupervisorPtr spSuper;
			hr = spTveTree->get_Supervisor(&spSuper);
			if(!FAILED(hr) && NULL != spSuper)
			{
				spSuper->InitStats();
				IUnknownPtr spSuperPunk(spSuper);
				spTveTree->UpdateView(spSuperPunk);
			}
		}
	}
	m_bDirty = FALSE;
	m_grfTruncLevelInitial = m_grfTruncLevel;
	return S_OK;
}


LRESULT 
CTveTreePP::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	ATLTRACE(_T("CTveTreePP::OnDestroy\n"));
	// TODO : Add Code for message handler. Call DefWindowProc if necessary.
	return 0;
}
LRESULT 
CTveTreePP::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{ 
	ATLTRACE(_T("CTveTreePP::OnInitDialog\n"));
    CComPtr<ITveTree> spTveTree;
	HRESULT hr = m_ppUnk[0]->QueryInterface(IID_ITveTree, reinterpret_cast<void**>(&spTveTree));
	if(FAILED(hr))
	   return 1;

	int grfTrunc;
	hr = spTveTree->get_GrfTrunc(&grfTrunc);

	m_grfTruncLevel = grfTrunc;
	m_grfTruncLevelInitial = grfTrunc;
	UpdateTruncButtons();

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tvetreeppage.h ===
// TveTreePPage.h : Declaration of the CTveTreePPage

#ifndef __TVETREEPPAGE_H_
#define __TVETREEPPAGE_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_TveTreePPage;

/////////////////////////////////////////////////////////////////////////////
// CTveTreePPage
class ATL_NO_VTABLE CTveTreePPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTveTreePPage, &CLSID_TveTreePPage>,
	public IPropertyPageImpl<CTveTreePPage>,
	public CDialogImpl<CTveTreePPage>
{
public:
	CTveTreePPage() 
	{
		m_dwTitleID = IDS_TITLETveTreePPage;
		m_dwHelpFileID = IDS_HELPFILETveTreePPage;
		m_dwDocStringID = IDS_DOCSTRINGTveTreePPage;
	}

	enum {IDD = IDD_TVETREEPPAGE};

DECLARE_REGISTRY_RESOURCEID(IDR_TVETREEPPAGE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTveTreePPage) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CTveTreePPage)
	CHAIN_MSG_MAP(IPropertyPageImpl<CTveTreePPage>)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	STDMETHOD(Apply)(void)
	{
		ATLTRACE(_T("CTveTreePPage::Apply\n"));
		for (UINT i = 0; i < m_nObjects; i++)
		{
			// Do something interesting here
			// ICircCtl* pCirc;
			// m_ppUnk[i]->QueryInterface(IID_ICircCtl, (void**)&pCirc);
			// pCirc->put_Caption(CComBSTR("something special"));
			// pCirc->Release();
		}
		m_bDirty = FALSE;
		return S_OK;
	}
};

#endif //__TVETREEPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tvetreepp.h ===
// TveTreePP.h : Declaration of the CTveTreePP

#ifndef __TVETREEPP_H_
#define __TVETREEPP_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_TveTreePP;

/////////////////////////////////////////////////////////////////////////////
// CTveTreePP
class ATL_NO_VTABLE CTveTreePP :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTveTreePP, &CLSID_TveTreePP>,
	public IPropertyPageImpl<CTveTreePP>,
	public CDialogImpl<CTveTreePP>
{
public:

	CTveTreePP() 
	{
		m_grfTruncLevel = 0;
		m_hParent = NULL;
		m_dwTitleID = IDS_TITLETveTreePP;
		m_dwHelpFileID = IDS_HELPFILETveTreePP;
		m_dwDocStringID = IDS_DOCSTRINGTveTreePP;

	}
	
	void SetParentHWnd(HWND &hWnd)
	{
		m_hParent = hWnd;
	}


	enum {IDD = IDD_TVETREEPP};

DECLARE_REGISTRY_RESOURCEID(IDR_TVETREEPP)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTveTreePP) 
	COM_INTERFACE_ENTRY(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CTveTreePP)
	CHAIN_MSG_MAP(IPropertyPageImpl<CTveTreePP>)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_HANDLER(IDC_TRUNC_E,  BN_CLICKED, OnClickedTrunc_E)
	COMMAND_HANDLER(IDC_TRUNC_S,  BN_CLICKED, OnClickedTrunc_S)
	COMMAND_HANDLER(IDC_TRUNC_T,  BN_CLICKED, OnClickedTrunc_T)
	COMMAND_HANDLER(IDC_TRUNC_V,  BN_CLICKED, OnClickedTrunc_V)
	COMMAND_HANDLER(IDC_TRUNC_X,  BN_CLICKED, OnClickedTrunc_X)
	COMMAND_HANDLER(IDC_TRUNC_EQ, BN_CLICKED, OnClickedTrunc_EQ)
	COMMAND_HANDLER(IDC_RESETCOUNTS, BN_CLICKED, OnClickedResetEventCounts)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	typedef enum TVE_LEVEL_ENUM 
	{
		TVE_LVL_EXPIREQUEUE			= 0x100,
		TVE_LVL_ENHANCEMENT_XOVER	= 0x80,
		TVE_LVL_SUPERVISOR			= 0x20,
		TVE_LVL_SERVICE				= 0x10,
		TVE_LVL_ENHANCEMENT			= 0x08,
		TVE_LVL_VARIATION			= 0x04,
		TVE_LVL_TRACK				= 0x02,
		TVE_LVL_TRIGGER				= 0x01
	};

	STDMETHOD(Apply)(void);
	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

	void UpdateTruncButtons()
	{
		CheckDlgButton(IDC_TRUNC_S,  (m_grfTruncLevel & TVE_LVL_SERVICE) ? BST_CHECKED : BST_UNCHECKED);
		CheckDlgButton(IDC_TRUNC_E,  (m_grfTruncLevel & TVE_LVL_ENHANCEMENT) ? BST_CHECKED : BST_UNCHECKED);
		CheckDlgButton(IDC_TRUNC_V,  (m_grfTruncLevel & TVE_LVL_VARIATION) ? BST_CHECKED : BST_UNCHECKED);
		CheckDlgButton(IDC_TRUNC_T,  (m_grfTruncLevel & TVE_LVL_TRACK) ? BST_CHECKED : BST_UNCHECKED);
		CheckDlgButton(IDC_TRUNC_X,  (m_grfTruncLevel & TVE_LVL_ENHANCEMENT_XOVER) ? BST_CHECKED : BST_UNCHECKED);
		CheckDlgButton(IDC_TRUNC_EQ, (m_grfTruncLevel & TVE_LVL_EXPIREQUEUE) ? BST_CHECKED : BST_UNCHECKED);
		long grfTruncLevelInitial = m_grfTruncLevelInitial;
		Apply();
		m_grfTruncLevelInitial = grfTruncLevelInitial;
		SetDirty(m_grfTruncLevel != m_grfTruncLevelInitial);	// cant seem to unset APPLY button this way (math right however)
	}

	LRESULT OnClickedResetEventCounts(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

#define SetOrClearGRF(grf,bitfield,flag) \
	if(flag) grf |= (bitfield); else grf &= ~(bitfield);

	LRESULT OnClickedTrunc_S(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		BOOL fIsChecked = IsDlgButtonChecked(IDC_TRUNC_S);
		SetOrClearGRF(m_grfTruncLevel, TVE_LVL_SERVICE, !fIsChecked);
		UpdateTruncButtons();
		return 0;
	}
	LRESULT OnClickedTrunc_E(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		BOOL fIsChecked = IsDlgButtonChecked(IDC_TRUNC_E);
		SetOrClearGRF(m_grfTruncLevel, TVE_LVL_ENHANCEMENT, !fIsChecked);
		UpdateTruncButtons();
		return 0;
	}
	LRESULT OnClickedTrunc_T(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		BOOL fIsChecked = IsDlgButtonChecked(IDC_TRUNC_T);
		SetOrClearGRF(m_grfTruncLevel, TVE_LVL_TRACK, !fIsChecked);
		UpdateTruncButtons();
		return 0;
	}
	LRESULT OnClickedTrunc_V(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		BOOL fIsChecked = IsDlgButtonChecked(IDC_TRUNC_V);
		SetOrClearGRF(m_grfTruncLevel, TVE_LVL_VARIATION, !fIsChecked);
		UpdateTruncButtons();
		return 0;
	}
	LRESULT OnClickedTrunc_X(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		BOOL fIsChecked = IsDlgButtonChecked(IDC_TRUNC_X);
		SetOrClearGRF(m_grfTruncLevel, TVE_LVL_ENHANCEMENT_XOVER, !fIsChecked);
		UpdateTruncButtons();
		return 0;
	}

	LRESULT OnClickedTrunc_EQ(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
	{
		BOOL fIsChecked = IsDlgButtonChecked(IDC_TRUNC_EQ);
		SetOrClearGRF(m_grfTruncLevel, TVE_LVL_EXPIREQUEUE, !fIsChecked);
		UpdateTruncButtons();
		return 0;
	}

private:
	HWND m_hParent;				// parent window (TVETreeControl)
	long m_grfTruncLevel;
	long m_grfTruncLevelInitial;
};

#endif //__TVETREEPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewequeue.cpp ===
// TVEViewEQueue.cpp : Implementation of CTVEViewEQueue
#include "stdafx.h"
#include "TVEViewEQueue.h"
#include "TveTree.h"

#include "isotime.h"

_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,			__uuidof(ITVEService_Helper));

// -------------------------------------------------------------------------

static DATE DateNow()
{
	SYSTEMTIME SysTimeNow;
	GetSystemTime(&SysTimeNow);									// initialize with currrent time.
	DATE dateNow;
	SystemTimeToVariantTime(&SysTimeNow, &dateNow);
	return dateNow;
}
/////////////////////////////////////////////////////////////////////////////
// CTVEViewEQueue

// ---------------------------------
LRESULT 
CTVEViewEQueue::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 1;  // Let the system set the focus
}

LRESULT 
CTVEViewEQueue::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

LRESULT 
CTVEViewEQueue::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

STDMETHODIMP 
CTVEViewEQueue::get_Visible(/*[out, retval]*/ VARIANT_BOOL *pfVisible)
{
	HRESULT hr = S_OK;
	*pfVisible = IsVisible();
	return hr;
}

STDMETHODIMP				// see Beginning ATL COM programming, page 136
CTVEViewEQueue::put_Visible(/*[in]*/ VARIANT_BOOL fVisible)
{
	HRESULT hr = S_OK;
	if(fVisible == IsVisible())			// nothing changed...
	{
		if(IsIconic())
			ShowWindow(SW_SHOWNORMAL);
		if(fVisible) {
			BringWindowToTop();
			if(IsDirty())
				UpdateFields();
		}
		return S_OK;
	}

	// Show or hide the window
	ShowWindow(fVisible ? SW_SHOW : SW_HIDE);


	if(IsVisible())
		UpdateFields();

	// now AddRef() or Release the object... This is ref-count for interactive user
	if(fVisible)
		GetUnknown()->AddRef();
	else
		GetUnknown()->Release();

	// don't do anything after this Release() call, could of deleted the object...

	return hr;
}

extern void DateToBSTR2(DATE date, BSTR *pbstrOut);

HRESULT 
DescribePUnk(IUnknown *pUnk, TVE_EnClass *penClass, BSTR *pbsClass, BSTR *pbsDesc)
{
	TVE_EnClass enClass = GetTVEClass(pUnk);
	if(*penClass) *penClass = enClass;

	CComBSTR bsClass;
	CComBSTR bsDesc;

	try {
		switch(enClass) {
		case TVE_EnSupervisor:
			{
				ITVESupervisorPtr spSupervisor(pUnk);
				if(spSupervisor)
				{
					bsClass = L"Supervisor";
					spSupervisor->get_Description(&bsDesc);
				}
			}
			break;
		case TVE_EnService:
			{
				ITVEServicePtr spService(pUnk);
				if(spService)
				{
					bsClass = L"Service";
					spService->get_Description(&bsDesc);
				}
			}
			break;
		case TVE_EnEnhancement:
			{
				ITVEEnhancementPtr spEnhancement(pUnk);
				if(spEnhancement)
				{
					bsClass = L"Enhancement";
					spEnhancement->get_Description(&bsDesc);
				}
			}
			break;
		case TVE_EnVariation:
			{
				ITVEVariationPtr spVariation(pUnk);
				if(spVariation)
				{
					bsClass = L"Variation";
					spVariation->get_Description(&bsDesc);
				}
			}
			break;
		case TVE_EnTrack:
			{
				ITVETrackPtr spTrack(pUnk);
				if(spTrack)
				{
					bsClass = L"Track";
					spTrack->get_Description(&bsDesc);
				}
			}
			break;
		case TVE_EnTrigger:
			{
				ITVETriggerPtr spTrigger(pUnk);
				if(spTrigger)
				{
					bsClass = L"Trigger";
					spTrigger->get_Name(&bsDesc);
				}
			}
			break;
		case TVE_EnFile:
			{
				ITVEFilePtr spFile(pUnk);
				if(spFile)
				{
					BOOL fPackage;
					spFile->get_IsPackage(&fPackage);
					if(fPackage)
						bsClass = L"Package";
					else
						bsClass = L"File";
					spFile->get_Description(&bsDesc);
				}
			}
			break;
		case TVE_EnEQueue:
			{
				ITVEAttrTimeQPtr spEQueue(pUnk);
				if(spEQueue)
				{
					bsClass = L"ExpireQueue";
					bsDesc = L"Expire Queue";
				}
			}
			break;
		case TVE_EnUnknown:
		default:
			bsClass = L"<Unknown>";
			bsDesc = L"<Unknown>";
			break;
		} // end switch
	}
	catch (...)
	{
		// something bad happened
	}

	bsClass.CopyTo(pbsClass);
	bsDesc.CopyTo(pbsDesc);

	return S_OK;
}

STDMETHODIMP				
CTVEViewEQueue::UpdateFields()
{
	if(NULL == m_spEQueue)
		return S_FALSE;

	USES_CONVERSION;
	int id = 0;	
	
	try {


		WCHAR wbuff[256];	
		CComBSTR spBstr;
		DATE dOffset;

		long cItems;
		m_spEQueue->get_Count(&cItems);


						// thread safe way...
/*		IUnknownPtr spEnPunk;
		hr = m_spEQueue->get__NewEnum(&spEnPunk);
		IEnumVARIANTPtr spEnVEQueue(spEnPunk);

		CComVariant varTimeQ;
		ULONG ulFetched;
		cItems = 0;
		while(S_OK == spEnVEQueue->Next(1, &varTimeQ, &ulFetched))
			cItems++;

		hr = spEnVEQueue->Reset();			// reset the enumerator to the start again.
*/
		_snwprintf(wbuff, 255,L"%d", cItems); 
		SetDlgItemText( IDC_EQ_ITEMS, W2T(wbuff)); 
	
		long dwChangeCount = 0;
		if(m_spService) {
			m_spService->get_ExpireOffset(&dOffset);		// don't know how to get service yet
			ITVEService_HelperPtr spSH(m_spService);
			if(spSH)
				spSH->get_ExpireQueueChangeCount(&dwChangeCount);		// don't know how to get service yet
		} else {
			dOffset = 0;
		}

		SetDlgItemInt(IDC_EQ_CHANGECOUNT, (int) dwChangeCount, false); 

		//DateToDiffBSTR(dOffset + DateNow() ,&spBstr);
		_snwprintf(wbuff, 255,L"%6.3f days (%d hr %d min %d sec)", dOffset, int(dOffset*24)%24, int(dOffset*24*60)%60, int(dOffset*24*60*60)%60); 
		SetDlgItemText( IDC_EQ_OFFSET,W2T(wbuff)); 		

				// Gee. My first functioning C-based list box.  See "List Box Messages" deep under "Platform SDK" for docs
		HWND hLBox = GetDlgItem(IDC_EQ_LIST);
		SendMessage(hLBox, LB_RESETCONTENT, 0, 0);				// clear previous items

					
		int rgTabStops[] = {4, 14, 20, 30, 28};	// tabstops as sizes
		int kTabStops = sizeof(rgTabStops) / sizeof(rgTabStops[0]);
		int sum = 0;
		for(int i = 0; i < kTabStops; i++)		// integrate...
		{
			sum += rgTabStops[i];
			rgTabStops[i] = sum;
		}

		SendMessage(hLBox, LB_SETTABSTOPS, (WPARAM) kTabStops, (LPARAM) rgTabStops);				// clear previous items

		int iItem = 0;
		for( iItem=0; iItem < cItems; iItem++)
		{
			CComVariant cvItem(iItem);
			DATE dateExpires;
			IUnknownPtr spPunk;
			m_spEQueue->get_Key(cvItem,  &dateExpires);
			m_spEQueue->get_Item(cvItem, &spPunk);

			CComBSTR bsExpires = DateToBSTR(dateExpires + dOffset);
			TVE_EnClass enClass;
			CComBSTR bsClass, bsDesc;

			DescribePUnk(spPunk, &enClass, &bsClass, &bsDesc);

			_snwprintf(wbuff, 255,L"%3d: \t0x%08x \t%12s \t%32s \t%32s", iItem, spPunk, bsClass, bsExpires, bsDesc); 
			SendMessage(hLBox, LB_ADDSTRING,       0, (LPARAM) W2T(wbuff)); 
			SendMessage(hLBox, LB_SETITEMDATA, iItem, (LPARAM) spPunk); 
		}

		SetDirty(false);
	}
	catch(...)
	{
		//
	}

	return S_OK;

}

STDMETHODIMP 
CTVEViewEQueue::get_ExpireQueue(/*[out, retval]*/ ITVEAttrTimeQ **ppIEQueue)
{
	HRESULT hr = S_OK;
	if(NULL == ppIEQueue)
		return E_POINTER;
	*ppIEQueue = m_spEQueue;
	if(m_spEQueue)
		m_spEQueue->AddRef();
	else 
		return E_FAIL;
	return hr;
}

STDMETHODIMP 
CTVEViewEQueue::put_ExpireQueue(/*[in]*/ ITVEAttrTimeQ *pIEQueue)
{
	HRESULT hr = S_OK;
	if(NULL != m_spEQueue && m_spEQueue != pIEQueue)
		SetDirty();

	m_spEQueue = pIEQueue;
	return hr;
}

STDMETHODIMP 
CTVEViewEQueue::get_Service(/*[out, retval]*/ ITVEService **ppService)
{
	HRESULT hr = S_OK;
	if(NULL == ppService)
		return E_POINTER;
	*ppService = m_spService;
	if(m_spService)
		m_spService->AddRef();
	else 
		return E_FAIL;
	return hr;
}

STDMETHODIMP 
CTVEViewEQueue::put_Service(/*[in]*/ ITVEService *pService)
{
	HRESULT hr = S_OK;
	if(NULL != m_spService && m_spService != pService)
		SetDirty();

	m_spService = pService;
	return hr;
}


STDMETHODIMP 
CTVEViewEQueue::get_TveTree(/*[out, retval]*/ ITveTree **ppTveTree)
{
	HRESULT hr = S_OK;
	if(NULL == ppTveTree)
		return E_POINTER;
	*ppTveTree = m_pTveTree;
	if(m_pTveTree)
		m_pTveTree->AddRef();
	else 
		return E_FAIL;
	return hr;
}

STDMETHODIMP 
CTVEViewEQueue::put_TveTree(/*[in]*/ ITveTree *pTveTree)
{
	HRESULT hr = S_OK;

	m_pTveTree = pTveTree;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewenhancement.h ===
// TVEViewEnhancement.h : Declaration of the CVEnhancement

#ifndef __VEnhancement_H_
#define __VEnhancement_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

#include "TveTree.h"		// MSTvE definitions.. (ITVEEnhancementPtr)

/////////////////////////////////////////////////////////////////////////////
// CVEnhancement
class CTVEViewEnhancement : 
	public CAxDialogImpl<CTVEViewEnhancement>,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTVEViewEnhancement, &CLSID_TVEViewEnhancement>,
	public ITVEViewEnhancement
{
public:
	CTVEViewEnhancement()
	{
		m_fDirty = false;
	}

	~CTVEViewEnhancement()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVEVIEWENHANCEMENT)

DECLARE_NOT_AGGREGATABLE(CTVEViewEnhancement)			// see beginning COM ATL programing, page 137
DECLARE_PROTECT_FINAL_CONSTRUCT()

	enum { IDD = IDD_TVEVIEWENHANCEMENT };

BEGIN_MSG_MAP(CTVEViewEnhancement)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

BEGIN_COM_MAP(CTVEViewEnhancement)
	COM_INTERFACE_ENTRY(ITVEViewEnhancement)
END_COM_MAP()
	

	HRESULT FinalConstruct()
	{
		if(Create(NULL))
			return S_OK;
		else
			return HRESULT_FROM_WIN32(GetLastError());
	}

	void FinalRelease()
	{
		DestroyWindow();
	}

	VARIANT_BOOL IsVisible()
	{
		return IsWindowVisible() ? VARIANT_TRUE : VARIANT_FALSE;
	}

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

// ITVEViewEnhancement
	STDMETHOD(get_Visible)(/*[out, retval]*/ VARIANT_BOOL *pfVisible);
	STDMETHOD(put_Visible)(/*[in]*/ VARIANT_BOOL fVisible);


	STDMETHOD(get_Enhancement)(/*[out, retval]*/ ITVEEnhancement **ppIEnhancement);
	STDMETHOD(put_Enhancement)(/*[in]*/ ITVEEnhancement *pIEnhancement);

	STDMETHOD(UpdateFields)();

	void					SetDirty(BOOL fDirty=true)	{m_fDirty = fDirty;}
	BOOL					IsDirty()					{return m_fDirty;}

private:
	BOOL					m_fDirty;

	ITVEEnhancementPtr		m_spEnhancement;

};

#endif //__VEnhancement_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tvetreeview.cpp ===
// TveTreeView.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f TveTreeViewps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "TveTreeView.h"

#include "TveViewSupervisor.h"
#include "TveViewService.h"
#include "TveViewEnhancement.h"
#include "TveViewVariation.h"
#include "TveViewTrack.h"
#include "TveViewTrigger.h"
#include "TveViewEQueue.h"
#include "TveViewFile.h"
#include "TveViewMCastMng.h"

#include <initguid.h>
#include "TveTreeView_i.c"

#include "TveTree.h"
#include "TveTreePP.h"

#include "dbgstuff.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TveTree,				CTveTree)
OBJECT_ENTRY(CLSID_TveTreePP,			CTveTreePP)
OBJECT_ENTRY(CLSID_TVEViewSupervisor,	CTVEViewSupervisor)
OBJECT_ENTRY(CLSID_TVEViewService,		CTVEViewService)
OBJECT_ENTRY(CLSID_TVEViewEnhancement,	CTVEViewEnhancement)
OBJECT_ENTRY(CLSID_TVEViewVariation,	CTVEViewVariation)
OBJECT_ENTRY(CLSID_TVEViewTrack,		CTVEViewTrack)
OBJECT_ENTRY(CLSID_TVEViewTrigger,		CTVEViewTrigger)
OBJECT_ENTRY(CLSID_TVEViewEQueue,		CTVEViewEQueue)
OBJECT_ENTRY(CLSID_TVEViewMCastManager,	CTVEViewMCastManager)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TveTreeViewLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tvetreeviewcp.h ===
#ifndef _TVETREEVIEWCP_H_
#define _TVETREEVIEWCP_H_






template <class T>
class CProxy_ITVETreeEvents : public IConnectionPointImpl<T, &DIID__ITVETreeEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_NotifyTVETreeTuneTrigger(ITVETrigger * tveTriggerFrom, ITVETrigger * tveTriggerTo)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = tveTriggerFrom;
				pvars[0] = tveTriggerTo;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x961, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVETreeTuneVariation(ITVEVariation * tveVariationFrom, ITVEVariation * tveVariationTo)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = tveVariationFrom;
				pvars[0] = tveVariationTo;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x962, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVETreeTuneEnhancement(ITVEEnhancement * tveEnhancementFrom, ITVEEnhancement * tveEnhancementTo)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = tveEnhancementFrom;
				pvars[0] = tveEnhancementTo;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x963, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_NotifyTVETreeTuneService(ITVEService * tveServiceFrom, ITVEService * tveServiceTo)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[1] = tveServiceFrom;
				pvars[0] = tveServiceTo;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x964, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewenhancement.cpp ===
// TVEViewEnhancement.cpp : Implementation of CTVEViewEnhancement
#include "stdafx.h"

#include "TVETreeView.h"		// MIDL generated file
#include "TVEViewEnhancement.h"

#include "isotime.h"
/////////////////////////////////////////////////////////////////////////////
// CVEnhancement
LRESULT 
CTVEViewEnhancement::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 1;  // Let the system set the focus
}

LRESULT 
CTVEViewEnhancement::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

LRESULT 
CTVEViewEnhancement::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

// ---------------------------------

STDMETHODIMP 
CTVEViewEnhancement::get_Visible(/*[out, retval]*/ VARIANT_BOOL *pfVisible)
{
	HRESULT hr = S_OK;
	*pfVisible = IsVisible();
	return hr;
}

STDMETHODIMP				// see Beginning ATL COM programming, page 136
CTVEViewEnhancement::put_Visible(/*[in]*/ VARIANT_BOOL fVisible)
{
	HRESULT hr = S_OK;
	if(fVisible == IsVisible())			// nothing changed...
	{
		if(IsIconic())
			ShowWindow(SW_SHOWNORMAL);
		if(fVisible) {
			BringWindowToTop();
			if(IsDirty())
				UpdateFields();
		}
		return S_OK;
	}

	// Show or hide the window
	ShowWindow(fVisible ? SW_SHOW : SW_HIDE);


	if(IsVisible())
		UpdateFields();

	// now AddRef() or Release the object... This is ref-count for interactive user
	if(fVisible)
		GetUnknown()->AddRef();
	else
		GetUnknown()->Release();

	// don't do anything after this Release() call, could of deleted the object...

	return hr;
}

					// ID is number . Label, Data both Wide-char 
#define SET_TEXT_ITEM(id, Label, Data) \
{\
	int _idx = (id); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(Data)); \
}

#define SET_NUMBER_ITEM(id, Label, Format, Data) \
{\
	int _idx = (id); \
	_snwprintf(wbuff, 255, Format, Data); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(wbuff));  \
}


void DateToBSTR2(DATE date, BSTR *pspbstrOut)
{
	CComBSTR bstr  = DateToBSTR(date);
	CComBSTR bstr2 = DateToDiffBSTR(date);
	bstr.Append(L"  ");
	bstr.AppendBSTR(bstr2);
	bstr.CopyTo(pspbstrOut);
}

STDMETHODIMP				
CTVEViewEnhancement::UpdateFields()
{
	if(NULL == m_spEnhancement)
		return S_FALSE;

	USES_CONVERSION;
	WCHAR wbuff[256];	
	CComBSTR spBstr;
	long cItems;
	double rVal;
    LONG lVal;
	DATE date;
	ITVEAttrMapPtr spAttrMap;
	VARIANT_BOOL vbVal;

	int id = 0;

	try {

		m_spEnhancement->get_Description(&spBstr);
		SET_TEXT_ITEM(id++, L"Description", spBstr); spBstr.Empty();

		m_spEnhancement->get_DescriptionURI(&spBstr);
		SET_TEXT_ITEM(id++, L"DescriptionURI", spBstr); spBstr.Empty();
		
		ITVEVariationsPtr spVariations;
		m_spEnhancement->get_Variations(&spVariations);
		spVariations->get_Count(&cItems);
		SET_NUMBER_ITEM(id++, L"Variations", L"%d", cItems);

		m_spEnhancement->get_IsPrimary(&vbVal);
		SET_TEXT_ITEM(id++, L"IsPrimary", vbVal ? L"Yes": L"No");

		m_spEnhancement->get_ProtocolVersion(&spBstr);
		SET_TEXT_ITEM(id++, L"ProtocolVer", spBstr); spBstr.Empty();

		m_spEnhancement->get_SessionUserName(&spBstr);
		SET_TEXT_ITEM(id++, L"Session UserName", spBstr); spBstr.Empty();
		
		m_spEnhancement->get_SessionId(&lVal);
		SET_NUMBER_ITEM(id++, L"Session ID", L"%8d", lVal);

		m_spEnhancement->get_SessionVersion(&lVal);
		SET_NUMBER_ITEM(id++, L"Session Version", L"%8d", lVal);

		m_spEnhancement->get_SessionIPAddress(&spBstr);
		SET_TEXT_ITEM(id++, L"Session IP Addr", spBstr); spBstr.Empty();

		m_spEnhancement->get_SessionName(&spBstr);
		SET_TEXT_ITEM(id++, L"Session Name", spBstr); spBstr.Empty();

		m_spEnhancement->get_EmailAddresses(&spAttrMap);
		spAttrMap->DumpToBSTR(&spBstr);
		SET_TEXT_ITEM(id++, L"EMail", spBstr); spBstr.Empty();

		m_spEnhancement->get_PhoneNumbers(&spAttrMap);
		spAttrMap->DumpToBSTR(&spBstr);
		SET_TEXT_ITEM(id++, L"Phone #s", spBstr); spBstr.Empty();

		m_spEnhancement->get_UUID(&spBstr);
		SET_TEXT_ITEM(id++, L"UUID", spBstr); spBstr.Empty();

		m_spEnhancement->get_StartTime(&date);
		DateToBSTR2(date, &spBstr);
		SET_TEXT_ITEM(id++, L"Start Time", spBstr); spBstr.Empty();

		m_spEnhancement->get_StopTime(&date);
		DateToBSTR2(date, &spBstr);
		SET_TEXT_ITEM(id++, L"Stop Time", spBstr); spBstr.Empty();

		m_spEnhancement->get_Type(&spBstr);
		SET_TEXT_ITEM(id++, L"Type", spBstr); spBstr.Empty();

		m_spEnhancement->get_TveType(&spBstr); 
		SET_TEXT_ITEM(id++, L"TveType", spBstr); spBstr.Empty();

		m_spEnhancement->get_TveSize(&lVal);
		SET_NUMBER_ITEM(id++, L"TveSize", L"%8d", lVal);

		m_spEnhancement->get_TveLevel(&rVal);
		SET_NUMBER_ITEM(id++, L"TveLevel", L"%10.2f", rVal);

		m_spEnhancement->get_Attributes(&spAttrMap);
		spAttrMap->DumpToBSTR(&spBstr);
		SET_TEXT_ITEM(id++, L"Attributes", spBstr); spBstr.Empty();

		m_spEnhancement->get_Rest(&spAttrMap);
		spAttrMap->DumpToBSTR(&spBstr);
		SET_TEXT_ITEM(id++, L"Rest", spBstr); spBstr.Empty();

		SetDirty(false);
	}
	catch(...)
	{
		SET_TEXT_ITEM(id++, L"***ERROR***", L"Tossed an error here");
	}


	return S_OK;

}


STDMETHODIMP 
CTVEViewEnhancement::get_Enhancement(/*[out, retval]*/ ITVEEnhancement **ppIEnhancement)
{
	HRESULT hr = S_OK;
	if(NULL == ppIEnhancement)
		return E_POINTER;
	*ppIEnhancement = m_spEnhancement;
	if(m_spEnhancement)
		m_spEnhancement->AddRef();
	else
		return E_FAIL;
	return hr;
}

STDMETHODIMP 
CTVEViewEnhancement::put_Enhancement(/*[in]*/ ITVEEnhancement *pIEnhancement)
{
	HRESULT hr = S_OK;
	if(NULL != m_spEnhancement && m_spEnhancement != pIEnhancement)
		SetDirty(true);
	m_spEnhancement = pIEnhancement;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewequeue.h ===
// TVEViewEQueue.h : Declaration of the CTVEViewEQueue

#ifndef __TVEVIEWEQUEUE_H_
#define __TVEVIEWEQUEUE_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

#include "TveTree.h"		// ITVEContr definitions.. (ITVETriggerPtr)

/////////////////////////////////////////////////////////////////////////////
// CTVEViewEQueue
class CTVEViewEQueue : 
	public CAxDialogImpl<CTVEViewEQueue>,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTVEViewEQueue, &CLSID_TVEViewEQueue>,
	public ITVEViewEQueue
{
public:
	CTVEViewEQueue()
	{
		m_pTveTree = NULL;
	}

	~CTVEViewEQueue()
	{
		m_pTveTree = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVEVIEWEQUEUE)
DECLARE_NOT_AGGREGATABLE(CTVEViewEQueue)			// see beginning COM ATL programing, page 137
DECLARE_PROTECT_FINAL_CONSTRUCT()

	enum { IDD = IDD_TVEVIEWEQUEUE };

BEGIN_MSG_MAP(CTVEViewEQueue)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

BEGIN_COM_MAP(CTVEViewEQueue)
	COM_INTERFACE_ENTRY(ITVEViewEQueue)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		if(Create(NULL))
			return S_OK;
		else
			return HRESULT_FROM_WIN32(GetLastError());
	}

	void FinalRelease()
	{
		DestroyWindow();
	}

	VARIANT_BOOL IsVisible()
	{
		return IsWindowVisible() ? VARIANT_TRUE : VARIANT_FALSE;
	}

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

// ITVEViewTrigger
	STDMETHOD(get_Visible)(/*[out, retval]*/ VARIANT_BOOL *pfVisible);
	STDMETHOD(put_Visible)(/*[in]*/ VARIANT_BOOL fVisible);

	STDMETHOD(get_ExpireQueue)(/*[out, retval]*/ ITVEAttrTimeQ **ppIEQueue);
	STDMETHOD(put_ExpireQueue)(/*[in]*/ ITVEAttrTimeQ *pIEQueue);

	STDMETHOD(get_Service)(/*[out, retval]*/ ITVEService **ppService);
	STDMETHOD(put_Service)(/*[in]*/ ITVEService *pIEService);
	STDMETHOD(get_TveTree)(/*[out, retval]*/ ITveTree **ppTveTree);
	STDMETHOD(put_TveTree)(/*[in]*/ ITveTree *pTveTree);

	STDMETHOD(UpdateFields)();

	void					SetDirty(BOOL fDirty=true)	{m_fDirty = fDirty;}
	BOOL					IsDirty()					{return m_fDirty;}

private:
	BOOL					m_fDirty;
	ITVEAttrTimeQPtr		m_spEQueue;
	ITVEServicePtr		    m_spService;
	ITveTree				*m_pTveTree;		// non ref counted back pointer
};

#endif //__TVEVIEWEQUEUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewfile.cpp ===
// TVEViewTrack.cpp : Implementation of CTVEViewFile
#include "stdafx.h"

#include "TVETreeView.h"		// MIDL generated file
#include "TVEViewFile.h"

/////////////////////////////////////////////////////////////////////////////
// CVTrack
LRESULT 
CTVEViewFile::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 1;  // Let the system set the focus
}

LRESULT 
CTVEViewFile::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

LRESULT 
CTVEViewFile::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

// ---------------------------------

STDMETHODIMP 
CTVEViewFile::get_Visible(/*[out, retval]*/ VARIANT_BOOL *pfVisible)
{
	HRESULT hr = S_OK;
	*pfVisible = IsVisible();
	return hr;
}

STDMETHODIMP				// see Beginning ATL COM programming, page 136
CTVEViewFile::put_Visible(/*[in]*/ VARIANT_BOOL fVisible)
{
	HRESULT hr = S_OK;
	if(fVisible == IsVisible())			// nothing changed...
	{
		if(IsIconic())
			ShowWindow(SW_SHOWNORMAL);
		if(fVisible) {
			BringWindowToTop();
			if(IsDirty())
				UpdateFields();
		}
		return S_OK;
	}

	// Show or hide the window
	ShowWindow(fVisible ? SW_SHOW : SW_HIDE);


	if(IsVisible())
		UpdateFields();

	// now AddRef() or Release the object... This is ref-count for interactive user
	if(fVisible)
		GetUnknown()->AddRef();
	else
		GetUnknown()->Release();

	// don't do anything after this Release() call, could of deleted the object...

	return hr;
}
					// ID is number . Label, Data both Wide-chra 
#define SET_TEXT_ITEM(id, Label, Data) \
{\
	int _idx = (id); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(Data)); \
}

#define SET_NUMBER_ITEM(id, Label, Format, Data) \
{\
	int _idx = (id); \
	_snwprintf(wbuff, 255, Format, Data); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(wbuff));  \
}

STDMETHODIMP				
CTVEViewFile::UpdateFields()
{
	if(NULL == m_spFile)
		return S_FALSE;
	USES_CONVERSION;
	int id = 0;

	try {

//		WCHAR wbuff[256];	
		CComBSTR spBstr;
	
		BOOL fPackage;
		m_spFile->get_IsPackage(&fPackage);
		if(fPackage)
		{
			spBstr = L"Package";
			SET_TEXT_ITEM(id++, L"Type", spBstr);
		} else {
			spBstr = L"File";
			SET_TEXT_ITEM(id++, L"Type", spBstr);
		}

		SetDirty(false);
	}
	catch(...)
	{
		SET_TEXT_ITEM(id++, L"***ERROR***", L"Tossed an error here");
	}

	return S_OK;
}


STDMETHODIMP 
CTVEViewFile::get_File(/*[out, retval]*/ ITVEFile **ppIFile)
{
	HRESULT hr = S_OK;
	if(NULL == ppIFile)
		return E_POINTER;
	*ppIFile = m_spFile;
	if(m_spFile)
		m_spFile->AddRef();
	else
		return E_FAIL;
	return hr;
}

STDMETHODIMP 
CTVEViewFile::put_File(/*[in]*/ ITVEFile *pIFile)
{
	HRESULT hr = S_OK;
	if(NULL != m_spFile && m_spFile != pIFile)
		SetDirty();

	m_spFile = pIFile;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewfile.h ===
// TVEViewFile.h : Declaration of the CVTrack

#ifndef __VTrack_H_
#define __VTrack_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

#include "TveTree.h"		// ITVEContr definitions.. (ITVETrackPtr)

/////////////////////////////////////////////////////////////////////////////
// CVTrack
class CTVEViewFile : 
	public CAxDialogImpl<CTVEViewFile>,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTVEViewFile, &CLSID_TVEViewFile>,
	public ITVEViewFile
{
public:
	CTVEViewFile()
	{
		m_fDirty = false;
	}

	~CTVEViewFile()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVEVIEWFILE)

DECLARE_NOT_AGGREGATABLE(CTVEViewFile)			// see beginning COM ATL programing, page 137
DECLARE_PROTECT_FINAL_CONSTRUCT()

	enum { IDD = IDD_TVEVIEWFILE };

BEGIN_MSG_MAP(CTVEViewFile)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

BEGIN_COM_MAP(CTVEViewFile)
	COM_INTERFACE_ENTRY(ITVEViewFile)
END_COM_MAP()
	

	HRESULT FinalConstruct()
	{
		if(Create(NULL))
			return S_OK;
		else
			return HRESULT_FROM_WIN32(GetLastError());
	}

	void FinalRelease()
	{
		DestroyWindow();
	}

	VARIANT_BOOL IsVisible()
	{
		return IsWindowVisible() ? VARIANT_TRUE : VARIANT_FALSE;
	}

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

// ITVEViewFile
	STDMETHOD(get_Visible)(/*[out, retval]*/ VARIANT_BOOL *pfVisible);
	STDMETHOD(put_Visible)(/*[in]*/ VARIANT_BOOL fVisible);


	STDMETHOD(get_File)(/*[out, retval]*/ ITVEFile **ppIFile);
	STDMETHOD(put_File)(/*[in]*/ ITVEFile *pIFile);

	STDMETHOD(UpdateFields)();

	void					SetDirty(BOOL fDirty=true)	{m_fDirty = fDirty;}
	BOOL					IsDirty()					{return m_fDirty;}

private:
	BOOL					m_fDirty;

	ITVEFilePtr				m_spFile;

};

#endif //__VTrack_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewservice.h ===
// TVEViewService.h : Declaration of the CVService

#ifndef __VSERVICE_H_
#define __VSERVICE_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

#include "TveTree.h"		// ITVEContr definitions.. (ITVEServicePtr)

/////////////////////////////////////////////////////////////////////////////
// CVService
class CTVEViewService : 
	public CAxDialogImpl<CTVEViewService>,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTVEViewService, &CLSID_TVEViewService>,
	public ITVEViewService
{
public:
	CTVEViewService()
	{
		m_fDirty = false;
	}

	~CTVEViewService()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVEVIEWSERVICE)

DECLARE_NOT_AGGREGATABLE(CTVEViewService)			// see beginning COM ATL programing, page 137
DECLARE_PROTECT_FINAL_CONSTRUCT()

	enum { IDD = IDD_TVEVIEWSERVICE };

BEGIN_MSG_MAP(CTVEViewService)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

BEGIN_COM_MAP(CTVEViewService)
	COM_INTERFACE_ENTRY(ITVEViewService)
END_COM_MAP()
	

	HRESULT FinalConstruct()
	{
		if(Create(NULL))
			return S_OK;
		else
			return HRESULT_FROM_WIN32(GetLastError());
	}

	void FinalRelease()
	{
		DestroyWindow();
	}

	VARIANT_BOOL IsVisible()
	{
		return IsWindowVisible() ? VARIANT_TRUE : VARIANT_FALSE;
	}

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

// ITVEViewService
	STDMETHOD(get_Visible)(/*[out, retval]*/ VARIANT_BOOL *pfVisible);
	STDMETHOD(put_Visible)(/*[in]*/ VARIANT_BOOL fVisible);


	STDMETHOD(get_Service)(/*[out, retval]*/ ITVEService **ppIService);
	STDMETHOD(put_Service)(/*[in]*/ ITVEService *pIService);

	STDMETHOD(UpdateFields)();

	void					SetDirty(BOOL fDirty=true)	{m_fDirty = fDirty;}
	BOOL					IsDirty()					{return m_fDirty;}

private:
	BOOL					m_fDirty;

	ITVEServicePtr			m_spService;

};

#endif //__VSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewmcastmng.h ===
// TVEViewMCastManager.h : Declaration of the CVTrigger

#ifndef __VMCastManager_H_
#define __VMCastManager_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

#include "TveTree.h"		// ITVEContr definitions.. (ITVETriggerPtr)

/////////////////////////////////////////////////////////////////////////////
// CVTrigger
class CTVEViewMCastManager : 
	public CAxDialogImpl<CTVEViewMCastManager>,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTVEViewMCastManager, &CLSID_TVEViewMCastManager>,
	public ITVEViewMCastManager
{
public:
	CTVEViewMCastManager()
	{
		m_fDirty = false;
	}

	~CTVEViewMCastManager()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVEVIEWMCASTMANAGER)

DECLARE_NOT_AGGREGATABLE(CTVEViewMCastManager)			// see beginning COM ATL programing, page 137
DECLARE_PROTECT_FINAL_CONSTRUCT()

	enum { IDD = IDD_TVEVIEWMCASTMANAGER };

BEGIN_MSG_MAP(CTVEViewMCastManager)
	MESSAGE_HANDLER(WM_INITDIALOG,          OnInitDialog)
	MESSAGE_HANDLER(WM_TIMER,               OnTimer)
	COMMAND_ID_HANDLER(IDOK,                OnOK)
	COMMAND_ID_HANDLER(IDCANCEL,            OnCancel)
    COMMAND_ID_HANDLER(IDC_MC_RESETCOUNT,   OnResetCount)

END_MSG_MAP()

BEGIN_COM_MAP(CTVEViewMCastManager)
	COM_INTERFACE_ENTRY(ITVEViewMCastManager)
END_COM_MAP()
	

	HRESULT FinalConstruct()
	{
		if(Create(NULL))
			return S_OK;
		else
			return HRESULT_FROM_WIN32(GetLastError());
	}

	void FinalRelease()
	{
        if(m_nTimer) KillTimer(m_nTimer);  m_nTimer = 0;
		DestroyWindow();
	}

	VARIANT_BOOL IsVisible()
	{
		return IsWindowVisible() ? VARIANT_TRUE : VARIANT_FALSE;
	}

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnResetCount(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

// ITVEViewMCastManager
	STDMETHOD(get_Visible)(/*[out, retval]*/ VARIANT_BOOL *pfVisible);
	STDMETHOD(put_Visible)(/*[in]*/ VARIANT_BOOL fVisible);

	STDMETHOD(get_MCastManager)(/*[out, retval]*/ ITVEMCastManager **ppIMCastManager);
	STDMETHOD(put_MCastManager)(/*[in]*/ ITVEMCastManager *pIMCastManager);

	STDMETHOD(UpdateFields)();

	void					SetDirty(BOOL fDirty=true)	{m_fDirty = fDirty;}
	BOOL					IsDirty()					{return m_fDirty;}

private:
    UINT                    m_nTimer;
	BOOL					m_fDirty;
	ITVEMCastManagerPtr		m_spMCastManager;

};

#endif //__VMCastManager_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewmcastmng.cpp ===
// TVEViewMCastManager.cpp : Implementation of CTVEViewMCastManager
#include "stdafx.h"

#include "TVETreeView.h"		// MIDL generated file
#include "TVEViewMCastMng.h"

_COM_SMARTPTR_TYPEDEF(ITVECBAnnc,                   __uuidof(ITVECBAnnc));
_COM_SMARTPTR_TYPEDEF(ITVECBFile,                   __uuidof(ITVECBFile));
_COM_SMARTPTR_TYPEDEF(ITVECBTrig,                   __uuidof(ITVECBTrig));
_COM_SMARTPTR_TYPEDEF(ITVECBDummy,                  __uuidof(ITVECBDummy));

_COM_SMARTPTR_TYPEDEF(ITVEService_Helper,           __uuidof(ITVEService_Helper));
_COM_SMARTPTR_TYPEDEF(ITVEMCastManager_Helper,      __uuidof(ITVEMCastManager_Helper));
 
/////////////////////////////////////////////////////////////////////////////
// CVTrigger
LRESULT 
CTVEViewMCastManager::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    const UINT uWait = 1000;
    m_nTimer = SetTimer(1, uWait);

	return 1;  // Let the system set the focus
}

LRESULT 
CTVEViewMCastManager::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

LRESULT 
CTVEViewMCastManager::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if(m_nTimer) KillTimer(m_nTimer);  m_nTimer = 0;
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

LRESULT 
CTVEViewMCastManager::OnResetCount(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    ITVEMCastsPtr spMCasts;
    HRESULT hr = m_spMCastManager->get_MCasts(&spMCasts);
    if(!FAILED(hr) && spMCasts != NULL)
    {

        const int kChars = 256;
		WCHAR wbuff[kChars];	
		CComBSTR spBstr;

		long cItems;
		spMCasts->get_Count(&cItems);
		int iItem = 0;
		for( iItem=0; iItem < cItems; iItem++)
		{
			CComVariant cvItem(iItem);
			DATE dateExpires;
			ITVEMCastPtr spMCast;
			spMCasts->get_Item(cvItem, &spMCast);
            
            spMCast->ResetStats();
        }

        UpdateFields();
    }  
	return 0;
}

LRESULT 
CTVEViewMCastManager::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	VARIANT_BOOL fVis;
    get_Visible(&fVis);
    if(fVis == VARIANT_TRUE)
        UpdateFields();
	return 0;
}

// ---------------------------------

STDMETHODIMP 
CTVEViewMCastManager::get_Visible(/*[out, retval]*/ VARIANT_BOOL *pfVisible)
{
	HRESULT hr = S_OK;
	*pfVisible = IsVisible();
	return hr;
}

STDMETHODIMP				// see Beginning ATL COM programming, page 136
CTVEViewMCastManager::put_Visible(/*[in]*/ VARIANT_BOOL fVisible)
{
	HRESULT hr = S_OK;
	if(fVisible == IsVisible())			// nothing changed...
	{
		if(IsIconic())
			ShowWindow(SW_SHOWNORMAL);
		if(fVisible) {
			BringWindowToTop();
			if(IsDirty())
				UpdateFields();
		}
		return S_OK;
	}

	// Show or hide the window
	ShowWindow(fVisible ? SW_SHOW : SW_HIDE);


	if(IsVisible())
		UpdateFields();

	// now AddRef() or Release the object... This is ref-count for interactive user
	if(fVisible)
		GetUnknown()->AddRef();
	else
		GetUnknown()->Release();

	// don't do anything after this Release() call, could of deleted the object...

	return hr;
}
					// ID is number . Label, Data both Wide-chra 
#define SET_TEXT_ITEM(id, Label, Data) \
{\
	int _idx = (id); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(Data)); \
}

#define SET_NUMBER_ITEM(id, Label, Format, Data) \
{\
	int _idx = (id); \
	_snwprintf(wbuff, 255, Format, Data); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(wbuff));  \
}

extern void DateToBSTR2(DATE date, BSTR *pbstrOut);

// helper function to find service/variation given a particular adapter, address, and port
//  returns S_FALSE if can't find it..
//  Note - may return wrong service for Announcements  - after all, they have same IP addr's/Ports
//     In this case, it tries to return the 'active' service preferentially.

HRESULT 
FindVariation(ITVESupervisor *pSuper, BSTR bstrAdapter, BSTR bstrAddress, LONG lPort,
              ITVEService **ppService, ITVEVariation **ppVariation, 
			  long *piEnhLoc, long *piVarLoc, NWHAT_Mode *pWhatType)
{
    HRESULT hr = S_OK;
    
    if(NULL == pSuper)      return E_INVALIDARG;
    if(NULL == ppService)   return E_POINTER;
    if(NULL == ppVariation) return E_POINTER;
    if(NULL == piEnhLoc)    return E_POINTER;
    if(NULL == piVarLoc)    return E_POINTER;
    *piVarLoc = 0;
	*piEnhLoc = 0;
	*ppService = NULL;			// make sure it's nulled out... 

    ITVEServicesPtr spServices;
    hr = pSuper->get_Services(&spServices);
    if(FAILED(hr)) 
        return hr;

	long cServices;
	hr = spServices->get_Count(&cServices);
    if(FAILED(hr))
        return hr;

	for(int iService = 0; iService < cServices; iService++)
	{
		CComVariant cv(iService);
        ITVEServicePtr spService;
		hr = spServices->get_Item(cv, &spService);
		_ASSERT(S_OK == hr);
		if(spService) 
        {
			ITVEService_HelperPtr spServHelper(spService);
			CComBSTR spbsAdapter;
			CComBSTR spbsIPAddr;
			LONG lPortIn;
			spServHelper->GetAnncIPValues(&spbsAdapter, &spbsIPAddr, &lPortIn);
        
                        // since all IP addr's in a service is on the same adapter, first check that
            if(spbsAdapter == bstrAdapter)
            {
                        // is it an announcement ? 
				VARIANT_BOOL fIsActive;
				spService->get_IsActive(&fIsActive);
			    if(spbsAdapter == bstrAdapter && spbsIPAddr == bstrAddress && lPort == lPortIn)
			    {
					if(*ppService == NULL || fIsActive)		// return name of Active Service
					{											//  somewhat strange, but without digging into callback,
						if(*ppService) (*ppService)->Release();	//  how else do we determine it?

						*ppService = spService;
						if(*ppService) (*ppService)->AddRef();
						*ppVariation = NULL;
						*pWhatType = NWHAT_Announcement;
					}
			    }

                ITVEEnhancementsPtr spEnhs;
                hr = spService->get_Enhancements(&spEnhs);
                if(!FAILED(hr) && spEnhs != NULL)
                {
                    long cEnhs;
                    hr = spEnhs->get_Count(&cEnhs);
                    _ASSERT(!FAILED(hr));
                    for(int i = 0; i < cEnhs; i++)
                    {
                        CComVariant cv(i);
                        ITVEEnhancementPtr spEnh;
                        hr = spEnhs->get_Item(cv, &spEnh);
                        _ASSERT(!FAILED(hr));
                        if(!FAILED(hr) && spEnh != NULL)
                        {
                            ITVEVariationsPtr spVars;
                            hr = spEnh->get_Variations(&spVars);
                            _ASSERT(!FAILED(hr));
                            long cVars;
                            hr = spVars->get_Count(&cVars);
                            _ASSERT(!FAILED(hr));
                            for(int j = 0; j < cVars; j++) 
                            {
                               CComVariant cvE(j);
                                ITVEVariationPtr spVar;
                                hr = spVars->get_Item(cvE, &spVar);
                                if(!FAILED(hr) && NULL != spVar)
                                {
                                    spbsIPAddr.Empty();
									spVar->get_FileIPAddress(&spbsIPAddr);
                                    spVar->get_FilePort(&lPortIn);
                                    if(spbsIPAddr == bstrAddress && lPort == lPortIn)
                                    {
										*ppVariation = spVar;
										if(*ppVariation) (*ppVariation)->AddRef();
										*ppService = spService;
										if(*ppService) (*ppService)->AddRef();
										*pWhatType = NWHAT_Data;
										*piEnhLoc = i;
                                        *piVarLoc = j;
										return S_OK;
                                    }
									spbsIPAddr.Empty();
                                    spVar->get_TriggerIPAddress(&spbsIPAddr);
                                    spVar->get_TriggerPort(&lPortIn);
                                    if(spbsIPAddr == bstrAddress && lPort == lPortIn)
                                    {
										*ppVariation = spVar;
										if(*ppVariation) (*ppVariation)->AddRef();
										*ppService = spService;
										if(*ppService) (*ppService)->AddRef();
                                        *pWhatType = NWHAT_Data;
                                        *piVarLoc = j;
										*piEnhLoc = i;
                                         return S_OK;
                                    }                                
                                }
                            }
                        }
                    }
                }
            }
		}
	}
    return S_FALSE;
}


STDMETHODIMP				
CTVEViewMCastManager::UpdateFields()
{
    HRESULT hr = S_OK;
	if(NULL == m_spMCastManager)
		return S_FALSE;

	USES_CONVERSION;
	int id = 0;	
	
	try {

        ITVEMCastsPtr spMCasts;
        hr = m_spMCastManager->get_MCasts(&spMCasts);
        if(!FAILED(hr) && spMCasts != NULL)
        {

            const int kChars = 256;
		    WCHAR wbuff[kChars];	
		    CComBSTR spBstr;

		    long cItems;
		    spMCasts->get_Count(&cItems);

						// thread safe way...
/*		IUnknownPtr spEnPunk;
		hr = spMCasts->get__NewEnum(&spEnPunk);
		IEnumVARIANTPtr spEnVMCasts(spEnPunk);

		CComVariant varTimeQ;
		ULONG ulFetched;
		cItems = 0;
		while(S_OK == spEnVMCasts->Next(1, &varTimeQ, &ulFetched))
			cItems++;

		hr = spEnVMCasts->Reset();			// reset the enumerator to the start again.
*/
		    SetDlgItemInt(IDC_MC_ITEMS, cItems, true);  

            ITVEMCastManager_HelperPtr spMCMHelper(m_spMCastManager);
            if(spMCMHelper)
            {
                long cPackets=-1, cPacketsDropped=-1, cPacketsDroppedTotal=-1;
                spMCMHelper->GetPacketCounts(&cPackets, &cPacketsDropped, &cPacketsDroppedTotal);
		        SetDlgItemInt(IDC_MC_PKTS_TOTAL, cPackets, true);  
		        SetDlgItemInt(IDC_MC_PKTS_DROPPED, cPacketsDroppedTotal, true);  
            }


		    HWND hLBox = GetDlgItem(IDC_EQ_LIST);
		    SendMessage(hLBox, LB_RESETCONTENT, 0, 0);				// clear previous items
                       // ID State TID Type Adapter  IP-Address  Service #Packets #Bytes
		    int rgTabStops[] = {18, 38, 68,   90,     150,        230,   340,   370};	// tabstops as sizes
		    int kTabStops = sizeof(rgTabStops) / sizeof(rgTabStops[0]);
		    int sum = 0;
/*		    for(int i = 0; i < kTabStops; i++)		// integrate...
		    {
			    sum += rgTabStops[i]*1;
			    rgTabStops[i] = sum;
		    }
*/

		    SendMessage(hLBox, LB_SETTABSTOPS, (WPARAM) kTabStops, (LPARAM) rgTabStops);				// clear previous items

		    int iItem = 0;
		    for( iItem=0; iItem < cItems; iItem++)
		    {
			    CComVariant cvItem(iItem);
			    DATE dateExpires;
			    ITVEMCastPtr spMCast;
			    spMCasts->get_Item(cvItem, &spMCast);


                CComBSTR spbsState(L"??");
				VARIANT_BOOL	fJoined;		                    spMCast->get_IsJoined(&fJoined);
			    VARIANT_BOOL	fSuspended;		                    spMCast->get_IsSuspended(&fSuspended);
                spbsState.Empty();
                spbsState.Append(fJoined ? L"J" : L"-");
                spbsState.Append(fSuspended ? L"S" : L"-");

                DWORD    dwTID=0;                                   //

                NWHAT_Mode whatType;
                CComBSTR spbsType(L"????");                         spMCast->get_WhatType(&whatType);
                if(whatType == NWHAT_Announcement)  spbsType = "Annc"; else
                if(whatType == NWHAT_Trigger)       spbsType = "Trig"; else
                if(whatType == NWHAT_Data)          spbsType = "Data"; else
                if(whatType == NWHAT_Other)         spbsType = "Othr"; else
                if(whatType == NWHAT_Extra)         spbsType = "Extr"; else
                                                    spbsType = "?";

/*                CTVEMCast *pMCast =(CTVEMCast *) spMCast;           // NASTY CAST
                ITVECBAnncPtr  spCB(pMCast->spMCastCallback); if(spCB)    spbsType = "Annc";
                ITVECBFilePtr  spCB(pMCast->spMCastCallback); if(spCB)    spbsType = "Data";
                ITVECBTrigPtr  spCB(pMCast->spMCastCallback); if(spCB)    spbsType = "Trig";
                ITVECBDummyPtr spCB(pMCast->spMCastCallback); if(spCB)    spbsType = "Dumy";
*/

                CComBSTR spbsAdapter;/*(L"000.000.000.000");*/           spMCast->get_IPAdapter(&spbsAdapter);
                CComBSTR spbsAddress;/*(L"000.000.000.000:00000");*/     spMCast->get_IPAddress(&spbsAddress);
                long    lPort;                                      spMCast->get_IPPort(&lPort);
 
                 CComBSTR spbsServiceDesc(L"---------------------");
                 CComBSTR spbsVarDesc("");
                 {
                    ITVESupervisorPtr spSuper;
                    m_spMCastManager->get_Supervisor(&spSuper);
                    ITVEServicePtr spService;
                    ITVEVariationPtr spVariation;
                    NWHAT_Mode whatType2;
                    long iVarLoc, iEnhLoc;
                    hr = FindVariation(spSuper, spbsAdapter, spbsAddress, lPort, 
                                        &spService, &spVariation, &iEnhLoc, &iVarLoc, &whatType2);
                    if(!FAILED(hr))
                    {
                        if(spService)    spService->get_Description(&spbsServiceDesc);
						WCHAR *pwc = spbsServiceDesc.m_str;
						while(*pwc != NULL && *pwc != '(')  pwc++;	// womp the IP addr I put in
						*pwc = NULL;						
                        if(spVariation) {
                            spbsVarDesc.Empty(); spVariation->get_Description(&spbsVarDesc);
                            if(spbsVarDesc.Length() == 0)
                            {
                                _snwprintf(wbuff,kChars,L"<<<Enh %d Var %d>>>", iEnhLoc, iVarLoc);
                            }
                            spbsServiceDesc = spbsVarDesc;
                        }
                    }
                }

                long    lPackets=99999;                           spMCast->get_PacketCount(&lPackets);
                long    lBytes=999999;                            spMCast->get_ByteCount(&lBytes);
           
                _snwprintf(wbuff,kChars,L":%d",lPort);
                spbsAddress.Append(wbuff);

			    _snwprintf(wbuff, kChars,L"%4d:\t %2s\t 0x%04x\t %4s\t %15s\t %21s\t %20s\t %-5d\t %-8d",
                    iItem, spbsState, dwTID, spbsType, spbsAdapter, spbsAddress,spbsServiceDesc,lPackets,lBytes);
			    SendMessage(hLBox, LB_ADDSTRING,       0, (LPARAM) W2T(wbuff)); 
			    SendMessage(hLBox, LB_SETITEMDATA, iItem, (LPARAM) iItem); 
		    }
        }
	    SetDirty(false);
	}
	catch(...)
	{
		//
	}	

	return S_OK;

}


STDMETHODIMP 
CTVEViewMCastManager::get_MCastManager(/*[out, retval]*/ ITVEMCastManager **ppIMCastManager)
{
	HRESULT hr = S_OK;
	if(NULL == ppIMCastManager)
		return E_POINTER;
	*ppIMCastManager = m_spMCastManager;
	if(m_spMCastManager)
		m_spMCastManager->AddRef();
	else 
		return E_FAIL;
	return hr;
}

STDMETHODIMP 
CTVEViewMCastManager::put_MCastManager(/*[in]*/ ITVEMCastManager *pIMCastManager)
{
	HRESULT hr = S_OK;
	if(NULL != m_spMCastManager && m_spMCastManager != pIMCastManager)
		SetDirty();

	m_spMCastManager = pIMCastManager;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewservice.cpp ===
// TVEViewService.cpp : Implementation of CTVEViewService
#include "stdafx.h"

#include "TVETreeView.h"		// MIDL generated file
#include "TVEViewService.h"

/////////////////////////////////////////////////////////////////////////////
// CVService
LRESULT 
CTVEViewService::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 1;  // Let the system set the focus
}

LRESULT 
CTVEViewService::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

LRESULT 
CTVEViewService::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

// ---------------------------------

STDMETHODIMP 
CTVEViewService::get_Visible(/*[out, retval]*/ VARIANT_BOOL *pfVisible)
{
	HRESULT hr = S_OK;
	*pfVisible = IsVisible();
	return hr;
}

STDMETHODIMP				// see Beginning ATL COM programming, page 136
CTVEViewService::put_Visible(/*[in]*/ VARIANT_BOOL fVisible)
{
	HRESULT hr = S_OK;
	if(fVisible == IsVisible())			// nothing changed...
	{
		if(IsIconic())
			ShowWindow(SW_SHOWNORMAL);
		if(fVisible) {
			BringWindowToTop();
			if(IsDirty())
				UpdateFields();
		}
		return S_OK;
	}

	// Show or hide the window
	ShowWindow(fVisible ? SW_SHOW : SW_HIDE);


	if(IsVisible())
		UpdateFields();

	// now AddRef() or Release the object... This is ref-count for interactive user
	if(fVisible)
		GetUnknown()->AddRef();
	else
		GetUnknown()->Release();

	// don't do anything after this Release() call, could of deleted the object...

	return hr;
}
					// ID is number . Label, Data both Wide-chra 
					// ID is number . Label, Data both Wide-chra 
#define SET_TEXT_ITEM(id, Label, Data) \
{\
	int _idx = (id); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(Data)); \
}

#define SET_NUMBER_ITEM(id, Label, Format, Data) \
{\
	int _idx = (id); \
	_snwprintf(wbuff, 255, Format, Data); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(wbuff));  \
}

STDMETHODIMP				
CTVEViewService::UpdateFields()
{
	HRESULT hr;
	if(NULL == m_spService)
		return S_FALSE;

	USES_CONVERSION;
	WCHAR wbuff[256];	
	CComBSTR spBstr;
	long cItems;
	DATE date;

	int id = 0;

	try {

		m_spService->get_Description(&spBstr);
		SET_TEXT_ITEM(id++, L"Description", spBstr);

		VARIANT_BOOL fActive;
		m_spService->get_IsActive(&fActive);
		SET_TEXT_ITEM(id++, L"Active", fActive ? L"True" : L"False");

		ITVEEnhancementsPtr spEnhancements;
		m_spService->get_Enhancements(&spEnhancements);
		spEnhancements->get_Count(&cItems);
		SET_NUMBER_ITEM(id++, L"Enhancements", L"%d", cItems);

		ITVETracksPtr spXoverTracks;
		m_spService->get_XOverLinks(&spXoverTracks);
		spXoverTracks->get_Count(&cItems);
		SET_NUMBER_ITEM(id++, L"XOver Links", L"%d", cItems);

		m_spService->get_ExpireOffset(&date);
		DATE fD = (date < 0) ? -date : date;
		if(fD < 1/(24.0 * 60)) {
			SET_NUMBER_ITEM(id++, L"Expire Offset", L"%6.1f secs", date*24*60*60);
		} else if(fD < 1/24.0) {
			SET_NUMBER_ITEM(id++, L"Expire Offset", L"%6.1f min", date*24*60);
		} else if(fD < 1) {
			SET_NUMBER_ITEM(id++, L"Expire Offset", L"%6.1f hr", date*24);
		} else if(fD < 100) {
			SET_NUMBER_ITEM(id++, L"Expire Offset", L"%6.1f days", date);
		} else { 
			SET_NUMBER_ITEM(id++, L"Expire Offset", L"%6.1f years", date/365.25);
		}


		ITVEAttrTimeQPtr spAttrTimeQ;
		hr = m_spService->get_ExpireQueue(&spAttrTimeQ);
		if(FAILED(hr) || NULL == spAttrTimeQ)
		{
			SET_TEXT_ITEM(id++, L"Expire Items", L"TimeQ Queue Not Initialized");
		}
		else
		{
			spAttrTimeQ->get_Count(&cItems);
			SET_NUMBER_ITEM(id++, L"Expire Items", L"%d", cItems);
		}

		SetDirty(false);
	}
	catch(...)
	{
		SET_TEXT_ITEM(id++, L"***ERROR***", L"Tossed an error here");
	}

	return S_OK;

}


STDMETHODIMP 
CTVEViewService::get_Service(/*[out, retval]*/ ITVEService **ppIService)
{
	HRESULT hr = S_OK;
	if(NULL == ppIService)
		return E_POINTER;
	*ppIService = m_spService;
	if(m_spService)
	{
		m_spService->AddRef();
		return hr;
	} else {
		return E_INVALIDARG;
	}
}

STDMETHODIMP 
CTVEViewService::put_Service(/*[in]*/ ITVEService *pIService)
{
	HRESULT hr = S_OK;
	if(NULL != m_spService && m_spService != pIService)
		SetDirty();

	m_spService = pIService;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewsupervisor.h ===
// TVEViewSupervisor.h : Declaration of the CVSupervisor

#ifndef __VSupervisor_H_
#define __VSupervisor_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

#include "TveTree.h"		// ITVEContr definitions.. (ITVESupervisorPtr)

/////////////////////////////////////////////////////////////////////////////
// CVSupervisor
class CTVEViewSupervisor : 
	public CAxDialogImpl<CTVEViewSupervisor>,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTVEViewSupervisor, &CLSID_TVEViewSupervisor>,
	public ITVEViewSupervisor
{
public:
	CTVEViewSupervisor()
	{
		m_fDirty = false;
	}

	~CTVEViewSupervisor()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVEVIEWSUPERVISOR)

DECLARE_NOT_AGGREGATABLE(CTVEViewSupervisor)			// see beginning COM ATL programing, page 137
DECLARE_PROTECT_FINAL_CONSTRUCT()

	enum { IDD = IDD_TVEVIEWSUPERVISOR };

BEGIN_MSG_MAP(CTVEViewSupervisor)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

BEGIN_COM_MAP(CTVEViewSupervisor)
	COM_INTERFACE_ENTRY(ITVEViewSupervisor)
END_COM_MAP()
	

	HRESULT FinalConstruct()
	{
		if(Create(NULL))
			return S_OK;
		else
			return HRESULT_FROM_WIN32(GetLastError());
	}

	void FinalRelease()
	{
		DestroyWindow();
	}

	VARIANT_BOOL IsVisible()
	{
		return IsWindowVisible() ? VARIANT_TRUE : VARIANT_FALSE;
	}

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

// ITVEViewSupervisor
	STDMETHOD(get_Visible)(/*[out, retval]*/ VARIANT_BOOL *pfVisible);
	STDMETHOD(put_Visible)(/*[in]*/ VARIANT_BOOL fVisible);


	STDMETHOD(get_Supervisor)(/*[out, retval]*/ ITVESupervisor **ppISupervisor);
	STDMETHOD(put_Supervisor)(/*[in]*/ ITVESupervisor *pISupervisor);

	STDMETHOD(UpdateFields)();

	void					SetDirty(BOOL fDirty=true)	{m_fDirty = fDirty;}
	BOOL					IsDirty()					{return m_fDirty;}

private:
	BOOL					m_fDirty;

	ITVESupervisorPtr		m_spSupervisor;


};

#endif //__VSupervisor_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewsupervisor.cpp ===
// TVEViewSupervisor.cpp : Implementation of CTVEViewSupervisor
#include "stdafx.h"

#include "TVETreeView.h"		// MIDL generated file
#include "TVEViewSupervisor.h"
#include "..\..\include\TVEStats.h"
/////////////////////////////////////////////////////////////////////////////
// CVSupervisor
LRESULT 
CTVEViewSupervisor::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 1;  // Let the system set the focus
}

LRESULT 
CTVEViewSupervisor::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

LRESULT 
CTVEViewSupervisor::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

// ---------------------------------

STDMETHODIMP 
CTVEViewSupervisor::get_Visible(/*[out, retval]*/ VARIANT_BOOL *pfVisible)
{
	HRESULT hr = S_OK;
	*pfVisible = IsVisible();
	return hr;
}

STDMETHODIMP				// see Beginning ATL COM programming, page 136
CTVEViewSupervisor::put_Visible(/*[in]*/ VARIANT_BOOL fVisible)
{
	HRESULT hr = S_OK;
	if(fVisible == IsVisible())			// nothing changed...
	{
		if(IsIconic())
			ShowWindow(SW_SHOWNORMAL);
		if(fVisible) {
			BringWindowToTop();
			if(IsDirty())
				UpdateFields();
		}
		return S_OK;
	}

	// Show or hide the window
	ShowWindow(fVisible ? SW_SHOW : SW_HIDE);


	if(IsVisible())
		UpdateFields();

	// now AddRef() or Release the object... This is ref-count for interactive user
	if(fVisible)
		GetUnknown()->AddRef();
	else
		GetUnknown()->Release();

	// don't do anything after this Release() call, could of deleted the object...

	return hr;
}
					// ID is number . Label, Data both Wide-chra 
#define SET_TEXT_ITEM(id, Label, Data) \
{\
	int _idx = (id); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(Data)); \
}

#define SET_NUMBER_ITEM(id, Label, Format, Data) \
{\
	int _idx = (id); \
	_snwprintf(wbuff, 255, Format, Data); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(wbuff));  \
}

STDMETHODIMP				
CTVEViewSupervisor::UpdateFields()
{
	if(NULL == m_spSupervisor)
		return S_FALSE;

	USES_CONVERSION;
	WCHAR wbuff[256];	

	CComBSTR spBstr;
	long cItems;
	int id = 0;

	try {
		m_spSupervisor->get_Description(&spBstr);
		SET_TEXT_ITEM(id++, L"Description", spBstr);	spBstr.Empty();

		ITVEServicesPtr spServices;
		m_spSupervisor->get_Services(&spServices);
		spServices->get_Count(&cItems);
		SET_NUMBER_ITEM(id++, L"Services", L"%8d", cItems);

		m_spSupervisor->GetStats(&spBstr);

		CTVEStats *pTveStats = (CTVEStats *) spBstr.m_str;		// nasty cast, but this is only test info


		SET_NUMBER_ITEM(id++,L"Tunes",			L"%8d", pTveStats->m_cTunes);
		SET_NUMBER_ITEM(id++,L"Files",			L"%8d", pTveStats->m_cFiles);
		SET_NUMBER_ITEM(id++,L"Packages",		L"%8d", pTveStats->m_cPackages);
		SET_NUMBER_ITEM(id++,L"Enhancements",	L"%8d", pTveStats->m_cEnhancements);
		SET_NUMBER_ITEM(id++,L"Triggers",		L"%8d", pTveStats->m_cTriggers);
		SET_NUMBER_ITEM(id++,L"XOverLinks",		L"%8d", pTveStats->m_cXOverLinks);
		SET_NUMBER_ITEM(id++,L"AuxInfos",		L"%8d", pTveStats->m_cAuxInfos);
	} 
	catch (...)
	{
		SET_TEXT_ITEM(id++, L"***ERROR***", L"Tossed an error here");
	}

	return S_OK;

}


STDMETHODIMP 
CTVEViewSupervisor::get_Supervisor(/*[out, retval]*/ ITVESupervisor **ppISupervisor)
{
	HRESULT hr = S_OK;
	if(NULL == ppISupervisor)
		return E_POINTER;
	*ppISupervisor = m_spSupervisor;
	if(m_spSupervisor)
		m_spSupervisor->AddRef();
	else 
		return E_FAIL;
	return hr;
}

STDMETHODIMP 
CTVEViewSupervisor::put_Supervisor(/*[in]*/ ITVESupervisor *pISupervisor)
{
	HRESULT hr = S_OK;
	if(NULL != m_spSupervisor && m_spSupervisor != pISupervisor)
		SetDirty();
	m_spSupervisor = pISupervisor;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewtrack.cpp ===
// TVEViewTrack.cpp : Implementation of CTVEViewTrack
#include "stdafx.h"

#include "TVETreeView.h"		// MIDL generated file
#include "TVEViewTrack.h"

/////////////////////////////////////////////////////////////////////////////
// CVTrack
LRESULT 
CTVEViewTrack::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 1;  // Let the system set the focus
}

LRESULT 
CTVEViewTrack::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

LRESULT 
CTVEViewTrack::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

// ---------------------------------

STDMETHODIMP 
CTVEViewTrack::get_Visible(/*[out, retval]*/ VARIANT_BOOL *pfVisible)
{
	HRESULT hr = S_OK;
	*pfVisible = IsVisible();
	return hr;
}

STDMETHODIMP				// see Beginning ATL COM programming, page 136
CTVEViewTrack::put_Visible(/*[in]*/ VARIANT_BOOL fVisible)
{
	HRESULT hr = S_OK;
	if(fVisible == IsVisible())			// nothing changed...
	{
		if(IsIconic())
			ShowWindow(SW_SHOWNORMAL);
		if(fVisible) {
			BringWindowToTop();
			if(IsDirty())
				UpdateFields();
		}
		return S_OK;
	}

	// Show or hide the window
	ShowWindow(fVisible ? SW_SHOW : SW_HIDE);


	if(IsVisible())
		UpdateFields();

	// now AddRef() or Release the object... This is ref-count for interactive user
	if(fVisible)
		GetUnknown()->AddRef();
	else
		GetUnknown()->Release();

	// don't do anything after this Release() call, could of deleted the object...

	return hr;
}
					// ID is number . Label, Data both Wide-chra 
#define SET_TEXT_ITEM(id, Label, Data) \
{\
	int _idx = (id); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(Data)); \
}

#define SET_NUMBER_ITEM(id, Label, Format, Data) \
{\
	int _idx = (id); \
	_snwprintf(wbuff, 255, Format, Data); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(wbuff));  \
}

STDMETHODIMP				
CTVEViewTrack::UpdateFields()
{
	if(NULL == m_spTrack)
		return S_FALSE;
	USES_CONVERSION;
	int id = 0;

	try {

//		WCHAR wbuff[256];	
		CComBSTR spBstr;

		m_spTrack->get_Description(&spBstr);
		SET_TEXT_ITEM(id++, L"Description", spBstr);

		SetDirty(false);
	}
	catch(...)
	{
		SET_TEXT_ITEM(id++, L"***ERROR***", L"Tossed an error here");
	}

	return S_OK;
}


STDMETHODIMP 
CTVEViewTrack::get_Track(/*[out, retval]*/ ITVETrack **ppITrack)
{
	HRESULT hr = S_OK;
	if(NULL == ppITrack)
		return E_POINTER;
	*ppITrack = m_spTrack;
	if(m_spTrack)
		m_spTrack->AddRef();
	else
		return E_FAIL;
	return hr;
}

STDMETHODIMP 
CTVEViewTrack::put_Track(/*[in]*/ ITVETrack *pITrack)
{
	HRESULT hr = S_OK;
	if(NULL != m_spTrack && m_spTrack != pITrack)
		SetDirty();

	m_spTrack = pITrack;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tveviewer\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewvariation.cpp ===
// TVEViewVariation.cpp : Implementation of CTVEViewVariation
#include "stdafx.h"

#include "TVETreeView.h"		// MIDL generated file
#include "TVEViewVariation.h"

/////////////////////////////////////////////////////////////////////////////
// CVVariation
LRESULT 
CTVEViewVariation::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 1;  // Let the system set the focus
}

LRESULT 
CTVEViewVariation::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

LRESULT 
CTVEViewVariation::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

// ---------------------------------

STDMETHODIMP 
CTVEViewVariation::get_Visible(/*[out, retval]*/ VARIANT_BOOL *pfVisible)
{
	HRESULT hr = S_OK;
	*pfVisible = IsVisible();
	return hr;
}

STDMETHODIMP				// see Beginning ATL COM programming, page 136
CTVEViewVariation::put_Visible(/*[in]*/ VARIANT_BOOL fVisible)
{
	HRESULT hr = S_OK;
	if(fVisible == IsVisible())			// nothing changed...
	{
		if(IsIconic())
			ShowWindow(SW_SHOWNORMAL);
		if(fVisible) {
			BringWindowToTop();
			if(IsDirty())
				UpdateFields();
		}
		return S_OK;
	}

	// Show or hide the window
	ShowWindow(fVisible ? SW_SHOW : SW_HIDE);


	if(IsVisible())
		UpdateFields();

	// now AddRef() or Release the object... This is ref-count for interactive user
	if(fVisible)
		GetUnknown()->AddRef();
	else
		GetUnknown()->Release();

	// don't do anything after this Release() call, could of deleted the object...

	return hr;
}

					// ID is number . Label, Data both Wide-char 
#define SET_TEXT_ITEM(id, Label, Data) \
{\
	int _idx = (id); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(Data)); \
}

#define SET_NUMBER_ITEM(id, Label, Format, Data) \
{\
	int _idx = (id); \
	_snwprintf(wbuff, 255, Format, Data); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(wbuff));  \
}

STDMETHODIMP				
CTVEViewVariation::UpdateFields()
{
	if(NULL == m_spVariation)
		return S_FALSE;

	USES_CONVERSION;
	WCHAR wbuff[256];	
	CComBSTR spBstr, spBstr2;
	long cItems;
    LONG lVal;
	ITVEAttrMapPtr spAttrMap;

	int id = 0;

	m_spVariation->get_Description(&spBstr);
	SET_TEXT_ITEM(id++, L"Description", spBstr);				spBstr.Empty();

	ITVETracksPtr spTracks;
	m_spVariation->get_Tracks(&spTracks);
	spTracks->get_Count(&cItems);
	SET_NUMBER_ITEM(id++, L"Triggers", L"%d", cItems);

	m_spVariation->get_MediaName(&spBstr);
	SET_TEXT_ITEM(id++, L"Media Name", spBstr);					spBstr.Empty();


	m_spVariation->get_MediaTitle(&spBstr);
	SET_TEXT_ITEM(id++, L"Media Title", spBstr);				spBstr.Empty();

	m_spVariation->get_FileIPAdapter(&spBstr);	
	m_spVariation->get_FileIPAddress(&spBstr2);
	m_spVariation->get_FilePort(&lVal);
	_snwprintf(wbuff, 255,L"%s / %s:%d",spBstr,spBstr2,lVal); 	spBstr.Empty();spBstr2.Empty();
	SET_TEXT_ITEM(id++, L"File Adapt/IP", wbuff);

	m_spVariation->get_TriggerIPAdapter(&spBstr);
	m_spVariation->get_TriggerIPAddress(&spBstr2);
	m_spVariation->get_TriggerPort(&lVal);
	_snwprintf(wbuff, 255,L"%s / %s:%d",spBstr,spBstr2,lVal);	spBstr.Empty();spBstr2.Empty();
	SET_TEXT_ITEM(id++, L"Trigger Adapt/IP", wbuff);


	m_spVariation->get_SDPLanguages(&spAttrMap);
	spAttrMap->DumpToBSTR(&spBstr);
	SET_TEXT_ITEM(id++, L"SDP Languages", spBstr);				spBstr.Empty();

	m_spVariation->get_Languages(&spAttrMap);
	spAttrMap->DumpToBSTR(&spBstr);
	SET_TEXT_ITEM(id++, L"Languages", spBstr);					spBstr.Empty();

	m_spVariation->get_Bandwidth(&lVal);
	m_spVariation->get_BandwidthInfo(&spBstr);
	_snwprintf(wbuff, 255, L"%d : %s",lVal,spBstr);				spBstr.Empty();
	SET_TEXT_ITEM(id++, L"Bandwidth", wbuff);

	m_spVariation->get_Attributes(&spAttrMap);
	spAttrMap->DumpToBSTR(&spBstr);
	SET_TEXT_ITEM(id++, L"Attributes", spBstr);					spBstr.Empty();

	m_spVariation->get_Rest(&spAttrMap);
	spAttrMap->DumpToBSTR(&spBstr);
	SET_TEXT_ITEM(id++, L"Rest", spBstr);						spBstr.Empty();
	
	SetDirty(false);

	return S_OK;

}


STDMETHODIMP 
CTVEViewVariation::get_Variation(/*[out, retval]*/ ITVEVariation **ppIVariation)
{
	HRESULT hr = S_OK;
	if(NULL == ppIVariation || NULL == *ppIVariation)
		return E_POINTER;
	*ppIVariation = m_spVariation;
	if(m_spVariation)
		m_spVariation->AddRef();
	else
		return E_FAIL;
	return hr;
}

STDMETHODIMP 
CTVEViewVariation::put_Variation(/*[in]*/ ITVEVariation *pIVariation)
{
	HRESULT hr = S_OK;
	if(NULL != m_spVariation && m_spVariation != pIVariation)
		SetDirty(true);
	m_spVariation = pIVariation;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewtrack.h ===
// TVEViewTrack.h : Declaration of the CVTrack

#ifndef __VTrack_H_
#define __VTrack_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

#include "TveTree.h"		// ITVEContr definitions.. (ITVETrackPtr)

/////////////////////////////////////////////////////////////////////////////
// CVTrack
class CTVEViewTrack : 
	public CAxDialogImpl<CTVEViewTrack>,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTVEViewTrack, &CLSID_TVEViewTrack>,
	public ITVEViewTrack
{
public:
	CTVEViewTrack()
	{
		m_fDirty = false;
	}

	~CTVEViewTrack()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVEVIEWTRACK)

DECLARE_NOT_AGGREGATABLE(CTVEViewTrack)			// see beginning COM ATL programing, page 137
DECLARE_PROTECT_FINAL_CONSTRUCT()

	enum { IDD = IDD_TVEVIEWTRACK };

BEGIN_MSG_MAP(CTVEViewTrack)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

BEGIN_COM_MAP(CTVEViewTrack)
	COM_INTERFACE_ENTRY(ITVEViewTrack)
END_COM_MAP()
	

	HRESULT FinalConstruct()
	{
		if(Create(NULL))
			return S_OK;
		else
			return HRESULT_FROM_WIN32(GetLastError());
	}

	void FinalRelease()
	{
		DestroyWindow();
	}

	VARIANT_BOOL IsVisible()
	{
		return IsWindowVisible() ? VARIANT_TRUE : VARIANT_FALSE;
	}

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

// ITVEViewTrack
	STDMETHOD(get_Visible)(/*[out, retval]*/ VARIANT_BOOL *pfVisible);
	STDMETHOD(put_Visible)(/*[in]*/ VARIANT_BOOL fVisible);


	STDMETHOD(get_Track)(/*[out, retval]*/ ITVETrack **ppITrack);
	STDMETHOD(put_Track)(/*[in]*/ ITVETrack *pITrack);

	STDMETHOD(UpdateFields)();

	void					SetDirty(BOOL fDirty=true)	{m_fDirty = fDirty;}
	BOOL					IsDirty()					{return m_fDirty;}

private:
	BOOL					m_fDirty;

	ITVETrackPtr		m_spTrack;

};

#endif //__VTrack_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewtrigger.h ===
// TVEViewTrigger.h : Declaration of the CVTrigger

#ifndef __VTrigger_H_
#define __VTrigger_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

#include "TveTree.h"		// ITVEContr definitions.. (ITVETriggerPtr)

/////////////////////////////////////////////////////////////////////////////
// CVTrigger
class CTVEViewTrigger : 
	public CAxDialogImpl<CTVEViewTrigger>,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTVEViewTrigger, &CLSID_TVEViewTrigger>,
	public ITVEViewTrigger
{
public:
	CTVEViewTrigger()
	{
		m_fDirty = false;
	}

	~CTVEViewTrigger()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVEVIEWTRIGGER)

DECLARE_NOT_AGGREGATABLE(CTVEViewTrigger)			// see beginning COM ATL programing, page 137
DECLARE_PROTECT_FINAL_CONSTRUCT()

	enum { IDD = IDD_TVEVIEWTRIGGER };

BEGIN_MSG_MAP(CTVEViewTrigger)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

BEGIN_COM_MAP(CTVEViewTrigger)
	COM_INTERFACE_ENTRY(ITVEViewTrigger)
END_COM_MAP()
	

	HRESULT FinalConstruct()
	{
		if(Create(NULL))
			return S_OK;
		else
			return HRESULT_FROM_WIN32(GetLastError());
	}

	void FinalRelease()
	{
		DestroyWindow();
	}

	VARIANT_BOOL IsVisible()
	{
		return IsWindowVisible() ? VARIANT_TRUE : VARIANT_FALSE;
	}

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

// ITVEViewTrigger
	STDMETHOD(get_Visible)(/*[out, retval]*/ VARIANT_BOOL *pfVisible);
	STDMETHOD(put_Visible)(/*[in]*/ VARIANT_BOOL fVisible);


	STDMETHOD(get_Trigger)(/*[out, retval]*/ ITVETrigger **ppITrigger);
	STDMETHOD(put_Trigger)(/*[in]*/ ITVETrigger *pITrigger);

	STDMETHOD(UpdateFields)();

	void					SetDirty(BOOL fDirty=true)	{m_fDirty = fDirty;}
	BOOL					IsDirty()					{return m_fDirty;}

private:
	BOOL					m_fDirty;
	ITVETriggerPtr			m_spTrigger;

};

#endif //__VTrigger_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewtrigger.cpp ===
// TVEViewTrigger.cpp : Implementation of CTVEViewTrigger
#include "stdafx.h"

#include "TVETreeView.h"		// MIDL generated file
#include "TVEViewTrigger.h"

/////////////////////////////////////////////////////////////////////////////
// CVTrigger
LRESULT 
CTVEViewTrigger::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 1;  // Let the system set the focus
}

LRESULT 
CTVEViewTrigger::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

LRESULT 
CTVEViewTrigger::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	put_Visible(VARIANT_FALSE);
//	EndDialog(wID);
	return 0;
}

// ---------------------------------

STDMETHODIMP 
CTVEViewTrigger::get_Visible(/*[out, retval]*/ VARIANT_BOOL *pfVisible)
{
	HRESULT hr = S_OK;
	*pfVisible = IsVisible();
	return hr;
}

STDMETHODIMP				// see Beginning ATL COM programming, page 136
CTVEViewTrigger::put_Visible(/*[in]*/ VARIANT_BOOL fVisible)
{
	HRESULT hr = S_OK;
	if(fVisible == IsVisible())			// nothing changed...
	{
		if(IsIconic())
			ShowWindow(SW_SHOWNORMAL);
		if(fVisible) {
			BringWindowToTop();
			if(IsDirty())
				UpdateFields();
		}
		return S_OK;
	}

	// Show or hide the window
	ShowWindow(fVisible ? SW_SHOW : SW_HIDE);


	if(IsVisible())
		UpdateFields();

	// now AddRef() or Release the object... This is ref-count for interactive user
	if(fVisible)
		GetUnknown()->AddRef();
	else
		GetUnknown()->Release();

	// don't do anything after this Release() call, could of deleted the object...

	return hr;
}
					// ID is number . Label, Data both Wide-chra 
#define SET_TEXT_ITEM(id, Label, Data) \
{\
	int _idx = (id); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(Data)); \
}

#define SET_NUMBER_ITEM(id, Label, Format, Data) \
{\
	int _idx = (id); \
	_snwprintf(wbuff, 255, Format, Data); \
	SetDlgItemText( IDC_LABEL0 + _idx, W2T(Label)); \
	SetDlgItemText( IDC_DATA0 + _idx, W2T(wbuff));  \
}

extern void DateToBSTR2(DATE date, BSTR *pbstrOut);

STDMETHODIMP				
CTVEViewTrigger::UpdateFields()
{
	if(NULL == m_spTrigger)
		return S_FALSE;

	USES_CONVERSION;
	int id = 0;	
	
	try {


		WCHAR wbuff[256];	
		CComBSTR spBstr;
		DATE date;
		float rVal;



		m_spTrigger->get_Name(&spBstr);				spBstr.Empty();
		SET_TEXT_ITEM(id++, L"Name", spBstr);

		m_spTrigger->get_URL(&spBstr);				spBstr.Empty();
		SET_TEXT_ITEM(id++, L"URL", spBstr);

		m_spTrigger->get_TVELevel(&rVal);
		SET_NUMBER_ITEM(id++, L"TveLevel", L"%8.2f", rVal);

		m_spTrigger->get_Rest(&spBstr);
		SET_TEXT_ITEM(id++, L"Rest", spBstr);		spBstr.Empty();

		m_spTrigger->get_Executes(&date);
		DateToBSTR2(date,&spBstr);
		SET_TEXT_ITEM(id++, L"Executes", spBstr);	spBstr.Empty();

		m_spTrigger->get_Expires(&date);
		DateToBSTR2(date,&spBstr);
		SET_TEXT_ITEM(id++, L"Expires", spBstr);	spBstr.Empty();		


		m_spTrigger->get_Script(&spBstr);
		SET_TEXT_ITEM(id++, L"Script", spBstr);		spBstr.Empty();

		SetDirty(false);
	}
	catch(...)
	{
		SET_TEXT_ITEM(id++, L"***ERROR***", L"Tossed an error here");
	}

	return S_OK;

}


STDMETHODIMP 
CTVEViewTrigger::get_Trigger(/*[out, retval]*/ ITVETrigger **ppITrigger)
{
	HRESULT hr = S_OK;
	if(NULL == ppITrigger)
		return E_POINTER;
	*ppITrigger = m_spTrigger;
	if(m_spTrigger)
		m_spTrigger->AddRef();
	else 
		return E_FAIL;
	return hr;
}

STDMETHODIMP 
CTVEViewTrigger::put_Trigger(/*[in]*/ ITVETrigger *pITrigger)
{
	HRESULT hr = S_OK;
	if(NULL != m_spTrigger && m_spTrigger != pITrigger)
		SetDirty();

	m_spTrigger = pITrigger;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tveviewer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TveViewer.rc
//
#define IDS_PROJNAME                    100
#define IDR_TveViewer                   100
#define IDB_TVEVIEW                     101
#define IDR_TVEVIEW                     102
#define IDD_TVEVIEW                     103
#define IDC_BUTTON_TUNE                 201
#define IDC_EDIT_STATION                202
#define IDC_EDIT_ADDRESS                203
#define IDC_EXPLORER                    204
#define IDC_TVETREE                     205
#define IDC_IE_BACK                     206
#define IDC_IE_FORWARD                  207
#define IDC_IE_STOP                     208
#define IDC_IE_REFRESH                  209
#define IDC_IE_HOME                     210
#define IDC_BUTTON_UNTUNE               211
#define IDC_RICHEDIT1                   213
#define IDC_IE_PROGCTRL                 216
#define IDC_TVELIST                     220
#define IDC_COMBO_ADAPTER               221
#define IDC_COMBO_SHIFTTIME             222
#define IDC_TVEEDIT                     223
#define IDC_TVEEDITLOG                  223
#define ID_BUTTON32768                  32768

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32769
#define _APS_NEXT_CONTROL_VALUE         224
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tvetreeview\tveviewvariation.h ===
// TVEViewVariation.h : Declaration of the CVVariation

#ifndef __VVariation_H_
#define __VVariation_H_

#include "resource.h"       // main symbols
#include <atlhost.h>

#include "TveTree.h"		// ITVEContr definitions.. (ITVEVariationPtr)

/////////////////////////////////////////////////////////////////////////////
// CVVariation
class CTVEViewVariation : 
	public CAxDialogImpl<CTVEViewVariation>,
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTVEViewVariation, &CLSID_TVEViewVariation>,
	public ITVEViewVariation
{
public:
	CTVEViewVariation()
	{
	}

	~CTVEViewVariation()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TVEVIEWVARIATION)

DECLARE_NOT_AGGREGATABLE(CTVEViewVariation)			// see beginning COM ATL programing, page 137
DECLARE_PROTECT_FINAL_CONSTRUCT()

	enum { IDD = IDD_TVEVIEWVARIATION};

BEGIN_MSG_MAP(CTVEViewVariation)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
	COMMAND_ID_HANDLER(IDOK, OnOK)
	COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

BEGIN_COM_MAP(CTVEViewVariation)
	COM_INTERFACE_ENTRY(ITVEViewVariation)
END_COM_MAP()
	

	HRESULT FinalConstruct()
	{
		if(Create(NULL))
			return S_OK;
		else
			return HRESULT_FROM_WIN32(GetLastError());
	}

	void FinalRelease()
	{
		DestroyWindow();
	}

	VARIANT_BOOL IsVisible()
	{
		return IsWindowVisible() ? VARIANT_TRUE : VARIANT_FALSE;
	}

// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

// ITVEViewVariation
	STDMETHOD(get_Visible)(/*[out, retval]*/ VARIANT_BOOL *pfVisible);
	STDMETHOD(put_Visible)(/*[in]*/ VARIANT_BOOL fVisible);


	STDMETHOD(get_Variation)(/*[out, retval]*/ ITVEVariation **ppIVariation);
	STDMETHOD(put_Variation)(/*[in]*/ ITVEVariation *pIVariation);

	STDMETHOD(UpdateFields)();

	void					SetDirty(BOOL fDirty=true)	{m_fDirty = fDirty;}
	BOOL					IsDirty()					{return m_fDirty;}

private:
	BOOL					m_fDirty;

	ITVEVariationPtr		m_spVariation;

};

#endif //__VVariation_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tveviewer\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7E3F5ECD_ADD8_4ECB_9C8E_D701659722BB__INCLUDED_)
#define AFX_STDAFX_H__7E3F5ECD_ADD8_4ECB_9C8E_D701659722BB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7E3F5ECD_ADD8_4ECB_9C8E_D701659722BB__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tveviewer\tvecontainer.cpp ===
// -------------------------------------
// TveContainer.cpp
//
//	Stupid little window class that 
//
// --------------------------------------------------------------------------------
#include "stdafx.h"
#include "resource.h"

#include "TveContainer.h"

// See MSDN article "Adding ATL Control Containment Support to Any Window"
// AtlAxWinInit is implemented in Atl.dll
#pragma comment(lib, "atl.lib")

HWND mhwnd;
HRESULT CTveContainer::CreateYourself()
{
	HRESULT hr = S_OK;
	InitCommonControls();
	AtlAxWinInit();

	HWND hWnd = ::CreateWindow(_T("AtlAxWin"), _T("TveViewer.TveView"),
							 WS_CLIPCHILDREN, //WS_VISIBLE, 
							 CW_USEDEFAULT, CW_USEDEFAULT,			// x,y
							 900, 700,								// w,h
							 NULL, NULL,							// parent, menu
							::GetModuleHandle(NULL), NULL);
	if(NULL == hWnd)
		hr = GetLastError();
	if(FAILED(hr))
		return hr;

//	ShowWindow(hWnd, SW_SHOWNORMAL);		-- I do not want these sam I am!  I do not want Show windows and Ham!
//	UpdateWindow(hWnd);

	return hr;
}

HRESULT CTveContainer::DestroyYourself()
{
	HRESULT hr = S_OK;
	return hr;
}




// --------------------------------------------------------
// ------ Interesting code - try putting it someplace
/*
void CServiceModule::LogEvent(LPCTSTR pFormat, ...)
{
    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
    va_list pArg;

    va_start(pArg, pFormat);
    _vstprintf(chMsg, pFormat, pArg);
    va_end(pArg);

    lpszStrings[0] = chMsg;

    if (m_bService)
    {
        // Get a handle to use with ReportEvent(). 
        hEventSource = RegisterEventSource(NULL, m_szServiceName);
        if (hEventSource != NULL)
        {
            // Write to event log. *
            ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
            DeregisterEventSource(hEventSource);
        }
    }
    else
    {
        // As we are not running as a service, just write the error to the console.
        _putts(chMsg);
    }
}

// ---------------------------------------------------------------------------------- 
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tveviewer\tvecontainer.h ===
// -----------------------------------------------------------------------------
// TveContainer.h
// -----------------------------------------------------------------------------

#include "stdafx.h"
#include <atldef.h>
#define _ATL_DLL_IMPL
#include <atliface.h> 

#include <stdio.h>
//#include <atlhost.h>
#include "commctrl.h"

#pragma warning( push )
#pragma warning( disable : 4146)			//   turn unsigned stuff, else  NENH_grfSAPEncryptComp = -2147483648 
/*#ifdef BUILT_FROM_BUILD
#ifdef BUILD_CHK
#import "..\..\MSTvE\objd\i386\MSTvE.dll" named_guids, raw_interfaces_only 
#else
#import "..\..\MSTvE\obj\i386\MSTve.dll" named_guids, raw_interfaces_only 
#endif
#else
#import "..\..\MSTvE\debug\MSTve.dll" named_guids, raw_interfaces_only 
#endif
*/
//namespace MSTvELib {
#include "MSTvE.h"
//}
#pragma warning( pop )	

										// use this rename 'cause ITVEEvents coming out of the TreeView too (somehow go in-out)
#ifdef BUILT_FROM_BUILD
#ifdef BUILD_CHK
#import  "..\TveTreeView\objd\i386\TveTreeView.tlb" named_guids raw_interfaces_only rename("_ITVEEvents", "_ITVEEventsX")
#else
#import  "..\TveTreeView\obj\i386\TveTreeView.tlb" named_guids raw_interfaces_only rename("_ITVEEvents", "_ITVEEventsX")
#endif
#else
#import  "..\TveTreeView\debug\TveTreeView.tlb" named_guids raw_interfaces_only rename("_ITVEEvents", "_ITVEEventsX")
#endif

//using namespace MSTvELib;
#include "TveViewer.h"
#include "TveView.h"

#pragma warning( push )
#pragma warning( disable : 4192)			// turn of automatically excluding OLECMDID,OLECMDF,OLECMDEXECOPT,tagREADYSTATE, while importing
//#import "shdocvw.dll" raw_interfaces_only, raw_native_types, named_guids	rename("FindWindow", "FindWindowX")
#include "exdisp.h"
#pragma warning( pop )

		
_COM_SMARTPTR_TYPEDEF(ITVESupervisor,           __uuidof(ITVESupervisor));
_COM_SMARTPTR_TYPEDEF(ITVEServices,				__uuidof(ITVEServices));
_COM_SMARTPTR_TYPEDEF(ITVEService,				__uuidof(ITVEService));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancements,			__uuidof(ITVEEnhancements));
_COM_SMARTPTR_TYPEDEF(ITVEEnhancement,			__uuidof(ITVEEnhancement));
_COM_SMARTPTR_TYPEDEF(ITVEVariations,			__uuidof(ITVEVariations));
_COM_SMARTPTR_TYPEDEF(ITVEVariation,			__uuidof(ITVEVariation));
_COM_SMARTPTR_TYPEDEF(ITVETracks,				__uuidof(ITVETracks));
_COM_SMARTPTR_TYPEDEF(ITVETrack,				__uuidof(ITVETrack));
_COM_SMARTPTR_TYPEDEF(ITVETrigger,				__uuidof(ITVETrigger));

_COM_SMARTPTR_TYPEDEF(ITVEAttrMap,				__uuidof(ITVEAttrMap));
_COM_SMARTPTR_TYPEDEF(ITVEAttrTimeQ,			__uuidof(ITVEAttrTimeQ));

_COM_SMARTPTR_TYPEDEF(ITVENavAid,               __uuidof(ITVENavAid));
_COM_SMARTPTR_TYPEDEF(ITVENavAid_Helper,		__uuidof(ITVENavAid_Helper));
_COM_SMARTPTR_TYPEDEF(ITVENavAid_NoVidCtl,		__uuidof(ITVENavAid_NoVidCtl));
_COM_SMARTPTR_TYPEDEF(ITVEFeature,				__uuidof(ITVEFeature));


class CTveContainer
{
public:
	HRESULT CreateYourself();
	HRESULT DestroyYourself();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tveviewer\tveview.cpp ===
// TveView.cpp : Implementation of CTveView

#include "stdafx.h"

#include "TveContainer.h"

extern HRESULT CleanIEAddress(BSTR bstrIn, BSTR *pBstrOut);

_COM_SMARTPTR_TYPEDEF(ITVENavAid_NoVidCtl,     __uuidof(ITVENavAid_NoVidCtl));
_COM_SMARTPTR_TYPEDEF(ITVESupervisor_Helper,   __uuidof(ITVESupervisor_Helper));

// ---------------------------------------------------------
//  event handler for the IE address edit box
//	  Turn the <CR> into an IDOK button

WNDPROC gwpOrigAddressEditProc = NULL; 

LRESULT CALLBACK MyAddressEditWndProc(
	HWND hwnd,        // handle to window
	UINT uMsg,        // message identifier
	WPARAM wParam,    // first message parameter
	LPARAM lParam)    // second message parameter
{ 
	switch (uMsg) 
	{ 

	case WM_GETDLGCODE:
		return DLGC_WANTALLKEYS; 

 	case WM_CHAR: 
		{
			static int i = 0;
			const int kSz=256;
			TCHAR sztbuff[kSz];
			_stprintf (sztbuff,_T("%8d# %08x %08x %08x\n"),i++,uMsg,lParam,wParam);
			OutputDebugString(sztbuff);
			char c = (char) wParam;
			if(c == 0x0d)
			{
				HWND hWndParent = GetParent(hwnd);				// the composite control

				::GetDlgItemText(hWndParent, IDC_EDIT_ADDRESS, sztbuff, kSz);

				SendMessage( hWndParent, WM_COMMAND, IDOK, (LONG) hWndParent);
				return true;
			}
		}
		break;

	// 
	// Process other messages. 
	// 

	default: 
		break;
	}		// switch uMsg

	_ASSERT(gwpOrigAddressEditProc);
	return CallWindowProc(gwpOrigAddressEditProc, hwnd, uMsg, wParam, lParam);
}
/////////////////////////////////////////////////////////////////////////////
// CTveView

HRESULT 
CTveView::InPlaceActivate(LONG iVerb, const RECT *prcPosRect)
{
	HRESULT hr = S_OK;
	hr = CComControlBase::InPlaceActivate(iVerb, prcPosRect);

	if(FAILED(hr) || iVerb != OLEIVERB_INPLACEACTIVATE)
		return hr;

		// for this way to work, sink object needs to support ITVEEvents.
		//   which it doesn't with DispEvent stuff.
		// Need to create out of the Final Constructor?

	if(NULL == m_spTVENavAid || NULL == m_spWebBrowser)		// navigation elements
		return E_NOINTERFACE;

	if(NULL == m_spTveTree)			// U/I element
		return E_NOINTERFACE;

		// hookup the NavAid to the web browser...
	IDispatchPtr spDispWebBrowser(m_spWebBrowser);
	hr = m_spTVENavAid->put_WebBrowserApp(spDispWebBrowser);
	if(FAILED(hr)) {
		_ASSERT(false);
		return hr;
	}


							// Tve Supervisor Events
	if(SUCCEEDED(hr))
	{
										// get the events...
		ITVESupervisorPtr spSuper;
		hr = m_spTveTree->get_Supervisor(&spSuper);
		if(FAILED(hr))
			return hr;

										// hook fake supervisor events up to NavAid  
/*		if(m_spTVENavAid)
		{
			ITVENavAid_HelperPtr spNAHelper(m_spTVENavAid);
			spNAHelper->put_FakeTVESuper(spSuper);
		}
*/
		_ASSERT(NULL != spSuper);
		
		IUnknownPtr spPunkSuper(spSuper);				// the event source
		IUnknownPtr spPunkSink(GetUnknown());			// this new event sink...

		if(m_dwEventsTveSuperCookie) {
			hr = AtlUnadvise(spPunkSuper,
							 DIID__ITVEEvents,
							 m_dwEventsTveSuperCookie);	// need to pass to AtlUnadvise...
			m_dwEventsTveSuperCookie = 0;
		}

		hr = AtlAdvise(spPunkSuper,						// event source (TveSupervisor)
					   spPunkSink,						// event sink (this app...)
					   DIID__ITVEEvents,				// <--- hard line
					   &m_dwEventsTveSuperCookie);		// need to pass to AtlUnadvise

		spPunkSink->Release();							// magic code here (Forward)
	}

								// Tve TreeView Control events
	if(SUCCEEDED(hr))
	{
										// get the events...
		_ASSERT(NULL != m_spTveTree);
		
		IUnknownPtr spPunkTveTree(m_spTveTree);			// the event source
		IUnknownPtr spPunkSink(GetUnknown());			// this new event sink...

		if(m_dwEventsTveTreeCookie) {
			hr = AtlUnadvise(spPunkTveTree,
							  TveTreeViewLib::DIID__ITVETreeEvents,
							 m_dwEventsTveTreeCookie);	// need to pass to AtlUnadvise...
			m_dwEventsTveTreeCookie = 0;
		}

		hr = AtlAdvise(spPunkTveTree,					// event source (TveTree control)
					   spPunkSink,						// event sink (this app...)
					   TveTreeViewLib::DIID__ITVETreeEvents,			// <--- hard line
					   &m_dwEventsTveTreeCookie);		// need to pass to AtlUnadvise

		spPunkSink->Release();							// magic code here (Forward)
	}
							 // Web Browser Events

	if(SUCCEEDED(hr))
	{
										// get the events...		
		IUnknownPtr spPunkWebBrowser(m_spWebBrowser);	// the event source
		IUnknownPtr spPunkSink(GetUnknown());			// this new event sink...

		if(m_dwEventsWebBrowserCookie) {
			hr = AtlUnadvise(spPunkWebBrowser,
							 DIID_DWebBrowserEvents2,
							 m_dwEventsWebBrowserCookie);	// need to pass to AtlUnadvise...
			m_dwEventsWebBrowserCookie = 0;
		}

		hr = AtlAdvise(spPunkWebBrowser,				// event source (IE Browser)
					   spPunkSink,						// event sink (gseg event listener...)
					   DIID_DWebBrowserEvents2,			// <--- hard line
					   &m_dwEventsWebBrowserCookie);	// need to pass to AtlUnadvise

		spPunkSink->Release();							// magic code here (Forward)
	}

	if(!FAILED(hr) && NULL != m_spWebBrowser)
	{
		CComVariant varZero(0);
		CComVariant varNull("");
		hr = m_spWebBrowser->put_Visible(true);
	//	CComBSTR bstrAddr(L"http://www.microsoft.com");
		CComBSTR bstrAddr(L"\\\\johnbrad10\\public\\TVE\\Chan1\\BaseTrack.html");

		CComBSTR bstrTmp;
		CleanIEAddress( bstrAddr, &bstrTmp);		
		hr = m_spWebBrowser->Navigate(bstrTmp, &varZero, &varNull, &varNull, &varNull);
	}

	return hr;
}


_COM_SMARTPTR_TYPEDEF(ITVETriggerCtrl,			__uuidof(ITVETriggerCtrl));

HRESULT 
CTveView::FinalConstruct()
{
	HRESULT hr = S_OK;

		// create the TVENavAid... Used to hook everything together..
	hr = CoCreateInstance(CLSID_TVENavAid, 
						  NULL, CLSCTX_INPROC_SERVER, 
						  IID_ITVENavAid, 
						  reinterpret_cast<void**>(&m_spTVENavAid));
	if(FAILED(hr))
	{
		_ASSERT(false);
		return hr;
	}


//test code - just to see if we can CoCreate it....
//	ITVETriggerCtrlPtr	spTriggerCtrl(CLSID_TVETriggerCtrl);
	ITVETriggerCtrlPtr	spTriggerCtrl;

	hr = CoCreateInstance(CLSID_TVETriggerCtrl, 
						  NULL, CLSCTX_INPROC_SERVER, 
						  IID_ITVETriggerCtrl, 
						  reinterpret_cast<void**>(&spTriggerCtrl));
	CComBSTR spbsBack;
	if(spTriggerCtrl)
		spTriggerCtrl->get_backChannel(&spbsBack);
//end test code 
	return hr;
}

HRESULT
CTveView::ReleaseEverything()
{
/*	if(m_spTVENavAid)
	{
		ITVENavAid_HelperPtr spNAHelper(m_spTVENavAid);
		spNAHelper->put_FakeTVESuper(NULL);
	} */

	
	m_hWndEditLog = 0;
	m_hWndProgressBar = 0;


	HRESULT hr = S_OK;
	if(0 != m_dwEventsTveSuperCookie)
	{
		if(m_spTveTree) {

			ITVESupervisorPtr spSuper;
			hr = m_spTveTree->get_Supervisor(&spSuper);

			spSuper->TuneTo(NULL, NULL);

			if(FAILED(hr))
				return hr;

			IUnknownPtr spPunkSuper(spSuper);

			IUnknownPtr spPunkSink(GetUnknown());		// this new event sink...
			spPunkSink->AddRef();						// magic code here (inverse)
			hr = AtlUnadvise(spPunkSuper,
							 DIID__ITVEEvents,
							 m_dwEventsTveSuperCookie);		// need to pass to AtlUnadvise...
			if(FAILED(hr))
				spPunkSink->Release();
			m_dwEventsTveSuperCookie = 0;
		}
	}


	if(0 != m_dwEventsTveTreeCookie)
	{
		if(m_spTveTree)
		{
										// get the events...		
			IUnknownPtr spPunkWebBrowser(m_spTveTree);		// the event source
			IUnknownPtr spPunkSink(GetUnknown());			// this new event sink...


			hr = AtlUnadvise(m_spTveTree,
							 TveTreeViewLib::DIID__ITVETreeEvents,
							 m_dwEventsTveTreeCookie);	// need to pass to AtlUnadvise...
			m_dwEventsTveTreeCookie = 0;
		}
	}

	if(0 != m_dwEventsWebBrowserCookie)
	{
		if(m_spWebBrowser)
		{
										// get the events...		
			IUnknownPtr spPunkWebBrowser(m_spWebBrowser);	// the event source
			IUnknownPtr spPunkSink(GetUnknown());			// this new event sink...
			spPunkSink->AddRef();							// Magic code (inverse)
			hr = AtlUnadvise(spPunkWebBrowser,
							 DIID_DWebBrowserEvents2,
							 m_dwEventsWebBrowserCookie);	// need to pass to AtlUnadvise...
		}
	}

	m_spTVENavAid = NULL;

    if(m_fpLogOut)
        fclose(m_fpLogOut); m_fpLogOut = 0;


	return hr;
}

HRESULT 
CTveView::FinalRelease()
{
    return ReleaseEverything();
}

LRESULT 
CTveView::OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{

	m_hWndEditLog = 0;		                        // try to close out to avoid bad events...

	if(m_spTVENavAid) {
		m_spTVENavAid->put_WebBrowserApp(NULL);			// womp the Advise sink...
		ITVENavAid_NoVidCtlPtr spNANoVidCtl(m_spTVENavAid);
		spNANoVidCtl->put_NoVidCtl_Supervisor(NULL);
	}


    ReleaseEverything();		// for some stange reason, FinalRelease not being called, so do it ourselves
	m_spTveTree = NULL;
	m_spWebBrowser = NULL;
	m_spTVENavAid = NULL;		

	DestroyWindow();
	PostQuitMessage(0);			// is FinalRelease not getting called because of this?
	return 0;
}

HRESULT
SetupIPAdapterAddrs(HWND hCBox, ITVESupervisorPtr spSuper)
{
    HRESULT hr = S_OK;
    
    if(NULL == spSuper)
        return E_INVALIDARG;
    if(!::IsWindow(hCBox))
        return E_INVALIDARG;

	SendMessage(hCBox, CB_RESETCONTENT, 0, 0);		// init the list

    ITVESupervisor_HelperPtr spSuperHelper(spSuper);
	int iAdapt = 0;
	CComBSTR spbsAdapter;			// TODO - this interface Sucks!  I need to know unidirectional vs. bidirectional ones
	bool fItsAUniDiAddr = true;

	while(S_OK == (hr = spSuperHelper->get_PossibleIPAdapterAddress(iAdapt,&spbsAdapter)))
	{
		SendMessage(hCBox, CB_INSERTSTRING,  -1, (LPARAM) W2T(spbsAdapter));
		SendMessage(hCBox, LB_SETITEMDATA,  iAdapt, (LPARAM) iAdapt);
		iAdapt++;
	}
	
	int cItems = SendMessage(hCBox, CB_GETCOUNT, 0, 0);
	SendMessage(hCBox, CB_SETCURSEL, 0, 0);
	

    return S_OK;
}

struct CTimeBoxData {
    BSTR m_Bs;
    DATE m_DateOffset;
};

static const CTimeBoxData kTimeBoxData[] =
{
    L"-1 C",   -365.25 * 100,
    L"-10 Y",  -365.25*10,
    L"-1 Y",   -365.25,
    L"-1 M",   -30.0,
    L"-1 W",   -7.0,
    L"-1 D",   -1.0,
    L"-1 H",   -1.0 / (24.0 ),
    L"-5 m",   -5.0 / (24.0 * 60),      //  This way for expiring things early
    L"none",   0,                       //-----------------
    L" 5 m",    5.0 / (24.0 * 60),      //  This way to keep old shows alive
    L" 1 H",    1.0 / (24.0 ),
    L" 1 D",    1.0,
    L" 1 W",    7.0,
    L" 1 M",    30.0,
    L" 1 Y",    365.25,
    L" 10 Y",   365.25 * 10,
    L" 1 C",    365.25 * 100,
    L"",        0.0
};
	
	
HRESULT
SetupShiftTimeBox(HWND hCBox)
{
    HRESULT hr = S_OK;

    if(!::IsWindow(hCBox))
        return E_INVALIDARG;

	SendMessage(hCBox, CB_RESETCONTENT, 0, 0);		// init the list

	int iTime = 0;
    int iTimeZero = 0;

	while(wcslen(kTimeBoxData[iTime].m_Bs) > 0)
	{
		SendMessage(hCBox, CB_INSERTSTRING,  -1, (LPARAM) W2T(kTimeBoxData[iTime].m_Bs));
                        // since can only store LPARAMS, convert DATE data to #secs
		long lSecs = long(24*60*60*kTimeBoxData[iTime].m_DateOffset);
		SendMessage(hCBox, LB_SETITEMDATA,  iTime, (LPARAM) lSecs);		// this doesn't seem to work...
        if(kTimeBoxData[iTime].m_DateOffset == 0.0)
            iTimeZero = iTime;
		iTime++;
	}
	
	int cItems = SendMessage(hCBox, CB_GETCOUNT, 0, 0);
	SendMessage(hCBox, CB_SETCURSEL, iTimeZero, 0);

    return S_OK;
}

LRESULT  
CTveView::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	HRESULT hr = S_OK;

			// override the IE address EditBox's message hander
	HWND hwndEdit     = GetDlgItem(IDC_EDIT_ADDRESS); 
	m_hWndProgressBar = GetDlgItem(IDC_IE_PROGCTRL);
	m_hWndEditLog     = GetDlgItem(IDC_TVEEDITLOG);
	m_hWndCBox        = GetDlgItem(IDC_COMBO_ADAPTER);
	m_hWndCBoxTime    = GetDlgItem(IDC_COMBO_SHIFTTIME);


    SendMessage(m_hWndProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0, 100)); 
    SendMessage(m_hWndProgressBar, PBM_SETSTEP, (WPARAM) 1, 0); 
 
//	SendMessage(m_hWndListWindow,  LB_SETHORIZONTALEXTENT, (WPARAM) 2000, 0);
	SendMessage(m_hWndEditLog,  EM_LIMITTEXT, (WPARAM) 100000, 0);

        // Subclass the edit control.		// nasty code - stuff into a Yecky Global
	gwpOrigAddressEditProc = (WNDPROC) ::SetWindowLong(hwndEdit, GWL_WNDPROC, (LONG)((LONG *)MyAddressEditWndProc)); 

  
				// get (and cache) the control objects....
	GetDlgControl(IDC_TVETREE, TveTreeViewLib::IID_ITveTree, (void **) &m_spTveTree);
	GetDlgControl(IDC_EXPLORER, IID_IWebBrowserApp, (void **) &m_spWebBrowser);

    if(NULL == m_spTveTree) 
    {
        MessageBox(_T("Failed to get TveTreeView Control"),_T("TvEViewer Error"),MB_OK);
        hr = E_NOINTERFACE;
    } else {
        ITVESupervisorPtr spSuper;
        m_spTveTree->get_Supervisor(&spSuper);
        SetupIPAdapterAddrs(m_hWndCBox, spSuper);
        SetupShiftTimeBox(m_hWndCBoxTime);
        
        ITVEServicesPtr spServices;
        hr = spSuper->get_Services(&spServices);
        if(!FAILED(hr))                                 // try to get a name for this service...
        {
            CComVariant cv(0);                          // wrong - really want the active service... This will do for now
            ITVEServicePtr spService;
            hr = spServices->get_Item(cv, &spService);
            CComBSTR spbsDesc;
            if(NULL != spService)
                spService->get_Description(&spbsDesc);
        }
    }
	if(NULL == m_spWebBrowser) 
	{
		MessageBox(_T("Failed to get WebBrowser Control"),_T("TvEViewer Error"),MB_OK);
		hr = E_NOINTERFACE;
	}

	if(FAILED(hr))

//		HRESULT hr = m_ppUnk[0]->QueryInterface(IID_ITveTree, reinterpret_cast<void**>(&spTveTree));
	if(FAILED(hr))
		return hr;
	return 0;
}

LRESULT  
CTveView::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
        // Remove the subclass from the edit control. 
        HWND hwndEdit = GetDlgItem(IDC_EDIT_ADDRESS); 
		if(gwpOrigAddressEditProc)
			::SetWindowLong(hwndEdit, GWL_WNDPROC, (LONG) gwpOrigAddressEditProc);
		gwpOrigAddressEditProc = NULL;
        // 
        // Continue the cleanup procedure. 
        // 
       return 0;
}

/*
LRESULT  
CTveView::OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	// TODO : Add Code for message handler. Call DefWindowProc if necessary.
	return 0;
} */

LRESULT  
CTveView::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	// TODO : Add Code for message handler. Call DefWindowProc if necessary.
	return 0;
}
// ---------------------------------------------------------------------------------
// IE Button Events
// ---------------------------------------------------------------------------------
LRESULT 
CTveView::OnClicked_IE_Back(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	HRESULT hr = m_spWebBrowser->GoBack();
	return 0;
}

LRESULT 
CTveView::OnClicked_IE_Forward(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	HRESULT hr = m_spWebBrowser->GoForward();
	return 0;
}

LRESULT 
CTveView::OnClicked_IE_Stop(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	HRESULT hr = m_spWebBrowser->Stop();
	return 0;
}

LRESULT 
CTveView::OnClicked_IE_Refresh(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	HRESULT hr = m_spWebBrowser->Refresh();
	return 0;
}

LRESULT 
CTveView::OnClicked_IE_Home(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	HRESULT hr = m_spWebBrowser->GoHome();
	return 0;
}

// --------------------------------------------------------------------------
//  IE Address string
// --------------------------------------------------------------------------
LRESULT 
CTveView::OnChangeEdit_Address(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	const int kSz = 1024;
	TCHAR tsAddress[kSz];
	GetDlgItemText(IDC_EDIT_ADDRESS, tsAddress, kSz);

	TCHAR tsBuff[kSz];
	_stprintf(tsBuff,_T("SetFocus     - %s\n"),tsAddress);
	OutputDebugString(tsBuff);
	
	return 0;
}



LRESULT 
CTveView::OnKillfocusEdit_Address(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	const int kSz = 1024;
	TCHAR tsAddress[kSz];
	GetDlgItemText(IDC_EDIT_ADDRESS, tsAddress, kSz);

	CComVariant varZero(0);
	CComVariant varNull(_T(""));
	CComBSTR bstrAddr(tsAddress);

	TCHAR tsBuff[kSz];
	_stprintf(tsBuff,_T("KillFocus - %s\n)"),tsAddress);
	OutputDebugString(tsBuff);
									// getting 0x1 0x1 in the middle of the address.. skip up to it.

	HRESULT hr;
	CComBSTR bstrTmp;
	CleanIEAddress( bstrAddr, &bstrTmp);		
	if(m_spWebBrowser)
		hr = m_spWebBrowser->Navigate(bstrTmp, &varZero, &varNull, &varNull, &varNull);
	return 0;
}


LRESULT 
CTveView::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	const int kSz = 1024;
	TCHAR tsAddress[kSz];
	GetDlgItemText(IDC_EDIT_ADDRESS, tsAddress, kSz);

	CComVariant varZero(0);
	CComVariant varNull(_T(""));
	CComBSTR bstrAddr(tsAddress);

	TCHAR tsBuff[kSz];
	_stprintf(tsBuff,_T("OnOK - %s\n"),tsAddress);
	OutputDebugString(tsBuff);
									// getting 0x1 0x1 in the middle of the address.. skip up to it.

	HRESULT hr;
	CComBSTR bstrTmp;
	CleanIEAddress( bstrAddr, &bstrTmp);		
	if(m_spWebBrowser)
		hr = m_spWebBrowser->Navigate(bstrTmp, &varZero, &varNull, &varNull, &varNull);
	return TRUE;
}

LRESULT 
CTveView::OnSetfocusEdit_Address(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	const int kSz = 1024;
	TCHAR tsAddress[kSz];
	GetDlgItemText(IDC_EDIT_ADDRESS, tsAddress, kSz);

	return 0;
}

LRESULT 
CTveView::OnUpdateEdit_Address(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	const int kSz = 1024;
	TCHAR tsAddress[kSz];
	GetDlgItemText(IDC_EDIT_ADDRESS, tsAddress, kSz);

	TCHAR tsBuff[kSz];
	_stprintf(tsBuff,_T("Update    - %s\n"),tsAddress);
	OutputDebugString(tsBuff);
	
	return 0;
}

LRESULT 
CTveView::OnMaxtextEdit_Address(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	const int kSz = 1024;
	TCHAR tsAddress[kSz];
	GetDlgItemText(IDC_EDIT_ADDRESS, tsAddress, kSz);

	CComVariant varZero(0);
	CComVariant varNull("");
	CComBSTR bstrAddr(tsAddress);

	TCHAR tsBuff[kSz];
	_stprintf(tsBuff,_T("MaxText - %s\n"),tsAddress);
	OutputDebugString(tsBuff);

	HRESULT hr;
	CComBSTR bstrTmp;
	CleanIEAddress( bstrAddr, &bstrTmp);		// I'm not sure about all this cleaning of user input, but what-the-hey	
	if(m_spWebBrowser)
		hr = m_spWebBrowser->Navigate(bstrTmp, &varZero, &varNull, &varNull, &varNull); 

	return 0;
}

// --------------------------------------------------------------------------
// Station string
// --------------------------------------------------------------------------
LRESULT 
CTveView::OnChangeEdit_Station(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	return 0;
}

LRESULT 
CTveView::OnKillfocusEdit_Station(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    USES_CONVERSION;
	const int kSz = 1024;
	TCHAR tsStation[kSz];
	GetDlgItemText(IDC_EDIT_STATION, tsStation, kSz);
	OutputDebugString(tsStation);

	return 0;
}

LRESULT 
CTveView::OnSetfocusEdit_Station(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
	return 0;
}

LRESULT 
CTveView::OnUpdateEdit_Station(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{

	return 0;
}

LRESULT 
CTveView::OnClicked_ButtonTune(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    USES_CONVERSION;
	const int kSz = 1024;
	TCHAR tsStation[kSz];
    TCHAR tsIPAdapter[kSz];
    GetDlgItemText(IDC_EDIT_STATION, tsStation, kSz);
	if(0 == _tcslen(tsStation)) {						// don't allow null station names...
		Beep(3000,200);Beep(300,100);Beep(2000,200);
		return 0;
	}

    int iSel =  SendMessage( m_hWndCBox, CB_GETCURSEL, 0, 0);
    SendMessage(m_hWndCBox, CB_GETLBTEXT, iSel, (LPARAM) &tsIPAdapter);

    iSel =  SendMessage( m_hWndCBoxTime, CB_GETCURSEL, 0, 0);
    DATE dateOffset;
    dateOffset = (SendMessage(m_hWndCBoxTime, CB_GETITEMDATA , iSel, 0))/(24.0 * 60 * 60);	// doesn't seem to work...

	dateOffset = kTimeBoxData[iSel].m_DateOffset;;

   // The correct way do to this, but needs a VidCtl
    ITVEFeaturePtr spFeature;
    hr = m_spTVENavAid->get_TVEFeature(&spFeature);
    if(NULL != spFeature)
    {
        spFeature->TuneTo(tsStation, tsIPAdapter);          
                // ITVEFeature inherits for ITVEService... Should this work?
        spFeature->put_ExpireOffset(dateOffset);
        spFeature->ExpireForDate(0.0);              // expire things now...
     } else {
        ITVESupervisorPtr spSuper;
       if(NULL != m_spTveTree)
            hr = m_spTveTree->get_Supervisor(&spSuper);
        if(NULL != spSuper)
           hr = spSuper->TuneTo(tsStation, tsIPAdapter);
        
                // get the active service...
        ITVEServicePtr spServiceActive;
        if(!FAILED(hr) && NULL != spSuper)
        {
           ITVEServicesPtr spServices;
           hr = spSuper->get_Services(&spServices);
           if(!FAILED(hr) && NULL != spServices)
           {
               long cItems;
               hr = spServices->get_Count(&cItems);
               _ASSERT(!FAILED(hr));
                for(int i = 0; i < cItems; i++)
               {
                   CComVariant cv(i);
                   ITVEServicePtr spService;
                   spServices->get_Item(cv, &spService);
                   VARIANT_BOOL fIsActive;
                   spService->get_IsActive(&fIsActive);
                   if(fIsActive)
                   {
                       spServiceActive = spService;
                       break;
                   }
               }
           }
        }
        if(NULL != spServiceActive)
        {
            spServiceActive->put_ExpireOffset(dateOffset);
            spServiceActive->ExpireForDate(0.0);
        }
     }
 
	return 0;
}

LRESULT 
CTveView::OnSelChanged_ComboTime(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int iSel =  SendMessage( m_hWndCBoxTime, CB_GETCURSEL, 0, 0);
    DATE dateOffset;
 
	dateOffset = kTimeBoxData[iSel].m_DateOffset;;

    ITVEFeaturePtr spFeature;
    HRESULT hr = m_spTVENavAid->get_TVEFeature(&spFeature);
    if(NULL != spFeature)
    {
                // ITVEFeature inherits for ITVEService... Should this work?
        spFeature->put_ExpireOffset(dateOffset);
        spFeature->ExpireForDate(0.0);              // expire things now...
     } else {
        ITVESupervisorPtr spSuper;
       if(NULL != m_spTveTree)
            hr = m_spTveTree->get_Supervisor(&spSuper);
        
                // get the active service...
        ITVEServicePtr spServiceActive;
        if(!FAILED(hr) && NULL != spSuper)
        {
           ITVEServicesPtr spServices;
           hr = spSuper->get_Services(&spServices);
           if(!FAILED(hr) && NULL != spServices)
           {
               long cItems;
               hr = spServices->get_Count(&cItems);
               _ASSERT(!FAILED(hr));
                for(int i = 0; i < cItems; i++)
               {
                   CComVariant cv(i);
                   ITVEServicePtr spService;
                   spServices->get_Item(cv, &spService);
                   VARIANT_BOOL fIsActive;
                   spService->get_IsActive(&fIsActive);
                   if(fIsActive)
                   {
                       spServiceActive = spService;
                       break;
                   }
               }
           }
        }
        if(NULL != spServiceActive)
        {
            spServiceActive->put_ExpireOffset(dateOffset);
            spServiceActive->ExpireForDate(0.0);
        }
     }
 
    return 0;
}


LRESULT 
CTveView::OnClicked_ButtonUnTune(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    USES_CONVERSION;

    ITVESupervisorPtr spSuper;
    if(m_spTveTree)
        hr = m_spTveTree->get_Supervisor(&spSuper);
    if(spSuper)
        hr = spSuper->TuneTo(NULL, NULL);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tveviewer\tveview.h ===
// TveView.h : Declaration of the CTveView

#ifndef __TVEVIEW_H_
#define __TVEVIEW_H_

#include "resource.h"       // main symbols
#include <atlctl.h>

_COM_SMARTPTR_TYPEDEF(ITVENavAid,               __uuidof(ITVENavAid));

LRESULT CALLBACK MyAddressEditWndProc(
	HWND hwnd,        // handle to window
	UINT uMsg,        // message identifier
	WPARAM wParam,    // first message parameter
	LPARAM lParam);    // second message parameter


extern WNDPROC gwpOrigAddressEditProc; 
/////////////////////////////////////////////////////////////////////////////
// CTveView
class ATL_NO_VTABLE CTveView : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CStockPropImpl<CTveView, ITveView, &IID_ITveView, &LIBID_TveViewerLib>,
	public CComCompositeControl<CTveView>,
	public IPersistStreamInitImpl<CTveView>,
	public IOleControlImpl<CTveView>,
	public IOleObjectImpl<CTveView>,
	public IOleInPlaceActiveObjectImpl<CTveView>,
	public IViewObjectExImpl<CTveView>,
	public IOleInPlaceObjectWindowlessImpl<CTveView>,
	public IPersistStorageImpl<CTveView>,
	public ISpecifyPropertyPagesImpl<CTveView>,
	public IQuickActivateImpl<CTveView>,
	public IDataObjectImpl<CTveView>,
	public IProvideClassInfo2Impl<&CLSID_TveView, NULL, &LIBID_TveViewerLib>,
	public CComCoClass<CTveView, &CLSID_TveView>,
	public IConnectionPointContainerImpl<CTveView>
{
public:
	CTveView()
	{
	
		m_dwEventsTveSuperCookie   = 0;
		m_dwEventsWebBrowserCookie = 0;
		m_dwEventsTveTreeCookie    = 0;
		m_bWindowOnly = TRUE;
		CalcExtent(m_sizeExtent);

		m_hWndEditLog = 0;
		m_hWndProgressBar = 0;

		m_iDelPercent  = 5;
		m_iPercent	   = 0;

        m_fpLogOut      = 0;
        m_iTonePri      = 5;
	}

	~CTveView() 
	{
		int x = 0;
		x++;				// place to hang a breakpoint
	};
	
	HRESULT FinalConstruct();
    HRESULT ReleaseEverything();        // for some reason, FinalRelase not getting called.  Call this is DestroyWindow
	HRESULT FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_TVEVIEW)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTveView)
	COM_INTERFACE_ENTRY(ITveView)
//	COM_INTERFACE_ENTRY(IDispatch)
	                // magic lines of code, support _ITVEEvents as IDispatch...
	COM_INTERFACE_ENTRY2(IDispatch, ITveView)
	COM_INTERFACE_ENTRY_IID(__uuidof(_ITVEEvents), IDispatch)		// MSTvELib::DIID__ITVEEvents, IDispatch)	
	COM_INTERFACE_ENTRY_IID(__uuidof(TveTreeViewLib::_ITVETreeEvents), IDispatch) // TveTreeViewLib::DIID__ITVETreeEvents, IDispatch)	

	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_PROP_MAP(CTveView)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	PROP_ENTRY("AutoSize", DISPID_AUTOSIZE, CLSID_NULL)
	PROP_ENTRY("BackColor", DISPID_BACKCOLOR, CLSID_StockColorPage)
	PROP_ENTRY("BorderColor", DISPID_BORDERCOLOR, CLSID_StockColorPage)
	PROP_ENTRY("BorderStyle", DISPID_BORDERSTYLE, CLSID_NULL)
	PROP_ENTRY("Caption", DISPID_CAPTION, CLSID_NULL)
	PROP_ENTRY("Enabled", DISPID_ENABLED, CLSID_NULL)
	PROP_ENTRY("FillColor", DISPID_FILLCOLOR, CLSID_StockColorPage)
	PROP_ENTRY("ForeColor", DISPID_FORECOLOR, CLSID_StockColorPage)
	PROP_ENTRY("HWND", DISPID_HWND, CLSID_NULL)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CTveView)
	CHAIN_MSG_MAP(CComCompositeControl<CTveView>)
	MESSAGE_HANDLER(WM_CLOSE, OnClose)
	MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
//	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
	MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
	COMMAND_ID_HANDLER(IDOK,	OnOK)						// subclassed to pick up <CR> out of address box
	COMMAND_HANDLER(IDC_IE_BACK, BN_CLICKED, OnClicked_IE_Back)
	COMMAND_HANDLER(IDC_IE_FORWARD, BN_CLICKED, OnClicked_IE_Forward)
	COMMAND_HANDLER(IDC_IE_STOP, BN_CLICKED, OnClicked_IE_Stop)
	COMMAND_HANDLER(IDC_IE_REFRESH, BN_CLICKED, OnClicked_IE_Refresh)
	COMMAND_HANDLER(IDC_IE_HOME, BN_CLICKED, OnClicked_IE_Home)

	COMMAND_HANDLER(IDC_EDIT_STATION, EN_CHANGE, OnChangeEdit_Station)
	COMMAND_HANDLER(IDC_EDIT_STATION, EN_KILLFOCUS, OnKillfocusEdit_Station)
	COMMAND_HANDLER(IDC_EDIT_STATION, EN_SETFOCUS, OnSetfocusEdit_Station)
	COMMAND_HANDLER(IDC_EDIT_STATION, EN_UPDATE, OnUpdateEdit_Station)

	COMMAND_HANDLER(IDC_EDIT_ADDRESS, EN_CHANGE, OnChangeEdit_Address)
	COMMAND_HANDLER(IDC_EDIT_ADDRESS, EN_KILLFOCUS, OnKillfocusEdit_Address)
	COMMAND_HANDLER(IDC_EDIT_ADDRESS, EN_SETFOCUS, OnSetfocusEdit_Address)
	COMMAND_HANDLER(IDC_EDIT_ADDRESS, EN_UPDATE, OnUpdateEdit_Address)
	COMMAND_HANDLER(IDC_EDIT_ADDRESS, EN_MAXTEXT, OnMaxtextEdit_Address)

   	COMMAND_HANDLER(IDC_BUTTON_TUNE,  BN_CLICKED, OnClicked_ButtonTune)
   	COMMAND_HANDLER(IDC_BUTTON_UNTUNE,BN_CLICKED, OnClicked_ButtonUnTune)

    COMMAND_HANDLER(IDC_COMBO_SHIFTTIME, CBN_SELCHANGE, OnSelChanged_ComboTime)

END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

BEGIN_SINK_MAP(CTveView)
	//Make sure the Event Handlers have __stdcall calling convention
END_SINK_MAP()

	STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
	{
		if (dispid == DISPID_AMBIENT_BACKCOLOR)
		{
			SetBackgroundColorFromAmbient();
			FireViewChange();
		}
		return IOleControlImpl<CTveView>::OnAmbientPropertyChange(dispid);
	}



// IViewObjectEx
	DECLARE_VIEW_STATUS(0)

// ITveView
public:
	OLE_COLOR m_clrBackColor;
	OLE_COLOR m_clrBorderColor;
	LONG m_nBorderStyle;
	CComBSTR m_bstrCaption;
	BOOL m_bEnabled;
	OLE_COLOR m_clrFillColor;
	OLE_COLOR m_clrForeColor;

	enum { IDD = IDD_TVEVIEW };	
	

			// UI Events;
	LRESULT OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//	LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);


		// _ITVEEvents
	STDMETHOD(NotifyTVETune)(/*[in]*/ NTUN_Mode tuneMode,/*[in]*/ ITVEService *pService,/*[in]*/ BSTR bstrDescription,/*[in]*/ BSTR bstrIPAdapter);
	STDMETHOD(NotifyTVEEnhancementNew)(/*[in]*/ ITVEEnhancement *pEnh);
		// changedFlags : NENH_grfDiff
	STDMETHOD(NotifyTVEEnhancementUpdated)(/*[in]*/ ITVEEnhancement *pEnh, /*[in]*/ long lChangedFlags);	
	STDMETHOD(NotifyTVEEnhancementStarting)(/*[in]*/ ITVEEnhancement *pEnh);
	STDMETHOD(NotifyTVEEnhancementExpired)(/*[in]*/ ITVEEnhancement *pEnh);
	STDMETHOD(NotifyTVETriggerNew)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive);
		// changedFlags : NTRK_grfDiff
	STDMETHOD(NotifyTVETriggerUpdated)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive, /*[in]*/ long lChangedFlags);	
	STDMETHOD(NotifyTVETriggerExpired)(/*[in]*/ ITVETrigger *pTrigger,/*[in]*/  BOOL fActive);
	STDMETHOD(NotifyTVEPackage)(/*[in]*/ NPKG_Mode engPkgMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUUID, /*[in]*/ long  cBytesTotal, /*[in]*/ long  cBytesReceived);
	STDMETHOD(NotifyTVEFile)(/*[in]*/ NFLE_Mode engFileMode, /*[in]*/ ITVEVariation *pVariation, /*[in]*/ BSTR bstrUrlName, /*[in]*/ BSTR bstrFileName);
		// WhatIsIt : NWHAT_Mode - lChangedFlags : NENH_grfDiff or NTRK_grfDiff treated as error bits
	STDMETHOD(NotifyTVEAuxInfo)(/*[in]*/ NWHAT_Mode enAuxInfoMode, /*[in]*/ BSTR bstrAuxInfoString, /*[in]*/ long lChangedFlags, /*[in]*/ long lErrorLine);	


		// _ITVETreeEvents
	STDMETHOD(NotifyTVETreeTuneTrigger)(/*[in]*/ ITVETrigger *pTriggerFrom, /*[in]*/ ITVETrigger *priggerTo);
	STDMETHOD(NotifyTVETreeTuneVariation)(/*[in]*/ITVEVariation *pVariationFrom, /*[in]*/  ITVEVariation *pVariationTo);
	STDMETHOD(NotifyTVETreeTuneEnhancement)(/*[in]*/ ITVEEnhancement *pEnhancementFrom, /*[in]*/  ITVEEnhancement *pEnhancementTo);
	STDMETHOD(NotifyTVETreeTuneService)(/*[in]*/ ITVEService *pServiceFrom, /*[in]*/  ITVEService *pServiceTo);

		// DWebBrowserEvents2
	STDMETHOD(NotifyStatusTextChange)(BSTR Text);
	STDMETHOD(NotifyProgressChange)(LONG Progress, LONG ProgressMax);
	STDMETHOD(NotifyCommandStateChange)(LONG Command, VARIANT_BOOL Enable);
	STDMETHOD(NotifyDownloadBegin)();
	STDMETHOD(NotifyDownloadComplete)();
	STDMETHOD(NotifyTitleChange)(BSTR Text);
	STDMETHOD(NotifyPropertyChange)(BSTR szProperty);
	STDMETHOD(NotifyBeforeNavigate2)(IDispatch * pDisp, VARIANT * URL, VARIANT * Flags, VARIANT * TargetFrameName, VARIANT * PostData, VARIANT * Headers, VARIANT_BOOL * Cancel);
	STDMETHOD(NotifyNewWindow2)(IDispatch * * ppDisp, VARIANT_BOOL * Cancel);
	STDMETHOD(NotifyNavigateComplete2)(IDispatch * pDisp, VARIANT * URL);
	STDMETHOD(NotifyDocumentComplete)(IDispatch * pDisp, VARIANT * URL);
	STDMETHOD(NotifyOnQuit)();
	STDMETHOD(NotifyOnVisible)(VARIANT_BOOL Visible);
	STDMETHOD(NotifyOnToolBar)(VARIANT_BOOL ToolBar);
	STDMETHOD(NotifyOnMenuBar)(VARIANT_BOOL MenuBar);
	STDMETHOD(NotifyOnStatusBar)(VARIANT_BOOL StatusBar);
	STDMETHOD(NotifyOnFullScreen)(VARIANT_BOOL FullScreen);
	STDMETHOD(NotifyOnTheaterMode)(VARIANT_BOOL TheaterMode);

			// overrides.
public:
	HRESULT InPlaceActivate(LONG iVerb, const RECT *prcPosRect);

private:
		CComBSTR							m_spbsStationID;
		TveTreeViewLib::ITveTreePtr			m_spTveTree;
		IWebBrowserAppPtr					m_spWebBrowser;
		
		HWND								m_hWndEditLog;
		HWND								m_hWndProgressBar;
        HWND                                m_hWndCBox;
        HWND                                m_hWndCBoxTime;

		IConnectionPointContainerPtr		m_spCPC;
		DWORD								m_dwEventsWebBrowserCookie;
		DWORD								m_dwEventsTveSuperCookie;
		DWORD								m_dwEventsTveTreeCookie;


			// AtvefState	
//		MSTvELib::ITVENavAidPtr	 m_spTVENavAid;
		ITVENavAidPtr	        m_spTVENavAid;
//		ITVENavAid	        *m_spTVENavAid;

			// local methods

		HRESULT TagIt(BSTR bstrEventName, BSTR bstrStr1, BSTR bstrStr2, BSTR bstrStr3);
        HRESULT CreateLogFile();

        FILE                *m_fpLogOut;
        int                 m_iTonePri;         // PlayBeep priority must be < than this to beep.
        void                PlayBeep(int iPri, int iTone);
public :

BEGIN_CONNECTION_POINT_MAP(CTveView)
END_CONNECTION_POINT_MAP()

	// UI events
	LRESULT OnClicked_IE_Back(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnClicked_IE_Forward(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnClicked_IE_Stop(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnClicked_IE_Refresh(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnClicked_IE_Home(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnChangeEdit_Station(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnKillfocusEdit_Station(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnSetfocusEdit_Station(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnUpdateEdit_Station(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnChangeEdit_Address(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnKillfocusEdit_Address(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnSetfocusEdit_Address(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnUpdateEdit_Address(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
	LRESULT OnMaxtextEdit_Address(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnClicked_ButtonTune(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnClicked_ButtonUnTune(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelChanged_ComboTime(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:

	int m_iDelPercent;		// progress bar indicators...
	int	m_iPercent; 
};
#endif //__TVEVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tveviewer\tveevents.cpp ===
// ------------------------------------
// TveEvents.cpp
//
//
//		Other than the NotifyTVETreeTuneTrigger() event which is used by the user to
//		tune to cached triggers, these events are purely for U/I info.  The TVENavAid
//		catches these same events and executes on them
// -----------------------------------
#include "stdafx.h"
#include "TveContainer.h"

#include "Mshtml.h"	// to get the IHTMLDocument2 interface
#include "math.h"

// -------------------------------------------------------------------------
//			simple list control to record and display the last N events.
//

extern DateToBSTR(DATE date);

HRESULT CTveView::CreateLogFile()
{
    if(0 != m_fpLogOut)
        fclose(m_fpLogOut);  m_fpLogOut = 0;

    SYSTEMTIME sysTime;
    GetLocalTime(&sysTime);

    WCHAR wszBuff[128];
    int iTimeZoneOffset = -7;       // PST Daylight savings time
    wsprintf(wszBuff,L"c:\\TVE-%d-%d-%d.log", sysTime.wDay, sysTime.wHour, sysTime.wMinute); // unique string
    m_fpLogOut = _wfopen(wszBuff,L"w");

    return S_OK;
}

// middle C (440 Hz) or is it A?
//  2^(1/12)

static void
GenTones(DWORD *rgArray, int cTones, int iMiddleA)  // generates frequences
{
    double fFact = pow(2.0, 1.0 / 12.0);
    double MiddleA = 440;
    for(int i = iMiddleA; i < cTones; i++)
    {
        rgArray[i] = DWORD(0.5 + MiddleA * pow(2.0, (i-iMiddleA) / 12.0));
    }
    for(int i = iMiddleA; i >= 0; --i)
    {
        rgArray[i] = DWORD(0.5 + MiddleA / pow(2.0, (iMiddleA-i) / 12.0));
    }
}

//  -------------
//   A A#  B  C C#  D D#  E  F F#  G G#  A A#  B  C C#  D
//   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
//            0     1     2  3     4     5     6
//  44 45 47 47

const int nMiddleA = 44;
const int  nS      = 999;               // silence
const int  nC      = (3+nMiddleA);
const int  nCS     = (4+nMiddleA);
const int  nD      = (5+nMiddleA);
const int  nDS     = (6+nMiddleA);
const int  nE      = (7+nMiddleA);
const int  nF      = (8+nMiddleA);
const int  nFS     = (9+nMiddleA);
const int  nG      = (10+nMiddleA);
const int  nGS     = (11+nMiddleA);
const int  nA      = (12+nMiddleA);
const int  nAS     = (13+nMiddleA);
const int  nB      = (14+nMiddleA);
const int  n1      = 12;                // an Octive
const int  n2      = 24;                // two Octive
const int  n3      = 35;                // three Octives

static void
Note(int nNote, int nDur)           // duration in 8th notes
{
    const int kTones=88;
    static DWORD rgToneArray[kTones];
    static int iMiddleA = 0;

    if(iMiddleA == 0)
    {
        iMiddleA = nMiddleA;
        GenTones(rgToneArray, kTones, iMiddleA);
    }
    const int nRate8th = 1000/8;
    if(nNote < 0 || nNote >= kTones)
        Sleep(nDur * nRate8th);
    else
        Beep(rgToneArray[nNote], nRate8th);
}

const int SONG_BeepC    = 1;
const int SONG_BeepF    = 2;
const int SONG_BeepA    = 3;
const int SONG_BeepUp   = 10;
const int SONG_BeepDown = 11;
const int SONG_ScaleUp  = 12;
const int SONG_ScaleDown = 13;
const int SONG_Bs5th     = 14;
const int SONG_UtOh      = 15;
void CTveView::PlayBeep(int iPri, int iTone)
{

    if(iPri < m_iTonePri)
    {
        switch(iTone)
        {
        case 0:                 // no note
            break;              
        default: 
        case SONG_BeepC:                 // simple C
            Note(nC,4); break;
        case SONG_BeepF:                 // simple F
            Note(nF,4); break;
        case SONG_BeepA:                 // simple A
            Note(nA,4); break;
        case SONG_BeepUp:                 
            Note(nC,1);Note(nC,1);Note(nF,2); break;
        case SONG_BeepDown:
            Note(nF,1);Note(nF,1);Note(nC,2); break;
        case SONG_ScaleUp: // scale up
            Note(nC,2);Note(nD,2);Note(nE,2);Note(nF,2);Note(nG,2);Note(nA,2);Note(nB,2);Note(nC+n1,2); break;
        case SONG_ScaleDown: // scale down
            Note(nC+n1,2);Note(nB,2);Note(nA,2);Note(nG,2);Note(nF,2);Note(nE,2);Note(nD,2);Note(nC,2); break;
        case SONG_Bs5th: // B's 5'th
            Note(nE,1);Note(nE,1);Note(nE,1);Note(nC,4);Note(nS,2);Note(nD,1);Note(nD,1);Note(nD,1);Note(nB-n1,4); break;
        case SONG_UtOh: // Ut Oh
            Note(nG,1);Note(nD,4); break;
        }
    }
}

const int SONG_Tune         = SONG_BeepUp;
const int SONG_NewEnh       = SONG_Bs5th;
const int SONG_UpdateEnh    = SONG_BeepC;
const int SONG_StartEnh     = SONG_ScaleUp;
const int SONG_ExpireEnh    = SONG_ScaleDown;
const int SONG_NewTrig      = SONG_BeepF;
const int SONG_UpdateTrig   = SONG_BeepA;
const int SONG_ExpTrig      = 0;
const int SONG_Package      = 0;
const int SONG_File         = SONG_BeepA;
const int SONG_AuxInfo      = SONG_UtOh;

HRESULT CTveView::TagIt(BSTR bstrEventName, BSTR bstrStr1, BSTR bstrStr2, BSTR bstrStr3)
{

	static int cChars = 0;
	static int cLines = 0;

	if(!::IsWindow(m_hWndEditLog))		// to avoid sending data to a destroyed window...
		return S_FALSE;
  
	if(cChars > 99000)		// list box can only hold 65K bytes of data... Clear it before it gets to large
	{
		SendMessage( m_hWndEditLog, WM_SETTEXT , 0, (LPARAM) _T("\r\n."));  	// clear previous items
		cChars=4;
	}

	const int kChars=512;
	USES_CONVERSION;

    SYSTEMTIME sysTime;
    GetLocalTime(&sysTime);

 	WCHAR szbuff[kChars];
	_snwprintf(szbuff,kChars-1,L"%02d:%02d:%02d %10s: %s, %s %s\r\n.",
                    sysTime.wHour, sysTime.wMinute, sysTime.wSecond,
                    bstrEventName, bstrStr1, bstrStr2, bstrStr3);
	szbuff[kChars-1] = 0;				// just in case we are overrunning the size....

    int cTextLength = SendMessage( m_hWndEditLog, WM_GETTEXTLENGTH, 0, 0);  
    SendMessage( m_hWndEditLog, EM_SETSEL, cTextLength-1, cTextLength);
	SendMessage( m_hWndEditLog, EM_REPLACESEL, false, (LPARAM) W2T(szbuff));

    if(!m_fpLogOut)
		CreateLogFile();
	
    if(m_fpLogOut) {
       fwprintf(m_fpLogOut,L"%s\n",szbuff);
       fflush(m_fpLogOut);
    }

	cChars += wcslen(szbuff);

	return S_OK;
}

STDMETHODIMP CTveView::NotifyTVETune( NTUN_Mode tuneMode,  ITVEService *pService, BSTR bstrDescription, BSTR bstrIPAdapter)
{
    PlayBeep(1,SONG_Tune);
	TagIt(L"Tune",bstrDescription,bstrIPAdapter,L"");
	return S_OK;
}

STDMETHODIMP CTveView::NotifyTVEEnhancementNew(ITVEEnhancement *pEnh)
{
	CComBSTR spbsDesc;
    PlayBeep(1,SONG_NewEnh);

	pEnh->get_Description(&spbsDesc);
	TagIt(L"Enh New",spbsDesc,L"",L"");
	return S_OK;
}
									// changedFlags : NENH_grfDiff
STDMETHODIMP CTveView::NotifyTVEEnhancementUpdated(ITVEEnhancement *pEnh, long lChangedFlags)
{
	CComBSTR spbsDesc;
    PlayBeep(3,SONG_UpdateEnh);
    
    pEnh->get_Description(&spbsDesc);
	TagIt(L"Enh Update",spbsDesc,L"",L"");

	return S_OK;
}

STDMETHODIMP CTveView::NotifyTVEEnhancementStarting(ITVEEnhancement *pEnh)
{
	CComBSTR spbsDesc;
    PlayBeep(1,SONG_StartEnh);

	pEnh->get_Description(&spbsDesc);
	TagIt(L"Enh Start",spbsDesc,L"",L"");

	return S_OK;
}

STDMETHODIMP CTveView::NotifyTVEEnhancementExpired(ITVEEnhancement *pEnh)
{
	CComBSTR spbsDesc;
    PlayBeep(1, SONG_ExpireEnh);

    pEnh->get_Description(&spbsDesc);
	TagIt(L"Expire Enh",spbsDesc,L"",L"");

	return S_OK;
}

STDMETHODIMP CTveView::NotifyTVETriggerNew(ITVETrigger *pTrigger, BOOL fActive)
{
	CComBSTR spbsName, spbsURL,spbsScript;
	pTrigger->get_Name(&spbsName);
	pTrigger->get_URL(&spbsURL);
	pTrigger->get_Script(&spbsScript);

    PlayBeep(3,2);
	TagIt(L"Trig New",spbsName,spbsURL,spbsScript);

	NotifyTVETriggerUpdated(pTrigger, fActive, 0xffffffff);					// Just call the Update function
	return S_OK;
}

	// ------------------------------------------------------


									// changedFlags : NTRK_grfDiff
STDMETHODIMP CTveView::NotifyTVETriggerUpdated(ITVETrigger *pTrigger, BOOL fActive, long lChangedFlags)
{
	HRESULT hr = S_OK;

	CComBSTR spbsName, spbsURL, spbsScript;
	pTrigger->get_Name(&spbsName);
	pTrigger->get_URL(&spbsURL);
	pTrigger->get_Script(&spbsScript);

	if(lChangedFlags != 0xffffffff)
    {
        PlayBeep(3,SONG_UpdateTrig);
		TagIt(L"Trig Update",spbsName,spbsURL,spbsScript);
    }

	return hr;
}

STDMETHODIMP CTveView::NotifyTVETriggerExpired(ITVETrigger *pTrigger, BOOL fActive)
{
	CComBSTR spbsName, spbsURL, spbsScript;

	pTrigger->get_Name(&spbsName);
	pTrigger->get_URL(&spbsURL);
	pTrigger->get_Script(&spbsScript);

    PlayBeep(3,SONG_ExpTrig);
	TagIt(L"Trig Exp",spbsName,spbsURL,spbsScript);
	return S_OK;
}

STDMETHODIMP CTveView::NotifyTVEPackage(NPKG_Mode engPkgMode, ITVEVariation *pVariation, BSTR bstrUUID, long  cBytesTotal, long  cBytesReceived)
{

	CComBSTR spbsMode;
	switch(engPkgMode)
	{ 
	case NPKG_Starting:  spbsMode = L"Starting";	 break;				// brand new packet (never seen this UUID before)
	case NPKG_Received:  spbsMode = L"Received";	 break;				// correctly received and decoded a package
	case NPKG_Duplicate: spbsMode = L"Duplicate"; break;				// duplicate send of a one already successfully received (packet 0 only)
	case NPKG_Resend:    spbsMode = L"Resend";	 break;				// resend of one that wasn't received correctly before (packet 0 only)
	case NPKG_Expired:   spbsMode = L"Expired";	 break;	
	}

    PlayBeep(3,SONG_Package);
	TagIt(L"Package",spbsMode,bstrUUID,L"");
	return S_OK;
}

STDMETHODIMP CTveView::NotifyTVEFile(NFLE_Mode engFileMode, ITVEVariation *pVariation, BSTR bstrUrlName, BSTR bstrFileName)
{
	CComBSTR spbsMode;
	switch(engFileMode)
	{ 
	case NFLE_Received:	  spbsMode = L"Received"; break;			// correctly received and decoded a package
	case NFLE_Expired:	  spbsMode = L"Expired";	 break;	
	}

    PlayBeep(3,SONG_File);

	TagIt(L"File",spbsMode,bstrUrlName,bstrFileName);
	return S_OK;
}

STDMETHODIMP CTveView::NotifyTVEAuxInfo(NWHAT_Mode enAuxInfoMode, BSTR bstrAuxInfoString, long lChangedFlags, long lErrorLine)	// WhatIsIt is NWHAT_Mode - lChangedFlags is NENH_grfDiff or NTRK_grfDiff treated as error bits 
{
	CComBSTR spbsMode;

    PlayBeep(3,SONG_AuxInfo);

	switch(enAuxInfoMode)
	{ 
	case NWHAT_Announcement:	spbsMode = L"Announcement"; break;
	case NWHAT_Trigger:			spbsMode = L"Trigger";		break;	
	case NWHAT_Data:			spbsMode = L"Data";			break;		
	case NWHAT_Other:			spbsMode = L"Other";		break;	
	case NWHAT_Extra:			spbsMode = L"Extra";		break;	
	}
	const int kChars=127;
	WCHAR wszBuff[kChars+1];
	_snwprintf(wszBuff,kChars, L"Flags 0x%08x, Line %d",lChangedFlags,lErrorLine);

	TagIt(L"AuxInfo",spbsMode,wszBuff,bstrAuxInfoString);
	return S_OK;
}


			//  _ITVETreeEvents

			// selected a new trigger/track in the U/I
STDMETHODIMP CTveView::NotifyTVETreeTuneTrigger(ITVETrigger *pTriggerFrom, ITVETrigger *pTriggerTo)
{
	HRESULT hr = S_OK;

	if(NULL != pTriggerTo)
	{
		CComBSTR spbsName, spbsURL, spbsScript;
		pTriggerTo->get_Name(&spbsName);
		pTriggerTo->get_URL(&spbsURL);
		pTriggerTo->get_Script(&spbsScript);

		TagIt(L"Tune Trigger",spbsName,spbsURL,spbsScript);
	
	//	ITveTrigger spTrig2;
		m_spTVENavAid->NavUsingTVETrigger(reinterpret_cast<ITVETrigger *>(pTriggerTo), /*forceNav*/ 0x1, /*forceExec*/ 0x0);
	}

	return hr;
}

STDMETHODIMP CTveView::NotifyTVETreeTuneVariation(ITVEVariation *pVariationFrom, ITVEVariation *pVariationTo)
{
	HRESULT hr = S_OK;
	if(pVariationTo)
	{
		CComBSTR spbsDescription;
		pVariationTo->get_Description(&spbsDescription);
		TagIt(L"Tune Variation",spbsDescription,L"",L"");
	}
	return S_OK;
}
	
STDMETHODIMP CTveView::NotifyTVETreeTuneEnhancement(ITVEEnhancement *pEnhancementFrom, ITVEEnhancement *pEnhancementTo)
{
	HRESULT hr = S_OK;
	if(pEnhancementTo)
	{
		CComBSTR spbsDescription;
		pEnhancementTo->get_Description(&spbsDescription);
		TagIt(L"Tune Enhancement",spbsDescription,L"",L"");
	}
	return S_OK;
}
	
STDMETHODIMP CTveView::NotifyTVETreeTuneService(ITVEService *pServiceFrom, ITVEService *pServiceTo)
{
	HRESULT hr = S_OK;
	if(pServiceTo)
	{
		CComBSTR spbsDescription;
		pServiceTo->get_Description(&spbsDescription);
		TagIt(L"Tune Service",spbsDescription,L"",L"");
        CComBSTR spbsAdapter;
                // name of form XXX(1.2.3.4)  -- remove the ()
         WCHAR *pC = spbsDescription.m_str;
         while(*pC) {
            if(*pC == '(') 
            {
                *pC = NULL;
                                    // slightly interesting code...
                pC++;
                spbsAdapter = CComBSTR(pC);
                pC = spbsAdapter;
                while(*pC)
                {
                    if(*pC == ')')
                    {
                        *pC = NULL;
                        break;
                    }
                    pC++;
                }
                break;
            }
            pC++;
        }

        USES_CONVERSION;
	    SetDlgItemText(IDC_EDIT_STATION, spbsDescription);
        HWND hWndCBox = GetDlgItem(IDC_COMBO_ADAPTER);
        SendMessage(hWndCBox, CB_SELECTSTRING, -1, (LPARAM) W2T(spbsAdapter));

		ITVEFeaturePtr spFeature;
		ITVEServicePtr spServiceToX(pServiceTo);
		m_spTVENavAid->get_TVEFeature(&spFeature);
		if(spFeature) {
			spFeature->ReTune(spServiceToX);
		} else {
						// no Feature - must be running VidCtl-less
			ITVENavAid_NoVidCtlPtr spNavAidNoVidCtl(m_spTVENavAid);
			if(spNavAidNoVidCtl)
			{							// in this case, get the supervisor out of the special interface on the TVEFeature
				ITVESupervisorPtr	spSuper;
//				hr = spNavAidNoVidCtl->get_NoVidCtl_Supervisor(&spSuper);	// why is this different here than next line?
				hr = m_spTveTree->get_Supervisor(&spSuper);					

				// may return NULL in VidCtl case
				if(S_OK == hr && NULL != spSuper)			
					spSuper->ReTune(spServiceToX);
			} else {
				_ASSERT(hr = E_NOINTERFACE);
			}
		}
//		if(pServiceFrom) pServiceFrom->Deactivate();
//		pServiceTo->Activate();
	} else {
			// ??? - usually in a Tune(NULL,NULL) state here...
	}
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tveviewer\tveviewer.cpp ===
// TveViewer.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f TveViewerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TveViewer.h"
#include "TveViewer_i.c"

#include "TveContainer.h"		// simple window creation code all buried in one class


const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TveView, CTveView)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//


void Usage()
{
	MessageBox(NULL, _T("usage: TVEViewer [-RegServer | -UnregServer]"), _T("TveViewer - Error"), MB_OK);
	exit(0);
}


#ifdef BUILT_FROM_BUILD
extern "C" int WINAPI WinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPSTR lpCmdLine, int /*nShowCmd*/)
#else
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
#endif
{
	USES_CONVERSION;

#ifdef BUILT_FROM_BUILD
    lpCmdLine = W2A(GetCommandLine()); //this line necessary for _ATL_MIN_CRT
#else
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
#endif

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif
    _ASSERTE(SUCCEEDED(hRes));
    _Module.Init(ObjectMap, hInstance, &LIBID_TveViewerLib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
	BOOL fUsage = false;
#ifdef BUILT_FROM_BUILD
    LPCTSTR lpszToken = FindOneOf(A2T(lpCmdLine), szTokens);
#else
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
#endif
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_TveViewer, FALSE);
            nRet = _Module.UnregisterServer(TRUE);
            bRun = FALSE;
			MessageBox(NULL, _T("Unregistered"), _T("TveViewer"), MB_OK);

            break;
        } else if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_TveViewer, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
	//		MessageBox(NULL, _T("Registered"), _T("TveViewer"), MB_OK);

            break;
        } else { 
			Usage();
		}
    }

#ifdef _DEBUG
	_CrtMemState s1, s2, s3;
	_CrtMemCheckpoint( &s1 );
#endif

    if (bRun)
    {
        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

		CTveContainer cTveContainer;
		cTveContainer.CreateYourself();

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0) > 0)
		{
			TranslateMessage( &msg );
            DispatchMessage(&msg);
		}

        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish
    }
			// Store another memory checkpoint in the s2 memory-state structure
#ifdef _DEBUG
	 _CrtMemCheckpoint( &s2 );
	 if ( _CrtMemDifference( &s3, &s1, &s2 ) ) 
	 {
		_RPT0(_CRT_WARN, "*** Detected Memory Memory Leaks ***\n");
		
        if(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & _CRTDBG_LEAK_CHECK_DF)
		{
			_CrtMemDumpAllObjectsSince(&s1);
		}
	 } else {
		_RPT0(_CRT_WARN, "*** No Memory Leaks Detected\n");
	 }
	 _CrtMemDumpStatistics( &s3 );
 	 _CrtSetDbgFlag(0);		// turn off more memory leaks, this exe leaks 40+ objects
#endif
    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tests\tveviewer\webevents.cpp ===
// ------------------------------------
// WebEvents.cpp
//
// -----------------------------------
#include "stdafx.h"
#include "TveContainer.h"


HRESULT 
CleanIEAddress(BSTR bstrAddr, BSTR *pbstrOut)	// IE address has ABC<01><01>http:\\XYZ stuff - strip out the 01's  
{
	WCHAR *pwcAddr = bstrAddr;
	BOOL fSawAOne = false;
	while(*pwcAddr >= 0x01)
	{
		if(*pwcAddr == 0x00)
			break;
		if(*pwcAddr == 0x01)
			fSawAOne = true;
		else if(fSawAOne)
			break;
		pwcAddr++;
	}
	if(*pwcAddr == 0x00)			// no ones...
		pwcAddr = bstrAddr;

								// URL's can also contain '#' or '?' with data following - truncate off all that junk too
	CComBSTR bstrTmp(pwcAddr);		// truncate off the begining
	pwcAddr = bstrTmp;
	while(*pwcAddr != 0x00)
	{
		if(*pwcAddr == '#' || *pwcAddr == '?')
			break;
		pwcAddr++;
	}
	*pwcAddr = 0;					// terminate at the end...

	bstrTmp.CopyTo(pbstrOut);

	return S_OK;
}
STDMETHODIMP CTveView::NotifyStatusTextChange(BSTR Text)
{
	return S_OK;
}

STDMETHODIMP CTveView::NotifyProgressChange(LONG Progress, LONG ProgressMax)
{
	if(ProgressMax > 0)
		m_iPercent = (Progress * 100) / ProgressMax;
	else
		m_iPercent += m_iDelPercent;
	if(m_iPercent > 100)								// cause it to bounce back and forth.
	{
		m_iPercent = 100; 
		m_iDelPercent = -abs(m_iDelPercent);
	} else if (m_iPercent < 0) {
		m_iPercent = 0;
		m_iDelPercent = abs(m_iDelPercent);
	}
	TCHAR tbuff[256];
	_stprintf(tbuff,_T("Progress : %d\n"),m_iPercent);
	OutputDebugString(tbuff);
	SendMessage(m_hWndProgressBar, PBM_SETPOS, (WPARAM) m_iPercent, (LPARAM) 0);
	return S_OK;
}

STDMETHODIMP CTveView::NotifyCommandStateChange(LONG Command, VARIANT_BOOL Enable)
{
	return S_OK;
}

STDMETHODIMP CTveView::NotifyDownloadBegin()
{
	m_iPercent = 0;
	m_iDelPercent = abs(m_iDelPercent);
	SendMessage(m_hWndProgressBar, PBM_SETPOS, (WPARAM) 0, (LPARAM) 0);
	return S_OK;
}

STDMETHODIMP CTveView::NotifyDownloadComplete()
{
	m_iPercent = 100;
	SendMessage(m_hWndProgressBar, PBM_SETPOS, (WPARAM) 100, (LPARAM) 0);
	return S_OK;
}

STDMETHODIMP CTveView::NotifyTitleChange(BSTR Text)
{
	return S_OK;
}

STDMETHODIMP CTveView::NotifyPropertyChange(BSTR szProperty)
{
	return S_OK;
}

STDMETHODIMP CTveView::NotifyBeforeNavigate2(IDispatch * pDisp, VARIANT * URL, VARIANT * Flags, VARIANT * TargetFrameName, VARIANT * PostData, VARIANT * Headers, VARIANT_BOOL * Cancel)
{
	return S_OK;
}

STDMETHODIMP CTveView::NotifyNewWindow2(IDispatch * * ppDisp, VARIANT_BOOL * Cancel)
{
	return S_OK;
}

STDMETHODIMP CTveView::NotifyNavigateComplete2(IDispatch * pDisp, VARIANT * URL)
{
	USES_CONVERSION;
	return S_OK;
}

STDMETHODIMP CTveView::NotifyDocumentComplete(IDispatch * pDisp, VARIANT * URL)
{
	USES_CONVERSION;

	CComBSTR bstrTmp;
	CleanIEAddress( URL->bstrVal, &bstrTmp);		// degunk the URL, and display it to the user in the address bar...

	if(bstrTmp)
		SetDlgItemText(IDC_EDIT_ADDRESS, W2T(bstrTmp));
	return S_OK;
}

STDMETHODIMP CTveView::NotifyOnQuit()
{
	return S_OK;
}

STDMETHODIMP CTveView::NotifyOnVisible(VARIANT_BOOL Visible)
{
	return S_OK;
}

STDMETHODIMP CTveView::NotifyOnToolBar(VARIANT_BOOL ToolBar)
{
	return S_OK;
}

STDMETHODIMP CTveView::NotifyOnMenuBar(VARIANT_BOOL MenuBar)
{
	return S_OK;
}

STDMETHODIMP CTveView::NotifyOnStatusBar(VARIANT_BOOL StatusBar)
{
	return S_OK;
}

STDMETHODIMP CTveView::NotifyOnFullScreen(VARIANT_BOOL FullScreen)
{
	return S_OK;
}

STDMETHODIMP CTveView::NotifyOnTheaterMode(VARIANT_BOOL TheaterMode)
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tvband\bandobjs.cpp ===
/* 
*/

/**************************************************************************
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

  Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

  File:          BandObjs.cpp
  
    Description:   Contains DLLMain and standard OLE COM object creation stuff.
    
**************************************************************************/

/**************************************************************************
#include statements
**************************************************************************/

#include <ole2.h>
#include <comcat.h>
#include <olectl.h>
#include "ClsFact.h"

/**************************************************************************
GUID stuff
**************************************************************************/

//this part is only done once
//if you need to use the GUID in another file, just include Guid.h
#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <shlguid.h>
#include "Guid.h"
#pragma data_seg()

/**************************************************************************
private function prototypes
**************************************************************************/

extern "C" BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID);
BOOL RegisterServer(CLSID, LPTSTR, BOOL);
BOOL RegisterComCat(CLSID, CATID, BOOL);

/**************************************************************************
global variables
**************************************************************************/

HINSTANCE   g_hInst = 0;
UINT        g_DllRefCount = 0;

/**************************************************************************

  DllMain
  
**************************************************************************/

extern "C" BOOL WINAPI DllMain(  HINSTANCE hInstance, 
                               DWORD dwReason, 
                               LPVOID lpReserved)
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInst = hInstance;
        break;
        
    case DLL_PROCESS_DETACH:
        break;
    }
    
    return TRUE;
}                                 

/**************************************************************************

  DllCanUnloadNow
  
**************************************************************************/

STDAPI DllCanUnloadNow(void)
{
    //return (g_DllRefCount ? S_FALSE : S_OK);
    return S_FALSE;
}

/**************************************************************************

  DllGetClassObject
  
**************************************************************************/

STDAPI DllGetClassObject(  REFCLSID rclsid, 
                         REFIID riid, 
                         LPVOID *ppReturn)
{
    *ppReturn = NULL;
    
    //if we don't support this classid, return the proper error code
    if( !IsEqualCLSID(rclsid, CLSID_TVBand))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    //create a CClassFactory object and check it for validity
    CClassFactory *pClassFactory = new CClassFactory(rclsid);
    if(NULL == pClassFactory)
        return E_OUTOFMEMORY;
    
    //get the QueryInterface return for our return value
    HRESULT hResult = pClassFactory->QueryInterface(riid, ppReturn);
    
    //call Release to decement the ref count - creating the object set it to one 
    //and QueryInterface incremented it - since its being used externally (not by 
    //us), we only want the ref count to be 1
    pClassFactory->Release();
    
    //return the result from QueryInterface
    return hResult;
}

/**************************************************************************

  DllRegisterServer 
  
**************************************************************************/

STDAPI DllRegisterServer(void)
{
    
    if(g_hInst==0)
    {
        //g_hInst was not initialized during DLL_PROCESS_ATTACH.
        return E_HANDLE;
    }
    
    //Register the comm band object.
    if(!RegisterServer(CLSID_TVBand, TEXT("Television"), TRUE))
        return SELFREG_E_CLASS;
    
    //Register the component categories for the comm band object.
    if(!RegisterComCat(CLSID_TVBand, CATID_CommBand, TRUE))
        return SELFREG_E_CLASS;
    
    return S_OK;
}


/**************************************************************************

  DllUnRegisterServer 
  
**************************************************************************/

STDAPI DllUnregisterServer(void)
{       
    //UnRegister the component categories for the comm band object.
    if(!RegisterComCat(CLSID_TVBand, CATID_CommBand, FALSE))
        return SELFREG_E_CLASS;

    //UnRegister the comm band object.
    if(!RegisterServer(CLSID_TVBand, TEXT("Television"), FALSE))
        return SELFREG_E_CLASS;    
    
    return S_OK;
}

/**************************************************************************

  RegisterServer 
  
**************************************************************************/

typedef struct{
    HKEY  hRootKey;
    LPTSTR szSubKey;//TCHAR szSubKey[MAX_PATH];
    LPTSTR lpszValueName;
    LPTSTR szData;//TCHAR szData[MAX_PATH];
}DOREGSTRUCT, *LPDOREGSTRUCT;

BOOL RegisterServer(CLSID clsid, LPTSTR lpszTitle, BOOL fRegister)
{
    int      i;
    HKEY     hKey;
    LRESULT  lResult;
    DWORD    dwDisp;
    TCHAR    szSubKey[MAX_PATH];
    TCHAR    szCLSID[MAX_PATH];
    TCHAR    szModule[MAX_PATH];
    LPWSTR   pwsz;
    
    //get the CLSID in string form
    StringFromIID(clsid, &pwsz);
    
    if(pwsz)
    {
#ifdef UNICODE
        lstrcpy(szCLSID, pwsz);
#else
        WideCharToMultiByte( CP_ACP,
            0,
            pwsz,
            -1,
            szCLSID,
            ARRAYSIZE(szCLSID),
            NULL,
            NULL);
#endif
        
        //free the string
        LPMALLOC pMalloc;
        CoGetMalloc(1, &pMalloc);
        pMalloc->Free(pwsz);
        pMalloc->Release();
    }
    
    //get this app's path and file name
    GetModuleFileName(g_hInst, szModule, ARRAYSIZE(szModule));
    
    DOREGSTRUCT ClsidEntries[] = {HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s"),                  NULL,                   lpszTitle,
        HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\InprocServer32"),  NULL,                   szModule,
        HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\InprocServer32"),  TEXT("ThreadingModel"), TEXT("Apartment"),
        NULL,                NULL,                               NULL,                   NULL};
    

    if(!fRegister)
    {
        //count the entries.
        for(i = 0; ClsidEntries[i].hRootKey; i++);
        
        while(i)
        {
            i--;
            //create the sub key string - for this case, insert the file extension
            wsprintf(szSubKey, ClsidEntries[i].szSubKey, szCLSID);
            
            lResult = RegDeleteKey(  ClsidEntries[i].hRootKey,
                szSubKey);
            
        }
        
        //UnRegister the toolbar.
        lResult = RegDeleteKey(
            HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar"));   
    }
    else
    {
        //register the CLSID entries
        for(i = 0; ClsidEntries[i].hRootKey; i++)
        {
            //create the sub key string - for this case, insert the file extension
            wsprintf(szSubKey, ClsidEntries[i].szSubKey, szCLSID);
            
            lResult = RegCreateKeyEx(  ClsidEntries[i].hRootKey,
                szSubKey,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                NULL,
                &hKey,
                &dwDisp);
            
            if(NOERROR == lResult)
            {
                TCHAR szData[MAX_PATH];
                
                //if necessary, create the value string
                wsprintf(szData, ClsidEntries[i].szData, szModule);
                
                lResult = RegSetValueEx(   hKey,
                    ClsidEntries[i].lpszValueName,
                    0,
                    REG_SZ,
                    (LPBYTE)szData,
                    (lstrlen(szData) + 1) * sizeof(TCHAR));
                
                RegCloseKey(hKey);
            }
            else
                return FALSE;
        }
        
        //Register the toolbar.
        lResult = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar"),
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_WRITE,
            NULL,
            &hKey,
            &dwDisp);
        
        if(NOERROR == lResult)
        {
            byte data[2] = {0,0};
            
            
            lResult = RegSetValueEx(
                hKey,
                szCLSID,
                0,
                REG_BINARY,
                (LPBYTE)data,
                1);
            
            RegCloseKey(hKey);
        }
        else
            return FALSE;
    }
    
    return TRUE;
}

/**************************************************************************

  RegisterComCat
  
**************************************************************************/
    
BOOL RegisterComCat(CLSID clsid, CATID CatID, BOOL fRegister)
{
    ICatRegister   *pcr;
    HRESULT        hr = S_OK ;
    
    CoInitialize(NULL);
    
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
        NULL, 
        CLSCTX_INPROC_SERVER, 
        IID_ICatRegister, 
        (LPVOID*)&pcr);
    
    if(SUCCEEDED(hr))
    {
        if(!fRegister)
        {
            hr = pcr->UnRegisterClassImplCategories(clsid, 1, &CatID);
        }
        else
        {
            hr = pcr->RegisterClassImplCategories(clsid, 1, &CatID);
        }
        
        pcr->Release();
    }
    
    CoUninitialize();
    
    return SUCCEEDED(hr);
}


    /*
    
    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tvband\clsfact.cpp ===
/* 
*/
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ClsFact.cpp
   
   Description:   Implements CClassFactory.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "ClsFact.h"
#include "Guid.h"

/**************************************************************************
   private function prototypes
**************************************************************************/

/**************************************************************************
   global variables
**************************************************************************/

///////////////////////////////////////////////////////////////////////////
//
// IClassFactory implementation
//

/**************************************************************************

   CClassFactory::CClassFactory

**************************************************************************/

CClassFactory::CClassFactory(CLSID clsid)
{
m_clsidObject = clsid;
m_ObjRefCount = 1;
g_DllRefCount++;
}

/**************************************************************************

   CClassFactory::~CClassFactory

**************************************************************************/

CClassFactory::~CClassFactory()
{
g_DllRefCount--;
}

/**************************************************************************

   CClassFactory::QueryInterface

**************************************************************************/

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppReturn)
{
*ppReturn = NULL;

if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = this;
   }
   
else if(IsEqualIID(riid, IID_IClassFactory))
   {
   *ppReturn = (IClassFactory*)this;
   }   

if(*ppReturn)
   {
   (*(LPUNKNOWN*)ppReturn)->AddRef();
   return S_OK;
   }

return E_NOINTERFACE;
}                                             

/**************************************************************************

   CClassFactory::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CClassFactory::AddRef()
{
return ++m_ObjRefCount;
}


/**************************************************************************

   CClassFactory::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CClassFactory::Release()
{
if(--m_ObjRefCount == 0)
   {
   delete this;
   return 0;
   }
   
return m_ObjRefCount;
}

/**************************************************************************

   CClassFactory::CreateInstance

**************************************************************************/

STDMETHODIMP CClassFactory::CreateInstance(  LPUNKNOWN pUnknown, 
                                             REFIID riid, 
                                             LPVOID *ppObject)
{
HRESULT  hResult = E_FAIL;
LPVOID   pTemp = NULL;

*ppObject = NULL;

if(pUnknown != NULL)
   return CLASS_E_NOAGGREGATION;
 
if(IsEqualCLSID(m_clsidObject, CLSID_TVBand))
   {
   CTVBand *pTVBand = new CTVBand();
   if(NULL == pTVBand)
      return E_OUTOFMEMORY;
   
   pTemp = pTVBand;
   }
  
if(pTemp)
   {
   //get the QueryInterface return for our return value
   hResult = ((LPUNKNOWN)pTemp)->QueryInterface(riid, ppObject);

   //call Release to decement the ref count
   ((LPUNKNOWN)pTemp)->Release();
   }

return hResult;
}

/**************************************************************************

   CClassFactory::LockServer

**************************************************************************/

STDMETHODIMP CClassFactory::LockServer(BOOL)
{
return E_NOTIMPL;
}


/*

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tvband\globals.h ===
/* 
*/
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          Globals.h
   
**************************************************************************/

/**************************************************************************
   global variables
**************************************************************************/

extern HINSTANCE  g_hInst;
extern UINT       g_DllRefCount;

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


/*

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tvband\clsfact.h ===
/* 
*/
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ClsFact.h
   
   Description:   CClassFactory definitions.

**************************************************************************/

#ifndef CLASSFACTORY_H
#define CLASSFACTORY_H

#include <windows.h>
#include "Globals.h"
#include "TVBand.h"

/**************************************************************************

   CClassFactory class definition

**************************************************************************/

class CClassFactory : public IClassFactory
{
protected:
   DWORD m_ObjRefCount;

public:
   CClassFactory(CLSID);
   ~CClassFactory();

   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID*);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();

   //IClassFactory methods
   STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
   STDMETHODIMP LockServer(BOOL);

private:
   CLSID m_clsidObject;
};

#endif   //CLASSFACTORY_H

/*

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tvband\guid.h ===
/* 
*/
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          Guid.h
   
   Description:   Private GUID definition.

**************************************************************************/


// {85E0B172-04FA-11d1-B7DA-00A0C90348D6}
DEFINE_GUID(CLSID_TVBand, 
0x85e0b172, 0x4fa, 0x11d1, 0xb7, 0xda, 0x0, 0xa0, 0xc9, 0x3, 0x48, 0xd6);

/*

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tvband\tvband.cpp ===
/*
*/
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          TVBand.cpp

   Description:   Implements CTVBand

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/
#include "TVBand.h"
#include "Guid.h"
#include <iphlpapi.h>
#define DBIMF_BREAK             0x0100


/**************************************************************************

   CTVBand::CTVBand()

**************************************************************************/

CTVBand::CTVBand()
{
    m_hwndParent = NULL;
    m_hWnd = NULL;
    m_hwndEnhancements = NULL;
    m_hwndServices = NULL;
    m_hwndVariations = NULL;
    m_hwndTracks = NULL;
    m_punkSite = NULL;
    m_dwViewMode = 0;
    m_dwBandID = 0;
    m_bFocus = FALSE;
    m_ObjRefCount = 1;
    m_pSupervisor = 0;
    m_bstrEnhancement = 0;
    m_bstrService = 0;
    m_bstrVariation = 0;
    m_bstrTrack = 0;

    InterlockedIncrement((long *)&g_DllRefCount);
}

/**************************************************************************

   CTVBand::~CTVBand()

**************************************************************************/

CTVBand::~CTVBand()
{
    SetSite(NULL);
    if(m_pSupervisor)
    {
        m_pSupervisor->Release();
        m_pSupervisor = 0;
    }

    if(m_bstrEnhancement)
    {
        SysFreeString(m_bstrEnhancement);
        m_bstrEnhancement = 0;
    }

    if(m_bstrService)
    {
        SysFreeString(m_bstrService);
        m_bstrService = 0;
    }

    if(m_bstrVariation)
    {
        SysFreeString(m_bstrVariation);
        m_bstrVariation = 0;
    }

    if(m_bstrTrack)
    {
        SysFreeString(m_bstrTrack);
        m_bstrTrack = 0;
    }

    InterlockedDecrement((long *)&g_DllRefCount);
}

///////////////////////////////////////////////////////////////////////////
//
// IUnknown Implementation
//

/**************************************************************************

   CTVBand::QueryInterface

**************************************************************************/

STDMETHODIMP CTVBand::QueryInterface(REFIID riid, LPVOID *ppReturn)
{
*ppReturn = NULL;

//IUnknown
if(IsEqualIID(riid, IID_IUnknown))
   {
   *ppReturn = this;
   }

//IOleWindow
else if(IsEqualIID(riid, IID_IOleWindow))
   {
   *ppReturn = (IOleWindow*)this;
   }

//IDockingWindow
else if(IsEqualIID(riid, IID_IDockingWindow))
   {
   *ppReturn = (IDockingWindow*)this;
   }

//IInputObject
else if(IsEqualIID(riid, IID_IInputObject))
   {
   *ppReturn = (IInputObject*)this;
   }

//IObjectWithSite
else if(IsEqualIID(riid, IID_IObjectWithSite))
   {
   *ppReturn = (IObjectWithSite*)this;
   }

//IDeskBand
else if(IsEqualIID(riid, IID_IDeskBand))
   {
   *ppReturn = (IDeskBand*)this;
   }

//IPersist
else if(IsEqualIID(riid, IID_IPersist))
   {
   *ppReturn = (IPersist*)this;
   }

//IPersistStream
else if(IsEqualIID(riid, IID_IPersistStream))
   {
   *ppReturn = (IPersistStream*)this;
   }
//IDispatch
else if(IsEqualIID(riid, IID_IDispatch))
{
    *ppReturn = (IDispatch *)this;
}
//_ITVEEvents
else if(IsEqualIID(riid, DIID__ITVEEvents))
{
    *ppReturn = (_ITVEEvents *)this;
}

else
{
    return E_NOINTERFACE;
}

AddRef();
return S_OK;

return E_NOINTERFACE;
}

/**************************************************************************

   CTVBand::AddRef

**************************************************************************/

STDMETHODIMP_(DWORD) CTVBand::AddRef()
{
    return InterlockedIncrement((long *)&m_ObjRefCount);
}


/**************************************************************************

   CTVBand::Release

**************************************************************************/

STDMETHODIMP_(DWORD) CTVBand::Release()
{
    if(InterlockedDecrement((long *)&m_ObjRefCount) == 0)
    {
        delete this;
        return 0;
    }

    return m_ObjRefCount;
}

///////////////////////////////////////////////////////////////////////////
//
// IOleWindow Implementation
//

/**************************************************************************

   CTVBand::GetWindow()

**************************************************************************/

STDMETHODIMP CTVBand::GetWindow(HWND *phWnd)
{
    *phWnd = m_hWnd;

    return S_OK;
}

/**************************************************************************

   CTVBand::ContextSensitiveHelp()

**************************************************************************/

STDMETHODIMP CTVBand::ContextSensitiveHelp(BOOL fEnterMode)
{
return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IDockingWindow Implementation
//
HRESULT CTVBand::Advise(ITVESupervisor *pSupervisor, BOOL fAdvise)
{
    HRESULT hr = E_FAIL;

    if(pSupervisor)
    {
        IConnectionPointContainer *pCPC = 0;

        hr = pSupervisor->QueryInterface(IID_IConnectionPointContainer, (void **) &pCPC);
        if(SUCCEEDED(hr))
        {
            IConnectionPoint *pConnectionPoint = 0;
            hr = pCPC->FindConnectionPoint(DIID__ITVEEvents, &pConnectionPoint);
            if(SUCCEEDED(hr))
            {
                _ITVEEvents *pSink = this;

                if(fAdvise)
                {
                    hr = pConnectionPoint->Advise(pSink, &m_dwConnectionPointCookie);
                }
                else if (m_dwConnectionPointCookie)
                {
                    hr = pConnectionPoint->Unadvise(m_dwConnectionPointCookie);
                    m_dwConnectionPointCookie = 0;
                }
                pConnectionPoint->Release();
                pConnectionPoint = 0;
            }
            pCPC->Release();
            pCPC = 0;
        }
    }
    return hr;
}

/**************************************************************************

   CTVBand::ShowDW()

**************************************************************************/

STDMETHODIMP CTVBand::ShowDW(BOOL fShow)
{
    HRESULT hr = S_OK;
    ITVESupervisor *pSupervisor = 0;

    if(!m_hWnd)
        return S_FALSE;

    hr = GetSupervisor(&pSupervisor);
    if(SUCCEEDED(hr))
    {
        IDispatch *pServices = 0;

        hr = Advise(pSupervisor, fShow);

        if(SUCCEEDED(hr) && fShow)
        {
            hr = pSupervisor->get_Services(&pServices);
            if(SUCCEEDED(hr))
            {
                hr = LoadServices(pServices);
                pServices->Release();
            }
        }
        pSupervisor->Release();
    }

    if(fShow)
    {
        //show our window
        ShowWindow(m_hWnd, SW_SHOW);
    }
    else
    {
        //hide our window
        ShowWindow(m_hWnd, SW_HIDE);
    }

    return hr;
}

/**************************************************************************

   CTVBand::CloseDW()

**************************************************************************/

STDMETHODIMP CTVBand::CloseDW(DWORD dwReserved)
{
    ShowDW(FALSE);

    if(IsWindow(m_hWnd))
        DestroyWindow(m_hWnd);

    m_hWnd = NULL;

    return S_OK;
}

/**************************************************************************

   CTVBand::ResizeBorderDW()

**************************************************************************/

STDMETHODIMP CTVBand::ResizeBorderDW(   LPCRECT prcBorder,
                                          IUnknown* punkSite,
                                          BOOL fReserved)
{
/*
This method is never called for Band Objects.
*/
return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// IInputObject Implementation
//

/**************************************************************************

   CTVBand::UIActivateIO()

**************************************************************************/

STDMETHODIMP CTVBand::UIActivateIO(BOOL fActivate, LPMSG pMsg)
{
    if(fActivate)
        SetFocus(m_hWnd);

return S_OK;
}

/**************************************************************************

   CTVBand::HasFocusIO()

   If this window or one of its decendants has the focus, return S_OK. Return
   S_FALSE if we don't have the focus.

**************************************************************************/

STDMETHODIMP CTVBand::HasFocusIO(void)
{
    if(m_bFocus)
       return S_OK;

    return S_FALSE;
}

/**************************************************************************

   CTVBand::TranslateAcceleratorIO()

   If the accelerator is translated, return S_OK or S_FALSE otherwise.

**************************************************************************/

STDMETHODIMP CTVBand::TranslateAcceleratorIO(LPMSG lpMsg)
{

    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
// IObjectWithSite implementations
//

/**************************************************************************

   CTVBand::SetSite()

**************************************************************************/

STDMETHODIMP CTVBand::SetSite(IUnknown* punkSite)
{
    HRESULT hr;

    m_hwndParent = NULL;

    if(punkSite)
    {
        punkSite->AddRef();
        IOleWindow  *pOleWindow;

        //Get the parent window.
        if(SUCCEEDED(punkSite->QueryInterface(IID_IOleWindow, (LPVOID*)&pOleWindow)))
        {
            pOleWindow->GetWindow(&m_hwndParent);
            pOleWindow->Release();
        }
    }

    //If a site is being held, release it.
    //Don't Release m_punkSite during shutdown because DLL unloads too early.
    if(m_punkSite && punkSite)
    {
        m_punkSite->Release();
    }

    m_punkSite = punkSite;

    if(m_hwndParent)
    {
        if(!RegisterAndCreateWindow())
            return E_FAIL;
    }

    return S_OK;
}

/**************************************************************************

   CTVBand::GetSite()

**************************************************************************/

STDMETHODIMP CTVBand::GetSite(REFIID riid, LPVOID *ppvReturn)
{
    HRESULT hr = E_FAIL;

    *ppvReturn = NULL;

    if(m_punkSite)
    {
        hr = m_punkSite->QueryInterface(riid, ppvReturn);
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////
//
// IDeskBand implementation
//

/**************************************************************************

   CTVBand::GetBandInfo()

**************************************************************************/

STDMETHODIMP CTVBand::GetBandInfo(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi)
{
if(pdbi)
   {
   m_dwBandID = dwBandID;
   m_dwViewMode = dwViewMode;

   if(pdbi->dwMask & DBIM_MINSIZE)
      {
      pdbi->ptMinSize.x = 100;
      pdbi->ptMinSize.y = 30;
      }

   if(pdbi->dwMask & DBIM_MAXSIZE)
      {
      pdbi->ptMaxSize.x = -1;
      pdbi->ptMaxSize.y = -1;
      }

   if(pdbi->dwMask & DBIM_INTEGRAL)
      {
      pdbi->ptIntegral.x = 1;
      pdbi->ptIntegral.y = 1;
      }

   if(pdbi->dwMask & DBIM_ACTUAL)
      {
      pdbi->ptActual.x = -1;
      pdbi->ptActual.y = 30;
      }

   if(pdbi->dwMask & DBIM_TITLE)
      {
      lstrcpyW(pdbi->wszTitle, L"TV");
      }

   if(pdbi->dwMask & DBIM_MODEFLAGS)
      {
      pdbi->dwModeFlags = DBIMF_NORMAL | DBIMF_BREAK;
      }

   if(pdbi->dwMask & DBIM_BKCOLOR)
      {
      //Use the default background color by removing this flag.
      pdbi->dwMask &= ~DBIM_BKCOLOR;
      }

   return S_OK;
   }

return E_INVALIDARG;
}

///////////////////////////////////////////////////////////////////////////
//
// IPersistStream implementations
//
// This is only supported to allow the desk band to be dropped on the
// desktop and to prevent multiple instances of the desk band from showing
// up in the context menu. This desk band doesn't actually persist any data.
//

/**************************************************************************

   CTVBand::GetClassID()

**************************************************************************/

STDMETHODIMP CTVBand::GetClassID(LPCLSID pClassID)
{
*pClassID = CLSID_TVBand;

return S_OK;
}

/**************************************************************************

   CTVBand::IsDirty()

**************************************************************************/

STDMETHODIMP CTVBand::IsDirty(void)
{
return S_FALSE;
}

/**************************************************************************

   CTVBand::Load()

**************************************************************************/

STDMETHODIMP CTVBand::Load(LPSTREAM pStream)
{
return S_OK;
}

/**************************************************************************

   CTVBand::Save()

**************************************************************************/

STDMETHODIMP CTVBand::Save(LPSTREAM pStream, BOOL fClearDirty)
{
return S_OK;
}

/**************************************************************************

   CTVBand::GetSizeMax()

**************************************************************************/

STDMETHODIMP CTVBand::GetSizeMax(ULARGE_INTEGER *pul)
{
return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////
//
// private method implementations
//


/**************************************************************************

   CTVBand::RegisterAndCreateWindow()

**************************************************************************/

BOOL CTVBand::RegisterAndCreateWindow(void)
{
    //If the window doesn't exist yet, create it now.
    if(!m_hWnd)
    {
        //Can't create a child window without a parent.
        if(!m_hwndParent)
        {
            return FALSE;
        }


        //If the window class has not been registered, then do so.
        WNDCLASS wc;
        if(!GetClassInfo(g_hInst, CB_CLASS_NAME, &wc))
        {
            ZeroMemory(&wc, sizeof(wc));
            wc.style          = CS_HREDRAW | CS_VREDRAW | CS_GLOBALCLASS;
            wc.lpfnWndProc    = WndProc;
            wc.cbClsExtra     = 0;
            wc.cbWndExtra     = 0;
            wc.hInstance      = g_hInst;
            wc.hIcon          = NULL;
            wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
            wc.hbrBackground  = (HBRUSH) COLOR_BACKGROUND;
            //wc.hbrBackground  = (HBRUSH)CreateSolidBrush(RGB(0, 192, 0));
            wc.lpszMenuName   = NULL;
            wc.lpszClassName  = CB_CLASS_NAME;

            if(!RegisterClass(&wc))
            {
                //If RegisterClass fails, CreateWindow below will fail.
            }
        }

        RECT  rc;

        GetClientRect(m_hwndParent, &rc);
        //Create the window. The WndProc will set m_hWnd.
        m_hWnd = CreateWindowEx(   0,
            CB_CLASS_NAME,
            NULL,
            WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
            rc.left,
            rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top,
            m_hwndParent,
            NULL,
            g_hInst,
            (LPVOID)this);
    }

    return (NULL != m_hWnd);
}


//Get the IP address of the network adapter.
HRESULT LoadIPAdapters(ITVESupervisor *pSupervisor)
{
    HRESULT hr = E_FAIL;
    BSTR bstrIP = 0;
    PIP_ADAPTER_INFO   pAdapterInfo;
    ULONG    Size = NULL;
    DWORD Status;
    WCHAR wszIP[16];


    memset(wszIP, 0, sizeof(wszIP));

    if ((Status = GetAdaptersInfo(NULL, & Size)) != 0)

    {
        if (Status != ERROR_BUFFER_OVERFLOW)
        {
            return 0;
        }
    }

    // Allocate memory from sizing information
    pAdapterInfo = (PIP_ADAPTER_INFO) GlobalAlloc(GPTR, Size);
    if(pAdapterInfo)
    {
        // Get actual adapter information
        Status = GetAdaptersInfo(pAdapterInfo, & Size);

        if (!Status)
        {
            PIP_ADAPTER_INFO pinfo = pAdapterInfo;


            while(pinfo)
            {
                MultiByteToWideChar(CP_ACP, 0, pinfo->IpAddressList.IpAddress.String, -1, wszIP, 16);

                bstrIP = SysAllocString(wszIP);
                if(bstrIP)
                {
                    hr = pSupervisor->TuneTo(bstrIP, bstrIP);
                    SysFreeString(bstrIP);
                }
                pinfo = pinfo->Next;
            }

        }
        GlobalFree(pAdapterInfo);
    }


    return hr;

}

/**************************************************************************

  CTVBand::GetSupervisor()

**************************************************************************/
HRESULT CTVBand::GetSupervisor(ITVESupervisor **ppSupervisor)
{
    HRESULT hr = E_FAIL;;

    *ppSupervisor = 0;

    if(m_pSupervisor)
    {
        hr = S_OK;
    }
    else
    {
        hr = CoCreateInstance(CLSID_TVESupervisor, NULL, CLSCTX_SERVER, IID_ITVESupervisor, (void **)&m_pSupervisor);
        if(SUCCEEDED(hr))
        {
            hr = LoadIPAdapters(m_pSupervisor);

            if(FAILED(hr))
            {
                m_pSupervisor->Release();
                m_pSupervisor = 0;
            }

        }
    }

    if(SUCCEEDED(hr))
    {
        m_pSupervisor->AddRef();
        *ppSupervisor = m_pSupervisor;
        hr = S_OK;
    }
    return hr;
}

/**************************************************************************

  CTVBand::WndProc()

**************************************************************************/
LRESULT CALLBACK CTVBand::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT result = 0;
    CTVBand  *pThis = (CTVBand*)GetWindowLong(hwnd, GWL_USERDATA);

    switch (msg)
    {
    case WM_COMMAND:
        switch(HIWORD(wParam))
        {
        case CBN_SELCHANGE:
            {
                HWND hwndCombo = (HWND) lParam;
                if(hwndCombo == pThis->m_hwndEnhancements)
                {
                    pThis->OnEnhancement(TRUE);
                }
                else if(hwndCombo == pThis->m_hwndVariations)
                {
                    pThis->OnVariation(TRUE);
                }
                else if(hwndCombo == pThis->m_hwndTracks)
                {
                    pThis->OnTrack(TRUE);
                }
                else if(hwndCombo == pThis->m_hwndServices)
                {
                    pThis->OnService(TRUE);
                }
            }
            break;
        default:
            break;
        }

        break;
        case WM_CREATE:
            {
                LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
                pThis = (CTVBand*)(lpcs->lpCreateParams);
                SetWindowLong(hwnd, GWL_USERDATA, (LONG)pThis);
                pThis->m_hWnd = hwnd;
                result = pThis->OnCreate(hwnd);
            }
            break;
        case WM_DELETEITEM:
            {
                //Release the interface pointer.
                LPDELETEITEMSTRUCT pItem = (LPDELETEITEMSTRUCT) lParam;
                if(pItem->itemData)
                {
                    IUnknown *punk = (IUnknown *)pItem->itemData;
                    punk->Release();
                }


            }
            break;

        default:
            result = DefWindowProc(hwnd, msg, wParam, lParam);
    }
    return result;
}


/**************************************************************************

   CTVBand::OnCreate()

**************************************************************************/
LRESULT CTVBand::OnCreate(HWND hwnd)
{
    DWORD dwBaseUnits;

    dwBaseUnits = GetDialogBaseUnits();

    m_hwndServices = CreateWindow(TEXT("COMBOBOX"), TEXT(""),
        CBS_DROPDOWNLIST | WS_CHILD | WS_VISIBLE,
        (6 * LOWORD(dwBaseUnits)) / 4,
        (2 * HIWORD(dwBaseUnits)) / 8,
        (100 * LOWORD(dwBaseUnits)) / 4,
        (50 * HIWORD(dwBaseUnits)) / 8,
        hwnd, (HMENU) ID_SERVICES, g_hInst, NULL);

    m_hwndEnhancements = CreateWindow(TEXT("COMBOBOX"), TEXT(""),
        CBS_DROPDOWNLIST | WS_CHILD | WS_VISIBLE,
        (112 * LOWORD(dwBaseUnits)) / 4,
        (2 * HIWORD(dwBaseUnits)) / 8,
        (100 * LOWORD(dwBaseUnits)) / 4,
        (50 * HIWORD(dwBaseUnits)) / 8,
        hwnd, (HMENU) ID_ENHANCEMENTS, g_hInst, NULL);

    m_hwndVariations = CreateWindow(TEXT("COMBOBOX"), TEXT(""),
        CBS_DROPDOWNLIST | WS_CHILD | WS_VISIBLE,
        (218 * LOWORD(dwBaseUnits)) / 4,
        (2 * HIWORD(dwBaseUnits)) / 8,
        (100 * LOWORD(dwBaseUnits)) / 4,
        (50 * HIWORD(dwBaseUnits)) / 8,
        hwnd, (HMENU) ID_VARIATIONS, g_hInst, NULL);

    m_hwndTracks = CreateWindow(TEXT("COMBOBOX"), TEXT(""),
        CBS_DROPDOWNLIST | WS_CHILD | WS_VISIBLE,
        (324 * LOWORD(dwBaseUnits)) / 4,
        (2 * HIWORD(dwBaseUnits)) / 8,
        (100 * LOWORD(dwBaseUnits)) / 4,
        (50 * HIWORD(dwBaseUnits)) / 8,
        hwnd, (HMENU) ID_TRACKS, g_hInst, NULL);


    return 0;
}



/**************************************************************************

   CTVBand::GetBrowser()

**************************************************************************/
IWebBrowser2 *CTVBand::GetBrowser()
{
    IWebBrowser2 *pBrowser = NULL;
    HRESULT hr;

    if(m_punkSite)
    {
        IServiceProvider *psp;

        hr = m_punkSite->QueryInterface(IID_IServiceProvider, (LPVOID*)&psp);
        if (SUCCEEDED(hr))
        {
            hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID*)&pBrowser);
            psp->Release();
        }
    }
    return pBrowser;
}



/**************************************************************************

   CTVBand::AddEnhancement()

**************************************************************************/
HRESULT CTVBand::AddEnhancement(ITVEEnhancement *pEnhancement)
{
    HRESULT hr = E_FAIL;
    BSTR bstrEnhancement;

    if(pEnhancement)
    {
        hr = pEnhancement->get_SessionName(&bstrEnhancement);
        if(SUCCEEDED(hr))
        {
            long i = SendMessage(m_hwndEnhancements, CB_ADDSTRING, 0, (LPARAM) bstrEnhancement);

            pEnhancement->AddRef();
            SendMessage(m_hwndEnhancements, CB_SETITEMDATA, i, (LPARAM) pEnhancement);

            //Check if the string matches the previously selected enhancement.
            if(m_bstrEnhancement && 0==lstrcmpi(m_bstrEnhancement,bstrEnhancement))
            {
                SendMessage(m_hwndEnhancements, CB_SETCURSEL, i, 0);
                hr = OnEnhancement(FALSE);
            }
            SysFreeString(bstrEnhancement);
        }
    }

    return hr;
}

/**************************************************************************

   CTVBand::AddService()

**************************************************************************/
HRESULT CTVBand::AddService(ITVEService *pService)
{
    HRESULT hr = E_FAIL;
    BSTR bstrService;

    if(pService)
    {
        hr = pService->get_Description(&bstrService);
        if(SUCCEEDED(hr))
        {
            long i = SendMessage(m_hwndServices, CB_ADDSTRING, 0, (LPARAM) bstrService);
            pService->AddRef();
            SendMessage(m_hwndServices, CB_SETITEMDATA, i, (LPARAM) pService);

            //Check if the string matches the previously selected service.
            if(m_bstrService && 0==lstrcmpi(m_bstrService,bstrService))
            {
                SendMessage(m_hwndServices, CB_SETCURSEL, i, 0);
                hr = OnService(FALSE);
            }
            SysFreeString(bstrService);
        }
    }

    return hr;
}

/**************************************************************************

   CTVBand::AddVariation()

**************************************************************************/
HRESULT CTVBand::AddVariation(ITVEVariation *pVariation)
{
    HRESULT hr = E_FAIL;
    if(pVariation)
    {
        BSTR bstrDescription;
        hr = pVariation->get_Description(&bstrDescription);
        if(SUCCEEDED(hr))
        {
            long i = SendMessage(m_hwndVariations, CB_ADDSTRING, 0, (LPARAM) bstrDescription);
            pVariation->AddRef();
            SendMessage(m_hwndVariations, CB_SETITEMDATA, i, (LPARAM) pVariation);

            //Check if the string matches the previously selected variation.
            if(m_bstrVariation && 0==lstrcmpi(m_bstrVariation,bstrDescription))
            {
                SendMessage(m_hwndVariations, CB_SETCURSEL, i, 0);
                hr = OnVariation(FALSE);
            }
            SysFreeString(bstrDescription);
        }
    }
    return hr;
}

/**************************************************************************

   CTVBand::AddTrack()

**************************************************************************/
HRESULT CTVBand::AddTrack(ITVETrack *pTrack)
{
    HRESULT hr = E_FAIL;
    if(pTrack)
    {
        BSTR bstrName = 0;
        ITVETrigger *pTrigger = 0;

        //Get the trigger object
        hr = pTrack->get_Trigger((IUnknown **)&pTrigger);
        if(SUCCEEDED(hr))
        {
            hr = pTrigger->get_Name(&bstrName);
            pTrigger->Release();
        }

        if(SUCCEEDED(hr) && bstrName)
        {
            long i = SendMessage(m_hwndTracks, CB_ADDSTRING, 0, (LPARAM) bstrName);
            pTrack->AddRef();
            SendMessage(m_hwndTracks, CB_SETITEMDATA, i, (LPARAM) pTrack);

            //Check if the string matches the previously selected track.
            if(m_bstrTrack && 0==lstrcmpi(m_bstrTrack,bstrName))
            {
                SendMessage(m_hwndTracks, CB_SETCURSEL, i, 0);
                hr = OnTrack(FALSE);
            }
            SysFreeString(bstrName);
        }
    }
    return hr;
}

/**************************************************************************

   CTVBand::LoadEnhancements()

**************************************************************************/
HRESULT CTVBand::LoadEnhancements(IDispatch *pDispatch)
{
    HRESULT hr = E_FAIL;
    long count = 0;

    SendMessage(m_hwndEnhancements, CB_RESETCONTENT, 0, 0);
    SendMessage(m_hwndVariations, CB_RESETCONTENT, 0, 0);
    SendMessage(m_hwndTracks, CB_RESETCONTENT, 0, 0);
    if(pDispatch)
    {
        ITVEEnhancements *pEnhancements;

        hr = pDispatch->QueryInterface(IID_ITVEEnhancements, (void **)&pEnhancements);
        if(SUCCEEDED(hr))
        {
            hr = pEnhancements->get_Count(&count);
            if(SUCCEEDED(hr))
            {
                long i;
                long iPrimary = 0;
                ITVEEnhancement *pEnhancement;
                VARIANT v;

                VariantInit(&v);
                v.vt = VT_INT;

                for(v.intVal = 0;v.intVal < count && SUCCEEDED(hr); v.intVal++)
                {
                    hr = pEnhancements->get_Item(v, &pEnhancement);
                    if(SUCCEEDED(hr))
                    {
                        long fIsPrimary = FALSE;

                        //Add the variation to the listbox.
                        hr = AddEnhancement(pEnhancement);

                        hr = pEnhancement->get_IsPrimary(&fIsPrimary);
                        if(SUCCEEDED(hr) && fIsPrimary)
                        {
                            iPrimary = v.intVal;
                        }
                    }
                }

                i = SendMessage(m_hwndEnhancements, CB_GETCURSEL,0,0);

                if(-1 == i)
                {
                    //Select the primary enhancement.
                    SendMessage(m_hwndEnhancements, CB_SETCURSEL, iPrimary, 0);
                    OnEnhancement(FALSE);
                }

            }
            pEnhancements->Release();
        }
    }
    return hr;
}

/**************************************************************************

   CTVBand::LoadServices()

**************************************************************************/
HRESULT CTVBand::LoadServices(IDispatch *pDispatch)
{
    HRESULT hr = E_FAIL;
    long count = 0;

    SendMessage(m_hwndServices, CB_RESETCONTENT, 0, 0);
    SendMessage(m_hwndEnhancements, CB_RESETCONTENT, 0, 0);
    SendMessage(m_hwndVariations, CB_RESETCONTENT, 0, 0);
    SendMessage(m_hwndTracks, CB_RESETCONTENT, 0, 0);

    if(pDispatch)
    {
        ITVEServices *pServices;

        hr = pDispatch->QueryInterface(IID_ITVEServices, (void **)&pServices);
        if(SUCCEEDED(hr))
        {
            hr = pServices->get_Count(&count);
            if(SUCCEEDED(hr))
            {
                long i;
                ITVEService *pService;
                VARIANT v;

                VariantInit(&v);
                v.vt = VT_INT;

                for(v.intVal = 0;v.intVal < count && SUCCEEDED(hr); v.intVal++)
                {
                    hr = pServices->get_Item(v, &pService);
                    if(SUCCEEDED(hr))
                    {
                        //Add the variation to the listbox.
                        hr = AddService(pService);
                    }
                }

                i = SendMessage(m_hwndServices, CB_GETCURSEL,0,0);

                if(-1 == i)
                {
                    //Select the first service.
                    SendMessage(m_hwndServices, CB_SETCURSEL, 0, 0);
                    OnService(FALSE);
                }
            }
            pServices->Release();
        }
    }
    return hr;
}

/**************************************************************************

   CTVBand::LoadTracks()

**************************************************************************/
HRESULT CTVBand::LoadTracks(IDispatch *pDispatch)
{
    HRESULT hr = E_FAIL;
    long count = 0;

    SendMessage(m_hwndTracks, CB_RESETCONTENT, 0, 0);
    if(pDispatch)
    {
        ITVETracks *pTracks;

        hr = pDispatch->QueryInterface(IID_ITVETracks, (void **)&pTracks);
        if(SUCCEEDED(hr))
        {
            hr = pTracks->get_Count(&count);
            if(SUCCEEDED(hr))
            {
                long i;
                ITVETrack *pTrack;
                VARIANT v;

                VariantInit(&v);
                v.vt = VT_INT;

                for(v.intVal = 0;v.intVal < count && SUCCEEDED(hr); v.intVal++)
                {
                    hr = pTracks->get_Item(v, &pTrack);
                    if(SUCCEEDED(hr))
                    {
                        //Add the track to the listbox.
                        hr = AddTrack(pTrack);
                    }
                }

                i = SendMessage(m_hwndTracks, CB_GETCURSEL,0,0);

                if(-1 == i)
                {
                    //Select the first track.
                    SendMessage(m_hwndTracks, CB_SETCURSEL, 0, 0);
                    OnTrack(FALSE);
                }
            }
            pTracks->Release();
        }
    }
    return hr;
}

/**************************************************************************

   CTVBand::LoadVariations()

**************************************************************************/
HRESULT CTVBand::LoadVariations(IDispatch *pDispatch)
{
    HRESULT hr = E_FAIL;
    long count = 0;

    SendMessage(m_hwndVariations, CB_RESETCONTENT, 0, 0);
    SendMessage(m_hwndTracks, CB_RESETCONTENT, 0, 0);

    if(pDispatch)
    {
        ITVEVariations *pVariations;

        hr = pDispatch->QueryInterface(IID_ITVEVariations, (void **)&pVariations);
        if(SUCCEEDED(hr))
        {
            hr = pVariations->get_Count(&count);
            if(SUCCEEDED(hr))
            {
                long i;
                ITVEVariation *pVariation;
                VARIANT v;

                VariantInit(&v);
                v.vt = VT_INT;

                for(v.intVal = 0;v.intVal < count && SUCCEEDED(hr); v.intVal++)
                {
                    hr = pVariations->get_Item(v, &pVariation);
                    if(SUCCEEDED(hr))
                    {
                        //Add the variation to the listbox.
                        hr = AddVariation(pVariation);
                    }
                }

                i = SendMessage(m_hwndVariations, CB_GETCURSEL,0,0);

                if(-1 == i)
                {
                    //Select the first variation.
                    SendMessage(m_hwndVariations, CB_SETCURSEL, 0, 0);
                    OnVariation(FALSE);
                }
            }
            pVariations->Release();
        }
    }
    return hr;
}

/**************************************************************************

   CTVBand::OnEnhancement()

**************************************************************************/
HRESULT CTVBand::OnEnhancement(BOOL fSetDefault)
{
    HRESULT hr = E_FAIL;
    int i;
    ITVEEnhancement *pEnhancement;

    i = SendMessage(m_hwndEnhancements, CB_GETCURSEL,0,0);

    if(-1 == i)
        return E_FAIL;

    pEnhancement = (ITVEEnhancement *) SendMessage(m_hwndEnhancements, CB_GETITEMDATA,i,0);

    if(pEnhancement)
    {
        IDispatch *pVariations = 0;

        if(fSetDefault)
        {
            if(m_bstrEnhancement)
            {
                SysFreeString(m_bstrEnhancement);
                m_bstrEnhancement = 0;
            }

            pEnhancement->get_Description(&m_bstrEnhancement);
        }

        hr = pEnhancement->get_Variations(&pVariations);
        if(SUCCEEDED(hr))
        {
            hr = LoadVariations(pVariations);
        }
    }

    return hr;
}


/**************************************************************************

   CTVBand::OnService()

**************************************************************************/
HRESULT CTVBand::OnService(BOOL fSetDefault)
{
    HRESULT hr = E_FAIL;
    int i;
    ITVEService *pService;

    i = SendMessage(m_hwndServices, CB_GETCURSEL,0,0);

    if(-1 == i)
        return E_FAIL;

    pService = (ITVEService *) SendMessage(m_hwndServices, CB_GETITEMDATA,i,0);

    if(pService)
    {
        IDispatch *pEnhancements = 0;
        BSTR bstrService = 0;

        hr = pService->get_Description(&bstrService);
        if(SUCCEEDED(hr))
        {
            //Tune to the selected interface.
            m_pSupervisor->TuneTo(bstrService, bstrService);

            if(fSetDefault)
            {
                if(m_bstrService)
                {
                    SysFreeString(m_bstrService);
                    m_bstrService = 0;
                }
                m_bstrService = bstrService;
            }
            else
            {
                SysFreeString(bstrService);
                bstrService = 0;
            }
        }

        hr = pService->get_Enhancements(&pEnhancements);
        if(SUCCEEDED(hr))
        {
            hr = LoadEnhancements(pEnhancements);
        }
    }

    return hr;
}

/**************************************************************************

   CTVBand::OnTrack()

**************************************************************************/
HRESULT CTVBand::OnTrack(BOOL fSetDefault)
{
    HRESULT hr = E_FAIL;
    int i;
    ITVETrack *pTrack;

    i = SendMessage(m_hwndTracks, CB_GETCURSEL,0,0);

    if(-1 == i)
        return E_FAIL;

    pTrack = (ITVETrack *) SendMessage(m_hwndTracks, CB_GETITEMDATA,i,0);

    if(pTrack)
    {
        ITVETrigger *pTrigger = 0;

        //Get the trigger object
        hr = pTrack->get_Trigger((IUnknown **)&pTrigger);
        if(SUCCEEDED(hr))
        {
            if(fSetDefault)
            {
                if(m_bstrTrack)
                {
                    SysFreeString(m_bstrTrack);
                    m_bstrTrack = 0;
                }

                pTrigger->get_Name(&m_bstrTrack);
            }

            hr = OnTrigger(pTrigger);
        }
    }

    return hr;
}

/**************************************************************************

   CTVBand::OnTrigger()

**************************************************************************/
HRESULT CTVBand::OnTrigger(ITVETrigger *pTrigger)
{
    HRESULT hr = E_FAIL;

    if(pTrigger)
    {
        IWebBrowser2 * pBrowser = GetBrowser();

        if(pBrowser)
        {
            BSTR bstrURL;

            hr = pTrigger->get_URL(&bstrURL);
            if(SUCCEEDED(hr))
            {
                hr = pBrowser->Navigate(bstrURL, 0, 0, 0, 0);
                SysFreeString(bstrURL);
            }
            pBrowser->Release();
        }
    }

    return hr;
}

/**************************************************************************

   CTVBand::OnVariation()

**************************************************************************/
HRESULT CTVBand::OnVariation(BOOL fSetDefault)
{
    HRESULT hr = E_FAIL;
    int i;
    ITVEVariation *pVariation;

    i = SendMessage(m_hwndVariations, CB_GETCURSEL,0,0);

    if(-1 == i)
        return E_FAIL;

    pVariation = (ITVEVariation *) SendMessage(m_hwndVariations, CB_GETITEMDATA,i,0);

    if(pVariation)
    {
        IDispatch *pTracks = 0;

        if(fSetDefault)
        {
            if(m_bstrVariation)
            {
                SysFreeString(m_bstrVariation);
                m_bstrVariation = 0;
            }

            pVariation->get_Description(&m_bstrVariation);
        }

        hr = pVariation->get_Tracks(&pTracks);
        if(SUCCEEDED(hr))
        {
            hr = LoadTracks(pTracks);
        }
    }

    return hr;
}


/**************************************************************************

   CTVBand::GetTypeInfoCount()

**************************************************************************/
HRESULT CTVBand::GetTypeInfoCount(UINT *pctinfo)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

/**************************************************************************

   CTVBand::GetTypeInfo()

**************************************************************************/
HRESULT CTVBand::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

/**************************************************************************

   CTVBand::GetIDsOfNames()

**************************************************************************/
HRESULT CTVBand::GetIDsOfNames (REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID __RPC_FAR *rgDispId)
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

/**************************************************************************

   CTVBand::Invoke() - Event handler for _ITVEEvents.


**************************************************************************/
HRESULT CTVBand::Invoke(
       DISPID dispIdMember,
       REFIID riid,
       LCID lcid,
       WORD wFlags,
       DISPPARAMS *pDispParams,
       VARIANT  *pVarResult,
       EXCEPINFO  *pExcepInfo,
       UINT *puArgErr)
{
    HRESULT hr = E_FAIL;
    switch(dispIdMember)
    {
    case 1:
        //Tune to
        break;
    case 2:
        //New enhancement
        hr = OnService(FALSE);
        break;
    case 3:
        //Enhancement updated
        hr = OnEnhancement(FALSE);
        break;
    case 4:
        //Enhancement starting.
        hr = OnEnhancement(FALSE);
    case 5:
        //Enhancement expired
        hr = OnService(FALSE);
        break;
    case 6:
        //New Trigger
        hr = OnVariation(FALSE);
        break;
    case 7:
        //Trigger updated.
        hr = OnTrack(FALSE);
        break;
    case 8:
        //Trigger expired.
        hr = OnVariation(FALSE);
        break;
    case 9:
        //Package
        break;
    case 10:
        ///File
        break;
    default:
        break;
    }
    return hr;
}



/*

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\tve\tvband\tvband.h ===
/* 
*/
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          TVBand.h
   
   Description:   CTVBand definitions.

**************************************************************************/

#include <windows.h>
#include <shlobj.h>

#include "Globals.h"

#import  "..\TveContr\TveContr.tlb" no_namespace named_guids

#ifndef TVBand_H
#define TVBand_H

#define ID_SERVICES     1
#define ID_ENHANCEMENTS 2
#define ID_VARIATIONS   3
#define ID_TRACKS       4

#define CB_CLASS_NAME (TEXT("TVBandSampleClass"))
LRESULT CALLBACK ToolbarWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

/**************************************************************************

   CTVBand class definition

**************************************************************************/

class CTVBand : public IDeskBand, 
                public IInputObject, 
                public IObjectWithSite,
                public IPersistStream,
                public _ITVEEvents
{
protected:
   DWORD m_ObjRefCount;

public:
   CTVBand();
   ~CTVBand();

   //IUnknown methods
   STDMETHODIMP QueryInterface(REFIID, LPVOID*);
   STDMETHODIMP_(DWORD) AddRef();
   STDMETHODIMP_(DWORD) Release();

   //IOleWindow methods
   STDMETHOD (GetWindow) (HWND*);
   STDMETHOD (ContextSensitiveHelp) (BOOL);

   //IDockingWindow methods
   STDMETHOD (ShowDW) (BOOL fShow);
   STDMETHOD (CloseDW) (DWORD dwReserved);
   STDMETHOD (ResizeBorderDW) (LPCRECT prcBorder, IUnknown* punkToolbarSite, BOOL fReserved);

   //IDeskBand methods
   STDMETHOD (GetBandInfo) (DWORD, DWORD, DESKBANDINFO*);

   //IInputObject methods
   STDMETHOD (UIActivateIO) (BOOL, LPMSG);
   STDMETHOD (HasFocusIO) (void);
   STDMETHOD (TranslateAcceleratorIO) (LPMSG);

   //IObjectWithSite methods
   STDMETHOD (SetSite) (IUnknown*);
   STDMETHOD (GetSite) (REFIID, LPVOID*);

   //IPersistStream methods
   STDMETHOD (GetClassID) (LPCLSID);
   STDMETHOD (IsDirty) (void);
   STDMETHOD (Load) (LPSTREAM);
   STDMETHOD (Save) (LPSTREAM, BOOL);
   STDMETHOD (GetSizeMax) (ULARGE_INTEGER*);

   //ITVEEvents methods
   STDMETHOD (GetTypeInfoCount)(UINT *pctinfo);   
   STDMETHOD (GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);   
   STDMETHOD (GetIDsOfNames) (REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID __RPC_FAR *rgDispId);   
   STDMETHOD (Invoke)(DISPID dispIdMember,
       REFIID riid,
       LCID lcid,
       WORD wFlags,
       DISPPARAMS *pDispParams,
       VARIANT  *pVarResult,
       EXCEPINFO  *pExcepInfo,
       UINT *puArgErr);
    

private:
    HWND m_hwndParent;
    HWND m_hWnd;
    HWND m_hwndEnhancements;
    HWND m_hwndServices;
    HWND m_hwndVariations;
    HWND m_hwndTracks;
    DWORD m_dwViewMode;
    DWORD m_dwBandID;
    DWORD m_dwConnectionPointCookie;
    BOOL m_bFocus;
    IUnknown *m_punkSite;
    ITVESupervisor *m_pSupervisor;
    BSTR m_bstrEnhancement;
    BSTR m_bstrService;
    BSTR m_bstrVariation;
    BSTR m_bstrTrack;

private:
    static LRESULT CALLBACK WndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    LRESULT OnCreate(HWND hwnd);
    BOOL RegisterAndCreateWindow(void);
    IWebBrowser2 * GetBrowser();
    HRESULT GetSupervisor(ITVESupervisor **ppSupervisor);

    HRESULT OnEnhancement(BOOL fSetDefault);
    HRESULT OnService(BOOL fSetDefault);
    HRESULT OnTrack(BOOL fSetDefault);
    HRESULT OnVariation(BOOL fSetDefault);
    HRESULT OnTrigger(ITVETrigger *pTrigger);
    HRESULT AddEnhancement(ITVEEnhancement *pTVEEnhancement);
    HRESULT AddService(ITVEService *pTVEService);
    HRESULT AddTrack(ITVETrack *pTrack);
    HRESULT AddVariation(ITVEVariation *pTVEVariation);
    HRESULT LoadEnhancements(IDispatch *pDispatch);
    HRESULT LoadServices(IDispatch *pDispatch);
    HRESULT LoadTracks(IDispatch *pDispatch);
    HRESULT LoadVariations(IDispatch *pDispatch);
    HRESULT Advise(ITVESupervisor *pSupervisor, BOOL fAdvise);

};

#endif   //TVBand_H


/*

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\util\clock\code\clock.h ===
// Copyright (c) 1994 - 1996  Microsoft Corporation.  All Rights Reserved.
// Implements IReferenceClock Interface, Anthony Phillips, March 1995

#ifndef _CLOCK__
#define __CLOCK__

// This class will also need to support a IControllableClock interface so
// that an audio card can update the system wide clock that everyone uses
// The interface will be pretty thin with probably just one update method

const INT ADVISE_CACHE = 10;                    // Arbitrary cache size
const UINT RESOLUTION = 1;                      // High resolution timer
const LONGLONG MAX_TIME = 0x7FFFFFFFFFFFFFFF;   // Maximum LONGLONG value

// This class implements the IReferenceClock interface, We have a separate
// worker thread that is created during construction and destroyed during
// destuction. This thread executes a series of WaitForSingleObject calls.
// Each advise call defines a point in time when they wish to be notified,
// where a periodic advise is a series of these such events. We maintain
// a list of advise links and calculate when the nearest event notification
// is due for. We then call WaitForSingleObject with a timeout equal to
// this time. The handle we wait on is used by the class to signal that
// something has changed and that we must reschedule the next event. This
// typically happens when someone comes in and asks for an advise link
// while we are waiting for an event to timeout.
//
// While we are executing the next event calculation and dispatching code
// we are protected from interference through a critical section. Clients
// are NOT advise through callbacks any more. One shot clients have an
// event set, while periodic clients have a semaphore released for each
// event notification. A semaphore allows a client to be kept upto date
// with the number of events actually triggered and be assured that they
// can't miss multiple events being set while they are processing


class CSystemClock :
    public CUnknown,
    public IReferenceClock,
    public CCritSec
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void ** ppv);

    DECLARE_IUNKNOWN

    // IReferenceClock methods

    // Ask for an async notification that a time has elapsed

    STDMETHODIMP AdviseTime(
        REFERENCE_TIME baseTime,         // base reference time
        REFERENCE_TIME streamTime,       // stream offset time
        HEVENT hEvent,                  // advise via this event
        DWORD *pdwAdviseCookie          // where your cookie goes
    );

    // Ask for an asynchronous periodic notification that a time has elapsed

    STDMETHODIMP AdvisePeriodic(
        REFERENCE_TIME StartTime,         // starting at this time
        REFERENCE_TIME PeriodTime,        // time between notifications
        HSEMAPHORE hSemaphore,           // advise via a semaphore
        DWORD *pdwAdviseCookie           // where your cookie goes
    );

    // Cancel a request for notification(s) - if the notification was
    // a one shot timer then this function doesn't need to be called

    STDMETHODIMP Unadvise(DWORD dwAdviseCookie);

    // Give me the reference time for this real time - this is a placeholder
    // for compatibility with future operating systems that have their own
    // idea of what a time structure looks like. If a filter wants to convert
    // their REFERENCE_TIME into something recognised by operating system APIs
    // then they can do it through this function

    STDMETHODIMP ConvertRealTime(
        TIME RealTime,
        REFERENCE_TIME *pRefTime
    );

    // Get the current reference time

    STDMETHODIMP GetTime(
        REFERENCE_TIME *pTime
    );

    // Constructor and destructor

    CSystemClock(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr);
    virtual ~CSystemClock();

private:

#if 0
    // We keep one of these objects for each advise link. NOTE for the sake
    // of efficiency we store the notification time and the time between
    // periodic timers as DWORD milliseconds rather than CRefTime objects
#else
    /* We keep one of these objects for each advise link. NOTE for the sake
       of efficiency we store the notification time and the time between
       periodic timers as LONGLONG reftimes rather than CRefTime objects */
#endif

    class CAdviseHolder : CBaseObject
    {
        CAdviseHolder(TCHAR *pName) : CBaseObject(pName) {};

        DWORD       m_dwAdviseCookie;   // Used to identify clients
        LONGLONG    m_RefTime;          // (Next) notification time
        BOOL        m_bPeriodic;        // Periodic events
        LONGLONG    m_Period;           // Periodic time
        HANDLE      m_hNotify;          // Notification mechanism
        friend class CSystemClock;      // Let it fill in the details
    };

    // Typed advise holder list derived from the generic list template

    typedef CGenericList<CAdviseHolder> CAdviseList;

    CAdviseList m_ListAdvise;       // A list of advise links
    DWORD m_dwNextCookie;           // Next advise link ID
    DWORD m_AdviseCount;            // Number of advise links
    CCache m_Cache;                 // Cache of CAdviseHolder objects
    BOOL m_bAbort;                  // TRUE if thread should abort
    HANDLE m_hThread;               // Thread handle
    DWORD m_ThreadID;               // Thread ID
    CAMEvent m_Event;                 // Notification event
    LARGE_INTEGER m_CurrentTime;    // Last notification time
    int  m_idGetTime;               // performance id for GetTime

    // This creates a new pending notification

    HRESULT CreateAdviseLink(
        LONGLONG RefTime,           // Advise me at this time
        LONGLONG RefPeriod,         // Period between notifications
        HANDLE hNotify,             // Notification mechanism
        DWORD *pdwAdviseCookie,     // where your cookie goes
        BOOL bPeriodic);            // Is this a one shot timer

    // These look after dispatching events to clients

    DWORD TimerEvent(BOOL bNotify);
    DWORD Notify();

    void DeleteEntry(CAdviseHolder *pAdviseHolder,
                     POSITION &pCurrent);

    CAdviseHolder *CreateEntry();

    LONGLONG Dispatch(CAdviseHolder *pAdviseHolder,POSITION pCurrent);
    LONGLONG inline ConvertToMillisecs(REFERENCE_TIME RT) const;
    static DWORD __stdcall TimerLoop(LPVOID lpvThreadParm);
};

#endif // __CLOCK__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\audpropi\audpropi.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#define MAX_INPUT_LINES     30
#define MIN_VOLUME_RANGE    0
#define MAX_VOLUME_RANGE    100
#define MAX_VOLUME_RANGEF   100
#define TONE_SCALE_FACTOR   10   // scale for better tone slider resolution


class CAudioInputMixerProperties;

class CAudioInputMixerProperties : public CBasePropertyPage
{

public:

    static CUnknown *WINAPI CreateInstance(LPUNKNOWN lpUnk,HRESULT *phr);
    DECLARE_IUNKNOWN;

private:

    CAudioInputMixerProperties(LPUNKNOWN pUnk,HRESULT *phr);
    ~CAudioInputMixerProperties();

    // IPropertyPage
    INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    // IAMAudioInputMixer dialog & data helpers
    HRESULT InitAIMDlg(HWND hwndParent);
    void    OnAIMSliderNotification(WPARAM wParam, LPARAM lParam);
    void    UpdateAIMPinControls( void );
    void    UpdateAIMFilterControls( void );
    void    SetAIMCurPinId( int iPinId ) { m_iAIMCurPinId = iPinId; }
    void    InitPinLinesAndLBContents( void );
    void    DeinitPinLines( void );
    DWORD   LinBalToKnobBal( LONG lBal );
    DWORD   LinVolToKnobVol( DWORD dwVol, DWORD dwMaxVolume );
    DWORD   KnobVolToLinVol( DWORD dwKnobVol, DWORD dwMaxVolume );
    LONG    KnobBalToLinBal( DWORD dwKnobBal );
    double  KnobLevelToToneLevel( DWORD dwKnobLevel, double dMaxLevel );
    DWORD   ToneLevelToKnobLevel( double dLevel, double dMaxLevel ); 

    double  ScaleToneLevel( double dLevel )
    {
        return dLevel * TONE_SCALE_FACTOR;
    }
    double   UnscaleToneLevel( double dScaledLevel )
    {
        return dScaledLevel/TONE_SCALE_FACTOR;
    }

    IBaseFilter * m_pFilter;

    // controls
    HWND    m_hwndAIMFilterVolSlider;
    HWND    m_hwndAIMFilterBalSlider;
    HWND    m_hwndAIMFilterBassSlider;
    HWND    m_hwndAIMFilterTrebleSlider;
    HWND    m_hwndAIMFilterEnable;
    HWND    m_hwndAIMFilterLoudness;
    HWND    m_hwndAIMFilterMono;
    HWND    m_hwndAIMPinVolSlider;
    HWND    m_hwndAIMPinBalSlider;
    HWND    m_hwndAIMPinBassSlider;
    HWND    m_hwndAIMPinTrebleSlider;
    HWND    m_hwndAIMPinEnable;
    HWND    m_hwndAIMPinLoudness;
    HWND    m_hwndAIMPinMono;
    HWND    m_hwndAIMPinSelect;

    int     m_iAIMCurPinId;             // current default input pin for dlg display

    // Filter & Pin IAMAudioInputMixer pointers
    IAMAudioInputMixer * m_pAIMFilter;
    IAMAudioInputMixer * m_apAIMPin[MAX_INPUT_LINES];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\audpropi\audpropi.cpp ===
// Copyright (c) Microsoft Corporation 1998. All Rights Reserved
 // DirectShow Input Audio Filter Property Pages, Michael Savage, August 1998

#include <streams.h>
#include <commctrl.h>
#include <tchar.h>
#include "audpropi.h"
#include "res.h"

#define AIM_CALL_TRACE_LEVEL 20 

// IAMAudioInputMixer page

// Constructor

CAudioInputMixerProperties::CAudioInputMixerProperties(LPUNKNOWN pUnk,HRESULT *phr) :
    CBasePropertyPage(NAME("Audio Input Mixer Page"),pUnk,IDD_AUDIOINPUTMIXER,IDS_AIM_PAGE_TITLE),
    m_pFilter( NULL ),
    m_pAIMFilter( NULL ),
    //filter controls
    m_hwndAIMFilterVolSlider( 0 ),    
    m_hwndAIMFilterBalSlider( 0 ),
    m_hwndAIMFilterTrebleSlider( 0 ),
    m_hwndAIMFilterBassSlider( 0 ),
    m_hwndAIMFilterEnable( 0 ),
    m_hwndAIMFilterLoudness( 0 ),
    m_hwndAIMFilterMono( 0 ),
    // pin controls
    m_hwndAIMPinVolSlider( 0 ),
    m_hwndAIMPinBalSlider( 0 ),  
    m_hwndAIMPinTrebleSlider( 0 ),
    m_hwndAIMPinBassSlider( 0 ),
    m_hwndAIMPinEnable( 0 ),
    m_hwndAIMPinLoudness( 0 ), 
    m_hwndAIMPinMono( 0 ),
    m_hwndAIMPinSelect( 0 ),
    m_iAIMCurPinId( -1 )
{
    ASSERT(phr);
    ZeroMemory( &m_apAIMPin[0], sizeof( IAMAudioInputMixer* ) * MAX_INPUT_LINES );
}

CAudioInputMixerProperties::~CAudioInputMixerProperties( void )
{
    ASSERT( !m_pFilter );
    ASSERT( !m_pAIMFilter );
}

// Create a properties object

CUnknown *WINAPI CAudioInputMixerProperties::CreateInstance(LPUNKNOWN lpUnk,HRESULT *phr)
{
    return new CAudioInputMixerProperties(lpUnk, phr);
}


// PropertyPage methods
  
// Handles the messages for our property window

INT_PTR CAudioInputMixerProperties::OnReceiveMessage(HWND hwnd,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    HRESULT hr = S_OK;
    LRESULT iState;
    
    switch (uMsg) {

        case WM_INITDIALOG:

            InitAIMDlg( hwnd );
            UpdateAIMFilterControls();
            InitPinLinesAndLBContents();
            UpdateAIMPinControls();
            return TRUE;

        case WM_VSCROLL:
            OnAIMSliderNotification(wParam, lParam);
            return TRUE;

        case WM_HSCROLL:
            OnAIMSliderNotification(wParam, lParam);
            return TRUE;

        case WM_COMMAND:

            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                // default pin changed
                int iIndex = (int)SendMessage (m_hwndAIMPinSelect, CB_GETCURSEL, 0, 0) ;
                
                SetAIMCurPinId( iIndex );
                UpdateAIMPinControls();

                return TRUE;
            }
            else
            {
                switch (LOWORD (wParam))
                {
                    case IDC_MIXER_PIN_ENABLE: //BN_CLICKED

                        iState = SendMessage (m_hwndAIMPinEnable, BM_GETCHECK, 0, 0) ;

                        hr = m_apAIMPin[m_iAIMCurPinId]->put_Enable( iState == BST_CHECKED ? TRUE : FALSE );
                        if( FAILED( hr ) )
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (pin #%d) put_Enable succeeded")
                                        , m_iAIMCurPinId)); 
                        else
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (pin #%d) put_Enable not supported (0x%08lx)")
                                        , m_iAIMCurPinId
                                        , hr)); 

                        return TRUE;
                        
                    case IDC_MIXER_FILTER_ENABLE:
                    
                        iState = SendMessage (m_hwndAIMFilterEnable, BM_GETCHECK, 0, 0) ;

                        m_pAIMFilter->put_Enable( iState == BST_CHECKED ? TRUE : FALSE );
                        if( SUCCEEDED( hr ) )
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (filter) put_Enable succeeded"))); 
                        else
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (filter) put_Enable not supported (0x%08lx)")
                                        , m_iAIMCurPinId
                                        , hr)); 
                        
                        return TRUE;
                        
                    case IDC_MIXER_PIN_LOUDNESS: 

                        iState = SendMessage (m_hwndAIMPinLoudness, BM_GETCHECK, 0, 0) ;

                        hr = m_apAIMPin[m_iAIMCurPinId]->put_Loudness( iState == BST_CHECKED ? TRUE : FALSE );
                        if( FAILED( hr ) )
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (pin #%d) put_Loudness succeeded")
                                        , m_iAIMCurPinId)); 
                        else
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (pin #%d) put_Loudness not supported (0x%08lx)")
                                        , m_iAIMCurPinId
                                        , hr)); 
                        return TRUE;
                        
                    case IDC_MIXER_FILTER_LOUDNESS:
                    
                        iState = SendMessage (m_hwndAIMFilterLoudness, BM_GETCHECK, 0, 0) ;

                        hr = m_pAIMFilter->put_Loudness( iState == BST_CHECKED ? TRUE : FALSE );
                        if( SUCCEEDED( hr ) )
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (filter) put_Loudness succeeded"))); 
                        else
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (filter) put_Loudness not supported (0x%08lx)")
                                        , m_iAIMCurPinId
                                        , hr)); 
                                        
                        return TRUE;
                        
                    case IDC_MIXER_PIN_MONO: 

                        iState = SendMessage (m_hwndAIMPinMono, BM_GETCHECK, 0, 0) ;

                        hr = m_apAIMPin[m_iAIMCurPinId]->put_Mono( iState == BST_CHECKED ? TRUE : FALSE );
                        if( FAILED( hr ) )
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (pin #%d) put_Mono succeeded")
                                        , m_iAIMCurPinId)); 
                        else
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (pin #%d) put_Mono not supported (0x%08lx)")
                                        , m_iAIMCurPinId
                                        , hr)); 
                        return TRUE;
                        
                    case IDC_MIXER_FILTER_MONO:
                    
                        iState = SendMessage (m_hwndAIMFilterMono, BM_GETCHECK, 0, 0) ;

                        hr = m_pAIMFilter->put_Mono( iState == BST_CHECKED ? TRUE : FALSE );
                        if( SUCCEEDED( hr ) )
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (filter) put_Mono succeeded"))); 
                        else
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (filter) put_Mono not supported (0x%08lx)")
                                        , m_iAIMCurPinId
                                        , hr)); 
                        return TRUE;
                        
                }
            }
            return (LRESULT) 1;
    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}

// Tells us the object that should be informed of the property changes

HRESULT CAudioInputMixerProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT( !m_pFilter );
    ASSERT( !m_pAIMFilter );

    HRESULT hr = pUnknown->QueryInterface(IID_IBaseFilter,(void **) &m_pFilter);
    if (FAILED(hr)) {
        return E_FAIL;
    }
    
    // Make sure at least the filter supports IAMAudioInputMixer

    hr = m_pFilter->QueryInterface(IID_IAMAudioInputMixer,(void **) &m_pAIMFilter);
    if (FAILED(hr)) {
        m_pFilter->Release();
        m_pFilter = NULL;
        return E_NOINTERFACE;
    }
    ASSERT(m_pAIMFilter);
    return NOERROR;
}

HRESULT CAudioInputMixerProperties::OnDisconnect()
{
    if( m_pAIMFilter )
    {
        m_pAIMFilter->Release();
        m_pAIMFilter = NULL;
    }
    if( m_pFilter )
    {
        m_pFilter->Release();
        m_pFilter = NULL;
    }
    DeinitPinLines();
    
    return NOERROR;
}


// Create the window we will use to edit properties
HRESULT CAudioInputMixerProperties::OnActivate()
{
    return NOERROR;
}

HRESULT CAudioInputMixerProperties::OnDeactivate()
{
    DeinitPinLines();
    return NOERROR;
}


// Apply any changes so far made

HRESULT CAudioInputMixerProperties::OnApplyChanges()
{
    return S_OK;
}

//------End of IPropertyPage methods--------//


//---------Control Data Handlers------------//

//
// OnSliderNotification
//
// Handle the notification messages for the slider controls
//
void CAudioInputMixerProperties::OnAIMSliderNotification(WPARAM wParam, LPARAM lParam)
{
    int     iVPos;
    int     iBPos;
    DWORD   dwVol = 0;
    DWORD   cbData = 0;
    HRESULT hr;
    long    lLinearValue;
    long    lLogVol;    
    long    lLogBal;    
    double  Level;
    
    switch (wParam)
    {
        case TB_BOTTOM:

            break;

        case TB_TOP:

            break;

        case TB_PAGEDOWN:
        case TB_PAGEUP:

            break;

        case TB_THUMBPOSITION:
        case TB_ENDTRACK:

            // set the corresponding filter slider level
            if (lParam == (LPARAM)m_hwndAIMFilterVolSlider)
            {
                iVPos = (int) SendMessage(m_hwndAIMFilterVolSlider, TBM_GETPOS, 0, 0L);
            
                lLinearValue = KnobVolToLinVol( iVPos, MAX_VOLUME_RANGE );
            
                Level = (double)lLinearValue/MAX_VOLUME_RANGEF;
                hr = m_pAIMFilter->put_MixLevel( Level );
                if( SUCCEEDED( hr ) )
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (filter) put_MixLevel %s succeeded"), CDisp(Level))); 
                else
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (filter) put_MixLevel %s failed (0x%08lx)")
                                , CDisp(Level)
                                    , hr)); 
            }    
            else if( lParam == (LPARAM)m_hwndAIMFilterBalSlider)
            {
                iBPos = (int) SendMessage(m_hwndAIMFilterBalSlider, TBM_GETPOS, 0, 0L);
            
                lLinearValue = KnobBalToLinBal( iBPos );

                double Pan = (double)lLinearValue/MAX_VOLUME_RANGEF;
                hr = m_pAIMFilter->put_Pan( Pan );
                if( SUCCEEDED( hr ) )
                    DbgLog( (LOG_TRACE                                
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (filter) put_Pan %s succeeded"), CDisp(Pan))); 
                else
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (filter) put_Pan %s not supported (0x%08lx)")
                                , CDisp(Pan)
                                , hr)); 
            }
            else if( lParam == (LPARAM)m_hwndAIMFilterTrebleSlider )
            {
                // first get range
                double dTrebleRange = 0;
                hr = m_pAIMFilter->get_TrebleRange( &dTrebleRange );
                if( SUCCEEDED( hr ) )
                {
                
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (filter) get_TrebleRange returned %s")
                                , CDisp(dTrebleRange))); 
                
                    iVPos = (int) SendMessage(m_hwndAIMFilterTrebleSlider, TBM_GETPOS, 0, 0L);
                    
                    double dToneLevel = KnobLevelToToneLevel( iVPos, dTrebleRange );
                    hr = m_pAIMFilter->put_Treble( dToneLevel );
                    if( SUCCEEDED( hr ) )
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (filter) put_Treble %s succeeded"), CDisp(dToneLevel))); 
                    else
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (filter) put_Treble %s not supported (0x%08lx)")
                                    , CDisp(dToneLevel)
                                    , hr)); 
                }
                else
                    DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (filter) get_TrebleRange not supported (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
            }
            else if( lParam == (LPARAM)m_hwndAIMFilterBassSlider )
            {
                // first get range
                double dBassRange = 0;
                hr = m_pAIMFilter->get_BassRange( &dBassRange );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (filter) get_BassRange returned %s")
                                , CDisp(dBassRange))); 
                                
                    iVPos = (int) SendMessage(m_hwndAIMFilterBassSlider, TBM_GETPOS, 0, 0L);
                    
                    double dToneLevel = KnobLevelToToneLevel( iVPos, dBassRange );
                    hr = m_pAIMFilter->put_Bass( dToneLevel );
                    if( SUCCEEDED( hr ) )
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (filter) put_Bass %s succeeded"), CDisp(dToneLevel))); 
                    else
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (filter) put_Bass %s not supported (0x%08lx)")
                                    , CDisp(dToneLevel)
                                    , hr)); 
                }
                else
                    DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (filter) get_BassRange not supported (0x%08lx)"), hr)); 
            }
            // Pin sliders
            else if( lParam == (LPARAM)m_hwndAIMPinVolSlider )
            {
                ASSERT( m_apAIMPin[m_iAIMCurPinId] );
                iVPos = (int) SendMessage(m_hwndAIMPinVolSlider, TBM_GETPOS, 0, 0L);
            
                lLinearValue = KnobVolToLinVol( iVPos, MAX_VOLUME_RANGE );
            
                Level = (double)lLinearValue/MAX_VOLUME_RANGEF;
                hr = m_apAIMPin[m_iAIMCurPinId]->put_MixLevel( Level );
                if( SUCCEEDED( hr ) )
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) put_MixLevel %s succeeded")
                                , m_iAIMCurPinId
                                , CDisp(Level))); 
                else
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) put_MixLevel %s failed (0x%08lx)")
                                , m_iAIMCurPinId
                                , CDisp(Level)
                                , hr)); 
            }
            else if( lParam == (LPARAM)m_hwndAIMPinBalSlider)
            {
                ASSERT( m_apAIMPin[m_iAIMCurPinId] );
                iBPos = (int) SendMessage(m_hwndAIMPinBalSlider, TBM_GETPOS, 0, 0L);
    
                lLinearValue = KnobBalToLinBal( iBPos );
            
                double Pan = (double)lLinearValue/MAX_VOLUME_RANGEF;
                hr = m_apAIMPin[m_iAIMCurPinId]->put_Pan( Pan );
                if( SUCCEEDED( hr ) )
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) put_Pan %s succeeded")
                                , m_iAIMCurPinId
                                , CDisp(Pan))); 
                else
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) put_Pan %s failed (0x%08lx)")
                                , m_iAIMCurPinId
                                , CDisp(Pan)
                                , hr)); 
            }
            else if( lParam == (LPARAM)m_hwndAIMPinTrebleSlider)
            {
                ASSERT( m_apAIMPin[m_iAIMCurPinId] );
                double dTrebleRange = 0;
                hr = m_apAIMPin[m_iAIMCurPinId]->get_TrebleRange( &dTrebleRange );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) get_TrebleRange returned %s")
                                , m_iAIMCurPinId
                                , CDisp(dTrebleRange))); 
                    iVPos = (int) SendMessage(m_hwndAIMPinTrebleSlider, TBM_GETPOS, 0, 0L);
                    
                    double dToneLevel = KnobLevelToToneLevel( iVPos, dTrebleRange );
                    hr = m_apAIMPin[m_iAIMCurPinId]->put_Treble( dToneLevel );
                    if( SUCCEEDED( hr ) )
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (pin # %d) put_Treble %s succeeded")
                                    , m_iAIMCurPinId
                                    , CDisp(dToneLevel)));
                    else
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (pin # %d) put_Treble %s failed (0x%08lx)")
                                    , m_iAIMCurPinId
                                    , CDisp(dToneLevel)
                                    , hr)); 
                }
                else
                    DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_TrebleRange not supported (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
            }
            else if( lParam == (LPARAM)m_hwndAIMPinBassSlider )
            {
                ASSERT( m_apAIMPin[m_iAIMCurPinId] );
                // first get range
                double dBassRange = 0;
                hr = m_apAIMPin[m_iAIMCurPinId]->get_BassRange( &dBassRange );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) get_BassRange returned %s")
                                , m_iAIMCurPinId
                                , CDisp(dBassRange))); 
                    iVPos = (int) SendMessage(m_hwndAIMPinBassSlider, TBM_GETPOS, 0, 0L);
                    
                    double dToneLevel = KnobLevelToToneLevel( iVPos, dBassRange );
                    hr = m_apAIMPin[m_iAIMCurPinId]->put_Bass( dToneLevel );
                    if( SUCCEEDED( hr ) )
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (pin # %d) put_Bass %s succeeded")
                                    , m_iAIMCurPinId
                                    , CDisp(dToneLevel)));
                    else
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (pin # %d) put_Bass %s failed (0x%08lx)")
                                    , m_iAIMCurPinId
                                    , CDisp(dToneLevel)
                                    , hr)); 
                }
                else
                    DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_BassRange not supported (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
            }                                
            
            
            break;

        case TB_THUMBTRACK: // default handling of these messages is ok.
        case TB_LINEDOWN:
        case TB_LINEUP:

            break;
    }

} // OnSliderNotification



//
// InitAIMDlg
//
// load hwnds for all dlg controls
//
HRESULT CAudioInputMixerProperties::InitAIMDlg(HWND hwndParent)
{
    HRESULT  hr;
    
    ASSERT( m_pAIMFilter );

    // initialize control hwnds...
    // for filter
    m_hwndAIMFilterVolSlider =      ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_VOLUME);
    m_hwndAIMFilterBalSlider =      ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_BALANCE);
    m_hwndAIMFilterTrebleSlider =   ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_TREBLE_LEVEL);
    m_hwndAIMFilterBassSlider =     ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_BASS_LEVEL);
    m_hwndAIMFilterEnable =         ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_ENABLE);
    m_hwndAIMFilterLoudness =       ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_LOUDNESS);
    m_hwndAIMFilterMono =           ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_MONO);

    // for pin
    m_hwndAIMPinVolSlider =         ::GetDlgItem(hwndParent, IDC_MIXER_PIN_VOLUME);
    m_hwndAIMPinBalSlider =         ::GetDlgItem(hwndParent, IDC_MIXER_PIN_BALANCE);
    m_hwndAIMPinTrebleSlider =      ::GetDlgItem(hwndParent, IDC_MIXER_PIN_TREBLE_LEVEL);
    m_hwndAIMPinBassSlider =        ::GetDlgItem(hwndParent, IDC_MIXER_PIN_BASS_LEVEL);
    m_hwndAIMPinEnable =            ::GetDlgItem(hwndParent, IDC_MIXER_PIN_ENABLE);
    m_hwndAIMPinLoudness =          ::GetDlgItem(hwndParent, IDC_MIXER_PIN_LOUDNESS);
    m_hwndAIMPinMono =              ::GetDlgItem(hwndParent, IDC_MIXER_PIN_MONO);
    m_hwndAIMPinSelect =            ::GetDlgItem(hwndParent, IDC_MIXER_PIN_SELECT);

    // initialize slider ranges we know
    SendMessage(m_hwndAIMFilterVolSlider, TBM_SETRANGE, TRUE, MAKELONG(0, MAX_VOLUME_RANGE));
    SendMessage(m_hwndAIMFilterBalSlider, TBM_SETRANGE, TRUE, MAKELONG(0, MAX_VOLUME_RANGE));
    SendMessage(m_hwndAIMPinVolSlider, TBM_SETRANGE, TRUE, MAKELONG(0, MAX_VOLUME_RANGE));
    SendMessage(m_hwndAIMPinBalSlider, TBM_SETRANGE, TRUE, MAKELONG(0, MAX_VOLUME_RANGE));

    return S_OK;

}  // InitAIMDlg

//
// InitPinLinesLBContents
//
// Query filter pins for support of IAMAudioInputMixer and load list box contents
// with pins names that support the interface
//
void CAudioInputMixerProperties::InitPinLinesAndLBContents( void )
{
    ASSERT( !m_apAIMPin[0] );
    
    //
    // query the input pins for interface support
    //
    int wextent = 0 ;
    SIZE extent ;

    IEnumPins * pEnum;    
    int iInputLines = 0; 

    //
    // get a dc for the pin combo box control. need this to get the extent of the strings
    // that we put in the list box (so that we can get a horiz scroll bar).
    //
    ASSERT( m_hwndAIMPinSelect );
    HDC hdc = GetDC (m_hwndAIMPinSelect) ;
    if( NULL == hdc )
    {
        return;
    }        
    
    HRESULT hr = m_pFilter->EnumPins( &pEnum );
    ASSERT( SUCCEEDED( hr ) );
    if( SUCCEEDED( hr ) )
    {
        IPin * pPin;
        ULONG  ul;
        //
        // we use i in the loop below just to count the total input pins on the filter 
        // for help debugging, whereas iInputLines is the current count of input pins 
        // which also support IAMAudioInputMixer
        //
        for( int i = 0 ; iInputLines < MAX_INPUT_LINES; )
        {
            ASSERT( MAX_INPUT_LINES > iInputLines );
            
            hr = pEnum->Next(1,  &pPin, &ul );
            ASSERT( SUCCEEDED( hr ) );
            if( S_OK != hr )
                break;
            else if( SUCCEEDED( hr ) )
            {
                PIN_DIRECTION dir;
                hr = pPin->QueryDirection( &dir );
                if( SUCCEEDED( hr ) && PINDIR_INPUT == dir)
                {
                    // query all input pins for the interface
                    hr = pPin->QueryInterface(IID_IAMAudioInputMixer, (void **)&m_apAIMPin[iInputLines]);
                    if( FAILED( hr ) )
                    {
                        DbgLog((LOG_TRACE, AIM_CALL_TRACE_LEVEL, TEXT("Input pin %d doesn't support IAMAudioInputMixer (0x%08lx)"),i,hr));    
                    }
                    else
                    {
                        PIN_INFO pinfo;
                        
                        hr = pPin->QueryPinInfo( &pinfo );
                        if( SUCCEEDED( hr ) )
                        {
                            TCHAR szPinName[MAX_PATH];
#ifdef UNICODE
                            lstrcpy(szPinName, pinfo.achName);
#else
            	            WideCharToMultiByte( CP_ACP, 0, pinfo.achName, -1, szPinName, sizeof(szPinName), 0, 0 );
#endif
                            //
                            // get the extent of the string and save the max extent
                            //
                            GetTextExtentPoint32 (hdc, szPinName, _tcslen(szPinName), &extent) ;
                            if (extent.cx > wextent)
                                wextent = extent.cx ;
                            //
                            // add the string to the list box.
                            //
                            LRESULT ix;
                            ix = SendMessage (m_hwndAIMPinSelect, CB_INSERTSTRING, iInputLines, (LPARAM)(LPCTSTR)szPinName) ;
                            ASSERT (CB_ERR != ix);
                            
                            pinfo.pFilter->Release();
                            iInputLines++;
                        }
                    }
                    i++; // use to count total input pins
                }
                pPin->Release();
            }            
        }
        if( iInputLines )
        {
            SendMessage (m_hwndAIMPinSelect, CB_SETHORIZONTALEXTENT, wextent, 0) ;
            
            // select a default input pin line
            if( -1 == m_iAIMCurPinId || m_iAIMCurPinId >= iInputLines )
            {
                // if we don't already have one due to reactivation than pick the 1st
                m_iAIMCurPinId = 0;
            }

            // init default in,put pin to fill details in on
            SendMessage (m_hwndAIMPinSelect, CB_SETCURSEL, m_iAIMCurPinId, 0) ;
        }
        pEnum->Release();
    }
    ReleaseDC( m_hwndAIMPinSelect, hdc );    
}

//
// DeinitPinLines
//
// release IAMAudioInputMixer interface on pins
//
void CAudioInputMixerProperties::DeinitPinLines( void )
{
    // leave current m_iAIMCurPinId as is, in case we come back to the page
    for( int i = 0 ; i < MAX_INPUT_LINES && m_apAIMPin[i]; i ++)
    {
        m_apAIMPin[i]->Release();
        m_apAIMPin[i] = NULL;
    }
}

//
// UpdateAIMFilterControls
//
// Update control details for the current filter line
//
void CAudioInputMixerProperties::UpdateAIMFilterControls( void )
{
    HRESULT hr = S_OK;
    
    ASSERT( m_pAIMFilter );
    if( !m_pAIMFilter )
        return;
    
    // initialize filter control data
    double Level;
    hr = m_pAIMFilter->get_MixLevel( &Level );
    EnableWindow (m_hwndAIMFilterVolSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_MixLevel returned %s"), CDisp(Level))); 

        DWORD dwScaledLinVol = LinVolToKnobVol( (DWORD) (Level * MAX_VOLUME_RANGE)
                                              , MAX_VOLUME_RANGE );
        SendMessage(m_hwndAIMFilterVolSlider, TBM_SETPOS, TRUE, (int)(dwScaledLinVol));            
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_MixLevel failed (0x%08lx)"), hr)); 
    

    double Pan;
    hr = m_pAIMFilter->get_Pan( &Pan );
    EnableWindow (m_hwndAIMFilterBalSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Pan returned %s"), CDisp(Pan))); 

        long lLinPan = (DWORD) (Pan * MAX_VOLUME_RANGEF);
        DWORD dwKnobBal = LinBalToKnobBal (lLinPan);

        SendMessage(m_hwndAIMFilterBalSlider, TBM_SETPOS, TRUE, dwKnobBal);            
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Pan failed (0x%08lx)"), hr)); 

    BOOL bEnable;
    hr = m_pAIMFilter->get_Enable( &bEnable );
    EnableWindow (m_hwndAIMFilterEnable, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Enable returned %d"), bEnable)); 

        Button_SetCheck(m_hwndAIMFilterEnable, bEnable);
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Enable failed (0x%08lx)"), hr)); 
    
    BOOL bMono;
    hr = m_pAIMFilter->get_Mono( &bMono );
    EnableWindow (m_hwndAIMFilterMono, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Mono returned %d"), bMono)); 
        Button_SetCheck(m_hwndAIMFilterMono, bMono);
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Mono failed (0x%08lx)"), hr)); 
    
    BOOL bLoudness;
    hr = m_pAIMFilter->get_Loudness( &bLoudness );
    EnableWindow (m_hwndAIMFilterLoudness, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_LoudnessEnable returned %d"), bLoudness)); 
        Button_SetCheck(m_hwndAIMFilterLoudness, bLoudness);
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Loudness failed (0x%08lx)"), hr)); 
    
    double dTreble;
    hr = m_pAIMFilter->get_Treble( &dTreble );
    EnableWindow (m_hwndAIMFilterTrebleSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Treble returned %s"), CDisp(dTreble))); 
        
        double dTrebleRange = 0;
        hr = m_pAIMFilter->get_TrebleRange( &dTrebleRange );
        if( SUCCEEDED( hr ) )
        {
            DbgLog( (LOG_TRACE
                  , AIM_CALL_TRACE_LEVEL
                  , TEXT("AudioInputMixer Properties (filter) get_TrebleRange returned %s")
                        , CDisp(dTrebleRange))); 
        
            SendMessage( m_hwndAIMFilterTrebleSlider
                       , TBM_SETRANGE
                       , TRUE
                       , MAKELONG(0, ScaleToneLevel(dTrebleRange) ) ); // allow for + and - levels
            DWORD dwKnobLevel = ToneLevelToKnobLevel( dTreble, dTrebleRange );
            SendMessage(m_hwndAIMFilterTrebleSlider, TBM_SETPOS, TRUE, dwKnobLevel);
        }
        else
            ASSERT( FALSE ); // better not happen!
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Treble failed (0x%08lx)"), hr)); 
    
    double dBass;
    hr = m_pAIMFilter->get_Bass( &dBass );
    EnableWindow (m_hwndAIMFilterBassSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Bass returned %s"), CDisp(dBass))); 
        
        double dBassRange = 0;
        hr = m_pAIMFilter->get_BassRange( &dBassRange );
        if( SUCCEEDED( hr ) )
        {
            DbgLog( (LOG_TRACE
                  , AIM_CALL_TRACE_LEVEL
                  , TEXT("AudioInputMixer Properties (filter) get_BassRange returned %s")
                        , CDisp(dBassRange))); 
            
            // assume linear for now
            SendMessage( m_hwndAIMFilterBassSlider
                       , TBM_SETRANGE
                       , TRUE
                       , MAKELONG(0, ScaleToneLevel(dBassRange) ) ); // allow for + and - levels
            DWORD dwKnobLevel = ToneLevelToKnobLevel( dBass, dBassRange );
            SendMessage(m_hwndAIMFilterBassSlider, TBM_SETPOS, TRUE, dwKnobLevel);
        }
        else
            ASSERT( FALSE ); // better not happen!            
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Bass failed (0x%08lx)"), hr)); 
}

//
// UpdateAIMPinControls
//
// Fill in control details for the current pin lines
//
void CAudioInputMixerProperties::UpdateAIMPinControls( void )
{
    HRESULT hr = S_OK;
    
    // now create controls for the pin lines
    if( -1 != m_iAIMCurPinId )
    {
        // initialize the current pin line's settings
        if( m_apAIMPin[m_iAIMCurPinId] )
        {
            double Level;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_MixLevel( &Level );
            EnableWindow (m_hwndAIMPinVolSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_MixLevel returned %s")
                            , m_iAIMCurPinId
                            , CDisp(Level))); 
                  
                DWORD dwScaledLinVol = LinVolToKnobVol( (DWORD) (Level * MAX_VOLUME_RANGE)
                                                      , MAX_VOLUME_RANGE );
                SendMessage(m_hwndAIMPinVolSlider, TBM_SETPOS, TRUE, (int)(dwScaledLinVol)); 
            }
            else
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_MixLevel failed (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
                
            double Pan;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_Pan( &Pan );
            EnableWindow (m_hwndAIMPinBalSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Pan returned %s")
                            , m_iAIMCurPinId
                            , CDisp(Pan))); 

                long lLinPan = (DWORD) (Pan * MAX_VOLUME_RANGE);
                DWORD dwKnobBal = LinBalToKnobBal (lLinPan);

                SendMessage(m_hwndAIMPinBalSlider, TBM_SETPOS, TRUE, (DWORD)(dwKnobBal));            
            }
            else
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Pan failed (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
            
            BOOL bEnable;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_Enable( &bEnable );
            EnableWindow (m_hwndAIMPinEnable, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Enable returned %d")
                            , m_iAIMCurPinId
                            , bEnable)); 
                Button_SetCheck(m_hwndAIMPinEnable, bEnable);
            }
            else
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Enable failed (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
            
            BOOL bMono;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_Mono( &bMono );
            EnableWindow (m_hwndAIMPinMono, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Mono returned %d")
                            , m_iAIMCurPinId
                            , bMono)); 
                Button_SetCheck(m_hwndAIMPinMono, bMono);
            }
            else
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Mono failed (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 

            BOOL bLoudness;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_Loudness( &bLoudness );
            EnableWindow (m_hwndAIMPinLoudness, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Loudness returned %d")
                            , m_iAIMCurPinId
                            , bLoudness)); 
                Button_SetCheck(m_hwndAIMPinLoudness, bLoudness);
            }
            else
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Loudness failed (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
            
            double dTreble;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_Treble( &dTreble );
            EnableWindow (m_hwndAIMPinTrebleSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Treble returned %s")
                            , m_iAIMCurPinId
                            , CDisp(Level))); 
                
                double dTrebleRange = 0;
                hr = m_apAIMPin[m_iAIMCurPinId]->get_TrebleRange( &dTrebleRange );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) get_TrebleRange returned %s")
                                , m_iAIMCurPinId
                                , CDisp(dTrebleRange))); 
                
                    // assume linear for now
                    SendMessage( m_hwndAIMPinTrebleSlider
                               , TBM_SETRANGE
                               , TRUE
                               , MAKELONG(0, ScaleToneLevel(dTrebleRange) ) ); // allow for + and - levels
                    DWORD dwKnobLevel = ToneLevelToKnobLevel( dTreble, dTrebleRange );
                    SendMessage(m_hwndAIMPinTrebleSlider, TBM_SETPOS, TRUE, dwKnobLevel);
                }
                else
                    ASSERT( FALSE ); // better not happen!
            }
        
            double dBass;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_Bass( &dBass );
            EnableWindow (m_hwndAIMPinBassSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Bass returned %s")
                            , m_iAIMCurPinId
                            , CDisp(Level))); 

                double dBassRange = 0;
                hr = m_apAIMPin[m_iAIMCurPinId]->get_BassRange( &dBassRange );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) get_BassRange returned %s")
                                , m_iAIMCurPinId
                                , CDisp(dBassRange))); 
                    
                    // assume linear for now
                    SendMessage( m_hwndAIMPinBassSlider
                               , TBM_SETRANGE
                               , TRUE
                               , MAKELONG(0, ScaleToneLevel(dBassRange) ) ); // allow for + and - levels
                    DWORD dwKnobLevel = ToneLevelToKnobLevel( dBass, dBassRange );
                    SendMessage(m_hwndAIMPinBassSlider, TBM_SETPOS, TRUE, dwKnobLevel);
                }
                else
                    ASSERT( FALSE ); // better not happen!    
            }
        } else {
            ASSERT(FALSE);
        }
    }
    else
    {
        // else no pins support intf, so disable all pin controls
        EnableWindow (m_hwndAIMPinVolSlider, FALSE);
        EnableWindow (m_hwndAIMPinBalSlider, FALSE);
        EnableWindow (m_hwndAIMPinEnable, FALSE);
        EnableWindow (m_hwndAIMPinMono, FALSE);
        EnableWindow (m_hwndAIMPinLoudness, FALSE);
        EnableWindow (m_hwndAIMPinTrebleSlider, FALSE);
        EnableWindow (m_hwndAIMPinBassSlider, FALSE);
    }    
}

//
// LinBalToKnobBal
//
// convert a signed linear balance value between +/- MAX_VOLUME_RANGE to an 
// unsigned dialog slider position
//
DWORD CAudioInputMixerProperties::LinBalToKnobBal( LONG lBal )
{
    DWORD dwKnobBal;
    
    if( lBal > 0 )
    {
    	dwKnobBal = (lBal - MIN_VOLUME_RANGE) / 2
        	     + (MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) / 2;
    }
    else 
    {
    	dwKnobBal = (MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) / 2
                   - (MIN_VOLUME_RANGE - lBal) / 2;
    }
    return dwKnobBal;
}

//
// LinVolToKnobVol
//
// convert a linear volume value between 0 and MaxVolume range to the 
// corresponding dialog vertical slider position.
//
DWORD CAudioInputMixerProperties::LinVolToKnobVol( DWORD dwVol, DWORD dwMaxVolume )
{
    DWORD dwKnobVol = dwMaxVolume - dwVol;

    return dwKnobVol;
}


//
// KnobBalToLinBal
//
// convert a dialog slider position to a signed linear balance value 
// between +/- MAX_VOLUME_RANGE
//
LONG CAudioInputMixerProperties::KnobBalToLinBal( DWORD dwKnobBal )
{
    LONG lLinBal;

    // In which half is the pan value?
    if( dwKnobBal > (MIN_VOLUME_RANGE + MAX_VOLUME_RANGE) / 2) {
        lLinBal = -(LONG)((MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) -
                        dwKnobBal - (MIN_VOLUME_RANGE + MAX_VOLUME_RANGE) / 2) * 2 +  
                        MIN_VOLUME_RANGE;
    }
    else
    {
        lLinBal = (dwKnobBal - (MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) / 2) * 2 + 
                       MIN_VOLUME_RANGE;
    }
    return lLinBal;
}


//
// KnobVolToLinVol
//
// convert a dialog vertical slider position to a linear volume value 
// between 0 and MaxVolume
//
DWORD CAudioInputMixerProperties::KnobVolToLinVol( DWORD dwKnobVol, DWORD dwMaxVolume )
{
    DWORD dwLinVol = dwMaxVolume - dwKnobVol;

    return dwLinVol;
}

//
// KnobLevelToToneLevel
//
// convert a tone slider position to a signed db level between +/- dMaxLevel 
// just assume linear for now
//
double CAudioInputMixerProperties::KnobLevelToToneLevel( DWORD dwKnobLevel, double dMaxLevel )
{
    double dLevel;
    double dMaxKnobLevel = ScaleToneLevel(dMaxLevel); // convert to max knob level

    // In which half is the value?
    if( dwKnobLevel > dMaxKnobLevel / 2) {
        dLevel = -(dMaxKnobLevel - dwKnobLevel - dMaxKnobLevel / 2) * 2;
    }
    else
    {
        dLevel = (dwKnobLevel - dMaxKnobLevel / 2) * 2;
    }
    
    return UnscaleToneLevel(dLevel); // remove the scale factor before returning
}

//
// ToneLevelToKnobLevel
//
// convert a signed db level between +/- dMaxLevel to a tone slider positon
// just assign linear for now
//
DWORD CAudioInputMixerProperties::ToneLevelToKnobLevel( double dLevel, double dMaxLevel )
{
    DWORD dwKnobLevel;
    
    // not that we scale the levels for better slider resolution    
    if( dLevel > 0 )
    {
    	dwKnobLevel = (DWORD) ( ScaleToneLevel(dLevel) / 2 + 
                                ScaleToneLevel(dMaxLevel) / 2);
    }
    else 
    {
    	dwKnobLevel = (DWORD) ( ScaleToneLevel(dMaxLevel) / 2 - 
                              (-ScaleToneLevel(dLevel) / 2 ) );
    }
    return dwKnobLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\util\clock\code\makefile.inc ===
# NOTE:
# this directory contains a makefile which contains a single line that
# includes the global build process makefile.def. If the
# NTTARGETFILE1 or NTTARGETFILE0 environment
# variable is set then makefile.def includes makefile.inc from the current
# directory. This makefile.inc creates an extra target for nmake to create
# when it is run. NTTARGETFILE0 is built before everything else, and
# NTTARGETFILE1 is built after everything else.

copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll     \
         $(SDK_ROOT)\bin\*.*
  @if not exist $(QUARTZ)\lib\$(TARGET_DIRECTORY)\nul
         md $(QUARTZ)\lib\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib     \
         $(QUARTZ)\lib\$(TARGET_DIRECTORY)\*.*

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\filter\decg711.h ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    decg711.h

Abstract:

    This module contains the G711 decoding functions.

Author:

    Mu Han (muhan) May-15-1999

--*/

#ifndef __DECG711_H__
#define __DECG711_H__

//--------------------------------------------------------------------------;
//
//  Name:
//      AlawToPcmTable
//
//
//  Description:
//      this array maps A-law characters to 16-bit PCM
//
//      
//  Arguments:
//      the index into the array is an A-law character
//
//  Return:
//      an element of the array is a 16-bit PCM value
//
//  Notes:
//
//
//  History:
//      07/28/93    Created.
//
//
//--------------------------------------------------------------------------;
const SHORT AlawToPcmTable[256] =
    {
         -5504,         // y[00]=   -688
         -5248,         // y[01]=   -656
         -6016,         // y[02]=   -752
         -5760,         // y[03]=   -720
         -4480,         // y[04]=   -560
         -4224,         // y[05]=   -528
         -4992,         // y[06]=   -624
         -4736,         // y[07]=   -592
         -7552,         // y[08]=   -944
         -7296,         // y[09]=   -912
         -8064,         // y[0a]=  -1008
         -7808,         // y[0b]=   -976
         -6528,         // y[0c]=   -816
         -6272,         // y[0d]=   -784
         -7040,         // y[0e]=   -880
         -6784,         // y[0f]=   -848
         -2752,         // y[10]=   -344
         -2624,         // y[11]=   -328
         -3008,         // y[12]=   -376
         -2880,         // y[13]=   -360
         -2240,         // y[14]=   -280
         -2112,         // y[15]=   -264
         -2496,         // y[16]=   -312
         -2368,         // y[17]=   -296
         -3776,         // y[18]=   -472
         -3648,         // y[19]=   -456
         -4032,         // y[1a]=   -504
         -3904,         // y[1b]=   -488
         -3264,         // y[1c]=   -408
         -3136,         // y[1d]=   -392
         -3520,         // y[1e]=   -440
         -3392,         // y[1f]=   -424
        -22016,         // y[20]=  -2752
        -20992,         // y[21]=  -2624
        -24064,         // y[22]=  -3008
        -23040,         // y[23]=  -2880
        -17920,         // y[24]=  -2240
        -16896,         // y[25]=  -2112
        -19968,         // y[26]=  -2496
        -18944,         // y[27]=  -2368
        -30208,         // y[28]=  -3776
        -29184,         // y[29]=  -3648
        -32256,         // y[2a]=  -4032
        -31232,         // y[2b]=  -3904
        -26112,         // y[2c]=  -3264
        -25088,         // y[2d]=  -3136
        -28160,         // y[2e]=  -3520
        -27136,         // y[2f]=  -3392
        -11008,         // y[30]=  -1376
        -10496,         // y[31]=  -1312
        -12032,         // y[32]=  -1504
        -11520,         // y[33]=  -1440
         -8960,         // y[34]=  -1120
         -8448,         // y[35]=  -1056
         -9984,         // y[36]=  -1248
         -9472,         // y[37]=  -1184
        -15104,         // y[38]=  -1888
        -14592,         // y[39]=  -1824
        -16128,         // y[3a]=  -2016
        -15616,         // y[3b]=  -1952
        -13056,         // y[3c]=  -1632
        -12544,         // y[3d]=  -1568
        -14080,         // y[3e]=  -1760
        -13568,         // y[3f]=  -1696
          -344,         // y[40]=    -43
          -328,         // y[41]=    -41
          -376,         // y[42]=    -47
          -360,         // y[43]=    -45
          -280,         // y[44]=    -35
          -264,         // y[45]=    -33
          -312,         // y[46]=    -39
          -296,         // y[47]=    -37
          -472,         // y[48]=    -59
          -456,         // y[49]=    -57
          -504,         // y[4a]=    -63
          -488,         // y[4b]=    -61
          -408,         // y[4c]=    -51
          -392,         // y[4d]=    -49
          -440,         // y[4e]=    -55
          -424,         // y[4f]=    -53
           -88,         // y[50]=    -11
           -72,         // y[51]=     -9
          -120,         // y[52]=    -15
          -104,         // y[53]=    -13
           -24,         // y[54]=     -3
            -8,         // y[55]=     -1
           -56,         // y[56]=     -7
           -40,         // y[57]=     -5
          -216,         // y[58]=    -27
          -200,         // y[59]=    -25
          -248,         // y[5a]=    -31
          -232,         // y[5b]=    -29
          -152,         // y[5c]=    -19
          -136,         // y[5d]=    -17
          -184,         // y[5e]=    -23
          -168,         // y[5f]=    -21
         -1376,         // y[60]=   -172
         -1312,         // y[61]=   -164
         -1504,         // y[62]=   -188
         -1440,         // y[63]=   -180
         -1120,         // y[64]=   -140
         -1056,         // y[65]=   -132
         -1248,         // y[66]=   -156
         -1184,         // y[67]=   -148
         -1888,         // y[68]=   -236
         -1824,         // y[69]=   -228
         -2016,         // y[6a]=   -252
         -1952,         // y[6b]=   -244
         -1632,         // y[6c]=   -204
         -1568,         // y[6d]=   -196
         -1760,         // y[6e]=   -220
         -1696,         // y[6f]=   -212
          -688,         // y[70]=    -86
          -656,         // y[71]=    -82
          -752,         // y[72]=    -94
          -720,         // y[73]=    -90
          -560,         // y[74]=    -70
          -528,         // y[75]=    -66
          -624,         // y[76]=    -78
          -592,         // y[77]=    -74
          -944,         // y[78]=   -118
          -912,         // y[79]=   -114
         -1008,         // y[7a]=   -126
          -976,         // y[7b]=   -122
          -816,         // y[7c]=   -102
          -784,         // y[7d]=    -98
          -880,         // y[7e]=   -110
          -848,         // y[7f]=   -106
          5504,         // y[80]=    688
          5248,         // y[81]=    656
          6016,         // y[82]=    752
          5760,         // y[83]=    720
          4480,         // y[84]=    560
          4224,         // y[85]=    528
          4992,         // y[86]=    624
          4736,         // y[87]=    592
          7552,         // y[88]=    944
          7296,         // y[89]=    912
          8064,         // y[8a]=   1008
          7808,         // y[8b]=    976
          6528,         // y[8c]=    816
          6272,         // y[8d]=    784
          7040,         // y[8e]=    880
          6784,         // y[8f]=    848
          2752,         // y[90]=    344
          2624,         // y[91]=    328
          3008,         // y[92]=    376
          2880,         // y[93]=    360
          2240,         // y[94]=    280
          2112,         // y[95]=    264
          2496,         // y[96]=    312
          2368,         // y[97]=    296
          3776,         // y[98]=    472
          3648,         // y[99]=    456
          4032,         // y[9a]=    504
          3904,         // y[9b]=    488
          3264,         // y[9c]=    408
          3136,         // y[9d]=    392
          3520,         // y[9e]=    440
          3392,         // y[9f]=    424
         22016,         // y[a0]=   2752
         20992,         // y[a1]=   2624
         24064,         // y[a2]=   3008
         23040,         // y[a3]=   2880
         17920,         // y[a4]=   2240
         16896,         // y[a5]=   2112
         19968,         // y[a6]=   2496
         18944,         // y[a7]=   2368
         30208,         // y[a8]=   3776
         29184,         // y[a9]=   3648
         32256,         // y[aa]=   4032
         31232,         // y[ab]=   3904
         26112,         // y[ac]=   3264
         25088,         // y[ad]=   3136
         28160,         // y[ae]=   3520
         27136,         // y[af]=   3392
         11008,         // y[b0]=   1376
         10496,         // y[b1]=   1312
         12032,         // y[b2]=   1504
         11520,         // y[b3]=   1440
          8960,         // y[b4]=   1120
          8448,         // y[b5]=   1056
          9984,         // y[b6]=   1248
          9472,         // y[b7]=   1184
         15104,         // y[b8]=   1888
         14592,         // y[b9]=   1824
         16128,         // y[ba]=   2016
         15616,         // y[bb]=   1952
         13056,         // y[bc]=   1632
         12544,         // y[bd]=   1568
         14080,         // y[be]=   1760
         13568,         // y[bf]=   1696
           344,         // y[c0]=     43
           328,         // y[c1]=     41
           376,         // y[c2]=     47
           360,         // y[c3]=     45
           280,         // y[c4]=     35
           264,         // y[c5]=     33
           312,         // y[c6]=     39
           296,         // y[c7]=     37
           472,         // y[c8]=     59
           456,         // y[c9]=     57
           504,         // y[ca]=     63
           488,         // y[cb]=     61
           408,         // y[cc]=     51
           392,         // y[cd]=     49
           440,         // y[ce]=     55
           424,         // y[cf]=     53
            88,         // y[d0]=     11
            72,         // y[d1]=      9
           120,         // y[d2]=     15
           104,         // y[d3]=     13
            24,         // y[d4]=      3
             8,         // y[d5]=      1
            56,         // y[d6]=      7
            40,         // y[d7]=      5
           216,         // y[d8]=     27
           200,         // y[d9]=     25
           248,         // y[da]=     31
           232,         // y[db]=     29
           152,         // y[dc]=     19
           136,         // y[dd]=     17
           184,         // y[de]=     23
           168,         // y[df]=     21
          1376,         // y[e0]=    172
          1312,         // y[e1]=    164
          1504,         // y[e2]=    188
          1440,         // y[e3]=    180
          1120,         // y[e4]=    140
          1056,         // y[e5]=    132
          1248,         // y[e6]=    156
          1184,         // y[e7]=    148
          1888,         // y[e8]=    236
          1824,         // y[e9]=    228
          2016,         // y[ea]=    252
          1952,         // y[eb]=    244
          1632,         // y[ec]=    204
          1568,         // y[ed]=    196
          1760,         // y[ee]=    220
          1696,         // y[ef]=    212
           688,         // y[f0]=     86
           656,         // y[f1]=     82
           752,         // y[f2]=     94
           720,         // y[f3]=     90
           560,         // y[f4]=     70
           528,         // y[f5]=     66
           624,         // y[f6]=     78
           592,         // y[f7]=     74
           944,         // y[f8]=    118
           912,         // y[f9]=    114
          1008,         // y[fa]=    126
           976,         // y[fb]=    122
           816,         // y[fc]=    102
           784,         // y[fd]=     98
           880,         // y[fe]=    110
           848          // y[ff]=    106
    };
        
//--------------------------------------------------------------------------;
//
//  Name:
//      UlawToPcmTable
//
//
//  Description:
//      this array maps u-law characters to 16-bit PCM
//      
//  Arguments:
//      the index into the array is a u-law character
//
//  Return:
//      an element of the array is a 16-bit PCM value
//
//  Notes:
//
//
//  History:
//      07/28/93    Created.
//
//
//--------------------------------------------------------------------------;
const SHORT UlawToPcmTable[256] =
    {
        -32124,         // y[00]=  -8031
        -31100,         // y[01]=  -7775
        -30076,         // y[02]=  -7519
        -29052,         // y[03]=  -7263
        -28028,         // y[04]=  -7007
        -27004,         // y[05]=  -6751
        -25980,         // y[06]=  -6495
        -24956,         // y[07]=  -6239
        -23932,         // y[08]=  -5983
        -22908,         // y[09]=  -5727
        -21884,         // y[0a]=  -5471
        -20860,         // y[0b]=  -5215
        -19836,         // y[0c]=  -4959
        -18812,         // y[0d]=  -4703
        -17788,         // y[0e]=  -4447
        -16764,         // y[0f]=  -4191
        -15996,         // y[10]=  -3999
        -15484,         // y[11]=  -3871
        -14972,         // y[12]=  -3743
        -14460,         // y[13]=  -3615
        -13948,         // y[14]=  -3487
        -13436,         // y[15]=  -3359
        -12924,         // y[16]=  -3231
        -12412,         // y[17]=  -3103
        -11900,         // y[18]=  -2975
        -11388,         // y[19]=  -2847
        -10876,         // y[1a]=  -2719
        -10364,         // y[1b]=  -2591
         -9852,         // y[1c]=  -2463
         -9340,         // y[1d]=  -2335
         -8828,         // y[1e]=  -2207
         -8316,         // y[1f]=  -2079
         -7932,         // y[20]=  -1983
         -7676,         // y[21]=  -1919
         -7420,         // y[22]=  -1855
         -7164,         // y[23]=  -1791
         -6908,         // y[24]=  -1727
         -6652,         // y[25]=  -1663
         -6396,         // y[26]=  -1599
         -6140,         // y[27]=  -1535
         -5884,         // y[28]=  -1471
         -5628,         // y[29]=  -1407
         -5372,         // y[2a]=  -1343
         -5116,         // y[2b]=  -1279
         -4860,         // y[2c]=  -1215
         -4604,         // y[2d]=  -1151
         -4348,         // y[2e]=  -1087
         -4092,         // y[2f]=  -1023
         -3900,         // y[30]=   -975
         -3772,         // y[31]=   -943
         -3644,         // y[32]=   -911
         -3516,         // y[33]=   -879
         -3388,         // y[34]=   -847
         -3260,         // y[35]=   -815
         -3132,         // y[36]=   -783
         -3004,         // y[37]=   -751
         -2876,         // y[38]=   -719
         -2748,         // y[39]=   -687
         -2620,         // y[3a]=   -655
         -2492,         // y[3b]=   -623
         -2364,         // y[3c]=   -591
         -2236,         // y[3d]=   -559
         -2108,         // y[3e]=   -527
         -1980,         // y[3f]=   -495
         -1884,         // y[40]=   -471
         -1820,         // y[41]=   -455
         -1756,         // y[42]=   -439
         -1692,         // y[43]=   -423
         -1628,         // y[44]=   -407
         -1564,         // y[45]=   -391
         -1500,         // y[46]=   -375
         -1436,         // y[47]=   -359
         -1372,         // y[48]=   -343
         -1308,         // y[49]=   -327
         -1244,         // y[4a]=   -311
         -1180,         // y[4b]=   -295
         -1116,         // y[4c]=   -279
         -1052,         // y[4d]=   -263
          -988,         // y[4e]=   -247
          -924,         // y[4f]=   -231
          -876,         // y[50]=   -219
          -844,         // y[51]=   -211
          -812,         // y[52]=   -203
          -780,         // y[53]=   -195
          -748,         // y[54]=   -187
          -716,         // y[55]=   -179
          -684,         // y[56]=   -171
          -652,         // y[57]=   -163
          -620,         // y[58]=   -155
          -588,         // y[59]=   -147
          -556,         // y[5a]=   -139
          -524,         // y[5b]=   -131
          -492,         // y[5c]=   -123
          -460,         // y[5d]=   -115
          -428,         // y[5e]=   -107
          -396,         // y[5f]=    -99
          -372,         // y[60]=    -93
          -356,         // y[61]=    -89
          -340,         // y[62]=    -85
          -324,         // y[63]=    -81
          -308,         // y[64]=    -77
          -292,         // y[65]=    -73
          -276,         // y[66]=    -69
          -260,         // y[67]=    -65
          -244,         // y[68]=    -61
          -228,         // y[69]=    -57
          -212,         // y[6a]=    -53
          -196,         // y[6b]=    -49
          -180,         // y[6c]=    -45
          -164,         // y[6d]=    -41
          -148,         // y[6e]=    -37
          -132,         // y[6f]=    -33
          -120,         // y[70]=    -30
          -112,         // y[71]=    -28
          -104,         // y[72]=    -26
           -96,         // y[73]=    -24
           -88,         // y[74]=    -22
           -80,         // y[75]=    -20
           -72,         // y[76]=    -18
           -64,         // y[77]=    -16
           -56,         // y[78]=    -14
           -48,         // y[79]=    -12
           -40,         // y[7a]=    -10
           -32,         // y[7b]=     -8
           -24,         // y[7c]=     -6
           -16,         // y[7d]=     -4
            -8,         // y[7e]=     -2
             0,         // y[7f]=      0
         32124,         // y[80]=   8031
         31100,         // y[81]=   7775
         30076,         // y[82]=   7519
         29052,         // y[83]=   7263
         28028,         // y[84]=   7007
         27004,         // y[85]=   6751
         25980,         // y[86]=   6495
         24956,         // y[87]=   6239
         23932,         // y[88]=   5983
         22908,         // y[89]=   5727
         21884,         // y[8a]=   5471
         20860,         // y[8b]=   5215
         19836,         // y[8c]=   4959
         18812,         // y[8d]=   4703
         17788,         // y[8e]=   4447
         16764,         // y[8f]=   4191
         15996,         // y[90]=   3999
         15484,         // y[91]=   3871
         14972,         // y[92]=   3743
         14460,         // y[93]=   3615
         13948,         // y[94]=   3487
         13436,         // y[95]=   3359
         12924,         // y[96]=   3231
         12412,         // y[97]=   3103
         11900,         // y[98]=   2975
         11388,         // y[99]=   2847
         10876,         // y[9a]=   2719
         10364,         // y[9b]=   2591
          9852,         // y[9c]=   2463
          9340,         // y[9d]=   2335
          8828,         // y[9e]=   2207
          8316,         // y[9f]=   2079
          7932,         // y[a0]=   1983
          7676,         // y[a1]=   1919
          7420,         // y[a2]=   1855
          7164,         // y[a3]=   1791
          6908,         // y[a4]=   1727
          6652,         // y[a5]=   1663
          6396,         // y[a6]=   1599
          6140,         // y[a7]=   1535
          5884,         // y[a8]=   1471
          5628,         // y[a9]=   1407
          5372,         // y[aa]=   1343
          5116,         // y[ab]=   1279
          4860,         // y[ac]=   1215
          4604,         // y[ad]=   1151
          4348,         // y[ae]=   1087
          4092,         // y[af]=   1023
          3900,         // y[b0]=    975
          3772,         // y[b1]=    943
          3644,         // y[b2]=    911
          3516,         // y[b3]=    879
          3388,         // y[b4]=    847
          3260,         // y[b5]=    815
          3132,         // y[b6]=    783
          3004,         // y[b7]=    751
          2876,         // y[b8]=    719
          2748,         // y[b9]=    687
          2620,         // y[ba]=    655
          2492,         // y[bb]=    623
          2364,         // y[bc]=    591
          2236,         // y[bd]=    559
          2108,         // y[be]=    527
          1980,         // y[bf]=    495
          1884,         // y[c0]=    471
          1820,         // y[c1]=    455
          1756,         // y[c2]=    439
          1692,         // y[c3]=    423
          1628,         // y[c4]=    407
          1564,         // y[c5]=    391
          1500,         // y[c6]=    375
          1436,         // y[c7]=    359
          1372,         // y[c8]=    343
          1308,         // y[c9]=    327
          1244,         // y[ca]=    311
          1180,         // y[cb]=    295
          1116,         // y[cc]=    279
          1052,         // y[cd]=    263
           988,         // y[ce]=    247
           924,         // y[cf]=    231
           876,         // y[d0]=    219
           844,         // y[d1]=    211
           812,         // y[d2]=    203
           780,         // y[d3]=    195
           748,         // y[d4]=    187
           716,         // y[d5]=    179
           684,         // y[d6]=    171
           652,         // y[d7]=    163
           620,         // y[d8]=    155
           588,         // y[d9]=    147
           556,         // y[da]=    139
           524,         // y[db]=    131
           492,         // y[dc]=    123
           460,         // y[dd]=    115
           428,         // y[de]=    107
           396,         // y[df]=     99
           372,         // y[e0]=     93
           356,         // y[e1]=     89
           340,         // y[e2]=     85
           324,         // y[e3]=     81
           308,         // y[e4]=     77
           292,         // y[e5]=     73
           276,         // y[e6]=     69
           260,         // y[e7]=     65
           244,         // y[e8]=     61
           228,         // y[e9]=     57
           212,         // y[ea]=     53
           196,         // y[eb]=     49
           180,         // y[ec]=     45
           164,         // y[ed]=     41
           148,         // y[ee]=     37
           132,         // y[ef]=     33
           120,         // y[f0]=     30
           112,         // y[f1]=     28
           104,         // y[f2]=     26
            96,         // y[f3]=     24
            88,         // y[f4]=     22
            80,         // y[f5]=     20
            72,         // y[f6]=     18
            64,         // y[f7]=     16
            56,         // y[f8]=     14
            48,         // y[f9]=     12
            40,         // y[fa]=     10
            32,         // y[fb]=      8
            24,         // y[fc]=      6
            16,         // y[fd]=      4
             8,         // y[fe]=      2
             0          // y[ff]=      0
    };

inline SHORT ALawToPcm(IN BYTE Alaw)
{
    return AlawToPcmTable[Alaw];
}

inline SHORT MuLawToPcm(IN BYTE MuLaw)
{
    return UlawToPcmTable[MuLaw];
}


#endif // __ENCG711_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\audpropi\res.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#define PROPPAGE_HEIGHT                 100
#define PROPPAGE_WIDTH                  240
#define IDC_MIXER_FILTER_ENABLE         3000
#define IDC_MIXER_FILTER_TREBLE_LEVEL   3001
#define IDC_MIXER_FILTER_BASS_LEVEL     3002
#define IDC_MIXER_PIN_MUTE              3003
#define IDC_MIXER_FILTER_LOUDNESS       3004
#define IDC_MIXER_FILTER_MONO           3005
#define IDC_MIXER_PIN_TREBLE_LEVEL      3006
#define IDC_MIXER_PIN_BASS_LEVEL        3007
#define IDC_MIXER_PIN_LOUDNESS          3008
#define IDC_MIXER_PIN_MONO              3009
#define IDC_MIXER_PIN_ENABLE            3012
#define IDC_MIXER_PIN_BALANCE           3013
#define IDC_MIXER_PIN_VOLUME            3014
#define IDC_MIXER_FILTER_BALANCE        3015
#define IDC_MIXER_FILTER_VOLUME         3016
#define IDC_MIXER_PIN_SELECT            3017
#define IDD_AUDIOINPUTMIXER             3050
#define IDS_AIM_PAGE_TITLE              3051
#define IDS_AIM_WINDOW_TITLE            3052
//#define IDC_STATIC                    -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\util\clock\code\clock.cpp ===
// Copyright (c) 1994 - 1996  Microsoft Corporation.  All Rights Reserved.
// Implements IReferenceClock Interface, Anthony Phillips, March 1995

#include <streams.h>
#include <mmsystem.h>
#include <limits.h>
#include <clock.h>

// NOTE All the advise links you set up through the IReferenceClock interface
// use the same event queue. The distance between events signalled to clients is
// obviously variable so we use a series of oneshot events. You don't have to
// call Unadvise() for one shot links set up through the AdviseTime interface
// method BUT you must call Unadvise for AdvisePeriodic. A single critical
// section (m_CSClock) protects the state of the clock. Notifications occur
// through Win32 synchonisation handles.  For one shot events this is an event
// handle, for periodic timers it is a semaphore. An advise link has its
// details stored in a CAdviseHolder object. We keep a list of these objects
// protected by the class critical section. Each advise link created has a
// CAdviseHolder object to store it's details. To improve efficiency and also
// reduce the number of these C++ objects being created and destroyed we keep
// a cache of advise holder objects that can be reinitialised on request

#ifdef FILTER_DLL

// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance
// function when it is asked to create a CLSID_SystemClock object

CFactoryTemplate g_Templates[1] = {
    {L"", &CLSID_SystemClock, CSystemClock::CreateInstance}
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

// This goes in the factory template table to create new instances

CUnknown *CSystemClock::CreateInstance(LPUNKNOWN pUnk,HRESULT *phr)
{
    return new CSystemClock(NAME("System clock"),pUnk, phr);
}


// Override this to say what interfaces we support and where

STDMETHODIMP CSystemClock::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv)
{
    // Do we have this interface

    if (riid == IID_IReferenceClock) {
        return GetInterface((IReferenceClock *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// Constructor starts the worker thread running. Each clock object has it's
// own thread so there is some advantage in the filter graph having a single
// clock that it uses amongst many graphs in a single process. Or possibly
// having a single clock available in the running object table that can be
// used by all filter graphs on a machine, this would require marshalling

CSystemClock::CSystemClock(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *phr) :
    CUnknown( pName, pUnk ),
    m_bAbort(FALSE),
    m_dwNextCookie(0),
    m_AdviseCount(0),
    m_Cache(NAME("Advise list cache"),ADVISE_CACHE),
    m_ListAdvise(NAME("Clock advise list"))
{
    timeBeginPeriod(RESOLUTION);

    // Create a thread to look after the window

    m_hThread = CreateThread(NULL,              // Security attributes
                             (DWORD) 0,         // Initial stack size
                             TimerLoop,         // Thread start address
                             (LPVOID) this,     // Thread parameter
                             (DWORD) 0,         // Creation flags
                             &m_ThreadID);      // Thread identifier

    ASSERT(m_hThread);
    if (m_hThread == NULL) {
        *phr = E_FAIL;
        return;
    }

    // Initialise our system times
    m_CurrentTime = timeGetTime();
    m_idGetTime = MSR_REGISTER("Sys Ref Clock::GetTime");
}


// We are called when the clock object is to be deleted which is typically
// when all the IReferenceClock interfaces have been released. The user must
// have called Unadvise() for all their links before calling release.

CSystemClock::~CSystemClock()
{
    // All advise links should have gone

    ASSERT(m_AdviseCount == 0);

    // Make sure the thread sees the abort flag

    m_bAbort = TRUE;
    m_Event.Set();

    // Wait for the thread to complete
    if (m_hThread) {
        WaitForSingleObject(m_hThread,INFINITE);
        CloseHandle(m_hThread);
	m_hThread=0;
    }
    timeEndPeriod(RESOLUTION);
}


// This function schedules event notifications from a separate thread

DWORD __stdcall CSystemClock::TimerLoop(LPVOID lpvThreadParm)
{
    // The clock object is passed in as the thread data

    CSystemClock *pClock = (CSystemClock *) lpvThreadParm;

    DWORD dwWait = INFINITE;
    while (TRUE) {

        // Wait for either one of the advise interface methods to signal
        // something has changed or for the next timeout to be signalled

        WaitForSingleObject(pClock->m_Event,dwWait);

        if (pClock->m_bAbort == TRUE) {
            ExitThread(TRUE);
            return TRUE;
        }
        dwWait = pClock->TimerEvent(TRUE);
    }
}


// This function is called when a timer event occurs. We first get the time
// from the system (using timeGetTime) and update our idea of current time,
// (this must be sensitive to clock wrapping). We then scan the list of clients
// with notification links and signal them if their timer request is due

DWORD CSystemClock::TimerEvent(BOOL bNotify)
{
    // Lock the object
    CAutoLock cObjectLock(this);

    // If the clock has wrapped then the current time will be less than
    // the last time we were notified so add on the extra milliseconds

    DWORD dwTime = timeGetTime();
    if (dwTime < m_CurrentTime.LowPart) {
        m_CurrentTime.HighPart += 1;
    }
    m_CurrentTime.LowPart = dwTime;

    // Notify any clients who are now ripe

    if (bNotify) {
        return Notify();
    }
    return INFINITE;
}


// This is called when a timer completes; the object's critical section is
// locked by the calling function which in this case is TimerLoop. We scan
// the list of notification clients and see if their time is less than or
// equal to the current time. If it is then we dispatch them a timer event
// We return the next nearest event time or INFINITE if there is not one

DWORD CSystemClock::Notify()
{
    // Scan through the list looking for prospective notifications

    POSITION pPos;              // Next position in advise list
    POSITION pCurrent;          // Current position in advise list
    LONGLONG NextNotify;        // Closest next notification time
    LONGLONG CurrentNotify;     // Current next event time

    // While we look through the list for potential notifications we also
    // maintain dwNextNotify that gives us the next notification time which
    // we use afterwards to set the WaitForSingleObject timeout field

    pCurrent = pPos = m_ListAdvise.GetHeadPosition();
    NextNotify = CurrentNotify = MAX_TIME;

    while (pPos) {

        CAdviseHolder *pAdviseHolder = m_ListAdvise.GetNext(pPos);
        ASSERT(pAdviseHolder != NULL);

        // If due for notification then dispatch the event and update the next
        // event time accordingly. Otherwise we just look at the notification
        // time in the advise holder and see it is any closer than our best

        if (m_CurrentTime.QuadPart >= pAdviseHolder->m_RefTime) {
            CurrentNotify = Dispatch(pAdviseHolder,pCurrent);
        } else {
            CurrentNotify = pAdviseHolder->m_RefTime;
        }

        // If the next notification time from the current node is nearer than
        // our best so far then we make this time the next event time due

        NextNotify = min(NextNotify,CurrentNotify);
        pCurrent = pPos;
    }

    // Do we need any more notifications

    if (NextNotify == MAX_TIME) {
        return INFINITE;
    }

    // If we are getting behind then the next notification time may already
    // have gone in which case set the wait time to zero. NOTE we cannot
    // simply recurse dispatching more events as we hold the object's lock
    // thereby stopping any one else from getting an advise link change

    NextNotify = max(NextNotify,m_CurrentTime.QuadPart);
    ASSERT(NextNotify - m_CurrentTime.QuadPart < (LONGLONG) INFINITE);
    return (DWORD)(NextNotify - m_CurrentTime.QuadPart);
}


// This function sets the client's event, if the notification is a one shot
// timer then the holder is removed from the pending list. If the timer is
// periodic then the next event notification time is calculated. The state
// critical section is locked by the calling Notify function

LONGLONG CSystemClock::Dispatch(
    CAdviseHolder *pAdviseHolder,
    POSITION pCurrent)
{
    // If this is a one shot then set the event and delete the entry from the
    // pending list and therefore make no change to the next event time

    ASSERT(pAdviseHolder->m_hNotify != INVALID_HANDLE_VALUE);
    if (pAdviseHolder->m_bPeriodic == FALSE) {
        EXECUTE_ASSERT(SetEvent(pAdviseHolder->m_hNotify));
        DeleteEntry(pAdviseHolder,pCurrent);
        return MAX_TIME;
    }

    // This is a periodic timer so increment the semaphore count and
    // then return the time when the filter should next be notified

    ASSERT(pAdviseHolder->m_bPeriodic == TRUE);
    EXECUTE_ASSERT(ReleaseSemaphore(pAdviseHolder->m_hNotify,1,NULL));
    pAdviseHolder->m_RefTime += pAdviseHolder->m_Period;
    return pAdviseHolder->m_RefTime;
}


// This function looks after deleting objects from the pending list

void CSystemClock::DeleteEntry(CAdviseHolder *pAdviseHolder,
                               POSITION &pCurrent)
{
    EXECUTE_ASSERT(m_ListAdvise.Remove(pCurrent) == pAdviseHolder);

    if (m_Cache.AddToCache(pAdviseHolder) == NULL) {
        delete pAdviseHolder;
    }
    m_AdviseCount--;
}


// This function creates and initialises a new advise holder object

CSystemClock::CAdviseHolder *CSystemClock::CreateEntry()
{
    // Try and get an advise holder from the cache

    CAdviseHolder *pAdviseHolder = (CAdviseHolder *) m_Cache.RemoveFromCache();

    // If no cache entries available then create a new object

    if (pAdviseHolder == NULL) {
        pAdviseHolder = new CAdviseHolder(NAME("Clock advise holder"));
        if (pAdviseHolder == NULL) {
            return NULL;
        }
    }

    // Initialise the fields in the advise holder object

    m_AdviseCount++;
    pAdviseHolder->m_dwAdviseCookie = FALSE;
    pAdviseHolder->m_RefTime = MAX_TIME;
    pAdviseHolder->m_bPeriodic = FALSE;
    pAdviseHolder->m_Period = MAX_TIME;
    pAdviseHolder->m_hNotify = INVALID_HANDLE_VALUE;

    return pAdviseHolder;
}


// Armed with the details of the advise notification create a pending entry
// and add it to the list, and then ensure the event thread is signalled
// NOTE this method does not check that the event notification or the period
// are less than one clock wrap away, this is because that situation is
// sufficiently unlikely that the checks would be virtually redundant

HRESULT CSystemClock::CreateAdviseLink(
    LONGLONG RefTime,            // Advise me at this time
    LONGLONG RefPeriod,          // Period between notifications
    HANDLE hNotify,              // Notification mechanism
    DWORD *pdwAdviseCookie,      // where your cookie goes
    BOOL bPeriodic)              // Is this a one shot timer
{
    // Create a new advise holder object for the client

    CAdviseHolder *pAdviseHolder = CreateEntry();
    if (pAdviseHolder == NULL) {
        return E_OUTOFMEMORY;
    }

    // Lock the object
    {
        CAutoLock cObjectLock(this);

        // Initialise the cookie with the next available number

        pAdviseHolder->m_dwAdviseCookie = ++m_dwNextCookie;
        *pdwAdviseCookie = pAdviseHolder->m_dwAdviseCookie;

        // Fill in the rest of the guff

        pAdviseHolder->m_hNotify = hNotify;
        pAdviseHolder->m_bPeriodic = bPeriodic;
        pAdviseHolder->m_RefTime = RefTime;
        pAdviseHolder->m_Period = RefPeriod;

        // Add it to the pending list and start the clock if necessary

        POSITION pPos = m_ListAdvise.AddTail(pAdviseHolder);
    }

    // Ensure we get scheduled correctly
    m_Event.Set();
    return NOERROR;
}


// Ask for an async notification that a time has elapsed

STDMETHODIMP CSystemClock::AdviseTime(
    REFERENCE_TIME baseTime,         // base reference time
    REFERENCE_TIME streamTime,       // stream offset time
    HEVENT hEvent,                  // advise via this event
    DWORD *pdwAdviseCookie)         // where your cookie goes
{
    ASSERT(pdwAdviseCookie);
    *pdwAdviseCookie = 0;

    // Convert the reference times to milliseconds

    LONGLONG lRefTime = ConvertToMillisecs(CRefTime(baseTime) + CRefTime(streamTime));

    // Quick check that the time is valid

    if (lRefTime <= 0) {
        return E_INVALIDARG;
    }

    // Create an advise link with our clock

    return CreateAdviseLink(lRefTime,           // Notification time
                            (DWORD) 0,          // No periodic time
                            (HANDLE) hEvent,    // Notification mechanism
                            pdwAdviseCookie,    // Their advise cookie
                            FALSE);             // NOT periodic
}


// Ask for an asynchronous periodic notification that a time has elapsed

STDMETHODIMP CSystemClock::AdvisePeriodic(
    REFERENCE_TIME StartTime,         // starting at this time
    REFERENCE_TIME PeriodTime,        // time between notifications
    HSEMAPHORE hSemaphore,           // advise via a semaphore
    DWORD *pdwAdviseCookie)          // where your cookie goes
{
    ASSERT(pdwAdviseCookie);
    *pdwAdviseCookie = 0;

    // Convert the reference times to milliseconds

    LONGLONG lStartTime = ConvertToMillisecs(StartTime);
    LONGLONG lPeriodTime = ConvertToMillisecs(PeriodTime);

    // Quick check that the times are valid

    if (lStartTime == 0 || lPeriodTime == 0) {
        return E_INVALIDARG;
    }

    // Create an advise link with our clock

    return CreateAdviseLink(lStartTime,            // Notification start time
                            lPeriodTime,           // Period between timers
                            (HANDLE) hSemaphore,   // Notification mechanism
                            pdwAdviseCookie,       // Their advise cookie
                            TRUE);                 // It is periodic
}


// Cancel a notification link

STDMETHODIMP CSystemClock::Unadvise(DWORD dwAdviseCookie)
{
    // Lock the object
    {
        CAutoLock cObjectLock(this);

        POSITION pPos = m_ListAdvise.GetHeadPosition();
        POSITION pCurrent = pPos;
        BOOL bFound = FALSE;

        while (pPos) {

            CAdviseHolder *pAdviseHolder = m_ListAdvise.GetNext(pPos);
            ASSERT(pAdviseHolder != NULL);

            // Do the advise cookies match

            if (pAdviseHolder->m_dwAdviseCookie == dwAdviseCookie) {
                DeleteEntry(pAdviseHolder,pCurrent);
                bFound = TRUE;
            }
            pCurrent = pPos;
        }

        // If nothing was changed then no event need be signalled

        if (bFound == FALSE) {
            return S_FALSE;
        }
    }

    // Ensure the scheduling is updated
    m_Event.Set();
    return S_OK;
}


// Give me the reference time as used in the operating system for
// this reference time which the streams architecture uses

STDMETHODIMP CSystemClock::ConvertRealTime(
    TIME realTime,
    REFERENCE_TIME *pRefTime)
{
    return E_NOTIMPL;
}


// This returns the current reference time which for this clock is the
// number of milliseconds since Windows was started. Since this is a
// wall clock time we don't bother subtracting any base time from it

STDMETHODIMP CSystemClock::GetTime(REFERENCE_TIME *pTime)
{
    // This causes a scheduling update
    MSR_START(m_idGetTime);

    /* This causes a scheduling update */
    TimerEvent(FALSE);

    // The current time is now MILLISECONDs accurate

    CAutoLock cObjectLock(this);
    pTime->RefTime.QuadPart = m_CurrentTime.QuadPart;
    pTime->RefTime.QuadPart *= (UNITS / MILLISECONDS);
    MSR_STOP(m_idGetTime);
    return NOERROR;
}


// This function converts a reference time to milliseconds

LONGLONG inline CSystemClock::ConvertToMillisecs(REFERENCE_TIME RT) const
{
    // This converts an arbitrary value representing a reference time
    // into a MILLISECONDS value for use in subsequent system calls

    return (RT / (UNITS / MILLISECONDS));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\filter\encg711.h ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    encg711.h

Abstract:

    This module contains the G711 encoding functions.

Author:

    Mu Han (muhan) May-15-1999

--*/
#ifndef __ENCG711_H__
#define __ENCG711_H__

inline BYTE PcmToALaw(IN SHORT pcm)
{
    BYTE alaw;
    USHORT wSample;
    
    // We'll init our A-law value per the sign of the PCM sample.  A-law
    // characters have the MSB=1 for positive PCM data.  Also, we'll
    // convert our signed 16-bit PCM value to it's absolute value and
    // then work on that to get the rest of the A-law character bits.
    if (pcm < 0)
    {
        wSample = (USHORT)(-pcm);
        alaw = 0x80;
    }
    else
    {
        wSample = (USHORT)pcm;
        alaw = 0;
    }
                        
    // Now we test the PCM sample amplitude and create the A-law character.
    // Study the CCITT A-law for more detail.
    
    if (wSample >= 2048)
    // 2048 <= wSample < 32768
    {
        if (wSample >= 8192)
        // 8192 <= wSample < 32768
        {
            if (wSample >= 16384)
            // 16384 <= wSample < 32768
            {
                alaw |= 0x70 | ((wSample >> 10) & 0x0F);
            }
            else
            // 8192 <= wSample < 16384
            {
                alaw |= 0x60 | ((wSample >> 9) & 0x0F);
            }
        }
        else
        // 2048 <= wSample < 8192
        {
            if (wSample >= 4096)
            // 4096 <= wSample < 8192
            {
                alaw |= 0x50 | ((wSample >> 8) & 0x0F);
            }
            else
            // 2048 <= wSample < 4096
            {
                alaw |= 0x40 | ((wSample >> 7) & 0x0F);
            }
        }
    }
    else
    // 0 <= wSample < 2048
    {
        if (wSample >= 512)
        // 512 <= wSample < 2048
        {
            if (wSample >= 1024)
            // 1024 <= wSample < 2048
            {
                alaw |= 0x30 | ((wSample >> 6) & 0x0F);
            }
            else
            // 512 <= wSample < 1024
            {
                alaw |= 0x20 | ((wSample >> 5) & 0x0F);
            }
        }
        else
        // 0 <= wSample < 512
        {
                alaw |= 0x00 | ((wSample >> 4) & 0x1F);
        }
    }

    return (BYTE)(alaw ^ 0x55);      // Invert even bits
}


#ifdef DBG

// This function is copied from the ACM code. Used for debug only.
inline BYTE PcmToMuLaw2(IN SHORT wSample)
{
    BYTE ulaw;

    // We'll init our u-law value per the sign of the PCM sample.  u-law
    // characters have the MSB=1 for positive PCM data.  Also, we'll
    // convert our signed 16-bit PCM value to it's absolute value and
    // then work on that to get the rest of the u-law character bits.
    if (wSample < 0)
        {
        ulaw = 0x00;
        wSample = (SHORT)-wSample;
        if (wSample < 0) wSample = 0x7FFF;
        }
    else
        {
        ulaw = 0x80;
        }
        
    // For now, let's shift this 16-bit value
    //  so that it is within the range defined
    //  by CCITT u-law.
    wSample = (SHORT)(wSample >> 2);
                        
    // Now we test the PCM sample amplitude and create the u-law character.
    // Study the CCITT u-law for more details.
    if (wSample >= 8159)
        goto Gotulaw;
    if (wSample >= 4063)
        {
        ulaw |= 0x00 + 15-((wSample-4063)/256);
        goto Gotulaw;
        }
    if (wSample >= 2015)
        {
        ulaw |= 0x10 + 15-((wSample-2015)/128);
        goto Gotulaw;
        }
    if (wSample >= 991)
        {
        ulaw |= 0x20 + 15-((wSample-991)/64);
        goto Gotulaw;
        }
    if (wSample >= 479)
        {
        ulaw |= 0x30 + 15-((wSample-479)/32);
        goto Gotulaw;
        }
    if (wSample >= 223)
        {
        ulaw |= 0x40 + 15-((wSample-223)/16);
        goto Gotulaw;
        }
    if (wSample >= 95)
        {
        ulaw |= 0x50 + 15-((wSample-95)/8);
        goto Gotulaw;
        }
    if (wSample >= 31)
        {
        ulaw |= 0x60 + 15-((wSample-31)/4);
        goto Gotulaw;
        }
    ulaw |= 0x70 + 15-((wSample)/2);
    
Gotulaw:
    return ulaw;
}
#endif //DBG

inline BYTE PcmToMuLaw(IN SHORT pcm)
{
    BYTE ulaw;
    USHORT wSample;

    // We'll init our u-law value per the sign of the PCM sample.  u-law
    // characters have the MSB=1 for positive PCM data.  Also, we'll
    // convert our signed 16-bit PCM value to it's absolute value and
    // then work on that to get the rest of the u-law character bits.
    if (pcm < 0)
    {
        wSample = (USHORT)(-pcm);
        ulaw = 0x0;
    }
    else
    {
        wSample = (USHORT)pcm;
        ulaw = 0x80;
    }

    // For now, let's shift this 16-bit value
    //  so that it is within the range defined
    //  by CCITT u-law.
    wSample = (USHORT)(wSample >> 2);
                        
    // Now we test the PCM sample amplitude and create the u-law character.
    // Study the CCITT u-law for more details.
    if (wSample >= 479)
    // 479 <= wSample
    {
        if (wSample >= 2015)
        // 2015 <= wSample
        {
            if (wSample >= 4063)
            // 4063 <= wSample
            {
                if (wSample < 8159)
                // 4063 <= wSample < 8159
                {
                    ulaw |= 0x00 + 15-((wSample-4063) >> 8);
                }
            }
            else
            // 2015 <= wSample < 4063
            {
                ulaw |= 0x10 + 15-((wSample-2015) >> 7);
            }
        }
        else 
        {
            if (wSample >= 991)
            // 991 <= wSample < 2015
            {
                ulaw |= 0x20 + 15-((wSample-991) >> 6);
            }
            else
            // 479 <= wSample < 991
            {
                ulaw |= 0x30 + 15-((wSample-479) >> 5);
            }
        }
    }
    else
    // 0 <= wSample < 479
    {
        if (wSample >= 95)
        // 95 <= wSample < 479
        {
            if (wSample >= 223)
            // 223 <= wSample < 479
            {
                ulaw |= 0x40 + 15-((wSample-223) >> 4);
            }
            else
            // 95 <= wSample < 223
            {
                ulaw |= 0x50 + 15-((wSample-95) >> 3);
            }
        }
        else
        // 0 <= wSample < 95
        {
            if (wSample >= 31)
            // 31 <= wSample < 95
            {
                ulaw |= 0x60 + 15-((wSample-31) >> 2);
            }
            else
            // 0 <= wSample < 31
            {
                ulaw |= 0x70 + 15-((wSample) >> 1);
            }
        }
    }

    // make sure we didn't break the standard.
    ASSERT(ulaw == PcmToMuLaw2(pcm));

    return ulaw;
}

#if 0 // a different method. Don't know which is faster, needs to test.

#define CLIP 32635

unsigned char
linear2ulaw(sample)
int sample; {
  static int exp_lut[256] = {0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,
                             4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
                             5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
                             5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
                             6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
                             6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
                             6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
                             6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
                             7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7};
  int sign, exponent, mantissa;
  unsigned char ulawbyte;

  /* Get the sample into sign-magnitude. */
  sign = (sample >> 8) & 0x80;          /* set aside the sign */
  if (sign != 0) sample = -sample;              /* get magnitude */
  if (sample > CLIP) sample = CLIP;             /* clip the magnitude */

  /* Convert from 16 bit linear to ulaw. */
  exponent = exp_lut[(sample >> 7) & 0xFF];
  mantissa = (sample >> (exponent + 3)) & 0x0F;
  ulawbyte = ~(sign | (exponent << 4) | mantissa);

  return(ulawbyte);
}

int
ulaw2linear(ulawbyte)
unsigned char ulawbyte;
{
  static int exp_lut[8] = {0,132,396,924,1980,4092,8316,16764};
  int sign, exponent, mantissa, sample;

  ulawbyte = ~ulawbyte;
  sign = (ulawbyte & 0x80);
  exponent = (ulawbyte >> 4) & 0x07;
  mantissa = ulawbyte & 0x0F;
  sample = exp_lut[exponent] + (mantissa << (exponent + 3));
  if (sign != 0) sample = -sample;

  return(sample);
}
#endif // #if 0


#endif // __ENCG711_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\filter\dscfiltr.cpp ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    dscfiltr.cpp

Abstract:

    This file is the main file for DSound Audio capture filter (based on TAPI's)

--*/


#include "stdafx.h"
#include <dsound.h>
#include "dsc.h"

// Setup data
const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_NULL,            // Major type
    &MEDIASUBTYPE_NULL          // Minor type
};

const AMOVIESETUP_PIN sudPins =
{
    L"Output",                  // Pin string name
    FALSE,                      // Is it rendered
    TRUE,                       // Is it an output
    FALSE,                      // Allowed none
    FALSE,                      // Likewise many
    &CLSID_NULL,                // Connects to filter
    L"Output",                  // Connects to pin
    1,                          // Number of types
    &sudPinTypes                // Pin information
};

const AMOVIESETUP_FILTER sudAudCap =
{
    &CLSID_DSoundCaptureFilter,
    L"DirectSound Capture Filter",   // strName
    MERIT_DO_NOT_USE,           // Filter merit
    1,                          // Number pins
    &sudPins                    // Pin details
};

#ifdef FILTER_DLL

extern "C" BOOL DSoundInDllEntry(HINSTANCE hInstance, ULONG ulReason, LPVOID pv);
extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, ULONG ulReason, LPVOID pv);

BOOL DSoundInDllEntry(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
{
    BOOL f = DllEntryPoint(hInstance, ulReason, pv);

    // if loading this dll, we want to call the 2nd dll entry point
    // only if the first one succeeded. if unloading, always call
    // both. if the second one fails, undo the first one.  HAVE NOT
    // verified that failing DllEntryPoint for ATTACH does not cause
    // the loader to call in again w/ DETACH. but that seems silly
    if(f || ulReason == DLL_PROCESS_DETACH)
    {
        if (ulReason == DLL_PROCESS_ATTACH)
        {
            DisableThreadLibraryCalls(hInstance);
        }
        else if (ulReason == DLL_PROCESS_DETACH)
        {
            // We hit this ASSERT in NT setup
            // ASSERT(_Module.GetLockCount()==0 );
        }
    }

    return f;
}
//
// Register with Amovie's helper functions.
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
} 
#endif

/* This goes in the factory template table to create new instances */

CUnknown *CDSoundCaptureFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    ENTER_FUNCTION("CreateAudioCaptureInstance");

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, pUnk outer:%p"), __fxName, pUnk));

    CUnknown *pUnkFilter = new CDSoundCaptureFilter(pUnk, phr);
    if (pUnkFilter == NULL) 
    {
        *phr = E_OUTOFMEMORY;
        DbgLog((LOG_TRACE, TRACE_LEVEL_FAIL,TEXT("%s, out of memory creating the filter"), __fxName));
    }
    else if (FAILED(*phr))
    {
        DbgLog((LOG_TRACE, TRACE_LEVEL_FAIL,TEXT("%s, filter's construtor failed, hr:%d"), __fxName, *phr));
    }

    DbgLog((LOG_TRACE, TRACE_LEVEL_FAIL,TEXT("%s, returning:%p, hr:%x"), __fxName, pUnkFilter, *phr));

    return pUnkFilter;
} 

CDSoundCaptureFilter::CDSoundCaptureFilter(
    IN  LPUNKNOWN pUnk, 
    OUT HRESULT *phr
    ) : 
    CBaseFilter(
        NAME("CDSoundCaptureFilter"), 
        pUnk, 
        &m_Lock, 
        CLSID_DSoundCaptureFilter
        ),
    m_fAutomaticGainControl(DEFAULT_AGC_STATUS),
    m_fAcousticEchoCancellation(DEFAULT_AEC_STATUS),
    m_pOutputPin(NULL),
    m_dwNumPins(0),
    m_dwNumInputPins(0),
    m_ppInputPins(NULL),
    m_hThread(NULL),
    m_WaveID(0),
    m_pCaptureDevice(NULL),
    m_pIAudioDuplexController(NULL),
    m_DSoundGUID( GUID_NULL ),
    m_fDeviceConfigured( TRUE ) // previously init'd to FALSE until SetDeviceID call
/*++

Routine Description:

    The constructor for the tapi audio capture filter. 

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    phr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::CDSoundCaptureFilter");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    *phr = S_OK;

    return;
}

CDSoundCaptureFilter::~CDSoundCaptureFilter()
/*++

Routine Description:

    The desstructor for the tapi audio capture filter. 

Arguments:

    Nothing.

Return Value:

    Nothing.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::~CDSoundCaptureFilter");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    if (m_hThread)
    {
        // stop the worker thread if it has started.
        m_evFinish.Set();
        
        // wait for the worker thread to finish;
        DWORD dwRes = WaitForSingleObject(m_hThread, INFINITE);

        if (dwRes!= WAIT_OBJECT_0)
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, wait for thread to exit returned err =%d"), 
                __fxName, GetLastError()));
        }
    }

    delete m_pOutputPin;
    delete [] m_ppInputPins;
    delete m_pCaptureDevice;
    if (m_pIAudioDuplexController) m_pIAudioDuplexController->Release();

    if (m_hThread)
    {
        // close all the remaining handles.
        CloseHandle(m_hThread);
    }
}

STDMETHODIMP
CDSoundCaptureFilter::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    Overrides CBaseFilter::NonDelegatingQueryInterface().
    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. 

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == IID_IAMAudioDeviceConfig) {

        return GetInterface(static_cast<IAMAudioDeviceConfig*>(this), ppv);
    }
    else if (riid == IID_IAMAudioDeviceControl) {

        return GetInterface(static_cast<IAMAudioDeviceControl*>(this), ppv);
    }
    else if (riid == IID_IAMAudioInputMixer) {

        return GetInterface(static_cast<IAMAudioInputMixer*>(this), ppv);
    }
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
} 

STDMETHODIMP
CDSoundCaptureFilter::EnumPins(IEnumPins **ppEnum)
/*++

Routine Description:

    overrides CBaseFilter::EnumPins().
    The function will create the pins if they have not been created yet. This 
    filter has one output pin and several input pins. The number of input pins 
    depends on the number of audio inputs returned by the mixer API.

Arguments:

    ppEnum -
        A pointer to a pointer to IEnumPins interface.

Return Value:

    The number of pins.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::EnumPins");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    CAutoLock Lock(m_pLock);

    HRESULT hr;

    if (m_dwNumPins == 0)
    {
        // Create the output pin.
        hr = InitializeOutputPin();

        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, InitialzeOutputPin failed. hr=%x"), __fxName, hr));

            return hr;
        }

        m_dwNumPins = 1;


        // Create the inputpins.
        hr = InitializeInputPins();

        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, InitializeInputPins failed. hr=%x"), __fxName, hr));

            return hr;
        }

        m_dwNumPins += m_dwNumInputPins;
    }

    hr = CBaseFilter::EnumPins(ppEnum);

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s returns hr=%x"), __fxName, hr));

    return hr;
}

int 
CDSoundCaptureFilter::GetPinCount()
/*++

Routine Description:

    Implements pure virtual CBaseFilter::GetPinCount().
    Get the total number of pins on this filter. 

Arguments:

    Nothing.

Return Value:

    The number of pins.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::GetPinCount");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    CAutoLock Lock(m_pLock);

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s returns %d"), __fxName, m_dwNumPins));

    return m_dwNumPins;
}

CBasePin * 
CDSoundCaptureFilter::GetPin(
    int n
    )
/*++

Routine Description:

    Implements pure virtual CBaseFilter::GetPin().
    Get the pin object at position n. n is zero based.

Arguments:

    n -
        The index of the pin, zero based.

Return Value:

    Returns a pointer to the pin object if the index is valid. Otherwise,
    NULL is returned. Note: the pointer doesn't add refcount.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::GetPin");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    ASSERT(m_dwNumPins != 0);

    // The first pin is the output pin, the rest are input pins.
    return (n == 0)
        ? (CBasePin*)m_pOutputPin 
        : (CBasePin*)m_ppInputPins[n - 1];
}

// IAudioDeviceControl methods
STDMETHODIMP CDSoundCaptureFilter::GetRange (
    IN AudioDeviceProperty Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT long *plFlags
    )
{
    if (plMin == NULL ||
        plMax == NULL ||
        plSteppingDelta == NULL ||
        plDefault == NULL ||
        plFlags == NULL
        )
    {
        return E_POINTER;
    }

    HRESULT hr = E_NOTIMPL;
    switch (Property)
    {
    case AudioDevice_DuplexMode:
        break;

    case AudioDevice_AutomaticGainControl:
        *plMin = 0;
        *plMax = 1;
        *plSteppingDelta = 1;
        *plDefault = DEFAULT_AGC_STATUS ? 1 : 0;
        *plFlags = AmAudioDeviceControl_Flags_Auto;
        hr = S_OK;
        break;

    case AudioDevice_AcousticEchoCancellation:
        *plMin = 0;
        *plMax = 1;
        *plSteppingDelta = 1;
        *plDefault = DEFAULT_AEC_STATUS ? 1 : 0;
        *plFlags = AmAudioDeviceControl_Flags_Auto;
        hr = S_OK;
        break;

    default:
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CDSoundCaptureFilter::Get (
    IN AudioDeviceProperty Property, 
    OUT long *plValue, 
    OUT long *plFlags
    )
{
    if (plValue == NULL ||
        plFlags == NULL
        )
    {
        return E_POINTER;
    }

    HRESULT hr = E_NOTIMPL;
    switch (Property)
    {
    case AudioDevice_DuplexMode:
        break;

    case AudioDevice_AutomaticGainControl:
        *plValue = m_fAutomaticGainControl;
        *plFlags = AmAudioDeviceControl_Flags_Auto;
        hr = S_OK;
        break;

    case AudioDevice_AcousticEchoCancellation:
        *plValue = m_fAcousticEchoCancellation;
        *plFlags = AmAudioDeviceControl_Flags_Auto;
        hr = S_OK;
        break;
    
    default:
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CDSoundCaptureFilter::Set(
    IN AudioDeviceProperty Property, 
    IN long lValue, 
    IN long lFlags
    )
{
    HRESULT hr = E_NOTIMPL;
    switch (Property)
    {
    case AudioDevice_DuplexMode:
        break;

    case AudioDevice_AutomaticGainControl:
        if (lValue !=0 && lValue != 1)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            m_fAutomaticGainControl = lValue;
            hr = S_OK;
        }

        break;

    case AudioDevice_AcousticEchoCancellation:
        if (lValue !=0 && lValue != 1)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            CAutoLock Lock(m_pLock);
            if (m_pCaptureDevice)
            {
                hr = m_pCaptureDevice->ConfigureAEC(lValue);
                if (SUCCEEDED(hr))
                {
                    m_fAcousticEchoCancellation = lValue;
                }
            }
            else
            {
                m_fAcousticEchoCancellation = lValue;
                hr = S_OK;
            }
        }
        break;

    default:
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CDSoundCaptureFilter::SetDeviceID(
    IN  REFGUID pDSoundGUID,
    IN  UINT    uiWaveID
    )
/*++

Routine Description:

    Set the audio device ID for this capture filter. It can only be set once.

Arguments:

    pDSoundGUID -
        The GUID for the DSoundCapture device.

    uiWaveID -
        The ID for the wave device. 

Return Value:

    Returns a pointer to the pin object if the index is valid. Otherwise,
    NULL is returned. Note: the pointer doesn't add refcount.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::SetDeviceId");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));
    
#ifdef DEBUG
    WCHAR strGUID[CHARS_IN_GUID+1];
    StringFromGUID2(pDSoundGUID, strGUID, NUMELMS(strGUID) );
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, DSoundGUID %ws, WaveID:%d"), __fxName, strGUID, uiWaveID));
#endif

    CAutoLock Lock(m_pLock);

    // ??
    //if (m_fDeviceConfigured)
    //{
    //    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
    //        TEXT("%s, device configured twice"), __fxName));
    //    return E_UNEXPECTED;
    //}

    m_fDeviceConfigured = TRUE;
    m_DSoundGUID = pDSoundGUID;
    m_WaveID = uiWaveID;

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s returns S_OK"), __fxName));
    return S_OK;
}

STDMETHODIMP CDSoundCaptureFilter::SetDuplexController(
    IN  IAMAudioDuplexController * pIAudioDuplexController
    )
/*++

Routine Description:

    Set duplex controller that is share between the capture device and the
    render device.

Arguments:

    pIAudioDuplexController -
        The duplex controller object.

Return Value:
    
    S_OK;

--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::SetDuplexController");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    ASSERT(pIAudioDuplexController);

    CAutoLock Lock(m_pLock);

    if (m_pIAudioDuplexController != NULL)
    {
        m_pIAudioDuplexController->Release();
    }

    pIAudioDuplexController->AddRef();
    m_pIAudioDuplexController = pIAudioDuplexController;

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            "%s returns S_OK", __fxName));
    return S_OK;
}

HRESULT 
CDSoundCaptureFilter::InitializeOutputPin()
/*++

Routine Description:

    This function creates the output pin of the capture filter. 

    The caller is required to lock the filter.
    The function changes the m_pOutputPin member.

Arguments:

    Nothing.

Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::InitializeOutputPin");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    ASSERT(m_pOutputPin == NULL);

    HRESULT hr = S_OK;
    CDSoundCaptureOutputPin *pOutputPin;

    pOutputPin = new CDSoundCaptureOutputPin(this, &m_Lock, &hr);
    
    if (pOutputPin == NULL) 
    {
        return E_OUTOFMEMORY;
    }

    // If there was anything failed during the creation of the pin, delete it.
    if (FAILED(hr))
    {
        delete pOutputPin;
        return hr;
    }

    m_pOutputPin = pOutputPin;

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s returns S_OK"), __fxName));
    return S_OK;
}

HRESULT 
CDSoundCaptureFilter::InitializeInputPins(
    )
/*++

Routine Description:

    This function uses the mixer api to find out all the audio inputs on this
    device. An input pin is created for each input. 
    
    The caller is required to lock the filter.
    The function changes the m_ppInpuPins and m_dwNumInputPins member.

Arguments:

    Nothing.

Return Value:

    HRESULT

--*/
{
    ASSERT(m_ppInputPins == NULL);

    //TODO:
    //    m_ppInputPins = ppInpuPins;

    return S_OK;
}

HRESULT CDSoundCaptureFilter::ConfigureCaptureDevice(
    IN const WAVEFORMATEX *pWaveFormatEx,
    IN DWORD dwSourceBufferSize
    )
{
    ENTER_FUNCTION("CDSoundCaptureFilter::ConfigureCaptureDevice");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    ASSERT(m_fDeviceConfigured);

    CAutoLock Lock(m_pLock);

    HRESULT hr;

    if (m_pCaptureDevice == NULL)
    {
        // first we need to start the worker thread. It creates the events
        // that it will listen on.
        if (m_hThread == NULL)
        {
            hr = StartThread();
            if (FAILED(hr)) 
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, can't start thread, hr=%x"), __fxName, hr));
                return hr;
            }
        }

        m_pCaptureDevice = new CDSoundCapture(
            &m_DSoundGUID, 
            m_evDevice, 
            m_pIAudioDuplexController,
            &hr);

        if (m_pCaptureDevice == NULL)
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
                TEXT("%s, no memory for a capture device"), __fxName));
            return E_OUTOFMEMORY;
        }
    }

    // configure the capture format and size.
    hr = m_pCaptureDevice->ConfigureFormat(
        pWaveFormatEx, 
        dwSourceBufferSize
        );

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s, ConfigureFormat. hr=%x"), __fxName, hr));
        return hr;
    }

    // configure AEC
    m_pCaptureDevice->ConfigureAEC(m_fAcousticEchoCancellation);

    return hr;
}

// override GetState to report that we don't send any data when paused, so
// renderers won't starve expecting that
//
STDMETHODIMP CDSoundCaptureFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    if (m_State == State_Paused)
        return VFW_S_CANT_CUE;
    else
        return S_OK;
}

STDMETHODIMP CDSoundCaptureFilter::Stop()
/*++

Routine Description:

    This function stops the filter. It calls Pause() first to stop the capture device
    and to notify the pins to be inactive. 

Arguments:

    Nothing.

Return Value:

    S_OK.
--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::Stop");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    HRESULT hr = S_OK;
    CAutoLock Lock(m_pLock);

    if (m_State == State_Running) 
    {
        hr = m_pCaptureDevice->Stop();

        if (FAILED(hr)) 
        {
            NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Stop, hr);
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, Error in capture Stop:%x"), __fxName, hr));
            goto end;
        }

        hr = m_pCaptureDevice->Close();

        if (FAILED(hr)) 
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, Error in capture Close:%x"), __fxName, hr));
            goto end;
        }
    }

 end:
    HRESULT hr2 = CBaseFilter::Stop();

    if (SUCCEEDED(hr))
    {
        hr = hr2;
    }

    return(hr);
}


STDMETHODIMP CDSoundCaptureFilter::Pause()
/*++

Routine Description:

    When changing from running to paused, the capture device is stopped. When changing
    from stopped state to running, the capture device is opened.  

Arguments:

    Nothing.

Return Value:

    S_OK.
--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::Pause");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    CAutoLock Lock(m_pLock);

    // we don't want to change state if we are not connected.
    if (!m_pOutputPin || !m_pOutputPin->IsConnected())
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, not connected"), __fxName));
        return E_FAIL;
    }

    // the capture device must have been configured now.
    ASSERT(m_pCaptureDevice);

    HRESULT hr = S_OK;

    /* Check we can PAUSE given our current state */
    if (m_State == State_Running) 
    {
        hr = m_pCaptureDevice->Stop();

        if (FAILED(hr)) 
        {
            NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Stop, hr);
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, Error in capture Stop:%x"), __fxName, hr));
            goto end;
        }

        hr = m_pCaptureDevice->Close();

        if (FAILED(hr)) 
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, Error in capture Close:%x"), __fxName, hr));
            goto end;
        }
    } 

 end:
    // tell the pin to go inactive and change state
    HRESULT hr2 = CBaseFilter::Pause();

    if (SUCCEEDED(hr))
    {
        hr = hr2;
    }

    return(hr);
}


STDMETHODIMP CDSoundCaptureFilter::Run(REFERENCE_TIME tStart)
/*++

Routine Description:

    start the capture device. 

Arguments:

    Nothing.

Return Value:

    S_OK.
--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::Run");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, start time:%d"), 
            __fxName, (LONG)((CRefTime)tStart).Millisecs()));

    CAutoLock Lock(m_pLock);

    // we don't want to change state if we are not connected.
    if (!m_pOutputPin || !m_pOutputPin->IsConnected())
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, not connected"), __fxName));
        return E_FAIL;
    }

    // the capture device must have been configured now.
    ASSERT(m_pCaptureDevice);

    // don't do anything if we are running.
    if (m_State == State_Running)
    {
        return S_OK;
    }

    // open the wave device. It will do nothing if the device has been
    // opened. 
    HRESULT hr = m_pCaptureDevice->Open();
    
    if (FAILED(hr)) 
    {
        NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Open, hr);
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, Error in capture Open:%x"), __fxName, hr));
        return hr;
    }

    hr = m_pCaptureDevice->Start();
    if (FAILED(hr))
    {    
        NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Start, hr);
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, Error %x from capture Start"), __fxName, hr));
    }

    return CBaseFilter::Run(tStart);
}

extern "C" DWORD WINAPI gfThreadProc(LPVOID p)
{
    return ((CDSoundCaptureFilter *)p)->ThreadProc();
}

HRESULT CDSoundCaptureFilter::StartThread()
/*++

Routine Description:

    Create the thread if it has not already been created. Otherwise, just
    keep track of how many times the thread start was performed so that
    we only stop the thread when all of these have been paired with a stop.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::StartThread");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    CAutoLock Lock(m_pLock);

    if (m_hThread != NULL)
    {
        return S_OK;
    }

    DWORD dwThreadID;
    m_hThread = ::CreateThread(NULL, 0, gfThreadProc, this, 0, &dwThreadID);

    if (m_hThread == NULL)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, create thread failed. error:%d"), 
            __fxName, GetLastError()));
        
        return E_FAIL;
    }

    /* Increase the priority of the audio capture thread */
    if (!SetThreadPriority(m_hThread, THREAD_PRIORITY_TIME_CRITICAL))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, set thread priority. error:%d"), 
            __fxName, GetLastError()));
    }
    // check whether this is necessary?
    m_evDevice.Reset();
    m_evFinish.Reset();

    return S_OK;
}


HRESULT CDSoundCaptureFilter::ThreadProc()
/*++

Routine Description:

    the main loop of the worker thread 

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::ThreadProc");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    BOOL bExitFlag = FALSE;

    // lock the object to make sure the member handles are valid
    m_pLock->Lock();

    HANDLE Events[2];
    Events[0] = m_evDevice;
    Events[1] = m_evFinish;

    m_pLock->Unlock();

#if 0
    // change the thread priority.
    if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, SetThreadPriority failed. error:%d"), 
            __fxName, GetLastError()));
    }
    else
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s, thread priority set to %d"), 
            __fxName, GetThreadPriority(GetCurrentThread())));
    }
#endif 

    while (!bExitFlag)
    {
        DWORD dwResult = ::WaitForMultipleObjectsEx(
            2,                // wait for two event
            Events,           // array of events to wait for
            FALSE,            // do not wait for all.
            INFINITE,         // wait forever
            TRUE              // alertable
            );

        switch (dwResult)
        {
        case WAIT_OBJECT_0:
            ProcessSample();
            break;

        case WAIT_OBJECT_0 + 1:
            bExitFlag = TRUE;
            break;

        case WAIT_IO_COMPLETION:
            break;

        default:
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, WaitForMultipleObjectsEx failed, error:%d"), 
                __fxName, GetLastError()));

            bExitFlag = TRUE;
            break;
        }
    }

    DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s exits"), __fxName));
    return S_OK;
}


HRESULT CDSoundCaptureFilter::ProcessSample()
/*++

Routine Description:

    The method is called when the capture device event is signaled. It asks
    the capture device for finished samples and pass them on to the output
    pin.

Arguments:
    
Return Value:

    HRESULT.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureFilter::ProcessSample");

    CAutoLock Lock(m_pLock);
    
    // we don't deliver anything if the filters is not in running state.
    if (m_State != State_Running) 
    {
        return S_OK;
    }

    HRESULT hr;
    do
    {
        // Get the samples from the capture device.
        BYTE *pbBuffer;
        DWORD dwSize;
        hr = m_pCaptureDevice->LockFirstFrame(&pbBuffer, &dwSize);

        if (hr != S_OK)
        {
            break;
        }

        // let the output pin process it.
        LONG lGainAdjustment = 0;
        hr = m_pOutputPin->ProcessOneBuffer(
            pbBuffer, 
            dwSize, 
            m_pClock,
            &lGainAdjustment
            );

        if (hr != S_OK)
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, ProcessOneFrame returned, hr:%x"), 
                __fxName, hr));
        }


        // return the buffer to the caputre.
        hr = m_pCaptureDevice->UnlockFirstFrame(pbBuffer, dwSize);

        // try to adjust gain.
        if (lGainAdjustment && m_fAutomaticGainControl)
        {
            double dMixLevel;
            HRESULT hr2 = get_MixLevel(&dMixLevel);
            if (FAILED(hr2))
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, get_MixLevel returned, hr:%x"), 
                    __fxName, hr2));
            }
            else
            {
                hr2 = put_MixLevel(dMixLevel * (1 + (float)lGainAdjustment / 100.0));
                if (FAILED(hr2))
                {
                    DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                        TEXT("%s, put_MixLevel returned, hr:%x"), 
                        __fxName, hr2));
                }
                else
                {
                    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
                        TEXT("%s, gain adjusted %d percent"), 
                        __fxName, lGainAdjustment
                        ));
                }
            }
        }

    } while (SUCCEEDED(hr));

    return hr;
}

// Get info about a control... eg. volume, mute, etc.
// Also get a handle for calling further mixer APIs
//
HRESULT CDSoundCaptureFilter::GetMixerControl(
    IN  DWORD dwControlType,
    IN  DWORD dwTryComponent,
    OUT HMIXEROBJ *pID,
    OUT MIXERCONTROL *pmc
    )
{
    ENTER_FUNCTION("CDSoundCaptureFilter::GetMixerControl");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    ASSERT(!IsBadWritePtr(pID, sizeof(HMIXEROBJ)));
    ASSERT(!IsBadWritePtr(pmc, sizeof(MIXERCONTROL)));

    if(!m_fDeviceConfigured)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, called without setting a device"), __fxName));
        return E_UNEXPECTED;
    }


    // !!! this doesn't appear to work for wave mapper. oh uh.
    ASSERT(m_WaveID != WAVE_MAPPER);

    // get an ID to talk to the Mixer APIs.  They are BROKEN if we don't do
    // it this way!
    HMIXEROBJ MixerID;
    MMRESULT mmr = mixerGetID(
        (HMIXEROBJ)IntToPtr(m_WaveID), (UINT *)&MixerID, MIXER_OBJECTF_WAVEIN
        );

    if (mmr != MMSYSERR_NOERROR) 
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, mixerGetID failed, mmr=%d"), __fxName, mmr));
        return HRESULT_FROM_WIN32(mmr);
    }

    // get info about the overall WAVE INPUT destination channel
    MIXERLINE mixerinfo;
    mixerinfo.cbStruct = sizeof(mixerinfo);
    mixerinfo.dwComponentType = dwTryComponent;
    mmr = mixerGetLineInfo(MixerID, &mixerinfo,
                    MIXER_GETLINEINFOF_COMPONENTTYPE);
    if (mmr != 0 || 0 == mixerinfo.cControls) 
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_WARNING,
                TEXT("%s, mixerGetLineInfo WAVEIN line failed, mmr=%d"), __fxName, mmr));

        return HRESULT_FROM_WIN32(mmr);
    }

  
    // Get info about ALL the controls on this destination.. stuff that is
    // filter-wide
    MIXERLINECONTROLS mixercontrol;
    mixercontrol.cbStruct = sizeof(mixercontrol);
    mixercontrol.dwLineID = mixerinfo.dwLineID;
    mixercontrol.cControls = mixerinfo.cControls;
    mixercontrol.pamxctrl = (MIXERCONTROL *)malloc(mixerinfo.cControls * sizeof(MIXERCONTROL));

    if (mixercontrol.pamxctrl == NULL) 
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, Cannot allocate control array"), __fxName));
        return E_OUTOFMEMORY;
    }

    mixercontrol.cbmxctrl = sizeof(MIXERCONTROL);
    for (int i = 0; i < (int)mixerinfo.cControls; i++) 
    {
        mixercontrol.pamxctrl[i].cbStruct = sizeof(MIXERCONTROL);
    }

    mmr = mixerGetLineControls(MixerID, &mixercontrol, MIXER_GETLINECONTROLSF_ALL);
    if (mmr != 0) 
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, mixerGetLineControls failed, mmr=%d"), __fxName, mmr));
        free(mixercontrol.pamxctrl);
        return HRESULT_FROM_WIN32(mmr);
    }

    // Now find the control they are interested in and return it
    BOOL bFound = FALSE;
    for (i = 0; i < (int)mixerinfo.cControls; i++) 
    {
        if (mixercontrol.pamxctrl[i].dwControlType == dwControlType) 
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
                TEXT("%s, Found %x '%ls' control"), 
                __fxName,
                mixercontrol.pamxctrl[i].dwControlType,
                mixercontrol.pamxctrl[i].szName
                ));

            DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
                TEXT("%s, Range %d-%d by %d"), 
                __fxName,
                mixercontrol.pamxctrl[i].Bounds.dwMinimum,
                mixercontrol.pamxctrl[i].Bounds.dwMaximum,
                mixercontrol.pamxctrl[i].Metrics.cSteps
                ));

            CopyMemory(
                pmc, 
                &mixercontrol.pamxctrl[i], 
                mixercontrol.pamxctrl[i].cbStruct
                );

            bFound = TRUE;
            break;
        }
    }

    free(mixercontrol.pamxctrl);

    if (!bFound)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, can't find the control needed"), __fxName));
        return E_FAIL;
    }

    *pID = MixerID;
    
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s, exits ok."), __fxName));
    return S_OK;
}

HRESULT CDSoundCaptureFilter::put_MixLevel(
    IN  double Level
    )
{
    ENTER_FUNCTION("CDSoundCaptureFilter::put_MixLevel");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    if (Level < 0. || Level > 1.)
    {
        return E_INVALIDARG;
    }

    // Get the volume control
    HMIXEROBJ MixerID = NULL;
    MIXERCONTROL mc;
    HRESULT hr = GetMixerControl(
        MIXERCONTROL_CONTROLTYPE_VOLUME,
        MIXERLINE_COMPONENTTYPE_DST_WAVEIN,
        &MixerID,
        &mc
        );
    
    if (hr != NOERROR) 
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, Error %x getting volume control, 1st try"), __fxName, hr));

        // try another component
        hr = GetMixerControl(
            MIXERCONTROL_CONTROLTYPE_VOLUME,
            MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE,
            &MixerID,
            &mc
            );
    
        if (hr != NOERROR) 
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, Error %x getting volume control, 2nd try"), __fxName, hr));
            return hr;
        }
    }

    // calculate the volume.
    MIXERCONTROLDETAILS_UNSIGNED Volume;
    Volume.dwValue = (DWORD)(Level * mc.Bounds.dwMaximum);

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, volume is %d"), __fxName, Volume.dwValue));

    // set the volume.
    MIXERCONTROLDETAILS mixerdetails;
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cChannels = 1;    // sets all channels to same value
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_UNSIGNED);
    mixerdetails.paDetails = &Volume;

    MMRESULT mmr = mixerSetControlDetails(MixerID, &mixerdetails, 0);

    if (mmr != MMSYSERR_NOERROR) 
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, Error %d setting volume"), __fxName, mmr));
        return HRESULT_FROM_WIN32(mmr);
    }

    return S_OK;
}


HRESULT CDSoundCaptureFilter::get_MixLevel(
    OUT double FAR* pLevel
    )
{
    ENTER_FUNCTION("CDSoundCaptureFilter::get_MixLevel");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, pLevel:%p"), __fxName, pLevel));

    ASSERT(!IsBadWritePtr(pLevel, sizeof(double)));

    // Get the volume control
    // Get the volume control
    HMIXEROBJ MixerID = NULL;
    MIXERCONTROL mc;
    HRESULT hr = GetMixerControl(
        MIXERCONTROL_CONTROLTYPE_VOLUME,
        MIXERLINE_COMPONENTTYPE_DST_WAVEIN,
        &MixerID,
        &mc
        );
    
    if (hr != NOERROR) 
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, Error %x getting volume control, 1st try"), __fxName, hr));

        // try another component
        hr = GetMixerControl(
            MIXERCONTROL_CONTROLTYPE_VOLUME,
            MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE,
            &MixerID,
            &mc
            );
    
        if (hr != NOERROR) 
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, Error %x getting volume control, 2nd try"), __fxName, hr));
            return hr;
        }
    }

    MIXERCONTROLDETAILS_UNSIGNED Volume;

    // get the current volume levels
    MIXERCONTROLDETAILS mixerdetails;
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_UNSIGNED);
    mixerdetails.paDetails = &Volume;
    
    MMRESULT mmr = mixerGetControlDetails(MixerID, &mixerdetails, 0);
    if (mmr != MMSYSERR_NOERROR) 
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, Error %d getting volume"), __fxName, mmr));
        return HRESULT_FROM_WIN32(mmr);
    }

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, volume is %d"), __fxName, Volume.dwValue));

    *pLevel = ((double)Volume.dwValue) / mc.Bounds.dwMaximum;
    return NOERROR;
}

CUnknown *CAudioDuplexController::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    ENTER_FUNCTION("CAudioDuplexController:CreateInstance");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, pUnk Outer:%p"), __fxName, pUnk));

    CUnknown *pUnkDuplexController = new CAudioDuplexController(pUnk, phr);
                
    if (pUnkDuplexController == NULL) 
    {
        *phr = E_OUTOFMEMORY;
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, out of memory"), 
            __fxName));
    }
    else if (FAILED(*phr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s, the constructor failed, hr:%d"), 
            __fxName, *phr));
    }

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, returning:%p, hr:%x"), __fxName, pUnkDuplexController, *phr));

    return pUnkDuplexController;
} 

// default to 1200 milliseconds of 16bits data if the capture doesn't
// say anyting.
const DWORD DEFAULT_CAPTURE_BUFFER_SIZE = 19200; 

CAudioDuplexController::CAudioDuplexController(
    IN  LPUNKNOWN pUnk, 
    OUT HRESULT *phr
    ) : 
    CUnknown(
        NAME("CAudioDuplexController"), 
        pUnk
        ),
    m_fCaptureConfigured(FALSE),
    m_fRenderConfigured(FALSE),
    m_DSoundCaptureGUID(GUID_NULL),
    m_DSoundRenderGUID(GUID_NULL),
    m_pDSoundCapture(NULL),
    m_pCaptureBuffer(NULL),
    m_pCaptureBuffer8(NULL),
    m_pDSoundRender(NULL),
    m_pRenderBuffer(NULL),
    m_hWindow(NULL),
    m_dwCooperateLevel(0)
/*++

Routine Description:

    The constructor for the tapi audio capture filter. 

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    phr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    ENTER_FUNCTION("CAudioDuplexController::CAudioDuplexController");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, this=%p"), __fxName, this));

    *phr = S_OK;
    ZeroMemory(m_Effects, sizeof(m_Effects));

    return;
}

void CAudioDuplexController::CleanUpInterfaces()
{
    if (m_pCaptureBuffer8) m_pCaptureBuffer8->Release();
    if (m_pCaptureBuffer) m_pCaptureBuffer->Release();
    if (m_pDSoundCapture) m_pDSoundCapture->Release();
    if (m_pRenderBuffer) m_pRenderBuffer->Release();
    if (m_pDSoundRender) m_pDSoundRender->Release();

    m_pCaptureBuffer8 = NULL;
    m_pDSoundCapture = NULL;
    m_pCaptureBuffer = NULL;
    m_pDSoundRender = NULL;
    m_pRenderBuffer = NULL;
}

CAudioDuplexController::~CAudioDuplexController()
/*++

Routine Description:

    The desstructor for the tapi audio capture filter. 

Arguments:

    Nothing.

Return Value:

    Nothing.

--*/
{
    ENTER_FUNCTION("CAudioDuplexController::~CAudioDuplexController");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, this=%p"), __fxName, this));
    
    CleanUpInterfaces();
}

STDMETHODIMP
CAudioDuplexController::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    Overrides CBaseFilter::NonDelegatingQueryInterface().
    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. 

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid ==IID_IAMAudioDuplexController) {

        return GetInterface(static_cast<IAMAudioDuplexController*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
CAudioDuplexController::SetCaptureBufferInfo (
    IN  GUID *          pDSoundCaptureGUID,
    IN  DSCBUFFERDESC * pDescription
    )
/*++

Routine Description:

    This method is used to set the capture related information. It is called
    by the capture filter when the capture filter is connected.

Arguments:

Return Value:

--*/
{
    ENTER_FUNCTION("CAudioDuplexController::SetCaptureBufferInfo");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, this=%p"), __fxName, this));

    ASSERT(pDSoundCaptureGUID);
    ASSERT(pDescription);
    ASSERT(pDescription->lpwfxFormat);

    HRESULT hr = S_OK;

    CAutoLock Lock(&m_Lock);

    if (m_pCaptureBuffer != NULL)
    {
        // if the capture has been created, check to see if the info 
        // has changed.
        if (m_DSoundCaptureGUID != *pDSoundCaptureGUID)
        {
            // the device changed, We need to recreate everything.
            ASSERT(m_pDSoundCapture != NULL);
            ASSERT(m_pCaptureBuffer != NULL);
            ASSERT(m_pDSoundRender != NULL);
            ASSERT(m_pRenderBuffer != NULL);

            CleanUpInterfaces();
        }
        else if (m_CaptureFormat.nSamplesPerSec != pDescription->lpwfxFormat->nSamplesPerSec
            || m_CaptureFormat.wBitsPerSample != pDescription->lpwfxFormat->wBitsPerSample
            || m_CaptureBufferDescription.dwBufferBytes != pDescription->dwBufferBytes)
        {
            
            ASSERT(m_pDSoundCapture != NULL);

            // format changed, recreate the capture buffer;
            if (m_pCaptureBuffer)
            {
                m_pCaptureBuffer->Release();
                m_pCaptureBuffer = NULL;
            }

            if (m_pCaptureBuffer8)
            {
                m_pCaptureBuffer8->Release();
                m_pCaptureBuffer8 = NULL;
            }

            LPDIRECTSOUNDCAPTUREBUFFER  pCaptureBuffer;
            hr = m_pDSoundCapture->CreateCaptureBuffer(
                pDescription, &pCaptureBuffer, NULL
                );

            if (FAILED(hr))
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, create capture buffer failed. hr=%x"), 
                    __fxName, hr));
                return hr;
            }
            
            IDirectSoundCaptureBuffer8 *pIDirectSoundCaptureBuffer8 = NULL;
            hr = pCaptureBuffer->QueryInterface(
                IID_IDirectSoundCaptureBuffer8, 
                (VOID**)&pIDirectSoundCaptureBuffer8
                );

            if (FAILED(hr))
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, query CaptureBuffer8. hr=%x"), 
                    __fxName, hr));
            }
            
            // the CaptureBuffer8 pointer is optional.
            hr = S_OK;

            m_pCaptureBuffer = pCaptureBuffer;
            m_pCaptureBuffer8 = pIDirectSoundCaptureBuffer8;
        }
    }

    m_DSoundCaptureGUID = *pDSoundCaptureGUID;
    m_CaptureBufferDescription = *pDescription;
    m_CaptureFormat = *(pDescription->lpwfxFormat);
    m_CaptureBufferDescription.lpwfxFormat = &m_CaptureFormat;

    m_fCaptureConfigured = TRUE;

    return hr;
}

STDMETHODIMP
CAudioDuplexController::SetRenderBufferInfo (
    IN  GUID *          pDSoundRenderGUID,
    IN  DSBUFFERDESC *  pDescription,
    IN  HWND            hWindow,
    IN  DWORD           dwCooperateLevel
    )
/*++

Routine Description:

    This method is used to set the capture related information. It is called
    by the render filter when the capture filter is connected.

Arguments:

Return Value:

--*/
{
    ENTER_FUNCTION("CAudioDuplexController::SetRenderBufferInfo");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, this=%p"), __fxName, this));

    ASSERT(pDSoundRenderGUID);
    ASSERT(pDescription);

    HRESULT hr = S_OK;

    CAutoLock Lock(&m_Lock);

    if (m_pRenderBuffer != NULL)
    {
        // if the Render has been created, check to see if the info 
        // has changed.
        if (m_DSoundRenderGUID != *pDSoundRenderGUID 
            || m_RenderBufferDescription.dwFlags != pDescription->dwFlags)
        {
            // the device changed, We need to recreate everything.
            ASSERT(m_pDSoundCapture != NULL);
            ASSERT(m_pCaptureBuffer != NULL);
            ASSERT(m_pDSoundRender != NULL);
            ASSERT(m_pRenderBuffer != NULL);

            CleanUpInterfaces();
        }
        else if ((pDescription->lpwfxFormat == NULL) && (m_RenderBufferDescription.lpwfxFormat != NULL)
            || (pDescription->lpwfxFormat != NULL) && (m_RenderBufferDescription.lpwfxFormat == NULL)
            || ((pDescription->lpwfxFormat != NULL) && 
                    (m_RenderFormat.nSamplesPerSec != pDescription->lpwfxFormat->nSamplesPerSec
                    || m_RenderFormat.wBitsPerSample != pDescription->lpwfxFormat->wBitsPerSample
                    || m_RenderBufferDescription.dwBufferBytes != pDescription->dwBufferBytes)))
        {

            ASSERT(m_pDSoundRender != NULL);

            // format changed, recreate the Render buffer;
            LPDIRECTSOUNDBUFFER  pRenderBuffer;
            hr = m_pDSoundRender->CreateSoundBuffer(
                pDescription, &pRenderBuffer, NULL
                );

            if (FAILED(hr))
            {
                    DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, create Render buffer failed. hr=%x"), 
                    __fxName, hr));
                return hr;
            }

            m_pRenderBuffer->Release();
            m_pRenderBuffer = pRenderBuffer;
        }
    }

    m_DSoundRenderGUID = *pDSoundRenderGUID;
    m_RenderBufferDescription = *pDescription;

    if (pDescription->lpwfxFormat)
    {
        m_RenderFormat = *(pDescription->lpwfxFormat);
        m_RenderBufferDescription.lpwfxFormat = &m_RenderFormat;
    }
    else
    {
        m_RenderBufferDescription.lpwfxFormat = NULL;
    }
        
    m_hWindow = hWindow;
    m_dwCooperateLevel = dwCooperateLevel;

    m_fRenderConfigured = TRUE;

    return hr;
}

STDMETHODIMP
CAudioDuplexController::EnableEffects (
    IN  DWORD           dwNumberEffects,
    IN  EFFECTS *       pEffects,
    IN  BOOL *          pfEnable
    )
{
    ENTER_FUNCTION("CAudioDuplexController::EnableEffects");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, this=%p, effects:%d"), 
        __fxName, this, dwNumberEffects));

    ASSERT(!IsBadReadPtr(pEffects, dwNumberEffects * sizeof(EFFECTS)));
    ASSERT(!IsBadReadPtr(pfEnable, dwNumberEffects * sizeof(BOOL)));

    CAutoLock Lock(&m_Lock);

    for (DWORD dw = 0; dw < dwNumberEffects; dw ++)
    {
        ASSERT(pEffects[dw] < EFFECTS_LAST);
        if (pEffects[dw] >= EFFECTS_LAST)
        {
            return E_INVALIDARG;
        }
        if (m_Effects[pEffects[dw]] != pfEnable[dw])
        {
            HRESULT hr = ToggleEffects(pEffects[dw], pfEnable[dw]);

            if (FAILED(hr))
            {
                    DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, ToggleEffects %d failed. hr=%x"),
                    __fxName, dw, hr));

                return hr;
            }

            m_Effects[pEffects[dw]] = pfEnable[dw];
        }
    }

    return S_OK;
}

HRESULT 
CAudioDuplexController::ToggleEffects (
    IN  EFFECTS     Effect,
    IN  BOOL        fEnable
    )
{
    ENTER_FUNCTION("CAudioDuplexController::ToggleEffects");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, this=%p, effect:%d, Enable:%d"),
        __fxName, this, Effect, fEnable));

    // we don't support other effects now. 
    if (Effect != EFFECTS_AEC)
    {
        return S_OK;
    }

    CAutoLock Lock(&m_Lock);

    if (m_pCaptureBuffer8 == NULL)
    {
        return S_OK;
    }

    // get the pointer to the effect object.
    LPDIRECTSOUNDCAPTUREFXAEC pIDirectSoundCaptureFXAec;
    HRESULT hr = m_pCaptureBuffer8->GetObjectInPath(
        GUID_DSCFX_CLASS_AEC,
        0,
        IID_IDirectSoundCaptureFXAec,
        (LPVOID *) &pIDirectSoundCaptureFXAec
        );

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, GetObjectInPath for AEC failed. hr=%x"),
            __fxName, hr));

        return hr;
    }

    // change the AEC setting.
    DSCFXAec dscfxAEC;
    dscfxAEC.fEnable = fEnable;
    dscfxAEC.fNoiseFill = FALSE;
    dscfxAEC.dwMode = DSCFX_AEC_MODE_FULL_DUPLEX;
    
    hr = pIDirectSoundCaptureFXAec->SetAllParameters(&dscfxAEC);

    pIDirectSoundCaptureFXAec->Release();

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, SetAllParameters for AEC failed. hr=%x"),
            __fxName, hr));

        return hr;
    }

    return hr;
}

HRESULT CAudioDuplexController::CacheInterfaces(
    IN LPDIRECTSOUNDFULLDUPLEX pDirectSoundFullDuplex,
    IN IDirectSoundCaptureBuffer8 *pIDirectSoundCaptureBuffer8,
    IN IDirectSoundBuffer8 *pIDirectSoundBuffer8
    )
/*++

Routine Description:

    find and remember the dsound interfaces that will be used later.

Arguments:

Return Value:

--*/
{
    ENTER_FUNCTION("CAudioDuplexController::CacheInterfaces");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, this=%p"), __fxName, this));

    HRESULT hr;

    // find the capture object.
    hr = pDirectSoundFullDuplex->QueryInterface(
        IID_IDirectSoundCapture, 
        (VOID**)&m_pDSoundCapture
        );

    if(FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, query dsound capture failed. hr=%x"),
            __fxName, hr));

        return hr;
    }

    // find the redner object.
    hr = pDirectSoundFullDuplex->QueryInterface(
        IID_IDirectSound8, 
        (VOID**)&m_pDSoundRender
        );

    if(FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, query dsound render failed. hr=%x"),
            __fxName, hr));

        return hr;
    }

    // find the capture buffer object.
    hr = pIDirectSoundCaptureBuffer8->QueryInterface(
        IID_IDirectSoundCaptureBuffer, 
        (VOID **)&m_pCaptureBuffer
        );

    if(FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, query dsound capture buffer failed. hr=%x"),
            __fxName, hr));

        return hr;
    }

    // find the render buffer object.
    hr = pIDirectSoundBuffer8->QueryInterface(
        IID_IDirectSoundBuffer, 
        (VOID **)&m_pRenderBuffer
        );

    if(FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, query dsound capture buffer failed. hr=%x"),
            __fxName, hr));

        return hr;
    }

    return S_OK;
}

HRESULT 
CAudioDuplexController::FullDuplexCreate()
{
    ENTER_FUNCTION("CAudioDuplexController::FullDuplexCreate");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, this=%p"), __fxName, this));

    HRESULT hr = E_FAIL;

#ifndef DYNAMIC_AEC
    // This block is a workaround to bug #172212. When that bug is fixed, this
    // block should be removed to fix bug#146887.

    // if AEC has not been enabled, create the object in the old way. AEC can't
    // be enabled after this.
    if (!m_Effects[EFFECTS_AEC])
    {
        if (m_fCaptureConfigured && !m_pCaptureBuffer)
        {
            // create the capture objects the old way.
            hr = DirectSoundCaptureCreate(
                &m_DSoundCaptureGUID,
                &m_pDSoundCapture,
                NULL
                );

            if( hr != DS_OK )
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, DirectSoundCreate failed, hr=%x"), __fxName, hr));

                CleanUpInterfaces();
                return hr;
            }
        
            DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
                TEXT("%s, Dsound buffer size=%d"), 
                __fxName, m_CaptureBufferDescription.dwBufferBytes));

            // Create the capture buffer.
            hr = m_pDSoundCapture->CreateCaptureBuffer(
                &m_CaptureBufferDescription, &m_pCaptureBuffer, NULL
                );

            if (FAILED(hr))
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, create capture buffer failed. hr=%x"), __fxName, hr));

                CleanUpInterfaces();
                return hr;
            }
        }

        if (m_fRenderConfigured && !m_pRenderBuffer)
        {
            // create the dsound render objects the old way.
            hr = DirectSoundCreate(
                &m_DSoundRenderGUID,
                &m_pDSoundRender,  
                NULL
                );
    
            if( hr != DS_OK )
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, DirectSoundCreate failed, hr=%x"), __fxName, hr));

                CleanUpInterfaces();
                return hr;
            }

            // set the conoperative level so that we can set format on the primary 
            // buffer later.
            hr = m_pDSoundRender->SetCooperativeLevel(m_hWindow, m_dwCooperateLevel);

            if( hr != DS_OK )
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, DirectSoundCreate failed, hr=%x"), __fxName, hr));
    
                CleanUpInterfaces();
                return hr ;
            }

            // create the primary dsound buffer.
            hr = m_pDSoundRender->CreateSoundBuffer(
                &m_RenderBufferDescription, &m_pRenderBuffer, NULL 
                );

            if( hr != DS_OK )
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, create primary buffer failed, hr=%x"), __fxName, hr));
        
                CleanUpInterfaces();
                return hr ;
            }
        }

        return hr;
    }
#endif

    // if the capture info is not ready, use the default.
    if (!m_fCaptureConfigured)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, capture info is not ready, use default values."),
            __fxName));

        ZeroMemory(&m_CaptureBufferDescription, sizeof(m_CaptureBufferDescription));

        m_CaptureBufferDescription.dwSize  = sizeof(m_CaptureBufferDescription);
        m_CaptureBufferDescription.dwBufferBytes = DEFAULT_CAPTURE_BUFFER_SIZE;

        m_CaptureFormat = StreamFormatPCM16;
        m_CaptureBufferDescription.lpwfxFormat = &m_CaptureFormat;

        m_fCaptureConfigured = TRUE;

    }

    // if the render buffer is not ready, use the default
    if (!m_fRenderConfigured)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, render info is not ready, use default values."),
            __fxName));

        ZeroMemory(&m_RenderBufferDescription, sizeof(m_RenderBufferDescription));

        m_RenderBufferDescription.dwSize  = sizeof(m_RenderBufferDescription);
    
        m_RenderBufferDescription.dwFlags    = 
            DSBCAPS_GLOBALFOCUS | DSBCAPS_CTRLVOLUME | DSBCAPS_GETCURRENTPOSITION2;
        m_RenderBufferDescription.dwBufferBytes = StreamFormatPCM16.nAvgBytesPerSec * 2;
        m_RenderFormat = StreamFormatPCM16;
        m_RenderBufferDescription.lpwfxFormat   = &m_RenderFormat;                      

        m_fRenderConfigured = TRUE;
    }

    // note: we are only using the AEC effects now. If more effects are needed,
    // this part of the code needs to be changed.
    DSCEFFECTDESC DscEffects[] = {
        {sizeof(DSCEFFECTDESC), 0}
        };
    
    DscEffects[0].guidDSCFXClass = GUID_DSCFX_CLASS_AEC;
    DscEffects[0].guidDSCFXInstance = GUID_DSCFX_MS_AEC;
    DscEffects[0].dwFlags = DSFX_LOCSOFTWARE;

    m_CaptureBufferDescription.dwFlags |= DSCBCAPS_CTRLFX;
    m_CaptureBufferDescription.dwFXCount = NUMELMS (DscEffects);
    m_CaptureBufferDescription.lpDSCFXDesc = DscEffects;

    // now, create the dsound objects.
    LPDIRECTSOUNDFULLDUPLEX pDirectSoundFullDuplex = NULL;
    IDirectSoundCaptureBuffer8 *pIDirectSoundCaptureBuffer8 = NULL;
    IDirectSoundBuffer8 *pIDirectSoundBuffer8 = NULL;

    // repeat several times as suggested by dsound
    for (int iRepeat=0; iRepeat< 15; iRepeat++)
    {
        hr = DirectSoundFullDuplexCreate(
            &m_DSoundCaptureGUID,
            &m_DSoundRenderGUID,
            &m_CaptureBufferDescription,
            &m_RenderBufferDescription,
            m_hWindow,
            m_dwCooperateLevel,
            &pDirectSoundFullDuplex,
            &pIDirectSoundCaptureBuffer8,
            &pIDirectSoundBuffer8,
            NULL
            );
            
        if (hr == NOERROR)
            break;

        if(FAILED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, create dsound fullduplex failed (try %d). hr=%x"),
                __fxName, iRepeat, hr));
        }

        Sleep(20); /* 20ms */
    }                    

    if(FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, create dsound fullduplex failed. hr=%x"),
            __fxName, hr));
        return hr;
    }

    hr = CacheInterfaces(
        pDirectSoundFullDuplex,
        pIDirectSoundCaptureBuffer8,
        pIDirectSoundBuffer8
        );

    pDirectSoundFullDuplex->Release();
    pIDirectSoundBuffer8->Release();

    // we need to remember this pointer to configure AEC on the fly.
    m_pCaptureBuffer8 = pIDirectSoundCaptureBuffer8;

    if(FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, CacheInterfaces failed. hr=%x"),
            __fxName, hr));

        CleanUpInterfaces();
        return hr;
    }
    
    for (DWORD dw = 0; dw < EFFECTS_LAST; dw ++)
    {
        if (!m_Effects[dw])
        {
            // disable the effects that the user doesn't want. We have to build
            // all the effects in the graph and then disable them. Otherwise, we
            // can't enable them after the graph is running.
            ToggleEffects((EFFECTS)dw, FALSE);
        }
    }

    return hr;
}


STDMETHODIMP
CAudioDuplexController::GetCaptureDevice (
    LPLPDIRECTSOUNDCAPTURE        ppDSoundCapture,
    LPLPDIRECTSOUNDCAPTUREBUFFER  ppCaptureBuffer
    )
/*++

Routine Description:

    This method is called by the capture filter to obtain the pointers to the
    capture objects when it starts running.

Arguments:

Return Value:

--*/
{
    ENTER_FUNCTION("CAudioDuplexController::GetCaptureDevice");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, this=%p"), __fxName, this));

    ASSERT(ppDSoundCapture);
    ASSERT(ppCaptureBuffer);

    HRESULT hr = S_OK;

    if (m_pCaptureBuffer == NULL)
    {
        ASSERT(m_pDSoundCapture == NULL);

        hr = FullDuplexCreate();
        if(FAILED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, FullDuplexCreate. hr=%x"),
                __fxName, hr));

            return hr;
        }
    }

    ASSERT(m_pDSoundCapture != NULL);

    *ppDSoundCapture = m_pDSoundCapture;
    m_pDSoundCapture->AddRef();

    *ppCaptureBuffer = m_pCaptureBuffer;
    m_pCaptureBuffer->AddRef();

    return hr;
}

STDMETHODIMP
CAudioDuplexController::GetRenderDevice (
    LPLPDIRECTSOUND        ppDSoundRender,
    LPLPDIRECTSOUNDBUFFER  ppRenderBuffer
    )
/*++

Routine Description:

    This method is called by the render filter to obtain the pointers to the
    render objects when it starts running.

Arguments:

Return Value:

--*/
{
    ENTER_FUNCTION("CAudioDuplexController::GetRenderDevice");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, this=%p"), __fxName, this));

    ASSERT(ppDSoundRender);
    ASSERT(ppRenderBuffer);

    HRESULT hr = S_OK;

    if (m_pRenderBuffer == NULL)
    {
        ASSERT(m_pDSoundRender == NULL);

        hr = FullDuplexCreate();
        if(FAILED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, FullDuplexCreate. hr=%x"),
                __fxName, hr));

            return hr;
        }
    }

    ASSERT(m_pDSoundRender != NULL);

    *ppDSoundRender = m_pDSoundRender;
    m_pDSoundRender->AddRef();

    *ppRenderBuffer = m_pRenderBuffer;
    m_pRenderBuffer->AddRef();

    return hr;
}

STDMETHODIMP
CAudioDuplexController::ReleaseCaptureDevice ()
/*++

Routine Description:

    This method is called by the capture filter to release the capture
    device when it is done with it.

Arguments:

Return Value:

--*/
{
    ENTER_FUNCTION("CAudioDuplexController::ReleaseCaptureDevice");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, this=%p"), __fxName, this));

    if (m_pCaptureBuffer)
    {
        m_pCaptureBuffer->Release();
        m_pCaptureBuffer = NULL;
    }

    if (m_pCaptureBuffer8) 
    {
        m_pCaptureBuffer8->Release();
        m_pCaptureBuffer8 = NULL;
    }

    if (m_pDSoundCapture)
    {
        m_pDSoundCapture->Release();
        m_pDSoundCapture = NULL;
    }

    return S_OK;
}

STDMETHODIMP
CAudioDuplexController::ReleaseRenderDevice ()
/*++

Routine Description:

    This method is called by the render filter to release the render device
    when it is done with it.

Arguments:

Return Value:

--*/
{
    ENTER_FUNCTION("CAudioDuplexController::ReleaseRenderDevice");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s, this=%p"), __fxName, this));

    if (m_pRenderBuffer)
    {
        m_pRenderBuffer->Release();
        m_pRenderBuffer = NULL;
    }

    if (m_pDSoundRender)
    {
        m_pDSoundRender->Release();
        m_pDSoundRender = NULL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\filter\dscoutpin.cpp ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    dscoutpin.cpp

Abstract:

    This file implements the output pin object of the dsound capture filter.

--*/

#include "stdafx.h"
#include "dscfiltr.h"

#ifdef DBG
#define PERF
#endif

#if DBG

DWORD THRESHODL_INITIAL = 1146; 
DWORD THRESHODL_MAX = 20000; 
DWORD THRESHOLD_DELTA = 12; // the distance above the backround average.
DWORD SILENCEAVERAGEWINDOW = 16;

// time to adapt the threshold.
DWORD THRESHOLD_TIMETOADJUST = 30;   // 30 frames.
DWORD THRESHODL_ADJUSTMENT = 10; 

// silence packets played to fill in gaps between words.
DWORD FILLINCOUNT = 30;    // 30 frames 

// values for gain adjustments.
DWORD SOUNDCEILING = 25000;
DWORD SHORTTERMSOUNDAVERAGEWINDOW = 4;

DWORD SOUNDFLOOR = 4000;
DWORD LONGTERMSOUNDAVERAGEWINDOW = 32;

DWORD GAININCREMENT = 10;  // only rise 10% everytime.
DWORD GAININCREASEDELAY = 50;

// this is the threshold to remove the DC from the samples.
long DC_THRESHOLD = 500;
DWORD SAMPLEAVERAGEWINDOW = 1024;

DWORD SOFTAGC = 0;

BOOL GetSettingsFromRegistry()
{
    HKEY  hKey;
    DWORD dwDataSize, dwDataType;

    if (::RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\dxmrtp"),
        0,
        KEY_READ,
        &hKey) != NOERROR)
    {
        return FALSE;
    }

#define GetRegValue(szName, Variable) \
    dwDataSize = sizeof(DWORD); \
    RegQueryValueExW(hKey, szName, 0, &dwDataType, (LPBYTE)&Variable, &dwDataSize);

    GetRegValue(TEXT("THRESHODL_INITIAL"), THRESHODL_INITIAL);
    GetRegValue(TEXT("THRESHODL_MAX"), THRESHODL_MAX);
    GetRegValue(TEXT("THRESHOLD_DELTA"), THRESHOLD_DELTA);
    GetRegValue(TEXT("SILENCEAVERAGEWINDOW"), SILENCEAVERAGEWINDOW);

    GetRegValue(TEXT("THRESHOLD_TIMETOADJUST"), THRESHOLD_TIMETOADJUST);
    GetRegValue(TEXT("THRESHODL_ADJUSTMENT"), THRESHODL_ADJUSTMENT);

    GetRegValue(TEXT("FILLINCOUNT"), FILLINCOUNT);

    GetRegValue(TEXT("SOUNDCEILING"), SOUNDCEILING);
    GetRegValue(TEXT("SHORTTERMSOUNDAVERAGEWINDOW"), SHORTTERMSOUNDAVERAGEWINDOW);

    GetRegValue(TEXT("SOUNDFLOOR"), SOUNDFLOOR);
    GetRegValue(TEXT("LONGTERMSOUNDAVERAGEWINDOW"), LONGTERMSOUNDAVERAGEWINDOW);

    GetRegValue(TEXT("GAININCREMENT"), GAININCREMENT);
    GetRegValue(TEXT("GAININCREASEDELAY"), GAININCREASEDELAY);

    GetRegValue(TEXT("SOFTAGC"), SOFTAGC);

    RegCloseKey (hKey);
    
    return TRUE;
}
#endif


#ifdef PERF
LARGE_INTEGER g_liFrequency;

inline int ClockDiff(
    LARGE_INTEGER &liNewTick, 
    LARGE_INTEGER &liOldTick
    )
{
    return (DWORD)((liNewTick.QuadPart - liOldTick.QuadPart) 
        * 1e9 / g_liFrequency.QuadPart);
}
#endif

CDSoundCaptureOutputPin::CDSoundCaptureOutputPin(
    IN  CDSoundCaptureFilter *     pFilter,
    IN  CCritSec *      pLock,
    OUT HRESULT *       phr
    ) :
    CBaseOutputPin(
        NAME("CDSoundCaptureOutputPin"),
        pFilter,                   // Filter
        pLock,                     // Locking
        phr,                       // Return code
        L"Output"                  // Pin name
        ),
    m_dwSampleSize(0),
    m_dwBufferSize(0),
    m_lDurationPerBuffer(0),
    m_dwSamplesPerBuffer(0),
    m_fFormatChanged(FALSE),
    m_pPendingSample(NULL),
    m_fSilenceSuppression(TRUE)

/*++

Routine Description:

    The constructor for the output pin. 

Arguments:

    IN  CDSoundCaptureFilter *     pFilter -
        The capture filter that exposes this pin.
        
    IN  CCritSec *      pLock -
        The critical section to lock the filter and the pin.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::CDSoundCaptureOutputPin");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, pFilter:%p"),
        __fxName, pFilter));

    *phr = S_OK;
    
#ifdef PERF
    QueryPerformanceFrequency(&g_liFrequency);
#endif

    m_WaveFormat = StreamFormatPCM16; // our default capture format
    
#if DBG 

    GetSettingsFromRegistry();

    m_fAutomaticGainControl = (SOFTAGC != 0);
    m_GainFactor = 1.0;

#endif

    ResetSilenceStats();

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s returns S_OK"), __fxName));
    return;
}


CDSoundCaptureOutputPin::~CDSoundCaptureOutputPin()
/*++

Routine Description:

    The desstructor for the tapi audio output pin. It releases the aggregated
    encoding handler object.

Arguments:

    Nothing.

Return Value:

    Nothing.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::~CDSoundCaptureOutputPin");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, this=%p"), __fxName, this));

    if (m_pPendingSample)
    {
        m_pPendingSample->Release();
    }
 }

STDMETHODIMP
CDSoundCaptureOutputPin::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    Overrides CBaseOutputPin::NonDelegatingQueryInterface().
    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. 

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    HRESULT hr;

    if (riid == IID_IAMStreamConfig) {

        return GetInterface(static_cast<IAMStreamConfig*>(this), ppv);
    }
    return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
} 

HRESULT
CDSoundCaptureOutputPin::Run(REFERENCE_TIME tStart)
{
    m_tStart = tStart;
    return S_OK;
}

HRESULT
CDSoundCaptureOutputPin::Inactive()
{
    ResetSilenceStats();
    if (m_pPendingSample)
    {
        m_pPendingSample->Release();
        m_pPendingSample = NULL;
    }

    return CBaseOutputPin::Inactive();
}

HRESULT CDSoundCaptureOutputPin::GetMediaType(
    IN      int     iPosition, 
    OUT     CMediaType *pMediaType
    )
/*++

Routine Description:

    This function is called by the CEnumMediaType::Next method. It is 
    delegated to the encoding handler's GetMediaType method.

Arguments:

    IN  int iPosition, 
        the index of the media type, zero based..
        
    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::GetMediaType");

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, iPosition:%d, pMediaType:%p"), 
        __fxName, iPosition, pMediaType));

    ASSERT(!IsBadWritePtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    // We only give out the media type selected by the user through SetFormat.
    if (iPosition != 0)
    {
        return VFW_S_NO_MORE_ITEMS;
    }

    // Get the media type.
    AM_MEDIA_TYPE *pmt;
    HRESULT hr = GetFormat(&pmt);

    if( SUCCEEDED( hr ) )
    {
        WAVEFORMATEX *pWaveFormat = (WAVEFORMATEX *) pmt->pbFormat;

        // fill the media type with our info.
        hr = CreateAudioMediaType(
            pWaveFormat, 
            pMediaType,
            TRUE
            );
    }            

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s returns %d"), __fxName, hr));

    return hr;
}


HRESULT CDSoundCaptureOutputPin::CheckMediaType(
    const CMediaType *pMediaType
    )
/*++

Routine Description:

    This function is called by AttemptConnection to see if we like this media
    type.

Arguments:

    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK - success
    E_OUTOFMEMORY - no memory
    VFW_E_TYPE_NOT_ACCEPTED - media type rejected
    VFW_E_INVALIDMEDIATYPE  - bad media type

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::CheckMediaType");

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, pMediaType:%p"), __fxName, pMediaType));
        
    CAutoLock Lock(m_pLock);
        
    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    // reject non-Audio type
    if (pMediaType->majortype != MEDIATYPE_Audio ||
        pMediaType->formattype != FORMAT_WaveFormatEx) 
    {
        DbgLog((LOG_TRACE, TRACE_LEVEL_FAIL, 
            "%s, invalid format type", __fxName));
        return VFW_E_INVALIDMEDIATYPE;
    }

    WAVEFORMATEX *pWaveFormatEx = (WAVEFORMATEX *) pMediaType->pbFormat;

    if (IsBadReadPtr(pWaveFormatEx, pMediaType->cbFormat))
    {
        DbgLog((LOG_TRACE, TRACE_LEVEL_FAIL, 
            "%s, bad pointer, pMediaType->pbFormat:%p", 
            __fxName, pWaveFormatEx));
        return E_POINTER;
    }

    ASSERT(!IsBadReadPtr(pWaveFormatEx, sizeof(WAVEFORMATEX)));

    BOOL fOK = (pWaveFormatEx->wFormatTag == WAVE_FORMAT_PCM)
        && (pWaveFormatEx->nChannels      >= StreamCapsPCM16.MinimumChannels)
        && (pWaveFormatEx->nChannels      <= StreamCapsPCM16.MaximumChannels)
        && (pWaveFormatEx->wBitsPerSample >= StreamCapsPCM16.MinimumBitsPerSample)
        && (pWaveFormatEx->wBitsPerSample <= StreamCapsPCM16.MaximumBitsPerSample)
        && (pWaveFormatEx->nSamplesPerSec >= StreamCapsPCM16.MinimumSampleFrequency)
        && (pWaveFormatEx->nSamplesPerSec <= StreamCapsPCM16.MaximumSampleFrequency);

    HRESULT hr = fOK ? S_OK : VFW_E_INVALIDMEDIATYPE;

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s returns %d"), __fxName, hr));

    return hr;
}

HRESULT CDSoundCaptureOutputPin::SetMediaType(
    const CMediaType *pMediaType
    )
/*++

Routine Description:

    This function is called by AttemptConnection to set the media type after
    the media type has been checked. AttemptConnection ignores the return of
    this function so it has to succeed.

Arguments:

    In  CMediaType *pMediaType
        Pointer to a CMediaType object to save the returned media type.

Return Value:

    S_OK.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::SetMediaType");

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, pMediaType:%p"), __fxName, pMediaType));

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    HRESULT hr = SetFormat((AM_MEDIA_TYPE*)pMediaType);

    ASSERT(hr == S_OK);

    hr = CBaseOutputPin::SetMediaType(pMediaType);

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s returns %d"), __fxName, hr));
    
    return hr;
}

HRESULT
CDSoundCaptureOutputPin::CompleteConnect(IPin *pReceivePin)
/*++

Routine Description:

    This function does the final check before connecting the two pins. It sets
    the capture format on the filter and negotiates allocators.

Arguments:

    pReceivePin - the pin that is going to be connected.

Return Value:

    S_OK.

--*/
{
    UNREFERENCED_PARAMETER(pReceivePin);

    ENTER_FUNCTION("CDSoundCaptureOutputPin::CompleteConnect");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s"), __fxName));

    // lock the object while we are doing format changing.
    CAutoLock Lock(m_pLock);
    
    // downstream filter will decide sample size in DecideBufferSize
    m_dwSampleSize       = 0;
    
    m_dwBufferSize       = PCM_SAMPLES_PER_FRAME * m_WaveFormat.wBitsPerSample / 8;
    m_lDurationPerBuffer = PCM_FRAME_DURATION;
    m_dwSamplesPerBuffer = PCM_SAMPLES_PER_FRAME;

    // this method will call DecideBufferSize
    HRESULT hr = CBaseOutputPin::CompleteConnect(pReceivePin);

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s CBaseOutputPin::CompleteConnect failed. hr=%x"),
            __fxName, hr));

        return hr;
    }

    // now configure the capture filter with the format and size required.
    hr = ((CDSoundCaptureFilter*)m_pFilter)->ConfigureCaptureDevice(
            &m_WaveFormat,
            m_dwSampleSize
            );

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s Configure capture device failed hr=%x"), __fxName, hr));
        return hr;
    }

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s returns %d"), __fxName, hr));
    return hr;
}

HRESULT CDSoundCaptureOutputPin::DecideBufferSize(
    IMemAllocator *pAlloc,
    ALLOCATOR_PROPERTIES *pProperties
    )
/*++

Routine Description:

    This function is called during the process of deciding an allocator. We tell
    the allocator what we want. It is also a chance to find out what the 
    downstream pin wants when we don't have a preference.

Arguments:

    pAlloc -
        Pointer to a IMemAllocator interface.

    pProperties -
        Pointer to the allocator properties.

Return Value:

    S_OK - success.

    E_FAIL - the buffer size can't fulfill our requirements.
--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::DecideBufferSize");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    if (m_dwSampleSize == 0)
    {
        if (pProperties->cbBuffer != 0)
        {
            // we don't care about the size, use the downstream pin's
            DWORD dwOldSize = m_dwBufferSize;

            if (dwOldSize == 0)
            {
                return E_UNEXPECTED;
            }

            m_dwSampleSize = pProperties->cbBuffer;
            m_lDurationPerBuffer = m_lDurationPerBuffer * m_dwSampleSize / dwOldSize;
            m_dwSamplesPerBuffer = m_dwSamplesPerBuffer * m_dwSampleSize / dwOldSize;
            m_dwBufferSize = m_dwSampleSize;
        }
        else
        {
            // if the downstream pin doesn't care either, use ours.
            m_dwSampleSize = m_dwBufferSize;
        }
    }

    ASSERT(m_dwSampleSize != 0);

    pProperties->cbBuffer = m_dwSampleSize;
    pProperties->cBuffers = AUDCAPOUTPIN_NUMBUFFERS;
    
    // Ask the allocator to reserve us the memory
    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s SetProperties failed hr=%x"), __fxName, hr));
        return hr;
    }

    // Is this allocator unsuitable
    if ((Actual.cbBuffer < pProperties->cbBuffer) ||
        (Actual.cBuffers < pProperties->cBuffers))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s actual allocator is too small, (%d,%d), asked(%d,%d)"),
            __fxName, Actual.cBuffers, Actual.cbBuffer,
            pProperties->cBuffers, pProperties->cbBuffer));

        return E_FAIL;
    }

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s property:cBuffers:%d,cbBuffer:%d,cbAlign:%d,cbPrefix"),
        __fxName, 
        Actual.cBuffers, Actual.cbBuffer, Actual.cbAlign, Actual.cbPrefix));

    return S_OK;
}

HRESULT CDSoundCaptureOutputPin::ValidateMediaType(
    IN  AM_MEDIA_TYPE *pMediaType
    )
/*++

Routine Description:

    This function validates that the media type is valid.

Arguments:

    pMediaType
        Pointer to a AM_MEDIA_TYPE structure.

Return Value:

    S_OK - success.

    E_POINTER - bad pointer.

    VFW_E_INVALIDMEDIATYPE - bad media type.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::ValidateMediaType");

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, pMediaType:%p"), __fxName, pMediaType));

    ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    // reject non-Audio type
    if (pMediaType->majortype != MEDIATYPE_Audio ||
        pMediaType->formattype != FORMAT_WaveFormatEx) 
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, invalid format type"), __fxName));
        return VFW_E_INVALIDMEDIATYPE;
    }

    WAVEFORMATEX *pWaveFormatEx = (WAVEFORMATEX *) pMediaType->pbFormat;

    if (IsBadReadPtr(pWaveFormatEx, pMediaType->cbFormat))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, bad pointer, pMediaType->pbFormat:%p"), 
            __fxName, pWaveFormatEx));
        return E_POINTER;
    }

    return S_OK;
}

HRESULT CDSoundCaptureOutputPin::SetFormatInternal(
    IN  AM_MEDIA_TYPE *pMediaType
    )
/*++

Routine Description:

    This function sets the format on the encoder handler and reconfigure
    the capture device if necessage.

Arguments:

    pMediaType
        Pointer to a AM_MEDIA_TYPE structure.

Return Value:

    S_OK - success.

    E_POINTER - bad pointer.

    VFW_E_INVALIDMEDIATYPE - bad media type.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::SetFormatInternal");

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, pMediaType:%p"), __fxName, pMediaType));

    WAVEFORMATEX * pwfx = (WAVEFORMATEX *) pMediaType->pbFormat;
    
    DWORD dwBufferSize = PCM_SAMPLES_PER_FRAME * pwfx->wBitsPerSample / 8;
    
    LONG  lDurationPerBuffer = PCM_FRAME_DURATION;
    DWORD dwSamplesPerBuffer = PCM_SAMPLES_PER_FRAME;

    // configure the capture filter with the format and size required.
    HRESULT hr = ((CDSoundCaptureFilter*)m_pFilter)->ConfigureCaptureDevice(
            pwfx,
            dwBufferSize
            );

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s Configure capture device failed hr=%x"), __fxName, hr));
        return hr;
    }

    m_dwBufferSize = dwBufferSize;
    m_lDurationPerBuffer = lDurationPerBuffer;
    m_dwSamplesPerBuffer = dwSamplesPerBuffer;
    
    m_WaveFormat = *pwfx;
    
    return hr;
}

STDMETHODIMP CDSoundCaptureOutputPin::SetFormat(
    IN  AM_MEDIA_TYPE *pMediaType
    )
/*++

Routine Description:

    This function sets the output format of the output pin. This method calls
    the SetFormat method on the encoding handler to change format. After that,
    the encoding handler is queried for the capture format as a result of the
    new output format. If anything changed, the capture device needs to be 
    reconfigured.

Arguments:

    pMediaType
        Pointer to a AM_MEDIA_TYPE structure.

Return Value:

    S_OK - success.

    E_POINTER - bad pointer.

    VFW_E_INVALIDMEDIATYPE - bad media type.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::SetFormat");

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, pMediaType:%p"), __fxName, pMediaType));

    // first validate the media type.
    HRESULT hr = ValidateMediaType(pMediaType);
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, the media type is not valid, hr=%x"), __fxName, hr));
        return hr;
    }

    // we want to lock the pin while configuring the formats.
    CAutoLock Lock(m_pLock);
    
    // second find out if the mediatype is the same as the current one.
    AM_MEDIA_TYPE* pCurrentMediaType = NULL;
    hr = GetFormat(&pCurrentMediaType);
    if (SUCCEEDED(hr))
    {
        ASSERT(pCurrentMediaType->cbFormat != 0);

        if ((pCurrentMediaType->cbFormat == pMediaType->cbFormat) &&
            (memcmp(pCurrentMediaType->pbFormat, 
                    pMediaType->pbFormat, pCurrentMediaType->cbFormat) == 0))
        {
            // nothing changed.
            DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
                TEXT("%s, same format, just return."), __fxName));

            DeleteMediaType(pCurrentMediaType);
            return S_OK;
        }
    }

    // if we are connected, make sure the connected pin likes it.
    if (IsConnected()) 
    {
        hr = GetConnected()->QueryAccept(pMediaType);
        if (hr != S_OK)
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, the connected failed QueryAccept, hr=%x"), 
                __fxName, hr));

            DeleteMediaType(pCurrentMediaType);
            return hr;
        }
    }

    hr = SetFormatInternal(pMediaType);
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, SetFormatInternal returned hr=%x"), 
            __fxName, hr));

        // if the new format failed, reset to the old one.
        HRESULT hr2 = SetFormatInternal(pCurrentMediaType);

        if (FAILED(hr2))
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, reset old fomrat returned hr=%x"), 
                __fxName, hr2));
        }

        // release the current media type.
        DeleteMediaType(pCurrentMediaType);
        
        return hr;
    }

    // release the current media type.
    DeleteMediaType(pCurrentMediaType);

    m_fFormatChanged = TRUE;

#if DYNAMIC // we need dynamic graph building to do this.
    // finally, reconnect the pin if we are already connected.
    if (IsConnected()) 
    {
        hr = m_pFilter->ReconnectPin(this, pMediaType);
    }
#endif

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s returns %d"), __fxName, hr));

    return hr;
}

STDMETHODIMP CDSoundCaptureOutputPin::GetFormat(
    OUT AM_MEDIA_TYPE **ppMediaType
    )
/*++

Routine Description:

    Get the current format being produced by the output pin. Delegated to the
    encoding handler.

Arguments:

    ppMediaType
        Pointer to a pointer to a AM_MEDIA_TYPE structure. The caller should 
        use DeleteMediaType to free the structure when done.

Return Value:

    S_OK - success.

    E_POINTER - bad pointer.

    E_OUTOFMEMORY - no memory.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::GetFormat");

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, ppMediaType:%p"), __fxName, ppMediaType));

    ASSERT(!IsBadWritePtr(ppMediaType, sizeof(AM_MEDIA_TYPE *)));

    // allocate the AM_MEDIA_TYPE structure for return.
    AM_MEDIA_TYPE * pMediaType = 
        (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));

    if (pMediaType == NULL)
    {
        DbgLog((LOG_TRACE, TRACE_LEVEL_FAIL, 
            "%s, no memory for the media type."));

        return E_OUTOFMEMORY;
    }

    // fill the media type with our info.
    HRESULT hr = CreateAudioMediaType(
        &m_WaveFormat, 
        pMediaType,
        TRUE
        );

    if (FAILED(hr))
    {
        CoTaskMemFree(pMediaType);
        DbgLog((LOG_TRACE, TRACE_LEVEL_FAIL, 
            "%s, CreateAudioMediaType failed, hr:%x", hr));
        return hr;
    }

    *ppMediaType = pMediaType;

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s returns %d"), __fxName, hr));

    return hr;
}


STDMETHODIMP CDSoundCaptureOutputPin::GetNumberOfCapabilities(
    OUT int *piCount,
    OUT int *piSize
    )
/*++

Routine Description:

    The the number of capabilities and the size of the structure describing
    the capability.

Arguments:

    pdwCount
        pointer to a int where the number of caps will be returned.

Return Value:

    S_OK - success.

    E_POINTER - bad pointer.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::GetNumberOfCapabilities");

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, pdwCount:%p:%p"), __fxName, piCount));

    ASSERT(!IsBadWritePtr(piCount, sizeof(int)));

    *piCount = 1;
    *piSize = sizeof( AUDIO_STREAM_CONFIG_CAPS );

    return S_OK;
}


STDMETHODIMP CDSoundCaptureOutputPin::GetStreamCaps(
    IN  int i, 
    OUT AM_MEDIA_TYPE **ppmt,
    OUT BYTE *pSCC
    )
/*++

Routine Description:

    Get a specific capability.

Arguments:

    dwIndex
        The index of the capability.

    ppMediaType
        Pointer to a pointer that will points to a AM_MEDIA_TYPE structure
        after return. The caller should use DeleteMediaType to free the memory.

    pCapability
        Pointer to a buffer allocated by the caller to store the capability.

Return Value:

    S_OK - success.

    VFW_S_NO_MORE_ITEMS - no more items.

    E_POINTER - bad pointer.

    E_OUTOFMEMORY - no memory.

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::GetStreamCaps");

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, dwIndex:%d, ppMediaType:%p, pCapability:%p"), 
        __fxName, i, ppmt, pSCC));

    ASSERT(!IsBadWritePtr(ppmt, sizeof(AM_MEDIA_TYPE *)));

    if (pSCC != NULL && 
        IsBadWritePtr(pSCC, sizeof(AUDIO_STREAM_CONFIG_CAPS)))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, iIndex:%d, ppMediaType:%p, pCapability:%p"), 
            __fxName, i, ppmt, pSCC));

        return E_POINTER;
    }

    if (i < 0)
        return E_INVALIDARG;
    if (pSCC == NULL || ppmt == NULL)
        return E_POINTER;

    if (i > 0)
        return S_FALSE;

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
	    return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(i, (CMediaType *) *ppmt);
    if (hr != NOERROR) {
    	CoTaskMemFree(*ppmt);
	    *ppmt = NULL;
        return hr;
    }

    AUDIO_STREAM_CONFIG_CAPS *pASCC = (AUDIO_STREAM_CONFIG_CAPS *)pSCC;

    pASCC->guid                     = MEDIATYPE_Audio;
    pASCC->MinimumChannels          = StreamCapsPCM16.MinimumChannels;
    pASCC->MaximumChannels          = StreamCapsPCM16.MaximumChannels;
    pASCC->ChannelsGranularity      = StreamCapsPCM16.ChannelsGranularity;
    pASCC->MinimumSampleFrequency   = StreamCapsPCM16.MinimumSampleFrequency;
    pASCC->MaximumSampleFrequency   = StreamCapsPCM16.MaximumSampleFrequency;
    pASCC->SampleFrequencyGranularity = StreamCapsPCM16.SampleFrequencyGranularity;
    pASCC->MinimumBitsPerSample     = StreamCapsPCM16.MinimumBitsPerSample;
    pASCC->MaximumBitsPerSample     = StreamCapsPCM16.MaximumBitsPerSample;
    pASCC->BitsPerSampleGranularity = StreamCapsPCM16.BitsPerSampleGranularity;

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s returns %d"), __fxName, hr));

    return hr;
}

HRESULT CDSoundCaptureOutputPin::DeliverSample(
    IN  IMediaSample * pSample,
    IN  DWORD dwStatus,
    IN  IReferenceClock * pClock
    )
/*++

Routine Description:

    Deliver on MediaSample to the next pin. If the sample is silence, it is
    discarded. If the sample needs to combine with the next few samples, it
    is queued up until enough samples have been queued.

Arguments:

    pSample - the media sample that contains the encoded data.

    dwStatus - the status code of the encoding. It indicates whether the sample
        is silence or needs to be queued up.

    pClock - the external clock to read the timestamp from.

Return Value:

    S_OK - success.
    S_FALSE - not connected.

    E_UNEXPECTED - incomplete sample..

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::DeliverSample");

    if (IsSilence(dwStatus))
    {
        return S_OK;
    }

    HRESULT hr = S_OK;

    // send event to stream so that it can notify the quality controller.
    if (IsTalkStart(dwStatus))
    {
        m_pFilter->NotifyEvent(VAD_EVENTBASE + VAD_TALKING, 0, 0);
    }
    else if (IsTalkEnd(dwStatus))
    {
        m_pFilter->NotifyEvent(VAD_EVENTBASE + VAD_SILENCE, 0, 0);
    }

    // if this is the first sample of a talk spurt, sync up the clock.
    if (IsTalkStart(dwStatus) && pClock)
    {
        CRefTime CurrentTime;
        hr = pClock->GetTime((REFERENCE_TIME*)&CurrentTime);
        if (SUCCEEDED(hr))
        {
            m_SampleTime = CurrentTime - m_tStart +
                (CRefTime)(LONG)(m_lDurationPerBuffer + SAMPLEDELAY);
        }
    }

    CRefTime StartTime(m_SampleTime);

    if (m_pPendingSample == NULL)
    {
        // This is a brand new sample.

        // set the Discontinuity flag to notify the RTP filter.
        // BOOL fDiscontinuity = (IsTalkStart(dwStatus) || IsTalkEnd(dwStatus));
        BOOL fDiscontinuity = IsTalkStart(dwStatus);
        hr = pSample->SetDiscontinuity(fDiscontinuity);
        ASSERT(SUCCEEDED(hr));

        // set the timestamps
        StartTime -= m_lDurationPerBuffer;

        hr = pSample->SetTime(
            (REFERENCE_TIME*)&StartTime, 
            (REFERENCE_TIME*)&m_SampleTime);

        ASSERT(SUCCEEDED(hr));

        DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("tStart(%d), tStop(%d),Bytes(%d)"),
            StartTime.Millisecs(),
            m_SampleTime.Millisecs(),
            pSample->GetActualDataLength()
            ));

        if (m_fFormatChanged)
        {
            AM_MEDIA_TYPE* pMediaType;
            DWORD dwPayLoadType;
    
            hr = GetFormat(&pMediaType);

            if (FAILED(hr))
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, GetFormat failed, hr=%x"), __fxName, hr));
                return hr;
            }

            hr = pSample->SetMediaType(pMediaType);

            // the sample keeps a copy.
            DeleteMediaType(pMediaType);
        
            if (FAILED(hr))
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, SetMediaType failed, hr=%x"), __fxName, hr));
                return hr;
            }

            m_fFormatChanged = FALSE;
        }
    }
    else
    {
        // We are dealing with an accumulated sample here. keep the original
        // flags, only change the endtime.
        CRefTime oldStartTime;        
        CRefTime oldStopTime;

        if (SUCCEEDED(pSample->GetTime(
            (REFERENCE_TIME*)&oldStartTime, 
            (REFERENCE_TIME*)&oldStopTime
            )))
        {
            hr = pSample->SetTime(
                (REFERENCE_TIME*)&oldStartTime, 
                (REFERENCE_TIME*)&m_SampleTime
                );

            DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
                TEXT("tStart(%d), tStop(%d),Bytes(%d)"),
                oldStartTime.Millisecs(),
                m_SampleTime.Millisecs(),
                pSample->GetActualDataLength()
                ));
        }
        else
        {
            ASSERT(!"No timestamp on pending sample");
        }
    }
    

    if (!IsPending(dwStatus) || IsTalkEnd(dwStatus))
    {
        hr = Deliver(pSample);
        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, Deliver failed, hr=%x"), __fxName, hr));
        }
        else
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
                TEXT("Sample delivered, Bytes(%d)"),
                pSample->GetActualDataLength()
                ));
        }

        pSample->SetMediaType(NULL);

        if (m_pPendingSample != NULL)
        {
            m_pPendingSample->Release();
            m_pPendingSample = NULL;
        }
    }
    else
    {
        // remember the sample for more data.
        if (m_pPendingSample == NULL)
        {
            m_pPendingSample = pSample;
            m_pPendingSample->AddRef();
        }

        // The pending sample should always been the last one.
        ASSERT(m_pPendingSample == pSample);
    }

    return hr;
}

HRESULT CDSoundCaptureOutputPin::ProcessOneBuffer(
    IN const BYTE* pbBuffer, 
    IN DWORD dwSize,
    IN IReferenceClock * pClock,
    OUT LONG *plGainAdjustment
    )
/*++

Routine Description:

    This method is called by the capture filter to process a buffer captured
    by the device. It calls the encoder handler to encode the buffer. Then it
    calls DeliverBuffer to deliver it.

Arguments:

    pbBuffer - the buffer that contains the samples.

    dwSize - the size of the buffer, in bytes.

    pClock - the external clock to read the timestamp from.

    plGainAdjustment - gain adjustment in percentage.
Return Value:

    S_OK - success.
    S_FALSE - not connected.

    E_UNEXPECTED - incomplete sample..

--*/
{
    ENTER_FUNCTION("CDSoundCaptureOutputPin::ProcessOneBuffer");

    // lock the pin just in case it got disconnected.
    CAutoLock Lock(m_pLock);
    
    if (!IsConnected())
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, the pin is not connected"), __fxName));
        return S_FALSE;
    }
    
    if (dwSize < m_dwBufferSize)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, Incomplete sample, dwSize:%d"), __fxName, dwSize));
        return E_UNEXPECTED;
    }

    HRESULT hr;
    IMediaSample *pSample = NULL;
    DWORD dwDestBufferSize = 0;
    BYTE *pDestBuffer = NULL;
    DWORD dwUsedSize = 0;

    // update the timestamps based on the samples captured.
    m_SampleTime += m_lDurationPerBuffer;

    if (m_pPendingSample == NULL)
    {
        hr = GetDeliveryBuffer(&pSample, NULL, NULL, AM_GBF_NOWAIT);
        if (FAILED(hr))
        {
            // This means the down stream filter is very slow in returning the 
            // samples. It should happen very rarely.
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, can't get a buffer to deliver samples, hr=%x"), 
                __fxName, hr));
            return hr;
        }

        // get the data buffer from the sample.
        dwDestBufferSize = (DWORD)pSample->GetSize();
        hr = pSample->GetPointer(&pDestBuffer);
        ASSERT(hr == S_OK);

        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, can't get the buffer in the destination sample, hr=%x"), 
                __fxName, hr));
            return hr;
        }
    }
    else
    {
        pSample = m_pPendingSample;
        pSample->AddRef();

        dwDestBufferSize = (DWORD)pSample->GetSize();
        hr = pSample->GetPointer(&pDestBuffer);

        // find out how much has been filled.
        dwUsedSize = pSample->GetActualDataLength();

        ASSERT(dwDestBufferSize >= dwUsedSize);

        // adjust the pointer and size.
        dwDestBufferSize -= dwUsedSize;
        pDestBuffer += dwUsedSize;
    }

    DWORD dwStatus = 0;

#ifdef PERF
    LARGE_INTEGER liTicks;
    LARGE_INTEGER liTicks1;
    QueryPerformanceCounter(&liTicks);
#endif

    hr = PrepareToDeliver(
        pbBuffer,           // source buffer
        dwSize,             // the length of source buffer
        pDestBuffer,        // the destination buffer
        &dwDestBufferSize,  // the size of the destination buffer.
        &dwStatus,          // the result of the transform
        plGainAdjustment    // gain adjustment
        );

#ifdef PERF
    QueryPerformanceCounter(&liTicks1);
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s, encode time:%dns"), __fxName, ClockDiff(liTicks1, liTicks)));
#endif

    if (FAILED(hr))
    {
        pSample->Release();

        if (m_pPendingSample != NULL)
        {
            m_pPendingSample->Release();
            m_pPendingSample = NULL;
        }

        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, TransForm failed, hr=%x"), __fxName, hr));
        return hr;
    }

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s, dwStatus:%x, GainAdjustment:%d"),
        __fxName,
        dwStatus,
        *plGainAdjustment
        ));

    if (dwUsedSize + dwDestBufferSize != 0)
    {
        // set the data length.
        hr = pSample->SetActualDataLength(dwUsedSize + dwDestBufferSize);
        ASSERT(SUCCEEDED(hr));

#ifdef PERF
        QueryPerformanceCounter(&liTicks);
#endif
        hr = DeliverSample(pSample, dwStatus, pClock);

#ifdef PERF
        QueryPerformanceCounter(&liTicks1);
        DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
                TEXT("%s, deliver time:%dns"), __fxName, ClockDiff(liTicks1, liTicks)));
#endif

        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, DeliverSample failed, hr=%x"), __fxName, hr));
        }
    }

    // we don't need the sample refrence any more
    pSample->Release();

    // TODO: Adjust the gain.
    return hr;
}

HRESULT CDSoundCaptureOutputPin::PrepareToDeliver(
    IN  const BYTE   *pSourceBuffer,
    IN      DWORD   dwSourceDataSize,
    IN      BYTE   *pDestBuffer,
    IN OUT  DWORD  *pdwDestBufferSize,
    OUT     DWORD  *pdwStatus,
    OUT     LONG   *plGainAdjustment
    )
{
    // this function is on the critical path, we trust the caller to pass in
    // valid pointers.
    ASSERT(!IsBadReadPtr(pSourceBuffer, dwSourceDataSize));
    ASSERT(!IsBadWritePtr(pdwDestBufferSize, sizeof(LONG)));
    ASSERT(!IsBadWritePtr(pDestBuffer, *pdwDestBufferSize));
    ASSERT(!IsBadWritePtr(pdwStatus, sizeof(DWORD)));
    ASSERT(!IsBadWritePtr(plGainAdjustment, sizeof(LONG)));

    HRESULT hr = S_OK;
    
#if DBG
    if (m_fAutomaticGainControl && m_GainFactor != 1.0)
    {
        for (DWORD dw = 0; dw < dwSourceDataSize / sizeof(WORD); dw ++)
        {
            ((SHORT*)pSourceBuffer)[dw] = 
                (SHORT)(((SHORT*)pSourceBuffer)[dw] * m_GainFactor);
        }
    }
#endif
	// do silence detection and AGC.
    hr = PreProcessing(
        pSourceBuffer, dwSourceDataSize, pdwStatus, plGainAdjustment
        );

    if (FAILED(hr))
    {
        return hr;
    }

    if (m_fSilenceSuppression  && IsSilence(*pdwStatus))
    {
        // if silence suppression is enabled and the data is silence, 
        // no further processing is needed.
        return hr;
    }

#if DBG
    if (m_fAutomaticGainControl && *plGainAdjustment != 0)
    {
        m_GainFactor = m_GainFactor * (100 + (*plGainAdjustment)) / 100;
    }
#endif
    if (dwSourceDataSize > *pdwDestBufferSize)
    {
        return VFW_E_BUFFER_OVERFLOW;
    }

    CopyMemory(pDestBuffer, pSourceBuffer, dwSourceDataSize);

    *pdwDestBufferSize = dwSourceDataSize;

    return hr;
}

LONG CDSoundCaptureOutputPin::GainAdjustment()
{
    LONG lAdjustment = 0;
    if (m_dwShortTermSoundAverage > SOUNDCEILING)
    {
        // the sound is too loud.
        lAdjustment = 
            -(LONG)((m_dwShortTermSoundAverage - SOUNDCEILING) 
                * 100 /  m_dwShortTermSoundAverage);
    }
    else if (m_dwLongTermSoundAverage < SOUNDFLOOR * 90 / 100)
    {
        // the sound is too low.
        if (-- m_dwGainIncreaseDelay == 0)
        {
            if (m_dwLongTermSoundAverage == 0) m_dwLongTermSoundAverage = 100;

            lAdjustment = (SOUNDFLOOR - m_dwLongTermSoundAverage) * GAININCREMENT 
                / m_dwLongTermSoundAverage;

            m_dwGainIncreaseDelay = GAININCREASEDELAY;
        }
    }
    return lAdjustment;
}

HRESULT CDSoundCaptureOutputPin::PreProcessing(
    IN  const BYTE   *pSourceBuffer,
    IN      DWORD   dwSourceDataSize,
    OUT     DWORD  *pdwStatus,
    OUT     LONG   *plGainAdjustment
    )
{
    DWORD dwPeak, dwClipPercent;

    Statistics(pSourceBuffer, dwSourceDataSize, &dwPeak, &dwClipPercent);

    if (m_fSilenceSuppression)
    {
        *pdwStatus = Classify(dwPeak);
    }
    else
    {
        *pdwStatus = TR_STATUS_TALK;
    }

    if ((*pdwStatus) & TR_STATUS_TALK)
    {
        *plGainAdjustment = GainAdjustment();
    }
    else
    {
        *plGainAdjustment = 0;
        m_dwGainIncreaseDelay = GAININCREASEDELAY;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\filter\dsc.h ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    tpdsin.h

Abstract:

    This file contains the definitions of CDSoundCapture that handles capturing
    using directsound.

Author:

    Mu Han (muhan) 8-10-1999

--*/

#ifndef __TPDSIN_H__
#define __TPDSIN_H__

class CDSoundCapture : public CCaptureDevice
{
public:
    CDSoundCapture(
        IN  GUID *pDSoundGuid, 
        IN  HANDLE hEvent,
        IN  IAMAudioDuplexController *pIAudioDuplexController,
        OUT HRESULT *phr
        );

    ~CDSoundCapture();

    HRESULT ConfigureFormat(
        IN const WAVEFORMATEX *pWaveFormtEx,
        IN DWORD dwFrameSize
        );

    HRESULT ConfigureAEC(
        IN BOOL fEnable
        );

    HRESULT Open();
    HRESULT Close();

    HRESULT Start();
    HRESULT Stop();

    HRESULT LockFirstFrame(
        OUT PBYTE *ppByte, 
        OUT DWORD* pdwSize
        );

    HRESULT UnlockFirstFrame(
        IN BYTE *pByte, 
        IN DWORD dwSize
        );

private:
    CRITICAL_SECTION    m_CritSec;
    BOOL                m_fCritSecValid;
    
    GUID *              m_pDSoundGuid;
    
    IAMAudioDuplexController  *  m_pIAudioDuplexController;
    LPDIRECTSOUNDCAPTURE       m_pDirectSound;
    LPDIRECTSOUNDCAPTUREBUFFER m_pCaptureBuffer;

    HANDLE              m_hEvent;

    WAVEFORMATEX        m_WaveFormatEx;
    DWORD               m_dwFrameSize;
    BOOL                m_fRunning;
    DWORD               m_dwReadPosition;
};

#endif // __TPDSIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\filter\dscinpin.cpp ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    dscinpin.cpp

Abstract:

    This file implements the input pin object of the DSound audio capture filter.

--*/

#include "stdafx.h"
#include "dscfiltr.h"

CDSoundCaptureInputPin::CDSoundCaptureInputPin(
    CDSoundCaptureFilter *     pFilter,
    CCritSec *      pLock,
    HRESULT *       phr
    ) :
    CBasePin(
        NAME("CDSoundCaptureInputPin"),
        pFilter,                   // Filter
        pLock,                     // Locking
        phr,                       // Return code
        L"Input",                  // Pin name
        PINDIR_INPUT               // Pin direction 
        )              
{
    return;
}

CDSoundCaptureInputPin::~CDSoundCaptureInputPin()
{
}

HRESULT 
CDSoundCaptureInputPin::CheckMediaType(const CMediaType *)
{
    return S_OK;
}

STDMETHODIMP 
CDSoundCaptureInputPin::ReceiveCanBlock()
{
    return S_FALSE;
}

// BeginFlush shouldn't be called on our input pins
STDMETHODIMP
CDSoundCaptureInputPin::BeginFlush(void)
{
    return E_UNEXPECTED;
}

// EndFlush shouldn't be called on our input pins
STDMETHODIMP
CDSoundCaptureInputPin::EndFlush(void)
{
    return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\filter\dscenum.cpp ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    devenum.cpp

Abstract:

    This file implements device enumeration of the audio capture filter

Author:

--*/

#include "stdafx.h"
#include <dsound.h>

#ifdef USE_DEVENUM

HRESULT ReadDeviceInfo(
    IN  IMoniker *      pMoniker,
    IN  AudioDeviceInfo * pDeviceInfo
    )
/*++

Routine Description:

    This method reads the device infomation from the Moniker.

Arguments:

    pMoniker - a moniker to a audio capture filter.

    pDeviceInfo - a pointer to a AudioDeviceInfo structure.

Return Value:

    S_OK
    E_POINTER
--*/
{
    ENTER_FUNCTION("ReadDeviceInfo");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s entered"), __fxName));

    HRESULT hr;

    // Bind the moniker to storage as a property bag.
    IPropertyBag* pBag;
    hr = pMoniker->BindToStorage(0, 0, __uuidof(IPropertyBag), (void **)&pBag);
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL
            TEXT("%s, IMoniker::BindToStorage failed. hr=%x"), __fxName, hr));
        return hr;
    }

    //
    // Get the name for this device out of the property bag.
    // Skip this terminal if it doesn't have a name.
    //

    VARIANT DeviceName;
    DeviceName.vt = VT_BSTR;
    hr = pBag->Read(L"FriendlyName", &DeviceName, 0);

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, failed to read friendly name. hr=%x"), __fxName, hr));

        pBag->Release();

        return hr;
    }

    lstrcpynW(pDeviceInfo->szDeviceDescription, DeviceName.bstrVal, MAX_PATH-1);

    VariantClear(&DeviceName);

    //
    // Get the wave ID from the property bag.
    // Skip this terminal if it doesn't have a wave ID.
    //

    VARIANT var;
    var.vt = VT_I4;
    hr = pBag->Read(L"WaveInId", &var, 0);

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, failed to read Wave ID. hr=%x"), __fxName, hr));

        pBag->Release();

        return hr;
    }

    // don't need the property bag any more.
    pBag->Release();

    pDeviceInfo->WaveID = var.lVal;

    return S_OK;
}

#endif

// this function is borrowed from the DShow devenum code.
void GetPreferredDeviceName(
    IN TCHAR *  szNamePreferredDevice,
    IN const    TCHAR *szVal,
    IN BOOL     bOutput
    )
{
    // first try to use the new DRVM_MAPPER_PREFERRED_GET message to get the preferred
    // device id. note that this message was added in nt5 and so is not guaranteed to
    // be supported on all os's.
    DWORD dw1, dw2;

    MMRESULT mmr;
    if (bOutput) {
        mmr = waveOutMessage( (HWAVEOUT) IntToPtr(WAVE_MAPPER)   // assume waveIn will translate WAVE_MAPPER?
                           , DRVM_MAPPER_PREFERRED_GET
                           , (DWORD_PTR) &dw1
                           , (DWORD_PTR) &dw2 );
    } else {
        mmr = waveInMessage( (HWAVEIN) IntToPtr(WAVE_MAPPER)   // assume waveIn will translate WAVE_MAPPER?
                           , DRVM_MAPPER_PREFERRED_GET
                           , (DWORD_PTR) &dw1
                           , (DWORD_PTR) &dw2 );
    }
    if( MMSYSERR_NOERROR == mmr )
    {
        UINT uiPrefDevId = (UINT)dw1;
        TCHAR *szPname;
        if (bOutput) {
            WAVEOUTCAPS woCaps;
            szPname = woCaps.szPname;
            mmr = waveOutGetDevCaps( uiPrefDevId
                                  , &woCaps
                                  , sizeof( woCaps ) );
        } else {
            WAVEINCAPS wiCaps;
            szPname = wiCaps.szPname;
            mmr = waveInGetDevCaps( uiPrefDevId
                                  , &wiCaps
                                  , sizeof( wiCaps ) );
        }
        if( ( MMSYSERR_NOERROR == mmr ) && ( ( (UINT)-1 ) != uiPrefDevId ) )
        {
            lstrcpy( szNamePreferredDevice, szPname );
        }
        else
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL
                  , TEXT("devenum: Failed to get preferred dev (%s for dev id %ld returned %ld)")
                  , bOutput ? TEXT("waveOutGetDevCaps") :
                              TEXT("waveInGetDevCaps")
                  , uiPrefDevId
                  , mmr ) );
            szNamePreferredDevice[0] = '\0';
        }
    }
    else
    {
        // revert back to reading the registry to get the preferred device name
        DbgLog((LOG_TRACE,TRACE_LEVEL_WARNING
              , TEXT("devenum: waveInMessage doesn't support DRVM_MAPPER_PREFERRED_GET (err = %ld). Reading registry instead...")
              , mmr ) );

        HKEY hkSoundMapper;
        LONG lResult = RegOpenKeyEx(
            HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\Multimedia\\Sound Mapper"),
            0,                      // reserved
            KEY_READ,
            &hkSoundMapper);
        if(lResult == ERROR_SUCCESS)
        {
            DWORD dwType, dwcb = MAX_PATH * sizeof(TCHAR);
            lResult = RegQueryValueEx(
                hkSoundMapper,
                szVal,
                0,                  // reserved
                &dwType,
                (BYTE *)szNamePreferredDevice,
                &dwcb);

            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_SZ : TRUE);
            EXECUTE_ASSERT(RegCloseKey(hkSoundMapper) == ERROR_SUCCESS);
        }

        if(lResult != ERROR_SUCCESS) {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("devenum: couldn't get preferred %s device from registry"),
                    szVal));
            szNamePreferredDevice[0] = '\0';
        }
    }
}


typedef struct tagDSEnumContext
{
    DWORD dwNumDevices;
    AudioDeviceInfo * pDeviceInfo;

} DSEnumContext;

BOOL CALLBACK DSEnumCallback(
    LPGUID lpGuid,
    LPCTSTR lpcstrDescription,
    LPCTSTR lpcstrModule,
    LPVOID lpContext
    )
{
    ENTER_FUNCTION("DSEnumCallback");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s enters, name:%hs"), __fxName, lpcstrDescription));

    // get the context of the enumeration.
    DSEnumContext *pContext = (DSEnumContext *)lpContext;
    ASSERT(!IsBadReadPtr(pContext, sizeof(DSEnumContext)));

    DWORD dwNumDevices = pContext->dwNumDevices;
    AudioDeviceInfo * pDeviceInfo = pContext->pDeviceInfo;
    ASSERT(!IsBadWritePtr(pDeviceInfo, sizeof(AudioDeviceInfo) * dwNumDevices));

#ifdef UNICODE
    const WCHAR * const Buffer = lpcstrDescription;
#else
    WCHAR Buffer[MAX_PATH];
    MultiByteToWideChar(
              GetACP(),
              0,
              lpcstrDescription,
              lstrlenA(lpcstrDescription)+1,
              Buffer,
              MAX_PATH
              );
#endif

    // find the device in our list.
    for (DWORD dw = 0; dw < dwNumDevices; dw ++)
    {
        if (wcsncmp(pDeviceInfo[dw].szDeviceDescription,
                    Buffer,
                    lstrlen(pDeviceInfo[dw].szDeviceDescription)) == 0)
        {
            pDeviceInfo[dw].DSoundGUID = *lpGuid;
            break;
        }
    }

    return(TRUE);
}

HRESULT EnumerateWaveinCapture(
    OUT DWORD * pdwNumDevices,
    OUT AudioDeviceInfo ** ppDeviceInfo
    )
/*++

Routine Description:

    This method enumeratesall the wavein capture devices.

Arguments:

    pdwNumDevices -
        The number of devices enumerated.

    ppDeviceInfo -
        The array of device info items. The caller should call
        AudioReleaseDeviceInfo to release it.

Return Value:

    S_OK    - success.
    E_FAIL
    E_OUTOFMEMORY
--*/
{
    ENTER_FUNCTION("EnumerateWaveinCapture");

    *pdwNumDevices = 0;
    *ppDeviceInfo = NULL;

    // find the numbef of wavein devices.
    UINT cNumDevices = waveInGetNumDevs();

    if (cNumDevices == 0)
    {
        return S_FALSE;
    }

    // allocate the memory for the device information.
    AudioDeviceInfo *pDeviceInfo =
        (AudioDeviceInfo *) malloc(sizeof(AudioDeviceInfo) * cNumDevices);

    if (pDeviceInfo == NULL)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s out of memory, array size:%d"), __fxName, cNumDevices));
        return E_OUTOFMEMORY;
    }

    ZeroMemory(pDeviceInfo, sizeof(AudioDeviceInfo) * cNumDevices);
        
    // get the default device.
    TCHAR szNamePreferredDevice[MAX_PATH];
    GetPreferredDeviceName(szNamePreferredDevice, TEXT("Record"), FALSE);

    for (UINT i = 0; i < cNumDevices; i ++)
    {
        WAVEINCAPS wiCaps;

        if(waveInGetDevCaps(i, &wiCaps, sizeof(wiCaps)) != MMSYSERR_NOERROR)
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("waveInGetDevCaps failed")));
            break;
        }

        if(lstrcmp(wiCaps.szPname, szNamePreferredDevice) == 0)
        {
            // if this the preferred device, put it in the first slot in
            // the array.
            if (i == 0)
            {
                // this is the first slot, just copy.
                lstrcpyW(pDeviceInfo[i].szDeviceDescription, wiCaps.szPname);
                pDeviceInfo[i].WaveID = i;
            }
            else
            {
                // copy the device in the first slot to this slot.
                lstrcpyW(
                    pDeviceInfo[i].szDeviceDescription,
                    pDeviceInfo[0].szDeviceDescription
                    );
                pDeviceInfo[i].WaveID = pDeviceInfo[0].WaveID;

                // copy the info into the first slot.
                lstrcpyW(pDeviceInfo[0].szDeviceDescription, wiCaps.szPname);
                pDeviceInfo[0].WaveID = i;

            }
        }
        else
        {
            // This is not the preferred device. just copy.
            lstrcpyW(pDeviceInfo[i].szDeviceDescription, wiCaps.szPname);
            pDeviceInfo[i].WaveID = i;
        }
    }

    if (i == 0)
    {
        free(pDeviceInfo);
        return S_FALSE;
    }

    *pdwNumDevices = i;
    *ppDeviceInfo = pDeviceInfo;

    return S_OK;
}

HRESULT EnumerateDSoundDevices(
    IN DWORD dwNumDevices,
    IN AudioDeviceInfo * pDeviceInfo
    )
/*++

Routine Description:

    This method enumerates all the dsound capture devices and matchs them with
    the wave devices with the same name.

Arguments:

    dwNumDevices -
        The number of devices.

    pDeviceInfo -
        The array of device info items.

Return Value:

    S_OK    - success.
    E_FAIL
    E_OUTOFMEMORY
--*/
{
    ENTER_FUNCTION("EnumerateDSoundDevices");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s enters"), __fxName));

    DSEnumContext Context;
    Context.dwNumDevices = dwNumDevices;
    Context.pDeviceInfo = pDeviceInfo;

    HRESULT hr = DirectSoundCaptureEnumerate(DSEnumCallback, &Context);

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s DSound Enum failed. hr=:%x"), __fxName, hr));
    }

    return hr;
}

AUDIOAPI AudioGetCaptureDeviceInfo(
    OUT DWORD * pdwNumDevices,
    OUT AudioDeviceInfo ** ppDeviceInfo
    )
/*++

Routine Description:

    This function enumerates the audio capture devices and return their info
    in an array.

Arguments:

    pdwNumDevices -
        The number of devices enumerated.

    ppDeviceInfo -
        The array of device info items. The caller should call
        AudioReleaseDeviceInfo to release it.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    ENTER_FUNCTION("AudioGetCaptureDeviceInfo");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s enters"), __fxName));

    if (pdwNumDevices == NULL || ppDeviceInfo == NULL)
    {
        return E_INVALIDARG;
    }

    ASSERT(!IsBadWritePtr(pdwNumDevices, sizeof(DWORD *)));
    ASSERT(!IsBadWritePtr(ppDeviceInfo, sizeof(AudioDeviceInfo *)));

    DWORD dwNumDevices = 0;
    AudioDeviceInfo * pDeviceInfo = NULL;

    HRESULT hr = EnumerateWaveinCapture(&dwNumDevices, &pDeviceInfo);
    if (FAILED(hr))
    {
        return hr;
    }

    if (dwNumDevices != 0)
    {
        hr = EnumerateDSoundDevices(dwNumDevices, pDeviceInfo);
    }

    *pdwNumDevices = dwNumDevices;
    *ppDeviceInfo = pDeviceInfo;

    return hr;
}


AUDIOAPI AudioReleaseCaptureDeviceInfo(
    IN AudioDeviceInfo * pDeviceInfo
    )
{
    if (pDeviceInfo != NULL)
    {
        free(pDeviceInfo);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\filter\dsc.cpp ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    tpdsin.cpp

Abstract:

    This file contains the implementation of Dsound caputer used by the 
    TAPI Audio Capture Filter.

Author:

    Mu Han (muhan) 8-10-1999

--*/

#include "stdafx.h"
#include <initguid.h>
#include <dsound.h>
#include "dsc.h"

CDSoundCapture::CDSoundCapture(
    IN  GUID *pDSoundGuid, 
    IN  HANDLE hEvent,
    IN  IAMAudioDuplexController *pIAudioDuplexController,
    OUT HRESULT *phr
    ) : 
    m_pDSoundGuid(pDSoundGuid),
    m_hEvent(hEvent),
    m_dwFrameSize(0),
    m_dwReadPosition(0),
    m_fRunning(FALSE),
    m_pCaptureBuffer(NULL),
    m_pDirectSound(NULL)
{
    ENTER_FUNCTION("CDSoundCapture::CDSoundCapture");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s"), __fxName));

    ASSERT(!IsBadWritePtr(phr, sizeof (HRESULT)));

    m_fCritSecValid = TRUE;
    __try 
    {
        InitializeCriticalSection(&m_CritSec);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        m_fCritSecValid = FALSE;
    }
   
    if (!m_fCritSecValid)
    {
        *phr =  E_OUTOFMEMORY;

        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, InitialzeCriticalSection failed. err=0x%x"), 
            __fxName, GetLastError()));
        return;
    }

    if (pIAudioDuplexController)
    {
        pIAudioDuplexController->AddRef();
        m_pIAudioDuplexController = pIAudioDuplexController;
    }
    else
    {
        m_pIAudioDuplexController = NULL;
    }

    ZeroMemory(&m_WaveFormatEx, sizeof(m_WaveFormatEx));
    m_WaveFormatEx.cbSize = sizeof(m_WaveFormatEx);

    *phr = S_OK;

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s exits ok"), __fxName));
}

CDSoundCapture::~CDSoundCapture()
{
    ENTER_FUNCTION("CDSoundCapture::~CDSoundCapture");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS, TEXT("%s enters, this=%p"), __fxName, this));

    // close the device if it hasn't been closed.
    Close();

    if (m_pDirectSound)
    {
        m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }

    if (m_pIAudioDuplexController)
    {
        m_pIAudioDuplexController->ReleaseCaptureDevice();
        m_pIAudioDuplexController->Release();
        m_pIAudioDuplexController = NULL;
    }

    if (m_fCritSecValid)
    {
        DeleteCriticalSection(&m_CritSec);
    }
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s exits ok"), __fxName));
}

HRESULT CDSoundCapture::ConfigureFormat(
    IN const WAVEFORMATEX *pWaveFormatEx,
    IN DWORD dwFrameSize
    )
/*++

Routine Description:

    This function is called by the filter to configure the capture device. It
    is called when a new format is set. The method verifies that the format can
    be supported by the devices and reset the device with the new format. The 
    device might be closed and reopened to use the new setting.

Arguments:

    pWaveFormatEx - the new capture format.

    dwFrameSize - the size of each frame for capture.

Return Value:

    S_OK
    E_FAIL - the format can't be supported.
    E_UNEXPECTED - the device failed.
    E_OUTOFMEMORY - no memory for the buffers.
--*/
{
    ENTER_FUNCTION("CDSoundCapture::Configure");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s enters"), __fxName));

    ASSERT(dwFrameSize > 0);

    EnterCriticalSection(&m_CritSec);

    BOOL fFormatChange = 
        (memcmp(&m_WaveFormatEx, pWaveFormatEx, sizeof(WAVEFORMATEX)) != 0);

    BOOL fSizeChange = (m_dwFrameSize != dwFrameSize);

    // no action required if everything stay the same.
    if (!fFormatChange && !fSizeChange)
    {
        LeaveCriticalSection(&m_CritSec);

        DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s exits ok"), __fxName));
        return S_OK;
    }

    HRESULT hr;

    // we are going to change the device settings, stop it if it is running.
    BOOL fNeedsRestart = m_fRunning;
    if (m_fRunning)
    {
        hr = Stop();
        if (FAILED(hr))
        {
            // we can't stop the device.
            LeaveCriticalSection(&m_CritSec);
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, stop device failed, hr=%x"), __fxName, hr));

            return E_UNEXPECTED;
        }
    }

    BOOL fNeedsReopen = FALSE;

    if (m_pCaptureBuffer)
    {
        // The devices has been opened. Decide what needs to be done based on
        // the changes needed.

        if (fFormatChange || fSizeChange)
        {
            hr = Close();
            if (FAILED(hr))
            {
                LeaveCriticalSection(&m_CritSec);
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, close device failed, hr=%x"), __fxName, hr));
                return E_UNEXPECTED;
            }

            // remember we need to reopen the device 
            fNeedsReopen = TRUE;
        }
    }

    // if there is a change of size, we need to reset the notification points.
    if (fSizeChange)
    {
        m_dwFrameSize = dwFrameSize;
    }

    // copy the new format if there is a format change.
    if (fFormatChange)
    {
        m_WaveFormatEx = *pWaveFormatEx;
        m_WaveFormatEx.cbSize = sizeof(m_WaveFormatEx);
    }

    if (m_pIAudioDuplexController)
    {
        // tell the AEC creation object about the change.

        DSCBUFFERDESC dsbd;
        memset( &dsbd, 0, sizeof(dsbd) );
        dsbd.dwSize  = sizeof(dsbd);
        dsbd.dwBufferBytes = NUM_CAPTURE_FRAMES * m_dwFrameSize; 
        dsbd.lpwfxFormat   = &m_WaveFormatEx;                      

        ASSERT(m_pIAudioDuplexController);
        hr = m_pIAudioDuplexController->SetCaptureBufferInfo (
                m_pDSoundGuid, 
                &dsbd
                );

        if (FAILED(hr))
        {
            // we recreate the buffer
            LeaveCriticalSection(&m_CritSec);
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, stop SetCaptureBufferInfo failed, hr=%x"), __fxName, hr));

            return E_UNEXPECTED;
        }
    }

    // reopen the device if it was closed in this function.
    if (fNeedsReopen)
    {
        // reopen the device.
        hr = Open();
        if (FAILED(hr))
        {
            LeaveCriticalSection(&m_CritSec);
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, open device failed. hr=%x"), __fxName, hr));
            return hr;
        }
    }

    // restart the device if it was stopped in this function.
    if (fNeedsRestart)
    {
        hr = Start();
        if (FAILED(hr))
        {
            LeaveCriticalSection(&m_CritSec);
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, start device failed. hr=%x"), __fxName, hr));
            return hr;
        }
    }

    LeaveCriticalSection(&m_CritSec);
    return S_OK;
}

HRESULT CDSoundCapture::ConfigureAEC(
    IN BOOL fEnable
    )
/*++

Routine Description:

    Configure the AEC status.

Arguments:

    fEnable - Enable or disable AEC.

Return Value:

    S_OK.
    HRESULT - a MMSYSERR converted to HRESULT.

--*/
{
    HRESULT hr = E_FAIL;

    EnterCriticalSection(&m_CritSec);
    if (m_pIAudioDuplexController)
    {
        EFFECTS Effect = EFFECTS_AEC;
        hr = m_pIAudioDuplexController->EnableEffects(1, &Effect, &fEnable);
    }
    LeaveCriticalSection(&m_CritSec);

    return hr;
}

HRESULT CDSoundCapture::Open()
/*++

Routine Description:

    Open the DirectSound device.

Arguments:


Return Value:

    S_OK.
    HRESULT - a MMSYSERR converted to HRESULT.

--*/
{
    ENTER_FUNCTION("CDSoundCapture::Open");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s enters"), __fxName));
    
    DWORD dw;
    HRESULT hr;

    EnterCriticalSection(&m_CritSec);
    
    // if the device has been opened, just return.
    if (m_pCaptureBuffer)
    {
        LeaveCriticalSection(&m_CritSec);
        return S_OK;
    }

    if (m_pIAudioDuplexController)
    {
        // Use the duplex controller to create the device.
        hr = m_pIAudioDuplexController->GetCaptureDevice(
            &m_pDirectSound, 
            &m_pCaptureBuffer
            );

        if( hr != DS_OK )
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, GetCaptureDevice failed, hr=%x"), __fxName, hr));

            goto exit;
        }

        // we don't need this object.
        m_pDirectSound->Release();
        m_pDirectSound = NULL;
    }
    else
    {
        // create the dsound objects the old way.
        if (!m_pDirectSound)
        {
            // create the dsound object if we haven't created it.
            hr = DirectSoundCaptureCreate(
                m_pDSoundGuid,
                &m_pDirectSound,
                NULL
                );

            if( hr != DS_OK )
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, DirectSoundCreate failed, hr=%x"), __fxName, hr));

                goto exit;
            }
        }
        
        DSCBUFFERDESC dsbd;
        memset( &dsbd, 0, sizeof(dsbd) );
        dsbd.dwSize  = sizeof(dsbd);
        dsbd.dwBufferBytes = NUM_CAPTURE_FRAMES * m_dwFrameSize; 
        dsbd.lpwfxFormat   = &m_WaveFormatEx;                      

        DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s, Dsound buffer size=%d"), __fxName, dsbd.dwBufferBytes));

        // Create the capture buffer.
        hr = m_pDirectSound->CreateCaptureBuffer(&dsbd, &m_pCaptureBuffer, NULL);

        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, create capture buffer failed. hr=%x"), __fxName, hr));

            goto exit;
        }
    }

    // get the IDirectSoundNotify interface.
    IDirectSoundNotify *pIDirectSoundNotify;
    hr = m_pCaptureBuffer->QueryInterface(
        IID_IDirectSoundNotify, (void **)&pIDirectSoundNotify);
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, Query IDirectSoundNotify failed. hr=%x"), __fxName, hr));

        goto exit;
    }

    // set up the notification positions.
    DSBPOSITIONNOTIFY NotifyPosition[NUM_CAPTURE_FRAMES];
    for (dw = 0; dw < NUM_CAPTURE_FRAMES; dw ++)
    {
        // notify me when the read pointer reaches the last byte of each frame.
        NotifyPosition[dw].dwOffset = (dw + 1) * m_dwFrameSize - 1;
        NotifyPosition[dw].hEventNotify = m_hEvent;
    }

    hr = pIDirectSoundNotify->SetNotificationPositions(
        NUM_CAPTURE_FRAMES, NotifyPosition
        );

    pIDirectSoundNotify->Release();

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, create capture buffer failed. hr=%x"), __fxName, hr));
    }
    else
    {
        m_dwReadPosition = 0;
    }

exit:
    if (FAILED(hr))
    {
        if (m_pCaptureBuffer)
        {
            m_pCaptureBuffer->Release();
            m_pCaptureBuffer = NULL;
        }
    }

    LeaveCriticalSection(&m_CritSec);

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s returns hr=%x"), __fxName, hr));
    return hr;
}

HRESULT CDSoundCapture::Close()
/*++

Routine Description:

    Close the DirectSound device.

Arguments:


Return Value:

    S_OK.
    HRESULT - a MMSYSERR converted to HRESULT.

--*/
{
    ENTER_FUNCTION("CDSoundCapture::Close");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s enters"), __fxName));

    EnterCriticalSection(&m_CritSec);

    if (m_pCaptureBuffer)
    {
        m_pCaptureBuffer->Release();
        m_pCaptureBuffer = NULL;
    }

    LeaveCriticalSection(&m_CritSec);

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s returns S_OK"), __fxName));

    return S_OK;
}

void LogWaveFormat(
    IN DWORD dwLevel,
    IN const WAVEFORMATEX *pFormat
    )
{
    DbgLog((LOG_TRACE,dwLevel,TEXT("wFormatTag %u"), pFormat->wFormatTag));
    DbgLog((LOG_TRACE,dwLevel,TEXT("nChannels %u"), pFormat->nChannels));
    DbgLog((LOG_TRACE,dwLevel,TEXT("nSamplesPerSec %lu"), pFormat->nSamplesPerSec));
    DbgLog((LOG_TRACE,dwLevel,TEXT("nAvgBytesPerSec %lu"), pFormat->nAvgBytesPerSec));
    DbgLog((LOG_TRACE,dwLevel,TEXT("nBlockAlign %u"), pFormat->nBlockAlign));
    DbgLog((LOG_TRACE,dwLevel,TEXT("wBitsPerSample %u"), pFormat->wBitsPerSample));
    DbgLog((LOG_TRACE,dwLevel,TEXT("cbSize %u"), pFormat->cbSize));
}

HRESULT CDSoundCapture::Start()
/*++

Routine Description:

    Start the DirectSound device.

Arguments:


Return Value:

    S_OK.
    HRESULT - a MMSYSERR converted to HRESULT.

--*/
{
    ENTER_FUNCTION("CDSoundCapture::Start");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s enters"), __fxName));

    HRESULT hr = E_UNEXPECTED;

    EnterCriticalSection(&m_CritSec);

    if (m_pCaptureBuffer == NULL)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, m_pCaptureBuffer is NULL"), __fxName));
    }
    else
    {
        hr = m_pCaptureBuffer->Start(DSCBSTART_LOOPING);

        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, start failed. hr=%x"), __fxName, hr));
        }
        else
        {
            m_fRunning = TRUE;

#ifdef DBG
            // get the format on the capture buffer.
            WAVEFORMATEX WaveFormatEx;
            DWORD dwBytesWritten;
            hr = m_pCaptureBuffer->GetFormat(
                &WaveFormatEx, sizeof(WAVEFORMATEX), &dwBytesWritten
                );

            if (FAILED(hr))
            {
                DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, GetFormat failed %d. hr=%x"), __fxName));
            }
            else
            {
                LogWaveFormat(TRACE_LEVEL_DETAILS, &WaveFormatEx);
            }
#endif
        }
    }

    LeaveCriticalSection(&m_CritSec);

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s returns hr=%x"), __fxName, hr));

    return hr;
}

HRESULT CDSoundCapture::Stop()
/*++

Routine Description:

    Stop the DirectSound device.

Arguments:


Return Value:

    S_OK.
    HRESULT - a MMSYSERR converted to HRESULT.

--*/
{
    ENTER_FUNCTION("CDSoundCapture::Stop");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s enters"), __fxName));

    HRESULT hr = E_UNEXPECTED;

    EnterCriticalSection(&m_CritSec);

    if (m_pCaptureBuffer == NULL)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, m_pCaptureBuffer is NULL"), __fxName));
    }
    else
    {
        hr = m_pCaptureBuffer->Stop();

        if (FAILED(hr))
        {
            DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                    TEXT("%s, start failed. hr=%x"), __fxName, hr));
        }
        else
        {
            m_fRunning = FALSE;
        }
    }

    LeaveCriticalSection(&m_CritSec);

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s returns hr=%x"), __fxName, hr));

    return hr;
}

HRESULT CDSoundCapture::LockFirstFrame(
    OUT PBYTE *ppByte, 
    OUT DWORD* pdwSize
    )
/*++

Routine Description:

    Get the pointer to the first finished buffer.

Arguments:

    ppByte - returns the address of the first finished buffer.

    pdwSize - returns the bytes captured in the buffer.

Return Value:

    S_OK.
    S_FALSE - no more buffers.
    E_UNEXPECTED - the device is not active.

--*/
{
    ENTER_FUNCTION("CDSoundCapture::LockFirstFrame");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s enters"), __fxName));

    HRESULT hr = E_UNEXPECTED;

    EnterCriticalSection(&m_CritSec);

    if (m_pCaptureBuffer == NULL)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
                TEXT("%s, m_pCaptureBuffer is NULL"), __fxName));

        LeaveCriticalSection(&m_CritSec);
        return hr;
    }

    DWORD dwCapturePosition;
    DWORD dwReadPosition;

    hr = m_pCaptureBuffer->GetCurrentPosition(
        &dwCapturePosition, &dwReadPosition
        );

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, GetCurrentPosition failed. hr=%x"), __fxName, hr));

        LeaveCriticalSection(&m_CritSec);
        return hr;
    }

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s capure:%d, read:%d"), 
        __fxName, dwCapturePosition, dwReadPosition));

    DWORD dwEndPosition = m_dwReadPosition + m_dwFrameSize;
    dwEndPosition %= (m_dwFrameSize * NUM_CAPTURE_FRAMES);

    if (m_dwReadPosition < dwEndPosition)
    {
        if (m_dwReadPosition <= dwReadPosition && dwReadPosition < dwEndPosition)
        {
            // we can't read from dangerous zone.
            LeaveCriticalSection(&m_CritSec);
            return S_FALSE;
        }
    }
    else
    {
        // the end position has wrapped around but the begin position hasn't
        if (dwReadPosition < dwEndPosition || m_dwReadPosition <= dwReadPosition)
        {
            // we can't read from dangerous zone.
            LeaveCriticalSection(&m_CritSec);
            return S_FALSE;
        }
    }

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s capure:%d, read:%d, my Read begin:%d, end:%d"), 
        __fxName, dwCapturePosition, dwReadPosition, m_dwReadPosition, dwEndPosition));

    BYTE *lpRead;
    DWORD dwLength;

    // lock the buffer for read
    hr = m_pCaptureBuffer->Lock(
        m_dwReadPosition,                      
        m_dwFrameSize, 
        (PVOID *) &lpRead, 
        &dwLength, 
        NULL,
        NULL,
        0
        );

    if (hr != DS_OK)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, lock dsound buffer failed, hr=%x"), __fxName, hr));
    }
    else
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s locked buffer:%p, length:%d"), 
            __fxName, lpRead, dwLength));

        ASSERT(dwLength == m_dwFrameSize);

        // update our position.
        m_dwReadPosition += m_dwFrameSize;
        m_dwReadPosition %= (m_dwFrameSize * NUM_CAPTURE_FRAMES);

        *ppByte = lpRead;
        *pdwSize = m_dwFrameSize;
    }

    LeaveCriticalSection(&m_CritSec);

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s returns hr=%x"), __fxName, hr));
    return hr;
}

HRESULT CDSoundCapture::UnlockFirstFrame(
    IN BYTE *pByte, 
    IN DWORD dwSize
    )
/*++

Routine Description:

    Release the first buffer. The buffer will be given to the device to capture.

Arguments:

    pByte - the pointer to the beginning of the frame.

    dwSize - the size of the frame.

Return Value:

    S_OK.
    E_UNEXPECTED - the device is not active.
    HRESULT - a MMSYSERR converted to HRESULT.

--*/
{
    ENTER_FUNCTION("CDSoundCapture::UnlockFirstFrame");
    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,TEXT("%s enters"), __fxName));

    HRESULT hr = E_UNEXPECTED;

    EnterCriticalSection(&m_CritSec);

    if (m_pCaptureBuffer == NULL)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, m_pCaptureBuffer is NULL"), __fxName));

        LeaveCriticalSection(&m_CritSec);
        return hr;
    }

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
            TEXT("%s unlocking buffer:%p, length:%d"), 
            __fxName, pByte, dwSize));

    hr = m_pCaptureBuffer->Unlock(
        pByte, 
        dwSize, 
        NULL, 
        0
        );

    if (hr != DS_OK)
    {
        DbgLog((LOG_TRACE,TRACE_LEVEL_FAIL,
            TEXT("%s, unlock dsound buffer failed, hr=%x"), __fxName, hr));
    }

    LeaveCriticalSection(&m_CritSec);

    DbgLog((LOG_TRACE,TRACE_LEVEL_DETAILS,
        TEXT("%s returns mmr=%d"), __fxName, hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\filter\dscfiltr.h ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    dscfiltr.h

Abstract:

    This file contains the definitions of the data structures used in the
    DSound Capture Filter.

--*/

#ifndef __DSCFILTR_H__
#define __DSCFILTR_H__

#define AUDIOAPI EXTERN_C __declspec (dllexport) HRESULT WINAPI
//#define AUDIOAPI extern "C" HRESULT WINAPI

AUDIOAPI AudioGetCaptureDeviceInfo(
    OUT DWORD * pdwNumDevices,
    OUT AudioDeviceInfo ** ppDeviceInfo
    );

AUDIOAPI AudioReleaseCaptureDeviceInfo(
    IN AudioDeviceInfo * ppDeviceInfo
    );

#ifdef DEBUG
#define ENTER_FUNCTION(s) const TCHAR __fxName[] = (TEXT(s))
#else
#define ENTER_FUNCTION(s)
#endif

#define TRACE_LEVEL_DETAILS 8
#define TRACE_LEVEL_FAIL    1
#define TRACE_LEVEL_WARNING 3

DWORD CalculateThreshold(
        IN DWORD dwBase,
        IN BYTE bAdjustment
        );

extern const AMOVIESETUP_FILTER sudAudCap;


#define VAD_EVENTBASE (100000)

// events for voice activity detection.
typedef enum VAD_EVENT
{
    VAD_TALKING,
    VAD_SILENCE

} VAD_EVENT;

const DWORD PCM_FRAME_DURATION = 30; // 30ms per frame.
const DWORD PCM_SAMPLES_PER_FRAME = 240;

const WAVEFORMATEX StreamFormatPCM16 =
{
	WAVE_FORMAT_PCM,                // wFormatTag
	1,                              // nChannels
	8000,                           // nSamplesPerSec
	16000,                          // nAvgBytesPerSec
	2,                              // nBlockAlign
	16,                             // wBitsPerSample
	0                               // cbSize
};                                              

const WAVEFORMATEX StreamFormatPCM16_16 =
{
	WAVE_FORMAT_PCM,		// wFormatTag
	1,						// nChannels
	16000,					// nSamplesPerSec
	32000,					// nAvgBytesPerSec
	2,						// nBlockAlign
	16,						// wBitsPerSample
	0						// cbSize
}; 

const AUDIO_STREAM_CONFIG_CAPS StreamCapsPCM16 =
{
     //MEDIATYPE_Audio,
     0x73647561, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 },
	 1,                      // MinimumChannels
	 1,                      // MaximumChannels
	 1,                      // ChannelsGranularity
	 16,                     // MinimumBitsPerSample
	 16,                     // MaximumBitsPerSample
	 1,                      // BitsPerSampleGranularity
	 8000,                   // MinimumSampleFrequency
	 16000,                  // MaximumSampleFrequency
	 8000                    // SampleFrequencyGranularity
};

#if DBG
extern DWORD THRESHODL_INITIAL; 
extern DWORD THRESHODL_MAX; 
extern DWORD THRESHOLD_DELTA; // the distance above the backround average.
extern DWORD SILENCEAVERAGEWINDOW;

// time to adapt the threshold.
extern DWORD THRESHOLD_TIMETOADJUST;   // 30 frames.
extern DWORD THRESHODL_ADJUSTMENT; 

// silence packets played to fill in gaps between words.
extern DWORD FILLINCOUNT;    // 30 frames 

// values for gain adjustments.
extern DWORD SOUNDCEILING;
extern DWORD SHORTTERMSOUNDAVERAGEWINDOW;

extern DWORD SOUNDFLOOR;
extern DWORD LONGTERMSOUNDAVERAGEWINDOW;

extern DWORD GAININCREMENT;  // only rise 10% everytime.
extern DWORD GAININCREASEDELAY;

// this is the threshold to remove the DC from the samples.
extern long DC_THRESHOLD;
extern DWORD SAMPLEAVERAGEWINDOW;

extern DWORD SOFTAGC;

#else

const DWORD THRESHODL_INITIAL = 1146; 
const DWORD THRESHODL_MAX = 20000; 
const DWORD THRESHOLD_DELTA = 12; // the distance above the backround average.
const DWORD SILENCEAVERAGEWINDOW = 16;

// time to adapt the threshold.
const DWORD THRESHOLD_TIMETOADJUST = 30;   // 30 frames.
const DWORD THRESHODL_ADJUSTMENT = 10; 

// silence packets played to fill in gaps between words.
const DWORD FILLINCOUNT = 30;    // 30 frames 

// values for gain adjustments.
const DWORD SOUNDCEILING = 25000;
const DWORD SHORTTERMSOUNDAVERAGEWINDOW = 4;

const DWORD SOUNDFLOOR = 4000;
const DWORD LONGTERMSOUNDAVERAGEWINDOW = 32;

const DWORD GAININCREMENT = 10;  // only rise 10% everytime.
const DWORD GAININCREASEDELAY = 50;

// this is the threshold to remove the DC from the samples.
const long DC_THRESHOLD = 500;
const DWORD SAMPLEAVERAGEWINDOW = 1024;

#endif

const BOOL DEFAULT_AEC_STATUS = FALSE;
const BOOL DEFAULT_AGC_STATUS = TRUE;

const DWORD TR_STATUS_SILENCE       = 0x00000000;
const DWORD TR_STATUS_TALK          = 0x00000001;
const DWORD TR_STATUS_TALKSTART     = 0x00000002;
const DWORD TR_STATUS_TALKEND       = 0x00000004;
const DWORD TR_STATUS_TALKPENDING   = 0x00000008;

// This is number of delivery buffers that the output pin requires the 
// downstream filter to provide.
const long AUDCAPOUTPIN_NUMBUFFERS = 1;

// This is size of delivery buffers that the output pin requires the 
// downstream filter to provide. It is big enough to handle dynamic
// format change without reconned.
const DWORD AUDCAPOUTPIN_BUFFERSIZE = 1024;

// This is the delay between a sample is captured and it is processed.
// It might be hardware dependent. We use a fixed number for now.
const DWORD SAMPLEDELAY = 1;

inline BOOL IsSilence(DWORD dwStatus)   { return (dwStatus == 0); }
inline BOOL IsTalkStart(DWORD dwStatus) { return (dwStatus & TR_STATUS_TALKSTART); }
inline BOOL IsTalkEnd(DWORD dwStatus)   { return (dwStatus & TR_STATUS_TALKEND); }
inline BOOL IsPending(DWORD dwStatus)   { return (dwStatus & TR_STATUS_TALKPENDING); }


class CDSoundCaptureInputPin;
class CDSoundCaptureOutputPin;
class CDSoundCaptureFilter;
class CWaveInCapture;

// The number of capture frames we prepare on the capture device.
const DWORD NUM_CAPTURE_FRAMES = 16;

// this is the interface for a capture device.
class DECLSPEC_NOVTABLE CCaptureDevice 
{
public:
    virtual ~CCaptureDevice() {};

    virtual HRESULT ConfigureFormat(
        IN const WAVEFORMATEX *pWaveFormtEx,
        IN DWORD dwFrameSize
        ) = 0;

    virtual HRESULT ConfigureAEC(
        IN BOOL fEnable
        ) = 0;

    virtual HRESULT Open() = 0;
    virtual HRESULT Close() = 0;

    virtual HRESULT Start() = 0;
    virtual HRESULT Stop() = 0;

    virtual HRESULT LockFirstFrame(
        OUT BYTE** ppByte, 
        OUT DWORD* pdwSize
        ) = 0;

    virtual HRESULT UnlockFirstFrame(
        IN BYTE *pByte, 
        IN DWORD dwSize
        ) = 0;
};


class CDSoundCaptureInputPin : public CBasePin
{
public:

    CDSoundCaptureInputPin(
        CDSoundCaptureFilter *pFilter,
        CCritSec *pLock,
        HRESULT *phr
        );

    ~CDSoundCaptureInputPin();
    
    HRESULT CheckMediaType(const CMediaType *);

    STDMETHODIMP ReceiveCanBlock();
    STDMETHODIMP BeginFlush(void);
    STDMETHODIMP EndFlush(void);
};

class CDSoundCaptureOutputPin : 
    public CBaseOutputPin, 
    public IAMStreamConfig
{
    DWORD            m_dwObjectID;
    
public:
    DECLARE_IUNKNOWN

    CDSoundCaptureOutputPin(
        CDSoundCaptureFilter *pFilter,
        CCritSec *pLock,
        HRESULT *phr
        );
    ~CDSoundCaptureOutputPin();

    STDMETHOD (NonDelegatingQueryInterface) (
        IN REFIID  riid,
        OUT PVOID*  ppv
        );

    // CBasePin stuff
    HRESULT Run(REFERENCE_TIME tStart);
    HRESULT Inactive(void);
    HRESULT GetMediaType(IN int iPosition, IN CMediaType *pMediaType);
    HRESULT CheckMediaType(IN const CMediaType *pMediatype);
    HRESULT SetMediaType(IN const CMediaType *pMediatype);

    // CBaseOutputPin stuff
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT DecideBufferSize(
        IMemAllocator * pAlloc,
        ALLOCATOR_PROPERTIES * ppropInputRequest
    );

    // IAMStreamConfig stuff
    STDMETHODIMP SetFormat(
        IN AM_MEDIA_TYPE *pmt
        );

    STDMETHODIMP GetFormat(
        OUT AM_MEDIA_TYPE **ppmt
        );

    STDMETHODIMP GetNumberOfCapabilities(
        OUT int *piCount,
        OUT int *piSize
        );

    STDMETHODIMP GetStreamCaps(
        IN  int  iIndex, 
        OUT AM_MEDIA_TYPE **ppmt, 
        OUT BYTE *pSCC );

    // methods called by the capture filter
    HRESULT ProcessOneBuffer(
        IN const BYTE* pbBuffer, 
        IN DWORD dwSize,
        IN IReferenceClock * pClock,
        OUT LONG *plGainAdjustment
        );

    // silence & gain processing
    LONG GainAdjustment();
    HRESULT PreProcessing(
        IN  const BYTE   *pSourceBuffer,
        IN      DWORD   dwSourceDataSize,
        OUT     DWORD  *pdwStatus,
        OUT     LONG   *plGainAdjustment
        );

    STDMETHODIMP ResetSilenceStats();
    STDMETHODIMP SetSilenceDetection(IN BOOL fEnable);
    STDMETHODIMP GetSilenceDetection(OUT LPBOOL pfEnable);
    STDMETHODIMP SetSilenceCompression(IN BOOL fEnable);
    STDMETHODIMP GetSilenceCompression(OUT LPBOOL pfEnable);
    STDMETHODIMP GetAudioLevel( OUT LPLONG plAudioLevel );
    STDMETHODIMP GetAudioLevelRange(
        OUT LPLONG plMin, 
        OUT LPLONG plMax, 
        OUT LPLONG plSteppingDelta
        );
    STDMETHODIMP SetSilenceLevel(
        IN LONG lSilenceLevel,
        IN LONG lFlags
        );
    STDMETHODIMP CDSoundCaptureOutputPin::GetSilenceLevel(
        OUT LPLONG plSilenceLevel,
        OUT LONG   * pFlags
        );
    STDMETHODIMP CDSoundCaptureOutputPin::GetSilenceLevelRange(
        OUT LPLONG plMin, 
        OUT LPLONG plMax, 
        OUT LPLONG plSteppingDelta, 
        OUT LPLONG plDefault,
        OUT LONG * pFlags
        );
    void CDSoundCaptureOutputPin::Statistics(
        IN  const BYTE *    pBuffer,
        IN  DWORD           dwSize,
        OUT DWORD *         pdwPeak,
        OUT DWORD *         pdwClipPercent
        );

    DWORD Classify(
        IN DWORD dwPeak
        );

private:
    HRESULT ValidateMediaType(
        IN  AM_MEDIA_TYPE *pMediaType
        );

    HRESULT SetFormatInternal(
        IN  AM_MEDIA_TYPE *pMediaType
        );

    HRESULT DeliverSample(
        IN  IMediaSample * pSample,
        IN  DWORD dwStatus,
        IN  IReferenceClock * pClock
        );

    HRESULT PrepareToDeliver(
        IN  const BYTE   *pSourceBuffer,
        IN      DWORD   dwSourceDataSize,
        IN      BYTE   *pDestBuffer,
        IN OUT  DWORD  *pdwDestBufferSize,
        OUT     DWORD  *pdwStatus,
        OUT     LONG   *plGainAdjustment
        );


private:
    CRefTime            m_SampleTime;
    DWORD               m_dwSampleSize;
    DWORD               m_dwBufferSize;
    LONG                m_lDurationPerBuffer;
    DWORD               m_dwSamplesPerBuffer;
    BOOL                m_fFormatChanged;
    IMediaSample *      m_pPendingSample;

    BOOL                m_fSilenceSuppression;
    BOOL                m_fSuppressMode;
    BOOL                m_fAdaptThreshold;
    DWORD               m_dwThreshold;
    DWORD               m_dwSilentFrameCount;
    DWORD               m_dwSoundFrameCount;
    LONG                m_lSampleAverage;
    DWORD               m_dwSilenceAverage;
    DWORD               m_dwShortTermSoundAverage;
    DWORD               m_dwLongTermSoundAverage;
    DWORD               m_dwGainIncreaseDelay;
    DWORD               m_dwSignalLevel;

    WAVEFORMATEX        m_WaveFormat;
    
#if DBG // used for debugging
    BOOL                m_fAutomaticGainControl;
    float               m_GainFactor;
#endif

};

class CDSoundCaptureFilter : 
    public CBaseFilter, 
    public IAMAudioInputMixer,
    public IAMAudioDeviceControl,
    public IAMAudioDeviceConfig
{
public:
    DECLARE_IUNKNOWN

    CDSoundCaptureFilter(LPUNKNOWN pUnk, HRESULT *phr);
    ~CDSoundCaptureFilter();

    STDMETHOD (NonDelegatingQueryInterface) (
        IN REFIID  riid,
        OUT PVOID*  ppv
        );

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // Pin enumeration functions.
    STDMETHOD (EnumPins)(IEnumPins **ppEnum);
    CBasePin * GetPin(int n);
    int GetPinCount();

    
    // Overrides CBaseFilter methods.
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);


    // IAMAudioDeviceControl methods
    STDMETHOD (GetRange) (
        IN AudioDeviceProperty Property, 
        OUT long *plMin, 
        OUT long *plMax, 
        OUT long *plSteppingDelta, 
        OUT long *plDefault, 
        OUT long *plFlags
        );

    STDMETHOD (Get) (
        IN AudioDeviceProperty Property, 
        OUT long *plValue, 
        OUT long *plFlags
        );

    STDMETHOD (Set) (
        IN AudioDeviceProperty Property, 
        IN long lValue, 
        IN long lFlags
        );

    // IAMAudioDeviceConfig methods
    STDMETHOD (SetDeviceID) (
        IN  REFGUID pDSoundGUID,
        IN  UINT    uiWaveID
        );

    STDMETHOD (SetDuplexController) (
        IN  IAMAudioDuplexController * pIAudioDuplexController
        );

    // IAMAudioInputMixer methods
    STDMETHOD (put_Enable) (BOOL fEnable) { return E_NOTIMPL;};
    STDMETHOD (get_Enable) (BOOL *pfEnable) { return E_NOTIMPL;};
    STDMETHOD (put_Mono) (BOOL fMono) { return E_NOTIMPL;};
    STDMETHOD (get_Mono) (BOOL *pfMono) { return E_NOTIMPL;};
    STDMETHOD (put_Loudness) (BOOL fLoudness) { return E_NOTIMPL;};
    STDMETHOD (get_Loudness) (BOOL *pfLoudness) { return E_NOTIMPL;};
    STDMETHOD (put_MixLevel) (double Level);
    STDMETHOD (get_MixLevel) (double FAR* pLevel);
    STDMETHOD (put_Pan) (double Pan) { return E_NOTIMPL;};
    STDMETHOD (get_Pan) (double FAR* pPan) { return E_NOTIMPL;};
    STDMETHOD (put_Treble) (double Treble) { return E_NOTIMPL;};
    STDMETHOD (get_Treble) (double FAR* pTreble) { return E_NOTIMPL;};
    STDMETHOD (get_TrebleRange) (double FAR* pRange) { return E_NOTIMPL;};
    STDMETHOD (put_Bass) (double Bass) { return E_NOTIMPL;};
    STDMETHOD (get_Bass) (double FAR* pBass) { return E_NOTIMPL;};
    STDMETHOD (get_BassRange) (double FAR* pRange) { return E_NOTIMPL;};

public:
    // methods for the pins.
    HRESULT ConfigureCaptureDevice(
        IN const WAVEFORMATEX *pWaveFormatEx,
        IN DWORD dwSourceBufferSize
        );

    // utility methods.
    HRESULT ThreadProc();

private:
    HRESULT InitializeOutputPin();
    HRESULT InitializeInputPins();
    
    HRESULT StartThread();
    HRESULT ProcessSample();

    HRESULT GetMixerControl(
        IN  DWORD dwControlType, 
        IN  DWORD dwTryComponent,
        OUT HMIXEROBJ *pID,
        OUT MIXERCONTROL *pmc
        );

private:

    // The lock for the filter and the pins.
    CCritSec                m_Lock;

    // The total number of pins on this filter.
    DWORD                   m_dwNumPins;

    // The filters' output pin.
    CDSoundCaptureOutputPin *   m_pOutputPin;

    // This filters's array of input pins.
    DWORD                   m_dwNumInputPins;
    CDSoundCaptureInputPin**    m_ppInputPins;

    HANDLE                  m_hThread;
    CAMEvent                m_evDevice;
    CAMEvent                m_evFinish;

    BOOL                    m_fAutomaticGainControl;
    BOOL                    m_fAcousticEchoCancellation;

    // The wave device ID used by this filter.
    BOOL                    m_fDeviceConfigured;
    GUID                    m_DSoundGUID;
    UINT                    m_WaveID;
    CCaptureDevice *        m_pCaptureDevice;
    IAMAudioDuplexController * m_pIAudioDuplexController;
};

class CAudioDuplexController : 
    public CUnknown,
    public IAMAudioDuplexController
{
public:
    DECLARE_IUNKNOWN

    CAudioDuplexController(LPUNKNOWN pUnk, HRESULT *phr);
    ~CAudioDuplexController();

    STDMETHOD (NonDelegatingQueryInterface) (
        IN REFIID  riid,
        OUT PVOID*  ppv
        );

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    //IAMAudioDuplexController methods
    STDMETHOD (SetCaptureBufferInfo) (
        IN  GUID *          pDSoundCaptureGUID,
        IN  DSCBUFFERDESC * pDescription
        );

    STDMETHOD (SetRenderBufferInfo) (
        IN  GUID *          pDSoundRenderGUID,
        IN  DSBUFFERDESC *  pDescription,
        IN  HWND            hWindow,
        IN  DWORD           dwCooperateLevel
        );

    STDMETHOD (EnableEffects) (
        IN  DWORD           dwNumberEffects,
        IN  EFFECTS *       pEffects,
        IN  BOOL *          pfEnable
        );

    HRESULT  ToggleEffects (
        IN  EFFECTS     Effect,
        IN  BOOL        fEnable
        );

    STDMETHOD (GetCaptureDevice) (
        LPLPDIRECTSOUNDCAPTURE        ppDSoundCapture,
        LPLPDIRECTSOUNDCAPTUREBUFFER  ppCaptureBuffer
        );

    STDMETHOD (GetRenderDevice) (
        LPLPDIRECTSOUND        ppDirectSound,
        LPLPDIRECTSOUNDBUFFER  ppRenderBuffer
        );

    STDMETHOD (ReleaseCaptureDevice) ();

    STDMETHOD (ReleaseRenderDevice) ();

private:
    void CleanUpInterfaces();

    HRESULT CacheInterfaces(
        IN LPDIRECTSOUNDFULLDUPLEX pDirectSoundFullDuplex,
        IN IDirectSoundCaptureBuffer8 *pIDirectSoundCaptureBuffer8,
        IN IDirectSoundBuffer8 *pIDirectSoundBuffer8
        );

    HRESULT FullDuplexCreate();

private:

    // The lock for the data.
    CCritSec        m_Lock;

    BOOL            m_Effects[EFFECTS_LAST];

    // dsound capture related data.
    BOOL            m_fCaptureConfigured;
    GUID            m_DSoundCaptureGUID;
    WAVEFORMATEX    m_CaptureFormat;
    DSCBUFFERDESC   m_CaptureBufferDescription;

    // dsound render retailed data.
    BOOL            m_fRenderConfigured;
    GUID            m_DSoundRenderGUID;
    WAVEFORMATEX    m_RenderFormat;
    DSBUFFERDESC    m_RenderBufferDescription;
    HWND            m_hWindow;
    DWORD           m_dwCooperateLevel;

    // dsound capture pointers.
    LPDIRECTSOUNDCAPTURE        m_pDSoundCapture;
    LPDIRECTSOUNDCAPTUREBUFFER  m_pCaptureBuffer;
    LPDIRECTSOUNDCAPTUREBUFFER8 m_pCaptureBuffer8;

    // dsound render pointers.
    LPDIRECTSOUND               m_pDSoundRender;
    LPDIRECTSOUNDBUFFER         m_pRenderBuffer;
};

#endif __DSCFILTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\filter\stdafx.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\filter\stdafx.h ===
/*++

    Copyright (c) 2000 Microsoft Corporation

Module Name:

    stdafx.h

Abstract:

    the precompile header file.

--*/

#include <objbase.h>
#include <windows.h>
#include <streams.h>
#include <mmsystem.h>
#include <mmddk.h>
#include <dshowaec.h>
#include "dscfiltr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\eq\eqfilt.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
// things that are broken:
//
// bogus handling of ends of buffers
// output DecideBufferSize is broken
// better format checking, require 8/16 bit
// doesn't handle stereo properly
//	well, it's better now, but we're not reporting stereo levels separately.
// we might be looking at the wrong FFT coefficients.
// frequency bands are very sharp, should there be some overlap?
// need to handle Pause to report correctly paused values while paused
//
// replace floating-point FFT with integer one for speed?
//
// Do we want to allow customizing # of bands?
//




#include <windows.h>
#include <streams.h>
#include <initguid.h>
#include <olectl.h>
#if (1100 > _MSC_VER)
#include <olectlid.h>
#endif
#include "ieqfilt.h"
#include "eqprop.h"
#include <math.h>

#include "fft.h"
const int EQ_BANDS = 10;

class CEqualizer : public CTransformFilter,
		  public IEqualizer,
		  public ISpecifyPropertyPages
{

public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    // Reveals IEqualizer & ISpecifyPropertyPages
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    DECLARE_IUNKNOWN;

    HRESULT Transform(IMediaSample *pIn, IMediaSample *pOut);
    HRESULT CheckInputType(const CMediaType *mtIn);
    HRESULT CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut);
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT DecideBufferSize(IMemAllocator *pAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);

    HRESULT StopStreaming();
    
    // IEqualizer methods

    STDMETHODIMP get_EqualizerLevels(int nBands, int EqualizerLevels[]);
    STDMETHODIMP get_EqualizerSettings(int *nBands, int pBandLevels[]);
    STDMETHODIMP put_EqualizerSettings(int nBands, int BandLevel[]);
    STDMETHODIMP put_DefaultEqualizerSettings();
    STDMETHODIMP get_EqualizerFrequencies(int *nBands, int pBandFrequencies[]);
    STDMETHODIMP put_BypassEqualizer(BOOL fBypass);
    STDMETHODIMP get_BypassEqualizer(BOOL *pfBypass);

    // ISpecifyPropertyPages method

    STDMETHODIMP GetPages(CAUUID *pPages);

private:

    // Constructor
    CEqualizer(TCHAR *tszName, LPUNKNOWN punk, HRESULT *phr);
    ~CEqualizer();

    HRESULT DoChunk(float *pBuffer, int divisor, int freq, REFERENCE_TIME rt);

    // The number of buffers to request on the output allocator
    const long m_lBufferRequest;

    BOOL m_fAdjustEq;
    float m_AdjustLevel[EQ_BANDS];

    struct TimedLevel {
	float levels[EQ_BANDS];
	REFERENCE_TIME rt;
    };

    CGenericList<TimedLevel> m_levels;

    // Non interface locking critical section
    CCritSec m_EqualizerLock;

    IUnknown *m_punkControl;

}; // CEqualizer


// setup data

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Audio,       // Major type
    &MEDIASUBTYPE_NULL      // Minor type
};

const AMOVIESETUP_PIN psudPins[] =
{
    {
        L"Input",           // String pin name
        FALSE,              // Is it rendered
        FALSE,              // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Output",          // Connects to pin
        1,                  // Number of types
        &sudPinTypes },     // The pin details
      { L"Output",          // String pin name
        FALSE,              // Is it rendered
        TRUE,               // Is it an output
        FALSE,              // Allowed none
        FALSE,              // Allowed many
        &CLSID_NULL,        // Connects to filter
        L"Input",           // Connects to pin
        1,                  // Number of types
        &sudPinTypes        // The pin details
    }
};


const AMOVIESETUP_FILTER sudEqualizer =
{
    &CLSID_Equalizer,        // Filter CLSID
    L"Audio Equalizer",      // Filter name
    MERIT_DO_NOT_USE,       // Its merit
    2,                      // Number of pins
    psudPins                // Pin details
};


// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance

CFactoryTemplate g_Templates[2] = {

    { L"Audio Equalizer"
    , &CLSID_Equalizer
    , CEqualizer::CreateInstance
    , NULL
    , &sudEqualizer }
  ,
    { L"Audio Equalizer Property Page"
    , &CLSID_EqualizerPropertyPage
    , CEqualizerProperties::CreateInstance }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


//
// Constructor
//
CEqualizer::CEqualizer(TCHAR *tszName,LPUNKNOWN punk,HRESULT *phr) :
    CTransformFilter(tszName, punk, CLSID_Equalizer),
    m_lBufferRequest(4), m_fAdjustEq(TRUE), m_levels(NAME("level values")),
    m_punkControl(NULL)
{
    ASSERT(tszName);
    ASSERT(phr);

    for (int i = 0; i < EQ_BANDS; i++) {
	m_AdjustLevel[i] = 1.0;
    }
} // Equalizer

CEqualizer::~CEqualizer()
{
    if (m_punkControl)
	m_punkControl->Release();
}

//
// CreateInstance
//
// Provide the way for COM to create a CEqualizer object
//
CUnknown * WINAPI CEqualizer::CreateInstance(LPUNKNOWN punk, HRESULT *phr) {

    CEqualizer *pNewObject = new CEqualizer(NAME("Equalizer"), punk, phr);
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return pNewObject;

} // CreateInstance


#include "eqocx.h"
//
// NonDelegatingQueryInterface
//
// Reveals IEqualizer and ISpecifyPropertyPages
//
STDMETHODIMP CEqualizer::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_IEqualizer) {
        return GetInterface((IEqualizer *) this, ppv);
    } else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    } else if (riid == IID_IOleObject ||
    	   riid == IID_IOleInPlaceObjectWindowless ||
	       riid == IID_IOleInPlaceObject ||
	       riid == IID_IViewObject ||
	       riid == IID_IViewObject2 ||
	       riid == IID_IOleWindow ||
	       riid == IID_IOleControl ||
	       riid == IID_IOleObject ||
	       riid == IID_IQuickActivate ||
	       riid == IID_ISpecifyPropertyPages ||
	       riid == IID_IDispatch ||
	       riid == IID_IOleInPlaceActiveObject ||
	       riid == IID_IViewObjectEx) { // !!! is this a complete list of interfaces?
	// in the standalone case, we aggregate the DAViewer control
	if (!m_punkControl) {
	    HRESULT hr = S_OK; 
	    // create the control aggregated 

       	    if(FAILED(CoCreateInstance(__uuidof(EQUI), (IBaseFilter *) this,
				       CLSCTX_INPROC_SERVER, IID_IUnknown, (void **) &m_punkControl))) {
		ASSERT(0);
		return E_NOINTERFACE;
	    }

	    IEQUI *pEQUI;

	    m_punkControl->QueryInterface(__uuidof(IEQUI), (void **) &pEQUI);
	    pEQUI->SetEQFilter((IEqualizer *) this);
	    pEQUI->Release();

	    // !!! do additional control initialization here, if needed.
	    // certainly need to give control a pointer to the filter of some
	    // kind.
	}
	
	return m_punkControl->QueryInterface(riid, ppv);
    } else {
        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }

} // NonDelegatingQueryInterface


//
// Transform
//
// Since we have a floating-point FFT, we first transform the input buffer
// into our float temp buffer, then do the FFT (& inverse if the equalizer is
// active), and convert back into the output buffer.
//
HRESULT CEqualizer::Transform(IMediaSample *pIn, IMediaSample *pOut)
{
    int iSize = pIn->GetActualDataLength();
    BYTE *pSampleBuffer;
    pIn->GetPointer(&pSampleBuffer);
    int i;

    AM_SAMPLE2_PROPERTIES * const pProps = m_pInput->SampleProps();

    REFERENCE_TIME rt = pProps->tStart;

    BYTE *pOutBuffer;
    pOut->GetPointer(&pOutBuffer);
    pOut->SetActualDataLength(iSize);

    if (!m_fAdjustEq) {
	// why isn't this an in-place transform in this case???
	CopyMemory(pOutBuffer, pSampleBuffer, iSize);
    }
    
    float buf[FFT_SIZE];
    // !!! need to get audio into temp buffer somehow
    // !!! what about latency here!  not much can be done.

    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) m_pInput->CurrentMediaType().Format();

    WORD nChannels = pwfx->nChannels;
    iSize /= nChannels;
    
    // branch depending on the type of audio we have....
    if (pwfx->wBitsPerSample == 8) {
	BYTE *pb1 = (BYTE *) pSampleBuffer;
	BYTE *pb1Out = (BYTE *) pOutBuffer;

	do {
	    int iCopy = min(iSize, FFT_SIZE);
	    iSize -= iCopy;

	    for (int chan = 0; chan < nChannels; chan++) {
		BYTE *pb = pb1 + chan;
		BYTE *pbOut = pb1Out + chan;
		
		for (i = 0; i < iCopy; i++) {
		    buf[i] = (float) (((int) (unsigned int) *pb - 128) * 256);
		    pb += nChannels;
		}

		while (i < FFT_SIZE) {
		    buf[i] = buf[i % iCopy];  // !!! not right, not right at all.
		    i++;
		}

		DoChunk(buf, 1, pwfx->nSamplesPerSec, rt);

		if (m_fAdjustEq) {
		    for (i = 0; i < iCopy; i++) {
			// !!! must clip
			LONG l = (long) (buf[i] / 256);
			if (l < -128)
			    l = -128;
			else if (l > 127)
			    l = 127;
			*pbOut = (BYTE) l + 128;
			pbOut += nChannels;
		    }
		}
	    }
	    pb1 += iCopy * nChannels;
	    pb1Out += iCopy * nChannels;
	    
	    rt += iCopy * UNITS / pwfx->nSamplesPerSec;
	} while (iSize > 0);
    } else if (pwfx->wBitsPerSample == 16) {
	WORD *pw1 = (WORD *) pSampleBuffer;
	WORD *pw1Out = (WORD *) pOutBuffer;
	
	iSize /= sizeof(WORD);

	do {
	    int iCopy = min(iSize, FFT_SIZE);
	    iSize -= iCopy;

	    for (int chan = 0; chan < nChannels; chan++) {
		WORD *pw = pw1 + chan;
		WORD *pwOut = pw1Out + chan;
		
		for (i = 0; i < iCopy; i++) {
		    buf[i] = (float) (short) *pw;
		    pw += nChannels;
		}

		while (i < FFT_SIZE) {
		    buf[i] = buf[i % iCopy];  // !!! not right, not right at all.
		    i++;
		}

		DoChunk(buf, 16, pwfx->nSamplesPerSec, rt);

		if (m_fAdjustEq) {
		    for (i = 0; i < iCopy; i++) {
			// !!! must clip
			LONG l = (LONG) buf[i];
			if (l < -32768)
			    l = -32768;
			else if (l > 32767)
			    l = 32767;
			*pwOut = (WORD) (int) l;
			pwOut += nChannels;
		    }
		}
	    }
	    pw1 += iCopy * nChannels;
	    pw1Out += iCopy * nChannels;
	    
	    rt += iCopy * UNITS / pwfx->nSamplesPerSec;
	} while (iSize > 0);
    } else {

	ASSERT(0); // !!!

    }

    return S_OK;
} // Transform


// get a level value and transform if necessary one FFT worth of data.
HRESULT CEqualizer::DoChunk(float *pBuffer, int divisor, int freq, REFERENCE_TIME rt)
{
    float outbuf[FFT_SIZE];
    TimedLevel *p = new TimedLevel;

    if (!p)
	return E_OUTOFMEMORY;

    p->rt = rt;
    
    for (int i = 0; i < EQ_BANDS; i++) p->levels[i] = 0;

    ComputeFFT(pBuffer, outbuf, FALSE);

    // now compute levels

    // low band is 31Hz, so we set the limit as sqrt(2) * 31 == (approx) 45 Hz,
    // then double this to get limits for future bands.  This is cheap, but it's
    // about right, since it's the geometric mean of the successive band centers.

    // of course, if this were written by somebody who actually knew something
    // about audio, the bands might merge into one another rather than being this
    // sharply defined.
    int bandlimit = 45;
    int band = 0;
    int bandstart = 0;

#if 1
    // start at 1, don't look at the DC offset in sample 0.
    for (i = 1; i < FFT_SIZE / 2; i++) {
	if ((i * freq / FFT_SIZE) > bandlimit) {
	    bandlimit *= 2;
	    if (i > bandstart)
		p->levels[band] /= (FFT_SIZE * divisor * 2 * (i - bandstart));
	    bandstart = i;
	    band++;
	}

	// !!! rather than adding up the real & imaginary parts, should I be
	// taking the sum of squares, and then a sqrt?
	p->levels[band] += (float) (fabs(outbuf[i]) + fabs(outbuf[FFT_SIZE + 1 - i]));
    }
#else
    // alternate method for computing levels
    double sum = 0;
    
    // start at 1, don't look at the DC offset in sample 0.
    for (i = 1; i < FFT_SIZE / 2; i++) {
	if ((i * freq / FFT_SIZE) > bandlimit) {
	    bandlimit *= 2;
	    if (i > bandstart)
		p->levels[band] = sqrt(sum) / (FFT_SIZE * divisor * 2 * (i - bandstart));
	    bandstart = i;
	    band++;
	    sum = 0;
	}

	// !!! rather than adding up the real & imaginary parts, should I be
	// taking the sum of squares, and then a sqrt?
	sum += outbuf[i] * outbuf[i] + outbuf[FFT_SIZE + 1 - i] * outbuf[FFT_SIZE + 1 - i];
    }
#endif

    if (i > bandstart)
	p->levels[band] /= (FFT_SIZE * divisor * 2 * (i - bandstart));

    // ok, so we have the levels.  store them?

    {
	CAutoLock lock(&m_EqualizerLock);
	m_levels.AddTail(p);

	// !!! could just copy settings and release lock
	if (m_fAdjustEq) {
	    bandlimit = 45;
	    band = 0;
	    float adj = m_AdjustLevel[0];
	    for (int i = 1; i < FFT_SIZE / 2; i++) {
		if ((i * freq / FFT_SIZE) > bandlimit) {
		    bandlimit *= 2;
		    band++;
		    adj = m_AdjustLevel[band];
		}

		outbuf[i] *= adj;
		outbuf[FFT_SIZE + 1 - i] *= adj;
	    }
	}
	// now convert back into output buffer....

	// compute inverse FFT
	ComputeFFT(outbuf, pBuffer, TRUE);

	// !!! we may need to do some kind of smoothing between chunks....
    }

    DbgLog((LOG_TRACE, 2, TEXT("Levels: %d %d %d %d %d %d %d %d %d %d"),
	    (int) p->levels[0], (int) p->levels[1], (int) p->levels[2], (int) p->levels[3], (int) p->levels[4], 
	    (int) p->levels[5], (int) p->levels[6], (int) p->levels[7], (int) p->levels[8], (int) p->levels[9]));
    
    return S_OK;
} 


HRESULT CEqualizer::StopStreaming()
{
    TimedLevel *p;

    // !!! ideally, we should be deleting some of these as we go, rather
    // than keeping them all until now
    while (p = m_levels.RemoveHead())
	delete p;

    return NOERROR;
}

//
// CheckInputType
//
// Check the input type is OK, return an error otherwise
//
HRESULT CEqualizer::CheckInputType(const CMediaType *mtIn)
{
    // Check this is a VIDEOINFO type

    if (*mtIn->FormatType() != FORMAT_WaveFormatEx) {
        return E_INVALIDARG;
    }

    if (*mtIn->Type() != MEDIATYPE_Audio) {
	return E_INVALIDARG;
    }

    if (*mtIn->Subtype() != MEDIASUBTYPE_PCM) {
	return E_INVALIDARG;
    }

    // !!! check more WAVEFORMATEX parts

    return S_OK;

} // CheckInputType


//
// CheckTransform
//
// To be able to transform the formats must be identical
//
HRESULT CEqualizer::CheckTransform(const CMediaType *mtIn,const CMediaType *mtOut)
{
    HRESULT hr;
    if (FAILED(hr = CheckInputType(mtIn))) {
	return hr;
    }

    if (*mtIn != *mtOut)
	return E_INVALIDARG;

    return S_OK;
} // CheckTransform



//
// GetMediaType
//
// I support one type, namely the type of the input pin
// We must be connected to support the single output type
//
HRESULT CEqualizer::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    // Is the input pin connected

    if (m_pInput->IsConnected() == FALSE) {
        return E_UNEXPECTED;
    }

    // This should never happen

    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    // Do we have more items to offer

    if (iPosition > 0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    *pMediaType = m_pInput->CurrentMediaType();
    return NOERROR;

} // GetMediaType


//
// DecideBufferSize
//
// Tell the output pin's allocator what size buffers we
// require. Can only do this when the input is connected
//
HRESULT CEqualizer::DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties)
{
    // Is the input pin connected

    if (m_pInput->IsConnected() == FALSE) {
        return E_UNEXPECTED;
    }

    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    // !!!m_pInput->m_pAllocator->GetProperties(pProperties);
    // !!! can't get to the input pin's allocator properties, unfortunately!
    pProperties->cBuffers = 4;
    pProperties->cbBuffer = 0x40000; // !!!!
    pProperties->cbAlign = 1;
    pProperties->cbPrefix = 0;
    
    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    if (pProperties->cBuffers > Actual.cBuffers ||
            pProperties->cbBuffer > Actual.cbBuffer) {
                return E_FAIL;
    }
    return NOERROR;

} // DecideBufferSize



//
// get_EqualizerLevels
//
// Return the current audio levels
//
STDMETHODIMP CEqualizer::get_EqualizerLevels(int nBands, int EqualizerLevels[])
{
    CAutoLock cAutoLock(&m_EqualizerLock);

    if (nBands < EQ_BANDS)
	return E_FAIL;

    CRefTime rtStream;
    HRESULT hr = StreamTime(rtStream);

    TimedLevel *plNow = NULL;
    if (SUCCEEDED(hr) && m_levels.GetCount() > 0) {
	POSITION p = m_levels.GetHeadPosition();
	TimedLevel *pl1;
	
	while (pl1 = m_levels.GetNext(p)) {
	    if (pl1->rt > rtStream)
		break;

	    plNow = pl1;

	    // !!! need code to discard old timings
	}
    }

    if (plNow) {
	for (int i = 0; i < EQ_BANDS; i++) {
	    EqualizerLevels[i] = (int) (plNow->levels[i] * MAX_EQ_LEVEL  / 256);
	}
    } else {
	for (int i = 0; i < EQ_BANDS; i++) {
	    EqualizerLevels[i] = 0;
	}    
    }

    // !!! currently, we return the pre-adjusted level, we could multiply
    // by the adjust factors if we wanted to.

    return NOERROR;

} // get_EqualizerLevel


//
// get_EqualizerSettings
//
// gets the current setup
//
STDMETHODIMP CEqualizer::get_EqualizerSettings(int *nBands, int BandLevels[])
{
    CAutoLock cAutoLock(&m_EqualizerLock);

    *nBands = EQ_BANDS;

    for (int i = 0; i < EQ_BANDS; i++) {
	BandLevels[i] = (int) (m_AdjustLevel[i] * (MAX_EQ_LEVEL / 2));
    }    

    return NOERROR;

} // put_EqualizerLevel


//
// put_EqualizerSettings
//
// Sets up the equalizer
//
STDMETHODIMP CEqualizer::put_EqualizerSettings(int nBands, int BandLevel[])
{
    CAutoLock cAutoLock(&m_EqualizerLock);

    // !!! should we allow changing the # of bands here?
    if (nBands != EQ_BANDS)
	return E_INVALIDARG;  // !!!
    
    for (int i = 0; i < EQ_BANDS; i++) {
	m_AdjustLevel[i] = (float) BandLevel[i] / (MAX_EQ_LEVEL / 2);
    }    

    return NOERROR;

} // put_EqualizerLevel


//
// get_EqualizerFrequencies
//
// gets the current setup
//
STDMETHODIMP CEqualizer::get_EqualizerFrequencies(int *nBands, int BandFrequencies[])
{
    CAutoLock cAutoLock(&m_EqualizerLock);

    *nBands = EQ_BANDS;

    // 16KHz 8KHz  4KHz  2KHz  1KHz
    // 500Hz  250 Hz  125Hz  62Hz  31Hz
    int freq = 16000;
    for (int i = EQ_BANDS - 1; i >= 0; i--) {
	BandFrequencies[i] = freq;
	freq /= 2;
    }

    return NOERROR;

} // put_EqualizerLevel

//
// put_DefaultEqualizerLevel
//
// Sets the default contrast level for the filter
//
STDMETHODIMP CEqualizer::put_DefaultEqualizerSettings()
{
    CAutoLock cAutoLock(&m_EqualizerLock);

    for (int i = 0; i < EQ_BANDS; i++) {
	m_AdjustLevel[i] = 1.0;
    }

    return NOERROR;

} // put_DefaultEqualizerSettings


STDMETHODIMP CEqualizer::put_BypassEqualizer(BOOL fBypass)
{
    m_fAdjustEq = !fBypass;

    return S_OK;
}

STDMETHODIMP CEqualizer::get_BypassEqualizer(BOOL *pfBypass)
{
    *pfBypass = !m_fAdjustEq;

    return S_OK;
}

//
// GetPages
//
// This is the sole member of ISpecifyPropertyPages
// Returns the clsid's of the property pages we support
//
STDMETHODIMP CEqualizer::GetPages(CAUUID *pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_EqualizerPropertyPage;
    return NOERROR;

} // GetPages



//
// DllRegisterServer
//
// Handle registration of this filter
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );

} // DllRegisterServer


//
// DllUnregisterServer
//
STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );

} // DllUnregisterServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\eq\eqocx.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Nov 03 15:39:40 1998
 */
/* Compiler settings for C:\testapps\eqocx\eqocx.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __eqocx_h__
#define __eqocx_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEQUI_FWD_DEFINED__
#define __IEQUI_FWD_DEFINED__
typedef interface IEQUI IEQUI;
#endif 	/* __IEQUI_FWD_DEFINED__ */


#ifndef ___IEQUIEvents_FWD_DEFINED__
#define ___IEQUIEvents_FWD_DEFINED__
typedef interface _IEQUIEvents _IEQUIEvents;
#endif 	/* ___IEQUIEvents_FWD_DEFINED__ */


#ifndef __EQUI_FWD_DEFINED__
#define __EQUI_FWD_DEFINED__

#ifdef __cplusplus
typedef class EQUI EQUI;
#else
typedef struct EQUI EQUI;
#endif /* __cplusplus */

#endif 	/* __EQUI_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IEQUI_INTERFACE_DEFINED__
#define __IEQUI_INTERFACE_DEFINED__

/* interface IEQUI */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IEQUI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53AE9B40-7367-11D2-A9FD-00C04FA3B60C")
    IEQUI : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_AutoSize( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_AutoSize( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Window( 
            /* [retval][out] */ long __RPC_FAR *phwnd) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEQFilter( 
            /* [in] */ IUnknown __RPC_FAR *pFilter) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEQUIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEQUI __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEQUI __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEQUI __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IEQUI __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IEQUI __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IEQUI __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IEQUI __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoSize )( 
            IEQUI __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoSize )( 
            IEQUI __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Window )( 
            IEQUI __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *phwnd);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEQFilter )( 
            IEQUI __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pFilter);
        
        END_INTERFACE
    } IEQUIVtbl;

    interface IEQUI
    {
        CONST_VTBL struct IEQUIVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEQUI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEQUI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEQUI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEQUI_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IEQUI_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IEQUI_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IEQUI_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IEQUI_put_AutoSize(This,vbool)	\
    (This)->lpVtbl -> put_AutoSize(This,vbool)

#define IEQUI_get_AutoSize(This,pbool)	\
    (This)->lpVtbl -> get_AutoSize(This,pbool)

#define IEQUI_get_Window(This,phwnd)	\
    (This)->lpVtbl -> get_Window(This,phwnd)

#define IEQUI_SetEQFilter(This,pFilter)	\
    (This)->lpVtbl -> SetEQFilter(This,pFilter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IEQUI_put_AutoSize_Proxy( 
    IEQUI __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IEQUI_put_AutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IEQUI_get_AutoSize_Proxy( 
    IEQUI __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IEQUI_get_AutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IEQUI_get_Window_Proxy( 
    IEQUI __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *phwnd);


void __RPC_STUB IEQUI_get_Window_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEQUI_SetEQFilter_Proxy( 
    IEQUI __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pFilter);


void __RPC_STUB IEQUI_SetEQFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEQUI_INTERFACE_DEFINED__ */



#ifndef __EQOCXLib_LIBRARY_DEFINED__
#define __EQOCXLib_LIBRARY_DEFINED__

/* library EQOCXLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_EQOCXLib;

#ifndef ___IEQUIEvents_DISPINTERFACE_DEFINED__
#define ___IEQUIEvents_DISPINTERFACE_DEFINED__

/* dispinterface _IEQUIEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__IEQUIEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("53AE9B42-7367-11D2-A9FD-00C04FA3B60C")
    _IEQUIEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IEQUIEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            _IEQUIEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            _IEQUIEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            _IEQUIEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            _IEQUIEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            _IEQUIEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            _IEQUIEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            _IEQUIEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } _IEQUIEventsVtbl;

    interface _IEQUIEvents
    {
        CONST_VTBL struct _IEQUIEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IEQUIEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define _IEQUIEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define _IEQUIEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define _IEQUIEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define _IEQUIEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define _IEQUIEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define _IEQUIEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IEQUIEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_EQUI;

#ifdef __cplusplus

class DECLSPEC_UUID("53AE9B41-7367-11D2-A9FD-00C04FA3B60C")
EQUI;
#endif
#endif /* __EQOCXLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\test\testapp.cpp ===
// This program adds a conferences on a given ILS server.

#include <objbase.h>
#include <strmif.h>
#include <control.h>
#include <uuids.h>
#include <stdio.h>
#include <mmsystem.h>
#include <initguid.h>
#include <dshowaec.h>
#include <atlbase.h>

// {3C78B8E2-6C4D-11d1-ADE2-0000F8754B99}
static const GUID CLSID_WavDest =
{ 0x3c78b8e2, 0x6c4d, 0x11d1, { 0xad, 0xe2, 0x0, 0x0, 0xf8, 0x75, 0x4b, 0x99 } };

///////////////////////////////////////////////////////////////////////////////
//
//   Performace helpers
//
///////////////////////////////////////////////////////////////////////////////
LARGE_INTEGER g_liFrequency;
LARGE_INTEGER g_liTicks;

inline int ClockDiff(
    LARGE_INTEGER &liNewTick, 
    LARGE_INTEGER &liOldTick
    )
{
    return (DWORD)((liNewTick.QuadPart - liOldTick.QuadPart) 
        * 1e6 / g_liFrequency.QuadPart);
}

///////////////////////////////////////////////////////////////////////////////
//
//   Log helpers
//
///////////////////////////////////////////////////////////////////////////////
typedef struct LOGITEM
{
    TCHAR * pszMessage;
    DWORD   dw;

} LOGITEM;

const DWORD LOG_BUFFER_MASK = 0x3ff;
const DWORD LOG_BUFFER_SIZE = LOG_BUFFER_MASK + 1;

LOGITEM g_LogBuffer[LOG_BUFFER_SIZE];
DWORD g_dwCurrentLogItem = 0;
DWORD g_dwTotalItems = 0;


void Log(
    TCHAR * pszMessage,
    DWORD dw
    )
{
    g_LogBuffer[g_dwCurrentLogItem].pszMessage = pszMessage;
    g_LogBuffer[g_dwCurrentLogItem].dw = dw;

    g_dwCurrentLogItem = ((g_dwCurrentLogItem + 1) & LOG_BUFFER_MASK);
    
    g_dwTotalItems ++;
    if (g_dwTotalItems > LOG_BUFFER_SIZE) 
    {
        g_dwTotalItems = LOG_BUFFER_SIZE;
    }
    
}

void DumpLog()
{
    for (DWORD i = g_dwCurrentLogItem; i < g_dwTotalItems; i ++)
    {
        printf("%40ws%14d\n", 
            g_LogBuffer[i].pszMessage,
            g_LogBuffer[i].dw
            );
    }

    for (i = 0; i < g_dwCurrentLogItem; i ++)
    {
        printf("%40ws%14d\n", 
            g_LogBuffer[i].pszMessage,
            g_LogBuffer[i].dw
            );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//   filter helpers
//
///////////////////////////////////////////////////////////////////////////////
void WINAPI MyDeleteMediaType(AM_MEDIA_TYPE *pmt)
/*++

Routine Description:
    
    Delete a AM media type returned by the filters.

Arguments:

    pmt     - a pointer to a AM_MEDIA_TYPE structure.

Return Value:

    HRESULT

--*/
{
    // allow NULL pointers for coding simplicity

    if (pmt == NULL) {
        return;
    }

    if (pmt->cbFormat != 0) {
        CoTaskMemFree((PVOID)pmt->pbFormat);

        // Strictly unnecessary but tidier
        pmt->cbFormat = 0;
        pmt->pbFormat = NULL;
    }
    if (pmt->pUnk != NULL) {
        pmt->pUnk->Release();
        pmt->pUnk = NULL;
    }

    CoTaskMemFree((PVOID)pmt);
}

HRESULT
AddFilter(
    IN IGraphBuilder *      pGraph,
    IN const CLSID &        Clsid,
    IN LPCWSTR              pwstrName,
    OUT IBaseFilter **      ppFilter
    )
/*++

Routine Description:

    Create a filter and add it into the filtergraph.

Arguments:
    
    pGraph         - the filter graph.

    Clsid           - reference to the CLSID of the filter

    pwstrName       - The name of ther filter added.

    ppFilter   - pointer to a pointer that stores the returned IBaseFilter
                      interface pointer to the newly created filter.

Return Value:

    HRESULT

--*/
{
    HRESULT hr;

    LARGE_INTEGER liTicks;
    LARGE_INTEGER liTicks1;
    QueryPerformanceCounter(&liTicks);

    if (FAILED(hr = CoCreateInstance(
            Clsid,
            NULL,
            CLSCTX_INPROC_SERVER,
            __uuidof(IBaseFilter),
            (void **) ppFilter
            )))
    {
        return hr;
    }
    QueryPerformanceCounter(&liTicks1);
    Log(TEXT("Create filter:"), ClockDiff(liTicks1, liTicks));

    QueryPerformanceCounter(&liTicks);
    if (FAILED(hr = pGraph->AddFilter(*ppFilter, pwstrName)))
    {
        (*ppFilter)->Release();
        *ppFilter = NULL;
        return hr;
    }

    QueryPerformanceCounter(&liTicks1);
    Log(TEXT("Add filter:"), ClockDiff(liTicks1, liTicks));

    return S_OK;
}

HRESULT
FindPin(
    IN  IBaseFilter *   pFilter, 
    OUT IPin **         ppPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree = TRUE
    )
/*++

Routine Description:

    Find a input pin or output pin on a filter.

Arguments:
    
    pIFilter    - the filter that has pins.

    ppIPin      - the place to store the returned interface pointer.

    direction   - PINDIR_INPUT or PINDIR_OUTPUT.

    bFree       - look for a free pin or not.

Return Value:

    HRESULT

--*/
{
    HRESULT hr;
    DWORD dwFetched;

    // Get the enumerator of pins on the filter.
    CComPtr< IEnumPins > pEnumPins;
    if (FAILED(hr = pFilter->EnumPins(&pEnumPins)))
    {
        return hr;
    }

    IPin * pPin = NULL;
    // Enumerate all the pins and break on the 
    // first pin that meets requirement.
    for (;;)
    {
        if (pEnumPins->Next(1, &pPin, &dwFetched) != S_OK)
        {
            return E_FAIL;
        }
        if (0 == dwFetched)
        {
            return E_FAIL;
        }

        PIN_DIRECTION dir;
        if (FAILED(hr = pPin->QueryDirection(&dir)))
        {
            pPin->Release();
            return hr;
        }
        if (direction == dir)
        {
            if (!bFree)
            {
                break;
            }

            // Check to see if the pin is free.
            CComPtr< IPin > pPinConnected;
            hr = pPin->ConnectedTo(&pPinConnected);
            if (pPinConnected == NULL)
            {
                break;
            }
        }
        pPin->Release();
    }

    *ppPin = pPin;

    return S_OK;
}

HRESULT
ConnectFilters(
    IN IGraphBuilder * pGraph,
    IN IBaseFilter *pFilter1, 
    IN IBaseFilter *pFilter2,
    IN AM_MEDIA_TYPE *pmt = NULL
    )
/*++

Routine Description:

    Connect the output pin of the first filter to the input pin of the
    second filter.

Arguments:

    pIGraph     - the filter graph.

    pIFilter1   - the filter that has the output pin.

    pIFilter2   - the filter that has the input pin.

    pmt         - a pointer to a AM_MEDIA_TYPE used in the connection.

Return Value:

    HRESULT

--*/
{
    HRESULT hr;

    CComPtr< IPin > pOutputPin;
    if (FAILED(hr =::FindPin(pFilter1, &pOutputPin, PINDIR_OUTPUT)))
    {
        return hr;
    }

    CComPtr< IPin > pInputPin;
    if (FAILED(hr =::FindPin(pFilter2, &pInputPin, PINDIR_INPUT)))
    {
        return hr;
    }

    hr = pGraph->ConnectDirect(pOutputPin, pInputPin, pmt);

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//   Test functions
//
///////////////////////////////////////////////////////////////////////////////
#ifdef USE_DEVENUM
HRESULT EnumerateAudioCapture(
    IBaseFilter ** ppICaptureFilter
    )
{
    LARGE_INTEGER liTicks;
    LARGE_INTEGER liTicks1;
    QueryPerformanceCounter(&liTicks);

    //
    // Create the DirectShow Category enumerator Creator
    //
    CComPtr< ICreateDevEnum > pCreateDevEnum;
    HRESULT hr = CoCreateInstance(
        CLSID_SystemDeviceEnum, NULL, 
        CLSCTX_INPROC_SERVER,
        //__uuidof(ICreateDevEnum), 
        IID_ICreateDevEnum), 
        (void**)&pCreateDevEnum
        );
    if (FAILED(hr))
    {
        return hr;
    }

    CComPtr< IEnumMoniker > pCatEnum;
    hr = pCreateDevEnum->CreateClassEnumerator(
        CLSID_CWaveinClassManager, &pCatEnum, 0
        );

    QueryPerformanceCounter(&liTicks1);
    Log(TEXT("enumerate filter:"), ClockDiff(liTicks1, liTicks));
    if (hr != S_OK)
    {
        return hr;
    }

    //
    // Find the capture filter's Moniker.
    //
    UINT WaveID;
    IMoniker * pMoniker = NULL;
    for (;;)
    {
        ULONG cFetched;
        hr = pCatEnum->Next(1, &pMoniker, &cFetched);
        if (hr != S_OK)
        {
            break;
        }

        CComPtr< IPropertyBag > pBag;
        hr = pMoniker->BindToStorage(0, 0, __uuidof(IPropertyBag), (void **)&pBag);

        if (FAILED(hr))
        {
            pMoniker->Release();
            pMoniker = NULL;
            
            continue;
        }

        VARIANT var;
        var.vt = VT_I4;
        hr = pBag->Read(L"WaveInId", &var, 0);

        if (FAILED(hr))
        {
            pMoniker->Release();
            pMoniker = NULL;
            
            continue;
        }

        WaveID = var.lVal;
        VariantClear(&var);

        // found
        break;
    }

    //
    // create the capture filter.
    //
    CComPtr< IBaseFilter > pCaptureFilter;

//#define USE_DEFAULT
#ifdef USE_DEFAULT
    QueryPerformanceCounter(&liTicks);

    hr = pMoniker->BindToObject(0, 0, IID_IBaseFilter, (void**)&pCaptureFilter);

    QueryPerformanceCounter(&liTicks1);
    Log(TEXT("Bind to object:"), ClockDiff(liTicks1, liTicks));

    pMoniker->Release();

    if (FAILED(hr))
    {
        return hr;
    }
#else

    pMoniker->Release();

    hr = CoCreateInstance(
        CLSID_DSoundCaptureFilter,
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        IID_IBaseFilter),
        (void **)&pCaptureFilter
        );

    if (FAILED(hr))
    {
        return hr;
    }
    
    IAMAudioDeviceConfig *pAudioDeviceConfig;
    hr = pICaptureFilter->QueryInterface(
        IID_IAMAudioDeviceConfig, 
        (void **)&pAudioDeviceConfig
        );

    if (FAILED(hr))
    {
        pICaptureFilter->Release();
        return hr;
    }

    hr = pAudioDeviceConfig->SetDeviceID(GUID_NULL, WaveID);
    pAudioDeviceConfig->Release();

    if (FAILED(hr))
    {
        pICaptureFilter->Release();
        return hr;
    }
#endif

    *ppCaptureFilter = pCaptureFilter;

    return hr;
}
#endif

HRESULT LoadAudioCaptureFilterDLL(
    IN  const TCHAR * const strDllName,
    OUT HMODULE * phModule,
    OUT PFNAudioGetDeviceInfo * ppfnAudioGetDeviceInfo,
    OUT PFNAudioReleaseDeviceInfo * ppfnAudioReleaseDeviceInfo
    )
/*++

Routine Description:

    This method enumerate loads the tapi video capture dll.

Arguments:

    str DllName - The name of the dll.

    phModule - memory to store returned module handle.

    ppfnAudioGetDeviceInfo - memory to store the address of AudioGetDeviceInfo
        function.

    ppfnAudioReleaseDeviceInfo - memory to store the address of 
        AudioReleaseDeviceInfo function.
    
Return Value:

    S_OK    - success.
    E_FAIL  - failure.

--*/
{
    const char * const strAudioGetDeviceInfo = "AudioGetCaptureDeviceInfo";
    const char * const strAudioReleaseDeviceInfo = "AudioReleaseCaptureDeviceInfo";

    // dynamically load the video capture filter dll.
    HMODULE hModule = LoadLibrary(strDllName);

    // validate handle
    if (hModule == NULL) 
    {
        return E_FAIL;
    }

    // retrieve function pointer to retrieve addresses
    PFNAudioGetDeviceInfo pfnAudioGetDeviceInfo 
        = (PFNAudioGetDeviceInfo)GetProcAddress(
                hModule, strAudioGetDeviceInfo
                );

    // validate function pointer
    if (pfnAudioGetDeviceInfo == NULL) 
    {
        FreeLibrary(hModule);

        // failure
        return E_FAIL;
    }

    // retrieve function pointer to retrieve addresses
    PFNAudioReleaseDeviceInfo pfnAudioReleaseDeviceInfo 
        = (PFNAudioReleaseDeviceInfo)GetProcAddress(
                hModule, strAudioReleaseDeviceInfo
                );

    // validate function pointer
    if (pfnAudioReleaseDeviceInfo == NULL) 
    {
        FreeLibrary(hModule);

        // failure
        return E_FAIL;
    }

    *phModule = hModule;
    *ppfnAudioGetDeviceInfo = pfnAudioGetDeviceInfo;
    *ppfnAudioReleaseDeviceInfo = pfnAudioReleaseDeviceInfo;
    
    return S_OK;
}

HRESULT CreateCaptureFilter(
    IN  REFGUID DSoundGUID,
    IN  UINT    WaveID,
    OUT IBaseFilter ** ppCaptureFilter
    )
{
    CComPtr< IBaseFilter > pCaptureFilter;

    HRESULT hr = CoCreateInstance(
        CLSID_DSoundCaptureFilter,
        NULL,
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        IID_IBaseFilter,
        (void **)&pCaptureFilter
        );

    if (FAILED(hr))
    {
        return hr;
    }

    CComPtr< IAMAudioDeviceConfig > pAudioDeviceConfig;
    hr = pCaptureFilter->QueryInterface(
        IID_IAMAudioDeviceConfig,
        (void **)&pAudioDeviceConfig
        );

    if (FAILED(hr))
    {
        pCaptureFilter->Release();
        return hr;
    }

    hr = pAudioDeviceConfig->SetDeviceID(DSoundGUID, WaveID);
    if (FAILED(hr))
    {
        return hr;
    }

    *ppCaptureFilter = pCaptureFilter;
    (*ppCaptureFilter)->AddRef();

    return hr;
}
//#if 0
HRESULT EnumerateAudioCapture(
    OUT IBaseFilter ** ppICaptureFilter
    )
{
    LARGE_INTEGER liTicks;
    LARGE_INTEGER liTicks1;
    QueryPerformanceCounter(&liTicks);

    const TCHAR * const strAudioCaptureDll = TEXT("qcap");

    // dynamically load the audio capture filter dll.
    HMODULE hAudCap;
    PFNAudioGetDeviceInfo pfnAudioGetDeviceInfo;
    PFNAudioReleaseDeviceInfo pfnAudioReleaseDeviceInfo;

    HRESULT hr = LoadAudioCaptureFilterDLL(
        strAudioCaptureDll,
        &hAudCap,
        &pfnAudioGetDeviceInfo,
        &pfnAudioReleaseDeviceInfo
        );

    if (FAILED(hr))
    {
        return hr;
    }

    DWORD dwNumDevices;
    AudioDeviceInfo *pDeviceInfo;

    hr = (*pfnAudioGetDeviceInfo)(&dwNumDevices, &pDeviceInfo);

    QueryPerformanceCounter(&liTicks1);
    Log(TEXT("enumerate filter:"), ClockDiff(liTicks1, liTicks));

    if (FAILED(hr))
    {
        // release library
        FreeLibrary(hAudCap);

        return hr;
    }

    QueryPerformanceCounter(&liTicks);

    hr = CreateCaptureFilter(
        pDeviceInfo[0].DSoundGUID, 
        pDeviceInfo[0].WaveID,
        ppICaptureFilter
        );

    QueryPerformanceCounter(&liTicks1);
    Log(TEXT("Create capture filter:"), ClockDiff(liTicks1, liTicks));

    // release the device info
    (*pfnAudioReleaseDeviceInfo)(pDeviceInfo);

    // release library
    FreeLibrary(hAudCap);

    return hr;
}
//#endif

HRESULT ConfigurePCMFormat(
    IBaseFilter * pCaptureFilter
    )
{
    HRESULT hr;

    CComPtr< IPin > pOutputPin;
    CComPtr< IAMStreamConfig > pStreamConfig;
    AM_MEDIA_TYPE *pMediaType = NULL;
    int iCount = 0; 
    int iSize = 0;

    hr = FindPin(pCaptureFilter, &pOutputPin, PINDIR_OUTPUT);
    if (FAILED(hr)) goto cleanup;

    hr = pOutputPin->QueryInterface(&pStreamConfig);
    if (FAILED(hr)) goto cleanup;

    hr = pStreamConfig->GetNumberOfCapabilities(&iCount, &iSize);
    if (FAILED(hr)) goto cleanup;
    
    AUDIO_STREAM_CONFIG_CAPS caps;
    hr = pStreamConfig->GetStreamCaps(
        iCount -1, // i know the last cap is PCM.
        &pMediaType,
        (BYTE *)&caps );
    if (FAILED(hr)) goto cleanup;
    
    hr = pStreamConfig->SetFormat(
        pMediaType
        );

    MyDeleteMediaType(pMediaType);

cleanup:

    return hr;
}

HRESULT BuildGraph(
    IGraphBuilder ** ppGraphBuilder                   
    )
{
    HRESULT hr;
    LARGE_INTEGER liTicks;
    LARGE_INTEGER liTicks1;

    CComPtr< IBaseFilter > pCaptureFilter;
    CComPtr< IGraphBuilder > pGraph;
    CComPtr< IAMAudioDuplexController > pAudioDuplexController;
    CComPtr< IAMAudioDeviceConfig > pAudioDeviceConfigCapture;
    CComPtr< IAMAudioDeviceControl > pAudioDeviceControl;
    CComPtr< IBaseFilter > pRenderFilter;
    CComPtr< IAMAudioDeviceConfig > pAudioDeviceConfigRender;
    CComPtr< IBaseFilter > pMuxFilter;
    CComPtr< IBaseFilter > pWriter;
    CComPtr< IFileSinkFilter > pFileSinkFilter;

    //
    // Create the filter graph object.
    //
    QueryPerformanceCounter(&liTicks);

    
    hr = CoCreateInstance(
        CLSID_FilterGraph,     
        NULL,
        CLSCTX_INPROC_SERVER,
        __uuidof(IGraphBuilder),
        (void **) &pGraph
        );

    QueryPerformanceCounter(&liTicks1);
    Log(TEXT("Create graph:"), ClockDiff(liTicks1, liTicks));

    if (FAILED(hr))
    {
        goto cleanup;
    }

    //
    // Find the default audio capture filter
    //
    hr = EnumerateAudioCapture(&pCaptureFilter);

    if (FAILED(hr))
    {
        goto cleanup;
    }

    //
    // Add the capture filter into the graph
    //
    QueryPerformanceCounter(&liTicks);
    
    hr = pGraph->AddFilter(pCaptureFilter, TEXT("Capture"));

    QueryPerformanceCounter(&liTicks1);
    Log(TEXT("Add Capture:"), ClockDiff(liTicks1, liTicks));

    if (FAILED(hr))
    {
        goto cleanup;
    }
         
    // configure the capture filter to generate PCM
    hr = ConfigurePCMFormat(pCaptureFilter);
    if (FAILED(hr))
    {
        goto cleanup;
    }
#define AEC 1    
#ifdef AEC    
//// FullDuplex

    hr = CoCreateInstance(
            CLSID_AudioDuplexController,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            IID_IAMAudioDuplexController,
            (void **) &pAudioDuplexController
            );
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pCaptureFilter->QueryInterface( 
                                IID_IAMAudioDeviceConfig,
                                ( void ** ) &pAudioDeviceConfigCapture );
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pAudioDeviceConfigCapture->SetDuplexController( pAudioDuplexController );
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
////    
    
    hr = pCaptureFilter->QueryInterface( 
                                IID_IAMAudioDeviceControl,  
                                ( void ** ) &pAudioDeviceControl );
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pAudioDeviceControl->Set( AudioDevice_AcousticEchoCancellation, TRUE, (AmAudioDeviceControlFlags) 0 );
    if( FAILED( hr ) )
    {
        goto cleanup;
    }
#endif    
    
    //
    // Create and add the render filter into the graph
    //
    hr = AddFilter(
        pGraph,
        CLSID_DSoundRender,
        TEXT("Audio Render"),
        &pRenderFilter
        );

    if (FAILED(hr))
    {
        goto cleanup;
    }
    
#ifdef AEC
    hr = pRenderFilter->QueryInterface( 
                                IID_IAMAudioDeviceConfig, 
                                ( void ** ) &pAudioDeviceConfigRender );
    if (FAILED(hr))
    {
        goto cleanup;
    }
    
    hr = pAudioDeviceConfigRender->SetDuplexController( pAudioDuplexController );
    if (FAILED(hr))
    {
        goto cleanup;
    }
#endif    

//#define FULLDUPLEX
#ifndef FULLDUPLEX
    //
    // Create and add the render filter into the graph
    //
    hr = AddFilter(
        pGraph,
        CLSID_WavDest,
        TEXT("Wav Mux"),
        &pMuxFilter
        );

    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = ConnectFilters(pGraph, pCaptureFilter, pMuxFilter);
    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = AddFilter(
        pGraph,
        CLSID_FileWriter,
        TEXT("File Writer"),
        &pWriter
        );

    if (FAILED(hr))
    {
        goto cleanup;
    }
    hr = pWriter->QueryInterface( IID_IFileSinkFilter, (void **) &pFileSinkFilter );
    if( FAILED( hr ) )
    {
        goto cleanup;
    }
    
    pFileSinkFilter->SetFileName( L"c:\\aectest.wav", NULL );
    if( FAILED( hr ) )
    {
        goto cleanup;
    }
            
    hr = ConnectFilters(pGraph, pMuxFilter, pWriter);
    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pGraph->RenderFile( L"c:\\8k16bitmono.wav", NULL );
    if( FAILED( hr ) )
    {
        goto cleanup;
    }

#endif

#ifdef FULLDUPLEX
    //
    // Connect the capture filter to the render
    //
    hr = ConnectFilters(pGraph, pCaptureFilter, pRenderFilter);

    if (FAILED(hr))
    {
        goto cleanup;
    }
#endif
    *ppGraphBuilder = pGraph;
    pGraph ->AddRef();

cleanup:
    
    return hr;
}

HRESULT GraphTest()
{
    HRESULT hr;
    LARGE_INTEGER liTicks;
    LARGE_INTEGER liTicks1;

    //
    // Connect the graph first.
    //
    CComPtr< IGraphBuilder > pGraphBuilder;
    hr = BuildGraph(&pGraphBuilder);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Obtain the Media control interface on the graph.
    //
    CComPtr< IMediaControl > pMediaControl;
    hr = pGraphBuilder->QueryInterface(
        IID_IMediaControl, 
        (void **) &pMediaControl
        );
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Start the graph.
    //
    QueryPerformanceCounter(&liTicks);

    hr = pMediaControl->Run();

    QueryPerformanceCounter(&liTicks1);
    Log(TEXT("Start graph:"), ClockDiff(liTicks1, liTicks));

    if (FAILED(hr))
    {
        return hr;
    }
    
    printf("\nGraph started. Press any key to stop the graph...\n");
    getchar();

    hr = pMediaControl->Stop();
    
    return hr;
}

int __cdecl
main(int argc, char *argv[])
{
    QueryPerformanceFrequency(&g_liFrequency);

    CoInitializeEx(NULL, COINIT_MULTITHREADED);

    HRESULT hr = GraphTest();

    CoUninitialize();

    DumpLog();

    printf("\nTest returned: %x\nPress any key to continue...\n", hr);
    getchar();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\dsndcap\filter\silence.cpp ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    silence.cpp

Abstract:

    This module implements the silence suppression functionality.

Author:

    Mu Han (muhan) May-15-1999

--*/

#include "stdafx.h"
#include "decg711.h"
#include "encg711.h"

STDMETHODIMP CDSoundCaptureOutputPin::ResetSilenceStats()
{
    m_fSuppressMode         = TRUE;
    m_fAdaptThreshold       = TRUE;
    m_dwThreshold           = THRESHODL_INITIAL;
    m_dwSilentFrameCount    = 0;
    m_dwSoundFrameCount     = 0;
    m_lSampleAverage        = 0;
    m_dwSilenceAverage      = THRESHODL_INITIAL;
    m_dwShortTermSoundAverage = SOUNDCEILING;
    m_dwLongTermSoundAverage  = SOUNDFLOOR;
    m_dwGainIncreaseDelay   = GAININCREASEDELAY;
    m_dwSignalLevel         = 0;

    return S_OK;
}

STDMETHODIMP CDSoundCaptureOutputPin::SetSilenceDetection(IN BOOL fEnable)
{
    m_fSilenceSuppression = fEnable;
    return S_OK;
}

STDMETHODIMP CDSoundCaptureOutputPin::GetSilenceDetection(OUT LPBOOL pfEnable)
{
    ASSERT(!IsBadWritePtr(pfEnable, sizeof(BOOL)));
    
    *pfEnable = m_fSilenceSuppression;

    return S_OK;
}

STDMETHODIMP CDSoundCaptureOutputPin::SetSilenceCompression(IN BOOL fEnable)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDSoundCaptureOutputPin::GetSilenceCompression(OUT LPBOOL pfEnable)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDSoundCaptureOutputPin::GetAudioLevel(
    OUT LPLONG plAudioLevel
    )
{
    ASSERT(!IsBadWritePtr(plAudioLevel, sizeof(LONG)));

    *plAudioLevel = m_dwSignalLevel;

    return S_OK;
}

STDMETHODIMP CDSoundCaptureOutputPin::GetAudioLevelRange(
    OUT LPLONG plMin, 
    OUT LPLONG plMax, 
    OUT LPLONG plSteppingDelta
    )
{
    ASSERT(!IsBadWritePtr(plMin, sizeof(LONG)));
    ASSERT(!IsBadWritePtr(plMax, sizeof(LONG)));
    ASSERT(!IsBadWritePtr(plSteppingDelta, sizeof(LONG)));

    *plMin = 0;
    *plMax = 32768; // the max PCM value.
    *plSteppingDelta = 1;
    
    return S_OK;
}

STDMETHODIMP CDSoundCaptureOutputPin::SetSilenceLevel(
    IN LONG lSilenceLevel,
    IN LONG lFlags
    )
{
    if (lSilenceLevel < 0 || lSilenceLevel > 32768)
    {
        return E_INVALIDARG;
    }
                                   
    m_dwThreshold = lSilenceLevel;
    m_fAdaptThreshold = (lFlags == AmAudioDeviceControl_Flags_Auto);

    return S_OK;
}

STDMETHODIMP CDSoundCaptureOutputPin::GetSilenceLevel(
    OUT LPLONG plSilenceLevel,
    OUT LONG * pFlags
    )
{
    ASSERT(!IsBadWritePtr(plSilenceLevel, sizeof(LONG)));
    ASSERT(!IsBadWritePtr(pFlags, sizeof(AmAudioDeviceControlFlags)));

    *plSilenceLevel = m_dwThreshold;
    *pFlags = (m_fAdaptThreshold) ? AmAudioDeviceControl_Flags_Auto : AmAudioDeviceControl_Flags_Manual;

    return S_OK;
}

STDMETHODIMP CDSoundCaptureOutputPin::GetSilenceLevelRange(
    OUT LPLONG plMin, 
    OUT LPLONG plMax, 
    OUT LPLONG plSteppingDelta, 
    OUT LPLONG plDefault,
    OUT LONG * pFlags
    )
{
    ASSERT(!IsBadWritePtr(plMin, sizeof(LONG)));
    ASSERT(!IsBadWritePtr(plMax, sizeof(LONG)));
    ASSERT(!IsBadWritePtr(plSteppingDelta, sizeof(LONG)));
    ASSERT(!IsBadWritePtr(plDefault, sizeof(LONG)));
    ASSERT(!IsBadWritePtr(pFlags, sizeof(AmAudioDeviceControlFlags)));

    *plMin = 0;
    *plMax = 32768; // the max PCM value.
    *plSteppingDelta = 1;
    *plDefault = THRESHODL_INITIAL;
    *pFlags = AmAudioDeviceControl_Flags_Auto;
    
    return S_OK;
}

void CDSoundCaptureOutputPin::Statistics(
    IN  const BYTE *    pBuffer,
    IN  DWORD           dwSize,
    OUT DWORD *         pdwPeak,
    OUT DWORD *         pdwClipPercent
    )
/*++

Routine Description:

    This function collects the statistics of a buffer of PCM16 sample. It
    return the peak value and the percent of samples clipped.

Arguments:

    pBuffer - the begining of the samples.

    dwSize - the size of the buffer, in bytes.

    pdwPeak - the peak PCM value.

    pdwClipPercent - the percentage of samples clipped.

Return Value:

    S_OK - success

    E_POINTER - bad pointer

--*/
{
    const DWORD CLIP = 32635;

    short *psData = (short*)pBuffer;
   
    DWORD dwPeak = 0;
    DWORD dwClipCount = 0;

    DWORD dwSampleCount = dwSize / 2; 
    for (DWORD i = 0; i < dwSampleCount; i ++)
    {
        // update the average
        m_lSampleAverage = 
            (m_lSampleAverage * (long)(SAMPLEAVERAGEWINDOW - 1) + (psData[i])) 
            / (long)SAMPLEAVERAGEWINDOW;

        // This is needed to remove the DC component from the input signal.
        if (abs(m_lSampleAverage) > DC_THRESHOLD)
        {
            psData[i] = (short)(psData[i] - m_lSampleAverage);
        }

        DWORD dwPCMValue;
        
        // find the absolute value of the sample
        if (psData[i] > 0)
        {
            dwPCMValue = (DWORD)(psData[i]);
        }
        else
        {
            dwPCMValue = (DWORD)(-psData[i]);
        }

        // compare with the current peak.
        if (dwPCMValue > dwPeak)
        {
            dwPeak = dwPCMValue;
        }
        
        // update clip count.
        if (dwPCMValue > CLIP)
        {
            dwClipCount ++;
        }
    }

    if (dwSampleCount > 0)
    {
        *pdwClipPercent = dwClipCount * 100 / dwSampleCount;
    }
    else
    {
        *pdwClipPercent = 0;
    }

    *pdwPeak = dwPeak;

    // remember the signal level in case the user wants to know.
    m_dwSignalLevel = dwPeak;
}

DWORD CalculateThreshold(
    IN DWORD dwBase,
    IN BYTE bAdjustment
    )
/*++

Routine Description:

    This method calculates the threshold. The base value is a 16bit linear PCM
    value. The adjustment is an 8-bit value. The PCM is converted to mulaw, 
    adjusted by the 8-bit value and then converted back to PCM. The idea of 
    this method is to use the log nature of mulaw to achieve log-based 
    adjustment on PCM values.

Arguments:

    dwBase - the base PCM value. must be positive.

    bAdjustment - the adjustment. must be between 0 and 0x7f.

Return Value:

    The adjusted value.

--*/
{
    ASSERT(bAdjustment < 0x7f);

    // first convert the linear PCM value to mulaw(log based).
    BYTE bMulaw = PcmToMuLaw((WORD)dwBase);
    
    // positive PCM values maps to mulaw values from 0x80 to 0xff.
    ASSERT(bMulaw > 0x7f);

    // bigger PCM value maps to smaller mulaw value, thus the -.
    bMulaw -= bAdjustment;

    // make sure it is still in the range.
    if (bMulaw < 0x80)
    {
        bMulaw = 0x80;
    }

    return UlawToPcmTable[bMulaw];
}

DWORD CDSoundCaptureOutputPin::Classify(
    IN DWORD dwPeak
    )
/*++

Routine Description:

    This function decides whether the packet is silence or voice. It maitains
    a state machine(silence/voice) based on the sample's energy. The running
    average of the silence packets' peak value is calculated and remembered.
    The threshold is derived from this running average.

Arguments:

    dwPeak - the peak PCM value in a packet.

Return Value:

    TR_STATUS_SILENCE - the packet contains only silence.
    TR_STATUS_TALK - the packet contains voice.
    (TR_STATUS_TALK | TR_STATUS_TALKSTART) - beginning of voice.
    (TR_STATUS_TALK | TR_STATUS_TALKEND) - end of voice.
--*/
{
    if (m_fSuppressMode)
    {
        //
        // We are in silent suppression mode now. If there is a sound frame,
        // the frame will be sent and the mode will be changed to non-suppress
        // mode. If there is a silence frame, it is suppressed.
        // 
        DbgLog((LOG_TRACE, TRACE_LEVEL_DETAILS, " 100 %8d %8d %8d %8d %8d %8d %8d", 
            dwPeak, 
            m_dwThreshold, 
            m_dwSilenceAverage, 
            m_dwShortTermSoundAverage, 
            m_dwLongTermSoundAverage, 
            abs(m_lSampleAverage), 
            (DWORD)(m_GainFactor * 1000)
            ));

        if (dwPeak > m_dwThreshold)
        {
            // we found a sound sample
    
            m_fSuppressMode = FALSE;

            m_dwSilentFrameCount = 0;
            m_dwSoundFrameCount = 1;

            m_dwShortTermSoundAverage = m_dwShortTermSoundAverage * 
                (SHORTTERMSOUNDAVERAGEWINDOW - 1) / SHORTTERMSOUNDAVERAGEWINDOW 
                + dwPeak / SHORTTERMSOUNDAVERAGEWINDOW;

            m_dwLongTermSoundAverage = m_dwLongTermSoundAverage * 
                (LONGTERMSOUNDAVERAGEWINDOW - 1) / LONGTERMSOUNDAVERAGEWINDOW 
                + dwPeak / LONGTERMSOUNDAVERAGEWINDOW;

            return (TR_STATUS_TALK | TR_STATUS_TALKSTART);
        }
        else
        {
            m_dwSilenceAverage = m_dwSilenceAverage * 
                (SILENCEAVERAGEWINDOW - 1) / SILENCEAVERAGEWINDOW 
                + dwPeak / SILENCEAVERAGEWINDOW;

            if (m_fAdaptThreshold)
            {
                m_dwThreshold  = CalculateThreshold(m_dwSilenceAverage, (BYTE)THRESHOLD_DELTA);
            }

            return TR_STATUS_SILENCE;
        }
    }

    //
    // We are in non-suppress mode now. If there is a sound frame,
    // just play it. If there are a number of continues silence, the mode
    // will be switched to suppress mode.
    // 
    DbgLog((LOG_TRACE, TRACE_LEVEL_DETAILS, "1000 %8d %8d %8d %8d %8d %8d %8d", 
        dwPeak, 
        m_dwThreshold, 
        m_dwSilenceAverage, 
        m_dwShortTermSoundAverage, 
        m_dwLongTermSoundAverage, 
        abs(m_lSampleAverage), 
        (DWORD)(m_GainFactor * 1000)
        ));

    if (dwPeak > m_dwThreshold)
    {
        // another sound frame.
        m_dwSilentFrameCount = 0;
        m_dwSoundFrameCount ++;

        if (m_dwSoundFrameCount > THRESHOLD_TIMETOADJUST)
        {
            if (m_fAdaptThreshold)
            {
                // Addjust the threshold when there are too many sound frames
                // without a gap.
                m_dwThreshold = CalculateThreshold(m_dwThreshold, (BYTE)THRESHODL_ADJUSTMENT);

                if (m_dwThreshold > THRESHODL_MAX)
                {
                    m_dwThreshold = THRESHODL_MAX;
                }
            }

            m_dwSoundFrameCount = 1;
        }

        m_dwShortTermSoundAverage = m_dwShortTermSoundAverage * 
            (SHORTTERMSOUNDAVERAGEWINDOW - 1) / SHORTTERMSOUNDAVERAGEWINDOW 
            + dwPeak / SHORTTERMSOUNDAVERAGEWINDOW;

        m_dwLongTermSoundAverage = m_dwLongTermSoundAverage * 
            (LONGTERMSOUNDAVERAGEWINDOW - 1) / LONGTERMSOUNDAVERAGEWINDOW 
            + dwPeak / LONGTERMSOUNDAVERAGEWINDOW;

    }
    else
    {
        // We got a silent frame within sound frames.
        m_dwSilentFrameCount ++;
        m_dwSoundFrameCount = 0;

        m_dwSilenceAverage = m_dwSilenceAverage * 
            (SILENCEAVERAGEWINDOW - 1) / SILENCEAVERAGEWINDOW 
            + dwPeak / SILENCEAVERAGEWINDOW;

        if (m_fAdaptThreshold)
        {
            m_dwThreshold  = CalculateThreshold(m_dwSilenceAverage, (BYTE)THRESHOLD_DELTA);
        }

        if (m_dwSilentFrameCount > FILLINCOUNT)
        {
            // We have got enough silent frames. Switch to suppress mode for the
            // next packet.
            m_fSuppressMode = TRUE;
            return (TR_STATUS_TALK | TR_STATUS_TALKEND);
        }
    }

    return TR_STATUS_TALK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\eq\eqprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// This class implements the property page for the equalizer filter

class CEqualizerProperties : public CBasePropertyPage
{

public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

private:

    BOOL OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void SetDirty();

    void	OnSliderNotification(WPARAM wParam, LPARAM lParam);

    void FixSliders();
    void UpdateSliders();

    CEqualizerProperties(LPUNKNOWN lpunk, HRESULT *phr);
    signed char m_cEqualizerOnExit; // Remember equalizer level for CANCEL
    signed char m_cEqualizerLevel;  // And likewise for next activate

    IEqualizer *m_pEqualizer;

    int m_Levels[10];
    int m_Settings[10];
    int m_SettingsOnExit[10];
    int m_nBands;
    
    IEqualizer *pIEqualizer() {
        ASSERT(m_pEqualizer);
        return m_pEqualizer;
    };

}; // CEqualizerProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\eq\eqprop.cpp ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
// This class implements the property page for the equalizer filter

// Things to do:  (DavidMay 10/98)
// better support for #bands != 10  (space equally, or something)
// label bands by frequency
//


#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include "resource.h"
#include "ieqfilt.h"


// This class implements the property page for the equalizer filter

class CEqualizerProperties : public CBasePropertyPage
{

public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

private:

    BOOL OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    void SetDirty();

    void	OnSliderNotification(WPARAM wParam, LPARAM lParam);

    void FixSliders();
    void UpdateSliders();

    CEqualizerProperties(LPUNKNOWN lpunk, HRESULT *phr);
    signed char m_cEqualizerOnExit; // Remember equalizer level for CANCEL
    signed char m_cEqualizerLevel;  // And likewise for next activate

    IEqualizer *m_pEqualizer;

    int m_Levels[10];
    int m_Settings[10];
    int m_SettingsOnExit[10];
    int m_nBands;
    
    IEqualizer *pIEqualizer() {
        ASSERT(m_pEqualizer);
        return m_pEqualizer;
    };

}; // CEqualizerProperties




//
// CreateInstance
//
// This goes in the factory template table to create new filter instances
//
CUnknown * WINAPI CEqualizerProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CEqualizerProperties(lpunk, phr);
    if (punk == NULL) {
	*phr = E_OUTOFMEMORY;
    }
    return punk;

} // CreateInstance


//
// Constructor
//
CEqualizerProperties::CEqualizerProperties(LPUNKNOWN pUnk, HRESULT *phr) :
    CBasePropertyPage(NAME("Equalizer Property Page"),pUnk,
                      IDD_EQUALIZERPROP,
                      IDS_TITLE),
    m_pEqualizer(NULL)
{
    InitCommonControls();

} // (Constructor)


//
// SetDirty
//
// Sets m_bDirty and notifies the property page site of the change
//
void CEqualizerProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite) {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }

} // SetDirty


//
// OnReceiveMessage
//
// Virtual method called by base class with Window messages
//
BOOL CEqualizerProperties::OnReceiveMessage(HWND hwnd,
                                           UINT uMsg,
                                           WPARAM wParam,
                                           LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
	    FixSliders();
	    SetTimer(m_Dlg, 1, 50, NULL);
	    
            return (LRESULT) 1;
        }
        case WM_VSCROLL:
        {
	    OnSliderNotification(wParam, lParam);
            return (LRESULT) 1;
        }

        case WM_COMMAND:
        {
	    if (LOWORD(wParam) == IDB_DEFAULT)
            {
	        pIEqualizer()->put_DefaultEqualizerSettings();
	        FixSliders();
                SetDirty();
	    } else if (LOWORD(wParam) == IDC_BYPASS)
            {
		pIEqualizer()->put_BypassEqualizer(
				IsDlgButtonChecked(m_Dlg, IDC_BYPASS));
		
		SetDirty();
	    }
            return (LRESULT) 1;
        }

        case WM_DESTROY:
        {
	    KillTimer(m_hwnd, 1);
	    
            return (LRESULT) 1;
        }

	case WM_TIMER:
	{
	    UpdateSliders();
	}

    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);

} // OnReceiveMessage


//
// OnConnect
//
// Called when the property page connects to a filter
//
HRESULT CEqualizerProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pEqualizer == NULL);

    HRESULT hr = pUnknown->QueryInterface(IID_IEqualizer, (void **) &m_pEqualizer);
    if (FAILED(hr)) {
        return E_NOINTERFACE;
    }

    ASSERT(m_pEqualizer);

    // Get the initial equalizer value
    m_pEqualizer->get_EqualizerSettings(&m_nBands, m_Settings);

    ASSERT(m_nBands <= 10); // !!!!
    
    CopyMemory(m_SettingsOnExit, m_Settings, sizeof(m_Settings));

    FixSliders();

    return NOERROR;

} // OnConnect


//
// OnDisconnect
//
// Called when we're disconnected from a filter
//
HRESULT CEqualizerProperties::OnDisconnect()
{
    // Release of Interface after setting the appropriate equalizer value

    if (m_pEqualizer == NULL) {
        return E_UNEXPECTED;
    }

    if (m_bDirty) {
	// revert to original levels
	m_pEqualizer->put_EqualizerSettings(m_nBands, m_SettingsOnExit);
    }
    m_pEqualizer->Release();
    m_pEqualizer = NULL;
    return NOERROR;

} // OnDisconnect


//
// OnDeactivate
//
// We are being deactivated
//
HRESULT CEqualizerProperties::OnDeactivate(void)
{
    // Remember the present equalizer level for the next activate

    // !!! pIEqualizer()->get_EqualizerLevel(&m_cEqualizerLevel);
    return NOERROR;

} // OnDeactivate


//
// OnApplyChanges
//
// Changes made should be kept. Change the m_cEqualizerOnExit variable
//
HRESULT CEqualizerProperties::OnApplyChanges()
{
    CopyMemory(m_SettingsOnExit, m_Settings, sizeof(m_Settings));
    m_bDirty = FALSE;
    return(NOERROR);

} // OnApplyChanges


//
// CreateSlider
//
// Create the slider (common control) to allow the user to adjust equalizer
//
void CEqualizerProperties::FixSliders()
{
    if (!pIEqualizer())
	return;

    BOOL fBypass = FALSE;
    pIEqualizer()->get_BypassEqualizer(&fBypass);
    CheckDlgButton(m_Dlg, IDC_BYPASS, fBypass);
   
    for (int i = 0; i < m_nBands; i++) {
	HWND hwndSlider = GetDlgItem(m_Dlg, IDC_TRACKBAR1 + i);
	
	// Set the initial range for the slider
	SendMessage(hwndSlider, TBM_SETRANGE, FALSE, MAKELONG(0, MAX_EQ_LEVEL) );

	// Set a tick at zero
	// SendMessage(hwndSlider, TBM_SETTIC, 0, 0L);

	// Set the initial slider position
	SendMessage(hwndSlider, TBM_SETPOS, FALSE, MAX_EQ_LEVEL - m_Settings[i]);
    }

    

    for ( ; i < 10; i++) {
	HWND hwndSlider = GetDlgItem(m_Dlg, IDC_TRACKBAR1 + i);
	
	ShowWindow(hwndSlider, SW_HIDE);
    }
    
    // read the current device levels
    UpdateSliders();
}

void CEqualizerProperties::UpdateSliders()
{
    if (!pIEqualizer())
	return;

    
    HRESULT hr = pIEqualizer()->get_EqualizerLevels(m_nBands, m_Levels);
    if (FAILED(hr))
	return;

    
    // Set the current levels
    for (int i = 0; i < m_nBands; i++) {
	SendMessage(GetDlgItem(m_Dlg, IDC_TRACKBAR1 + i),
		    TBM_SETSEL, TRUE, MAKELONG(MAX_EQ_LEVEL - m_Levels[i],
					       MAX_EQ_LEVEL));
    }
} // FixSliders


//
// OnSliderNotification
//
// Handle the notification messages from the slider control
//
void CEqualizerProperties::OnSliderNotification(WPARAM wParam, LPARAM lParam)
{
    HWND hwndSlider = (HWND) lParam;
    for (int i = 0; i < m_nBands; i++) {
	if (hwndSlider == GetDlgItem(m_Dlg, IDC_TRACKBAR1 + i))
	    break;
    }

    if (i >= m_nBands)
	return;

    switch (wParam) {
        case TB_BOTTOM:
            SetDirty();
	    SendMessage(hwndSlider, TBM_SETPOS, TRUE, (LPARAM) 0);
	    break;

        case TB_TOP:
            SetDirty();
    	    SendMessage(hwndSlider, TBM_SETPOS, TRUE, (LPARAM) MAX_EQ_LEVEL);
            break;

        case TB_PAGEDOWN:
        case TB_PAGEUP:
            break;

        case TB_THUMBPOSITION:
        case TB_ENDTRACK:
        {
                SetDirty();
                m_Settings[i] = MAX_EQ_LEVEL -
				    (int) SendMessage(hwndSlider, TBM_GETPOS, 0, 0L);
		pIEqualizer()->put_EqualizerSettings(m_nBands, m_Settings);
        }
	break;

        // Default handling of these messages is ok
        case TB_THUMBTRACK:
        case TB_LINEDOWN:
        case TB_LINEUP:
	    break;
    }

} // OnSliderNotification
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\nullwave\makefile.inc ===
# NOTE:
# this directory contains a makefile which contains a single line that
# includes the global build process makefile.def. If the
# NTTARGETFILE1 or NTTARGETFILE0 environment
# variable is set then makefile.def includes makefile.inc from the current
# directory. This makefile.inc creates an extra target for nmake to create
# when it is run. NTTARGETFILE0 is built before everything else, and
# NTTARGETFILE1 is built after everything else.

copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll     \
         $(SDK_ROOT)\bin\*.*
  @if not exist $(QUARTZ)\lib\$(TARGET_DIRECTORY) \
    md $(QUARTZ)\lib\$(TARGET_DIRECTORY)
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).lib     \
         $(QUARTZ)\lib\$(TARGET_DIRECTORY)\*.*


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\eq\ieqfilt.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// A custom interface to allow the user to adjust the equalizer level.

#ifndef __IEQUALIZER__
#define __IEQUALIZER__

// The CLSID's used by the Equalizer filter

//
// Equalizer Filter Object
//
// {20291AC1-5931-11d2-A521-00A0D10129C0}
DEFINE_GUID(CLSID_Equalizer,
0x20291ac1, 0x5931, 0x11d2, 0xa5, 0x21, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);

//
// Equalizer Property Page
//
// {20291AC2-5931-11d2-A521-00A0D10129C0}
DEFINE_GUID(CLSID_EqualizerPropertyPage,
0x20291ac2, 0x5931, 0x11d2, 0xa5, 0x21, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);

#define MAX_EQ_LEVEL		100
#define DEF_EQ_LEVEL		50


#ifdef __cplusplus
extern "C" {
#endif

    // {20291AC0-5931-11d2-A521-00A0D10129C0}
    DEFINE_GUID(IID_IEqualizer,
    0x20291ac0, 0x5931, 0x11d2, 0xa5, 0x21, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);

    DECLARE_INTERFACE_(IEqualizer, IUnknown)
    {
        STDMETHOD(get_EqualizerLevels) (THIS_
	    int nBands,
            int EqualizerLevels[]      // The current equalizer level
        ) PURE;

        STDMETHOD(get_EqualizerSettings) (THIS_
			int *nBands,
			int BandLevel[]) PURE;

        STDMETHOD(put_EqualizerSettings) (THIS_
			int nBands,
			int BandLevel[]) PURE;

        STDMETHOD(put_DefaultEqualizerSettings) (THIS) PURE;

        STDMETHOD(get_EqualizerFrequencies) (THIS_
			int *nBands,
			int BandFrequencies[]) PURE;

        STDMETHOD(get_BypassEqualizer) (THIS_  BOOL *pfBypass) PURE;
        STDMETHOD(put_BypassEqualizer) (THIS_  BOOL fBypass) PURE;
    };

#ifdef __cplusplus
}
#endif

#endif // __IEQUALIZER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\eq\resource.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by eqprop.rc
//
#define IDD_EQUALIZERPROP               101
#define IDC_EQUALIZER                   1000
#define IDB_DEFAULT                     1001
#define IDS_TITLE                       1002
#define IDC_TRACKBAR1                   1003
#define IDC_TRACKBAR2                   1004
#define IDC_TRACKBAR3                   1005
#define IDC_TRACKBAR4                   1006
#define IDC_TRACKBAR5                   1007
#define IDC_TRACKBAR6                   1008
#define IDC_TRACKBAR7                   1009
#define IDC_TRACKBAR8                   1010
#define IDC_TRACKBAR9                   1011
#define IDC_TRACKBAR10                  1012
#define IDC_BYPASS                      1013
#define IDS_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\eq\fft.cpp ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
// FFT routine, from Jay Stokes (dsplib)

#include <streams.h>
#include <math.h>

#define M_PI 3.14159265358979
#define K2    0.70710678118655f

#include "fft.h"

float *pSinTable;

void 
CFloatFft_realCore(
    float *input,
    float *x, 
    long n, 
    long m, 
    float *wi );
void 
CFloatFft_realInverseCore(
    float* x, 
    long n, 
    long m, 
    float* wi );
void 
CFloatFft_computeTwiddleFactors(
    long n, 
    float* wi );


HRESULT ComputeFFT(float *pInput, float *pOutput, BOOL fInverse)
{
    ASSERT((1 << LOG_FFT_SIZE) == FFT_SIZE);
    
    if (!pSinTable) {
	pSinTable = new float[FFT_SIZE * 2];
	if (!pSinTable)
	    return E_OUTOFMEMORY;
	CFloatFft_computeTwiddleFactors(FFT_SIZE, pSinTable);
    }

    if (!fInverse) {
	CFloatFft_realCore( pInput, 
                        pOutput,
                        FFT_SIZE, 
                        LOG_FFT_SIZE, 
                        pSinTable);
    } else {
	CopyMemory(pOutput, pInput, sizeof(float) * FFT_SIZE);
	CFloatFft_realInverseCore(
                        pOutput,
                        FFT_SIZE, 
                        LOG_FFT_SIZE, 
                        pSinTable);
    }

    /* Unwrap the results which are returned as          */
    /* (Re[0], Re[1], ... Re[n/2], Im[n/2 - 1]...Im[1])  */
    
    return S_OK ;
}




/**************************************************************************/
/*                                                                        */
/* Local method                                                           */
/*                                                                        */
/**************************************************************************/

/************************************************************************
 *                                                                      *
 *    This subroutine computes a split-radix FFT for real data          *
 *    It is a C version of the FORTRAN program in "Real-Valued          *
 *    Fast Fourier Transform Algorithms" by H. Sorensen et al.          *
 *    in Trans. on ASSP, June 1987, pp. 849-863. It uses half           *
 *    of the operations than its counterpart for complex data.          *
 *                                                                      *
 *    Length is n = 2^(m). Decimation in time. Result is in place.      *
 *    It uses table look-up for the trigonometric functions.            *
 *    Input order:                                                      *
 *    (x[0], x[1], ... x[n - 1])                                        *
 *    Ouput order:                                                      *
 *    (Re[0], Re[1], ... Re[n/2], Im[n/2 - 1]...Im[1])                  *
 *    The output transform exhibit hermitian symmetry (i.e. real        *
 *    part of transform is even while imaginary part is odd).           *
 *    Hence Im[0] = Im[n/2] = 0; and n memory locations suffice.        *
 *                                                                      *
 *                                                                      *
 ************************************************************************/

void 
CFloatFft_realCore(
    float *input,
    float *x, 
    long n, 
    long m, 
    float *wi )
{
    long  n1, n2, n4, n8, i0, i1, i2, i3, i4, i5, i6, i7, i8;
    long  is, id, i, j, k, ia, ie, ia3;
    float xt, t1, t2, t3, t4, t5, t6, *wr, r1, cc1, cc3, ss1, ss3;

    wr = wi + (n / 2);

    /* digit reverse counter */
    j = 0;
    n1 = n - 1;
    for (i = 0; i < n1; i++) {
        if (i < j) {
            xt = input[j];
            x[j] = input[i];
            x[i] = xt;
        }
        else if (i == j)
        {
            x[j] = input[i];
        }
        k = n / 2;
        while (k <= j) {
            j -= k;
            k /= 2;
        }
        j += k;
    }
    x[n1] = input[n1];

    /* length two butterflies */
    is = 0;
    id = 4;
    while (is < n - 1) {
        for (i0 = is; i0 < n; i0 += id) {
            i1 = i0 + 1;
            r1 = x[i0];
            x[i0] = r1 + x[i1];
            x[i1] = r1 - x[i1];
        }
        is = 2 * (id - 1);
        id = 4 * id;
    }

    /* L shaped butterflies */
    n2 = 2;
    ie = n;
    for (k = 1; k < m; k++) {
        n2 = n2 * 2;
        n4 = n2 / 4;
        n8 = n2 / 8;
        ie /= 2;
        is = 0;
        id = 2 * n2;
        while (is < n) {
            for (i = is; i < n; i += id) {
                i1 = i;
                i2 = i1 + n4;
                i3 = i2 + n4;
                i4 = i3 + n4;
                t1 = x[i4] + x[i3];
                x[i4] = x[i4] - x[i3];
                x[i3] = x[i1] - t1;
                x[i1] = x[i1] + t1;
                if (n4 > 1) {
                    i1 = i1 + n8;
                    i2 = i2 + n8;
                    i3 = i3 + n8;
                    i4 = i4 + n8;
                    t1 = K2 * (x[i3] + x[i4]);
                    t2 = K2 * (x[i3] - x[i4]);
                    x[i4] = x[i2] - t1;
                    x[i3] = - x[i2] - t1;
                    x[i2] = x[i1] - t2;
                    x[i1] = x[i1] + t2;
                }
            }
            is = 2 * id - n2;
            id = 4 * id;
        }
        ia = 0;
        for (j = 1; j < n8; j++) {
            ia += ie;
            ia3 = 3 * ia;
            cc1 = wr[ia];
            ss1 = wi[ia];
            cc3 = wr[ia3];
            ss3 = wi[ia3];
            is = 0;
            id = 2 * n2;
            while (is < n) {
                for (i = is; i < n; i += id) {
                    i1 = i + j;
                    i2 = i1 + n4;
                    i3 = i2 + n4;
                    i4 = i3 + n4;
                    i5 = i + n4 - j;
                    i6 = i5 + n4;
                    i7 = i6 + n4;
                    i8 = i7 + n4;
                    t1 = x[i3] * cc1 + x[i7] * ss1;
                    t2 = x[i7] * cc1 - x[i3] * ss1;
                    t3 = x[i4] * cc3 + x[i8] * ss3;
                    t4 = x[i8] * cc3 - x[i4] * ss3;
                    t5 = t1 + t3;
                    t6 = t2 + t4;
                    t3 = t1 - t3;
                    t4 = t2 - t4;
                    t2 = x[i6] + t6;
                    x[i3] = t6 - x[i6];
                    x[i8] = t2;
                    t2 = x[i2] - t3;
                    x[i7] = - x[i2] - t3;
                    x[i4] = t2;
                    t1 = x[i1] + t5;
                    x[i6] = x[i1] - t5;
                    x[i1] = t1;
                    t1 = x[i5] + t4;
                    x[i5] = x[i5] - t4;
                    x[i2] = t1;
                }
                is = 2 * id - n2;
                id = 4 * id;
            }
        }
    }
}





/************************************************************************
 *                                                                      *
 *    This subroutine computes a split-radix IFFT for real data         *
 *    It is a C version of the FORTRAN program in "Real-Valued          *
 *    Fast Fourier Transform Algorithms" by H. Sorensen et al.          *
 *    in Trans. on ASSP, June 1987, pp. 849-863. It uses half           *
 *    of the operations than its counterpart for complex data.          *
 *                                                                      *
 *    Length is n = 2^(m). Decimation in frequency. Result is           *
 *    in place. It uses table look-up for the trigonometric             *
 *    functions.                                                        *
 *    Input order:                                                      *
 *    (Re[0], Re[1], ... Re[n/2], Im[n/2 - 1]...Im[1])                  *
 *    Output order:                                                     *
 *    (x[0], x[1], ... x[n - 1])                                        *
 *    The output transform exhibit hermitian symmetry (i.e. real        *
 *    part of transform is even while imaginary part is odd).           *
 *    Hence Im[0] = Im[n/2] = 0; and n memory locations suffice.        *
 *                                                                      *
 ************************************************************************/

void 
CFloatFft_realInverseCore(
    float* x, 
    long n, 
    long m, 
    float* wi )
{
    long   n1, n2, n4, n8, i0, i1, i2, i3, i4, i5, i6, i7, i8;
    long   is, id, i, j, k, ie, ia, ia3;
    float  xt, t1, t2, t3, t4, t5, *wr, r1, cc1, cc3, ss1, ss3;

    wr = wi + (n / 2);

    /* L shaped butterflies */
    n2 = 2 * n;
    ie = 1;
    for (k = 1; k < m; k++) {
        is = 0;
        id = n2;
        n2 = n2 / 2;
        n4 = n2 / 4;
        n8 = n4 / 2;
        ie *= 2;
        while (is < n - 1) {
            for (i = is; i < n; i += id) {
                i1 = i;
                i2 = i1 + n4;
                i3 = i2 + n4;
                i4 = i3 + n4;
                t1 = x[i1] - x[i3];
                x[i1] = x[i1] + x[i3];
                x[i2] = 2 * x[i2];
                x[i3] = t1 - 2 * x[i4];
                x[i4] = t1 + 2 * x[i4];
                if (n4 > 1) {
                    i1 = i1 + n8;
                    i2 = i2 + n8;
                    i3 = i3 + n8;
                    i4 = i4 + n8;
                    t1 = K2 * (x[i2] - x[i1]);
                    t2 = K2 * (x[i4] + x[i3]);
                    x[i1] = x[i1] + x[i2];
                    x[i2] = x[i4] - x[i3];
                    x[i3] = - 2 * (t1 + t2);
                    x[i4] = 2 * (t1 - t2);
                }
            }
            is = 2 * id - n2;
            id = 4 * id;
        }
        ia = 0;
        for (j = 1; j < n8; j++) {
            ia += ie;
            ia3 = 3 * ia;
            cc1 = wr[ia];
            ss1 = wi[ia];
            cc3 = wr[ia3];
            ss3 = wi[ia3];
            is = 0;
            id = 2 * n2;
            while (is < n - 1) {
                for (i = is; i < n; i += id) {
                    i1 = i + j;
                    i2 = i1 + n4;
                    i3 = i2 + n4;
                    i4 = i3 + n4;
                    i5 = i + n4 - j;
                    i6 = i5 + n4;
                    i7 = i6 + n4;
                    i8 = i7 + n4;
                    t1 = x[i1] - x[i6];
                    x[i1] = x[i1] + x[i6];
                    t2 = x[i5] - x[i2];
                    x[i5] = x[i2] + x[i5];
                    t3 = x[i8] + x[i3];
                    x[i6] = x[i8] - x[i3];
                    t4 = x[i4] + x[i7];
                    x[i2] = x[i4] - x[i7];
                    t5 = t1 - t4;
                    t1 = t1 + t4;
                    t4 = t2 - t3;
                    t2 = t2 + t3;
                    x[i3] = t5 * cc1 + t4 * ss1;
                    x[i7] = - t4 * cc1 + t5 * ss1;
                    x[i4] = t1 * cc3 - t2 * ss3;
                    x[i8] = t2 * cc3 + t1 * ss3;
                }
                is = 2 * id - n2;
                id = 4 * id;
            }
        }
    }

    /* length two butterflies */
    is = 0;
    id = 4;
    while (is < n - 1) {
        for (i0 = is; i0 < n; i0 += id) {
            i1 = i0 + 1;
            r1 = x[i0];
            x[i0] = r1 + x[i1];
            x[i1] = r1 - x[i1];
        }
        is = 2 * (id - 1);
        id = 4 * id;
    }

    /* digit reverse counter */
    j = 0;
    n1 = n - 1;
    for (i = 0; i < n1; i++) {
        if (i < j) {
            xt = x[j];
            x[j] = x[i];
            x[i] = xt;
        }
        k = n / 2;
        while (k <= j) {
            j -= k;
            k /= 2;
        }
        j += k;
    }
    for (i = 0; i < n; i++)
        x[i] /= n;
}




/************************************************************************
 *                                                                      *
 *    This routine produces 2*n samples of a sin() for a full           *
 *    period: i.e sin(pi*k/n). It is used in fft computations.          *
 *    Actually only a quarter period is computed, filling the           *
 *    rest by symmetries.                                               *
 *                                                                      *
 ************************************************************************/


void 
CFloatFft_computeTwiddleFactors(
    long n, 
    float* wi )
{
    long k;
    float a;
    double p;

    p = M_PI / n;
    wi[0] = 0.0f;
    wi[n] = 0.0f;

    for (k = 1; k < n / 2; k++) {
        a = (float) sin (k * p);
        wi[k] = a;
        wi[n - k] = a;
        wi[n + k] = - a;
        wi[2 * n - k] = - a;
    }

    wi[n / 2] = 1.0f;
    wi[3 * n / 2] = - 1.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\nullwave\bsicaud.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// Implements audio control interface

#ifndef __BSAUDCTL__
#define __BSAUDCTL__

// OLE Automation has different ideas of TRUE and FALSE

#define OATRUE (-1)
#define OAFALSE (0)

// This class implements the IBasicAudio interface

#define QZ_MIN_VOLUME 0		// mute
#define QZ_MAX_VOLUME 0xFFFF	// full on

class CNullBasicAudioControl : public CBasicAudio
{
    CNullWaveOutFilter *m_pAudioRenderer;         // The renderer that owns us

public:

    CNullBasicAudioControl(TCHAR *pName,               // Object description
                  LPUNKNOWN pUnk,             // Normal COM ownership
                  HRESULT *phr,               // OLE failure return code
                  CNullWaveOutFilter *pAudioRenderer); // our owner

    // These are the properties we support

    STDMETHODIMP get_Volume(long *plVolume);
    STDMETHODIMP put_Volume(long lVolume);

    STDMETHODIMP get_Balance(long *plBalance);
    STDMETHODIMP put_Balance(long lBalance);

    // And these are the methods for our friend classes - no parameter validation
    friend class CNullWaveOutFilter;

private:
    STDMETHODIMP GetVolume(long *plVolume);
    STDMETHODIMP PutVolume();
    STDMETHODIMP GetBalance(long *plBalance);
    STDMETHODIMP PutBalance();

    // volume is in the range -10000 to 0 (100th DB units)
    // amplitude and Balance are cumulative
    LONG        m_lVolume;
    LONG        m_lBalance;

    WORD	m_wLeft;     		// Left channel volume
    WORD	m_wRight;		// Right channel volume
};

#endif // __BSAUDCTL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\eq\fft.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
const int LOG_FFT_SIZE = 10;
const int FFT_SIZE = 1024;

HRESULT ComputeFFT(float *pInput, float *pOutput, BOOL fInverse);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\eq\testfft.cpp ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#include <stdio.h>
#include "fft.cpp"

void PrintBuf(char * label, float *buf)
{
    float min, max;
    min = max = buf[0];

    for (int i = 0; i < FFT_SIZE; i++) {
	if (min > buf[i])
	    min = buf[i];

	if (max < buf[i])
	    max = buf[i];
    }

    printf("%s: min=%4.2f max=%4.2f   data = %4.2f %4.2f %4.2f %4.2f %4.2f\n",
    	   label, min, max, buf[0], buf[1], buf[2], buf[3], buf[4]);
}

void PrintTwo(char * label1, float *buf1, char * label2, float *buf2)
{
    printf("%s, %s\n", label1, label2);

    for (int i = 0; i < FFT_SIZE; i++) {
	printf("%4.2f, %4.2f\n", buf1[i], buf2[i]);
    }

    printf("\n");
}

void PrintLevels(char *label, float *buf)
{
    float levels[8];
    int i = 0;
    for (int lev = 0; lev < 8; lev++) {
	levels[lev] = 0;

	for (int j = 0; j < (FFT_SIZE / (2 * 8)); j++) {
	    levels[lev] += buf[i++];
	}
	levels[lev] /= (FFT_SIZE / (2 * 8));
    }

    printf("%s: %6.1f %6.1f %6.1f %6.1f %6.1f %6.1f %6.1f %6.1f \n",
	   label, levels[0], levels[1], levels[2], levels[3],
			    levels[4], levels[5], levels[6], levels[7]);

}

void TestFFT(float *buf, BOOL verbose = FALSE)
{
    float buf2[FFT_SIZE];
    float buf3[FFT_SIZE];

    ComputeFFT(buf, buf2, FALSE);
    ComputeFFT(buf2, buf3, TRUE);

    float bufdiff[FFT_SIZE];
    for (int i = 0; i < FFT_SIZE; i++) {
	bufdiff[i] = buf3[i] - buf[i];
    }

    if (verbose) {
	PrintBuf("original", buf);
	PrintBuf("fft     ", buf2);
	PrintBuf("inverse ", buf3);
	PrintBuf("diff    ", bufdiff);
    }
    
    PrintLevels("levels", buf2);
}

void ShowWholeFFT(float *buf, BOOL verbose = FALSE)
{
    float buf2[FFT_SIZE];
    float buf3[FFT_SIZE];

    ComputeFFT(buf, buf2, FALSE);
    ComputeFFT(buf2, buf3, TRUE);

    for (int i = 0; i < FFT_SIZE; i++) {
	buf2[i] /= FFT_SIZE;
    }
    
    
    PrintTwo("original", buf, "fft", buf2);
}

void main(int argc,
    char *argv[])
{

    float buf[FFT_SIZE];

    int i;

    if (argc == 1) {
	printf("all zeroes\n");
	for (i = 0; i < FFT_SIZE; i++) {
	    buf[i] = 0;
	}

	TestFFT(buf, TRUE);

	printf("linear\n");
	for (i = 0; i < FFT_SIZE; i++) {
	    buf[i] = i;
	}

	TestFFT(buf, TRUE);

	printf("sin\n");
	for (i = 0; i < FFT_SIZE; i++) {
	    buf[i] = sin(i * M_PI / 50) * 16384;
	}

	TestFFT(buf, TRUE);


	printf("freq range\n");
	for (float freq = .3; freq <= 10; freq += .5) {
	    printf("freq = %3.1f   ", freq); 
	    for (i = 0; i < FFT_SIZE; i++) {
		buf[i] = sin(i * M_PI / freq) * 128;
	    }

	    TestFFT(buf);
	}

    } else {
#if 0
	printf("linear\n");
	for (i = 0; i < FFT_SIZE; i++) {
	    buf[i] = i;
	}

	ShowWholeFFT(buf, TRUE);
#endif
	printf("sin\n");
	for (i = 0; i < FFT_SIZE; i++) {
	    buf[i] = sin(i * M_PI / 5) * 16384;
	}

	ShowWholeFFT(buf, TRUE);





    }






}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\nullwave\bsicaud.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
// Implements audio control interface

#include <streams.h>
#include <mmsystem.h>
#include <nwaveout.h>
#include <decibels.h>

// This class implements the IBasicAudio control functions (dual interface).
// We support some methods that duplicate the properties but provide a
// more direct mechanism.

CNullBasicAudioControl::CNullBasicAudioControl(TCHAR *pName,           // Object description
                             LPUNKNOWN pUnk,         // Normal COM ownership
                             HRESULT *phr,           // OLE failure code
                             CNullWaveOutFilter *pAudioRenderer) : // Main renderer object
      CBasicAudio(pName,pUnk)
    , m_pAudioRenderer(pAudioRenderer)
    , m_lVolume(0)
    , m_lBalance(0)
    , m_wLeft(0xFFFF)
    , m_wRight(0xFFFF)


{
    ASSERT(pUnk);
    ASSERT(m_pAudioRenderer);
}

//
// This returns the current Audio volume. We remember that we have been called
// and therefore we should set the volume in future.
//
// The structure has a public dual interface method which will lock and
// validate the parameter.  This calls a private method shared with the
// waveout filter to talk to the device.

STDMETHODIMP CNullBasicAudioControl::get_Volume(long *plVolume)
{
    CAutoLock cInterfaceLock(m_pAudioRenderer);
    ASSERT(plVolume);

    // We never have an audio device - return the last set value
    *plVolume = m_lVolume;
    return NOERROR;
}

STDMETHODIMP CNullBasicAudioControl::GetVolume(long *plVolume)
{
    // We never have an audio device - return the last set value
    *plVolume = m_lVolume;
    return NOERROR;
}


//
// Set the volume.  This is a public method so we should validate
// the input parameter.  If the device is not connected, remember the
// volume setting and we will set it later
//

STDMETHODIMP
CNullBasicAudioControl::put_Volume(long lVolume)
{
    CAutoLock cInterfaceLock(m_pAudioRenderer);

    if ((AX_MAX_VOLUME < lVolume) || (AX_MIN_VOLUME > lVolume)) {
	return E_INVALIDARG;
    }

    m_lVolume = lVolume;
    return NOERROR;
}


//
// Internal routine to set the volume.  No parameter checking...
//

STDMETHODIMP
CNullBasicAudioControl::PutVolume()
{
    return NOERROR;
}


STDMETHODIMP CNullBasicAudioControl::get_Balance(long *plBalance)
{
    CAutoLock cInterfaceLock(m_pAudioRenderer);
    ASSERT(plBalance);

    *plBalance = m_lBalance;
    return NOERROR;
}

//
// Set the Balance.  This is a public method so we should validate
// the input parameter.  If the device is not connected, remember the
// Balance setting and we will set it later
//

STDMETHODIMP
CNullBasicAudioControl::put_Balance(long lBalance)
{
    CAutoLock cInterfaceLock(m_pAudioRenderer);

    if ((AX_BALANCE_RIGHT < lBalance) || (AX_BALANCE_LEFT > lBalance)) {
	return E_INVALIDARG;
    }

    m_lBalance = lBalance;

    return NOERROR;
}


//
// Internal routine to set the Balance.  No parameter checking...
//

STDMETHODIMP
CNullBasicAudioControl::GetBalance(long * plBalance)
{
    *plBalance = m_lBalance;
    return(NOERROR);
}

STDMETHODIMP
CNullBasicAudioControl::PutBalance()
{
    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\nullwave\nwaveout.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
// Digital audio renderer, David Maymudes, January 1995

#include <streams.h>
#include <mmsystem.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif
#include "wavefake.h"
#include "nwaveout.h"


// If the following is defined, we pretend that the wave device plays at this fraction of
// the requested rate, to test our synchronization code....
// #define SIMULATEBROKENDEVICE 0.80
//
// IBaseFilter stuff
// Return the number of input pins we support

int CNullWaveOutFilter::GetPinCount()
{
    return 1;
}


/* Return our single input pin - not addrefed */

CBasePin *CNullWaveOutFilter::GetPin(int n)
{

    /* We only support one input pin and it is numbered zero */

    //ASSERT(n == 0);   Allow an invalid parameter
    if (n != 0) {
        return NULL;
    }

    return m_pInputPin;
}


// switch the filter into stopped mode.
STDMETHODIMP CNullWaveOutFilter::Stop()
{
    CAutoLock lock(this);

    if (m_State != State_Stopped) {

        // pause the device if we were running
        if (m_State == State_Running) {
            HRESULT hr = Pause();
            if (FAILED(hr)) {
                return hr;
            }
        }

        DbgLog((LOG_TRACE,1,TEXT("Stopping....")));


        // need to make sure that no more buffers appear in the queue
        // during or after the reset process below or the buffer
        // count may get messed up - currently Receive holds the
        // filter-wide critsec to ensure this

        // force end-of-stream clear
        InterlockedIncrement(&m_lBuffers);

        if (m_hwo)
            waveReset(m_hwo);

        // now force the buffer count back to the normal (non-eos) 1
        // at this point, we are sure there are no more buffers coming in
        // and no more buffers waiting for callbacks.
        m_lBuffers = 1;

        // base class changes state and tells pin to go to inactive
        // the pin Inactive method will decommit our allocator, which we
        // need to do before closing the device.
        HRESULT hr =  CBaseFilter::Stop();
        if (FAILED(hr)) {
            return hr;
        }

        // don't close the wave device - it will be done during the
        // last release of a buffer

    }
    return NOERROR;
}


STDMETHODIMP CNullWaveOutFilter::Pause()
{
    CAutoLock lock(this);

    HRESULT hr = NOERROR;

    /* Check we can PAUSE given our current state */

    if (m_State == State_Running) {
        DbgLog((LOG_TRACE,1,TEXT("Running->Paused")));

        if (m_hwo) {
            wavePause(m_hwo);
        }
    } else {
        if (m_State == State_Stopped) {
            DbgLog((LOG_TRACE,1,TEXT("Inactive->Paused")));

            // open the wave device. We keep it open until the
            // last buffer using it is released and the allocator
            // goes into Decommit mode.
            hr = OpenWaveDevice();
            if (FAILED(hr)) {
                return hr;
            }
        }
    }

    // tell the pin to go inactive and change state
    return CBaseFilter::Pause();

}


STDMETHODIMP CNullWaveOutFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock lock(this);

    HRESULT hr = NOERROR;

    FILTER_STATE fsOld = m_State;

    // this will call Pause if currently Stopped
    hr = CBaseFilter::Run(tStart);
    if (FAILED(hr)) {
        return hr;
    }

    if (fsOld != State_Running) {

        DbgLog((LOG_TRACE,1,TEXT("Paused->Running")));

        // the queued data might be just an end of
        // stream - in which case, signal it here
        // since we are not running, we know there are no wave
        // callbacks happening, so we are safe to check this value

        // if we are not connected, then we will never get any data
        // so in this case too, don't start the wave device and
        // signal EC_COMPLETE - but succeed the Run command
        if ((m_lBuffers == 0) || (m_pInputPin->IsConnected() == FALSE)) {
            // no more buffers - signal now
            NotifyEvent(EC_COMPLETE, S_OK, 0);

            if (m_lBuffers == 0) {
                // back up to one now (clear the EOS marker)
                InterlockedIncrement(&m_lBuffers);
            }

            // don't bother starting the wave device - there's no
            // data coming.
        } else {

            //!!! correct timing needed here
            // we should postpone this restart until the correct
            // start time. That means knowing the stream at which we paused
            // and having an advise for (just before) that time.

            if (m_hwo) {
                waveRestart(m_hwo);
            }
        }
    }

    return NOERROR;
}

// open the wave device if not already open
// called by the wave allocator at Commit time
STDMETHODIMP
CNullWaveOutFilter::OpenWaveDevice(void)
{
    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) m_pInputPin->m_mt.Format();

    if (!pwfx)
        return (S_FALSE);  // not properly connected.  Ignore this non existent wave data

    // !!! adjust based on speed?
    // !!! for the moment, only for PCM!!!
    WAVEFORMATEX wfxPCM;
    double dRate = 1.0;
    if (m_pImplPosition && pwfx->wFormatTag == WAVE_FORMAT_PCM) {

        HRESULT hr = m_pImplPosition->get_Rate(&dRate);

        if (FAILED(hr)) {
            DbgLog((LOG_ERROR,1,TEXT("Failed to get playback rate")));
        }
    }

#ifdef SIMULATEBROKENDEVICE
    dRate *= SIMULATEBROKENDEVICE;
#endif

    if (dRate != 1.0) {
        DbgLog((LOG_TRACE,1,TEXT("Playing at %d%% of normal speed"), (int) (dRate * 100)));
        wfxPCM = *pwfx;
        pwfx = &wfxPCM;

        wfxPCM.nSamplesPerSec = (DWORD) (wfxPCM.nSamplesPerSec * dRate);
        wfxPCM.nAvgBytesPerSec = (DWORD) (wfxPCM.nAvgBytesPerSec * dRate);
    }

    UINT err = waveOpen(&m_hwo,
                           WAVE_MAPPER,
                           pwfx,
                           (DWORD) &CNullWaveOutFilter::WaveOutCallback,
                           (DWORD) this,
                           CALLBACK_FUNCTION);

    // !!! if we can't open the wave device, should we do a
    // sndPlaySound(NULL) and try again? -- now done by MMSYSTEM!

    if (err != 0) {
        DbgLog((LOG_TRACE,1,TEXT("Error opening wave device: %u"), err));
        m_hwo = NULL;
        return S_FALSE; // !!! allow things to continue....
    }

    if (m_fVolumeSet) {
#if 1
	m_BasicAudioControl.PutVolume();
#else
#if (WINVER >= 0x0400)
        // Why 4.01?  I don't know, but that's what the header says.
        err = waveSetVolume(m_hwo, MAKELONG(m_wLeft, m_wRight));
#else
        UINT uDevID;
        err = waveGetID(m_hwo, &uDevID);

        if (err == MMSYSERR_NOERROR) {
            err = waveSetVolume(uDevID, MAKELONG(m_wLeft, m_wRight));
        }
        // actually both NT 3.51 and Win95 allow either an ID or a device handle to
        // be passed to waveSetVolume
#endif
#endif
    }

    HRESULT hr = m_pInputPin->m_pOurAllocator->SetWaveHandle((HWAVE) m_hwo);
    if (FAILED(hr)) {
        return hr;
    }
    wavePause(m_hwo);

    return NOERROR;
}

// close the wave device
// called by the wave allocator at Decommit time.
STDMETHODIMP
CNullWaveOutFilter::CloseWaveDevice(void)
{
    if (m_hwo) {
        m_hwo = NULL;
    }

    return NOERROR;
}


#ifdef FILTER_DLL
/* List of class IDs and creator functions for class factory */

CFactoryTemplate g_Templates[] = {
    {L"", &CLSID_NullAudioRender, CNullWaveOutFilter::CreateInstance},
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif




/* PUBLIC Member functions */
/* This goes in the factory template table to create new instances */

CUnknown *CNullWaveOutFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CNullWaveOutFilter(pUnk, phr);
}


/* Constructor */

#pragma warning(disable:4355)

CNullWaveOutFilter::CNullWaveOutFilter(
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseFilter(NAME("Null WaveOut Filter"), pUnk,
                  (CCritSec *)this, CLSID_NullAudioRender),
      m_BasicAudioControl(NAME("Audio properties"), GetOwner(), phr, this),
      m_pImplPosition(NULL),
      m_lBuffers(1)

{
    m_fStopping = FALSE;
    m_hwo = NULL;
    m_fVolumeSet = FALSE;
    m_fHasVolume = FALSE;

    /* Create the single input pin */

    m_pInputPin = new CNullWaveOutInputPin(
                            this,                   // Owning filter
                            phr,                    // Result code
                            L"Audio Input");        // Pin name

    ASSERT(m_pInputPin);
    if (!m_pInputPin)
        *phr = E_OUTOFMEMORY;
}


/* Destructor */

CNullWaveOutFilter::~CNullWaveOutFilter()
{

    /* Release our reference clock if we have one */

    ASSERT(m_hwo == NULL);

    /* Delete the contained interfaces */

    ASSERT(m_pInputPin);

    delete m_pInputPin;

    if (m_pImplPosition) {
        delete m_pImplPosition;
    }
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP CNullWaveOutFilter::NonDelegatingQueryInterface(REFIID riid,
                                                        void ** ppv)
{
    if (riid == IID_IPersist) {
        return GetInterface((IPersist *) this, ppv);
    } else if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
        if (!m_pImplPosition) {
            HRESULT hr = S_OK;
            m_pImplPosition = new CPosPassThru(
                                    NAME("Audio Render CPosPassThru"),
                                    GetOwner(),
                                    &hr,
                                    (IPin *)m_pInputPin);
            if (FAILED(hr)) {
                if (m_pImplPosition) {
                    delete m_pImplPosition;
                    m_pImplPosition = NULL;
                }
                return hr;
            }
        }
        return m_pImplPosition->NonDelegatingQueryInterface(riid, ppv);
    } else if (IID_IBasicAudio == riid) {
	return m_BasicAudioControl.NonDelegatingQueryInterface(riid, ppv);
    } else {
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}


// Pin stuff

/* Constructor */

CNullWaveOutInputPin::CNullWaveOutInputPin(
    CNullWaveOutFilter *pFilter,
    HRESULT *phr,
    LPCWSTR pPinName)
    : CBaseInputPin(NAME("WaveOut Pin"), pFilter, pFilter, phr, pPinName)
{
    m_pFilter = pFilter;
    m_pOurAllocator = NULL;
    m_fUsingOurAllocator = FALSE;

#ifdef PERF
    m_idReceive       = MSR_REGISTER("WaveOut receive");
    m_idAudioBreak    = MSR_REGISTER("WaveOut audio break");
#endif
}

CNullWaveOutInputPin::~CNullWaveOutInputPin()
{
    /* Release our allocator if we made one */

    if (m_pOurAllocator) {
        m_pOurAllocator->Release();
        m_pOurAllocator = NULL;
    }
}

// return the allocator interface that this input pin
// would like the output pin to use
STDMETHODIMP
CNullWaveOutInputPin::GetAllocator(
    IMemAllocator ** ppAllocator)
{
    HRESULT hr = NOERROR;

    if (!IsConnected())
        return E_FAIL;

    if (m_pAllocator) {
        // we've already got an allocator....
        /* Get a reference counted IID_IMemAllocator interface */
        m_pAllocator->QueryInterface(IID_IMemAllocator,
                                                (void **)ppAllocator);
    } else {

        if (!m_pOurAllocator) {
            // !!! Check if format set?

            DbgLog((LOG_MEMORY,1,TEXT("Creating new WaveAllocator...")));
            m_pOurAllocator = new CNullWaveAllocator(
                                        NAME("WaveOut allocator"),
                                        (WAVEFORMATEX *) m_mt.Format(),
                                        FALSE,
                                        &hr);

            if (!m_pOurAllocator)
                hr = E_OUTOFMEMORY;

            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,1,TEXT("Failed to create new allocator!")));
                return hr;
            }

            m_pOurAllocator->AddRef();
        }

        /* Get a reference counted IID_IMemAllocator interface */
        m_pOurAllocator->QueryInterface(IID_IMemAllocator,
                                                (void **)ppAllocator);
    }

    if (*ppAllocator == NULL) {
        return E_NOINTERFACE;
    }
    return NOERROR;
}

STDMETHODIMP CNullWaveOutInputPin::NotifyAllocator(
    IMemAllocator *pAllocator,
    BOOL bReadOnly)
{
    HRESULT hr;             // General OLE return code

    /* Make sure the base class gets a look */

    hr = CBaseInputPin::NotifyAllocator(pAllocator,bReadOnly);
    if (FAILED(hr)) {
        return hr;
    }

    /* See if the IUnknown pointers match */

    // !!! what if our allocator hasn't been created yet? !!!
    IMemAllocator * pOurAllocator;
    if (!m_pOurAllocator) {

        DbgLog((LOG_MEMORY,1,TEXT("Creating new WaveAllocator...")));
        m_pOurAllocator = new CNullWaveAllocator(
                                NAME("WaveOut allocator"),
                                (WAVEFORMATEX *) m_mt.Format(),
                                FALSE,
                                &hr);

        if (!m_pOurAllocator)
            hr = E_OUTOFMEMORY;

        if (FAILED(hr)) {
            DbgLog((LOG_ERROR,1,TEXT("Failed to create new allocator!")));
            return hr;
        }

        m_pOurAllocator->AddRef();
    }
    /* Get a reference counted IID_IMemAllocator interface */
    hr = m_pOurAllocator->QueryInterface(IID_IMemAllocator, (void **) &pOurAllocator);

    if (FAILED(hr)) {
        return hr;
    }

    m_fUsingOurAllocator = (pOurAllocator == pAllocator);

    DbgLog((LOG_TRACE,1,TEXT("NotifyAllocator: UsingOurAllocator = %d"), m_fUsingOurAllocator));

    /* Release the extra reference count we hold on the interface */
    pOurAllocator->Release();

    if (!m_fUsingOurAllocator) {

        // somebody else has provided an allocator, so we need to
        // make a few buffers of our own....

        ALLOCATOR_PROPERTIES Request,Actual;
        Request.cbAlign = 1;
        Request.cbBuffer = 4096;
        Request.cBuffers = 4;
        Request.cbPrefix = 0;

        hr = pOurAllocator->SetProperties(&Request,&Actual);
        DbgLog((LOG_TRACE,1,
                TEXT("Allocated %d buffers of %d bytes from our allocator"),
                Actual.cBuffers, Actual.cbBuffer));

        if (FAILED(hr))
            return hr;
    }

    return NOERROR;
}



/* This is called when a connection or an attempted connection is terminated
   and allows us to reset the connection media type to be invalid so that
   we can always use that to determine whether we are connected or not. We
   leave the format block alone as it will be reallocated if we get another
   connection or alternatively be deleted if the filter is finally released */

HRESULT CNullWaveOutInputPin::BreakConnect()
{
    /* Check we have a valid connection */

    if (m_mt.IsValid() == FALSE) {
        return E_FAIL;
    }

    // !!! Should we check that all buffers have been freed?
    // --- should be done in the Decommit ?

    /* Set the CLSIDs of the connected media type */

    m_mt.SetType(&GUID_NULL);
    m_mt.SetSubtype(&GUID_NULL);

    return CBaseInputPin::BreakConnect();
}


/* Check that we can support a given proposed type */

HRESULT CNullWaveOutInputPin::CheckMediaType(const CMediaType *pmt)
{

    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pmt->Format();
    DbgLog((LOG_TRACE,1,TEXT("Format length %d"),pmt->FormatLength()));

    #ifdef DEBUG

    //const int iGUID_STRING = 128;
    //OLECHAR szGUIDName[iGUID_STRING];

    /* Dump the GUID types */

    DbgLog((LOG_TRACE,2,TEXT("Major type %s"),GuidNames[*pmt->Type()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype %s"),GuidNames[*pmt->Subtype()]));

    /* Dump the generic media types */

    DbgLog((LOG_TRACE,2,TEXT("Fixed size sample %d"),pmt->IsFixedSize()));
    DbgLog((LOG_TRACE,2,TEXT("Temporal compression %d"),pmt->IsTemporalCompressed()));
    DbgLog((LOG_TRACE,2,TEXT("Sample size %d"),pmt->GetSampleSize()));
    DbgLog((LOG_TRACE,2,TEXT("Format size %d"),pmt->FormatLength()));

    #endif


    // reject non-Audio type
    if (pmt->majortype != MEDIATYPE_Audio) {
        return E_INVALIDARG;
    }

    // if it's MPEG audio, we want it without packet headers.
    if (pmt->subtype == MEDIASUBTYPE_MPEG1Packet) {
        return E_INVALIDARG;
    }

    if (pmt->FormatLength() < sizeof(PCMWAVEFORMAT))
        return E_INVALIDARG;

    #ifdef DEBUG

    /* Dump the contents of the WAVEFORMATEX type-specific format structure */

    DbgLog((LOG_TRACE,2,TEXT("wFormatTag %u"), pwfx->wFormatTag));
    DbgLog((LOG_TRACE,2,TEXT("nChannels %u"), pwfx->nChannels));
    DbgLog((LOG_TRACE,2,TEXT("nSamplesPerSec %lu"), pwfx->nSamplesPerSec));
    DbgLog((LOG_TRACE,2,TEXT("nAvgBytesPerSec %lu"), pwfx->nAvgBytesPerSec));
    DbgLog((LOG_TRACE,2,TEXT("nBlockAlign %u"), pwfx->nBlockAlign));
    DbgLog((LOG_TRACE,2,TEXT("wBitsPerSample %u"), pwfx->wBitsPerSample));

    /* PCM uses a WAVEFORMAT and does not have the extra size field */

    if (pmt->FormatLength() >= sizeof(WAVEFORMATEX)) {
        DbgLog((LOG_TRACE,2,TEXT("cbSize %u"), pwfx->cbSize));
    }

    #endif

    // adjust based on rate that has been chosen, or don't bother?
    UINT err = waveOpen(NULL,
                           WAVE_MAPPER,
                           pwfx,
                           0,
                           0,
                           WAVE_FORMAT_QUERY);

    if (err != 0) {
        DbgLog((LOG_ERROR,1,TEXT("Error checking wave format: %u"), err));
        return E_FAIL; // !!!!
    }

    // don't bother querying for volume setting capability
    m_pFilter->m_fHasVolume = WAVECAPS_VOLUME | WAVECAPS_LRVOLUME;

    return NOERROR;
}


/* Implements the remaining IMemInputPin virtual methods */


// Here's the next block of data from the stream
// We need to AddRef it if we hold onto it. This will then be
// released in the WaveOutCallback function.

HRESULT CNullWaveOutInputPin::Receive(IMediaSample * pSample)
{
    HRESULT hr;

    // if stop time is before start time, forget this
    CRefTime tStart, tStop;

    pSample->GetTime((REFERENCE_TIME*) &tStart,
                     (REFERENCE_TIME*) &tStop);

    if (tStop <= tStart) {
        return S_OK;
    }

#ifdef PERF
    MSR_START(m_idReceive);

    if (m_pFilter->m_State == State_Running && m_pFilter->m_lBuffers <= 1) {
        MSR_NOTE(m_idAudioBreak);
    }
#endif

                // From media sample, need to get back our WAVEOUTHEADER
    BYTE *pData;                // Pointer to image data
    pSample->GetPointer(&pData);
    ASSERT(pData != NULL);

    {
        // lock this with the filter-wide lock
        CAutoLock lock(m_pFilter);

        // if we're stopped, then reject this call
        // (the filter graph may be in mid-change)
        if (m_pFilter->m_State == State_Stopped) {
            DbgLog((LOG_ERROR,1, TEXT("Receive when stopped!")));
            return E_FAIL;
        }

        if (m_pFilter->m_hwo == NULL) {
            // no wave device, so we can't do much....
            return S_FALSE; // !!! what, if anything, does this mean?
        }

        // check all is well with the base class
        hr = CBaseInputPin::Receive(pSample);

        // S_FALSE means we are not accepting samples. Errors also mean
        // we reject this
        if (hr != S_OK)
            return hr;

        if( m_fUsingOurAllocator ){
            // addref pointer since we will keep it beyond the callback
            // - MUST do this before the callback releases it!
            pSample->AddRef();

            LPWAVEHDR pwh = ((LPWAVEHDR) pData) - 1;

            // need to adjust to actual bytes written
            pwh->dwBufferLength = pSample->GetActualDataLength();

            // note that we have added another buffer
            InterlockedIncrement(&m_pFilter->m_lBuffers);

            DbgLog((LOG_TRACE,5,
                TEXT("WaveOutWrite: sample %X, %d bytes"),
                pSample, pwh->dwBufferLength));
            UINT err = waveWrite(m_pFilter->m_hwo, pwh, sizeof(WAVEHDR));
            if (err > 0) {
                // device error: PCMCIA card removed?
                DbgLog((LOG_ERROR,1,TEXT("Error from waveWrite: %d"), err));
                hr = E_FAIL;

                // release it here since the callback will never happen
                pSample->Release();
                return hr;
            }

            return NOERROR;
        }
    }

    // When here we are not using our own allocator and
    // therefore need to copy the data

    // We have released the filter-wide lock so that GetBuffer will not
    // cause a deadlock when we go from Paused->Running or Paused->Playing

    IMediaSample * pBuffer;
    LONG lData = pSample->GetActualDataLength();

    while( lData > 0 && hr == S_OK ){
        // note: this blocks!
        hr = m_pOurAllocator->GetBuffer(&pBuffer,NULL,NULL,0);

        if (FAILED(hr))
            return hr;

        {
            // filter-wide lock
            CAutoLock Lock( m_pFilter );

            // if we're stopped, then reject this call
            // (the filter graph may be in mid-change)
            if (m_pFilter->m_State == State_Stopped) {
                DbgLog((LOG_ERROR,1, TEXT("Receive when stopped!")));
                pBuffer->Release();
                return E_FAIL;
            }

            if (m_pFilter->m_hwo == NULL) {
                // no wave device, so we can't do much....
                pBuffer->Release();
                return S_FALSE; // !!! what, if anything, does this mean?
            }

            BYTE * pBufferData;
            pBuffer->GetPointer(&pBufferData);
            LONG cbBuffer = min(lData, pBuffer->GetSize());

            DbgLog((LOG_TRACE,8,TEXT("Copying %d bytes of data"), cbBuffer));

            CopyMemory(pBufferData, pData, cbBuffer);
            pBuffer->SetActualDataLength(cbBuffer);

            lData -= cbBuffer;
            pData += cbBuffer;

            LPWAVEHDR pwh = ((LPWAVEHDR) pBufferData) - 1;

            // need to adjust to actual bytes written
            pwh->dwBufferLength = cbBuffer;

            // note that we have added another buffer
            InterlockedIncrement(&m_pFilter->m_lBuffers);

            UINT err = waveWrite(m_pFilter->m_hwo, pwh, sizeof(WAVEHDR));


            if (err > 0) {
                // device error: PCMCIA card removed?
                DbgLog((LOG_ERROR,1,TEXT("Error from waveWrite: %d"), err));
                pBuffer->Release();
                return E_FAIL;
            }

        }

    }

    MSR_STOP(m_idReceive);

    /* Return the status code */
    return hr;
} // Receive
// no more data is coming. If we have samples queued, then store this for
// action in the last wave callback. If there are no samples, then action
// it now by notifying the filtergraph.
//
// we communicate with the wave callback using InterlockedDecrement on
// m_lBuffers. This is normally 1, and is incremented for each added buffer.
// At eos, we decrement this, so on the last buffer, the waveout callback
// will be decrementing it to 0 rather than 1 and can signal EC_COMPLETE.

STDMETHODIMP
CNullWaveOutInputPin::EndOfStream(void)
{
    if (InterlockedDecrement(&m_pFilter->m_lBuffers) == 0) {

        // if we are paused, leave this queued until we run

        if (m_pFilter->m_State == State_Running) {
            // no more buffers - signal now
            m_pFilter->NotifyEvent(EC_COMPLETE, S_OK, 0);

            // back up to one now (clear the EOS marker)
            InterlockedIncrement(&m_pFilter->m_lBuffers);
        }
    }

    // else there are some buffers outstanding, and on release of the
    // last buffer the waveout callback will signal.

    return S_OK;
}


// enter flush state - block receives and free queued data
STDMETHODIMP
CNullWaveOutInputPin::BeginFlush(void)
{
    // lock this with the filter-wide lock
    // ok since this filter cannot block in Receive
    CAutoLock lock(m_pFilter);

  // block receives
    HRESULT hr = CBaseInputPin::BeginFlush();
    if (FAILED(hr)) {
        return hr;
    }

  // discard queued data

    // force end-of-stream clear - this is to make sure
    // that a queued end-of-stream does not get delivered by
    // the wave callback when the buffers are released.
    InterlockedIncrement(&m_pFilter->m_lBuffers);

    // release all buffers from the wave driver
    if (m_pFilter->m_hwo) {
        waveReset(m_pFilter->m_hwo);
        if (m_pFilter->m_State == State_Paused) {
            wavePause(m_pFilter->m_hwo);
        }
    }

    // now force the buffer count back to the normal (non-eos) 1
    // at this point, we are sure there are no more buffers coming in
    // and no more buffers waiting for callbacks.
    m_pFilter->m_lBuffers = 1;


  // free anyone blocked on receive - not possible in this filter

  // call downstream -- no downstream pins
    return S_OK;
}

// leave flush state - ok to re-enable receives
STDMETHODIMP
CNullWaveOutInputPin::EndFlush(void)
{
    // lock this with the filter-wide lock
    // ok since this filter cannot block in Receive
    CAutoLock lock(m_pFilter);

    // sync with pushing thread -- we have no worker thread

    // ensure no more data to go downstream
    // --- we did this in BeginFlush()

    // call EndFlush on downstream pins -- no downstream pins

    // unblock Receives
    return CBaseInputPin::EndFlush();
}



HRESULT
CNullWaveOutInputPin::Active(void)
{
    if (m_pOurAllocator == NULL) {
        return E_FAIL;
    }
    // commit and prepare our allocator. Needs to be done
    // if he is not using our allocator, and in any case needs to be done
    // before we complete our close of the wave device.
    return m_pOurAllocator->Commit();
}

HRESULT
CNullWaveOutInputPin::Inactive(void)
{
    if (m_pOurAllocator == NULL) {
        return E_FAIL;
    }
    // decommit the buffers - normally done by the output
    // pin, but we need to do it here ourselves, before we close
    // the device, and in any case if he is not using our allocator.
    // the output pin will also decommit the allocator if he
    // is using ours, but that's not a problem
    HRESULT hr = m_pOurAllocator->Decommit();

    m_pFilter->CloseWaveDevice();

    return hr;
}


// dwUser parameter is the CNullWaveOutFilter pointer

void CALLBACK CNullWaveOutFilter::WaveOutCallback(HDRVR hdrvr, UINT uMsg, DWORD dwUser,
                                              DWORD dw1, DWORD dw2)
{
    switch (uMsg) {
        case WOM_DONE:
        {
            LPWAVEHDR lpwh = (LPWAVEHDR) dw1; // !!! verify?

            CMediaSample * pSample = (CMediaSample *) lpwh->dwUser;

            DbgLog((LOG_TRACE,5,
                    TEXT("WaveOutCallback: sample %X"), pSample));

            // is this the end of stream?
            CNullWaveOutFilter* pFilter = (CNullWaveOutFilter *) dwUser;
            ASSERT(pFilter);

            // note that we have finished with a buffer, and
            // look for eos
            if (InterlockedDecrement(&pFilter->m_lBuffers) == 0) {

                // signal that we're done
                pFilter->NotifyEvent(EC_COMPLETE, S_OK, 0);

                // now clear the EOS flag
                InterlockedIncrement(&pFilter->m_lBuffers);
            }

            pSample->Release(); // we're done with this buffer....
        }
            break;

        case WOM_OPEN:
        case WOM_CLOSE:
            break;

        default:
            DbgLog((LOG_ERROR,2,TEXT("Unexpected wave callback message %d"), uMsg));
            break;
    }
}


// CNullWaveAllocator

/* Constructor must initialise the base allocator */

CNullWaveAllocator::CNullWaveAllocator(
    TCHAR *pName,
    LPWAVEFORMATEX lpwfx,
    BOOL fInput,
    HRESULT *phr)
    : CBaseAllocator(pName, NULL, phr)
{
    // Keep a copy of the format

    int cbSize = sizeof(WAVEFORMATEX);
    if (lpwfx->wFormatTag != WAVE_FORMAT_PCM) {
        cbSize += lpwfx->cbSize;
    }

    m_lpwfx = (LPWAVEFORMATEX) new BYTE[cbSize];
    ZeroMemory((PVOID)m_lpwfx,cbSize);

    if (lpwfx->wFormatTag == WAVE_FORMAT_PCM)
        cbSize = sizeof(WAVEFORMAT);

    CopyMemory(m_lpwfx, lpwfx, cbSize);
    m_fBuffersLocked = FALSE;
    m_hw = 0;
}


// Called from destructor and also from base class

// all buffers have been returned to the free list and it is now time to
// go to inactive state. Unprepare all buffers and then free them.
void CNullWaveAllocator::Free(void)
{
    // unprepare the buffers
    LockBuffers(FALSE);

    CMediaSample *pSample;      // Pointer to next sample to delete
    WAVEHDR wh;                 // Shared DIB section information
    WAVEHDR *pwh;               // Used to retrieve the WAVEHDR

    /* Should never be deleting this unless all buffers are freed */

    ASSERT(m_lAllocated == m_lFree.GetCount());
    ASSERT(!m_fBuffersLocked);

    DbgLog((LOG_MEMORY,1,TEXT("Destroying %u buffers (%u free)"), m_lAllocated, m_lFree.GetCount()));

    /* Free up all the CMediaSamples */

    while (m_lFree.GetCount() != 0) {

        /* Delete the CMediaSample object but firstly get the WAVEHDR
           structure from it so that we can clean up it's resources */

        pSample = m_lFree.RemoveHead();
        pSample->GetPointer((BYTE **)&pwh);
        wh = *(pwh - 1);

        // !!! Is this really one of our objects?

        // delete the actual memory buffer
        delete[] (BYTE *) (pwh - 1);

        // delete the CMediaSample object
        delete pSample;
    }

    /* Empty the lists themselves */

    m_lAllocated = 0;

    if (m_hw) {
        waveClose((HWAVEOUT) m_hw);
        m_hw = NULL;
    }
}

// the commit and decommit handle preparing and unpreparing of
// the buffers. The filter calls this to tell us the wave handle just
// after opening and just before closing the device. It is the filter's
// responsibility to ensure that Commit or Decommit calls are called in
// the right order (Commit after this, Decommit before this).
STDMETHODIMP CNullWaveAllocator::SetWaveHandle(HWAVE hw)
{
    m_hw = hw;

    return NOERROR;
}

STDMETHODIMP CNullWaveAllocator::LockBuffers(BOOL fLock)
{
    if (m_fBuffersLocked == fLock)
        return NOERROR;

    if (!m_hw)
        return NOERROR;

    if (m_lAllocated == 0)
        return NOERROR;

    /* Should never be doing this unless all buffers are freed */

    ASSERT(m_lAllocated == m_lFree.GetCount());

    DbgLog((LOG_TRACE,2,TEXT("Calling wave%hs%hsrepare on %u buffers (%u free)"), "Out" , fLock ? "P" : "Unp", m_lAllocated, m_lFree.GetCount()));

    /* Prepare/unprepare up all the CMediaSamples */

    for (CMediaSample *pSample = m_lFree.Head();
         pSample != NULL;
         pSample = m_lFree.Next(pSample)) {

        WAVEHDR *pwh;

        pSample->GetPointer((BYTE **)&pwh);
        pwh -= 1;

        UINT err;

        err = (fLock ? wavePrepareHeader : waveUnprepareHeader)
                                ((HWAVEOUT) m_hw, pwh,
                                sizeof(WAVEHDR));
        if (err > 0) {
            DbgLog((LOG_ERROR,1,TEXT("Error in wave%hs%hsrepare: %u"), "Out" , fLock ? "P" : "Unp", err));

            // !!! Need to unprepare everything....
            return E_FAIL; // !!!!
        }
    }

    m_fBuffersLocked = fLock;

    return NOERROR;
}


/* The destructor ensures the shared memory DIBs are deleted */

CNullWaveAllocator::~CNullWaveAllocator()
{
    // go to decommit state here. the base class can't do it in its
    // destructor since its too late by then - we've been destroyed.
    Decommit();

    delete[] (BYTE *) m_lpwfx;
}


// Agree the number and size of buffers to be used. No memory
// is allocated until the Commit call.
STDMETHODIMP CNullWaveAllocator::SetProperties(
		    ALLOCATOR_PROPERTIES* pRequest,
		    ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pRequest,E_POINTER);
    CheckPointer(pActual,E_POINTER);
    const LONG MIN_BUFFER_SIZE = 4096;

    ALLOCATOR_PROPERTIES Adjusted = *pRequest;

    if (Adjusted.cbBuffer < MIN_BUFFER_SIZE)
        Adjusted.cbBuffer = MIN_BUFFER_SIZE;

    if (Adjusted.cBuffers < 2)
        Adjusted.cBuffers = 2;

    Adjusted.cbBuffer -= (Adjusted.cbBuffer % m_lpwfx->nBlockAlign);

    if (Adjusted.cbBuffer <= 0) {
        return E_INVALIDARG;
    }

    /* Pass the amended values on for final base class checking */
    return CBaseAllocator::SetProperties(&Adjusted,pActual);
}


// allocate and prepare the buffers

// called from base class to alloc memory when moving to commit state.
// object locked by base class
HRESULT
CNullWaveAllocator::Alloc(void)
{
    /* Check the base class says it's ok to continue */

    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
        return hr;
    }

    CMediaSample *pSample;      // Pointer to the new sample

    /* We create a new memory block large enough to hold our WAVEHDR
       along with the actual wave data */

    DbgLog((LOG_MEMORY,1,TEXT("Allocating %d wave buffers, %d bytes each"), m_lCount, m_lSize));

    ASSERT(m_lAllocated == 0);
    for (; m_lAllocated < m_lCount; m_lAllocated++) {
        /* Create and initialise a buffer */
        BYTE * lpMem = new BYTE[m_lSize + sizeof(WAVEHDR)];
        WAVEHDR * pwh = (WAVEHDR *) lpMem;

        if (lpMem == NULL) {
            hr = E_OUTOFMEMORY;
            break;
        }

        /* The address we give the sample to look after is the actual address
           the audio data will start and so does not include the prefix.
           Similarly, the size is of the audio data only */

        pSample = new CMediaSample(NAME("Wave audio sample"), this, &hr, lpMem + sizeof(WAVEHDR), m_lSize);

        pwh->lpData = (char *) (lpMem + sizeof(WAVEHDR));
        pwh->dwBufferLength = m_lSize;
        pwh->dwFlags = 0;
        pwh->dwUser = (DWORD) pSample;

        /* Clean up the resources if we couldn't create the object */

        if (FAILED(hr) || pSample == NULL) {
            delete[] lpMem;
            break;
        }

        /* Add the completed sample to the available list */

        m_lFree.Add(pSample);
    }

    LockBuffers(TRUE);

    /* Put all the media samples we have just created also onto the free list
       so they can be allocated. They all have a reference count of zero */


    return NOERROR;
}


STDMETHODIMP
CNullWaveAllocator::ReleaseBuffer(IMediaSample * pSample)
{
    ASSERT (m_lFree.GetCount() < m_lAllocated);

    return CBaseAllocator::ReleaseBuffer(pSample);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\nullwave\wavefake.h ===
/******************************Module*Header*******************************\
* Module Name: WaveFake.h
*
*
* Fake waveout apis - these boys never fail !!
*
*
* Created: 17-11-95
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#if (WINVER >= 0x0400)
MMRESULT waveGetVolume(HWAVEOUT hwo, LPDWORD pdwVolume);
MMRESULT waveSetVolume(HWAVEOUT hwo, DWORD dwVolume);
#else
MMRESULT waveGetVolume(UINT uId, LPDWORD pdwVolume);
MMRESULT waveSetVolume(UINT uId, DWORD dwVolume);
#endif

MMRESULT waveOpen(LPHWAVEOUT phwo, UINT uDeviceID,
    LPCWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen);
MMRESULT waveClose(HWAVEOUT hwo);
MMRESULT wavePrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
MMRESULT waveUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
MMRESULT waveWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
MMRESULT wavePause(HWAVEOUT hwo);
MMRESULT waveRestart(HWAVEOUT hwo);
MMRESULT waveReset(HWAVEOUT hwo);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\nullwave\wavefake.c ===
/******************************Module*Header*******************************\
* Module Name: WaveFake.c
*
* Fake waveout apis - these boys never fail !!
*
* Created: 16-11-95
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1995  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <windows.h>
#include <mmsystem.h>
#include "WaveFake.h"

BOOL            fOpen = FALSE;  // TRUE is faked device is open
LPDRVCALLBACK   lpCallback;     // Address of callback function to call
DWORD           dwData;         // Private DWORD given to us on waveOpen



#if (WINVER >= 0x0400)
/******************************Public*Routine******************************\
* waveGetVolume
*
* History:
* 16-11-95 - StephenE - Created
*
\**************************************************************************/
MMRESULT WINAPI waveGetVolume(HWAVEOUT hwo, LPDWORD pdwVolume)
{
    return MMSYSERR_NOERROR;
}

/******************************Public*Routine******************************\
* waveSetVolume
*
* History:
* 16-11-95 - StephenE - Created
*
\**************************************************************************/
MMRESULT WINAPI waveSetVolume(HWAVEOUT hwo, DWORD dwVolume)
{
    return MMSYSERR_NOERROR;
}

#else
/******************************Public*Routine******************************\
* waveGetVolume
*
* History:
* 16-11-95 - StephenE - Created
*
\**************************************************************************/
MMRESULT WINAPI waveGetVolume(UINT uId, LPDWORD pdwVolume)
{
    return MMSYSERR_NOERROR;
}

/******************************Public*Routine******************************\
* waveSetVolume
*
* History:
* 16-11-95 - StephenE - Created
*
\**************************************************************************/
MMRESULT WINAPI waveSetVolume(UINT uId, DWORD dwVolume)
{
    return MMSYSERR_NOERROR;
}
#endif



/******************************Public*Routine******************************\
* waveOpen
*
* History:
* 16-11-95 - StephenE - Created
*
\**************************************************************************/
MMRESULT WINAPI waveOpen(LPHWAVEOUT phwo, UINT uDeviceID,
    LPCWAVEFORMATEX pwfx, DWORD dwCallback, DWORD dwInstance, DWORD fdwOpen)
{

    //
    // By accepting all formats we don't have to decompress any wave data.
    // Alternatively, we should only accept PCM formats (plus the others
    // that ACM knows about) and reject all the others.  Basically reject
    // the MPEG wave audio format. This causes audio decompressors to get
    // plugged into the filter graph.
    //
    if (fdwOpen == WAVE_FORMAT_QUERY) {
        return MMSYSERR_NOERROR;
    }

    if (fOpen) {
        return MMSYSERR_ALLOCATED;
    }

    fOpen = TRUE;
    if (fdwOpen == CALLBACK_FUNCTION) {
        *phwo = (HWAVEOUT)fOpen;
        lpCallback = (LPDRVCALLBACK)dwCallback;
        dwData = dwInstance;
        (*lpCallback)((HDRVR)*phwo, WOM_OPEN, dwData, 0L, 0L);
    }

    return MMSYSERR_NOERROR;
}


/******************************Public*Routine******************************\
* waveClose
*
* History:
* 16-11-95 - StephenE - Created
*
\**************************************************************************/
MMRESULT WINAPI waveClose(HWAVEOUT hwo)
{
    if (!fOpen || (BOOL)hwo != TRUE) {
        return MMSYSERR_INVALHANDLE;
    }

    fOpen = FALSE;
    if (lpCallback != NULL) {
        (*lpCallback)((HDRVR)hwo, WOM_CLOSE, dwData, 0L, 0L);
    }
    return MMSYSERR_NOERROR;
}

/******************************Public*Routine******************************\
* wavePrepareHeader
*
* History:
* 16-11-95 - StephenE - Created
*
\**************************************************************************/
MMRESULT WINAPI wavePrepareHeader(
    HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
{
    pwh->dwFlags |= WHDR_PREPARED;
    return MMSYSERR_NOERROR;
}

/******************************Public*Routine******************************\
* waveUnprepareHeader
*
* History:
* 16-11-95 - StephenE - Created
*
\**************************************************************************/
MMRESULT WINAPI waveUnprepareHeader(
    HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
{
    pwh->dwFlags &= ~WHDR_PREPARED;
    return MMSYSERR_NOERROR;
}

/******************************Public*Routine******************************\
* waveWrite
*
* History:
* 16-11-95 - StephenE - Created
*
\**************************************************************************/
MMRESULT WINAPI waveWrite(
    HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh)
{

    pwh->dwFlags |= WHDR_DONE;
    if (lpCallback != NULL) {
        (*lpCallback)((HDRVR)hwo, WOM_DONE, dwData, (DWORD)pwh, 0L);
    }
    return MMSYSERR_NOERROR;
}

/******************************Public*Routine******************************\
* wavePause
*
* History:
* 16-11-95 - StephenE - Created
*
\**************************************************************************/
MMRESULT WINAPI wavePause(HWAVEOUT hwo)
{
    return MMSYSERR_NOERROR;
}

/******************************Public*Routine******************************\
* waveRestart
*
* History:
* 16-11-95 - StephenE - Created
*
\**************************************************************************/
MMRESULT WINAPI waveRestart(HWAVEOUT hwo)
{
    return MMSYSERR_NOERROR;
}

/******************************Public*Routine******************************\
* waveReset
*
* History:
* 16-11-95 - StephenE - Created
*
\**************************************************************************/
MMRESULT WINAPI waveReset(HWAVEOUT hwo)
{
    return MMSYSERR_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\nullwave\nwaveout.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

/*  Implements a digital audio renderer using waveOutXXX apis */
/*            David Maymudes          */
/*              January 1995            */

//
// Hacked by StephenE so that we can render files on machines
// that don't have a sound card (ie. my laptop).
//



// {20209144-20B5-11cf-8E88-02608C9BABA2}
DEFINE_GUID(CLSID_NullAudioRender,
0x20209144, 0x20b5, 0x11cf, 0x8e, 0x88, 0x2, 0x60, 0x8c, 0x9b, 0xab, 0xa2);



class CNullWaveOutFilter;

// Declare the BasicAudio control properties/methods
#include "bsicaud.h"


//
// This is an allocator based on the abstract CBaseAllocator class
// that allocates sample buffers
//
class CNullWaveAllocator : public CBaseAllocator
{

    LPWAVEFORMATEX	m_lpwfx;
    BOOL		m_fInput;
    BOOL		m_fBuffersLocked;
    HWAVE		m_hw;

    // override this to free the memory when we are inactive
    void Free(void);

    // override this to allocate and prepare memory when we become active
    HRESULT Alloc(void);

    // called by CMediaSample to return it to the free list and
    // block any pending GetSample call.
    STDMETHODIMP ReleaseBuffer(IMediaSample * pSample);
    // obsolete: virtual void PutOnFreeList(CMediaSample * pSample);

public:

    /* Constructors and destructors */

    CNullWaveAllocator(
        TCHAR *pName,
        LPWAVEFORMATEX lpwfx,
        BOOL fInput,
        HRESULT *phr);
    ~CNullWaveAllocator();

    STDMETHODIMP SetProperties(
		    ALLOCATOR_PROPERTIES* pRequest,
		    ALLOCATOR_PROPERTIES* pActual);

    STDMETHODIMP LockBuffers(BOOL fLock = TRUE);
    STDMETHODIMP SetWaveHandle(HWAVE hw = NULL);

};


//
// Class supporting the renderer input pin
//
//
// This pin is still a separate object in case it wants to have a distinct
// IDispatch....
//
class CNullWaveOutInputPin : public CBaseInputPin
{
    friend class CNullWaveOutFilter;

private:

    CNullWaveOutFilter  *m_pFilter;         // The renderer that owns us

    CNullWaveAllocator  *m_pOurAllocator;
    BOOL	        m_fUsingOurAllocator;

#ifdef PERF
    int m_idReceive;                   // MSR_id for time data received
    int m_idAudioBreak;
#endif

public:

    CNullWaveOutInputPin(
        CNullWaveOutFilter *pWaveOutFilter,
	HRESULT *phr,
	LPCWSTR pPinName);

    ~CNullWaveOutInputPin();

    // return the allocator interface that this input pin
    // would like the output pin to use
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    // tell the input pin which allocator the output pin is actually
    // going to use.
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator,BOOL bReadOnly);

    /* Lets us know where a connection ends */
    HRESULT BreakConnect();

    /* Check that we can support this output type */
    HRESULT CheckMediaType(const CMediaType *pmt);

    /* IMemInputPin virtual methods */

    /* Here's the next block of data from the stream.
       AddRef it if you are going to hold onto it. */
    STDMETHODIMP Receive(IMediaSample *pSample);

    // no more data is coming
    STDMETHODIMP EndOfStream(void);

    // override so we can decommit and commit our own allocator
    HRESULT Active(void);
    HRESULT Inactive(void);

    // Override to handle quality messages
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q)
    {    return E_NOTIMPL;             // We do NOT handle this
    }

    // flush our queued data
    STDMETHODIMP BeginFlush(void);
    STDMETHODIMP EndFlush(void);
};


//
// This is the COM object that represents a simple rendering filter. It
// supports IBaseFilter and IMediaFilter and has a single input stream (pin)
//
// It will also (soon!) support IDispatch to allow it to expose some
// simple properties....
//
//
class CNullWaveOutFilter : public CBaseFilter, public CCritSec
{

public:
    // Implements the IBaseFilter and IMediaFilter interfaces

    DECLARE_IUNKNOWN

    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);

public:

    CNullWaveOutFilter(
        LPUNKNOWN pUnk,
        HRESULT *phr);

    virtual ~CNullWaveOutFilter();

    /* Return the pins that we support */

    int GetPinCount();
    CBasePin *GetPin(int n);

    /* Override this to say what interfaces we support and where */

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // open the wave device if not already open
    // called by the wave allocator at Commit time
    STDMETHODIMP OpenWaveDevice(void);

    // close the wave device
    // called by the wave allocator at Decommit time.
    STDMETHODIMP CloseWaveDevice(void);

private:

    /* The nested classes may access our private state */

    friend class CNullWaveOutInputPin;
    friend class CNullBasicAudioControl;   // needs the wave device handle

    /* Member variables */
    CNullWaveOutInputPin *m_pInputPin;         /* IPin and IMemInputPin interfaces */


    // This filter currently can only work with its own internal clock
    // There was a declaration here of    IReferenceClock *m_pReferenceClock;
    // but it was never used.
    // If we are going to support cards where the clock can be slaved or
    // synchronised to an external master then this must be looked at.

    // ??? SetSyncSource should ensure that we only accept our own clock!

    BOOL	m_fStopping;

    BOOL	m_fVolumeSet;
    BOOL	m_fHasVolume;           // wave device can set the volume
    HWAVEOUT	m_hwo;

    // handles IMediaPosition by passing upstream
    CPosPassThru * m_pImplPosition;

    // handle setting/retrieving audio properties
    CNullBasicAudioControl m_BasicAudioControl;

    static void WaveOutCallback(HDRVR hdrvr, UINT uMsg, DWORD dwUser,
					DWORD dw1, DWORD dw2);

    // in order to synchronise end-of-stream with the codec,
    // we have a long that counts the number of queued buffers, which we
    // access with InterlockedIncrement. It is initialised to 1,
    // incremented whenever a buffer is added, and then decremented whenever
    // a buffer is completed. End-of-stream decrements it, so if the decrement
    // decrements it to 0, the wave callback knows it is EOS. The wave callback
    // will then re-increment it back to 1 so it can detect future end of
    // streams.
    LONG        m_lBuffers;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\ramp\passthru.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\ramp\rampout.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\ramp\ramptest.c ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\qksaud\audinmix.cpp ===
//--------------------------------------------------------------------------;
//
//  File: AudInMix.cpp
//
//  Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//      Implements IAMAudioInputMixer for KsProxy audio filters
//      
//  History:
//      10/05/98    msavage     created
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "ks.h"
#include "ksmedia.h"
#include <ksproxy.h>
#include "ksaudtop.h"
#include "qksaud.h"

//
// limits taken from wavein IAMAudioInputMixer implementation
//
#define MAX_TREBLE 6.0
#define MAX_BASS   6.0

//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::put_Loudness
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::put_Loudness(BOOL fLoudness)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): put_Loudness to %ld")
            , fLoudness ) );

    PQKSAUDNODE_ELEM pNode;
    IPin * pPin;
    
    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_LOUDNESS
                               , 0 );
    if (SUCCEEDED( hr ) )
    {
        hr = SetNodeBoolean( NULL, pNode, fLoudness );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "PutNodeBoolean (LOUDNESS): fLoudness = %ld" )
                    , fLoudness ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "PutNodeBoolean (LOUDNESS) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::get_Loudness
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::get_Loudness(BOOL *pfLoudness)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): get_Loudness") ) );

    if (pfLoudness == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;

    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_LOUDNESS
                               , 0 );
    if (SUCCEEDED( hr ) )
    {
        hr = GetNodeBoolean( NULL, pNode, pfLoudness );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "GetNodeBoolean (LOUDNESS): *pfLoudness = %ld" )
                    , *pfLoudness ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "GetNodeBoolean (LOUDNESS) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::put_MixLevel
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::put_MixLevel(double Level)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): put_MixLevel to %s")
            , CDisp(Level) ) );

    // fix this later! wavein doesn't implement this either...
    if (Level == AMF_AUTOMATICGAIN)
        return E_NOTIMPL;

    if (Level < 0. || Level > 1.)
        return E_INVALIDARG;

    PQKSAUDNODE_ELEM pNode;

    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_VOLUME
                               , 0 );
    if (SUCCEEDED( hr ) )
    {
        double Pan;
        LONG lBalance;
        hr = get_Pan( &Pan );
        
        // scale the linear range for a volume node
        lBalance = (long) ( LINEAR_RANGE * Pan );
    
        // now scale the volume
        long lVolume = (long) ( LINEAR_RANGE * Level );
        DbgLog( ( LOG_TRACE 
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT("Setting volume to %d")
                , lVolume));

        // now set the volume for the wdm node
        // just pan center for now
        hr = SetNodeVolume( NULL, pNode, lVolume, lBalance, TRUE );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "Node Volume set on pin = %ld (lBalance = %ld)" )
                    , lVolume
                    , lBalance ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "SetNodeVolume failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::get_MixLevel
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::get_MixLevel(double *pLevel)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): get_MixLevel") ) );

    // !!! detect if we're using AGC?

    if (pLevel == NULL)
    return E_POINTER;
    
    PQKSAUDNODE_ELEM pNode;

    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_VOLUME
                               , 0 );
    if (SUCCEEDED( hr ) )
    {
        // scale the volume
        long lVolume;
    
        // get the volume for the node
        hr = GetNodeVolume( NULL, pNode, &lVolume, NULL, TRUE );
        if (SUCCEEDED(hr))
        {
            *pLevel = ( (double) lVolume ) / LINEAR_RANGE ;
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "get_MixLevel = %ld" )
                    , *pLevel ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "GetNodeVolume failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::put_Pan
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::put_Pan(double Pan)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): put_Pan %s")
            , CDisp(Pan) ) );

    if (Pan < -1. || Pan > 1.)
        return E_INVALIDARG;
        
    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_VOLUME
                               , 0 );
    if (SUCCEEDED( hr ) )
    {
        // if this isn't a stereo control, we can't pan
        if (pNode->cChannels != 2) {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT("*Can't pan: not stereo (cChannels = %d)!")
                    , pNode->cChannels ) );
            return E_NOTIMPL;
        }
        
        double MixLevel;
        hr = get_MixLevel( &MixLevel );
        LONG lVolume = (LONG) (LINEAR_RANGE * MixLevel);            
        
        // now scale the balance
        long lBalance = (long) ( LINEAR_RANGE * Pan );
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT("Setting volume to %ld, balance to %ld")
                , lVolume
                , lBalance ) );
    
        // now set the volume for the wdm node
        // just pan center for now
        hr = SetNodeVolume( NULL, pNode, lVolume, lBalance, TRUE );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "Pan set on pin = %ld (lVolume = %ld)" )
                    , lBalance
                    , lVolume ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "SetNodeVolume failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::get_Pan
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::get_Pan(double *pPan)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): get_Pan") ) );

    if ( !pPan )
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_VOLUME
                               , 0 );
    if (SUCCEEDED( hr ) )
    {
        // if this isn't a stereo control, we can't pan
        if (pNode->cChannels != 2) 
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT("Can't pan: not stereo (cChannels = %d)!")
                    , pNode->cChannels ) );
            *pPan = 0.0; // but center the pan value returned
            return E_NOTIMPL;
        }
        
        long lBalance;
        
        hr = GetNodeVolume( NULL, pNode, NULL, &lBalance, TRUE );
        if (SUCCEEDED(hr))
        {
            *pPan = ((double)lBalance) / LINEAR_RANGE;
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "get_Pan returning = %s" )
                    , CDisp(*pPan) ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "get_Pan failed [0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::put_Treble
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::put_Treble(double Treble)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): put_Treble to %s")
            , CDisp(Treble) ) );

    if (Treble < MAX_TREBLE * -1. || Treble > MAX_TREBLE)
        return E_INVALIDARG;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_TONE
                               , KSPROPERTY_AUDIO_TREBLE );
    if (SUCCEEDED( hr ) )
    {
        DWORD treble = (DWORD)(Treble / MAX_TREBLE * LINEAR_RANGE);
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT("Setting treble to %d")
                , treble) );

        hr = SetNodeTone( NULL, pNode, treble );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "Node tone (treble) set on pin = %ld" )
                    , treble ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "SetNodeTone (treble) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr; 
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::get_Treble
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::get_Treble(double *pTreble)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): get_Treble") ) );

    if (pTreble == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_TONE
                               , KSPROPERTY_AUDIO_TREBLE );
    if (SUCCEEDED( hr ) )
    {
        LONG treble;
        
        hr = GetNodeTone( NULL, pNode, &treble );
        if (SUCCEEDED(hr))
        {
            // convert the node current value to a linear range
            LONG lLinVol = VolLogToLinear (treble, pNode->MinValue, pNode->MaxValue);

            *pTreble = ((double)lLinVol / LINEAR_RANGE * MAX_TREBLE);

            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "Node tone (treble) gotten on pin = %s" )
                    , CDisp(*pTreble) ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "GetNodeTone (treble) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::get_TrebleRange
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::get_TrebleRange(double *pRange)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): get_TrebleRange") ) );

    if (pRange == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_TONE
                               , KSPROPERTY_AUDIO_TREBLE );
    if (SUCCEEDED( hr ) )
    {
        LONG treble;
        
        hr = GetNodeTone( NULL, pNode, &treble );
        if (SUCCEEDED(hr))
        {
            // fix this and do it the right way. below is how it's done in wavein
            *pRange = MAX_TREBLE;
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT("Treble range is %s.  I'M LYING !")
                    , CDisp(*pRange) ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "GetNodeTone (treble) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::put_Bass
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::put_Bass(double Bass)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): put_Bass to %s")
            , CDisp(Bass) ) );

    if (Bass < MAX_BASS * -1. || Bass > MAX_BASS)
        return E_INVALIDARG;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_TONE
                               , KSPROPERTY_AUDIO_BASS );
    if (SUCCEEDED( hr ) )
    {
        DWORD bass = (DWORD)(Bass / MAX_BASS * LINEAR_RANGE);
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT("Setting bass to %d")
                , bass ) );

        hr = SetNodeTone( NULL, pNode, bass );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "Node tone (bass) set on pin = %ld" )
                    , bass ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "SetNodeTone (bass) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::get_Bass
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::get_Bass(double *pBass)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): get_Bass") ) );

    if (pBass == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_TONE
                               , KSPROPERTY_AUDIO_BASS );
    if (SUCCEEDED( hr ) )
    {
        LONG bass;
        
        hr = GetNodeTone( NULL, pNode, &bass );
        if (SUCCEEDED(hr))
        {
            // convert the node current value to a linear range
            LONG lLinVol = VolLogToLinear (bass, pNode->MinValue, pNode->MaxValue);
            *pBass = ((double) lLinVol / LINEAR_RANGE * MAX_BASS);
                
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "Node tone (bass) gotten on pin = %ld" )
                    , CDisp(*pBass) ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "GetNodeTone (bass) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::put_Enable
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::put_Enable(BOOL fEnable)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): put_Enable") ) );

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_MUTE
                               , 0 );
    if (SUCCEEDED( hr ) )
    {
        hr = SetNodeMute( NULL, pNode, !fEnable );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "SetNodeMute : bMute = %ld" )
                    , !fEnable ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "SetNodeMute failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
    
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::get_Enable
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::get_Enable(BOOL *pfEnable)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): get_Enable") ) );
            
    if (pfEnable == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_MUTE
                               , 0 );
    if (SUCCEEDED( hr ) )
    {
        hr = GetNodeMute( NULL, pNode, pfEnable );
        if (SUCCEEDED(hr))
        {
            // flip flop the Mute state for Enable
            *pfEnable = !(*pfEnable);
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "GetNodeMute: *pfMute = %ld" )
                    , *pfEnable ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "GetNodeMute (ENABLE) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
    
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::get_BassRange
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::get_BassRange(double *pRange)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (filter): get_BassRange") ) );

    if (pRange == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = AIMGetDestNode( &pNode
                               , KSNODETYPE_TONE
                               , KSPROPERTY_AUDIO_BASS );
    if (SUCCEEDED( hr ) )
    {
        LONG bass;
        
        hr = GetNodeTone( NULL, pNode, &bass );
        if (SUCCEEDED(hr))
        {
            // fix this and do it the right way. below is how it's done in wavein
            *pRange = MAX_BASS;
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT("Bass range is %s.  I'M LYING !")
                    , CDisp(*pRange) ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "GetNodeTone (bass) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::put_Mono
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::put_Mono(BOOL fMono)
{
    return E_NOTIMPL;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::get_Mono
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::get_Mono(BOOL *pfMono)
{
    return E_NOTIMPL;
}

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// Filter level helper methods
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::AIMGetDestNode
//
// Helper function which Inits the topology, finds the capture pin, and 
// retrives the destination node.
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::AIMGetDestNode
( 
    PQKSAUDNODE_ELEM *  ppNode,
    REFCLSID            clsidType,
    ULONG               ulPropertyId 
)
{
    HRESULT hr = InitTopologyInfo();
    if (SUCCEEDED(hr))
    {
        IPin * pPin = NULL;
        hr = GetCapturePin( &pPin ); // note: GetCapturePin doesn't hold a ref count
        if( SUCCEEDED( hr ) )
        {   
            //
            // now to handle nodes which branch back to multiple parents we want to
            // make sure we branch back to a capture type input, i.e. NOT the pcm input
            // pin for a device which also supports output. to do this we pass the 
            // from one of the input pin handlers.
            //
            IPin * pSrcPin = NULL;
            
            for( POSITION Position = m_lstPinHandler.GetHeadPosition(); Position ; )
            {            
                CQKsAudIntfPinHandler * PinIntfHandler = m_lstPinHandler.Get( Position );
                IPin * pTmpPin = PinIntfHandler->GetPin();
                IAMAudioInputMixer * pAIM;
                
                HRESULT hrTmp = pTmpPin->QueryInterface( IID_IAMAudioInputMixer, (void **) &pAIM );
                if( SUCCEEDED( hrTmp ) )
                {
                    // this is a capture input pin
                    pAIM->Release();
                    pSrcPin = pTmpPin;
                    break;
                }                    
                Position = m_lstPinHandler.Next( Position );
            }        
             
            hr = GetNextNodeFromDestPin( NULL
                                      , ppNode
                                      , pPin
                                      , clsidType
                                      , pSrcPin
                                      , ulPropertyId );
                                       
        }
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::AIMGetSrcNode
//
// Helper function which Inits the topology, finds the capture pin, and 
// retrieves the source node.
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::AIMGetSrcNode
( 
    PQKSAUDNODE_ELEM *  ppNode,
    IPin *              pPin,
    REFCLSID            clsidType,
    ULONG               ulPropertyId 
)
{
    HRESULT hr = InitTopologyInfo();
    if (SUCCEEDED(hr))
    {
        PQKSAUDNODE_ELEM pNode;
        
        IPin * pDestPin;
        hr = GetCapturePin( &pDestPin ); 
        if( SUCCEEDED( hr ) )
        {        
            hr = GetNextNodeFromSrcPin( NULL
                                      , ppNode
                                      , pPin
                                      , clsidType
                                      , pDestPin
                                      , ulPropertyId );
        }
    }
    return hr;
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// IAMAudioInputMixer methods - Pin level
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::put_Mono
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::put_Mono(BOOL fMono)
{
    return E_NOTIMPL;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::get_Mono
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::get_Mono(BOOL *pfMono)
{
    return E_NOTIMPL;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::put_Loudness
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::put_Loudness(BOOL fLoudness)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): put_Loudness to %ld")
            , fLoudness ) );


    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_LOUDNESS
                                                , 0 );
    if (SUCCEEDED( hr ) )
    {
        hr = m_pFilterHandler->SetNodeBoolean( NULL, pNode, fLoudness );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "PutNodeBoolean (LOUDNESS): fLoudness = %ld" )
                    , fLoudness ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "PutNodeBoolean (LOUDNESS) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::get_Loudness
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::get_Loudness(BOOL *pfLoudness)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): get_Loudness") ) );

    if (pfLoudness == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_LOUDNESS
                                                , 0 );
    if (SUCCEEDED( hr ) )
    {
        hr = m_pFilterHandler->GetNodeBoolean( NULL, pNode, pfLoudness );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "GetNodeBoolean (LOUDNESS): *pfLoudness = %ld" )
                    , *pfLoudness ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "GetNodeBoolean (LOUDNESS) failed on pin[0x%lx]" )
                    , hr ) );
    }
     
     
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::put_MixLevel
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::put_MixLevel(double Level)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): put_MixLevel to %s")
            , CDisp(Level) ) );

    // !!! fix
    if (Level == AMF_AUTOMATICGAIN)
        return E_NOTIMPL;

    if (Level < 0. || Level > 1.)
        return E_INVALIDARG;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_VOLUME
                                                , 0 );
    if (SUCCEEDED( hr ) )
    {
        double Pan;
        LONG lBalance;
        hr = get_Pan( &Pan );
        lBalance = (long) (LINEAR_RANGE * Pan);
        
        // now scale the volume
        long lVolume = (long) ( LINEAR_RANGE * Level );
        DbgLog( ( LOG_TRACE 
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT("Setting volume to %d")
                , lVolume));

        // now set the volume for the wdm node
        // just pan center for now
        hr = m_pFilterHandler->SetNodeVolume( NULL, pNode, lVolume, lBalance, TRUE );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "Node Volume set on pin = %ld (lBalance = %ld)" )
                    , lVolume
                    , lBalance ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "SetNodeVolume failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::get_MixLevel
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::get_MixLevel(double *pLevel)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): get_MixLevel") ) );

    // !!! detect if we're using AGC?
    if (pLevel == NULL)
        return E_POINTER;
    
    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_VOLUME
                                                , 0 );
    if (SUCCEEDED( hr ) )
    {
        long lVolume;
        
        // get the volume for the node
        hr = m_pFilterHandler->GetNodeVolume( NULL, pNode, &lVolume, NULL, TRUE );
        if (SUCCEEDED(hr))
        {
            *pLevel = ( (double) lVolume ) / LINEAR_RANGE ;
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "get_MixLevel = %s" )
                    , CDisp(*pLevel) ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "GetNodeVolume failed on pin[0x%lx]" )
                    , hr ) );

    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::put_Pan
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::put_Pan(double Pan)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): put_Pan %s")
            , CDisp(Pan) ) );

    if (Pan < -1. || Pan > 1.)
        return E_INVALIDARG;
        
    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_VOLUME
                                                , 0 );
    if (SUCCEEDED( hr ) )
    {
        // if this isn't a stereo control, we can't pan
        if (pNode->cChannels != 2) {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT("Can't pan: not stereo (cChannels = %d)!")
                    , pNode->cChannels ) );
            return E_NOTIMPL;
        }
        
        double MixLevel;
        hr = get_MixLevel( &MixLevel );
        LONG lVolume = (LONG) (LINEAR_RANGE * MixLevel);            
        
        // now scale the balance
        long lBalance = (long) ( LINEAR_RANGE * Pan );
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT("Setting volume to %ld, balance to %ld")
                , lVolume
                , lBalance ) );

        // now set the volume for the wdm node
        // just pan center for now
        hr = m_pFilterHandler->SetNodeVolume( NULL, pNode, lVolume, lBalance, TRUE );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "Pan set on pin = %ld (lVolume = %ld)" )
                    , lBalance
                    , lVolume ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "SetNodeVolume failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
        
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::get_Pan
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::get_Pan(double *pPan)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): get_Pan") ) );

    if (pPan == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_VOLUME
                                                , 0 );
    if (SUCCEEDED( hr ) )
    {
        // if this isn't a stereo control, we can't pan
        if (pNode->cChannels != 2) {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT("Can't pan: not stereo (cChannels = %d)!")
                    , pNode->cChannels ) );
            *pPan = 0.0;  // but center the pan value returned
            return E_NOTIMPL;
        }
        
        long lBalance;
        hr = m_pFilterHandler->GetNodeVolume( NULL, pNode, NULL, &lBalance, TRUE );
        if (SUCCEEDED(hr))
        {
            *pPan = ((double)lBalance) / LINEAR_RANGE;
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "get_Pan returning = %s" )
                    , CDisp(*pPan) ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "get_Pan failed [0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::put_Treble
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::put_Treble(double Treble)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): put_Treble to %s")
            , CDisp(Treble) ) );

    if (Treble < MAX_TREBLE * -1. || Treble > MAX_TREBLE)
        return E_INVALIDARG;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_TONE
                                                , KSPROPERTY_AUDIO_TREBLE );
    if (SUCCEEDED( hr ) )
    {
        DWORD treble = (DWORD)(Treble / MAX_TREBLE * LINEAR_RANGE);
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT("Setting treble to %d")
                , treble) );

        hr = m_pFilterHandler->SetNodeTone( NULL, pNode, treble );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "Node tone (treble) set on pin = %ld" )
                    , treble ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "SetNodeTone (treble) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::get_Treble
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::get_Treble(double *pTreble)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): get_Treble") ) );

    if (pTreble == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;
    
    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_TONE
                                                , KSPROPERTY_AUDIO_TREBLE );
    if (SUCCEEDED( hr ) )
    {
        LONG treble;
        
        hr = m_pFilterHandler->GetNodeTone( NULL, pNode, &treble );
        if (SUCCEEDED(hr))
        {
            LONG lLinVol = VolLogToLinear (treble, pNode->MinValue, pNode->MaxValue);
            *pTreble = ((double)lLinVol / LINEAR_RANGE * MAX_TREBLE);
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "Node tone (treble) gotten on pin = %s" )
                    , CDisp(*pTreble) ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "GetNodeTone (treble) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::get_TrebleRange
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::get_TrebleRange(double *pRange)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): get_TrebleRange") ) );

    if (pRange == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;

    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_TONE
                                                , KSPROPERTY_AUDIO_TREBLE );
    if (SUCCEEDED( hr ) )
    {
        LONG treble;
        
        hr = m_pFilterHandler->GetNodeTone( NULL, pNode, &treble );
        if (SUCCEEDED(hr))
        {
            // fix this and do it the right way. below is how it's done in wavein
            *pRange = MAX_TREBLE;
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT("Treble range is %s.  I'M LYING !")
                    , CDisp(*pRange) ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "GetNodeTone (treble) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::put_Bass
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::put_Bass(double Bass)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): put_Bass to %s")
            , CDisp(Bass) ) );

    if (Bass < MAX_BASS * -1. || Bass > MAX_BASS)
        return E_INVALIDARG;


    PQKSAUDNODE_ELEM pNode;

    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_TONE
                                                , KSPROPERTY_AUDIO_BASS );
    if (SUCCEEDED( hr ) )
    {
        DWORD bass = (DWORD)(Bass / MAX_BASS * LINEAR_RANGE);
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT("Setting bass to %d")
                , bass ) );

        hr = m_pFilterHandler->SetNodeTone( NULL, pNode, bass );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "Node tone (bass) set on pin = %ld" )
                    , bass ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "SetNodeTone (bass) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::get_Bass
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::get_Bass(double *pBass)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): get_Bass") ) );

    if (pBass == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;

    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_TONE
                                                , KSPROPERTY_AUDIO_BASS );
    if (SUCCEEDED( hr ) )
    {
        LONG bass;
        
        hr = m_pFilterHandler->GetNodeTone( NULL, pNode, &bass );
        if (SUCCEEDED(hr))
        {
            LONG lLinVol = VolLogToLinear (bass, pNode->MinValue, pNode->MaxValue);
            *pBass = ((double) lLinVol / LINEAR_RANGE * MAX_BASS);
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "Node tone (bass) gotten on pin = %ld" )
                    , CDisp(*pBass) ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "GetNodeTone (bass) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::put_Enable
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::put_Enable(BOOL fEnable)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): put_Enable") ) );

    PQKSAUDNODE_ELEM pNode;

    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_MUTE
                                                , 0 );
    if (SUCCEEDED( hr ) )
    {
        hr = m_pFilterHandler->SetNodeMute( NULL, pNode, !fEnable );
        if (SUCCEEDED(hr))
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "SetNodeMute (ENABLE): bMute = %ld" )
                    , !fEnable ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "SetNodeMute (ENABLE) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::get_Enable
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::get_Enable(BOOL *pfEnable)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("IAMAudioInputMixer (pin): get_Enable") ) );
            
    if (pfEnable == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;

    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_MUTE
                                                , 0 );
    if (SUCCEEDED( hr ) )
    {
        hr = m_pFilterHandler->GetNodeMute( NULL, pNode, pfEnable );
        if (SUCCEEDED(hr))
        {
            *pfEnable = !( *pfEnable );
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "GetNodeMute : *pfMute = %ld" )
                    , *pfEnable ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "GetNodeMute failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::get_BassRange
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfPinHandler::get_BassRange(double *pRange)
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("KsProxy Pin: get_BassRange") ) );

    if (pRange == NULL)
        return E_POINTER;

    PQKSAUDNODE_ELEM pNode;

    HRESULT hr = m_pFilterHandler->AIMGetSrcNode( &pNode
                                                , m_pPin
                                                , KSNODETYPE_TONE
                                                , KSPROPERTY_AUDIO_BASS );
    if (SUCCEEDED( hr ) )
    {
        LONG bass;
        
        hr = m_pFilterHandler->GetNodeTone( NULL, pNode, &bass );
        if (SUCCEEDED(hr))
        {
            // fix this and do it the right way. below is how it's done in wavein
            *pRange = MAX_BASS;
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT("Bass range is %s.  I'M LYING !")
                    , CDisp(*pRange) ) );
        }
        else
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "GetNodeTone (bass) failed on pin[0x%lx]" )
                    , hr ) );
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\qksaud\basicaud.cpp ===
//--------------------------------------------------------------------------;
//
//  File: BasicAud.cpp
//
//  Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//      Implements IBasicAudio for KsProxy audio filters
//      
//  History:
//      10/05/98    msavage     created
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "ks.h"
#include "ksmedia.h"
#include <ksproxy.h>
#include "ksaudtop.h"
#include "qksaud.h"

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// IBasicAudio methods - Filter level
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::put_Volume
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfHandler::put_Volume(IN long lVolume)
{
    if (lVolume < -10000 || lVolume > 0)
        return E_INVALIDARG;
        
    HRESULT hr = InitTopologyInfo();

    if (SUCCEEDED(hr))
    {
        // bug!! init m_lVolume to a non-possible value.
        if ( lVolume == m_lVolume )
            return S_OK;
            
        PQKSAUDNODE_ELEM pNode;
        
        m_lVolume = lVolume;
        SetBasicAudDirty();
        for( POSITION Position = m_lstPinHandler.GetHeadPosition(); Position; )
        {
            // update volume on all connected pin handlers
            CQKsAudIntfPinHandler * PinIntfHandler = m_lstPinHandler.Get( Position );
            if( PinIntfHandler->IsKsPinConnected() )
            {            
                hr = PinIntfHandler->put_Volume( m_lVolume );
            }
            Position = m_lstPinHandler.Next( Position );
        }        
    }    
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::get_Volume
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfHandler::get_Volume(OUT long *plVolume)
{
    if (!plVolume)
        return E_POINTER;
        
    HRESULT hr = InitTopologyInfo();
    if (SUCCEEDED(hr))
    {
        // if we're connected and haven't made a put_ call than just query the first connected pin
        // connected pin
        for( POSITION Position = m_lstPinHandler.GetHeadPosition(); Position; )
        {
            CQKsAudIntfPinHandler * PinIntfHandler = m_lstPinHandler.Get( Position );
            if( PinIntfHandler->IsKsPinConnected() )
            {
                hr = PinIntfHandler->get_Volume( plVolume );
                break;
            }
            Position = m_lstPinHandler.Next( Position );
        }        
    }
    
    return hr;
}   
 
//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::put_Balance
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfHandler::put_Balance(IN long lBalance)
{
    if (lBalance < -10000 || lBalance > 10000)
        return E_INVALIDARG;
        
    HRESULT hr = InitTopologyInfo();

    if (SUCCEEDED(hr))
    {
        if ( lBalance == m_lBalance )
            return S_OK;
            
        m_lBalance = lBalance;
        SetBasicAudDirty();

        for( POSITION Position = m_lstPinHandler.GetHeadPosition(); Position; )
        {
            // update balance on all pin handlers
            CQKsAudIntfPinHandler * PinIntfHandler = m_lstPinHandler.Get( Position );
        
            if( PinIntfHandler->IsKsPinConnected() )
            {
                hr = PinIntfHandler->put_Balance( m_lBalance );
            }
            Position = m_lstPinHandler.Next( Position );
        }        
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::get_Balance
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfHandler::get_Balance(OUT long *plBalance)
{

    if (!plBalance)
        return E_POINTER;
        
    HRESULT hr = InitTopologyInfo();
    if (SUCCEEDED(hr))
    {
        // if we're connected and haven't made a put_ call than just query the first connected pin
        // connected pin
        for( POSITION Position = m_lstPinHandler.GetHeadPosition(); Position; )
        {
            CQKsAudIntfPinHandler * PinIntfHandler = m_lstPinHandler.Get( Position );
            if( PinIntfHandler->IsKsPinConnected() )
            {
                hr = PinIntfHandler->get_Balance( plBalance );
            }
            Position = m_lstPinHandler.Next( Position );
        }        
    }
    
    return hr;
}

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// IBasicAudio methods - Pin level
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::put_Volume
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfPinHandler::put_Volume(IN long lVolume)
{
    if (lVolume < -10000 || lVolume > 0)
        return E_INVALIDARG;

    // bug!! init m_lPinVolume to a non-possible value.
    if ( lVolume == m_lPinVolume )
        return S_OK;
            
    HRESULT hr = m_pFilterHandler->InitTopologyInfo();
    if (SUCCEEDED(hr))
    {
        PQKSAUDNODE_ELEM pNode;
        
        hr = m_pFilterHandler->GetNextNodeFromSrcPin( m_pKsControl, &pNode, m_pPin, KSNODETYPE_VOLUME, NULL, 0 );
        if (SUCCEEDED( hr ) )
        {
            // now scale the volume for the ksproperty
            hr = m_pFilterHandler->SetNodeVolume( m_pKsControl, pNode, lVolume, m_lPinBalance );
            if (SUCCEEDED(hr))
            {
                m_lPinVolume = lVolume;
                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_DETAILS
                        , TEXT( "Node Volume set on pin = %ld" )
                        , lVolume ) );
            }
            else
                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_FAILURES
                        , TEXT( "SetNodeVolume failed on pin[0x%lx]" )
                        , hr ) );
        }
    }    
    return hr;
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::get_Volume
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfPinHandler::get_Volume(OUT long *plVolume)
{
    if (!plVolume)
        return E_POINTER;
        
    HRESULT hr = m_pFilterHandler->InitTopologyInfo();
    if (SUCCEEDED(hr))
    {
        PQKSAUDNODE_ELEM pNode;

        hr = m_pFilterHandler->GetNextNodeFromSrcPin( m_pKsControl, &pNode, m_pPin, KSNODETYPE_VOLUME, NULL, 0 );
        if (SUCCEEDED( hr ) )
        {
            hr = m_pFilterHandler->GetNodeVolume( m_pKsControl, pNode, plVolume, NULL );
            if (SUCCEEDED(hr))
            {
                m_lPinVolume = *plVolume;
                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_DETAILS
                        , TEXT( "GetNodeVolume on pin returned = %ld" )
                        , *plVolume ) );
            }
            else
                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_FAILURES
                        , TEXT( "GetNodeVolume on pin failed[0x%lx]" )
                        , hr ) );
        }
    }    
    return hr;
    
}   
 
//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::put_Balance
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfPinHandler::put_Balance(IN long lBalance)
{
    if (lBalance < -10000 || lBalance > 10000)
        return E_INVALIDARG;
        
    // bug!! init m_lPinBalance to a non-possible value.
    if ( lBalance == m_lPinBalance )
        return S_OK;
            
    HRESULT hr = m_pFilterHandler->InitTopologyInfo();
    if (SUCCEEDED(hr))
    {
        PQKSAUDNODE_ELEM pNode;
        
        hr = m_pFilterHandler->GetNextNodeFromSrcPin( m_pKsControl, &pNode, m_pPin, KSNODETYPE_VOLUME, NULL, 0 );
        if (SUCCEEDED( hr ) )
        {
            // now scale the volume for the ksproperty
            hr = m_pFilterHandler->SetNodeVolume( m_pKsControl, pNode, m_lPinVolume, lBalance );
            if (SUCCEEDED(hr))
            {
                m_lPinBalance = lBalance;
                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_DETAILS
                        , TEXT( "Node Balance set on pin = %ld" )
                        , lBalance ) );
            }
            else
                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_FAILURES
                        , TEXT( "SetNodeVolume failed on pin[0x%lx]" )
                        , hr ) );
        }
    }    
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::get_Balance
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfPinHandler::get_Balance(OUT long *plBalance)
{
    if (!plBalance)
        return E_POINTER;
        
    HRESULT hr = m_pFilterHandler->InitTopologyInfo();
    if (SUCCEEDED(hr))
    {
        PQKSAUDNODE_ELEM pNode;

        hr = m_pFilterHandler->GetNextNodeFromSrcPin( m_pKsControl, &pNode, m_pPin, KSNODETYPE_VOLUME, NULL, 0 );
        if (SUCCEEDED( hr ) )
        {
            hr = m_pFilterHandler->GetNodeVolume( m_pKsControl, pNode, NULL, plBalance );
            if (SUCCEEDED(hr))
            {
                m_lPinBalance = *plBalance;
                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_DETAILS
                        , TEXT( "GetNodeVolume on pin returned balance = %ld" )
                        , *plBalance ) );
            }
            else
                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_FAILURES
                        , TEXT( "GetNodeVolume on pin failed[0x%lx]" )
                        , hr ) );
        }
    }    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\qksaud\ksaudtop.h ===
//--------------------------------------------------------------------------;
//
//  File: KsAudTop.h
//
//  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//      Header file for wdm audio parsing class for KsProxy
//      
//  History:
//      10/05/98    msavage     created, much of the parsing code based on 
//                              wdmaud mixer line code.
//
//--------------------------------------------------------------------------;

#define PINID_WILDCARD ( (ULONG) -2 )
#define MAX_CHANNELS    2
#define MASTER_CHANNEL  ( (ULONG) -1 )
#define LEFT_CHANNEL    0
#define RIGHT_CHANNEL   1
#define UNIFORM_CHANNEL LEFT_CHANNEL

typedef enum tagNODE_TYPE { SOURCE, DESTINATION, NODE } NODE_TYPE;

typedef struct tagPEERNODE* PEERLIST;

typedef struct tagQKSAUD_NODE_ELEM {
    SINGLE_LIST_ENTRY  List;            // MUST BE THE FIRST MEMBER!
    NODE_TYPE          Type;            // Type of node: SOURCE, DEST, or NODE
    GUID               NodeType;        // KSNODETYPE of the node
    ULONG              PropertyId;      // default PropertyId for node
    ULONG              Id;              // Pin or node ID
    PEERLIST           Children;        // List of Children
    PEERLIST           Parents;         // List of Parents
    DWORD              MaxValue;        // Max property value
    DWORD              MinValue;        // Min property value
    DWORD              Granularity;     // Property granularity
    DWORD              ChannelMask;     // Channel support
    DWORD              cChannels;
    BOOL               bMute;
    BOOL               bDetailsSet;      // Indicates whether property node details have 
                                         // been initialized for this node.
    PEERLIST           Clones;           // copies of same node to allow multiple

    union {
        //
        // Supermixer parameters
        //
        struct {
            ULONG                 Size;
            PKSAUDIO_MIXCAP_TABLE pMixCaps;
            PKSAUDIO_MIXLEVEL     pMixLevels;   // Stored mix levels
        };
    } Parameters;

} QKSAUDNODE_ELEM, *PQKSAUDNODE_ELEM, *QKSAUDNODE_LIST;


typedef struct tagPEERNODE 
{
    SINGLE_LIST_ENTRY   List;        // MUST BE THE FIRST MEMBER!
    PQKSAUDNODE_ELEM    pNode;       // Pointer to the topology node element
} PEERNODE, *PPEERNODE;


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// ks audio topology parsing class
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
class CKsAudHelper
{

public:

    CKsAudHelper( void );
    ~CKsAudHelper( void );

protected:

    IKsPropertySet * m_pKsPropSet;
    IKsControl     * m_pKsControl;

    //--------------------------------------------------------------------------;
    //
    // Audio Node property set/get wrappers - candidates for an interface TBD
    //
    //--------------------------------------------------------------------------;
    HRESULT GetNextNodeFromDestPin
    (   
        IKsControl *        pKsControl,
        PQKSAUDNODE_ELEM *  ppNode,
        IPin *              pPin,
        REFCLSID            clsidNodeType,
        IPin *              pSrcPin,
        ULONG               PropertyId
    );

    HRESULT GetNextNodeFromSrcPin
    (   
        IKsControl * pKsControl,
        PQKSAUDNODE_ELEM * ppNode,
        IPin *     pPin,
        REFCLSID   clsidNodeType,
        IPin *     pDestPin,
        ULONG      PropertyId
    );

    HRESULT GetNodeVolume
    (
        IKsControl *     pKsControl,
        PQKSAUDNODE_ELEM pNode,
        LONG *           plVolume,
        LONG *           plBalance,
        BOOL             bLinear = FALSE
    );

    HRESULT SetNodeVolume
    (
        IKsControl *     pKsControl,
        PQKSAUDNODE_ELEM pNode,
        LONG             lVolume,
        LONG             lBalance,
        BOOL             bLinear = FALSE
    );

    HRESULT SetNodeTone
    (   
        IKsControl * pKsControl,
        PQKSAUDNODE_ELEM   pNode,
        LONG lLevel
    );

    HRESULT GetNodeTone
    (   
        IKsControl * pKsControl,
        PQKSAUDNODE_ELEM   pNode,
        LONG *plLevel
    );

    HRESULT SetNodeBoolean
    (   
        IKsControl *        pKsControl,
        PQKSAUDNODE_ELEM    pNode,
        BOOL                Bool
    );

    HRESULT GetNodeBoolean
    (   
        IKsControl *        pKsControl,
        PQKSAUDNODE_ELEM    pNode,
        BOOL *              pBool
    );

    HRESULT SetNodeMute
    (   
        IKsControl *        pKsControl,
        PQKSAUDNODE_ELEM    pNode,
        BOOL                Bool
    );

    HRESULT GetNodeMute
    (   
        IKsControl *        pKsControl,
        PQKSAUDNODE_ELEM    pNode,
        BOOL *              pBool
    );

    HRESULT GetProperty
    (
        const GUID   *pPSGUID,          // The requested property set
        DWORD        dwPropertyId,      // The ID of the specific property
        ULONG        cbInput,           // The number of extra input bytes
        PBYTE        pInputData,        // Pointer to the extra input bytes
        PBYTE        *ppPropertyOutput  // Pointer to a pointer of the output
    );

    //--------------------------------------------------------------------------;
    //
    // low level parsing methods
    //
    //--------------------------------------------------------------------------;

    HRESULT QueryTopology( void );
    HRESULT InitTopologyInfo(void);
    HRESULT ParseTopology(void);
    HRESULT BuildNodeTable(void);

    ULONG FindTopologyConnection
    (
        ULONG    StartIndex,     // Index to start search
        ULONG    FromNode,       // The Node ID to look for
        ULONG    FromNodePin     // The Pin ID to look for
    );

    HRESULT BuildChildGraph
    (
        PQKSAUDNODE_ELEM    pNode,         // The node to build the graph for
        ULONG               FromNode,      // The node's ID
        ULONG               FromNodePin    // The Pin connection to look for
    );

    ULONG SupportsControl
    (
        IKsControl * pKsControl,
        ULONG        Node,           // The node id to query
        ULONG        Property        // The property to check for
    );

    HRESULT LoadNodeDetails
    (
        IKsControl *          pKsControl,
        PQKSAUDNODE_ELEM  pNode
    );

    HRESULT InitDestinationControls( void );
    HRESULT InitSourceControls( void );
    HRESULT TraverseAndInitSourcePathControls( PQKSAUDNODE_ELEM pNode );

    HRESULT GetControlRange
    (
        IKsControl * pKsControl,
        QKSAUDNODE_ELEM * pControl 
    );

    HRESULT QueryPropertyRange
    (
        IKsControl *            pKsControl,
        CONST GUID*             pguidPropSet,
        ULONG                   ulPropertyId,
        ULONG                   ulNodeId,
        PKSPROPERTY_DESCRIPTION* ppPropDesc
    );

    HRESULT GetSuperMixCaps
    (
        IKsControl *           pKsControl,
        ULONG                  ulNodeId,
        PKSAUDIO_MIXCAP_TABLE* paMixCaps
    );

    HRESULT GetMuteFromSuperMix
    (
        IKsControl *           pKsControl,
        QKSAUDNODE_ELEM *      pNode,
        BOOL *                 pBool
    );

    HRESULT SetMuteFromSuperMix
    (
        IKsControl *           pKsControl,
        QKSAUDNODE_ELEM *      pNode,
        BOOL                   Bool
    );

    BOOL FindDestinationPin
    (
        PQKSAUDNODE_ELEM pNode,      // The starting node for the connection search
        ULONG            ulDestPinId // The destination pin we want to reach
    );

    BOOL FindSourcePin
    (
        PQKSAUDNODE_ELEM pNode,      // The starting node for the connection search
        ULONG            ulSrcPinId  // The destination pin we want to reach
    );

    PQKSAUDNODE_ELEM FindDestination
    (
        ULONG           Id          // The node Id to look for in the list
    );


    BOOL CheckSupport
    (
        IN  PQKSAUDNODE_ELEM  pNode
    );

    //
    // lower lever node helpers
    //
    HRESULT GetAudioNodeProperty
    (
        IKsControl * pKsControl,
        ULONG        ulPropertyId,      // The audio property to get
        ULONG        ulNodeId,          // The virtual node id
        LONG         lChannel,          // The channel number
        PVOID        pInData,           // Pointer to extra input bytes
        ULONG        cbInData,          // Number of extra input bytes
        PVOID        pOutData,          // Pointer to output buffer
        LONG         cbOutData          // Size of the output buffer
    );

    HRESULT SetAudioNodeProperty
    (
        IKsControl * pKsControl,
        ULONG        ulPropertyId,      // The audio property to get
        ULONG        ulNodeId,          // The virtual node id
        LONG         lChannel,          // The channel number
        PVOID        pInData,           // Pointer to extra input bytes
        ULONG        cbInData,          // Number of extra input bytes
        PVOID        pOutData,          // Pointer to output buffer
        LONG         cbOutData          // Size of the output buffer
    );

    BOOL IsDestinationNode
    (
        PQKSAUDNODE_ELEM pNode           // The node to check
    );

private:
    
    PKSTOPOLOGY      m_pKsTopology;
    QKSAUDNODE_LIST  m_pKsNodeTable;
    QKSAUDNODE_LIST  m_listSources;
    QKSAUDNODE_LIST  m_listDests;
    HRESULT          m_hrTopologyInitStatus;

};

//--------------------------------------------------------------------------;
//
// List processing macros
//
//--------------------------------------------------------------------------;
#define AddToList( pNodeList, pNode )                                   \
            if( pNodeList ) {                                           \
                (pNode)->List.Next = (SINGLE_LIST_ENTRY *) (pNodeList); \
                (pNodeList)        = (pNode);                           \
            } else {                                                    \
                (pNodeList) = (pNode);                                  \
            }

#define AddToChildList( NodeList, Node )                          \
            ASSERT( (Node)->pNode );                                  \
            AddToList( (NodeList)->Children, (Node) );

#define AddToParentList( NodeList, Node )                         \
            ASSERT( (Node)->pNode );                                  \
            AddToList( (NodeList)->Parents, (Node) );

#define AddToCloneList( NodeList, Node )                         \
            ASSERT( (Node)->pNode );                                  \
            AddToList( (NodeList)->Clones, (Node) );

#define ParentListLength( pNode ) ListCount( (SINGLE_LIST_ENTRY *) pNode->Parents  )
#define ChildListLength( pNode )  ListCount( (SINGLE_LIST_ENTRY *) pNode->Children )
#define CloneListLength( pNode )  ListCount( (SINGLE_LIST_ENTRY *) pNode->Clones )
#define ListLength( List )        ListCount( (SINGLE_LIST_ENTRY *) List            )


#define FirstInList( NodeList )  ( NodeList )
#define FirstChildNode( pNode )  (( PEERNODE* ) (pNode)->Children )
#define FirstParentNode( pNode ) (( PEERNODE* ) (pNode)->Parents  )
#define FirstCloneNode( pNode ) (( PEERNODE* ) (pNode)->Clones  )


//--------------------------------------------------------------------------;
//
// Next in list retrieval macros
//
//--------------------------------------------------------------------------;
#define NextInList( pList, Type )   (( Type* ) ( pList->List.Next ) )

#define NextNode( pNode )       NextInList( pNode,    QKSAUDNODE_ELEM    )
#define NextPeerNode( pNode )   NextInList( pNode,    PEERNODE   )

// list removal macros

//--------------------------------------------------------------------------;
//
// Remove from a list macros
//
//--------------------------------------------------------------------------;
#define RemoveFirstEntry( list, Type )                                \
            (Type*) (list);                                           \
            {                                                         \
                SINGLE_LIST_ENTRY * pRFETemp;                       \
                pRFETemp = (SINGLE_LIST_ENTRY *) (list);              \
                if( (list) ) {                                        \
                    (list) = (Type*) (list)->List.Next;               \
                    if( pRFETemp ) {                                  \
                        ((Type*) pRFETemp)->List.Next = NULL;         \
                    }                                                 \
                }                                                     \
            }


#define RemoveFirstNode( pNodeList )                                  \
            RemoveFirstEntry( (pNodeList), QKSAUDNODE_ELEM )

#define RemoveFirstPeerNode( pPeerList )                              \
            RemoveFirstEntry( (pPeerList), PEERNODE )

#define RemoveFirstChildNode( pNode )                                 \
            RemoveFirstEntry( (pNode)->Children, PEERNODE )

#define RemoveFirstParentNode( pNode )                                \
            RemoveFirstEntry( (pNode)->Parents, PEERNODE )

#define RemoveFirstCloneNode( pNode )                                \
            RemoveFirstEntry( (pNode)->Clones, PEERNODE )


ULONG
ListCount(
    SINGLE_LIST_ENTRY * pList     // The list to count the elements of
);

BOOL InList(
    PEERLIST             list,      // The list to search
    PQKSAUDNODE_ELEM  pNewNode   // The new to search for
);

BOOL InChildList(
    QKSAUDNODE_LIST list,    // The list to search the parent list
    PQKSAUDNODE_ELEM pNewNode // The node to search for
);

BOOL InParentList(
    QKSAUDNODE_LIST list,    // The list to search the parent list
    PQKSAUDNODE_ELEM pNewNode // The node to search for
);

//--------------------------------------------------------------------------;
//
// Miscellaneous helpers
//
//--------------------------------------------------------------------------;

VOID FreePeerList
(
    PEERLIST list                    // The PeerList to free
);

STDMETHODIMP PinFactoryIDFromPin
(
    IPin  * pPin,
    ULONG * PinFactoryID
);

const char* KsPinCategoryToString
(
    CONST GUID* NodeType // The GUID to translate
);

const char* NodeTypeToString
(
    CONST GUID* NodeType // The GUID to translate
);

void CloneNode
( 
    PQKSAUDNODE_ELEM pDestNode, 
    PQKSAUDNODE_ELEM pSrcNode 
);


LONG VolLinearToLog
( 
    DWORD Value, 
    DWORD dwMinValue,
    DWORD dwMaxValue
);

LONG VolLogToLinear
(
    LONG       Value,
    LONG       lMinValue,
    LONG       lMaxValue
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\qksaud\ksaudtop.cpp ===
//--------------------------------------------------------------------------;
//
//  File: KsAudTop.cpp
//
//  Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//      WDM Audio topology parsing code helper class for KsProxy audio filters
//
//  History:
//      10/05/98    msavage     Created. Topology parsing code based on wdmaud mixer line code.
//
//
//  Methods defined in this class:
//
//      CKsAudHelper()
//      ~CKsAudHelper()
//      GetNextNodeFromDestPin()
//      GetNextNodeFromSrcPin()
//      InitTopologyInfo()
//      InitSourceControls()
//      TraverseAndInitSourcePathControls()
//      IsDestinationNode()
//      InitDestinationControls()
//      QueryTopology()
//      BuildNodeTable()
//      ParseTopology()
//      BuildChildGraph()
//      FindTopologyConnection()
//      GetProperty()
//      SupportsControl()
//      LoadNodeDetails()
//      CloneNode()
//      GetAudioNodeProperty()
//      SetAudioNodeProperty()
//      GetControlRange()
//      QueryPropertyRange()
//
//  Global functions:
//
//      KsPinCategoryToString()
//      PinFactoryIDFromPin()
//      NodeTypeToString()
//      FreePeerList()
//      InList()
//      BOOL InChildList()
//      BOOL InParentList()
//      PQKSAUDNODE_ELEM FindDestination()
//      ULONG ListCount()
//      LONG VolLinearToLog()
//      LONG VolLogToLinear()
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "ks.h"
#include "ksmedia.h"
#include <ksproxy.h>
#include "ksaudtop.h"
#include "qksaud.h"
#include <math.h>
#include <math.h>
#include <malloc.h>
#include <limits.h>
#define _AMOVIE_DB_
#include <decibels.h>

const double BA_TO_KS_DB_SCALE_FACTOR = 655.36; // use to convert IBasicAudio
                                                // units to ks volume units

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// CQKsAudHelper class methods
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;


//--------------------------------------------------------------------------;
//
// CKsAudHelper::CKsAudioHelper
//
// Constructor
//
//--------------------------------------------------------------------------;
CKsAudHelper::CKsAudHelper()
  : m_pKsPropSet(NULL),
    m_pKsControl(NULL),
    m_pKsTopology(NULL),
    m_pKsNodeTable(NULL),
    m_listSources(NULL),
    m_listDests(NULL)
{
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::~CKsAudioHelper
//
// Destructor
//
//--------------------------------------------------------------------------;
CKsAudHelper::~CKsAudHelper()
{
    //
    // Free up the source and destination lists.  Both types of these lists
    // are allocated list nodes and allocated nodes.  Both need to be freed.
    // The Children and Parent lists, though, are only allocated list nodes.
    // The actual nodes are contained in the node table and will be deallocated
    // in one chunk in the next block of code.
    //

    //
    // Note that the deallocation order is very important here!!
    // So we do things as follows:
    //      For each node in the mail
    //
    // Free up the peer lists for the children and parents inside the
    // nodes of the node table.  Finally, deallocate the array of nodes.
    //
    if( m_pKsNodeTable ) {
        ASSERT( m_pKsTopology );
        for( int i = 0; m_pKsTopology && i < (int) m_pKsTopology->TopologyNodesCount; i++ ) {

            FreePeerList( m_pKsNodeTable[ i ].Children );
            FreePeerList( m_pKsNodeTable[ i ].Parents );
            FreePeerList( m_pKsNodeTable[ i ].Clones );
        }
    }

    PQKSAUDNODE_ELEM pTemp;
    while( m_listSources ) {
        pTemp = RemoveFirstNode( m_listSources );
        FreePeerList( pTemp->Children );
        delete pTemp;
    }

    while( m_listDests ) {
        pTemp = RemoveFirstNode( m_listDests );
        FreePeerList( pTemp->Parents );
        delete pTemp;
    }

    if( m_pKsNodeTable )
    {
        // now free the node table
        delete m_pKsNodeTable;
        m_pKsNodeTable = NULL;
    }

    if( m_pKsTopology )
    {
        delete ( ( ( PKSMULTIPLE_ITEM ) m_pKsTopology->TopologyNodes ) - 1 );
        delete ( ( ( PKSMULTIPLE_ITEM ) m_pKsTopology->TopologyConnections ) - 1 );
        delete m_pKsTopology;
        m_pKsTopology = NULL;
    }


}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::InitTopologyInfo
//
// The call that starts it all. Builds the topology map for this filter.
// Parsing will be done only once per filter instance.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::InitTopologyInfo(void)
{
    HRESULT hr = S_OK;

    if (m_pKsTopology)
    {
        //
        // already initialized (or failed to)
        //
        return m_hrTopologyInitStatus;
    }

    m_pKsTopology = (PKSTOPOLOGY) new KSTOPOLOGY;
    if (!m_pKsTopology)
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "InitTopologyInfo: FAILED to allocate KSTOPOLOGY memory" )
                , hr ) );
        hr = E_OUTOFMEMORY;
    }
    if( SUCCEEDED( hr ) )
    {
        hr = QueryTopology();
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "InitTopologyInfo: QueryTopology() FAILED (0x%08lx)" )
                , hr ) );
    }
    if (SUCCEEDED( hr ) )
    {
        hr = BuildNodeTable();
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "InitTopologyInfo: BuildNodeTable() FAILED (0x%08lx)" )
                , hr ) );
    }
    if( SUCCEEDED( hr ) )
    {
        hr = ParseTopology();
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "InitTopologyInfo: ParseTopology() FAILED (0x%08lx)" )
                , hr ) );
    }
    if( SUCCEEDED( hr ) )
    {
        hr = InitDestinationControls();
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "InitTopologyInfo: InitDestinationControls() FAILED (0x%08lx)" )
                , hr ) );
    }
    if( SUCCEEDED( hr ) )
    {
        hr = InitSourceControls();
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "InitTopologyInfo: InitSourceControls() FAILED (0x%08lx)" )
                , hr ) );
    }

    m_hrTopologyInitStatus = hr;

    return m_hrTopologyInitStatus;
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// GetNextNodeFromDestPin and GetNextNodeFromSrcPin are the methods used
// to find the desired topology node. A starting input or output pin must
// always be specified for the search and in some cases a destination pin
// can also be specified. This allows us to correctly searching through a
// line which may contain splits.
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// CKsAudHelper::GetNextNodeFromDestPin
//
// Overloaded version which takes an output pin as arg
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::GetNextNodeFromDestPin
(
    IKsControl *          pKsControl,
    PQKSAUDNODE_ELEM *    ppNode,
    IPin *                pPin,
    REFCLSID              clsidNodeType,
    IPin *                pSrcPin,
    ULONG                 PropertyId
)
{
    HRESULT            hr = S_OK;
    PQKSAUDNODE_ELEM   pDest = NULL;
    BOOL               bStereo;

    ASSERT( m_listDests );

    ULONG PinFactoryID;
    hr = PinFactoryIDFromPin( pPin, &PinFactoryID );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "GetNextNodeFromDestPin: PinFactoryIDFromPin return 0x%lx" )
                , hr ) );

        return hr;
    }

    ULONG SrcPinID = -1;
    if( pSrcPin )
    {
        hr = PinFactoryIDFromPin( pSrcPin, &SrcPinID );
        if( FAILED( hr ) )
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "GetNextNodeFromDestPin: ERROR - PinFactoryIDFromPin for destination pin return 0x%lx" )
                    , hr ) );

            return hr;
        }
    }

    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT( "GetNextNodeFromDestPin: PinFactoryIDFromPin: PinFactoryID=%d" )
            , PinFactoryID ) );

    //
    // Loop over all the destination node searching for the output line that matches this PinID
    //
    pDest = FirstInList( m_listDests );
    while( pDest )
    {
        if( PinFactoryID == pDest->Id )
        {
            break;
        }

        pDest = NextNode( pDest );
    }

    if( !pDest )
        return E_FAIL;

    //
    // now loop through destination starting with pNode until we find a
    // node of the right type
    //
    PEERNODE * pTemp = FirstParentNode( pDest );
    while( pTemp )
    {
        // first check if this node is the one we want
        if( pTemp->pNode->NodeType == clsidNodeType )
        {
            break;
        }
        // hack (for the moment), a supermix node can also act as a mute node
        else if( ( KSNODETYPE_MUTE == clsidNodeType ) &&
                 ( KSNODETYPE_SUPERMIX == pTemp->pNode->NodeType ) )
        {
            if( pTemp->pNode->bMute )
                break;
        }
        else if( KSNODETYPE_SUM == pTemp->pNode->NodeType )
        {
            //
            // stop here, we should go no further for this line
            //
            pTemp = NULL; // reset since we didn't find what we wanted
            break;
        }

        // didn't find it, get the next node to try
        if( ( -1 != SrcPinID ) && ( ParentListLength( pTemp->pNode ) > 1 ) )
        {
            // this node branches off and a destination node was specified, so find the right
            // parent to use
            pTemp = FirstParentNode( pTemp->pNode );
            while( pTemp )
            {
                if( FindSourcePin( pTemp->pNode, SrcPinID ) )
                    break;

                pTemp = NextPeerNode( pTemp );
            }
        }
        else
        {
            pTemp = FirstParentNode( pTemp->pNode );
        }
    }

    if( !pTemp )
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "Error: GetNodeFromDestPin never found node[0x%lx]" )
                , hr ) );
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
        *ppNode = pTemp->pNode;
    }

    return hr;
}


//--------------------------------------------------------------------------;
//
// CKsAudHelper::GetNextNodeFromSrcPin
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::GetNextNodeFromSrcPin
(
    IKsControl *          pKsControl,
    PQKSAUDNODE_ELEM *    ppNode,
    IPin *                pPin,
    REFCLSID              clsidNodeType,
    IPin *                pDestPin,
    ULONG                 PropertyId
)
{

    HRESULT            hr = S_OK;
    PQKSAUDNODE_ELEM   pSrc = NULL;
    BOOL               bStereo;

    ULONG PinFactoryID;
    hr = PinFactoryIDFromPin( pPin, &PinFactoryID );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "GetNextNodeFromSrcPin: PinFactoryIDFromPin return 0x%lx" )
                , hr ) );

        return hr;
    }

    ULONG DestPinID = -1;
    if( pDestPin )
    {
        hr = PinFactoryIDFromPin( pDestPin, &DestPinID );
        if( FAILED( hr ) )
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "GetNextNodeFromSrcPin: PinFactoryIDFromPin for destination pin return 0x%lx" )
                    , hr ) );

            return hr;
        }
    }


    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT( "GetNextNodeFromSrcPin: PinFactoryIDFromPin: PinFactoryID=%d" )
            , PinFactoryID ) );

    //
    // First loop over all the source nodes searching for the line that matches this PinID
    //
    pSrc = FirstInList( m_listSources );
    while( pSrc )
    {
        if( PinFactoryID == pSrc->Id )
        {
            break;
        }

        pSrc = NextNode( pSrc );
    }

    if( !pSrc )
        return E_FAIL;

    //
    // now loop through this source line starting with pNode until we find a
    // node of the right type
    //
    PEERNODE * pTemp = FirstChildNode( pSrc );
    BOOL bDone = FALSE;
    while( pTemp )
    {
        // first check if this node is the one we want
        if( pTemp->pNode->NodeType == clsidNodeType )
        {
            // initialize data for this object handle if it hasn't been done yet
            LoadNodeDetails( pKsControl, pTemp->pNode );

            // For volume node, skip this node if ChannelMask == 0
            if( clsidNodeType == KSNODETYPE_VOLUME )
            {
                if( 0 != pTemp->pNode->ChannelMask )
                    bDone = TRUE;
            }
            // if this is a multi-property node check property id
            else if( 0 != PropertyId )
            {
                if( PropertyId == pTemp->pNode->PropertyId )
                    bDone = TRUE;
            }
            else
                bDone = TRUE;

        }
        // hack (for the moment), a supermix node can also act as a mute node
        else if( ( KSNODETYPE_MUTE == clsidNodeType ) &&
                 ( KSNODETYPE_SUPERMIX == pTemp->pNode->NodeType ) )
        {
            if( pTemp->pNode->bMute )
               bDone = TRUE;
        }

        if( bDone )
        {
            // we found what we were looking for, we're done
            break;
        }

        if( ( -1 != DestPinID ) && ( ChildListLength( pTemp->pNode ) > 1 ) )
        {
            // this node branches off and a destination node was specified, so find the right
            // child to use
            pTemp = FirstChildNode( pTemp->pNode );
            while( pTemp )
            {
                if( FindDestinationPin( pTemp->pNode, DestPinID ) )
                    break;

                pTemp = NextPeerNode( pTemp );
            }
        }
        else
        {
            // just get next node and try that
            pTemp = FirstChildNode( pTemp->pNode );
        }
    }

    if( !pTemp )
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "Error: GetNodeFromSrcPin never found node[0x%lx]" )
                , hr ) );
        hr = E_FAIL;
    }
    else
    {
        hr = S_OK;
        *ppNode = pTemp->pNode;
    }

    return hr;
}

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// Audio Node Property Setting/Getting Helpers
//
// The next group of methods are the high level methods which an app (or
// wrapper, in our case) would use to set and get the various types of
// node property data structures.
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;


//--------------------------------------------------------------------------;
//
// CKsAudHelper::GetNodeVolume
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::GetNodeVolume
(
    IKsControl * pKsControl,
    PQKSAUDNODE_ELEM   pNode,
    LONG * plVolume,
    LONG * plBalance,
    BOOL   bLinear
)
{
    LONG lLeftKsVol, lRightKsVol;
    HRESULT hr = S_OK;
    ASSERT( plVolume || plBalance );


    hr = GetAudioNodeProperty( pKsControl
                             , KSPROPERTY_AUDIO_VOLUMELEVEL
                             , pNode->Id
                             , UNIFORM_CHANNEL
                             , NULL
                             , 0
                             , &lLeftKsVol
                             , sizeof( lLeftKsVol ) );
    if ( ( pNode->ChannelMask & (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT ) ) ==
       ( SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT ) )
    {
        // stereo, so set right as well
        hr = GetAudioNodeProperty( pKsControl
                                 , KSPROPERTY_AUDIO_VOLUMELEVEL
                                 , pNode->Id
                                 , RIGHT_CHANNEL
                                 , NULL
                                 , 0
                                 , &lRightKsVol
                                 , sizeof( lRightKsVol ) );
    }
    else
    {
        lRightKsVol = lLeftKsVol;
    }

    LONG lLogVol = max( lLeftKsVol, lRightKsVol );
    if( plVolume )
    {
        if( !bLinear )
            *plVolume = (LONG) ( lLogVol / BA_TO_KS_DB_SCALE_FACTOR );
        else
            *plVolume = VolLogToLinear (lLogVol, pNode->MinValue, pNode->MaxValue);
    }

    // get the balance
    if( lLeftKsVol == lRightKsVol )
    {
        if( plBalance )
            *plBalance = 0;
    }
    else if( plBalance )
    {
        if( !bLinear )
        {
            LONG lLDecibel = (LONG) ( lLeftKsVol / BA_TO_KS_DB_SCALE_FACTOR );
            LONG lRDecibel = (LONG) ( lRightKsVol / BA_TO_KS_DB_SCALE_FACTOR );

            *plBalance = lRDecibel - lLDecibel;
        }
        else
        {
            LONG lKsRightLinVol = VolLogToLinear( lRightKsVol, (LONG) pNode->MinValue, (LONG) pNode->MaxValue);
            LONG lKsLeftLinVol =  VolLogToLinear( lLeftKsVol, (LONG) pNode->MinValue, (LONG) pNode->MaxValue);

            if( lKsRightLinVol > lKsLeftLinVol )
            {
                *plBalance = MulDiv( lKsRightLinVol - lKsLeftLinVol
                                   , LINEAR_RANGE
                                   , lKsRightLinVol );
            }
            else
            {
                *plBalance = -MulDiv( lKsLeftLinVol - lKsRightLinVol
                                    , LINEAR_RANGE
                                    , lKsLeftLinVol );
            }
        }
    }
    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::SetNodeVolume
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::SetNodeVolume
(
    IKsControl * pKsControl,
    PQKSAUDNODE_ELEM   pNode,
    LONG lVolume,
    LONG lBalance,
    BOOL bLinear

)
{
    // first adjust the balance
    //
    // Calculate scaling factors
    //
    LONG lTotalLeftDB, lTotalRightDB ;
    LONG lLeftAmpFactor, lRightAmpFactor;
    LONG lLeftKsLogVol, lRightKsLogVol;
    HRESULT hr = E_FAIL;

    if( !bLinear )
    {
        //
        // for now this means we've been called with an IBasicAudio value,
        // uses a logarithmic scale from -10,000 to 0 (divide by 100 to convert
        // to decibels). to convert this to the KS volume range of 0 to 65536
        // (note that IBasicAudio didn't support amplification) we need to
        // multiply this volume by 65536/100.
        //
        if (lBalance >= 0)
        {
            // left is attenuated
            lTotalLeftDB    = lVolume - lBalance ;
            lTotalRightDB   = lVolume;
        }
        else
        {
            // right is attenuated
            lTotalLeftDB    = lVolume;
            lTotalRightDB   = lVolume - (-lBalance);
        }
        lLeftKsLogVol = (LONG) ( lTotalLeftDB * BA_TO_KS_DB_SCALE_FACTOR );
        lRightKsLogVol = (LONG) ( lTotalRightDB * BA_TO_KS_DB_SCALE_FACTOR );
    }
    else
    {
        if( lBalance == 0 )
        {
            lLeftAmpFactor = lVolume;
            lRightAmpFactor = lVolume;
        }
        else if (lBalance > 0 )
        {
            lLeftAmpFactor = lVolume - MulDiv( lVolume, lBalance, LINEAR_RANGE );
            lRightAmpFactor = lVolume;
        }
        else
        {
            lLeftAmpFactor = lVolume;
            lRightAmpFactor = lVolume + MulDiv( lVolume, lBalance, LINEAR_RANGE );
        }
        lLeftKsLogVol = AmpFactorToDB( lLeftAmpFactor );
        DbgLog( ( LOG_TRACE
                , 0
                , TEXT( "AmpFactorToDB(lAmpFactor = %ld) returned %ld" )
                , lLeftAmpFactor
                , lLeftKsLogVol) );


        lLeftKsLogVol = VolLinearToLog (lLeftAmpFactor, pNode->MinValue, pNode->MaxValue);
        lRightKsLogVol = VolLinearToLog (lRightAmpFactor, pNode->MinValue, pNode->MaxValue);
        DbgLog( ( LOG_TRACE
                , 0
                , TEXT( "VolLinearToLog(lAmpFactor = %ld,MinValue= 0x%08lx,MaxVal=0x%08lx) returned %ld" )
                , lLeftAmpFactor
                , pNode->MinValue
                , pNode->MaxValue
                , lLeftKsLogVol) );

    }

    if ( ( pNode->ChannelMask & (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT ) ) ==
         ( SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT ) )
    {
        // Set stereo volume, start with right channel
        hr = SetAudioNodeProperty( pKsControl
                                 , KSPROPERTY_AUDIO_VOLUMELEVEL
                                 , pNode->Id
                                 , RIGHT_CHANNEL
                                 , NULL
                                 , 0
                                 , &lRightKsLogVol
                                 , sizeof( lRightKsLogVol ) );

    }
    else
    {
        // for mono just use the largest value
        lLeftKsLogVol = __max( lLeftKsLogVol, lRightKsLogVol );
    }
    hr = SetAudioNodeProperty( pKsControl
                             , KSPROPERTY_AUDIO_VOLUMELEVEL
                             , pNode->Id
                             , LEFT_CHANNEL
                             , NULL
                             , 0
                             , &lLeftKsLogVol
                             , sizeof( lLeftKsLogVol ) );

    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::SetNodeTone
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::SetNodeTone
(
    IKsControl * pKsControl,
    PQKSAUDNODE_ELEM   pNode,
    LONG lLevel
)
{
    HRESULT hr = E_FAIL;

    LONG lLeftAmpFactor   = DBToAmpFactor(lLevel);

    // Average of the level (for uniform channel control) is lLeftAmpFactor
    LONG lLeftKsLogVol = VolLinearToLog (lLeftAmpFactor, pNode->MinValue, pNode->MaxValue);

    if ( pNode->ChannelMask == UNIFORM_CHANNEL )
    {
        hr = SetAudioNodeProperty( pKsControl
                                 , pNode->PropertyId
                                 , pNode->Id
                                 , UNIFORM_CHANNEL
                                 , NULL
                                 , 0
                                 , &lLeftKsLogVol
                                 , sizeof( lLeftKsLogVol ) );
    }
    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::GetNodeTone
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::GetNodeTone
(
    IKsControl * pKsControl,
    PQKSAUDNODE_ELEM   pNode,
    LONG * plLevel
)
{
    // first adjust the balance
    //
    // Calculate scaling factors
    //
    LONG    lLogToneLevel;
    HRESULT hr = S_OK;

    // we don't really allow separate channel control of tone so just use one side
    hr = GetAudioNodeProperty( pKsControl
                             , pNode->PropertyId
                             , pNode->Id
                             , UNIFORM_CHANNEL
                             , NULL
                             , 0
                             , &lLogToneLevel
                             , sizeof( lLogToneLevel ) );

    LONG lLinearToneLevel = VolLogToLinear (lLogToneLevel, pNode->MinValue, pNode->MaxValue);
    *plLevel  = AmpFactorToDB(lLinearToneLevel);

    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::GetNodeBoolean
//
// Gets a boolean node value.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::GetNodeBoolean
(
    IKsControl *        pKsControl,
    PQKSAUDNODE_ELEM    pNode,
    BOOL *              pBool
)
{
    HRESULT hr = S_OK;

    ASSERT( pBool );
    if( !pBool )
        return E_POINTER;

    hr = GetAudioNodeProperty( pKsControl
                             , pNode->PropertyId
                             , pNode->Id
                             , 0 // uniform channel
                             , NULL
                             , 0
                             , pBool
                             , sizeof( *pBool ) );
    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::SetNodeBoolean
//
// Sets a boolean node value.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::SetNodeBoolean
(
    IKsControl *        pKsControl,
    PQKSAUDNODE_ELEM    pNode,
    BOOL                Bool
)
{
    HRESULT hr = S_OK;

    hr = SetAudioNodeProperty( pKsControl
                             , pNode->PropertyId
                             , pNode->Id
                             , pNode->ChannelMask
                             , NULL
                             , 0
                             , &Bool
                             , sizeof( Bool ) );
    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::GetNodeMute
//
// Gets the current state of the Mute property for a given node. Handles true
// mute nodes as well as SuperMix nodes which can act as mute nodes.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::GetNodeMute
(
    IKsControl *        pKsControl,
    PQKSAUDNODE_ELEM    pNode,
    BOOL *              pBool
)
{
    HRESULT hr = S_OK;

    ASSERT( pBool );
    if( !pBool )
        return E_POINTER;

    if( KSNODETYPE_SUPERMIX == pNode->NodeType )
    {
        // a super mix node is being used as a mute
        hr = GetMuteFromSuperMix( pKsControl, pNode, pBool );
    }
    else
    {
        hr = GetAudioNodeProperty( pKsControl
                                 , pNode->PropertyId
                                 , pNode->Id
                                 , 0 // uniform channel
                                 , NULL
                                 , 0
                                 , pBool
                                 , sizeof( *pBool ) );
    }
    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::SetNodeMute
//
// Sets the current state of the Mute property for a given node. Handles true
// mute nodes as well as SuperMix nodes which can act as mute nodes.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::SetNodeMute
(
    IKsControl *        pKsControl,
    PQKSAUDNODE_ELEM    pNode,
    BOOL                Bool
)
{
    HRESULT hr = S_OK;

    if( KSNODETYPE_SUPERMIX == pNode->NodeType )
    {
        // a super mix node is being used as a mute
        hr = SetMuteFromSuperMix( pKsControl, pNode, Bool );
    }
    else
    {
        hr = SetAudioNodeProperty( pKsControl
                                 , pNode->PropertyId
                                 , pNode->Id
                                 , pNode->ChannelMask
                                 , NULL
                                 , 0
                                 , &Bool
                                 , sizeof( Bool ) );
    }

    return hr;
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// Low level topology parsing code
//
// The nitty gritty code which traverses through the filter topology and
// builds up the node information lists.
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;


//--------------------------------------------------------------------------;
//
// CKsAudHelper::InitSourceControls
//
// Initializes node controls for all input pin (source) lines.  A source line
// ends when a SUM node, a destination node, or a node contained in a
// destination line is encountered.  When splits are encountered in the topology,
// new lines need to be created and the controls on those lines enumerated.
//
// InitSourceControls will recurse to find the controls on subnodes.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::InitSourceControls( void )
{
    PPEERNODE        pTemp  = NULL;
    PQKSAUDNODE_ELEM pSrc;


    pSrc = FirstInList( m_listSources );
    while( pSrc )
    {
        TraverseAndInitSourcePathControls( pSrc );
        pSrc = NextNode( pSrc );
    }

    return S_OK;
}


//--------------------------------------------------------------------------;
//
// CKsAudHelper::TraverseAndInitSourceControls
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::TraverseAndInitSourcePathControls
(
    PQKSAUDNODE_ELEM pNode
)
{
    PPEERNODE    pTemp  = NULL;

    //
    // Check to see if this is the end of this line.
    //
    if( ( pNode->NodeType == KSNODETYPE_SUM ) ||
        ( pNode->NodeType == KSNODETYPE_MUX ) ||
        ( pNode->Type == DESTINATION        ) ||
        ( IsDestinationNode( pNode )        )   )
    {
        return S_OK;
    }

    //
    // Retrieve and translate the node for the first child, appending any
    // controls created onto the list of controls for this line.
    //
    PEERNODE * pChild = FirstChildNode( pNode );
    if( !pChild ) {
        return S_OK ;
    }
    while( pChild )
    {

        // Save the number of controls here.  If a split occurs beneath this
        // node, we don't want to include children followed on the first
        // child's path.

        LoadNodeDetails( NULL, pChild->pNode );

        // recurse for pChild->pNode
        TraverseAndInitSourcePathControls( pChild->pNode );

        pChild = NextPeerNode( pChild );
    }

    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::IsDestinationNode
//
// Searches all the list of controls on the given list of destinations
// to see if the node appears in any of those lists.
//
//--------------------------------------------------------------------------;
BOOL CKsAudHelper::IsDestinationNode
(
    PQKSAUDNODE_ELEM pNode                   // The node to check
)
{
    PQKSAUDNODE_ELEM  pTemp;
    PPEERNODE pParent;

    if( pNode->Type == SOURCE ) {
        return( FALSE );
    }

    if( pNode->Type == DESTINATION ) {
        return( TRUE );
    }

    //
    // Loop over each of the destinations
    //
    pTemp = FirstInList( m_listDests );
    while( pTemp ) {

        //
        // Loop over the parent.
        //

        pParent = FirstParentNode( pTemp );
        while( pParent ) {

            if( pParent->pNode->Id == pNode->Id ) {
                return( TRUE );
            }

            if( ( pParent->pNode->NodeType == KSNODETYPE_SUM ) ||
                ( pParent->pNode->NodeType == KSNODETYPE_MUX ) ||
                ( pParent->pNode->Type == SOURCE             ) )
            {
                break;
            }

            //
            // Check for the node Ids matching.
            //
            pParent = FirstParentNode( pParent->pNode );
        }

        pTemp = NextNode( pTemp );
    }

    return( FALSE );
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::InitDestinationControls
//
// Starts at the destination node and fills in details for each node.
// This process stops when the first SUM node is encountered, indicating
// the end of a destination line.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::InitDestinationControls( void )
{
    PPEERNODE        pTemp  = NULL;
    PQKSAUDNODE_ELEM pDest;


    pDest = FirstInList( m_listDests );
    while( pDest ) {

        pTemp = FirstParentNode( pDest );
        while( pTemp ) {

            if( pTemp->pNode->NodeType == KSNODETYPE_SUM ) {
                //
                // We've found a SUM node.  Discontinue the loop... there are
                // no more controls for us
                //
                break;
            }

            if( pTemp->pNode->NodeType == KSNODETYPE_MUX ) {
                LoadNodeDetails( NULL, pTemp->pNode );
                break;
            }

            if( ( ParentListLength( pTemp->pNode ) > 1 ) ) {
                //
                // Found a node with multiple parents that is not a SUM node.
                // Can't handle that here so add the control details for this node
                // and discontinue the loop.
                //
                LoadNodeDetails( NULL, pTemp->pNode );
                break;
            }

            LoadNodeDetails( NULL, pTemp->pNode );

            pTemp = FirstParentNode( pTemp->pNode );
        }
        pDest = NextNode( pDest );
    }

    return S_OK;
}


//--------------------------------------------------------------------------;
//
// CKsAudHelper::QueryTopology
//
// Queries the topology from the device and stores all the information
// in pTopology.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::QueryTopology( void )
{
    HRESULT hr          = S_OK;
    ULONG ulCategories  = 0;
    ULONG ulNodes       = 0;
    ULONG ulConnections = 0;

    BYTE * pConnectionData = NULL;
    BYTE * pNodeData = NULL;

    ASSERT( m_pKsTopology );

    //
    // Get the list of nodes types in the topology
    //
    hr = GetProperty( &KSPROPSETID_Topology
                    , KSPROPERTY_TOPOLOGY_NODES
                    , NULL
                    , 0
                    , &pNodeData );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "Error: TOPOLOGY_NODES query failed[0x%lx]" )
                , hr ) );
        return E_FAIL;
    }

    //
    // Get the list of connections in the meta-topology
    //
    hr = GetProperty( &KSPROPSETID_Topology
                    , KSPROPERTY_TOPOLOGY_CONNECTIONS
                    , NULL
                    , 0
                    , &pConnectionData );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "Error: TOPOLOGY_CONNECTIONS query failed[0x%lx]" )
                , hr ) );
        delete pNodeData;
        return E_FAIL;
    }

    //
    // Fill in the topology structure so this information is available
    // later.  For the Categories and TopologyNodes, the pointers are
    // pointers to a KSMULTIPLE_ITEM structure.  The definition of this
    // is that the data will follow immediately after the structure.
    //
    m_pKsTopology->TopologyNodesCount       = ( ( PKSMULTIPLE_ITEM ) pNodeData )->Count;
    m_pKsTopology->TopologyNodes            = ( GUID* )( pNodeData + sizeof( KSMULTIPLE_ITEM ) );
    m_pKsTopology->TopologyConnectionsCount = ( (PKSMULTIPLE_ITEM ) pConnectionData )->Count;
    m_pKsTopology->TopologyConnections      =
        ( PKSTOPOLOGY_CONNECTION ) ( pConnectionData + sizeof( KSMULTIPLE_ITEM ) );

    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_TOPOLOGY
            , TEXT( "# Nodes:          %ld" )
            , ( ( PKSMULTIPLE_ITEM )pNodeData )->Count ) );
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_TOPOLOGY
            , TEXT( "# Connections:    %ld" )
            , ( ( PKSMULTIPLE_ITEM )pConnectionData )->Count ) );

    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::BuildNodeTable
//
// Allocates enough memory to hold TopologyNodeCount FGNODE structures.
// The GUIDs from the Topology are copied over into the FGNODE structures.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::BuildNodeTable(void)
{
    PQKSAUDNODE_ELEM pTable = NULL;
    ULONG            i;

    ASSERT( m_pKsTopology );

    //
    // Allocate an array of nodes the same size as the Topology Node
    // table.
    //
    m_pKsNodeTable = (QKSAUDNODE_LIST) new BYTE[ sizeof( QKSAUDNODE_ELEM ) * m_pKsTopology->TopologyNodesCount ];
    if(!m_pKsNodeTable)
    {
        return E_OUTOFMEMORY;
    }
    ZeroMemory( m_pKsNodeTable, m_pKsTopology->TopologyNodesCount * sizeof( QKSAUDNODE_ELEM ) );

    //
    // Initialize the nodes.  All that can be filled in here is the GUIDs,
    // copied from the node table.
    //
    for( i = 0; i < m_pKsTopology->TopologyNodesCount; i++ ) {
        m_pKsNodeTable[ i ].NodeType = m_pKsTopology->TopologyNodes[ i ];
    }
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::ParseTopolgy
//
// Loops through all the pins building up lists of sources and
// destinations.  For each source, a child graph is built.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::ParseTopology(void)
{
    HRESULT          hr = S_OK;
    ULONG            ulPins, PinID;
    PQKSAUDNODE_ELEM pTemp = NULL;

    ASSERT( !m_listSources );
    ASSERT( !m_listDests   );

    //
    // Query the number of pins
    //
    ULONG ulBytesReturned = 0;

    hr = m_pKsPropSet->Get( KSPROPSETID_Pin
                          , KSPROPERTY_PIN_CTYPES
                          , NULL
                          , 0
                          , (BYTE *) &ulPins
                          , sizeof( ulPins )
                          , (DWORD *)&ulBytesReturned );
    if( FAILED( hr ) )
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "Error: Failed to get PIN_CTYPES property [0x%lx]" )
                , hr ) );
        return E_FAIL;
    }
    else
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT( "KSPROPERTY_PIN_CTYPES returned %d" )
                , ulPins ) );

    //
    // Now scan through each of the pins identifying those that are
    // sources and destinations.
    //
    HRESULT hrTmp = S_OK; // use this for failures that are non-critical

    for( PinID = 0; PinID < ulPins; PinID++ ) {
        KSPIN_DATAFLOW      DataFlow;

        //
        // Read the direction of dataflow of this pin.
        //
        KSP_PIN Property;

        ZeroMemory( &Property, sizeof( Property ) );
        Property.PinId = PinID;
        ulBytesReturned = 0;

        hr = m_pKsPropSet->Get( KSPROPSETID_Pin
                          , KSPROPERTY_PIN_DATAFLOW
                          , &Property.PinId
                          , sizeof( Property ) - sizeof( Property.Property )
                          , (BYTE *) &DataFlow
                          , sizeof( KSPIN_DATAFLOW )
                          , &ulBytesReturned );
        if( FAILED( hr ) )
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "Error: GetProperty on Pin property KSPROPERTY_PIN_DATAFLOW failed[0x%lx]" )
                    , hr ) );
            return E_FAIL;
        }

        //
        // Based on the DataFlow, identify if the pin is a source,
        // a destination, or neither.
        //
        switch( DataFlow ) {

            ///////////////////////////////////////////////////////////
            case KSPIN_DATAFLOW_IN:
            ///////////////////////////////////////////////////////////
            // DATAFLOW_IN pins are sources.                         //
            ///////////////////////////////////////////////////////////

                //
                // Create a new node structure for this source
                // and fill in the known information about it.
                //
                pTemp = (PQKSAUDNODE_ELEM) new QKSAUDNODE_ELEM;
                if( pTemp )
                {
                    ZeroMemory (pTemp, sizeof (QKSAUDNODE_ELEM));

                    DbgLog( ( LOG_TRACE
                            , DBG_LEVEL_TRACE_ALLOCATIONS
                            , TEXT( "Parse topology: Allocating source node at 0x%08lx (pNode=0x%08lx, pNext=0x%08lx)" )
                            , pTemp ) );

                    pTemp->Type = SOURCE;
                    pTemp->Id   = PinID;
                    ulBytesReturned = 0;

                    //
                    // Retrieve the category of this pin and store it away.
                    //
                    hrTmp = m_pKsPropSet->Get( KSPROPSETID_Pin
                                 , KSPROPERTY_PIN_CATEGORY
                                 , &Property.PinId
                                 , sizeof( Property ) - sizeof( Property.Property )
                                 , (BYTE *) &pTemp->NodeType
                                 , sizeof( pTemp->NodeType )
                                 , &ulBytesReturned );
                    // NOTE: The above can fail in some cases, so don't check error code
                    //       and the node type will already default to GUID_NULL.

                    DbgLog( ( LOG_TRACE
                            , DBG_LEVEL_TRACE_DETAILS
                            , TEXT( "ParseTopology: Identifies SOURCE (%d): %s" )
                            , PinID
                            , KsPinCategoryToString( &pTemp->NodeType )));

                    //
                    // Add this new source node to the list of source
                    // nodes.
                    //
                    AddToList( m_listSources, pTemp );
                }
                else
                    hr = E_OUTOFMEMORY;

                break;

            ///////////////////////////////////////////////////////////
            case KSPIN_DATAFLOW_OUT:
            ///////////////////////////////////////////////////////////
            // DATAFLOW_OUT pins are destinations                    //
            ///////////////////////////////////////////////////////////

                //
                // Create a new node structure for this dest
                // and fill in the known information about it.
                //
                pTemp = (PQKSAUDNODE_ELEM) new QKSAUDNODE_ELEM;
                if( pTemp )
                {
                    ZeroMemory( pTemp, sizeof( QKSAUDNODE_ELEM ) );

                    DbgLog( ( LOG_TRACE
                            , DBG_LEVEL_TRACE_ALLOCATIONS
                            , TEXT( "Parse topology: Allocating dest node at 0x%08lx" )
                            , pTemp ) );

                    pTemp->Type = DESTINATION;
                    pTemp->Id   = PinID;
                    ulBytesReturned = 0;

                    //
                    // Retrieve the category of this pin and store it away.
                    //
                    hrTmp = m_pKsPropSet->Get( KSPROPSETID_Pin
                                 , KSPROPERTY_PIN_CATEGORY
                                 , &Property.PinId
                                 , sizeof( Property ) - sizeof( Property.Property )
                                 , (BYTE *) &pTemp->NodeType
                                 , sizeof( pTemp->NodeType )
                                 , &ulBytesReturned );
                    // NOTE: The above can fail in some cases, so don't check error code
                    //       and the node type will already default to GUID_NULL.

                    DbgLog( ( LOG_TRACE
                            , DBG_LEVEL_TRACE_TOPOLOGY
                            , TEXT("ParseTopology: Identifies DESTINATION (%d): %s")
                            , PinID
                            , KsPinCategoryToString( &pTemp->NodeType )));

                    //
                    // Add this new destination node to the list of destination
                    // nodes.
                    //
                    AddToList( m_listDests, pTemp );
                }
                else
                    hr = E_OUTOFMEMORY;

                break;

            ///////////////////////////////////////////////////////////
            default:
                ;
        }
    }
    if( SUCCEEDED( hr ) )
    {
        //
        // For each source found, build the graphs of their children.  This
        // will recurse building the graph of the children's children, etc.
        //
        pTemp = FirstInList( m_listSources );
        while( pTemp ) {

            hr = BuildChildGraph( pTemp            // The source node to build the graph for
                                , KSFILTER_NODE    // Sources are always KSFILTER_NODEs
                                , pTemp->Id );     // The Pin id of the source
            if( FAILED( hr ) )
                break;

            pTemp = NextNode( pTemp );
        }
    }
    return hr;
}


//--------------------------------------------------------------------------;
//
// CKsAudHelper::BuildChildGraph
//
// Builds the graph of the child of the given node.  For each child
// of the node, it recurses to find their child, etc.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::BuildChildGraph
(
    PQKSAUDNODE_ELEM    pNode,         // The node to build the graph for
    ULONG               FromNode,      // The node's ID
    ULONG               FromNodePin    // The Pin connection to look for
)
{
    ULONG               Index         = 0;
    PQKSAUDNODE_ELEM    pNewNode      = NULL;
    PQKSAUDNODE_ELEM    pTemp         = NULL;
    BOOL                bEndOfTheLine = FALSE;
    PEERNODE*           pPeerNode     = NULL;
    HRESULT             hr            = S_OK;

    for( ; ; )
    {
        //
        // Find the index of the requested connection.  A return of -1
        // indicates that the connection was not found.  Searches start
        // at Index, which starts with 0 and is > 0 if the last was a match.
        //
        Index = FindTopologyConnection(
            Index,
            FromNode,
            FromNodePin
            );
        if( Index == (ULONG) -1 ) {
            break;
        }

        //
        // Check to see if this connection is a KSFILTER_NODE.  That will
        // indicate that it's connected to a destination and not another node.
        //

        if( m_pKsTopology->TopologyConnections[ Index ].ToNode == KSFILTER_NODE )
        {
            //
            // Find the destination node so that the parent field can be
            // updated to include this node.  bEndOfTheLine is set to TRUE
            // since there can be no other connections after the destination.
            //

            pNewNode = FindDestination(
                m_pKsTopology->TopologyConnections[ Index ].ToNodePin
                );
            //
            // We better find a destination; if not, something's really wrong.
            //
            ASSERT( pNewNode );
            if( !pNewNode )
            {
                hr = E_FAIL;
                break;
            }
            bEndOfTheLine = TRUE;
        }
        else
        {
            //
            // Using the identifier stored in the ToNode of the topology
            // connections, index into the node table and retrieve the
            // mixer node associated with that id.
            //

            pNewNode = &m_pKsNodeTable[
                m_pKsTopology->TopologyConnections[ Index ].ToNode
                ];

            //
            // Fill in a couple of missing details.  Note that these details
            // may already be filled in but it doesn't hurt to overwrite
            // them with the same values.
            //
            pNewNode->Type = NODE;
            pNewNode->Id   = m_pKsTopology->TopologyConnections[ Index ].ToNode;
        }

        //
        // Insert the new node into the childlist of the current node only
        // if it isn't already there.  It only wastes memory to add it more
        // than once and prevents the proper updating of the child and parent
        // lists.
        //
        if( !InChildList( pNode, pNewNode ) ) {
            pPeerNode = (PEERNODE *) new PEERNODE;
            if( pPeerNode )
            {
                ZeroMemory (pPeerNode, sizeof (PEERNODE));
                pPeerNode->pNode = pNewNode;

                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_ALLOCATIONS
                        , TEXT( "BuildChildGraph: Allocated child peer node at 0x%08lx (pNode=0x%08lx)" )
                        , pPeerNode
                        , pPeerNode->pNode ) );


                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_TOPOLOGY
                        , TEXT("BuildChildGraph: Added %s(%d) to child list of %s(%d)")
                        , pPeerNode->pNode->Type == SOURCE      ? "SOURCE" :
                            pPeerNode->pNode->Type == DESTINATION ? "DEST"   :
                            pPeerNode->pNode->Type == NODE        ? "NODE"   :
                            "Unknown node type?"
                        , pPeerNode->pNode->Id
                        , pNode->Type == SOURCE      ? "SOURCE" :
                            pNode->Type == DESTINATION ? "DEST"   :
                            pNode->Type == NODE        ? "NODE"   :
                            "Unknown node type?"
                        , pNode->Id ) );

                AddToChildList( pNode, pPeerNode );
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }

        //
        // Insert the new node into the parentlist of the new node only
        // if it isn't already there.  It only wastes memory to add it more
        // than once and prevents the proper updating the child and parent
        // lists.
        //

        if( !InParentList( pNewNode, pNode ) ) {
            pPeerNode = (PEERNODE *) new PEERNODE;
            if( pPeerNode )
            {
                ZeroMemory (pPeerNode, sizeof (PEERNODE));
                pPeerNode->pNode = pNode;

                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_ALLOCATIONS
                        , TEXT( "BuildChildGraph: Allocated parent peer node at 0x%08lx (pNode=0x%08lx)" )
                        , pPeerNode
                        , pPeerNode->pNode ) );

                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_TOPOLOGY
                        , TEXT("BuildChildGraph: Added %s(%d) to parent list of %s(%d)")
                        , pNode->Type == SOURCE      ? "SOURCE" :
                            pNode->Type == DESTINATION ? "DEST"   :
                            pNode->Type == NODE        ? "NODE"   :
                            "Unknown node type?"
                        , pNode->Id
                        , pNewNode->Type == SOURCE      ? "SOURCE" :
                            pNewNode->Type == DESTINATION ? "DEST"   :
                            pNewNode->Type == NODE        ? "NODE"   :
                            "Unknown node type?"
                        , pNewNode->Id ));

                AddToParentList( pNewNode, pPeerNode );
            }
            else
            {
                return E_OUTOFMEMORY;
                break;
            }
        }
        //
        // Skip past the connection we just processed.
        //
        ++Index;

    }  // for( ; ; ) Loop until FindConnection fails.

    //
    // The last connection found connects to a destination node.  Do not
    // try to enumerate the children, since there are none.
    //
    if( bEndOfTheLine ) {
        return S_OK;
    }

    if( SUCCEEDED( hr ) )
    {
        //
        // For each of the children of this node, recurse to build up the lists
        // of the child's nodes.
        //

        pPeerNode = FirstChildNode( pNode );
        while( pPeerNode ) {

            hr = BuildChildGraph(
                pPeerNode->pNode,     // The parent node
                pPeerNode->pNode->Id, // The Id of the parent
                PINID_WILDCARD        // Look for any connection by this node
                );
            if( FAILED( hr ) )
                break;

            pPeerNode = NextPeerNode( pPeerNode );
        }
    }
    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::FindTopologyConnection
//
// Scans through the connection table looking for a connection that
// matches the FromNode/FromNodePin criteria.
//
//--------------------------------------------------------------------------;
ULONG CKsAudHelper::FindTopologyConnection
(
    ULONG                        StartIndex,     // Index to start search
    ULONG                        FromNode,       // The Node ID to look for
    ULONG                        FromNodePin     // The Pin ID to look for
)
{
    ULONG i;

    for( i = StartIndex; i < m_pKsTopology->TopologyConnectionsCount; i++ ) {
        if( ( ( m_pKsTopology->TopologyConnections[ i ].FromNode    == FromNode       )||
              ( FromNode    == PINID_WILDCARD ) ) &&
            ( ( m_pKsTopology->TopologyConnections[ i ].FromNodePin == FromNodePin )   ||
              ( FromNodePin == PINID_WILDCARD ) ) ) {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_TOPOLOGY
                    , TEXT( "Found connection from (%d,%d) -> %d.\n")
                    , FromNode
                    , FromNodePin
                    , i ) );
            return( i );
        }
    }
    return( (ULONG) -1 );
}


//--------------------------------------------------------------------------;
//
// CKsAudHelper::GetProperty
//
// Queries a property by first determining the correct number of
// output bytes, allocating that much memory, and quering the
// actual data.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::GetProperty
(
    const GUID   *pPSGUID,          // The requested property set
    DWORD        dwPropertyId,      // The ID of the specific property
    ULONG        cbInput,           // The number of extra input bytes
    PBYTE        pInputData,        // Pointer to the extra input bytes
    PBYTE        *ppPropertyOutput  // Pointer to a pointer of the output
)
{
    ASSERT( m_pKsPropSet );

    ULONG       cbPropertyInput = sizeof(KSPROPERTY);
    PKSPROPERTY pPropertyInput;

    ULONG ulCount = 0;
    HRESULT hr = S_OK;

    // first get the size we need to allocate...
    hr = m_pKsPropSet->Get( *pPSGUID
                          , dwPropertyId
                          , pInputData
                          , cbInput
                          , NULL
                          , 0
                          , (DWORD *) &ulCount );
    if( HRESULT_FROM_WIN32( ERROR_MORE_DATA ) != hr )
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "Error: ERROR_MORE_DATA not received for propid %d size query[0x%08lx]" )
                , dwPropertyId
                , hr ) );
        return E_FAIL;
    }

    //
    // Allocate enough memory for the KSPROPERTY structure and any additional
    // input the callers wants to include.
    //
    if ( 0 < ulCount )
    {
        *ppPropertyOutput = (PBYTE) new BYTE[ ulCount ];
        if( !*ppPropertyOutput )
            return E_OUTOFMEMORY;


        hr = m_pKsPropSet->Get( *pPSGUID
                              , dwPropertyId
                              , pInputData
                              , cbInput
                              , *ppPropertyOutput
                              , ulCount
                              , &ulCount );
        if( FAILED( hr ) )
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_FAILURES
                    , TEXT( "Error: Get query failed for propid %d [0x%lx]" )
                    , dwPropertyId
                    , hr ) );
            delete *ppPropertyOutput;
            return E_FAIL;
        }
    }
    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::SupportsControl
//
// Queries Property on the left channel, the right channel, and on
// the master channel (if left and right both fail) to see if the
// property is supported.  The left channel and right channels set
// bits in the return if they are supported.  Master channel sets
// all bits.
//
//--------------------------------------------------------------------------;
ULONG CKsAudHelper::SupportsControl
(
    IKsControl * pKsControl,
    ULONG        Node,           // The node id to query
    ULONG        Property        // The property to check for
)
{
    HRESULT     hr = S_OK;
    LONG        Level;
    ULONG       ChannelMask = 0;

    //
    // First check to see if the property works on the left channel.
    //
    hr = GetAudioNodeProperty( pKsControl
                             , Property
                             , Node
                             , LEFT_CHANNEL
                             , NULL
                             , 0
                             , &Level
                             , sizeof( Level ) );
    if( SUCCEEDED( hr ) ) {
        ChannelMask |= SPEAKER_FRONT_LEFT;
    } else {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT("SupportsControl for (%d, %X) failed on LEFT channel[0x%lx]")
                , Node
                , Property
                , hr ) );
    }


    //
    // Now check the property on the right channel.
    //

    hr = GetAudioNodeProperty( pKsControl
                             , Property
                             , Node
                             , RIGHT_CHANNEL
                             , NULL
                             , 0
                             , &Level
                             , sizeof( Level ) );
    if( SUCCEEDED( hr ) ) {
        ChannelMask |= SPEAKER_FRONT_RIGHT;
    } else {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT("SupportsControl for (%d, %X) failed on RIGHT channel[0x%lx]")
                , Node
                , Property
                , hr ) );
    }

    if( ChannelMask == 0 ) {

        //
        // If neither left nor right succeeded, check the MASTER channel.
        //
        hr = GetAudioNodeProperty( pKsControl
                                 , Property
                                 , Node
                                 , MASTER_CHANNEL
                                 , NULL
                                 , 0
                                 , &Level
                                 , sizeof( Level ) );
        if( SUCCEEDED( hr ) ) {
            return MASTER_CHANNEL;
        } else {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT("SupportsControl for (%d, %X) failed on MASTER channel[0x%lx]")
                    , Node
                    , Property
                    , hr ) );
        }
    }

    return( ChannelMask );
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::LoadNodeDetails
//
// Translates a NodeType GUID into a mixer line control.  The memory
// for the control(s) is allocated and we fill in as much information about
// the control as we can.
//
// NOTES:
// This function returns the number of controls added to the ppControl
// array.
//
// Returns the number of controls actually created.
//
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::LoadNodeDetails
(
    IKsControl *      pKsControl,
    PQKSAUDNODE_ELEM  pNode
)
{
    ULONG   ChannelMask;
    HRESULT hr = S_OK;
    BOOL    bStereo = FALSE;

    ASSERT( pNode );
    if( !pNode )
        return E_POINTER;

    if( pNode->bDetailsSet )
    {
        // this node has already been initialized
        return S_OK;
    }

    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT("Checking %d ( %s ) node.")
            , pNode->Id
            , NodeTypeToString( &pNode->NodeType ) ) );

    ///////////////////////////////////////////////////////////////////
    if( pNode->NodeType == KSNODETYPE_AGC ) {
    ///////////////////////////////////////////////////////////////////
    //
    // AGC is represented by an ONOFF control.
    //
    // AGC is a UNIFORM (mono) control.
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node property supports AGC.
        //

        ChannelMask = SupportsControl( pKsControl, pNode->Id, KSPROPERTY_AUDIO_AGC );
        if( ChannelMask == 0 ) {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT("AGC node fails property!") ) );
            goto exit;
        }

    ///////////////////////////////////////////////////////////////////
    } else if( pNode->NodeType == KSNODETYPE_LOUDNESS ) {
    ///////////////////////////////////////////////////////////////////
    //
    // LOUNDNESS is represented by an ONOFF-type control.
    //
    // LOUDNESS is a UNIFORM (mono) control.
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node properly supports LOUDNESS.
        //

        //
        // Read the channel mask for the node.
        //
        ChannelMask = SupportsControl(
            pKsControl,
            pNode->Id,
            KSPROPERTY_AUDIO_LOUDNESS
            );

        //
        // If the ChannelMask is 0, this node does not support loudness
        //
        if( ChannelMask == 0 ) {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT("AUDIO_LOUDNESS node fails property!") ) );
            goto exit;
        }

        //
        // Fill in as much information as possible.
        //
        pNode->PropertyId = KSPROPERTY_AUDIO_LOUDNESS;
        pNode->ChannelMask = ChannelMask;
        pNode->cChannels = 1;
        pNode->MaxValue = 1;
        pNode->MinValue = 0;
        pNode->Granularity = 0;
        pNode->bDetailsSet = TRUE;

    ///////////////////////////////////////////////////////////////////
    } else if( pNode->NodeType == KSNODETYPE_MUTE ) {
    ///////////////////////////////////////////////////////////////////
    //
    // MUTE is represented by an ONOFF-type control.
    //
    // MUTE is a UNIFORM (mono) control.
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Check to see if the node property supports MUTE.
        //

        ChannelMask = SupportsControl(
            pKsControl,
            pNode->Id,
            KSPROPERTY_AUDIO_MUTE );
        if( ChannelMask == 0 ) {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT("AUDIO_MUTE node fails property!") ) );
            goto exit;
        }
        else
        {
            // else force ChannelMask to be uniform, since it seems to always fail
            // using a stereo mask, even when the card claims to support it.
            ChannelMask = UNIFORM_CHANNEL;
        }
        pNode->PropertyId = KSPROPERTY_AUDIO_MUTE;
        pNode->ChannelMask = ChannelMask;
        pNode->bDetailsSet = TRUE;

    ///////////////////////////////////////////////////////////////////
    } else if( pNode->NodeType == KSNODETYPE_TONE ) {
    ///////////////////////////////////////////////////////////////////
    //
    // A TONE node can represent up to 3 controls:
    //   Treble:     A fader control
    //   Bass:       A fader control
    //   Bass Boost: A OnOff control
    //
    // Both Treble and Bass are UNIFORM (mono) controls.
    //
    ///////////////////////////////////////////////////////////////////
        PQKSAUDNODE_ELEM pCurNode = pNode; // pointer to node structure to fill in
        BOOL bCloneRequired = FALSE; // used for nodes that support multiple properties
                                     // to indicate that the parent node has been initialized
                                     // and that a clone node is needed for additional properties

        if( ChannelMask = SupportsControl( pKsControl
                                         , pNode->Id
                                         , KSPROPERTY_AUDIO_BASS_BOOST ) )
        {
            //
            // Bass boost control is supported.
            //
            if( bCloneRequired )
            {
                // we need to create a clone node for this node to support additional
                // properties for this node
                PEERNODE * pNewNode = (PEERNODE *) new PEERNODE;
                if( pNewNode )
                {
                    ZeroMemory( pNewNode, sizeof( PEERNODE ) );
                    pNewNode->pNode = (PQKSAUDNODE_ELEM) new QKSAUDNODE_ELEM;
                    if( !pNewNode->pNode )
                    {
                        hr = E_OUTOFMEMORY;
                        goto exit;
                    }
                    DbgLog( ( LOG_TRACE
                            , DBG_LEVEL_TRACE_ALLOCATIONS
                            , TEXT( "LoadNodeDetails: Allocated clone peer node at 0x%08lx (pNode=0x%08lx)" )
                            , pNewNode
                            , pNewNode->pNode ) );

                    CloneNode( pNewNode->pNode, pNode );
                    AddToCloneList( pNode, pNewNode );
                    pCurNode = pNewNode->pNode;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
            }

            //
            // Fill in as much information as possible.
            //
            pCurNode->NodeType                  = KSNODETYPE_TONE;
            pCurNode->ChannelMask               = ChannelMask;
            pCurNode->PropertyId                = KSPROPERTY_AUDIO_BASS_BOOST;
            pCurNode->MinValue                  = 0;
            pCurNode->MaxValue                  = 1;
            pCurNode->Granularity               = 0;
            pNode->bDetailsSet                  = TRUE;

            bCloneRequired = TRUE; // additional properties for this node will require a clone
            //hr = GetControlRange( pKsControl, pNode );
        }

        if( ChannelMask = SupportsControl( pKsControl
                                         , pNode->Id
                                         , KSPROPERTY_AUDIO_BASS ) )
        {
            //
            // Bass control is supported.
            //
            if( bCloneRequired )
            {
                // we need to create a clone node for this node to support additional
                // properties for this node
                PEERNODE * pNewNode = (PEERNODE *) new PEERNODE;
                if( pNewNode )
                {
                    ZeroMemory( pNewNode, sizeof( PEERNODE ) );
                    pNewNode->pNode = (PQKSAUDNODE_ELEM) new QKSAUDNODE_ELEM;
                    if( !pNewNode->pNode )
                    {
                        hr = E_OUTOFMEMORY;
                        delete pNewNode;
                        goto exit;
                    }
                    DbgLog( ( LOG_TRACE
                            , DBG_LEVEL_TRACE_ALLOCATIONS
                            , TEXT( "LoadNodeDetails: Allocated clone peer node at 0x%08lx (pNode=0x%08lx)" )
                            , pNewNode
                            , pNewNode->pNode ) );

                    CloneNode( pNewNode->pNode, pNode );
                    AddToCloneList( pNode, pNewNode );
                    pCurNode = pNewNode->pNode;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
            }

            //
            // Fill in as much information as possible.
            //
            pCurNode->NodeType                  = KSNODETYPE_TONE;
            pCurNode->ChannelMask               = ChannelMask;
            pCurNode->PropertyId                = KSPROPERTY_AUDIO_BASS;
            pCurNode->MinValue                  = 0;
            pCurNode->MaxValue                  = 0xFFFF;
            pNode->bDetailsSet                  = TRUE;

            hr = GetControlRange( pKsControl, pCurNode );
            if( ( pNode->Granularity == 0 ) ||
                ( ( pNode->MaxValue - pNode->MinValue ) == 0 ) )
            {
                goto exit;
            } else {

                bCloneRequired = TRUE; // additional properties for this node will require a clone
            }
        }

        if( ChannelMask = SupportsControl( pKsControl
                                         , pNode->Id
                                         , KSPROPERTY_AUDIO_TREBLE ) )
        {
            //
            // Treble is supported.
            //
            if( bCloneRequired )
            {
                // we need to create a clone node for this node to support additional
                // properties for this node
                PEERNODE * pNewNode = (PEERNODE *) new PEERNODE;
                ZeroMemory( pNewNode, sizeof( PEERNODE ) );
                if( pNewNode )
                {
                    pNewNode->pNode = (PQKSAUDNODE_ELEM) new QKSAUDNODE_ELEM;
                    if( !pNewNode->pNode )
                    {
                        hr = E_OUTOFMEMORY;
                        goto exit;
                    }
                    DbgLog( ( LOG_TRACE
                            , DBG_LEVEL_TRACE_ALLOCATIONS
                            , TEXT( "LoadNodeDetails: Allocated clone peer node at 0x%08lx (pNode=0x%08lx)" )
                            , pNewNode
                            , pNewNode->pNode ) );

                    CloneNode( pNewNode->pNode, pNode );
                    AddToCloneList( pNode, pNewNode );
                    pCurNode = pNewNode->pNode;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
            }

            //
            // Fill in as much information as possible.
            //
            pCurNode->NodeType                  = KSNODETYPE_TONE;
            pCurNode->ChannelMask               = ChannelMask;
            pCurNode->PropertyId                = KSPROPERTY_AUDIO_TREBLE;
            pCurNode->MinValue                  = 0;
            pCurNode->MaxValue                  = 0xFFFF;
            pNode->bDetailsSet                  = TRUE;

            hr = GetControlRange( pKsControl, pCurNode );
            if( ( pNode->Granularity == 0 ) ||
                ( ( pNode->MaxValue - pNode->MinValue ) == 0 ) )
            {
                goto exit;
            } else {

                bCloneRequired = TRUE; // additional properties for this node will require a clone
            }
        }

    ///////////////////////////////////////////////////////////////////
    } else if( pNode->NodeType == KSNODETYPE_VOLUME ) {
    ///////////////////////////////////////////////////////////////////
    //
    // A VOLUME is a fader-type control
    //
    // To determine if a node supports stereo volume changes (left
    // and right have independent control), a help function is called.
    //
    ///////////////////////////////////////////////////////////////////

        //
        // Read the channel mask for the node.
        //
        ChannelMask = SupportsControl ( pKsControl
                                      , pNode->Id
                                      , KSPROPERTY_AUDIO_VOLUMELEVEL );
        //
        // If the ChannelMask is 0, this node does not support volume.
        //

        if( ChannelMask == 0 )
        {
            goto exit;
        }

        if( ( ChannelMask & SPEAKER_FRONT_LEFT  ) &&
            ( ChannelMask & SPEAKER_FRONT_RIGHT ) &&
            ( ChannelMask != MASTER_CHANNEL       ) )
        {
            bStereo = TRUE;
        }

        //
        // Fill in as much information as possible.
        //
        pNode->PropertyId = KSPROPERTY_AUDIO_VOLUMELEVEL;
        pNode->ChannelMask = ChannelMask;
        if( bStereo )
        {
            pNode->cChannels = 2;
        }
        else
        {
            pNode->cChannels = 1;
        }

        hr = GetControlRange( pKsControl, pNode );
        pNode->bDetailsSet = TRUE;

    ///////////////////////////////////////////////////////////////////
    } else if( pNode->NodeType == KSNODETYPE_SUPERMIX ) {
    ///////////////////////////////////////////////////////////////////
    //
    // SuperMix nodes can be supported as MUTE controls if the MUTE
    // property is supported.
    //
    ///////////////////////////////////////////////////////////////////


        PKSAUDIO_MIXCAP_TABLE pMixCaps;
        ULONG                 i,
                              Size;
        BOOL                  bMutable;
        BOOL                  bVolume = FALSE;
        PKSAUDIO_MIXLEVEL     pMixLevels;

        hr = GetSuperMixCaps( pKsControl, pNode->Id, &pMixCaps );
        // caller must free pMixCaps mem
        if( SUCCEEDED( hr ) )
        {
            Size = pMixCaps->InputChannels * pMixCaps->OutputChannels;

            pMixLevels = (KSAUDIO_MIXLEVEL *) new BYTE[ Size * sizeof( KSAUDIO_MIXLEVEL ) ];
            if( !pMixLevels )
                hr = E_OUTOFMEMORY;
            else
            {
                hr = GetAudioNodeProperty( pKsControl
                                         , KSPROPERTY_AUDIO_MIX_LEVEL_TABLE
                                         , pNode->Id
                                         , 0
                                         , NULL
                                         , 0
                                         , pMixLevels
                                         , Size * sizeof( KSAUDIO_MIXLEVEL ) );
                if( SUCCEEDED( hr ) )
                {
                    bMutable = TRUE;
                    for( i = 0; i < Size; i++ )
                    {
                        //
                        // If the channel is mutable, then all is well for this entry.
                        //
                        if( pMixCaps->Capabilities[ i ].Mute ) {
                            continue;
                        }

                        //
                        // The the entry is not mutable but is fully attenuated,
                        // this will work too.
                        //
                        if( ( pMixCaps->Capabilities[ i ].Minimum == LONG_MIN ) &&
                            ( pMixCaps->Capabilities[ i ].Maximum == LONG_MIN ) &&
                            ( pMixCaps->Capabilities[ i ].Reset   == LONG_MIN ) )
                        {
                            continue;
                        }

                        bMutable = FALSE;
                        break;
                    }

                    //
                    // This node cannot be used as a MUTE control.
                    //
                    if( !bMutable && !bVolume )
                    {
                        delete pMixCaps;
                        delete pMixLevels;
                    }
                    else if( bMutable )
                    {
                        //
                        // The Supermix is verifiably usable as a MUTE.  Fill in all the
                        // details.
                        //
                        pNode->Parameters.Size             = pMixCaps->InputChannels *
                                                                 pMixCaps->OutputChannels;
                        pNode->Parameters.pMixCaps         = pMixCaps;
                        pNode->Parameters.pMixLevels       = pMixLevels;

                        pNode->NodeType                    = KSNODETYPE_SUPERMIX;
                        pNode->ChannelMask                 = MASTER_CHANNEL;
                        pNode->PropertyId                  = KSPROPERTY_AUDIO_MIX_LEVEL_TABLE;
                        pNode->MinValue                    = 0;
                        pNode->bMute                       = TRUE; //hack!!! get rid of this
                        pNode->MaxValue                    = 1;
                        pNode->Granularity                 = 0;


                        pNode->MinValue                    = pMixCaps->Capabilities[ 0 ].Minimum;
                        pNode->MaxValue                    = pMixCaps->Capabilities[ 0 ].Minimum;
                        pNode->Granularity                 = 32; // why?
                        pNode->bDetailsSet                 = TRUE;
                    }
                }
                else
                {
                    delete pMixCaps;
                    delete pMixLevels;
                }
            }
        }
    }

exit:
    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::CloneNode
//
// Copy the contents of one node into another
//
//--------------------------------------------------------------------------;
void CloneNode
(
    PQKSAUDNODE_ELEM pDestNode,
    PQKSAUDNODE_ELEM pSrcNode
)
{
    ASSERT( pDestNode && pSrcNode );

    // just copy the struct
    if( pDestNode && pSrcNode )
    {
        pDestNode = pSrcNode;
    }
}


//--------------------------------------------------------------------------;
//
// CKsAudHelper::GetAudioNodeProperty
//
// Similar to ksNodeProperty except for the property set is assumed
// to be KSPROPSETID_Audio and a KSNODEPROPERTY_AUDIO_CHANNEL structure
// is used instead of KSNODEPROPERTY to allow channel selection.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::GetAudioNodeProperty
(
    IKsControl * pKsControl,
    ULONG        ulPropertyId,      // The audio property to get
    ULONG        ulNodeId,          // The virtual node id
    LONG         lChannel,          // The channel number
    PVOID        pInData,           // Pointer to extra input bytes
    ULONG        cbInData,          // Number of extra input bytes
    PVOID        pOutData,          // Pointer to output buffer
    LONG         cbOutData          // Size of the output buffer
)
{
    HRESULT                       hr = S_OK;
    ULONG                         cbInput;
    ULONG                         ulBytesReturned;

    if( !pKsControl )
        pKsControl = m_pKsControl;

    //
    // Determine the minimum number of input bytes
    //
    cbInput = sizeof( KSNODEPROPERTY_AUDIO_CHANNEL );

    //
    // If the caller passed in additional data, allocate enough memory
    // to hold the KSNODEPROPERTY_AUDIO_CHANNEL plus the input bytes
    // and copy the input bytes into the new memory immediately after
    // the KSNODEPROPERTY_AUDIO_CHANNEL structure.
    //
    if( cbInData > 0 ) {
        cbInput += cbInData;
    }

    PKSNODEPROPERTY_AUDIO_CHANNEL pInput =
        (PKSNODEPROPERTY_AUDIO_CHANNEL) _alloca( cbInput );
    if (!pInput)
    {
        ASSERT (pInput);
        return E_OUTOFMEMORY;
    }
    ZeroMemory( pInput, sizeof( KSNODEPROPERTY_AUDIO_CHANNEL ) );

    if( cbInData )
        memcpy( pInput + 1, pInData, cbInData ); // Copy the extra data at the end of the structure

    //
    // The extra work required to call SynchronousDeviceControl
    //
    pInput->NodeProperty.Property.Set   = KSPROPSETID_Audio;
    pInput->NodeProperty.Property.Id    = ulPropertyId;
    pInput->NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET |
                                          KSPROPERTY_TYPE_TOPOLOGY;

    //
    // Fill in the node id
    //
    pInput->NodeProperty.NodeId = ulNodeId;
    pInput->NodeProperty.Reserved = 0; // shouldn't be necessary

    //
    // Fill in the channel details.
    //
    pInput->Channel                     = lChannel;
    pInput->Reserved                    = 0;

    if (SUCCEEDED (hr))
    {
        hr = pKsControl->KsProperty(
            (PKSPROPERTY) pInput,           // Pointer to the KSNODEPROPERTY struct
            cbInput,                        // Number or bytes input
            pOutData,                       // Pointer to the buffer to store output
            cbOutData,                      // Size of the output buffer
            &ulBytesReturned                // Number of bytes returned from the call
            );
    }
    // caller must free pOutData
    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::SetAudioNodeProperty
//
// Similar to ksNodeProperty except for the property set is assumed
// to be KSPROPSETID_Audio and a KSNODEPROPERTY_AUDIO_CHANNEL structure
// is used instead of KSNODEPROPERTY to allow channel selection.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::SetAudioNodeProperty
(
    IKsControl * pKsControl,
    ULONG        ulPropertyId,      // The audio property to get
    ULONG        ulNodeId,          // The virtual node id
    LONG         lChannel,          // The channel number
    PVOID        pInData,           // Pointer to extra input bytes
    ULONG        cbInData,          // Number of extra input bytes
    PVOID        pOutData,          // Pointer to output buffer
    LONG         cbOutData         // Size of the output buffer
)
{
    HRESULT                       hr = S_OK;
    ULONG                         cbInput;
    ULONG                         ulBytesReturned;

    if( !pKsControl )
        pKsControl = m_pKsControl;

    //
    // Determine the minimum number of input bytes
    //
    cbInput = sizeof( KSNODEPROPERTY_AUDIO_CHANNEL );

    //
    // If the caller passed in additional data, allocate enough memory
    // to hold the KSNODEPROPERTY_AUDIO_CHANNEL plus the input bytes
    // and copy the input bytes into the new memory immediately after
    // the KSNODEPROPERTY_AUDIO_CHANNEL structure.
    //
    if( cbInData > 0 ) {
        cbInput += cbInData;
    }

    PKSNODEPROPERTY_AUDIO_CHANNEL pInput =
        (PKSNODEPROPERTY_AUDIO_CHANNEL) _alloca( cbInput );
    if (!pInput)
    {
        ASSERT (pInput);
        return E_OUTOFMEMORY;
    }
    ZeroMemory( pInput, sizeof( KSNODEPROPERTY_AUDIO_CHANNEL ) );

    if( cbInData )
        memcpy( pInput + 1, pInData, cbInData ); // Copy the extra data at the end of the structure

    //
    // The extra work required to call SynchronousDeviceControl
    //
    pInput->NodeProperty.Property.Set   = KSPROPSETID_Audio;
    pInput->NodeProperty.Property.Id    = ulPropertyId;
    pInput->NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET |
                                          KSPROPERTY_TYPE_TOPOLOGY;

    //
    // Fill in the node id
    //
    pInput->NodeProperty.NodeId = ulNodeId;
    pInput->NodeProperty.Reserved = 0; // shouldn't be necessary


    //
    // Fill in the channel details.
    //
    pInput->Channel                     = lChannel;
    pInput->Reserved                    = 0;

    if (SUCCEEDED (hr))
    {
        hr = pKsControl->KsProperty(
            (PKSPROPERTY) pInput,           // Pointer to the KSNODEPROPERTY struct
            cbInput,                        // Number or bytes input
            pOutData,                       // Pointer to the buffer to store output
            cbOutData,                      // Size of the output buffer
            &ulBytesReturned                  // Number of bytes returned from the call
            );
    }
    // caller must free pOutData
    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::GetControlRange
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::GetControlRange
(
    IKsControl * pKsControl,
    QKSAUDNODE_ELEM * pNode
)
{
    PKSPROPERTY_DESCRIPTION   pPropDesc = NULL;
    PKSPROPERTY_MEMBERSHEADER pMemberHeader;
    PKSPROPERTY_STEPPING_LONG pSteppingLong;

    //
    // Query the range for this control.  For a failure, set the
    // default range.
    //

    HRESULT hr = QueryPropertyRange(
        pKsControl,
        &KSPROPSETID_Audio,
        pNode->PropertyId,
        pNode->Id,
        &pPropDesc
        );
    if( FAILED( hr ) ) {
        //SetDefaultRange( pNode );
        return hr;
    }

    //
    // Do some checking on the returned value.  Look for things that we
    // support.
    //
    if( ( pPropDesc->MembersListCount == 0                      ) ||
        ( pPropDesc->PropTypeSet.Set != KSPROPTYPESETID_General ) ||
        ( pPropDesc->PropTypeSet.Id != VT_I4                    ) )
    {
        ASSERT( FALSE );
        //SetDefaultRange( pNode );
        delete pPropDesc;
        return E_FAIL;
    }

    pMemberHeader = (PKSPROPERTY_MEMBERSHEADER) ( pPropDesc + 1 );

    if( pMemberHeader->MembersFlags & KSPROPERTY_MEMBER_STEPPEDRANGES ) {

        pSteppingLong = (PKSPROPERTY_STEPPING_LONG) ( pMemberHeader + 1 );
        pNode->MinValue = pSteppingLong->Bounds.SignedMinimum;
        pNode->MaxValue = pSteppingLong->Bounds.SignedMaximum;
        if( pSteppingLong->SteppingDelta > 0 )
        {
            pNode->Granularity    = (LONG) ( ( (LONGLONG) pSteppingLong->Bounds.SignedMaximum -
                                                (LONGLONG) pSteppingLong->Bounds.SignedMinimum ) /
                                                (LONGLONG) pSteppingLong->SteppingDelta );
        }
        else
        {
            pNode->Granularity = 0;
        }
        hr = S_OK;
    }
    else
        hr = E_FAIL;

    delete pPropDesc;

    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::QueryPropertyRange
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::QueryPropertyRange
(
    IKsControl *             pKsControl,
    CONST GUID*              pguidPropSet,
    ULONG                    ulPropertyId,
    ULONG                    ulNodeId,
    PKSPROPERTY_DESCRIPTION* ppPropDesc
)
{
    HRESULT                 hr;
    KSNODEPROPERTY          NodeProperty;
    KSPROPERTY_DESCRIPTION  PropertyDescription;
    PKSPROPERTY_DESCRIPTION pPropDesc = NULL;
    ULONG                   ulBytesReturned;

    if( !pKsControl )
        pKsControl = m_pKsControl;

    NodeProperty.Property.Set   = *pguidPropSet;
    NodeProperty.Property.Id    = ulPropertyId;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT |
                                  KSPROPERTY_TYPE_TOPOLOGY;
    NodeProperty.NodeId         = ulNodeId;
    NodeProperty.Reserved       = 0;

    hr = pKsControl->KsProperty(
        (KSIDENTIFIER *) &NodeProperty,
        sizeof( NodeProperty ),
        &PropertyDescription,
        sizeof( PropertyDescription ),
        &ulBytesReturned
        );
    if( SUCCEEDED( hr ) )
    {
        pPropDesc = (PKSPROPERTY_DESCRIPTION) new BYTE[ PropertyDescription.DescriptionSize ];
        if( !pPropDesc )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pKsControl->KsProperty(
                (KSIDENTIFIER *) &NodeProperty,
                sizeof( NodeProperty ),
                pPropDesc,
                PropertyDescription.DescriptionSize,
                &ulBytesReturned
                );
        }
    }

    if (FAILED( hr )) {
        delete pPropDesc;
        pPropDesc = NULL;
    }

    *ppPropDesc = pPropDesc;
    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::GetSuperMixCaps
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::GetSuperMixCaps
(
    IKsControl *           pKsControl,
    ULONG                  ulNodeId,
    PKSAUDIO_MIXCAP_TABLE* paMixCaps
)
{
    ASSERT( paMixCaps );

    HRESULT                 hr;
    ULONG                   ulBytesReturned;

    ULONG Size;
    struct
    {
        ULONG InputChannels;
        ULONG OutputChannels;
    } SuperMixSize;
    PKSAUDIO_MIXCAP_TABLE pMixCaps = NULL;

    *paMixCaps = NULL;

    if( !pKsControl )
        pKsControl = m_pKsControl;

    //
    // Query the node with just the first 2 DWORDs of the MIXCAP table.
    // This will return the dimensions of the supermixer.
    //
    hr = GetAudioNodeProperty( pKsControl
                             , KSPROPERTY_AUDIO_MIX_LEVEL_CAPS
                             , ulNodeId
                             , 0
                             , NULL
                             , 0
                             , &SuperMixSize
                             , sizeof( SuperMixSize ) );
    if( SUCCEEDED( hr ) )
    {
        //
        // Allocate a MIXCAPS table big enough to hold all the entrees.
        // The size needs to include the first 2 DWORDs in the MIXCAP
        // table besides the array ( InputCh * OutputCh ) of MIXCAPs
        //
        Size = sizeof( SuperMixSize ) +
               SuperMixSize.InputChannels * SuperMixSize.OutputChannels *
               sizeof( KSAUDIO_MIX_CAPS );

        pMixCaps = (KSAUDIO_MIXCAP_TABLE *) new BYTE[ Size ];
        if( !pMixCaps )
        {
            hr = E_OUTOFMEMORY;
        }

        //
        // Query the node once again to fill in the MIXCAPS structures.
        //
        hr = GetAudioNodeProperty( pKsControl
                                 , KSPROPERTY_AUDIO_MIX_LEVEL_CAPS
                                 , ulNodeId
                                 , 0
                                 , NULL
                                 , 0
                                 , pMixCaps
                                 , Size );
    }
    if (FAILED( hr )) {
        delete pMixCaps;
        pMixCaps = NULL;
    }

    *paMixCaps = pMixCaps; // must free this
    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::GetMuteFromSuperMix
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::GetMuteFromSuperMix
(
    IKsControl *           pKsControl,
    QKSAUDNODE_ELEM *      pNode,
    BOOL *                 pBool
)
{
    ASSERT( pNode );
    ASSERT( pNode->Parameters.pMixCaps   );
    ASSERT( pNode->Parameters.pMixLevels );

    if( !pNode || !pNode->Parameters.pMixCaps || !pNode->Parameters.pMixLevels )
        return E_POINTER;

    HRESULT hr = S_OK;

    BOOL bMute = FALSE;
    //
    // Read the current state of the supermix
    //
    hr = GetAudioNodeProperty( pKsControl
                             , KSPROPERTY_AUDIO_MIX_LEVEL_TABLE
                             , pNode->Id
                             , 0
                             , NULL
                             , 0
                             , pNode->Parameters.pMixLevels
                             , pNode->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL ) );
    if( SUCCEEDED( hr ) )
    {
        for( int i = 0; i < (int) pNode->Parameters.Size; i++ )
        {
            if( pNode->Parameters.pMixLevels[ i ].Mute )
            {
                bMute = TRUE;
                continue;
            }

            if( pNode->Parameters.pMixLevels[ i ].Level == LONG_MIN )
            {
                bMute = TRUE;
                continue;
            }

            bMute = FALSE;
            break;
        }
    }

    *pBool = bMute;

    return hr;
}


//--------------------------------------------------------------------------;
//
// CKsAudHelper::SetMuteFromSuperMix
//
//  Sets the mute state on a supermixer.
//
//--------------------------------------------------------------------------;
HRESULT CKsAudHelper::SetMuteFromSuperMix
(
    IKsControl *           pKsControl,
    QKSAUDNODE_ELEM *      pNode,
    BOOL                   Bool
)
{
    ASSERT( pNode );
    ASSERT( pNode->Parameters.pMixCaps   );
    ASSERT( pNode->Parameters.pMixLevels );

    if( !pNode || !pNode->Parameters.pMixCaps || !pNode->Parameters.pMixLevels )
        return E_POINTER;

    HRESULT hr = S_OK;

    BOOL bMute = FALSE;

    //
    // Read the current state of the supermix
    //
    hr = GetAudioNodeProperty( pKsControl
                             , KSPROPERTY_AUDIO_MIX_LEVEL_TABLE
                             , pNode->Id
                             , 0
                             , NULL
                             , 0
                             , pNode->Parameters.pMixLevels
                             , pNode->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL ) );
    if( SUCCEEDED( hr ) )
    {
        //
        // For any entry in the table that supports muting, mute it.
        //
        for( int i = 0; i < (int) pNode->Parameters.Size; i++ )
        {
            if( pNode->Parameters.pMixCaps->Capabilities[ i ].Mute ) {
                pNode->Parameters.pMixLevels[ i ].Mute = Bool;
            }
        }

        //
        // Set this new supermixer state.
        //
        hr = SetAudioNodeProperty( pKsControl
                                 , KSPROPERTY_AUDIO_MIX_LEVEL_TABLE
                                 , pNode->Id
                                 , 0
                                 , NULL
                                 , 0
                                 , pNode->Parameters.pMixLevels
                                 , pNode->Parameters.Size * sizeof( KSAUDIO_MIXLEVEL ) );
    }

    return hr;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::FindDestinationPin
//
// Loop through all of a node's children (and branches) to see if the line
// ends in a destination pin of the desired type, looping over all node
// branches if necessary.
//
//--------------------------------------------------------------------------;
BOOL CKsAudHelper::FindDestinationPin
(
    PQKSAUDNODE_ELEM      pNode,        // The node to start the search with
    ULONG                 ulDestPinId   // The desired node type of the destination
)
{
    ASSERT( pNode );
    if( !pNode )
        return FALSE;

    //
    // Check to see if this is the end of this line.
    //
    if( pNode->Type == DESTINATION )
    {
        if( pNode->Id == ulDestPinId )
            return TRUE;
        else
            return FALSE;
    }

    PEERNODE * pPeer = FirstChildNode( pNode );
    if( pPeer )
    {
        if( ChildListLength( pPeer->pNode ) > 1 )
        {
            // go right to the children of this node
            pPeer = FirstChildNode( pPeer->pNode );
            while( pPeer )
            {
                if( FindDestinationPin( pPeer->pNode, ulDestPinId ) )
                    return TRUE;

                pPeer = NextPeerNode( pPeer );
            }
        }
        else
        {
            if( FindDestinationPin( pPeer->pNode, ulDestPinId ) )
                return TRUE;
        }
    }
    return FALSE;
}

//--------------------------------------------------------------------------;
//
// CKsAudHelper::FindSourcePin
//
// Loop through all of a node's parents (and branches) to see if the line
// ends in a source pin of the desired type, looping over all node
// branches if necessary.
//
//--------------------------------------------------------------------------;
BOOL CKsAudHelper::FindSourcePin
(
    PQKSAUDNODE_ELEM      pNode,        // The node to start the search with
    ULONG                 ulSrcPinId    // The desired node type of the source
)
{
    ASSERT( pNode );
    if( !pNode )
        return FALSE;

    //
    // Check to see if this is the beginning of this line.
    //
    if( pNode->Type == SOURCE )
    {
        if( pNode->Id == ulSrcPinId )
            return TRUE;
        else
            return FALSE;
    }

    PEERNODE * pPeer = FirstParentNode( pNode );
    if( pPeer )
    {
        if( ParentListLength( pPeer->pNode ) > 1 )
        {
			// go right to the parent of this node
			pPeer = FirstParentNode( pPeer->pNode );
            while( pPeer )
            {
                if( FindSourcePin( pPeer->pNode, ulSrcPinId ) )
                    return TRUE;

                pPeer = NextPeerNode( pPeer );
            }
        }
        else
        {
            if( FindSourcePin( pPeer->pNode, ulSrcPinId ) )
                return TRUE;
        }
    }
    return FALSE;
}



//--------------------------------------------------------------------------;
//
// FindDestination
//
// In the list of destinations, it finds the destination matching
// the given id.
//
//--------------------------------------------------------------------------;
PQKSAUDNODE_ELEM CKsAudHelper::FindDestination(
    ULONG              Id          // The node Id to look for in the list
)
{
    PQKSAUDNODE_ELEM pTemp = FirstInList( m_listDests );

    while( pTemp ) {
        if( pTemp->Id == Id ) {
            return( pTemp );
        }
        pTemp = NextNode( pTemp );
    }

    return( NULL );
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// Global Helper Functions
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// PinCategoryToString
//
// Converts the Pin category GUIDs to a string.
//
//--------------------------------------------------------------------------;
const char* KsPinCategoryToString
(
    CONST GUID* NodeType // The GUID to translate
)
{
    return(
        ( *NodeType == KSNODETYPE_MICROPHONE             ) ? "Microphone"       :
        ( *NodeType == KSNODETYPE_SPEAKER                ) ? "Speaker"          :
        ( *NodeType == KSNODETYPE_HEADPHONES             ) ? "Headphones"       :
        ( *NodeType == KSNODETYPE_LEGACY_AUDIO_CONNECTOR ) ? "Wave"             :
        ( *NodeType == KSNODETYPE_CD_PLAYER              ) ? "CD Player"        :
        ( *NodeType == KSNODETYPE_SYNTHESIZER            ) ? "Synthesizer"      :
        ( *NodeType == KSCATEGORY_AUDIO                  ) ? "Wave"             :
        ( *NodeType == KSNODETYPE_LINE_CONNECTOR         ) ? "Aux Line"         :
        ( *NodeType == KSNODETYPE_TELEPHONE              ) ? "Telephone"        :
        ( *NodeType == KSNODETYPE_PHONE_LINE             ) ? "Phone Line"       :
        ( *NodeType == KSNODETYPE_DOWN_LINE_PHONE        ) ? "Downline Phone"   :
        ( *NodeType == KSNODETYPE_ANALOG_CONNECTOR       ) ? "Analog connector" :
            "Unknown"
    );
}

//--------------------------------------------------------------------------;
//
// PinFactoryIDFromPin
//
// Returns the PinFactoryID for an IPin
//
//--------------------------------------------------------------------------;
STDMETHODIMP PinFactoryIDFromPin
(
    IPin  * pPin,
    ULONG * pPinFactoryID
)
{
    HRESULT hr = E_INVALIDARG;

    *pPinFactoryID = 0;

    if (pPin)
    {
        IKsPinFactory * PinFactoryInterface;

        hr = pPin->QueryInterface(__uuidof(IKsPinFactory), reinterpret_cast<PVOID*>(&PinFactoryInterface));
        if (SUCCEEDED(hr)) {
            hr = PinFactoryInterface->KsPinFactory(pPinFactoryID);
            PinFactoryInterface->Release();
        }
    }
    return hr;
}

//--------------------------------------------------------------------------;
//
// NodeTypeToString
//
// Converts a NodeType GUID to a string
//
//--------------------------------------------------------------------------;
const char* NodeTypeToString
(
    CONST GUID* NodeType // The GUID to translate
)
{
    return(
        ( *NodeType == KSNODETYPE_SPEAKER ) ? "Speaker"            :
        ( *NodeType == KSNODETYPE_DAC                     ) ? "DAC"                :
        ( *NodeType == KSNODETYPE_ADC                     ) ? "ADC"                :
        ( *NodeType == KSNODETYPE_SRC                     ) ? "SRC"                :
        ( *NodeType == KSNODETYPE_SUPERMIX                ) ? "SuperMIX"           :
        ( *NodeType == KSNODETYPE_SUM                     ) ? "Sum"                :
        ( *NodeType == KSNODETYPE_MUTE                    ) ? "Mute"               :
        ( *NodeType == KSNODETYPE_VOLUME                  ) ? "Volume"             :
        ( *NodeType == KSNODETYPE_TONE                    ) ? "Tone"               :
        ( *NodeType == KSNODETYPE_AGC                     ) ? "AGC"                :
        ( *NodeType == KSNODETYPE_DELAY                   ) ? "Delay"              :
        ( *NodeType == KSNODETYPE_LOUDNESS                ) ? "LOUDNESS"           :
        ( *NodeType == KSNODETYPE_DEV_SPECIFIC            ) ? "Dev Specific"       :
        ( *NodeType == KSNODETYPE_PROLOGIC_DECODER        ) ? "Prologic Decoder"   :
        ( *NodeType == KSNODETYPE_STEREO_WIDE             ) ? "Stereo Wide"        :
        ( *NodeType == KSNODETYPE_REVERB                  ) ? "Reverb"             :
        ( *NodeType == KSNODETYPE_CHORUS                  ) ? "Chorus"             :
        ( *NodeType == KSNODETYPE_ACOUSTIC_ECHO_CANCEL    ) ? "AEC"                :
        ( *NodeType == KSNODETYPE_EQUALIZER               ) ? "Equalizer"          :
        ( *NodeType == KSNODETYPE_MUX                     ) ? "Mux"                :
        ( *NodeType == KSNODETYPE_DEMUX                   ) ? "Demux"              :
        ( *NodeType == KSNODETYPE_STEREO_ENHANCE          ) ? "Stereo Enhance"     :
        ( *NodeType == KSNODETYPE_SYNTHESIZER             ) ? "Synthesizer"        :
            "Unknown"
    );
}

//--------------------------------------------------------------------------;
//
// FreePeerList
//
// Note: This only frees the peer nodes in a peer list.  The nodes pointed
// to by the pNode member must be cleaned up in some other manner.
//
//--------------------------------------------------------------------------;
VOID FreePeerList
(
    PEERLIST list            // The PeerList to free
)
{
    PEERNODE* pPeerNode = RemoveFirstPeerNode( list );

    while( pPeerNode ) {

        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_ALLOCATIONS
                , TEXT( "FreePeerList: freeing peer node at 0x%08lx (pNode=0x%08lx)" )
                , pPeerNode
                , pPeerNode->pNode ) );

        if( pPeerNode->pNode->Parameters.pMixCaps )
        {
            //
            // free any supermix allocations, NOTE that we expect the node to
            // still be valid when we're doing this!!! So the node freeing
            // code should free QKSAUDNODE_ELEM nodes AFTER freeing peer list nodes.
            //
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_ALLOCATIONS
                    , TEXT( "FreePeerList: freeing supermix caps for node 0x%08lx (pNode=0x%08lx)" )
                    , pPeerNode
                    , pPeerNode->pNode ) );
            delete pPeerNode->pNode->Parameters.pMixCaps;
            pPeerNode->pNode->Parameters.pMixCaps = NULL;
        }
        if( pPeerNode->pNode->Parameters.pMixLevels )
        {
            delete pPeerNode->pNode->Parameters.pMixLevels;
            pPeerNode->pNode->Parameters.pMixLevels = NULL;
        }

        // now delete the peer node
        delete pPeerNode;
        pPeerNode = RemoveFirstPeerNode( list );
    }
}

//--------------------------------------------------------------------------;
//
// InList
//
// Loops through the given list looking for pNewNode.
//
//--------------------------------------------------------------------------;
BOOL InList
(
    PEERLIST            list,      // The list to search
    PQKSAUDNODE_ELEM    pNewNode   // The new to search for
)
{
    PEERNODE* pTemp = FirstInList( list );

    // Zing through the list checking to see if there is a node with
    // the same Id and Type.  These two checks are suffient to ensure
    // uniquness.  Ids are unique among all sources and destinations,
    // and Ids, or node numbers, are unique among all nodes.  Note
    // that a source (or destination) node and a node can have the same
    // Id.

    while( pTemp )
    {
        if( ( pTemp->pNode->Id   == pNewNode->Id   ) &&
            ( pTemp->pNode->Type == pNewNode->Type ) )
            return( TRUE );
        pTemp = NextPeerNode( pTemp );
    }

    // No match in the entire list, the new node is not already in the
    // list.
    return( FALSE );
}

//--------------------------------------------------------------------------;
//
// InChildList
//
// Calls InList on the child list of the node.
//
//--------------------------------------------------------------------------;
BOOL InChildList
(
    QKSAUDNODE_LIST     list,       // The list to search the parent list
    PQKSAUDNODE_ELEM    pNewNode    // The node to search for
)
{
    ASSERT( list )    ;
    ASSERT( pNewNode );

    return( InList( list->Children, pNewNode ) );
}

//--------------------------------------------------------------------------;
//
// InParentList
//
// Calls InList on the parent list of the node.
//
//--------------------------------------------------------------------------;
BOOL InParentList
(
    QKSAUDNODE_LIST  list,       // The list to search the parent list
    PQKSAUDNODE_ELEM pNewNode    // The node to search for
)
{
    ASSERT( list     );
    ASSERT( pNewNode );

    return( InList( list->Parents, pNewNode ) );
}

//--------------------------------------------------------------------------;
//
// ListCount
//
// Loops through the Next fields to count the elements.
//
//--------------------------------------------------------------------------;
ULONG ListCount
(
    SINGLE_LIST_ENTRY * pList     // The list to count the elements of
)
{
    ULONG   Count = 0;
    SINGLE_LIST_ENTRY * pTemp = pList;

    while( pTemp ) {
        ++Count;
        pTemp = pTemp->Next;
    }

    return( Count );
}

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// More db/linear conversion helpers
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// VolLinearToLog
//
// Converts from the linear range (0-64k) to the hardware range (dB).
//
//--------------------------------------------------------------------------;
LONG VolLinearToLog(
    DWORD       Value,
    DWORD       dwMinValue,
    DWORD       dwMaxValue
)
{
    double         LinearRange;
    double         dfValue;
    double         dfResult;
    double         dfRatio;
    LONG           Result;

    if( Value == 0 ) {
        return( NEG_INF_DB );
    }

    LinearRange = (double) LINEAR_RANGE;
    dfValue     = (double) Value;

    dfRatio = ( (double) (LONG) dwMaxValue -
                (double) (LONG) dwMinValue ) / DFLINEAR_RANGE;

    if( dfRatio < 1.0 ) {
        dfRatio = 1.0;
    }
    dfResult = LinearRange * dfRatio * 20.0 * log10( dfValue / LinearRange );
    if( dfResult < 0.0 ) {
        Result = (LONG) ( dfResult - 0.5 ) + dwMaxValue;
    } else {
        Result = (LONG) ( dfResult + 0.5 ) + dwMaxValue;
    }
    return( Result );
}


//--------------------------------------------------------------------------;
//
// VolLogToLinear
//
// Converts the hardware range (dB) to a linear range from 0-64k.
//
//--------------------------------------------------------------------------;
LONG VolLogToLinear
(
    LONG       Value,
    LONG       lMinValue,
    LONG       lMaxValue
)
{
    double         LinearRange;
    double         dfValue;
    double         dfResult;
    double         dfRatio;
    DWORD          Result;

    if( Value == NEG_INF_DB ) {
        return( 0 );
    }

    LinearRange = (double) LINEAR_RANGE;
    dfValue     = (double) Value;

    dfRatio = ( (double) lMaxValue -
                (double) lMinValue ) / DFLINEAR_RANGE;

    if( dfRatio < 1.0 ) {
        dfRatio = 1.0;
    }

    dfValue = ( dfValue - lMaxValue ) / LinearRange;
    dfResult = LinearRange * pow( 10.0, dfValue / ( 20.0 * dfRatio ) );
    if( dfResult >= LINEAR_RANGE ) {
        Result = LINEAR_RANGE;
    } else if ( dfResult < 0.0 ) {
       Result = 0;
    } else {
       Result = (DWORD) ( dfResult + 0.5 );
    }
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\qksaud\qksaud.h ===
//--------------------------------------------------------------------------;
//
//  File: QKsPAud.h
//
//  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//      Header for KsProxy audio interface handler for DirectShow
//      
//  History:
//      10/05/98    msavage     created
//
//--------------------------------------------------------------------------;

#define DBG_LEVEL_TRACE_DETAILS       5
#define DBG_LEVEL_TRACE_FAILURES      5
#define DBG_LEVEL_TRACE_TOPOLOGY      5
#define DBG_LEVEL_TRACE_ALLOCATIONS   15
#define DBG_LEVEL_TRACE_DIRTY_DETAILS 15

// for db/ampl conversions
#define LINEAR_RANGE 0xFFFF     // 64k
#define DFLINEAR_RANGE  ( 96.0 * 65535.0 )
#define NEG_INF_DB   0x80000000 // -32767 * 64k dB

class CQKsAudIntfPinHandler;
class CQKsAudIntfHandler;

//
// This is only used internally 
//
struct DECLSPEC_UUID("cd6dba4e-2734-11d2-b733-00c04fb6bd3d") IAMKsAudIntfHandler;
DECLARE_INTERFACE_(IAMKsAudIntfHandler, IUnknown)
{
    STDMETHOD_(HRESULT, CreatePinHandler)(LPUNKNOWN UnkOuter, CQKsAudIntfPinHandler **, IPin *) PURE;
};


//
// Interface Handler class for pins
//
class CQKsAudIntfPinHandler :
    public CBasicAudio,
    public IAMAudioInputMixer,
    public IDistributorNotify
{

public:
    DECLARE_IUNKNOWN;

    CQKsAudIntfPinHandler(
        LPUNKNOWN UnkOuter,
        CQKsAudIntfHandler * pFilterHandler,
        TCHAR* Name,
        IPin* pPin,
        HRESULT* hr);

    ~CQKsAudIntfPinHandler();

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);

    // Implement IBasicAudio
    STDMETHODIMP put_Volume (IN  long   lVolume);
    STDMETHODIMP get_Volume (OUT long *plVolume);
    STDMETHODIMP put_Balance(IN  long   lVolume);
    STDMETHODIMP get_Balance(OUT long *plVolume);

    // Implement IAMAudioInputMixer
    STDMETHODIMP put_Enable(BOOL fEnable);
    STDMETHODIMP get_Enable(BOOL *pfEnable);
    STDMETHODIMP put_Mono(BOOL fMono);
    STDMETHODIMP get_Mono(BOOL *pfMono);
    STDMETHODIMP put_Loudness(BOOL fLoudness);
    STDMETHODIMP get_Loudness(BOOL *pfLoudness);
    STDMETHODIMP put_MixLevel(double Level);
    STDMETHODIMP get_MixLevel(double FAR* pLevel);
    STDMETHODIMP put_Pan(double Pan);
    STDMETHODIMP get_Pan(double FAR* pPan);
    STDMETHODIMP put_Treble(double Treble);
    STDMETHODIMP get_Treble(double FAR* pTreble);
    STDMETHODIMP get_TrebleRange(double FAR* pRange);
    STDMETHODIMP put_Bass(double Bass);
    STDMETHODIMP get_Bass(double FAR* pBass);
    STDMETHODIMP get_BassRange(double FAR* pRange);

    IPin * GetPin() { return m_pPin; }
    IKsControl * GetKsControl() { return m_pKsControl; }
    BOOL IsKsPinConnected();

    // IDistributorNotify
    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tBase);
    STDMETHODIMP NotifyGraphChange();

private:

    CQKsAudIntfHandler             * m_pFilterHandler;
    IPin                           * m_pPin;
    IKsControl                     * m_pKsControl;
    IKsObject                      * m_pKsObject;

    LONG    m_lPinVolume;
    LONG    m_lPinBalance;

};

typedef CGenericList<CQKsAudIntfPinHandler> CPinHandlerList;

//
// Interface Handler class for filter
//
class CQKsAudIntfHandler :
    public CBasicAudio,
    public IAMAudioInputMixer,
    public IAMKsAudIntfHandler,
    public IDistributorNotify,
    public CKsAudHelper
{

friend class CQKsAudIntfPinHandler;

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CQKsAudIntfHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);

    ~CQKsAudIntfHandler();

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);
    
    // Implement our interface IAMKsAudIntfHandler interface
    STDMETHODIMP_(HRESULT) CreatePinHandler(
        LPUNKNOWN UnkOuter,
        CQKsAudIntfPinHandler **ppPinHandler, 
        IPin * pPin);

    HRESULT UpdatePinData(
        BOOL         bConnected,
        IPin *       pPin,
        IKsControl * pKsControl);

    HRESULT GetCapturePin(IPin ** ppPin);

protected:

    // node retrieval helpers
    HRESULT AIMGetDestNode(
        PQKSAUDNODE_ELEM *  ppNode,
        REFCLSID            clsidType,
        ULONG               ulPropertyId );

    HRESULT AIMGetSrcNode(
        PQKSAUDNODE_ELEM *  ppNode,
        IPin *              pPin,
        REFCLSID            clsidType,
        ULONG               ulPropertyId );

    // IDistributorNotify
    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tBase);
    STDMETHODIMP NotifyGraphChange();

    // Implement IBasicAudio
    STDMETHODIMP put_Volume (IN  long   lVolume);
    STDMETHODIMP get_Volume (OUT long *plVolume);
    STDMETHODIMP put_Balance(IN  long   lVolume);
    STDMETHODIMP get_Balance(OUT long *plVolume);

    // Implement IAMAudioInputMixer
    STDMETHODIMP put_Enable(BOOL fEnable);
    STDMETHODIMP get_Enable(BOOL *pfEnable);
    STDMETHODIMP put_Mono(BOOL fMono);
    STDMETHODIMP get_Mono(BOOL *pfMono);
    STDMETHODIMP put_Loudness(BOOL fLoudness);
    STDMETHODIMP get_Loudness(BOOL *pfLoudness);
    STDMETHODIMP put_MixLevel(double Level);
    STDMETHODIMP get_MixLevel(double FAR* pLevel);
    STDMETHODIMP put_Pan(double Pan);
    STDMETHODIMP get_Pan(double FAR* pPan);
    STDMETHODIMP put_Treble(double Treble);
    STDMETHODIMP get_Treble(double FAR* pTreble);
    STDMETHODIMP get_TrebleRange(double FAR* pRange);
    STDMETHODIMP put_Bass(double Bass);
    STDMETHODIMP get_Bass(double FAR* pBass);
    STDMETHODIMP get_BassRange(double FAR* pRange);

    void SetBasicAudDirty() { m_bBasicAudDirty = TRUE; }
    BOOL IsBasicAudDirty()  { return m_bBasicAudDirty; }

private:

    IBaseFilter    * m_pOwningFilter;

    LONG    m_lVolume; 
    LONG    m_lBalance;
    CPinHandlerList m_lstPinHandler;

    BOOL    m_bBasicAudDirty;           // has IBasicAudio called a put_ on this filter?
    BOOL    m_bDoneWithPinAggregation;  // only need to aggregate our pins once per filter

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twavein\resource.h ===
// Resource IDs for Src Test app

#define IDM_DISCONNECT      100
#define IDM_CONNECT         101
#define IDM_STOP            102
#define IDM_PAUSE           104
#define IDM_RUN             105
#define IDM_TRANSFORM       106
#define IDM_CLEARLOG        107

#define IDM_EXIT            110

#define ID_LISTBOX          300


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twavein\makefile.inc ===
# NTTARGETFILES targets

# Browse data for the app

SHELLDIR=$(SHELLTREE)\src\obj\$(TARGET_DIRECTORY)

SBRS=obj\$(TARGET_DIRECTORY)\sink.sbr     \
     obj\$(TARGET_DIRECTORY)\twavein.sbr  \
     obj\$(TARGET_DIRECTORY)\tests.sbr    \
     $(SHELLDIR)\tslog.sbr                \
     $(SHELLDIR)\tsrunset.sbr             \
     $(SHELLDIR)\tsseltst.sbr             \
     $(SHELLDIR)\tssetpth.sbr             \
     $(SHELLDIR)\tsstats.sbr              \
     $(SHELLDIR)\tsstep.sbr               \
     $(SHELLDIR)\tsmain.sbr               \
     $(SHELLDIR)\wpf.sbr                  \
     $(SHELLDIR)\toolbar.sbr              \
     $(SHELLDIR)\text.sbr

BSCMAKETMP=$(SHELLDIR)\bscmake.tmp

# Uncomment this block of code to build the browse file.

#$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).bsc: $(SBRS)
#    md $(BSCMAKETMP)
#    copy $(SHELLDIR)\*.sbr $(BSCMAKETMP)
#    bscmake /o $@ $**
#    copy $(BSCMAKETMP)\*.sbr $(SHELLDIR)
#    deltree /y $(BSCMAKETMP)


# Test shell help file

$(TARGETPATH)\$(TARGET_DIRECTORY)\tstshell.hlp:
    copy $(SHELLTREE)\src\help\tstshell.hlp $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\qksaud\qksaud.cpp ===
//--------------------------------------------------------------------------;
//
//  File: QKsPAud.cpp
//
//  Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//      Implements a DirectShow audio interface wrapper for KsProxy audio filters.
//      This file contains the startup code for the class plus the non interface-specific
//      code needed to implement the wrapper. This handler object code 
//      is instantiated via ksproxy's handler mechanism for ks filters and pins 
//      that support the property sets tagged in the g_Templates structure.
//      
//  History:
//      10/05/98    msavage     created
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "ksaudtop.h"
#include "qksaud.h"
#include "audpropi.h"
#include <initguid.h>

//
// GUID for this KsBasicAudioIntfHandler object
// {B9F8AC2E-0F71-11d2-B72C-00C04FB6BD3D}
//DEFINE_GUID(CLSID_QKsAudIntfHandler, 
//0xb9f8ac2e, 0xf71, 0x11d2, 0xb7, 0x2c, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d);

#ifdef FILTER_DLL
//--------------------------------------------------------------------------;
//
// templates for classes supported by this DLL
//
//--------------------------------------------------------------------------;
CFactoryTemplate g_Templates[] = 
{
    // Load for filters that support the SysAudio prop set
    {L"QKsAudIntfHandler",                   &KSPROPSETID_Sysaudio, 
        CQKsAudIntfHandler::CreateInstance, NULL, NULL},

    // Load for all connected pins that support the Audio prop set
    {L"QKsAudioIntfHandler",                   &KSPROPSETID_Audio, 
        CQKsAudIntfHandler::CreateInstance, NULL, NULL},

    // --- Data handlers ---
// none for now    
//    {L"KsDataTypeHandlerAudio",             &FORMAT_WaveFormatEx,  
//        CAudio1DataTypeHandler::CreateInstance, NULL, NULL}

    // --- Property page handlers ---
    {L"QKs AudioInputMixer Property Page",      &CLSID_AudioInputMixerProperties, 
        CAudioInputMixerProperties::CreateInstance}

};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);

#endif

//--------------------------------------------------------------------------;
//
// CQKsAudInftHandler::CreateInstance
//
// Create an instance of this audio interface handler for KsProxy.
//
// Returns a pointer to the non-delegating CUnknown portion of the object.
//
//--------------------------------------------------------------------------;
CUnknown* CALLBACK CQKsAudIntfHandler::CreateInstance
(
    LPUNKNOWN   UnkOuter,
    HRESULT*    phr
)
{
    CUnknown *Unknown = NULL;

    if( !UnkOuter )
        return NULL;
        
    if( SUCCEEDED( *phr ) ) 
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT( "CQKsAudIntfHandler::CreateInstance called on object 0x%08lx" )
                , UnkOuter ) );
        //
        // first determine if we're being called for a filter or pin object
        //
        IBaseFilter * pFilter;
        *phr = UnkOuter->QueryInterface(
                                IID_IBaseFilter, 
                                reinterpret_cast<PVOID*>(&pFilter));
        if (SUCCEEDED( *phr ) )
        {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "CQKsAudIntfHandler: load called on filter object" ) ) );
            //
            // if we're being called on a filter object, always create a new handler
            //
            Unknown = new CQKsAudIntfHandler( UnkOuter
                                            , NAME("QKsAud intf handler")
                                            , phr);
            if (!Unknown) {
                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_FAILURES
                        , TEXT( "CQKsAudIntfHandler: ERROR - Load failed on filter object" ) ) );
                *phr = E_OUTOFMEMORY;
            }
            pFilter->Release();
        }
        else
        {
            //
            // if this is a pin object then find the corresponding filter object
            // (which will already have been created) and create a new pin handler
            // object on the filter handler
            //
            IPin * pPin;
            
            *phr = UnkOuter->QueryInterface(
                                    IID_IPin, 
                                    reinterpret_cast<PVOID*>(&pPin));
            if (SUCCEEDED( *phr ) )
            {
                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_DETAILS
                        , TEXT( "CQKsAudIntfHandler: load called on pin object" ) ) );
                PIN_DIRECTION dir;
                *phr = pPin->QueryDirection( &dir );
                if( SUCCEEDED( *phr ) && PINDIR_INPUT == dir)
                {
                    //
                    // Have the i/f handler for this pin's filter load a handler
                    // for this pin. We do this by querying the pin's filter 
                    // for its IAMKsAudInftHandler i/f and calling the
                    // CreatePinHandler method on that.
                    //
                    PIN_INFO pinfo;
                    
                    *phr = pPin->QueryPinInfo( &pinfo );
                    ASSERT( SUCCEEDED( *phr ) );
                    if( SUCCEEDED( *phr ) )
                    {
                        DbgLog( ( LOG_TRACE
                                , DBG_LEVEL_TRACE_DETAILS
                                , TEXT( "CQKsAudIntfHandler: Preparing to load a pin handler for this input pin" ) ) );

                        IAMKsAudIntfHandler * pIntfHandler;
                        *phr = pinfo.pFilter->QueryInterface( __uuidof( IAMKsAudIntfHandler )
                                                            , reinterpret_cast<PVOID*>(&pIntfHandler) );
                        ASSERT( SUCCEEDED( *phr ) );                                                            
                        if( SUCCEEDED( *phr ) )
                        {
                            CQKsAudIntfPinHandler * pPinHandler;
                            
                            *phr = pIntfHandler->CreatePinHandler( UnkOuter, &pPinHandler, pPin );
                            ASSERT( SUCCEEDED( *phr ) );
                            if( SUCCEEDED( *phr ) )
                            {
                                DbgLog( ( LOG_TRACE
                                        , DBG_LEVEL_TRACE_DETAILS
                                        , TEXT( "CQKsAudIntfHandler: Successfully loaded a pin handler for this input pin" ) ) );
                                Unknown = (CUnknown *) pPinHandler;
                            }
                            else
                            {
                                DbgLog( ( LOG_TRACE
                                        , DBG_LEVEL_TRACE_FAILURES
                                        , TEXT( "CQKsAudIntfHandler: ERROR - Failed to load a pin handler for this input pin[0x08%lx]" ) 
                                        , *phr ) );
                            }                            
                            pIntfHandler->Release();
                        }
                        pinfo.pFilter->Release();
                    }
                }
                pPin->Release();
            }
        }
    }
    else
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "CQKsAudIntfHandler::CreateInstance called on NULL object" ) ) );
        *phr = E_FAIL;
    }
    
    return Unknown;
} 

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// Filter Handler methods
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// CQKsAudInftHandler::CQKsAudIntfHandler
//
// The constructor for the DShow/KsProxy audio interface object. Save off 
// the IKsControl & IKsPropertySet ptrs for this object.
//
//--------------------------------------------------------------------------;
CQKsAudIntfHandler::CQKsAudIntfHandler(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    phr
    ) :
    CBasicAudio(Name, UnkOuter),
    CKsAudHelper(),
    m_pOwningFilter( NULL ),
    m_bDoneWithPinAggregation( FALSE ),
    m_lstPinHandler( NAME("CQKsAudIntfPinHandler list") ),
    m_lBalance( 0 ),
    m_bBasicAudDirty( FALSE )
{
    if (UnkOuter) 
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT( "CQKsAudIntfHandler constructor called on object 0x%08lx" )
                , UnkOuter ) );
        
        if (SUCCEEDED(*phr)) {
            *phr = UnkOuter->QueryInterface(
                                __uuidof(IKsPropertySet), 
                                reinterpret_cast<PVOID*>(&m_pKsPropSet));
        }   
        
        if (SUCCEEDED(*phr)) {
            *phr = UnkOuter->QueryInterface(
                                __uuidof(IKsControl), 
                                reinterpret_cast<PVOID*>(&m_pKsControl));
        }

        if (SUCCEEDED(*phr)) {
            *phr = UnkOuter->QueryInterface(
                                IID_IBaseFilter, 
                                reinterpret_cast<PVOID*>(&m_pOwningFilter));
        }
           
        // Assumption: We need to immediately release this to prevent deadlock in the proxy
        if (m_pKsPropSet)
            m_pKsPropSet->Release();
            
        if (m_pKsControl)
            m_pKsControl->Release();
            
        if (m_pOwningFilter)
            m_pOwningFilter->Release();
        
    } 
    else 
    {
        *phr = VFW_E_NEED_OWNER;
    }
}

//--------------------------------------------------------------------------;
//
// CQKsAudInftHandler::~CQKsAudIntfHandler
//
//--------------------------------------------------------------------------;
CQKsAudIntfHandler::~CQKsAudIntfHandler()
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT( "CQKsAudIntfHandler destructor called" ) ) ); // save off constructor UnkOuter for logging?
            
    POSITION Position = m_lstPinHandler.GetHeadPosition(); 
    while( Position != NULL)
    {
        POSITION delPosition = Position;
        CQKsAudIntfPinHandler * pPinHandler = m_lstPinHandler.GetNext( Position );

        m_lstPinHandler.Remove( delPosition );
    }        
}

//--------------------------------------------------------------------------;
//
// CQKsAudInftHandler::NonDelegationQueryInterface
//
// We support:
// 
// IBasicAudio         - basic output audio level and pan control, supported on filter and midi/wav audio input pins
// IAMAudioInputMixer  - input line control for audio capture, supported on filter and control input pin
// IDistributorNotify  - this is how ksproxy notifies of changes like pin creation, disconnects...
// IAMKsAudIntfHandler - exposed by this object for pin handler creation on a filter handler
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfHandler::NonDelegatingQueryInterface
(
    REFIID  riid,
    PVOID*  ppv
)
{
    if (riid ==  IID_IBasicAudio) {
        return GetInterface(static_cast<IBasicAudio*>(this), ppv);
    }
    else if (riid == IID_IAMAudioInputMixer) {
        return GetInterface(static_cast<IAMAudioInputMixer*>(this), ppv);
    }
    else if (riid == __uuidof( IAMKsAudIntfHandler ) ) {
        return GetInterface(static_cast<IAMKsAudIntfHandler*>(this), ppv);
    }
    else if (riid == IID_IDistributorNotify) {
        return GetInterface(static_cast<IDistributorNotify*>(this), ppv);
    }
    
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


//--------------------------------------------------------------------------;
//
// IDistributorNotify methods (filter)
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::SetSyncSouce
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfHandler::SetSyncSource(IReferenceClock *pClock) 
{
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::Stop
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfHandler::Stop() 
{
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::Pause
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfHandler::Pause() 
{
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::Run
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfHandler::Run(REFERENCE_TIME tBase) 
{
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::NotifyGraphChange 
//
// This method will be called:
//
//  a) On the initial load of a ksproxy audio filter just after the filter pins have been
//     created. This will allow us to load a pin interface handler for any control input
//     pins that the filter supports, the cd audio, mic, and line input lines for example.
//     Pins of this type must support the IAMAudioInputMixer interface to allow DShow capture
//     apps to control the input mix level.
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfHandler::NotifyGraphChange() 
{
    ASSERT( m_pOwningFilter );
    
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT( "Entering CQKsAudIntfHandler::NotifyGraphChange" ) ) );
    
    HRESULT hr = S_OK;    
    if( !m_bDoneWithPinAggregation )
    {
        m_bDoneWithPinAggregation = TRUE;
        
        // only need to do this once per filter
        IKsAggregateControl * pFilterKsAggControl;
        hr = m_pOwningFilter->QueryInterface( __uuidof( IKsAggregateControl )
                                            , reinterpret_cast<PVOID*>(&pFilterKsAggControl));
        if( SUCCEEDED( hr ) )
        {
            IEnumPins * pEnum;
            hr = m_pOwningFilter->EnumPins( &pEnum );
            if( SUCCEEDED( hr ) )
            {
                for( ; ; )
                {
                    IPin * pPin;
                    ULONG  ul;
                    
                    hr = pEnum->Next(1,  &pPin, &ul );
                    if( S_OK == hr )
                    {
                        PIN_DIRECTION dir;
                        hr = pPin->QueryDirection( &dir );
                        if( SUCCEEDED( hr ) && PINDIR_INPUT == dir)
                        {
                            //
                            // look for input pins on which to load the
                            // IAMAudioInputMixer interface handler
                            //
                            
                            // Get the PinFactoryID
                            ULONG PinFactoryID;
                            if (SUCCEEDED(hr = PinFactoryIDFromPin( pPin, &PinFactoryID))) 
                            {                            
                                PIN_INFO pinfo;
                                
                                hr = pPin->QueryPinInfo( &pinfo );
                                if( SUCCEEDED( hr ) )
                                {
                                    DbgLog( ( LOG_TRACE
                                            , DBG_LEVEL_TRACE_DETAILS
                                            , TEXT("CQKsAudIntfHandler: Checking whether to aggregate on Input pin %ls")
                                            , pinfo.achName ) );    
                                    //
                                    // Retrieve the category of this pin 
                                    //
                                    KSP_PIN Property;
                    
                                    ZeroMemory( &Property, sizeof( Property ) );
                                    Property.PinId = PinFactoryID;
                                    ULONG ulBytesReturned = 0;
                                    GUID NodeType;
                                    
                                    hr = m_pKsPropSet->Get( KSPROPSETID_Pin
                                                 , KSPROPERTY_PIN_CATEGORY
                                                 , &Property.PinId
                                                 , sizeof( Property ) - sizeof( Property.Property )
                                                 , (BYTE *) &NodeType
                                                 , sizeof( NodeType )
                                                 , &ulBytesReturned );
                                    if( IsEqualGUID( NodeType, KSNODETYPE_CD_PLAYER )      ||
                                        IsEqualGUID( NodeType, KSNODETYPE_MICROPHONE )     ||
                                        IsEqualGUID( NodeType, KSNODETYPE_LINE_CONNECTOR ) ||
                                        IsEqualGUID( NodeType, KSNODETYPE_SYNTHESIZER )    ||
                                        IsEqualGUID( NodeType, KSNODETYPE_MICROPHONE ) )
                                    {
                                        IKsAggregateControl * pPinKsAggControl;
                                        hr = pPin->QueryInterface( __uuidof( IKsAggregateControl )
                                                                 , reinterpret_cast<PVOID*>(&pPinKsAggControl));
                                        if( SUCCEEDED( hr ) )
                                        {
                                            // add support for the IAMAudioInputMixer prop page
                                            
                                            // use the Sysaudio propset for now
                                            hr = pPinKsAggControl->KsAddAggregate( KSPROPSETID_Sysaudio );
                                            if( SUCCEEDED( hr ) )
                                            {
                                                DbgLog( ( LOG_TRACE
                                                        , DBG_LEVEL_TRACE_FAILURES
                                                        , TEXT("Added aggregate for pin %ls")
                                                        , pinfo.achName));    
                                            }
                                            pPinKsAggControl->Release();
                                        }
                                    }
                                    pinfo.pFilter->Release();
                                }
                                else
                                    DbgLog( ( LOG_TRACE
                                            , DBG_LEVEL_TRACE_FAILURES
                                            , TEXT("QKSPAudIntfHandler::NotifyGraphChange ERROR: QueryPinInfo failed [0x%08lx")
                                            , hr));    
                                
                            }
                            else
                            {
                                ASSERT( FALSE ); //PinFactoryFromID failed
                                DbgLog( ( LOG_TRACE
                                        , DBG_LEVEL_TRACE_FAILURES
                                        , TEXT("QKSPAudIntfHandler::NotifyGraphChange ERROR: PinFactoryFromID failed [0x%08lx]")
                                        , hr));    
                            }
                        }
                        pPin->Release();
                    }
					else
						break;
                }
                pEnum->Release();
            }
            pFilterKsAggControl->Release();
        }
    }
                                
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// IAMKsAudIntfHandler methods (internal interface)
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::CreatePinHandler
//
// This method creates a new handler object for a pin on the main filter object. Making it
// a child of the main filter handler means that it can share the same cached node topology 
// code.
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfHandler::CreatePinHandler
( 
    LPUNKNOWN             UnkOuter,
    CQKsAudIntfPinHandler **ppPinHandler,
    IPin                   *pPin
)
{
    ASSERT( ppPinHandler );

    HRESULT hr = S_OK;
#if 0    
/// !!! FOR TESTING ONLY - 

    hr = InitTopologyInfo();
    ASSERT( SUCCEEDED( hr ) );
#endif
    
    *ppPinHandler = new CQKsAudIntfPinHandler( UnkOuter
                                             , this
                                             , NAME("Pin Handler")
                                             , pPin
                                             , &hr ); 
    if( !*ppPinHandler )
        return E_OUTOFMEMORY;
        
    m_lstPinHandler.AddTail( *ppPinHandler );
            
    return hr;
}


//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::UpdatePinData
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::UpdatePinData
(
    BOOL         bConnected,
    IPin *       pPin,
    IKsControl * pKsControl
)
{
    PQKSAUDNODE_ELEM pNode;
    HRESULT hr = S_OK;
    
    if( bConnected )
    {
        // transfer any filter settings to this pin line
        if( IsBasicAudDirty() )
        {
            hr = GetNextNodeFromSrcPin( pKsControl, &pNode, pPin, KSNODETYPE_VOLUME, NULL, 0 );
            if (SUCCEEDED( hr ) )
            {
                // now scale the volume for the ksproperty
                hr = SetNodeVolume( pKsControl, pNode, m_lVolume, m_lBalance );
                if (SUCCEEDED(hr))
                {
                    DbgLog( ( LOG_TRACE
                            , DBG_LEVEL_TRACE_DETAILS
                            , TEXT( "Node Volume set = %ld" )
                            , m_lVolume ) );
                }
                else
                    DbgLog( ( LOG_TRACE
                            , DBG_LEVEL_TRACE_FAILURES
                            , TEXT( "SetNodeVolume failed[0x%lx]" )
                            , hr ) );
            }
        }        
    }
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfHandler::GetCapturePin
//
// Find the audio capture output pin on this ksproxy filter.
//
//--------------------------------------------------------------------------;
HRESULT CQKsAudIntfHandler::GetCapturePin(IPin ** ppPin) 
{
    ASSERT( m_pOwningFilter );
    if( !ppPin )
        return E_POINTER;
        
    IEnumPins * pEnum;
    BOOL bFound = FALSE;
    *ppPin = NULL;
    
    HRESULT hr = m_pOwningFilter->EnumPins( &pEnum );
    if( SUCCEEDED( hr ) )
    {
        for( ; !bFound ; )
        {
            IPin * pPin;
            ULONG  ul;
            
            hr = pEnum->Next(1,  &pPin, &ul );
            if( S_OK == hr ) 
            {
                PIN_DIRECTION dir;
                GUID clsidPinCategory;
                ULONG ulBytesReturned;
                
                hr = pPin->QueryDirection( &dir );
                if( SUCCEEDED( hr ) && PINDIR_OUTPUT == dir)
                {
                    IKsPropertySet * pKs;
                    if (pPin->QueryInterface( IID_IKsPropertySet
                                            , (void **)&pKs) == S_OK) 
                    {
                        hr = pKs->Get( AMPROPSETID_Pin
                                     , AMPROPERTY_PIN_CATEGORY
                                     , NULL
                                     , 0
                                     , &clsidPinCategory
                                     , sizeof( clsidPinCategory )
                                     , &ulBytesReturned );
                        if( SUCCEEDED( hr ) && 
                            ( clsidPinCategory == PIN_CATEGORY_CAPTURE ) )
                        {
                            *ppPin = pPin; // should be ok to release this since we're aggregated?
                            bFound = TRUE;
                        }
                        pKs->Release();
                    }                        
                }
                pPin->Release();
            }
            else
                break;
        }
        pEnum->Release();
    }
    if( ( S_FALSE == hr ) || !bFound )
        return E_FAIL;
    else
        return hr;        
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// Pin Handler methods
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::CQKsAudIntfPinHandler
//
//--------------------------------------------------------------------------;
CQKsAudIntfPinHandler::CQKsAudIntfPinHandler(
    LPUNKNOWN   UnkOuter,
    CQKsAudIntfHandler * pFilterHandler,
    TCHAR*      Name,
    IPin*       pPin,
    HRESULT*    phr
    ) :
    CBasicAudio(Name, UnkOuter),
    m_pFilterHandler( pFilterHandler ),
    m_pPin( pPin ),
    m_lPinBalance( 0 ),
    m_lPinVolume( 0 )
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT( "Entering CQKsAudIntfPinHandler constructor" ) ) );

    HRESULT hr = UnkOuter->QueryInterface(
                      __uuidof(IKsObject), 
                      reinterpret_cast<PVOID*>(&m_pKsObject));
    ASSERT( SUCCEEDED( hr ) );
    if( SUCCEEDED( hr ) )
        m_pKsObject->Release();
    
    // initialize the IKsControl interface for this object
    hr = m_pKsObject->QueryInterface(
                      __uuidof(IKsControl), 
                      reinterpret_cast<PVOID*>(&m_pKsControl));
    ASSERT( SUCCEEDED( hr ) );
    if( SUCCEEDED( hr ) )
        // we must release this immediately, correct?
        m_pKsControl->Release();
    
    if( IsKsPinConnected() )
    {
        // we've been connected, update node settings for this pin line if they're dirty
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT( "CQKsAudIntfPinHandler constructor - pin connected" ) ) );
        
        m_pFilterHandler->UpdatePinData( TRUE, m_pPin, m_pKsControl );
    }
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::~CQKsAudIntfPinHandler
//
//--------------------------------------------------------------------------;
CQKsAudIntfPinHandler::~CQKsAudIntfPinHandler()
{
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::NonDelegatingQueryInterface
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfPinHandler::NonDelegatingQueryInterface
(
    REFIID  riid,
    PVOID*  ppv
)
{
    if (riid == IID_IDistributorNotify) {
        return GetInterface(static_cast<IDistributorNotify*>(this), ppv);
    }
    else if (riid ==  IID_IBasicAudio) {
        return GetInterface(static_cast<IBasicAudio*>(this), ppv);
    }
    else if (riid == IID_IAMAudioInputMixer) {
        return GetInterface(static_cast<IAMAudioInputMixer*>(this), ppv);
    }
    
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 

//--------------------------------------------------------------------------;
//
// IDistributorNotify methods (pin)
//
//--------------------------------------------------------------------------;


//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::SetSyncSource
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfPinHandler::SetSyncSource(IReferenceClock *pClock) 
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT( "Entering CQKsAudIntfPinHandler::SetSyncSource" ) ) );
    HRESULT hr = S_OK;

    return hr;
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::Stop
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfPinHandler::Stop() 
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT( "Entering CQKsAudIntfPinHandler::Stop" ) ) );
    HRESULT hr = S_OK;

    return hr;
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::Pause
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfPinHandler::Pause() 
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT( "Entering CQKsAudIntfPinHandler::Pause" ) ) );
    HRESULT hr = S_OK;

    return hr;
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::Run
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfPinHandler::Run(REFERENCE_TIME tBase) 
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT( "Entering CQKsAudIntfPinHandler::Run" ) ) );
    HRESULT hr = S_OK;

    return hr;
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::NotifyGraphChange
//
//--------------------------------------------------------------------------;
STDMETHODIMP CQKsAudIntfPinHandler::NotifyGraphChange() 
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT( "Entering CQKsAudIntfPinHandler::NotifyGraphChange" ) ) );
    
    // Either we're being connected or disconnected so we need to check
    HANDLE hPin = m_pKsObject->KsGetObjectHandle();
    if( hPin )
    {
        // we've been connected, update node settings for this pin line
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT( "CQKsAudIntfPinHandler::NotifyGraphChange - pin connected" ) ) );

        m_pFilterHandler->UpdatePinData( TRUE, m_pPin, m_pKsControl );
    }
    else
    {
        // we've been disconnected, so notify parent filter of the change
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT( "CQKsAudIntfPinHandler::NotifyGraphChange - pin disconnected" ) ) );
        
        m_pFilterHandler->UpdatePinData( FALSE, m_pPin, m_pKsControl );
    }        
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CQKsAudIntfPinHandler::IsKsPinConnected
//
// Helper method
//
//--------------------------------------------------------------------------;
BOOL CQKsAudIntfPinHandler::IsKsPinConnected() 
{
    ASSERT( m_pKsObject );
    HANDLE hPin = m_pKsObject->KsGetObjectHandle();
    if( hPin )
        return TRUE;
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twavein\twavein.h ===
/***************************************************************************\
*                                                                           *
*   File: twavein.h                                                         *
*                                                                           *
*   Copyright (c) 1993,1996 Microsoft Corporation.  All rights reserved     *
*                                                                           *
*   Abstract:                                                               *
*       This header file contains various constants and prototypes used     *
*       in the Quartz WaveIn unit test app                                  *
*                                                                           *
*                                                                           *
\***************************************************************************/


// Prototypes

// From twavein.cpp
extern LRESULT FAR PASCAL MenuProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
extern BOOL InitOptionsMenu (LRESULT (CALLBACK* ManuProc)(HWND, UINT, WPARAM, LPARAM));
extern LRESULT FAR PASCAL tstAppWndProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);


// From tests.cpp
extern int expect (UINT uExpected, UINT uActual, LPSTR CaseDesc);
extern int apiToTest (void);
extern int FAR PASCAL execTest1(void);
extern int FAR PASCAL execTest2(void);
extern int FAR PASCAL execTest3(void);
extern int FAR PASCAL execTest4(void);



// Constants

// Stops the logging intensive test
#define VSTOPKEY            VK_SPACE

// The string identifiers for the group's names
#define GRP_SRC             100
#define GRP_TRANSFORM       101
#define GRP_LAST            GRP_TRANSFORM

// The string identifiers for the test's names
#define ID_TEST1           200
#define ID_TEST2           201
#define ID_TEST3           202
#define ID_TEST4           203
#define ID_TESTLAST        ID_TEST4

// The test case identifier (used in the switch statement in execTest)
#define FX_TEST1            300
#define FX_TEST2            301
#define FX_TEST3            302
#define FX_TEST4            303

// Menu identifiers
#define IDM_DISCONNECT      100
#define IDM_CONNECT         101
#define IDM_STOP            102
#define IDM_PAUSE           104
#define IDM_RUN             105
#define IDM_TRANSFORM       106
#define IDM_CLEARLOG        107

// Identifies the test list section of the resource file
#define TEST_LIST           500

// Multiple platform support
#define PLATFORM1           1
#define PLATFORM2           2
#define PLATFORM3           4


// Global variables

extern HWND         ghwndTstShell;  // Handle to test shell main window
extern CTestSink    *gpSink;        // Test sink object for all the tests



/***************************************************************************/
/* debugging stuff */
#ifdef DPF
#undef DPF
#endif
#ifdef DEBUG
   extern void FAR cdecl dprintf(LPSTR szFormat, ...);
   #define DPF     dprintf
#else
   #define DPF     //
#endif
/***************************************************************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twaveout\shell.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
// Wave out test shell, David Maymudes, Sometime in 1996

#include <streams.h>
#include <windows.h>
#include <windowsx.h>
#include <ole2.h>
#include <wxdebug.h>
#include <mmsystem.h>
#include <waveout.h>
#include "twaveout.h"


/* Constructor */

CShell::CShell( LPUNKNOWN pUnk,
                HRESULT *phr)
    : CUnknown(NAME("Audio Renderer test shell"), pUnk)
{
    /* Create the interfaces we own */

    m_pFilter = new CImplFilter( this, phr );
    ASSERT(m_pFilter);

    /* Set a null clock */
    m_pFilter->SetSyncSource(NULL);

    m_pOutputPin = new CImplOutputPin( m_pFilter, this, phr, L"Test Shell Audio Output");
    ASSERT(m_pOutputPin);
}


/* Destructor */

CShell::~CShell()
{
    /* Release the clock if we have one - note that the clock is in the base class */
    m_pFilter->SetSyncSource(NULL);

    /* Delete the interfaces we own
       WARNING: the output pin must be deleted
       before the filter as it may use that filter's critical section */

    ASSERT(m_pOutputPin);
    delete m_pOutputPin;

    ASSERT(m_pFilter);
    delete m_pFilter;
}


/* Override this to say what interfaces we support where */

STDMETHODIMP CShell::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    /* See if we have the interface */

    if (riid == IID_IBaseFilter) {
        return m_pFilter->NonDelegatingQueryInterface(IID_IBaseFilter, ppv);
    } else if (riid == IID_IMediaFilter) {
        return m_pFilter->NonDelegatingQueryInterface(IID_IMediaFilter, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twaveout\makefile.inc ===
# NTTARGETFILES targets

# Browse data for the app

SHELLDIR=$(SHELLTREE)\src\obj\$(TARGET_DIRECTORY)

SBRS=obj\$(TARGET_DIRECTORY)\tests.sbr   \
     obj\$(TARGET_DIRECTORY)\image.sbr   \
     obj\$(TARGET_DIRECTORY)\shell.sbr   \
     obj\$(TARGET_DIRECTORY)\filter.sbr  \
     obj\$(TARGET_DIRECTORY)\pin.sbr     \
     $(SHELLDIR)\tslog.sbr               \
     $(SHELLDIR)\tsrunset.sbr            \
     $(SHELLDIR)\tsseltst.sbr            \
     $(SHELLDIR)\tssetpth.sbr            \
     $(SHELLDIR)\tsstats.sbr             \
     $(SHELLDIR)\tsstep.sbr              \
     $(SHELLDIR)\tsmain.sbr              \
     $(SHELLDIR)\wpf.sbr                 \
     $(SHELLDIR)\toolbar.sbr             \
     $(SHELLDIR)\text.sbr

BSCMAKETMP=$(SHELLDIR)\bscmake.tmp

# Build the browse file

$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).bsc: $(SBRS)
    md $(BSCMAKETMP)
    copy $(SHELLDIR)\*.sbr $(BSCMAKETMP)
    bscmake /o $@ $**
    copy $(BSCMAKETMP)\*.sbr $(SHELLDIR)
    deltree /y $(BSCMAKETMP)


# Test shell help file

$(TARGETPATH)\$(TARGET_DIRECTORY)\tstshell.hlp:
    copy $(SHELLTREE)\src\help\tstshell.hlp $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twavein\tests.cpp ===
//--------------------------------------------------------------------------;
//
//  File: Tests.cpp
//
//  Copyright (c) 1993,1996 Microsoft Corporation.  All rights reserved
//
//  Abstract:
//      The test functions for the Quartz WaveIn filter unit test.
//
//  Contents:
//      apiToTest()
//      execTest1()
//      execTest2()
//      expect()
//--------------------------------------------------------------------------;

#include <streams.h>    // Streams architecture
#include <tstshell.h>   // Include file for the test shell's APIs
#include "sink.h"       // Test sink definition
#include "twavein.h"    // Various includes, constants, prototypes, globals


//--------------------------------------------------------------------------;
//
//  void YieldAndSleep
//
//  Description:
//      Sleep using tstWinYield to allow other threads to log messages
//      in the main window.
//
//  Arguments:
//      DWORD  cMilliseconds:   sleep time in milliseconds
//
//  Return:
//      None.
//
//  History:
//      9-Mar-95    v-mikere
//
//--------------------------------------------------------------------------;

void FAR PASCAL YieldAndSleep
(
    DWORD  cMilliseconds                // sleep time in milliseconds
)
{
    DWORD   dwEndTime = GetTickCount() + cMilliseconds;
    DWORD   dwCurrentTime = GetTickCount();

    while
    (
        WAIT_TIMEOUT != MsgWaitForMultipleObjects(0,
                                                  NULL,
                                                  FALSE,
                                                  dwEndTime - dwCurrentTime,
                                                  QS_ALLINPUT)
    )
    {
        tstWinYield();
        if ((dwCurrentTime = GetTickCount()) >= dwEndTime)
        {
            return;
        }
    }
}


//--------------------------------------------------------------------------;
//
//  int execTest1
//
//  Description:
//      Test 1, connect and disconnect source
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

int FAR PASCAL execTest1(void) {

    TESTRES result = TST_FAIL;                     // The result of the test

    tstLog (TERSE, "Entering test #1");
    tstLogFlush();

    result = gpSink->TestConnect();
    if (result==TST_PASS)
        result = gpSink->TestDisconnect();

    tstLog (TERSE, "Exiting test #1");
    tstLogFlush();

    return result;
} // execTest1()



//--------------------------------------------------------------------------;
//
//  int execTest2
//
//  Description:
//      Test 2, connect source, pause and disconnect
//
//  Arguments:
//      None.
//
//  Return (int): TST_FAIL indicating failure
//--------------------------------------------------------------------------;

int FAR PASCAL execTest2 (void) {

    int         result;                     // The result of the test

    tstLog (TERSE, "Entering test #2");
    tstLogFlush();

    result = gpSink->TestConnect();

    if (result == TST_PASS) {
        tstBeginSection("Pause");
        result = gpSink->TestPause();
        YieldAndSleep(5000);               // Crude wait for video clip to play - do I need this?
        tstEndSection();
    }
    if (result==TST_PASS) {
        result = gpSink->TestDisconnect();
    }

    tstLog (TERSE, "Exiting test #2");
    tstLogFlush();
    return result;
} // execTest2()


//--------------------------------------------------------------------------;
//
//  int execTest3
//
//  Description:
//      Test 3, connect source, run, stop and disconnect
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//--------------------------------------------------------------------------;

int FAR PASCAL execTest3 (void) {

    int         result;                     // The result of the test

    tstLog (TERSE, "Entering test #3");
    tstLogFlush();

    result = gpSink->TestConnect();

    if (result == TST_PASS) {
        result = gpSink->TestRun();
        YieldAndSleep(15000);               // Crude wait for video clip to play
    }
    if (result == TST_PASS) {
        result = gpSink->TestStop();
    }
    if (result == TST_PASS) {
        result = gpSink->TestDisconnect();
    }

    tstLog (TERSE, "Exiting test #3");
    tstLogFlush();
    return result;
} // execTest3()


//--------------------------------------------------------------------------;
//
//  int execTest4
//
//  Description:
//      Test 4, connect source, run, pause, run, pause, stop and disconnect
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//--------------------------------------------------------------------------;
int FAR PASCAL execTest4 (void) {

    int         result;                     // The result of the test

    tstLog (TERSE, "Entering test #4");
    tstLogFlush();

    result = gpSink->TestConnect();

    if (result == TST_PASS) {
        result = gpSink->TestRun();
        YieldAndSleep(15000);               // Crude wait for video clip to play
    }
    if (result == TST_PASS) {
        result = gpSink->TestPause();
    }
    if (result == TST_PASS) {
        result = gpSink->TestRun();
        YieldAndSleep(15000);               // Crude wait for video clip to play
    }
    if (result == TST_PASS) {
        result = gpSink->TestPause();
    }
    if (result == TST_PASS) {
        result = gpSink->TestStop();
    }
    if (result == TST_PASS) {
        result = gpSink->TestDisconnect();
    }

    tstLog (TERSE, "Exiting test #4");
    tstLogFlush();
    return result;
} // execTest4()



//--------------------------------------------------------------------------;
//
//  int expect
//
//  Description:
//      Compares the expected result to the actual result.  Note that this
//      function is not at all necessary; rather, it is a convenient
//      method of saving typing time and standardizing output.  As an input,
//      you give it an expected value and an actual value, which are
//      unsigned integers in our example.  It compares them and returns
//      TST_PASS indicating that the test was passed if they are equal, and
//      TST_FAIL indicating that the test was failed if they are not equal.
//      Note that the two inputs need not be integers.  In fact, if you get
//      strings back, you can modify the function to use lstrcmp to compare
//      them, for example.  This function is NOT to be copied to a test
//      application.  Rather, it should serve as a model of construction to
//      similar functions better suited for the specific application in hand
//
//  Arguments:
//      UINT uExpected: The expected value
//
//      UINT uActual: The actual value
//
//      LPSTR CaseDesc: A description of the test case
//
//  Return (int): TST_PASS if the expected value is the same as the actual
//      value and TST_FAIL otherwise
//                                                                          *   History:
//      06/08/93    T-OriG (based on code by Fwong)
//
//--------------------------------------------------------------------------;

int expect
(
    UINT    uExpected,
    UINT    uActual,
    LPSTR   CaseDesc
)
{
    if(uExpected == uActual)
    {
        tstLog(TERSE, "PASS : %s",CaseDesc);
        return(TST_PASS);
    }
    else
    {
        tstLog(TERSE,"FAIL : %s",CaseDesc);
        return(TST_FAIL);
    }
} // Expect()

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twaveout\twaveout.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
// Wave out test shell, David Maymudes, Sometime in 1995

#include <streams.h>
#include <windowsx.h>
#include <vfw.h>
#include <stdio.h>
#include <limits.h>
#include <tstshell.h>
#include <initguid.h>
#include <waveout.h>
#include <tchar.h>
#include <decibels.h>
#include "twaveout.h"

HWND ghwndTstShell;     // A handle to the main window of the test shell.
HINSTANCE hinst;        // Running instance of the test shell
HMENU hConnectionMenu;  // Handle to the connection ("Type") pop-up
HMENU hAudioMenu;       // Handle to the audio pop-up

#ifdef _WIN32
LPTSTR szAppName = TEXT("Quartz audio renderer tests - Win32");
#else
LPTSTR szAppName = TEXT("Quartz audio renderer tests - Motown");
#endif

UINT   uiAudioChoice = 0;
CRefTime cWaveLength;
static TCHAR *pAudioFileNames[] = { TEXT("8M11.WAV"),
				    TEXT("8M22.WAV"),
				    TEXT("16M11.WAV")
				  };

CShell *pShell = NULL;                  // Pointer to shell object
WAVEFORMATEX g_wfx;                     // Header from loaded WAV
BYTE bData[ MAX_SAMPLE_SIZE ];          // Audio buffer
DWORD cbData;                           // size of audio
BOOL bConnected = FALSE;                // Have we connected them
BOOL bCreated = FALSE;                  // have the objects been created
BOOL bRunning = FALSE;                  // Are we pushing samples
HANDLE hWorkerThread;                   // Handle to the worker thread
DWORD dwThreadID;                       // Thread ID for worker thread
HANDLE hState;                          // Signal the thread to change state
DWORD dwIncrement = 100;                // Period between subsequent samples
TCHAR szInfo[INFO];                     // General string formatting field
UINT uiConnectionType;                  // IDM_WAVEALLOC or IDM_OTHERALLOC
CCritSec CSLog;                         // Thread safe logging access
BOOL bStateChanging = FALSE;            // Is the state being changed

/* Interfaces we hold on the objects */

PPIN pOutputPin;                        // Pin provided by the shell object
PPIN pInputPin;                         // Pin to connect with in the renderer
PFILTER pRenderFilter;                  // The renderer IBaseFilter interface
PFILTER pShellFilter;                   // The shell IBaseFilter interface
CBasicAudio* pIBasicAudio;
PMEDIAFILTER pRenderMedia;              // The renderer IMediaFilter interface
PMEDIAFILTER pShellMedia;               // The shell IMediaFilter interface
CRefTime gtBase;                        // Time when we started running
CRefTime gtPausedAt;                    // This was the time we paused
IReferenceClock *pClock;                // Reference clock


//--------------------------------------------------------------------------
//
//  int tstGetTestInfo
//
//  Description:
//      Called by the test shell to get information about the test. Also
//      saves a copy of the running instance of the test shell.
//
//      We also initialise custom profile handlers here so that we can set
//      everything up when running automatically from a profile.
//
//  Arguments:
//      HINSTANCE hinstance: A handle to the running instance of the shell
//
//      LPSTR lpszTestName: Pointer to buffer of name for test. Among
//          other things, it is used as a caption for the main window and
//          as the name of its class. Always ANSI.
//
//      LPSTR lpszPathSection: Pointer to buffer of name of section in
//          win.ini in which the default input and output paths are
//          stored. Always ANSI.
//
//      LPWORD wPlatform: The platform on which the tests are to be run,
//          which may be determined dynamically. In order for a test to
//          be shown on the run list, it must have all the bits found in
//          wPlatform turned on. It is enough for one bit to be turned off
//          to disqualify the test. This also means that if this value is
//          zero, all tests will be run. In order to make this more
//          mathematically precise, I shall give the relation which Test
//          Shell uses to decide whether a test with platform flags
//          wTestPlatform may run:  It may run if the following is TRUE:
//          ((wTestPlatform & wPlatform) == wPlatform)
//
//  Return (int):
//      The value which identifies the test list resouce (found in the
//      resource file).
//
//--------------------------------------------------------------------------

int tstGetTestInfo(HINSTANCE hinstance,
		   LPSTR lpszTestName,
		   LPSTR lpszPathSection,
		   LPWORD wPlatform)
{

    // Save a copy of a handle to the running instance
    hinst = hinstance;

    // Install profile handlers for custom data
    tstInstallWriteCustomInfo(SaveCustomProfile);
    tstInstallReadCustomInfo(LoadCustomProfile);

    // Pass app name to test shell

#ifdef UNICODE
    WideCharToMultiByte(CP_ACP,
			0,
			szAppName,
			-1,
			lpszTestName,
			SECTION_LENGTH,
			NULL,
			NULL);

    WideCharToMultiByte(CP_ACP,
			0,
			szAppName,
			-1,
			lpszPathSection,
			SECTION_LENGTH,
			NULL,
			NULL);
#else
    lstrcpy(lpszTestName, szAppName);
    lstrcpy(lpszPathSection, szAppName);
#endif

    *wPlatform = 0;         // The platform the test is running on
    return TEST_LIST;
}


//--------------------------------------------------------------------------
//
//  void InitOptionsMenu
//
//  Description:
//      Creates an additional app-specific menu. Note that this
//      function is called from within tstInit as all menu installations
//      MUST be done in tstInit or else the app's behavior is undefined.
//      Also note the calls to tstInstallCustomTest which is a shell API
//      that allows custom installation of tests. From tstshell version
//      2.0 on, it is possible to install menus the usual way and trap the
//      appropriate window messages, though the method presented here is
//      still the preferred one for Test Applications to use.
//
//      For the Quartz tests, complete menu structures and window procs
//      exist, so it is simpler to just load and append the existing menu
//      resources than to call tstInstallCustomTest once for each menu
//      option. The window message handling is incorporated in
//      tstAppWndProc.
//
//  Arguments:
//      LRESULT (CALLBACK* MenuProc)(HWND,UINT,WPARAM,LPARAM):
//          The menu function (not used in the Quartz tests).
//
//  Return (BOOL):
//      TRUE if menu installation is successful, FALSE otherwise
//
//--------------------------------------------------------------------------

BOOL InitOptionsMenu(
    LRESULT (CALLBACK* MenuProc)(HWND, UINT, WPARAM, LPARAM))
{
    HMENU hTWaveOutMenu;

    if (NULL == (hTWaveOutMenu = LoadMenu(hinst, TEXT("TWaveOutMenu")))) {
	return(FALSE);
    }

    if (!AppendMenu(GetMenu(ghwndTstShell),
		    MF_POPUP,
		    (UINT) hTWaveOutMenu,
		    TEXT("&WaveOut"))) {

	return(FALSE);
    }

    DrawMenuBar(ghwndTstShell);

    // Save handles to audio and connection pop-ups

    hAudioMenu = GetSubMenu(hTWaveOutMenu, AUDIO_MENU_POS);
    ASSERT(hAudioMenu);
    hConnectionMenu = GetSubMenu(hTWaveOutMenu, CONNECTION_MENU_POS);
    ASSERT(hConnectionMenu);

    return TRUE;
}


//--------------------------------------------------------------------------
//
//  BOOL tstInit
//
//  Description:
//      Called by the test shell to provide the test program with an
//      opportunity to do whatever initialization it needs to do before
//      user interaction is initiated. It also provides the test program
//      with an opportunity to keep a copy of a handle to the main window,
//      if the test program needs it. In order to use some of the more
//      advanced features of test shell, several installation must be done
//      here:
//
//      -- All menu installation must be done here by calling
//          tstInstallCustomTest (that is, all menus that the test
//          application wants to add).
//
//      -- If the test application wants to trap the window messages of
//          the main test shell window, it must install its default
//          window procedure here by calling tstInstallDefWindowProc.
//
//      -- If the test application would like to use the status bar for
//          displaying the name of the currently running test, it must
//          call tstDisplayCurrentTest here.
//
//      -- If the test application would like to change the stop key from
//          ESC to something else, it must do so here by calling
//          tstChangeStopVKey.
//
//      -- If the test application would like to add dynamic test cases
//          to the test list, it must first add their names to the
//          virtual string table using tstAddNewString (and add their
//          group's name too), and then add the actual tests using
//          tstAddTestCase. The virtual string table is an abstraction
//          which behaves just like a string table from the outside with
//          the exception that it accepts dynamically added string.
//
//  Arguments:
//      HWND hwndMain: A handle to the main window
//
//  Return (BOOL):
//      TRUE if initialization went well, FALSE otherwise which will abort
//      execution.
//
//--------------------------------------------------------------------------

BOOL tstInit(HWND hwndMain)
{
    QzInitialize(NULL);             // Initialise COM library
    DbgInitialise(hinst);           // Initialise debug library

    // Keep a copy of a handle to the main window
    ghwndTstShell = hwndMain;

    // Installs a default windows procedure which may handle messages
    // directed to Test Shell's main window. It is vital to note that
    // this window function is substituted for DefWindowProc and not in
    // addition to it, and therefore DefWindowProc MUST be called from
    // within it in the default case (look at tstAppWndProc for an example).
    tstInstallDefWindowProc (tstAppWndProc);

    // Install the custom menus. Look at InitOptionsMenu for more details.
    if (InitOptionsMenu(NULL)==FALSE)
	return FALSE;  // If menu installation failed, abort execution

    // Set up the audio test app
    if (InitialiseTest() == FALSE) {
	return FALSE;
    }

    // This is a shell API which tells Test Shell to display the name of
    // the currently executing API in its status bar. It is a really nice
    // feature for test applications which do not use the toolbar for any
    // other purpose as test progress can be easily reported.
    tstDisplayCurrentTest();

    // Change the stop key from ESC to SPACE
    tstChangeStopVKey (VSTOPKEY);
    return(TRUE);
}


//--------------------------------------------------------------------------
//
//  int execTest
//
//  Description:
//      This is the actual test function which is called from within the
//      test shell. It is passed various information about the test case
//      it is asked to run, and branches off to the appropriate test
//      function. Note that it needs not switch on nFxID, but may also
//      use iCase or wID.
//
//  Arguments:
//      int nFxID: The test case identifier, also found in the third column
//          in the third column of the test list in the resource file
//
//      int iCase: The test case's number, which expresses the ordering
//          used by the test shell.
//
//      UINT wID: The test case's string ID, which identifies the string
//          containing the description of the test case. Note that it is
//          also a good candidate for use in the switch statement, as it
//          is unique to each test case.
//
//      UINT wGroupID: The test case's group's string ID, which identifies
//          the string containing the description of the test case's group.
//
//  Return (int): Indicates the result of the test by using TST_FAIL,
//          TST_PASS, TST_OTHER, TST_ABORT, TST_TNYI, TST_TRAN, or TST_TERR
//
//--------------------------------------------------------------------------

typedef int (FAR PASCAL *TestApi)(void);

TestApi TestArray[nTests] = {execTest1, execTest2, execTest3, execTest4, execTest5, execTest6};

int execTest(int nFxID,
	     int iCase,
	     UINT wID,
	     UINT wGroupID)
{
    int ret = TST_OTHER;
    tstBeginSection(" ");

    if ((nFxID >=FX_TESTFIRST) && (nFxID <= FX_TESTLAST)) {
	ret = TestArray[nFxID - FX_TESTFIRST]();
    }

    tstEndSection();
    return(ret);
}


//--------------------------------------------------------------------------
//
//  void tstTerminate
//
//  Description:
//      This function is called when the test series is finished to free
//      structures and do whatever cleanup work it needs to do. If it
//      needs not do anything, it may just return.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//--------------------------------------------------------------------------

void tstTerminate()
{
    /* If we are asked to close we initiate the destruction
       of all the objects that may be currently allocated */

    if (bCreated == TRUE) {
	ReleaseStream();
    }

    DbgTerminate();
    QzUninitialize();
}


//--------------------------------------------------------------------------
//
//  LRESULT tstAppWndProc
//
//  Description:
//      This shows how a test application can trap the window messages
//      received by the main Test Shell window. It is installed in
//      in tstInit by calling tstInstallDefWindowProc, and receives
//      all window messages since. This allows the test application to
//      be notified of certain event via a window without creating its
//      own hidden window or waiting in a tight PeekMessage() loop. Note
//      that it is extremely important to call DefWindowProcA in the default
//      case as that is NOT done in tstshell's main window procedure if
//      tstInstallDefWindowProc is used. DefWindowProcA has to be used
//      as the test shell main window is an ANSI window.
//
//  Arguments:
//      HWND hWnd: A handle to the window
//
//      UINT msg: The message to be processed
//
//      WPARAM wParam: The first parameters, meaning depends on msg
//
//      LPARAM lParam: The second parameter, meaning depends on msg
//
//  Return (LRESULT):
//
//--------------------------------------------------------------------------

LRESULT FAR PASCAL tstAppWndProc(HWND hWnd,
				 UINT msg,
				 WPARAM wParam,
				 LPARAM lParam)
{
    switch (msg)
    {
	case WM_COMMAND:

	    switch (wParam) {

		/* These manage the state changes for the stream and
		   match the IMediaFilter state change methods */

		case IDM_STOP:
		    StopSystem();
		    break;

		case IDM_PAUSE:
		    PauseSystem();
		    break;

		case IDM_RUN:
		    StartSystem();
		    break;

		/* These initialise the filters and their connections */

		case IDM_CREATE:
		    CreateStream();
		    return FALSE;

		case IDM_RELEASE:
		    ReleaseStream();
		    return FALSE;

		case IDM_CONNECT:
		    ConnectStream();
		    return FALSE;

		case IDM_DISCONNECT:
		    DisconnectStream();
		    return FALSE;

		/* Extra debug facilties */

		case IDM_DUMP:
		    DumpTestObjects();
		    return FALSE;

		case IDM_BREAK:
		    DebugBreak();
		    return FALSE;

		/* Change the type of connection we make */

		case IDM_WAVEALLOC:
		case IDM_OTHERALLOC:

		    ChangeConnectionType(wParam);
		    return FALSE;

		/* These change the sound we use for the test */

		case IDM_8M11:
		case IDM_8M22:
		case IDM_16M11:

		    LoadWAV(wParam);
		    return FALSE;
	    }
	    break;
    }
    return DefWindowProcA (hWnd, msg, wParam, lParam);
}


//--------------------------------------------------------------------------
//
//   void SaveCustomProfile
//
//   Description:
//       This function saves custom environment info into a profile. It is
//       installed by calling tstInstallWriteCustomInfo from tstGetTestInfo
//       and is called during normal profile handling in SaveProfile.
//
//       Assumes the profile file was created from scratch by the calling
//       function.
//
//       Custom data for this app:
//           [custom settings]   - section for custom settings
//               TimeIncrement       - value of time increment in ms
//               ConnectionType      - Overlay or Samples
//               BitsPerPixel        - 8, 16 or 24
//
//   Arguments:
//           LPCSTR szProfileName: name of profile file
//
//   Return (void):
//
//--------------------------------------------------------------------------


VOID CALLBACK SaveCustomProfile(LPCSTR pszProfileName)
{
    HANDLE      hProfile;
    TCHAR       szLine[128];
    CHAR        szBuf[128];
    DWORD       dwNumberOfBytesWritten;
    LPCTSTR     tszProfileName;

#ifdef UNICODE
    WCHAR   wszProfileName[128];

    if (!MultiByteToWideChar(CP_ACP,
			     0,
			     pszProfileName,
			     -1,
			     wszProfileName,
			     128)) {

	MessageBox(ghwndTstShell,
		   TEXT("Could not convert profile name to UNICODE"),
		   szAppName,
		   MB_ICONEXCLAMATION | MB_OK);
	return;
    }

    tszProfileName = wszProfileName;
#else
    tszProfileName = pszProfileName;
#endif

    hProfile = CreateFile(tszProfileName,
			  GENERIC_WRITE,
			  0,
			  NULL,
			  OPEN_ALWAYS,
			  FILE_ATTRIBUTE_NORMAL,
			  NULL);

    if (INVALID_HANDLE_VALUE == hProfile)
    {
	wsprintf(szLine, TEXT("Cannot open %s for writing"), tszProfileName);
	MessageBox(ghwndTstShell, szLine, szAppName,MB_ICONEXCLAMATION | MB_OK);
	return;
    }

    if (INFINITE == SetFilePointer(hProfile, 0, NULL, FILE_END))
    {
	wsprintf(szLine, TEXT("Could not seek to end of %s"), tszProfileName);
	MessageBox(ghwndTstShell, szLine, szAppName,MB_ICONEXCLAMATION | MB_OK);
	return;
    }

    wsprintfA(szBuf, "[custom settings]\r\n");
    WriteFile(hProfile, szBuf, lstrlenA(szBuf), &dwNumberOfBytesWritten, NULL);

    wsprintfA(szBuf, "TimeIncrement=%lu\r\n", dwIncrement);
    WriteFile(hProfile, szBuf, lstrlenA(szBuf), &dwNumberOfBytesWritten, NULL);

    wsprintfA(szBuf,
	      "Allocator=%s\r\n",
	      (uiConnectionType == IDM_WAVEALLOC ? "WaveOut" : "Other"));
    WriteFile(hProfile, szBuf, lstrlenA(szBuf), &dwNumberOfBytesWritten, NULL);

    for(UINT ui = IDM_8M11; ui <= IDM_16M11; ui++)
    {
	if (MF_CHECKED & GetMenuState(hAudioMenu, ui, MF_BYCOMMAND)) {
	    break;
	}
    }

    wsprintfA(szBuf,
	      "BitsPerSample=%s\r\n",
	      (ui == IDM_8M11 ? "8" : "16"));

    WriteFile(hProfile, szBuf, lstrlenA(szBuf), &dwNumberOfBytesWritten, NULL);

    CloseHandle(hProfile);

}


//--------------------------------------------------------------------------
//
//   BOOL LoadCustomProfile
//
//   Description:
//       This function loads custom environment info from a profile. It is
//       installed by calling tstInstallReadCustomInfo from tstGetTestInfo,
//       and is called during normal profile handling in LoadProfile.
//
//       Custom data for this app:
//           [custom settings]   - section for custom settings
//               TimeIncrement       - value of time increment in ms
//               ConnectionType      - Waveout allocator, or our own
//               BitsPerSample       - 8, 16
//
//   Arguments:
//           LPCSTR szProfileName: name of profile file
//
//   Return (void):
//
//--------------------------------------------------------------------------

VOID CALLBACK LoadCustomProfile(LPCSTR pszProfileName)
{
    TCHAR       szBuf[128];
    HANDLE      hProfile;
    LPCTSTR     tszProfileName;

#ifdef UNICODE
    WCHAR   wszProfileName[128];

    if (!MultiByteToWideChar(CP_ACP,
			     0,
			     pszProfileName,
			     -1,
			     wszProfileName,
			     128)) {

	MessageBox(ghwndTstShell,
		   TEXT("Could not convert profile name to ANSI"),
		   szAppName,
		   MB_ICONEXCLAMATION | MB_OK);
	return;
    }

    tszProfileName = wszProfileName;
#else
    tszProfileName = pszProfileName;
#endif

    hProfile = CreateFile(tszProfileName,
			  GENERIC_READ,
			  0,
			  NULL,
			  OPEN_EXISTING,
			  FILE_ATTRIBUTE_NORMAL,
			  NULL);

    if (INVALID_HANDLE_VALUE == hProfile) {
	wsprintf(szBuf, TEXT("Cannot open profile %hs"), pszProfileName);
	MessageBox(ghwndTstShell, szBuf, szAppName,MB_ICONEXCLAMATION | MB_OK);
	return;
    }

    CloseHandle(hProfile);

    // Read the time increment setting
    wsprintf(szBuf, TEXT("%lu"), dwIncrement);
    GetPrivateProfileString(TEXT("custom settings"),
			    TEXT("TimeIncrement"),
			    szBuf,
			    szBuf,
			    MAX_PATH,
			    tszProfileName);
    dwIncrement = _tcstoul(szBuf, NULL, 10);

    // Read the connection type
    wsprintf(szBuf, TEXT("%s"), "Samples");
    GetPrivateProfileString(TEXT("custom settings"),
			    TEXT("Allocator"),
			    szBuf,
			    szBuf,
			    MAX_PATH,
			    tszProfileName);
    ChangeConnectionType(0 == lstrcmp(szBuf, TEXT("WaveOut")) ?
			 IDM_WAVEALLOC : IDM_OTHERALLOC);

    // Read number of bits per pixel
    wsprintf(szBuf, TEXT("%u"), 8);
    GetPrivateProfileString(TEXT("custom settings"),
			    TEXT("BitsPerSample"),
			    szBuf,
			    szBuf,
			    MAX_PATH,
			    tszProfileName);
    DWORD dwBitsPerSample = _tcstoul(szBuf, NULL, 10);
    if ((dwBitsPerSample != 8) && (dwBitsPerSample != 16)) {
	wsprintf(szBuf, TEXT("BitsPerSample must be 8 or 16. %d is illegal and is ignored"), dwBitsPerSample);
	MessageBox(ghwndTstShell, szBuf, szAppName,MB_ICONEXCLAMATION | MB_OK);
	dwBitsPerSample = 8;
    }
    LoadWAV(dwBitsPerSample == 8 ? IDM_8M11 : IDM_16M11);
}


/* Log the text into the test shell window using tstLog. This is more complex
   that first appears because of a potential deadlock problem. The window has
   it's own thread of execution, if we use that thread to change the state of
   any COM objects then we cannot be calling Log at the same time on another
   thread as the SendMessage it eventually executes will never complete. We
   have a critical section that we lock and then set a flag indicating we are
   changing the state, when we enter this routine we check we can continue */

void Log(UINT iLogLevel, LPTSTR text)
{
    CAutoLock cObjectLock(&CSLog);

    if (bStateChanging == FALSE) {

	#ifdef UNICODE
	    CHAR ach[128];
	    WideCharToMultiByte(CP_ACP, 0, text, -1, ach, 128, NULL, NULL);
	    tstLog(iLogLevel, ach);
	#else
	    tstLog(iLogLevel, text);
	#endif
    }
}


//==========================================================================
//
//  BOOL DumpTestObjects
//
//  Description:
//      In DEBUG builds the audio renderer exports a special entry point
//      called DbgDumpObjectRegister (actually it's exported by the base
//      classes it uses) so we provide a menu option to call this entry
//      point. What it will do is to dump all the C++ objects currently
//      active. This is useful to call to see the current object state
//
//==========================================================================


/* This displays the objects active in the audio renderer */

BOOL DumpTestObjects()
{
    DbgDumpObjectRegister();

    /* Get a module handle for the renderer */

    HMODULE hModule = GetModuleHandle(TEXT("WAVEOUT.DLL"));
    if (hModule == NULL) {
	HMODULE hModule = GetModuleHandle(TEXT("QUARTZ.DLL"));
	if (hModule == NULL) {
	    return FALSE;
	}
    }

    /* Get the DLL address of DbgDumpObjectRegister */

    PDUMP pDump = (PDUMP) GetProcAddress(hModule,"DbgDumpObjectRegister");
    if (pDump == NULL) {
	return FALSE;
    }

    pDump();
    return TRUE;
}


/* Sets a flag indicating we are changing state */

void StartStateChange()
{
    CAutoLock cObjectLock(&CSLog);
    bStateChanging = TRUE;
}


/* Sets a flag indicating we have completed a state change */

void EndStateChange()
{
    CAutoLock cObjectLock(&CSLog);
    bStateChanging = FALSE;
}


/* Create the logging list box and the worker thread */

BOOL InitialiseTest()
{
    /* Set the default connection type to use samples */
    ChangeConnectionType(IDM_WAVEALLOC);

    /* Load the default audio data from the current directory */

    HRESULT hr = LoadWAV(DEFAULT_WAVE);
    if (FAILED(hr)) {
	MessageBox(ghwndTstShell,
		   TEXT("Test sounds not found on the path"),
		   TEXT("Load"),
		   MB_OK | MB_ICONSTOP);
	return FALSE;
    }

    /* Create the event we use to start and stop the worker thread */

    hState = CreateEvent(NULL,FALSE,FALSE,NULL);
    ASSERT(hState);

    /* Display the period between frames we will send */

    wsprintf(szInfo,TEXT("Initial sample delay %dms"),dwIncrement/10);
    Log(TERSE, szInfo);
    wsprintf(szInfo, TEXT("Wave file in use: %hs"), pAudioFileNames[uiAudioChoice]);
    Log(TERSE, szInfo);
    wsprintf(szInfo, TEXT("        Channels: %d"), g_wfx.nChannels);
    Log(TERSE, szInfo);
    wsprintf(szInfo, TEXT("   SamplesPerSec: %d"), g_wfx.nSamplesPerSec);
    Log(TERSE, szInfo);
    wsprintf(szInfo, TEXT("  wBitsPerSample: %d"), g_wfx.wBitsPerSample);
    Log(TERSE, szInfo);
    return TRUE;
}


/* Reset the interface pointers to NULL */

HRESULT ResetInterfaces()
{
    /* Clock interface */
    pClock = NULL;

    /* IBaseFilter interfaces */
    pRenderFilter = NULL;
    pShellFilter = NULL;

    /* IMediaFilter interfaces */
    pRenderMedia = NULL;
    pShellMedia = NULL;

    /* IPin interfaces */
    pOutputPin = NULL;
    pInputPin = NULL;

    /* Reset the test shell object */
    pShell = NULL;
    return NOERROR;
}


/* Release any interfaces currently held */

HRESULT ReleaseInterfaces()
{
    HRESULT hr = NOERROR;
    Log(VERBOSE, TEXT("Releasing interfaces..."));

    /* Clock interface */

    if (pClock != NULL) {
	pRenderMedia->SetSyncSource(NULL);
	hr = pClock->Release();
	if (FAILED(hr)) {
	    Log(TERSE, TEXT("Could not release clock"));
	    return E_FAIL;
	}
    }

    /* Volume control */

    if (pIBasicAudio != NULL) {
	hr = pIBasicAudio->Release();
	if (FAILED(hr)) {
	    Log(TERSE, TEXT("Could not release audio control"));
	    return E_FAIL;
	}
	pIBasicAudio = NULL;
    }

    /* IBaseFilter interfaces */

    if (pRenderFilter != NULL) {
	hr = pRenderFilter->Release();
	if (FAILED(hr)) {
	    Log(TERSE, TEXT("Could not release render IBaseFilter"));
	    return E_FAIL;
	}
    }

    if (pShellFilter != NULL) {
	hr = pShellFilter->Release();
	if (FAILED(hr)) {
	    Log(TERSE, TEXT("Could not release shell IBaseFilter"));
	    return E_FAIL;
	}
    }

    /* IMediaFilter interfaces */

    if (pRenderMedia != NULL) {
	hr = pRenderMedia->Release();
	if (FAILED(hr)) {
	    Log(TERSE, TEXT("Could not release render IMediaFilter"));
	    return E_FAIL;
	}
    }

    if (pShellMedia != NULL) {
	hr = pShellMedia->Release();
	if (FAILED(hr)) {
	    Log(TERSE, TEXT("Could not release shell IMediaFilter"));
	    return E_FAIL;
	}
    }

    /* IPin interfaces */

    if (pOutputPin != NULL) {
	hr = pOutputPin->Release();
	if (FAILED(hr)) {
	    Log(TERSE, TEXT("Could not release shell IPin"));
	    return E_FAIL;
	}
    }

    if (pInputPin != NULL) {
	hr = pInputPin->Release();
	if (FAILED(hr)) {
	    Log(TERSE, TEXT("Could not release render IPin"));
	    return E_FAIL;
	}
    }

    Log(TERSE, TEXT("Released interfaces"));
    return NOERROR;
}


//==========================================================================
//
//  HRESULT LoadWAV(uint uiMenuItem)
//
//  Description:
//
//      uiMenuItem is IDM_8M11 etc to identify 8bit/11KHz, 16bit/11KHz
//      or 8bit/22KHz.  No other wave formats are currently tested.
//
//      This function loads a header from a wave file, initialises a
//      global wave format structure, g_wfx, then reads the audio data into
//      bData.  The maximum size the data can be (bytes) is MAX_SAMPLE_SIZE.
//
//==========================================================================


HRESULT LoadWAV(UINT uiMenuItem)
{
    HANDLE hFile;               // File handle
    DWORD dwRead;               // Number of bytes read
    UINT  filechoice;
    WAVEFORMATEX wfx;
    static const FOURCC wavedata = MAKEFOURCC('d','a','t','a');
    static const FOURCC wavefact = MAKEFOURCC('f','a','c','t');
    static const FOURCC waveWAVE = MAKEFOURCC('W','A','V','E');
    static const FOURCC wavefmt  = MAKEFOURCC('f','m','t',' ');

    /* We can only change the audio when we are disconnected */

    if (bConnected == TRUE) {

	MessageBox(ghwndTstShell,
		   TEXT("Must be disconnected to change wave data"),
		   TEXT("Load WAVE"),
		   MB_ICONEXCLAMATION | MB_OK);

	return E_FAIL;
    }

    /* Open the wave file for reading */

    ASSERT((IDM_FILEFIRST<=uiMenuItem) && (IDM_FILELAST>=uiMenuItem));

    filechoice = uiMenuItem-IDM_FILEFIRST;
    const TCHAR *pFileName = pAudioFileNames[filechoice];

    hFile = CreateFile( pFileName,              // File name
			GENERIC_READ,           // Read access
			FILE_SHARE_READ,        // Share attributes
			NULL,                   // Security attributes
			OPEN_EXISTING,          // Always open the file
			FILE_ATTRIBUTE_NORMAL,  // Normal file attributes
			NULL );                 // No template

    if (hFile == INVALID_HANDLE_VALUE) {
	Log(TERSE, TEXT("File containing wave data not on path"));
	return E_FAIL;
    }

    struct {
	DWORD   dwRIFF;
	DWORD   dwFileSize;
	DWORD   dwWAVE;
	DWORD   dwFMT;
	DWORD   dwFMTSize;
    } WAVEHEADER;

    struct {
	DWORD   dwDATA;
	DWORD   dwDataSize;
    } WAVEHEADER2;

    /* Read the wave header */

    ReadFile(hFile, (PVOID) &WAVEHEADER, sizeof(WAVEHEADER), &dwRead, NULL);

    if ((dwRead < sizeof(WAVEHEADER))
	  || (WAVEHEADER.dwRIFF != FOURCC_RIFF)
	  || (WAVEHEADER.dwWAVE != waveWAVE)
	  || (WAVEHEADER.dwFMT  != wavefmt )
    ) {
	Log(TERSE, TEXT("File is not a valid WAV"));
	CloseHandle(hFile);
	return E_FAIL;
    }

    wfx.cbSize = 0; // we only deal with PCM data...

    ReadFile(hFile,
	     (PVOID)&wfx,
	     WAVEHEADER.dwFMTSize,
	     &dwRead,
	     NULL);

    if (dwRead < WAVEHEADER.dwFMTSize) {
	Log(TERSE, TEXT("File is not a valid WAV"));
	CloseHandle(hFile);
	return E_FAIL;
    }

    if (wfx.wFormatTag != WAVE_FORMAT_PCM) {
	Log(TERSE, TEXT("File must be a PCM wave file"));
	CloseHandle(hFile);
	return E_FAIL;
    }

    // we now have to read the data.  note that the test
    // wave files have a FACT chunk immediately after the
    // wave format data which therefore has to be skipped.

    // Read each chunk in turn until we find the data (or
    // run up against the end of file.

    while (1) {
	TCHAR szBuf[256];
	ReadFile(hFile, (PVOID) &WAVEHEADER2, sizeof(WAVEHEADER2), &dwRead, NULL);

	if (dwRead < sizeof(WAVEHEADER2)) {
	    Log(TERSE, TEXT("File is not a valid WAV"));
	    CloseHandle(hFile);
	    return E_FAIL;
	}
#ifdef DEBUG
	wsprintf(szBuf, TEXT("Read chunk info for \"%4.4hs\""), &WAVEHEADER2);
	Log(VERBOSE, szBuf);
#endif
	if (WAVEHEADER2.dwDATA == wavedata) break;
	
	// We do not have the wave data chunk next... we must
	// skip forward the length of this chunk
	SetFilePointer(hFile, WAVEHEADER2.dwDataSize, NULL, FILE_CURRENT);
    }

    /* Calculate the audio data size and read it in */

    cbData = WAVEHEADER2.dwDataSize;
    ASSERT(cbData < MAX_SAMPLE_SIZE);

    EXECUTE_ASSERT(ReadFile(hFile, bData, cbData, &dwRead, NULL));

    EXECUTE_ASSERT(CloseHandle(hFile));

    uiAudioChoice = filechoice;
    SetImageMenuCheck(uiMenuItem);
    g_wfx = wfx;

    // cbData is the number of data bytes that we have.  Calculate the
    // length of the sample in RefTime units so that when we pass sample
    // start and end times we get it right...

    // Take account of 8/16 bit samples
    // Take account of stereo data

    // single channel length = Total_length/nChannels
    // s_c_l in seconds = s_c_l * 8 / BitsPerSample
    // s_c_l in NANOSECONDS = 1000*10 * (s_c_l in seconds)
#define WAVE_NSTIME  (cbData/wfx.nChannels*10000/wfx.nSamplesPerSec*8/wfx.wBitsPerSample)
    cWaveLength = ((LONGLONG)WAVE_NSTIME);
    return NOERROR;
}

/* This creates the filters and obtains their pins */

HRESULT CreateStream()
{
    /* Check we have not already created the objects */

    if (bCreated == TRUE) {

	MessageBox(ghwndTstShell,
		   TEXT("Objects already created"),
		   TEXT("Create"),
		   MB_ICONEXCLAMATION | MB_OK);

	return S_FALSE;
    }

    HRESULT hr = CreateObjects();
    if (FAILED(hr)) {
	ReleaseInterfaces();
	ResetInterfaces();
	return E_FAIL;
    }

    /* Enumerate the filters' pins */

    EnumeratePins();
    if (FAILED(hr)) {
	ReleaseInterfaces();
	ResetInterfaces();
	return E_FAIL;
    }

    /* Get the IMediaFilter interfaces */

    hr = GetIMediaFilterInterfaces();
    if (FAILED(hr)) {
	ReleaseInterfaces();
	ResetInterfaces();
	return E_FAIL;
    }

    /* Get the pin interfaces to work with */

    hr = GetIPinInterfaces();
    if (FAILED(hr)) {
	ReleaseInterfaces();
	ResetInterfaces();
	return E_FAIL;
    }

    /* Get the volume control interface to work with */

    hr = GetIBasicAudioInterface();
    if (FAILED(hr)) {
	// for the moment do not require the audio control
	// interface to be present
	//ReleaseInterfaces();
	//ResetInterfaces();
	//return E_FAIL;
    }
    Log(TERSE, TEXT("Objects successfully created"));
    bCreated = TRUE;
    return NOERROR;
}


/* This functions looks after actually creating the objects */

HRESULT CreateObjects()
{
    HRESULT hr = NOERROR;

    /* Create a reference clock */


    /* Create an audio renderer object */

    hr = CoCreateInstance(CLSID_AudioRender,          // Audio renderer object
			  NULL,                       // Outer unknown
			  CLSCTX_INPROC,              // Inproc server
			  IID_IBaseFilter,            // Interface required
			  (void **) &pRenderFilter ); // Where to put result

    if (FAILED(hr) || pRenderFilter == NULL) {
	Log(TERSE, TEXT("Couldn't create an audio renderer"));
	return E_FAIL;
    }

    Log(VERBOSE, TEXT("Created an audio renderer"));

    //  Get the clock from the audio renderer
    hr = pRenderFilter->QueryInterface(IID_IReferenceClock,
					       (VOID **) &pClock);
    if (!FAILED(hr)) {
	Log(TERSE, TEXT("Using Clock returned from audio renderer"));
	// This should also prevent the clock being destroyed until
	// we have finished with it
    } else {

	hr = CoCreateInstance(CLSID_SystemClock,        // Clock object
			      NULL,                     // Outer unknown
			      CLSCTX_INPROC,            // Inproc server
			      IID_IReferenceClock,      // Interface required
			      (void **) &pClock );      // Where to put result
    }

    if (FAILED(hr) || pClock == NULL) {
	pClock = NULL;
	Log(TERSE, TEXT("Couldn't create a clock"));
	return E_FAIL;
    }

    Log(VERBOSE, TEXT("Created a reference clock"));

    /* Now create a shell object */

    pShell = new CShell(NULL,&hr);
    ASSERT(pShell != NULL);

    hr = pShell->NonDelegatingQueryInterface(
	IID_IBaseFilter,
	(void **) &pShellFilter);

    if (FAILED(hr)) {
	Log(TERSE, TEXT("Couldn't create a shell object"));
	return E_FAIL;
    }
    Log(VERBOSE, TEXT("Created a shell test object"));
    return NOERROR;
}


/* Control point for releasing the filter stream */

HRESULT ReleaseStream()
{
    /* Check there is a valid stream */

    if (bCreated == FALSE) {

	MessageBox(ghwndTstShell,
		   TEXT("Objects not yet created"),
		   TEXT("Release"),
		   MB_ICONEXCLAMATION | MB_OK);

	return S_FALSE;
    }

    /* Do we need to disconnect first */

    if (bConnected) {
	DisconnectStream();
    }

    /* Release the interfaces */

    ReleaseInterfaces();
    ResetInterfaces();
    bCreated = FALSE;
    return NOERROR;
}


/* Control point for connecting the filters up */

HRESULT ConnectStream()
{
    /* Check the stream is valid */

    if (bCreated == FALSE) {

	MessageBox(ghwndTstShell,
		   TEXT("Objects not yet created"),
		   TEXT("ConnectStream"),
		   MB_ICONEXCLAMATION | MB_OK);

	return S_FALSE;
    }

    Log(VERBOSE, TEXT("Connecting filters..."));

    /* Try and connect the input AUDIO pin and the output SHELL pin */

    ASSERT(pOutputPin != NULL);
    ASSERT(pInputPin != NULL);

    HRESULT hr = pOutputPin->Connect(pInputPin,NULL);
    if (FAILED(hr)) {
	Log(TERSE, TEXT("Could not connect pins"));
	return E_FAIL;
    }

    /* Set the reference clock source */

    pRenderMedia->SetSyncSource(pClock);
    Log(VERBOSE, TEXT("Connected filters"));
    bConnected = TRUE;
    return NOERROR;
}


/* Disconnects the filters from each other */

HRESULT DisconnectStream()
{
    /* Check the stream is valid */

    if (bCreated == FALSE) {

	MessageBox(ghwndTstShell,
		   TEXT("Objects not yet created"),
		   TEXT("DisconnectStream"),
		   MB_ICONEXCLAMATION | MB_OK);

	return S_FALSE;
    }

    if (bConnected == FALSE) {

	MessageBox(ghwndTstShell,
		   TEXT("Objects not connected"),
		   TEXT("DisconnectStream"),
		   MB_ICONEXCLAMATION | MB_OK);

	return S_FALSE;
    }

    /* Do we need to stop running first */
    /* Should we also automatically stop if Paused? */

    if (bRunning == TRUE) {
	StopSystem();
    }

    Log(VERBOSE, TEXT("Disconnecting filters..."));

    /* Disconnect the pins */

    HRESULT hr = pOutputPin->Disconnect();
    if (FAILED(hr)) {
	Log(TERSE, TEXT("Could not disconnect SHELL pin"));
	return E_FAIL;
    }

    hr = pInputPin->Disconnect();
    if (FAILED(hr)) {
	Log(TERSE, TEXT("Could not disconnect AUDIO pin"));
	return E_FAIL;
    }
    Log(VERBOSE, TEXT("Disconnected filters"));
    bConnected = FALSE;
    return NOERROR;
}


/* Enumerate the pins on each filter */

HRESULT EnumFilterPins(PFILTER pFilter)
{
    HRESULT hr;             // Return code
    PENUMPINS pEnumPins;    // Pin enumerator
    PPIN pPin;              // Holds next pin obtained
    LONG lPins;             // Number of pins retrieved
    ULONG ulFetched;        // Number retrieved on each call
    PIN_INFO pi;            // Information about each pin

    hr = pFilter->EnumPins(&pEnumPins);

    /* See what happened */

    if (FAILED(hr)) {
	Log(TERSE, TEXT("Couldn't get IEnumPins interface"));
	return E_FAIL;
    }

    Log(VERBOSE, TEXT("Got the IEnumPins interface"));

    pPin = NULL;
    lPins = 0;

    /* Retrieve the pins one by one */

    while (TRUE) {

	/* Get the next pin interface */

	pEnumPins->Next(1, &pPin, &ulFetched);
	if (ulFetched != 1) {
	    break;
	}

	lPins++;

	/* Display the pin information */

	ASSERT(pPin != NULL);
	hr = pPin->QueryPinInfo(&pi);

	if (FAILED(hr)) {
	    pPin->Release();
	    pEnumPins->Release();
	    Log(TERSE, TEXT("QueryPinInfo failed"));
	    return NULL;
	}
	QueryPinInfoReleaseFilter(pi);

	/* Display the pin information */

	wsprintf(szInfo,TEXT("%3d %20s (%s)"), lPins, pi.achName,
		 (pi.dir == PINDIR_INPUT ? TEXT("Input") : TEXT("Output")));

	Log(VERBOSE, szInfo);
	pPin->Release();

    }
    pEnumPins->Release();
    if (lPins) {
	return NOERROR;
    } else {
	return E_FAIL;
    }
}


/* This function looks after enumerating and displaying the pins available */

HRESULT EnumeratePins()
{
    Log(VERBOSE, TEXT("Enumerating RENDERER pins..."));

    HRESULT hr = EnumFilterPins(pRenderFilter);
    if (FAILED(hr)) {
	return hr;
    }

    Log(VERBOSE, TEXT("Enumerating SHELL pins..."));

    hr = EnumFilterPins(pShellFilter);
    if (FAILED(hr)) {
	return hr;
    }
    return NOERROR;
}


/* This function retrieves the IBasicAudio interface for each filter */

HRESULT GetIBasicAudioInterface()
{
    Log(VERBOSE, TEXT("Obtaining IBasicAudio interface"));

    HRESULT hr = pRenderFilter->QueryInterface(IID_IBasicAudio,
					       (VOID **) &pIBasicAudio);
    if (FAILED(hr)) {
	Log(TERSE, TEXT("No Audio IBasicControl"));
	// for the moment, carry on without the audio control being present
	//return E_FAIL;
    }
    return NOERROR;
}

/* This function retrieves the IMediaFilter interface for each filter */

HRESULT GetIMediaFilterInterfaces()
{
    Log(VERBOSE, TEXT("Obtaining IMediaFilter interface"));

    /* Get the audio renderer IMediaFilter interface */

    HRESULT hr = pRenderFilter->QueryInterface(IID_IMediaFilter,
					       (VOID **) &pRenderMedia);
    if (FAILED(hr)) {
	Log(TERSE, TEXT("No Audio IMediaFilter"));
	return E_FAIL;
    }

    /* Get the SHELL IMediaFilter interface */

    pShellFilter->QueryInterface(IID_IMediaFilter,
				 (VOID **) &pShellMedia);
    if (FAILED(hr)) {
	Log(TERSE, TEXT("No Shell IMediaFilter"));
	return E_FAIL;
    }

    Log(VERBOSE, TEXT("Obtained IMediaFilter interface"));
    return NOERROR;
}


/* This function retrieves the pin interfaces needed to make the
   connections between the filters so that the show can begin */

HRESULT GetIPinInterfaces()
{
    Log(VERBOSE, TEXT("Obtaining IPin interfaces"));

    /* Get the pin interfaces */

    pOutputPin = GetPin(pShellFilter,0);
    if (pOutputPin == NULL) {
	return E_FAIL;
    }

    pInputPin = GetPin(pRenderFilter,0);
    if (pInputPin == NULL) {
	return E_FAIL;
    }

    Log(VERBOSE, TEXT("Obtained IPin interfaces"));
    return NOERROR;
}


/* Return a pin on a filter identified by ordinal position starting at ZERO */

IPin *GetPin(IBaseFilter *pFilter, ULONG lPin)
{
    HRESULT hr;             // Return code
    PENUMPINS pEnumPins;    // Pin enumerator
    PPIN pPin;              // Holds next pin obtained
    ULONG ulFetched;        // Number retrieved on each call

    /* First of all get the pin enumerator */

    hr = pFilter->EnumPins(&pEnumPins);
    if (FAILED(hr)) {
	Log(TERSE, TEXT("Couldn't get IEnumPins interface"));
	return NULL;
    }

    /* Skip to the relevant pin */

    hr = pEnumPins->Skip(lPin);
    if (S_OK != hr) {
	Log(TERSE, TEXT("Couldn't SKIP to pin"));
	pEnumPins->Release();
	return NULL;
    }

    /* Get the next pin interface */

    hr = pEnumPins->Next(1, &pPin, &ulFetched);
    if (FAILED(hr) || ulFetched != 1) {
	Log(TERSE, TEXT("Couldn't get NEXT pin"));
	pEnumPins->Release();
	return NULL;
    }

    /* Release the enumerator and return the pin */

    pEnumPins->Release();
    return pPin;
}


/* This sets the system into a paused state */

HRESULT PauseSystem()
{
    HRESULT hr;         // General OLE return code

    /* Check there is a valid connection */

    if (bConnected == FALSE) {

	MessageBox(ghwndTstShell,
		   TEXT("Objects not yet connected"),
		   TEXT("Pause"),
		   MB_ICONEXCLAMATION | MB_OK);

	return S_FALSE;
    }

    Log(VERBOSE, TEXT("Pausing system..."));

    /* Are we pausing from running? */

    if (gtBase > CRefTime(0L)) {

	/* In this case, we need to remember the pause time, so
	   that we can set the correct base time at restart */

	hr = pClock->GetTime((REFERENCE_TIME *) &gtPausedAt);
	if (FAILED(hr)) {
	    Log(TERSE, TEXT("Couldn't get time"));
	    return hr;
	}
    }

    StartStateChange();
    hr = pRenderMedia->Pause();
    EndStateChange();

    if (FAILED(hr)) {
	Log(TERSE, TEXT("Couldn't pause AUDIO"));
	return E_FAIL;
    }

    hr = pShellMedia->Pause();
    if (FAILED(hr)) {
	Log(TERSE, TEXT("Couldn't pause SHELL"));
	pRenderMedia->Stop();     // Have to stop the audio
	return E_FAIL;
    }
    Log(TERSE, TEXT("Paused system"));
    return NOERROR;
}


/* This sets the system into stopped state */

HRESULT StopSystem()
{
    /* Check there is a valid connection */

    if (bConnected == FALSE) {

	MessageBox(ghwndTstShell,
		   TEXT("Objects not yet connected"),
		   TEXT("Stop"),
		   MB_ICONEXCLAMATION | MB_OK);

	return S_FALSE;
    }

    Log(VERBOSE, TEXT("Stopping system..."));

    /* We no longer have a base time */

    gtBase = CRefTime(0L);
    gtPausedAt = CRefTime(0L);

    /* Change the state of the filters */

    StartStateChange();
    HRESULT hr = pRenderMedia->Stop();
    EndStateChange();

    if (FAILED(hr)) {
	Log(TERSE, TEXT("Couldn't stop AUDIO"));
	return E_FAIL;
    }

    hr = pShellMedia->Stop();
    if (FAILED(hr)) {
	Log(TERSE, TEXT("Couldn't stop SHELL"));
	return E_FAIL;
    }

    StopWorkerThread();
    Log(TERSE, TEXT("Stopped system"));
    bRunning = FALSE;
    return NOERROR;
}


/* This sets the filters running - we start at the renderer end on the right
   so that as soon as we get to the source shell filter everything is ready */

HRESULT StartSystem()
{
    /* Check there is a valid connection */

    if (bConnected == FALSE) {

	MessageBox(ghwndTstShell,
		   TEXT("Objects not yet connected"),
		   TEXT("Start"),
		   MB_ICONEXCLAMATION | MB_OK);

	return S_FALSE;
    }

    Log(VERBOSE, TEXT("Starting system running..."));
    SetStartTime();

    StartStateChange();
    HRESULT hr = pRenderMedia->Run(gtBase);
    EndStateChange();

    if (FAILED(hr)) {
	Log(TERSE, TEXT("Couldn't start AUDIO running"));
	return E_FAIL;
    }

    hr = pShellMedia->Run(gtBase);
    if (FAILED(hr)) {
	Log(TERSE, TEXT("Couldn't start SHELL running"));
	pRenderMedia->Stop();
	return E_FAIL;
    }

    Log(TERSE, TEXT("Started system running"));
    hr = StartWorkerThread();
    if (FAILED(hr)) {
	StartStateChange();
	HRESULT hr = pRenderMedia->Stop();
	EndStateChange();
	hr = pShellMedia->Stop();
	return(hr);
    }
    bRunning = TRUE;
    return NOERROR;
}

/* This tests the volume setting */

extern void FAR PASCAL YieldAndSleep(DWORD cMilliseconds);
HRESULT TestVolume()
{
    /* Check there is a valid connection */

    if (!pIBasicAudio) {

	Log(TERSE, TEXT("No audio interface to use"));
	MessageBox(ghwndTstShell,
		   TEXT("No audio interface"),
		   TEXT("TestVolume"),
		   MB_ICONEXCLAMATION | MB_OK);

	return S_FALSE;
    }

    ULONG vInit;
    LONG volume, v2;
    HRESULT hr;
    hr = pIBasicAudio->get_Volume(&volume);
    vInit = volume;
    TCHAR szInfo[40];
    wsprintf(szInfo, TEXT("Initial volume is %d"), volume);
    Log(TERSE, szInfo);
    volume = AX_HALF_VOLUME;    // half volume
    hr = pIBasicAudio->put_Volume(volume);
    if (SUCCEEDED(hr)) {
	hr = pIBasicAudio->get_Volume(&v2);
    }

    if (FAILED(hr) || (abs(volume-v2) > 100)) {
	Log(TERSE, TEXT("Volume set is not equal to volume read"));
	MessageBox(ghwndTstShell,
		   TEXT("Volume setting failed"),
		   TEXT("TestVolume"),
		   MB_ICONEXCLAMATION | MB_OK);
	return(S_FALSE);
    }

    ULONG change = 1000;
    v2 = 0;

    Log(TERSE, TEXT("Running volume down"));
    for (int i=10; i; --i) {
	pIBasicAudio->put_Volume(v2 - (change*(10-i)));
	YieldAndSleep(800);
    }

    Log(TERSE, TEXT("Running volume up"));
    for (i=10; i; --i) {
	pIBasicAudio->put_Volume(v2 - (change*i));
	YieldAndSleep(800);
    }

    hr = pIBasicAudio->put_Volume(AX_MAX_VOLUME+1);
    if (!FAILED(hr)) {
	Log(VERBOSE, TEXT("Should have failed setting volume to AX_MAX_VOLUME+1"));
	return(S_FALSE);
    }

    hr = pIBasicAudio->put_Volume(AX_MIN_VOLUME-1);
    if (!FAILED(hr)) {
	Log(VERBOSE, TEXT("Should have failed setting volume to AX_MIN_VOLUME-1"));
	return(S_FALSE);
    }


    pIBasicAudio->put_Volume(vInit);

    ULONG vInitBalance;
    LONG Balance, b2;
    hr = pIBasicAudio->get_Balance(&Balance);
    vInitBalance = Balance;
    wsprintf(szInfo, TEXT("Initial Balance is %d"), Balance);
    Log(TERSE, szInfo);

    Balance = -600;
    hr = pIBasicAudio->put_Balance(Balance);
    if (SUCCEEDED(hr)) {
	hr = pIBasicAudio->get_Balance(&b2);
    }

    if (FAILED(hr) || (abs(Balance-b2) > 100)) {
	Log(TERSE, TEXT("Balance set is not equal to Balance read"));
	MessageBox(ghwndTstShell,
		   TEXT("Balance setting failed"),
		   TEXT("TestVolume"),
		   MB_ICONEXCLAMATION | MB_OK);
	return(S_FALSE);
    }
    change = 2000;
    b2 = 10000;

    Log(TERSE, TEXT("Running Balance left"));
    for (i=10; i; --i) {
	pIBasicAudio->put_Balance(b2 - (change*(10-i)));
	YieldAndSleep(800);
    }

    Log(TERSE, TEXT("Running Balance right"));
    for (i=10; i; --i) {
	pIBasicAudio->put_Balance(b2 - (change*i));
	YieldAndSleep(800);
    }
    pIBasicAudio->put_Balance(vInitBalance);
    Log(TERSE, TEXT("Volume (amplitude and Balance) contol works"));
    return S_OK;
}

/* This tests that setting the volume leaves balance unchanged */

HRESULT TestVolumeBalance()
{
#if 0
    Log(TERSE, TEXT("Test under construction"));
    MessageBox(ghwndTstShell,
	       TEXT("Test under construction"),
	       TEXT("TestVolumeBalance"),
	       MB_ICONEXCLAMATION | MB_OK);

    return S_OK;
#endif

    /* Check there is a valid connection */
    if (!pIBasicAudio) {

	Log(TERSE, TEXT("No audio interface to use"));
	MessageBox(ghwndTstShell,
		   TEXT("No audio interface"),
		   TEXT("TestVolumeBalance"),
		   MB_ICONEXCLAMATION | MB_OK);

	return S_FALSE;
    }

    ULONG vInit;
    LONG volume, v2;
    HRESULT hr;
    hr = pIBasicAudio->get_Volume(&volume);
    vInit = volume;
    TCHAR szInfo[40];
    wsprintf(szInfo, TEXT("Initial volume is %d"), volume);
    Log(TERSE, szInfo);
    volume = AX_HALF_VOLUME;    // half volume
    hr = pIBasicAudio->put_Volume(volume);
    if (SUCCEEDED(hr)) {
	hr = pIBasicAudio->get_Volume(&v2);
    }

    if (FAILED(hr) || (abs(volume-v2) > 100)) {
	Log(TERSE, TEXT("Volume set is not equal to volume read"));
	MessageBox(ghwndTstShell,
		   TEXT("Volume setting failed"),
		   TEXT("TestVolumeBalance"),
		   MB_ICONEXCLAMATION | MB_OK);
	return(S_FALSE);
    }

    ULONG change = 1000;
    v2 = 0;

    Log(TERSE, TEXT("Running volume down"));
    for (int i=10; i; --i) {
	pIBasicAudio->put_Volume(v2 - (change*(10-i)));
	YieldAndSleep(800);
    }

    Log(TERSE, TEXT("Running volume up"));
    for (i=10; i; --i) {
	pIBasicAudio->put_Volume(v2 - (change*i));
	YieldAndSleep(800);
    }

    pIBasicAudio->put_Volume(vInit);

    ULONG vInitBalance;
    LONG Balance, b2;
    hr = pIBasicAudio->get_Balance(&Balance);
    vInitBalance = Balance;
    wsprintf(szInfo, TEXT("Initial Balance is %d"), Balance);
    Log(TERSE, szInfo);

    Balance = -600;
    hr = pIBasicAudio->put_Balance(Balance);
    if (SUCCEEDED(hr)) {
	hr = pIBasicAudio->get_Balance(&b2);
    }

    if (FAILED(hr) || (abs(Balance-b2) > 100)) {
	Log(TERSE, TEXT("Balance set is not equal to Balance read"));
	MessageBox(ghwndTstShell,
		   TEXT("Balance setting failed"),
		   TEXT("TestVolumeBalance"),
		   MB_ICONEXCLAMATION | MB_OK);
	return(S_FALSE);
    }
    change = 2000;
    b2 = 10000;

    Log(TERSE, TEXT("Running Balance left"));
    for (i=10; i; --i) {
	pIBasicAudio->put_Balance(b2 - (change*(10-i)));
	YieldAndSleep(800);
    }

    Log(TERSE, TEXT("Running Balance right"));
    for (i=10; i; --i) {
	pIBasicAudio->put_Balance(b2 - (change*i));
	YieldAndSleep(800);
    }
    pIBasicAudio->put_Balance(vInitBalance);
    Log(TERSE, TEXT("Volume (amplitude and Balance) contol works"));
    return S_OK;
}

/* This tests that setting the balance leaves volume unchanged */

HRESULT TestBalanceVolume()
{
#if 0
    Log(TERSE, TEXT("Test under construction"));
    MessageBox(ghwndTstShell,
	       TEXT("Test under construction"),
	       TEXT("TestBalanceVolume"),
	       MB_ICONEXCLAMATION | MB_OK);

    return S_OK;
#endif

    /* Check there is a valid connection */

    if (!pIBasicAudio) {

	Log(TERSE, TEXT("No audio interface to use"));
	MessageBox(ghwndTstShell,
		   TEXT("No audio interface"),
		   TEXT("TestBalanceVolume"),
		   MB_ICONEXCLAMATION | MB_OK);

	return S_FALSE;
    }

    ULONG vInit;
    LONG volume, v2;
    HRESULT hr;
    hr = pIBasicAudio->get_Volume(&volume);
    vInit = volume;
    TCHAR szInfo[40];
    wsprintf(szInfo, TEXT("Initial volume is %d"), volume);
    Log(TERSE, szInfo);
    volume = AX_HALF_VOLUME;    // half volume
    hr = pIBasicAudio->put_Volume(volume);
    if (SUCCEEDED(hr)) {
	hr = pIBasicAudio->get_Volume(&v2);
    }

    if (FAILED(hr) || (abs(volume-v2) > 100)) {
	Log(TERSE, TEXT("Volume set is not equal to volume read"));
	MessageBox(ghwndTstShell,
		   TEXT("Volume setting failed"),
		   TEXT("TestBalanceVolume"),
		   MB_ICONEXCLAMATION | MB_OK);
	return(S_FALSE);
    }

    ULONG change = 1000;
    v2 = 0;

    Log(TERSE, TEXT("Running volume down"));
    for (int i=10; i; --i) {
	pIBasicAudio->put_Volume(v2 - (change*(10-i)));
	YieldAndSleep(800);
    }

    Log(TERSE, TEXT("Running volume up"));
    for (i=10; i; --i) {
	pIBasicAudio->put_Volume(v2 - (change*i));
	YieldAndSleep(800);
    }

    pIBasicAudio->put_Volume(vInit);

    ULONG vInitBalance;
    LONG Balance, b2;
    hr = pIBasicAudio->get_Balance(&Balance);
    vInitBalance = Balance;
    wsprintf(szInfo, TEXT("Initial Balance is %d"), Balance);
    Log(TERSE, szInfo);

    Balance = -600;
    hr = pIBasicAudio->put_Balance(Balance);
    if (SUCCEEDED(hr)) {
	hr = pIBasicAudio->get_Balance(&b2);
    }

    if (FAILED(hr) || (abs(Balance-b2) > 100)) {
	Log(TERSE, TEXT("Balance set is not equal to Balance read"));
	MessageBox(ghwndTstShell,
		   TEXT("Balance setting failed"),
		   TEXT("TestBalanceVolume"),
		   MB_ICONEXCLAMATION | MB_OK);
	return(S_FALSE);
    }
    change = 2000;
    b2 = 10000;

    Log(TERSE, TEXT("Running Balance left"));
    for (i=10; i; --i) {
	pIBasicAudio->put_Balance(b2 - (change*(10-i)));
	YieldAndSleep(800);
    }

    Log(TERSE, TEXT("Running Balance right"));
    for (i=10; i; --i) {
	pIBasicAudio->put_Balance(b2 - (change*i));
	YieldAndSleep(800);
    }
    pIBasicAudio->put_Balance(vInitBalance);
    Log(TERSE, TEXT("Volume (amplitude and Balance) contol works"));
    return S_OK;
}

/* This stops the worker thread and waits until it completes */

HRESULT StopWorkerThread()
{
    /* Only kill the thread if we have one */

    Log(VERBOSE, TEXT("Stopping worker thread..."));

    if (hWorkerThread == NULL) {
	Log(TERSE, TEXT("Stopped worker thread"));
	return NOERROR;
    }

    /* Stop the worker thread from running */
    SetEvent(hState);

    while (TRUE) {

	DWORD dwResult;     // Wait return code
	MSG msg;            // Windows message block

	/* Wait for either the thread handle to be signaled or for a sent
	   message to arrive as the thread may be trying to log something */

	dwResult = MsgWaitForMultipleObjects(
			    (DWORD) 1,        // One thread handle
			    &hWorkerThread,   // Handle to wait on
			    FALSE,            // Wait for either
			    INFINITE,         // No event timeout
			    QS_SENDMESSAGE);  // Thread may do logging

	if (dwResult == WAIT_OBJECT_0) {
	    break;
	}

	/* Read all of the messages in this loop
	   removing each message as we read it */

	while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

	    /* Throw away any menu interactions while we are stopping
	       so that the user can't get us into a confused state */

	    if (msg.message == WM_COMMAND) {
		break;
	    }

	    /* Otherwise dispatch it to the window procedure */
	    DispatchMessage(&msg);
	}
    }

    /* Close the thread handle and reset the signaling event */

    EXECUTE_ASSERT(CloseHandle(hWorkerThread));
    ResetEvent(hState);
    hWorkerThread = NULL;

    /* Tell them we were successful */

    Log(TERSE, TEXT("Stopped worker thread"));
    return NOERROR;
}



/* This creates a worker thread that will either push media samples or
   tests overlay functionality depending upon the current settings */

HRESULT StartWorkerThread()
{
    /* Only start a thread if we don't already have one */

    if (hWorkerThread) {
	return NOERROR;
    }

    /* Create the worker thread to push samples to the renderer */

    hWorkerThread = CreateThread(NULL,              // Security attributes
			   (DWORD) 0,         // Initial stack size
			   SampleLoop,        // Thread start address
			   (LPVOID) 0,        // Thread parameter
			   (DWORD) 0,         // Creation flags
			   &dwThreadID);      // Thread identifier
    ASSERT(hWorkerThread);
    return NOERROR;
}


/* If we are starting from stopped then the time at which filters should
   start running is essentially now, although we actually give them the time
   in 100ms time to allow for start up latency. If we have been paused then
   we calculate how long we have been paused for, the we take that off the
   current time and hand that to the filters as the time when they run from */

HRESULT SetStartTime()
{
    HRESULT hr;     // OLE return code

    /* Are we restarting? */

    if (gtPausedAt > CRefTime(0L)) {

	ASSERT(gtBase > CRefTime(0L));

	/* The new base time is the old one plus the
	   length of time we have been paused for */

	CRefTime tNow;
	hr = pClock->GetTime((REFERENCE_TIME *) &tNow);
	ASSERT(SUCCEEDED(hr));

	gtBase += tNow - gtPausedAt;

	/* We are no longer paused */
	gtPausedAt = CRefTime(0L);
	return NOERROR;
    }

    /* We are starting from cold */

    ASSERT(gtBase == CRefTime(0L));
    ASSERT(gtPausedAt == CRefTime(0L));

    /* Since the initial stream time will be zero we need to set the
       base time to now plus a little processing time (100ms ?) */

    hr = pClock->GetTime((REFERENCE_TIME *) &gtBase);
    ASSERT(SUCCEEDED(hr));
    gtBase += CRefTime(100L);
    return NOERROR;
}


/* We can choose from three different wave files each of which is the same
   data but with differing bit depths.  This marks the current selection */

void SetImageMenuCheck(UINT uiMenuItem)
{
    static uiCurrentMenuItem = FALSE;

    /* Unset the old audio choice and then set our current mark */

    if (uiCurrentMenuItem) {
	CheckMenuItem(hAudioMenu,uiCurrentMenuItem,MF_BYCOMMAND | MF_UNCHECKED);
    }
    CheckMenuItem(hAudioMenu,uiMenuItem,MF_BYCOMMAND | MF_CHECKED);
    uiCurrentMenuItem = uiMenuItem;
}


/* We can either push samples or use an IOverlay interface */

void SetConnectionMenuCheck(UINT uiMenuItem)
{
    static uiCurrentMenuItem = FALSE;

    /* Unset the old image choice and then set our current mark */

    if (uiCurrentMenuItem) {
	CheckMenuItem(hConnectionMenu,uiCurrentMenuItem,MF_BYCOMMAND | MF_UNCHECKED);
    }
    CheckMenuItem(hConnectionMenu,uiMenuItem,MF_BYCOMMAND | MF_CHECKED);
    uiCurrentMenuItem = uiMenuItem;
}


/* We can either push samples to the test renderer or we can pretend to be an
   overlay device in which case we get an IOverlay interface and use that */

void ChangeConnectionType(UINT uiMenuItem)
{
    /* Check there is no current connection */

    if (bConnected == TRUE) {

	MessageBox(ghwndTstShell,
		   TEXT("Objects are already connected"),
		   TEXT("Change connection type"),
		   MB_ICONEXCLAMATION | MB_OK);
	return;
    }

    /* Check we are not running */

    if (bRunning == TRUE) {

	MessageBox(ghwndTstShell,
		   TEXT("System is running"),
		   TEXT("Change connection type"),
		   MB_ICONEXCLAMATION | MB_OK);
	return;
    }
    SetConnectionMenuCheck(uiMenuItem);
    uiConnectionType = uiMenuItem;
}


//
// Audio Test: worker thread
//
// This thread waits for an event to be signalled, either from Quartz
// (e.g. buffer complete) or from the UI (e.g. STOP).  While running
// we push audio samples down the pipe to the renderer.
//

DWORD SampleLoop(LPVOID lpvThreadParm)
{
    CRefTime StartTime;              // Start sample time
    CRefTime EndTime;                // End sample time
    HRESULT hr = NOERROR;            // OLE return code
    int iCount = FALSE;              // Number of samples count

    /* Keep going until someone stops us by setting the state event */

    while (TRUE) {

	/* See if we should stop */

	DWORD dwResult = WaitForSingleObject(hState,(DWORD) 0);
	if (dwResult == WAIT_OBJECT_0) {
	    break;
	}

	/* Set the time stamps */

	StartTime += CRefTime((LONG)dwIncrement);
	EndTime = StartTime + cWaveLength;
	dwIncrement = 0;

	/* Pass the sample through the output pin to the renderer */

	hr = PushSample((REFERENCE_TIME *) &StartTime,
			(REFERENCE_TIME *) &EndTime);
	if (FAILED(hr)) {
	    if (hr == VFW_E_NOT_COMMITTED) {
		Log(TERSE, TEXT("Allocator decommitted - stopping push loop"));
	    } else {
		Log(TERSE, TEXT("Error code pushing sample, state change ?"));
	    }
	    break;
	}

	/* See if the user has closed the test */

	if (hr == ResultFromScode(S_FALSE)) {
	    Log(TERSE, TEXT("User closed window"));
	    break;
	}
    }
    ExitThread(FALSE);
    return FALSE;
}


/* Send some samples down the connection */

HRESULT PushSample(REFERENCE_TIME *pStart, REFERENCE_TIME *pEnd)
{
    CBaseOutputPin *pShellPin;      // Output pin from shell
    PMEDIASAMPLE pMediaSample;      // Media sample for buffers
    HRESULT hr = NOERROR;           // OLE Return code
    BYTE *pData;                    // Pointer to buffer

    /* Get the output pin pointer from the shell object */

    pShellPin = pShell->m_pOutputPin;
    ASSERT(pShellPin);

    /* Fill in the next media sample's time stamps */

    hr = pShellPin->GetDeliveryBuffer(&pMediaSample,NULL,NULL,0);
    if (FAILED(hr)) {
	ASSERT(pMediaSample == NULL);
	return hr;
    }

    pMediaSample->SetTime(pStart,pEnd);

    /* Copy the image data into the media sample buffer */

    pMediaSample->GetPointer(&pData);
    ASSERT(pData != NULL);
    memcpy(pData,bData,cbData);

    // !!! check buffer is big enough???

    // set actual size of data
    pMediaSample->SetActualDataLength(cbData);

    /* Deliver the media sample to the input pin */

    hr = pShellPin->Deliver(pMediaSample);

    /* Done with the buffer, the connected pin may AddRef it to keep it */

    pMediaSample->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twavein\sink.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved


//
// source filter test class
//

#include <streams.h>

// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>

// all required clsid's are accessed via streams.h

#include "sink.h"
#include <TstsHell.h>


// --- CTestSink methods --------------

CTestSink::CTestSink(LPUNKNOWN pUnk, HRESULT * phr, HWND hwnd)
    : CUnknown(NAME("Test sink"), pUnk)
{
    m_hwndParent = hwnd;

    // we have zero pins for now
    m_paPins = NULL;
    m_nPins  = 0;

    // not yet connected
    m_pSource         = NULL;
    m_pSourceMF       = NULL;
    m_pTransformInput = NULL;
    m_pSourceOutput   = NULL;
    m_pClock          = NULL;

    // create our nested interface objects
    m_pFilter = new CImplFilter(this, phr);

    // need this for notify
    HRESULT hr = QzGetMalloc(MEMCTX_TASK, &m_pMalloc);
    if (FAILED(hr)) {
        *phr = hr;
        return;
    }
    ASSERT(m_pMalloc);

}

CTestSink::~CTestSink()
{
    // delete all our pins and release the filter
    TestDisconnect();

    // delete our nested interface objects
    m_pFilter->SetSyncSource(NULL);
    delete m_pFilter;

    if (m_pMalloc) {
        m_pMalloc->Release();
    }

    if (m_pClock) {
        m_pClock->Release();
    }
}

STDMETHODIMP
CTestSink::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IBaseFilter) {
        return m_pFilter->NonDelegatingQueryInterface(IID_IBaseFilter, ppv);
    } else if (riid == IID_IMediaFilter) {
        return m_pFilter->NonDelegatingQueryInterface(IID_IMediaFilter, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

CBasePin *
CTestSink::GetPin(int n)
{

    if ((m_nPins > 0) && (n < m_nPins) && m_paPins[n]) {
        return m_paPins[n];
    }
    return NULL;
}


// Create and connect to the subject filter.
// should be in a disconnected state first
TESTRES CTestSink::TestConnect(void)
{
    if (m_pSource) {
        Notify(TERSE, TEXT("** Null effect: Already Connected"));
	return TST_PASS;  //?? is this success? - but we probably want the next test
			  //   to run...
    }

    m_pSource = MakeSourceFilter();
    if (!m_pSource) {
        Notify(VERBOSE, TEXT("Could not instantiate Source filter") );
        return TST_FAIL;
    }

    // get a mediafilter interface
    HRESULT hr = m_pSource->QueryInterface(
                    IID_IMediaFilter,
                    (void **)&m_pSourceMF);

    if (FAILED(hr) || (!m_pSourceMF)) {
        Notify(VERBOSE, TEXT("Could not get IMediaFilter pointer") );
        return TST_FAIL;
    }

    ASSERT(SUCCEEDED(hr));
    ASSERT(m_pSourceMF);

    // connect to any exposed output pins
    if (MakePinConnections() == TST_FAIL) {
        Notify(TERSE, TEXT("Could not connect pins") );
	return TST_FAIL;
    }

    // set the reference clock
    m_pSourceMF->SetSyncSource(m_pClock);
    m_pFilter->SetSyncSource(m_pClock);


    Notify(TERSE, TEXT("Connected") );
    return TST_PASS;
}


IBaseFilter *CTestSink::MakeSourceFilter(void) {

    // make a reference clock
    HRESULT hr = QzCreateFilterObject(CLSID_SystemClock,
                    NULL,
                    CLSCTX_INPROC,
                    IID_IReferenceClock,
                    (void**) &m_pClock);
    if (FAILED(hr)) {
        Notify(VERBOSE, TEXT("Could not create clock"));
        return NULL;
    }

    IBaseFilter * pFilter;

    // instantiate the source filter using hardwired clsid
    hr = QzCreateFilterObject(CLSID_AudioRecord,
                          NULL,
                          CLSCTX_INPROC,
                          IID_IBaseFilter,
                          (void **) &pFilter);
    if (!pFilter) {
        Notify(VERBOSE, TEXT("Could not CoCreate WaveIn") );
        return NULL;
    }

    ASSERT(SUCCEEDED(hr));

    return pFilter;
}


//enumerate the pins, and connect to each of them
TESTRES CTestSink::MakePinConnections(void) {

    IEnumPins *pEnum;
    HRESULT hr = m_pSource->EnumPins(&pEnum);
    if (FAILED(hr)) {
        Notify(TERSE, TEXT("Could not get pin enumerator") );
	return TST_FAIL;
    }

    // first count the pins
    IPin *pPin;		// The pin we are currently interested in
    ULONG ulActual;	// The no. of pins returned by Next()

    m_nPins = 0;
    do {
        hr = pEnum->Next(1, &pPin, &ulActual);
        if (SUCCEEDED(hr) && (ulActual == 1)) {

            // is this output ?
            PIN_DIRECTION pd;
            hr = pPin->QueryDirection(&pd);
            if (pd == PINDIR_OUTPUT) {
                m_nPins++;
            }
            pPin->Release();
        }
    } while (SUCCEEDED(hr) && (ulActual==1));

    m_paPins = new CImplPin*[m_nPins];
    if (!m_paPins) {
        Notify(TERSE, TEXT("Could not create harness input pins") );
	pEnum->Release();
	return TST_FAIL;
    }

    // connect to each pin
    pEnum->Reset();
    for (int i = 0; i < m_nPins; /* only incr when we get o/p pin */ ) {

        hr = pEnum->Next(1, &pPin, &ulActual);
        if (FAILED(hr) || (ulActual != 1)) {
            Notify(TERSE, TEXT("Error message"));
	    Notify(VERBOSE, TEXT("Actually the enumerator has packed up during it second use"));
	    pEnum->Release();
	    return TST_FAIL;
	};
        ASSERT(pPin);
        ASSERT(ulActual == 1);

        // get the pin name and use that as our name
        PIN_INFO pi;
        hr = pPin->QueryPinInfo(&pi);
	if (FAILED(hr)) {
	    Notify(TERSE, TEXT("Could not QueryPinInfo on pin: %d"), i );
	    pPin->Release();
	    pEnum->Release();
	    return TST_FAIL;
	};
	QueryPinInfoReleaseFilter(pi);

        // we only connect to outputs
        if (pi.dir == PINDIR_OUTPUT) {

            // make an input pin to connect to it
            m_paPins[i] = new CImplPin(
                                m_pFilter,
                                this,
                                &hr,
                                pi.achName);
            ASSERT(m_paPins[i]);

            // connect the pins
            IPin * pOurPin;
            hr = m_paPins[i]->QueryInterface(IID_IPin, (void**) &pOurPin);
            ASSERT(SUCCEEDED(hr));
            ASSERT(pOurPin);

            hr = pPin->Connect(pOurPin,NULL);
            pOurPin->Release();
	    if (FAILED(hr)) {
	        Notify(TERSE, TEXT("Failed to connect pin %d"), i);
		pPin->Release();
		pEnum->Release();
		return TST_FAIL;
	    }

            // increment loop counter now we have a pin
            i++;
        }

        // release their pin. Our pin will have it if it needs it
        pPin->Release();
    }

    // finished with enumerator
    pEnum->Release();

    Notify(VERBOSE, TEXT("Connected to %d pins"), m_nPins);
    return TST_PASS;
}


// Disconnect and release the subject filters interfaces. -> if its refcount
// reaches zero, it should go away...
TESTRES CTestSink::TestDisconnect(void)
{
    if (m_paPins) {
        for (int i = 0; i < m_nPins; i++) {
            if (m_paPins[i]) {

                // call disconnect on both pins
                IPin *pConnected;
                HRESULT hr = m_paPins[i]->ConnectedTo(&pConnected);
                if (FAILED(hr)) {
		    Notify(TERSE, TEXT("Pin %d failed ConnectedTo()"), i);
		    return TST_FAIL;
	        }

                pConnected->Disconnect();
                pConnected->Release();
                m_paPins[i]->Disconnect();

                delete m_paPins[i];
            }
        }
        delete[] m_paPins;
        m_paPins = NULL;
    }

    if (m_pSourceMF) {
        m_pSourceMF->Release();
        m_pSourceMF = NULL;
    }

    if (m_pSource) {
        m_pSource->Release();
        m_pSource = NULL;
    }

    // disconnect source->transform and release m_pSource
    if (m_pTransformInput) {
        m_pTransformInput->Disconnect();
        m_pTransformInput->Release();
        m_pTransformInput = NULL;
    }

    if (m_pSourceOutput) {
        m_pSourceOutput->Disconnect();
        m_pSourceOutput->Release();
        m_pSourceOutput = NULL;
    }

    Notify(TERSE, TEXT("Disconnected"));

    return TST_PASS;
}


// Put the filter into its stopped state. It should free up some of the resources
// it uses - eg worker threads.
TESTRES CTestSink::TestStop(void)
{
    HRESULT hr;

    // no longer running
    m_tBase = CRefTime(0L);
    m_tPausedAt = CRefTime(0L);


    if (m_pSourceMF) {
        hr = m_pSourceMF->Stop();
        if (FAILED(hr)) {
            Notify(TERSE, TEXT("WaveIn->Stop() failed") );
	    return TST_FAIL;
	}
    }

    // don't forget the renderer - ourselves
    hr = m_pFilter->Stop();
    ASSERT (SUCCEEDED(hr));

    return TST_PASS;
}


// The source filter needs to stop pushing data, but be ready to start
// again immediately.
TESTRES CTestSink::TestPause(void)
{
    // are we pausing from running ?
    HRESULT hr;
    if (m_tBase > CRefTime(0L)) {

        // in this case, we need to remember the pause time, so
        // that we can set the correct base time at restart
        hr = m_pClock->GetTime((REFERENCE_TIME *) &m_tPausedAt);
        ASSERT(SUCCEEDED(hr));
    }

    // don't forget the renderer - ourselves
    hr = m_pFilter->Pause();
    ASSERT(SUCCEEDED(hr));

    if (m_pSourceMF) {
        hr = m_pSourceMF->Pause();
	if (FAILED(hr)) {
	    Notify(TERSE, TEXT("WaveIn->Pause failed") );
	    return TST_FAIL;
	}
    }

    return TST_PASS;
}


// Start the filter pushing data.
// **** Should we expect a delay if not paused? Should a filter first be paused
//      in the start posn.?
TESTRES CTestSink::TestRun(void)
{
    HRESULT hr;

    // are we restarting?
    if (m_tPausedAt > CRefTime(0L)) {

        ASSERT(m_tBase > CRefTime(0L));

        // the new base time is the old one plus the length of time
        // we have been paused
        CRefTime tNow;
        hr = m_pClock->GetTime((REFERENCE_TIME *) &tNow);
        ASSERT(SUCCEEDED(hr));

        m_tBase += tNow - m_tPausedAt;

        // we are no longer paused
        m_tPausedAt = CRefTime(0L);

    } else {

        // we are starting from cold.
        ASSERT(m_tBase == CRefTime(0L));
        ASSERT(m_tPausedAt == CRefTime(0L));

        // since the initial stream time will be 0,
        // we need to set the base time to now plus a little
        // processing time (100ms ?)
        hr = m_pClock->GetTime((REFERENCE_TIME *) &m_tBase);
        ASSERT(SUCCEEDED(hr));

        m_tBase += CRefTime(100L);
    }


    // don't forget the renderer - ourselves
    hr = m_pFilter->Run(m_tBase);
    ASSERT(SUCCEEDED(hr));

    if (m_pSourceMF) {
        hr = m_pSourceMF->Run(m_tBase);
	if (FAILED(hr)) {
	    Notify(TERSE, TEXT("WaveIn->Run() failed") );
	    return TST_FAIL;
	}
    }

    return TST_PASS;
}


// log events to the test shell window, using tstLog
// N.B. tstLog accepts only ANSI strings
void
CTestSink::Notify(UINT iLogLevel, LPTSTR szFormat, ...)
{
    va_list va;
    va_start(va, szFormat);

    CHAR *pch = (CHAR *)m_pMalloc->Alloc(128);
#ifdef UNICODE
    WCHAR *pwch = (WCHAR *)m_pMalloc->Alloc(128 * sizeof(WCHAR));

    wvsprintf(pwch, szFormat, va);
    WideCharToMultiByte(GetACP(), MB_PRECOMPOSED, pwch, -1, pch, 128);
    tstLog(iLogLevel, pch);

    m_pMalloc->Free(pwch);
#else
    wvsprintf(pch, szFormat, va);
    tstLog(iLogLevel, pch);
#endif
    m_pMalloc->Free(pch);

    va_end(va);
}

// --- CImplFilter methods ------------

CTestSink::CImplFilter::CImplFilter(CTestSink * pSink, HRESULT * phr)
    : CBaseFilter(NAME("Filter interfaces"), pSink->GetOwner(), pSink, CLSID_NULL)
{
    m_pSink = pSink;
}

CTestSink::CImplFilter::~CImplFilter()
{

}

// --- pin object methods -------------------

CTestSink::CImplPin::CImplPin(
    CBaseFilter* pFilter,
    CTestSink* pSink,
    HRESULT * phr,
    LPCWSTR pPinName)
        : CBaseInputPin(NAME("Input pin"), pFilter, pSink, phr, pPinName)
{
    m_pFilter = pFilter;
    m_pSink = pSink;
}

CTestSink::CImplPin::~CImplPin()
{
}

HRESULT
CTestSink::CImplPin::ProposeMediaType(CMediaType* mt)
{
    // we can't propose anything
    return E_NOTIMPL;
}

HRESULT
CTestSink::CImplPin::CheckMediaType(const CMediaType* mt)
{
    // pick out the type and subtype as a fourcc anyway
    FOURCCMap fccSubtype(mt->Subtype());
    DWORD fst = fccSubtype.GetFOURCC();

    // notify the type
    if (*mt->Type() == MEDIATYPE_Video) {
	m_pSink->Notify(VERBOSE, TEXT("MEDIATYPE_Video (%.4hs)"), &fst);
    } else if (*mt->Type() == MEDIATYPE_Audio) {
	m_pSink->Notify(VERBOSE, TEXT("MEDIATYPE_Audio (%.4hs)"), &fst);
    } else {
	// assume it's a fourcc?
	FOURCCMap fccType(mt->Type());
	DWORD ft = fccType.GetFOURCC();

	m_pSink->Notify(VERBOSE, TEXT("MediaType %.4hs.%.4hs"), &ft, &fst);
    }

    // we accept anything
    return NOERROR;
}

// receive a sample from the upstream pin. We only need to addref or
// release the sample if we hold it after this method returns.
STDMETHODIMP
CTestSink::CImplPin::Receive(IMediaSample * pSample)
{
    HRESULT hr;

    // check all is well with the base class
    hr = CBaseInputPin::Receive(pSample);
    if (hr != S_OK) {
        return hr;
    }

    // how early or late is this?
    CRefTime tStream;
    hr = m_pSink->m_pFilter->StreamTime(tStream);
    ASSERT(SUCCEEDED(hr));

    CRefTime tStart, tLength;
    hr = pSample->GetTime((REFERENCE_TIME *) &tStart,
                          (REFERENCE_TIME *) &tLength);
    ASSERT(SUCCEEDED(hr));

    // this is positive if late
    CRefTime tDelta = tStream - tStart;


    LPTSTR pStream;
    TCHAR achType[16];
    if (*m_mt.Type() == MEDIATYPE_Video) {
	pStream = TEXT("Video");
    } else if (*m_mt.Type() == MEDIATYPE_Audio) {
	pStream = TEXT("Audio");
    } else {
	DWORD fccType;
	fccType = ((FOURCCMap*)m_mt.Type())->GetFOURCC();
	wsprintf(achType, TEXT("(%.4hs)"), &fccType);
	pStream = achType;
    }


    m_pSink->Notify(VERBOSE, TEXT("%s: sample %d..%d msecs at %d (%d)"),
	    pStream,
            tStart.Millisecs(),
            tLength.Millisecs(),
            tStream.Millisecs(),
            tDelta.Millisecs()
            );

    return NOERROR;
}

// flush any pending media samples
STDMETHODIMP
CTestSink::CImplPin::Flush()
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twavein\sink.h ===
//
// CTestSink
//


// we send this to the parent window, with a string that
// the parent should display then free
#define SINKM_NOTIFY    WM_USER


// TstsHell.h defines the results of tests as a set of integer constants...
typedef int TESTRES;

// This is a filter that tests source filters by connecting to them,
// opening a file and connecting an input pin to every output pin.

// it implements IBaseFilter and IMediaFilter via the embedded object
// of class CImplFilter.
// it also exposes test methods called from menu items in main.cpp


class CTestSink : public CUnknown, public CCritSec
{

public:
    CTestSink(LPUNKNOWN pUnk, HRESULT * phr, HWND hwnd);
    ~CTestSink();

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // pin enumerator calls these
    int GetPinCount() {
        return m_nPins;
    };
    CBasePin * GetPin(int n);

    // methods called by the test app

    TESTRES TestConnect(void);
    TESTRES TestDisconnect(void);
    TESTRES TestStop(void);
    TESTRES TestPause(void);
    TESTRES TestRun(void);

    // log events via the test shell
    // iLogLevel can be TERSE or VERBOSE
    void Notify(UINT iLogLevel, LPTSTR szFormat, ...);

    // --- nested classes ------

    // implements IBaseFilter, IMediaFilter
    class CImplFilter : public CBaseFilter
    {
    private:
        CTestSink * m_pSink;

    public:
        CImplFilter(CTestSink * pSink, HRESULT * phr);
        ~CImplFilter();

        // map pin enumerator exports to owner
        int GetPinCount() {
            return m_pSink->GetPinCount();
        };
        CBasePin * GetPin(int n) {
            return m_pSink->GetPin(n);
        };

    };


    // one of these for each input pin we expose, implements IPin
    // and IMemInputPin
    class CImplPin : public CBaseInputPin
    {
    private:
        CBaseFilter* m_pFilter;
        CTestSink* m_pSink;

    public:
        CImplPin(
            CBaseFilter* pFilter,
            CTestSink* pSink,
            HRESULT * phr,
            LPCWSTR pPinName);
        ~CImplPin();

        // override pure virtual - return the media type supported
        HRESULT ProposeMediaType(CMediaType* mt);
        // check that we can support this output type
        HRESULT CheckMediaType(const CMediaType* mt);

        // --- IMemInputPin -----

        // here's the next block of data from the stream.
        // AddRef it if you need to hold it.
        STDMETHODIMP Receive(IMediaSample * pSample);

        // flush any pending media samples (if possible)
        STDMETHODIMP Flush();

    };

private:
    friend class CImplPin;
    friend class CImplFilter;

    CImplFilter * m_pFilter;

    CImplPin ** m_paPins;   // Array of pins which currently exist.
                            // ??? Hm!  Ours or theirs I wonder.  Theirs I think.
    int m_nPins;            // number of pins currently in m_paPins


    // connected filter
    // kept here as no actual pins may be connected yet
//    IBaseFilter * m_pConnected;   // ??? source filter we connect to
    IBaseFilter * m_pSource;
    IPin * m_pTransformInput;   // used for disconnect
    IPin * m_pSourceOutput;     // used for disconnect


    // we use this to start/stop the source filter
//    IMediaFilter * m_pConnectMF;   // ??? MediaFilter interface to source filter we connect to
    IMediaFilter * m_pSourceMF;

    // the reference clock we are using
    IReferenceClock * m_pClock;

    // base time offset from streamtime to reference time
    CRefTime m_tBase;

    // time at which we paused
    CRefTime m_tPausedAt;

    // window to which we notify interesting happenings
    HWND m_hwndParent;

    // task allocator
    IMalloc * m_pMalloc;

    // connect to any exposed output pins on m_pConnected
    TESTRES MakePinConnections(void);

    // instantiate the source
    IBaseFilter * MakeSourceFilter(void);
};

// ??? The rules as to what other filters it has and what is connecte to what
// ??? and when are not obvious to the reader.
// ??? Explanatory comments are needed for the following:
// ??? IMediaFilter     * m_pConnectMF
// ??? IBaseFilter      * m_pSourceMF
// ??? IBaseFilter      * m_pConnected
// ??? IPin             * m_pTransformInput
// ??? IPin             * m_pSourceOutput
// ??? IBaseFilter      * m_pSource
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twavein\twavein.cpp ===
//--------------------------------------------------------------------------;
//
//  File: twavein.cpp
//
//  Copyright (c) 1993,1996 Microsoft Corporation.  All rights reserved
//
//  Abstract:
//
//  Contents:
//      tstGetTestInfo()
//      MenuProc()
//      InitOptionsMenu()
//      tstInit()
//      execTest()
//      tstTerminate()
//      tstAppWndProc()
//      dprintf()
//
//  History:
//      08/03/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//      15-Mar-95   v-mikere - Quartz sample test app
//      4-Apr-95    t-jmcal  - Used as template to become the WaveIn
//                             filter unit test
//
//--------------------------------------------------------------------------;

#include <streams.h>    // Streams architecture
#include <windowsx.h>   // Windows macros etc.
#include <tstshell.h>   // Include file for the test shell's APIs
#include "sink.h"       // Test sink definition
#include "twavein.h"    // Various includes, constants, prototypes, globals


// Globals

HWND    ghwndTstShell;  // A handle to the main window of the test shell.
                        // It's not used here, but may be used by test apps.

HINSTANCE hinst;        // A handle to the running instance of the test
                        // shell.  It's not used here, but may be used by
                        // test apps.

HMENU   hmenuOptions;   // A handle to the options menu

CTestSink   *gpSink;    // Test sink object for all the tests


// App Name
#ifdef _WIN32
LPSTR           szAppName = "Quartz WaveIn Sample test app - Win32";
#else
LPSTR           szAppName = "Quartz WaveIn Sample test app - Motown";
#endif

//--------------------------------------------------------------------------;
//
//  int tstGetTestInfo
//
//  Description:
//      Called by the test shell to get information about the test.  Also
//      saves a copy of the running instance of the test shell.
//
//  Arguments:
//      HINSTANCE hinstance: A handle to the running instance of the test
//          shell
//
//      LPSTR lpszTestName: Pointer to buffer of name for test.  Among
//          other things, it is used as a caption for the main window and
//          as the name of its class.
//
//      LPSTR lpszPathSection: Pointer to buffer of name of section in
//          win.ini in which the default input and output paths are
//          stored.
//
//      LPWORD wPlatform: The platform on which the tests are to be run,
//          which may be determined dynamically.  In order for a test to
//          be shown on the run list, it must have all the bits found in
//          wPlatform turned on.  It is enough for one bit to be turned off
//          to disqualify the test.  This also means that if this value is
//          zero, all tests will be run.  In order to make this more
//          mathematically precise, I shall give the relation which Test
//          Shell uses to decide whether a test with platform flags
//          wTestPlatform may run:  It may run if the following is TRUE:
//          ((wTestPlatform & wPlatform) == wPlatform)
//
//  Return (int):
//      The value which identifies the test list resouce (found in the
//      resource file).
//
//  History:
//      08/03/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

int tstGetTestInfo
(
    HINSTANCE   hinstance,
    LPSTR       lpszTestName,
    LPSTR       lpszPathSection,
    LPWORD      wPlatform
)
{
    hinst = hinstance;      // Save a copy of a handle to the running instance
    lstrcpyA (lpszTestName, szAppName);
    lstrcpyA (lpszPathSection, szAppName);
    *wPlatform = 0;         // The platform the test is running on, to be
                            // determined dynamically.
    return TEST_LIST;
} // tstGetTestInfo()



//--------------------------------------------------------------------------;
//
//  void InitOptionsMenu
//
//  Description:
//      Creates an additional app-specific menu.  Note that this
//      function is called from within tstInit as all menu installations
//      MUST be done in tstInit or else the app's behavior is undefined.
//      Also note the calls to tstInstallCustomTest which is a shell API
//      that allows custom installation of tests.  From tstshell version
//      2.0 on, it is possible to install menus the usual way and trap the
//      appropriate window messages, though the method presented here is
//      still the preferred one for Test Applications to use.
//
//      For the Quartz tests, complete menu structures and window procs
//      exist, so it is simpler to just load and append the existing menu
//      resources than to call tstInstallCustomTest once for each menu
//      option.  The window message handling is incorporated in
//      tstAppWndProc.
//
//  Arguments:
//      LRESULT (CALLBACK* MenuProc)(HWND,UINT,WPARAM,LPARAM):
//          The menu function (not used in the Quartz tests).
//
//  Return (BOOL):
//      TRUE if menu installation is successful, FALSE otherwise
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//      15-Mar-95   v-mikere - Quartz sample test app
//
//--------------------------------------------------------------------------;

BOOL InitOptionsMenu
(
    LRESULT (CALLBACK* MenuProc)(HWND, UINT, WPARAM, LPARAM)
)
{
    HMENU   hWaveInMenu;

    if (NULL == (hWaveInMenu = LoadMenu(hinst, TEXT("twaveinMenu"))))
    {
        return(FALSE);
    }

    if
    (
        !AppendMenu(GetMenu(ghwndTstShell),
                    MF_POPUP,
                    (UINT) hWaveInMenu,
                    TEXT("&WaveIn"))
    )
    {
        return(FALSE);
    }

    DrawMenuBar(ghwndTstShell);
    return TRUE;
}



//--------------------------------------------------------------------------;
//
//  BOOL tstInit
//
//  Description:
//      Called by the test shell to provide the test program with an
//      opportunity to do whatever initialization it needs to do before
//      user interaction is initiated.  It also provides the test program
//      with an opportunity to keep a copy of a handle to the main window,
//      if the test program needs it.  In order to use some of the more
//      advanced features of test shell, several installation must be done
//      here:
//
//      -- All menu installation must be done here by calling
//          tstInstallCustomTest (that is, all menus that the test
//          application wants to add).
//
//      -- If the test application wants to trap the window messages of
//          the main test shell window, it must install its default
//          window procedure here by calling tstInstallDefWindowProc.
//
//      -- If the test application would like to use the status bar for
//          displaying the name of the currently running test, it must
//          call tstDisplayCurrentTest here.
//
//      -- If the test application would like to change the stop key from
//          ESC to something else, it must do so here by calling
//          tstChangeStopVKey.
//
//      -- If the test application would like to add dynamic test cases
//          to the test list, it must first add their names to the
//          virtual string table using tstAddNewString (and add their
//          group's name too), and then add the actual tests using
//          tstAddTestCase.  The virtual string table is an abstraction
//          which behaves just like a string table from the outside with
//          the exception that it accepts dynamically added string.
//
//  Arguments:
//      HWND hwndMain: A handle to the main window
//
//  Return (BOOL):
//      TRUE if initialization went well, FALSE otherwise which will abort
//      execution.
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

BOOL tstInit
(
    HWND    hwndMain
)
{
    HRESULT     hr;


    QzInitialize(NULL);            // Initialise COM library
    DbgInitialise(hinst);

    // It might have been nice to have this a few lines earlier
    // - but we gotta do DbgInitialise first!
    DbgLog((LOG_TRACE, 1, TEXT("Entering tstInit")));

    // Create the test sink object

    gpSink = new CTestSink(NULL, &hr, ghwndTstShell);
    ASSERT(gpSink);
    ASSERT(SUCCEEDED(hr));

    // initially it has a ref count of 0.
    gpSink->NonDelegatingAddRef();

   // Keep a copy of a handle to the main window
    ghwndTstShell = hwndMain;

    // Installs a default windows procedure which may handle messages
    // directed to Test Shell's main window.  It is vital to note that
    // this window function is substituted for DefWindowProc and not in
    // addition to it, and therefore DefWindowProc MUST be called from
    // within it in the default case (look at tstAppWndProc for an example).
    tstInstallDefWindowProc (tstAppWndProc);

    // Install the custom menus.  Look at InitOptionsMenu for more details.
    if (InitOptionsMenu(NULL)==FALSE)
        return FALSE;  // If menu installation failed, abort execution

    // This is a shell API which tells Test Shell to display the name of
    // the currenly executing API in its status bar.  It is a really nice
    // feature for test applications which do not use the toolbar for any
    // other purpose, as it comfortably notifies the user of the progress
    // of the tests.
    tstDisplayCurrentTest();

    // Change the stop key from ESC to SPACE
    tstChangeStopVKey (VSTOPKEY);

    // Add the names of the dynamic tests and dynamic groups to the
    // virtual string table.  Before the tests are added, it is important
    // to add their names, as the name ID is required by tstAddTestCase.
//    tstAddNewString (ID_TESTLAST + 1, (LPSTR) "The first test added dynamically");
//    tstAddNewString (GRP_LAST + 1, (LPSTR) "A dynamically added group");
//    tstAddNewString (ID_TESTLAST + 2, (LPSTR) "The first test in a dynamically added group");

    // Add test cases dynamically.  Note that these test cases will execute
    // on any platform, since they are added dynamically.  Real test
    // applications probably want to check the run environment and then
    // add dynamic test cases selectively.
//    tstAddTestCase (ID_TESTLAST + 1, TST_AUTOMATIC, FX_TEST1, GRP_ONE);
//    tstAddTestCase (ID_TESTLAST + 2, TST_AUTOMATIC, FX_TEST1, GRP_LAST + 1);

    DbgLog((LOG_TRACE,1, TEXT("Exiting tstInit")));
    return(TRUE);
} // tstInit()




//--------------------------------------------------------------------------;
//
//  int execTest
//
//  Description:
//      This is the actual test function which is called from within the
//      test shell.  It is passed various information about the test case
//      it is asked to run, and branches off to the appropriate test
//      function.  Note that it needs not switch on nFxID, but may also
//      use iCase or wID.
//
//  Arguments:
//      int nFxID: The test case identifier, also found in the third column
//          in the third column of the test list in the resource file
//
//      int iCase: The test case's number, which expresses the ordering
//          used by the test shell.
//
//      UINT wID: The test case's string ID, which identifies the string
//          containing the description of the test case.  Note that it is
//          also a good candidate for use in the switch statement, as it
//          is unique to each test case.
//
//      UINT wGroupID: The test case's group's string ID, which identifies
//          the string containing the description of the test case's group.
//
//  Return (int): Indicates the result of the test by using TST_FAIL,
//          TST_PASS, TST_OTHER, TST_ABORT, TST_TNYI, TST_TRAN, or TST_TERR
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

int execTest
(
    int     nFxID,
    int     iCase,
    UINT    wID,
    UINT    wGroupID
)
{
    int ret = TST_OTHER;

    tstBeginSection(" ");

    switch(nFxID)
    {
        //
        //  The test cases
        //

        case FX_TEST1:
            ret = execTest1();
            break;

        case FX_TEST2:
            ret = execTest2();
            break;

        case FX_TEST3:
            ret = execTest3();
            break;

        case FX_TEST4:
            ret = execTest4();
            break;

        default:
            break;
    }

    tstEndSection();

    return(ret);

//Abort:
    return(TST_ABORT);
} // execTest()




//--------------------------------------------------------------------------;
//
//  void tstTerminate
//
//  Description:
//      This function is called when the test series is finished to free
//      structures and do whatever cleanup work it needs to do.  If it
//      needs not do anything, it may just return.
//
//  Arguments:
//      None.
//
//  Return (void):
//
//  History:
//      06/08/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

void tstTerminate
(
    void
)
{
    DbgLog((LOG_TRACE, 1, TEXT("Entering tstTerminate")));

    gpSink->NonDelegatingRelease();

    DbgTerminate();
    QzUninitialize();

    DbgLog((LOG_TRACE, 1, TEXT("Exiting tstTerminate")));
    return;
} // tstTerminate()




//--------------------------------------------------------------------------;
//
//  LRESULT tstAppWndProc
//
//  Description:
//      This shows how a test application can trap the window messages
//      received by the main Test Shell window.  It is installed in
//      in tstInit by calling tstInstallDefWindowProc, and receives
//      all window messages since.  This allows the test application to
//      be notified of certain event via a window without creating its
//      own hidden window or waiting in a tight PeekMessage() loop.  Note
//      that it is extremely important to call DefWindowProcA in the default
//      case as that is NOT done in tstshell's main window procedure if
//      tstInstallDefWindowProc is used.  DefWindowProcA has to be used as the
//      test shell main window is an ANSI window.
//
//  Arguments:
//      HWND hWnd: A handle to the window
//
//      UINT msg: The message to be processed
//
//      WPARAM wParam: The first parameters, meaning depends on msg
//
//      LPARAM lParam: The second parameter, meaning depends on msg
//
//  Return (LRESULT):
//
//  History:
//      08/03/93    T-OriG   - sample test app
//      9-Mar-95    v-mikere - adapted for Quartz source filter tests
//
//--------------------------------------------------------------------------;

LRESULT FAR PASCAL tstAppWndProc
(
    HWND    hWnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    switch (msg)
    {
        case WM_COMMAND:

        switch (GET_WM_COMMAND_ID(wParam, lParam)) {

            case IDM_DISCONNECT:
                gpSink->TestDisconnect();
                return 0;

            case IDM_CONNECT:
                gpSink->TestConnect();
                return 0;

            case IDM_STOP:
                gpSink->TestStop();
                return 0;

            case IDM_PAUSE:
                gpSink->TestPause();
                return 0;

            case IDM_RUN:
                gpSink->TestRun();
                return 0;
        }
        break;
    }
    return DefWindowProcA (hWnd, msg, wParam, lParam);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twaveout\twfilter.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
// Wave out test shell, David Maymudes, Sometime in 1995

#include <streams.h>
#include <windows.h>
#include <ole2.h>
#include <wxdebug.h>
#include <mmsystem.h>
#include <waveout.h>
#include "twaveout.h"


/* Constructor */

CShell::CImplFilter::CImplFilter(
    CShell *pShell,
    HRESULT *phr)
    : CBaseFilter(NAME("Filter interfaces"), pShell->GetOwner(), pShell, CLSID_NULL)
{
    m_pShell = pShell;
}


/* Return our single output pin - not AddRef'd */

CBasePin *CShell::CImplFilter::GetPin(int n)
{
    /* We only support one output pin and it is numbered zero */

    ASSERT(n == OUTPUTSHELLPIN);
    if (n != OUTPUTSHELLPIN) {
        return NULL;
    }

    /* Return the pin not AddRef'd */
    return m_pShell->m_pOutputPin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\wavein\wavein.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.

/*  Implements a digital audio source using waveInXXX apis */
/*            David Maymudes          */
/*              January 1995            */


extern const AMOVIESETUP_FILTER sudwaveInFilter ;

struct AUDIO_FORMAT_INFO  
{   
    DWORD dwType;
    WORD  wBitsPerSample;
    WORD  nChannels;
    DWORD nSamplesPerSec;
};

// This is the default list of formats types (in quality order) that we'll offer
// in GetMediaType. We use 2 arrays to build this list:
//      1) An array of defined formats in mmsystem.h that use waveInGetDevsCaps
//         info to build the list. 
//      2) An array of extra formats that aren't explicitly defined in mmsystem.h 
//         (so far we only do this for 8kHz types). We query the device directly for 
//         support of these types.

#define NO_CAPS_FLAG_FORMAT 0 

static const AUDIO_FORMAT_INFO g_afiFormats[] = 
{ 
    // let's assume 44.1k should be the default format
    {  WAVE_FORMAT_4S16,    16,  2,  44100 },
    {  WAVE_FORMAT_4M16,    16,  1,  44100 },
    {  NO_CAPS_FLAG_FORMAT, 16,  2,  32000 },
    {  NO_CAPS_FLAG_FORMAT, 16,  1,  32000 },
    {  WAVE_FORMAT_2S16,    16,  2,  22050 },
    {  WAVE_FORMAT_2M16,    16,  1,  22050 },
    {  WAVE_FORMAT_1S16,    16,  2,  11025 },
    {  WAVE_FORMAT_1M16,    16,  1,  11025 },
    {  NO_CAPS_FLAG_FORMAT, 16,  2,   8000 },
    {  NO_CAPS_FLAG_FORMAT, 16,  1,   8000 },
    {  WAVE_FORMAT_4S08,    8,   2,  44100 },
    {  WAVE_FORMAT_4M08,    8,   1,  44100 },
    {  WAVE_FORMAT_2S08,    8,   2,  22050 },
    {  WAVE_FORMAT_2M08,    8,   1,  22050 },
    {  WAVE_FORMAT_1S08,    8,   2,  11025 },
    {  WAVE_FORMAT_1M08,    8,   1,  11025 },
    {  NO_CAPS_FLAG_FORMAT, 8,   2,   8000 },
    {  NO_CAPS_FLAG_FORMAT, 8,   1,   8000 },
    //
    // now a few formats for those digital pro cards that can be set to only accept 1 type
    //
    // note that caps flags were added for 48kHz and 96kHz in Whistler, but
    // in order to be backwards compatible we can't depend on those
    //
    //{  WAVE_FORMAT_48S16,   16,  2,  48000 },
    //{  WAVE_FORMAT_48M16,   16,  1,  48000 },
    //{  WAVE_FORMAT_96S16,   16,  2,  96000 },
    //{  WAVE_FORMAT_96M16,   16,  1,  96000 }
    {  NO_CAPS_FLAG_FORMAT,   16,  2,  48000 },
    {  NO_CAPS_FLAG_FORMAT,   16,  1,  48000 },
    {  NO_CAPS_FLAG_FORMAT,   16,  2,  96000 },
    {  NO_CAPS_FLAG_FORMAT,   16,  1,  96000 }
};

// initialize to number of types in above array
static const DWORD g_cMaxFormats = 
                        sizeof(g_afiFormats)/sizeof(g_afiFormats[0]); 

// store the maximum types we could have. this include the format array, plus one for
// the default type.
static const DWORD g_cMaxPossibleTypes = g_cMaxFormats + 1;

// CNBQueue
//
// Non blocking version of active movie queue class
// 

template <class T> class CNBQueue {
private:
    HANDLE          hSemPut;        // Semaphore controlling queue "putting"
    HANDLE          hSemGet;        // Semaphore controlling queue "getting"
    CRITICAL_SECTION CritSect;      // Thread seriallization
    int             nMax;           // Max objects allowed in queue
    int             iNextPut;       // Array index of next "PutMsg"
    int             iNextGet;       // Array index of next "GetMsg"
    T             **QueueObjects;   // Array of objects (ptr's to void)

    HRESULT Initialize(int n) {
        iNextPut = iNextGet = 0;
        nMax = n;
        InitializeCriticalSection(&CritSect);
        hSemPut = CreateSemaphore(NULL, n, n, NULL);
        hSemGet = CreateSemaphore(NULL, 0, n, NULL);

        QueueObjects = new T*[n];
        if( NULL == hSemPut || NULL == hSemGet || NULL == QueueObjects )
        {
            return E_OUTOFMEMORY;
        }
        return S_OK;
    }


public:
    CNBQueue(int n, HRESULT *phr) {
        *phr = Initialize(n);
    }

    CNBQueue( HRESULT *phr ) {
        *phr = Initialize(DEFAULT_QUEUESIZE);
    }

    ~CNBQueue() {
        delete [] QueueObjects;
        DeleteCriticalSection(&CritSect);
        CloseHandle(hSemPut);
        CloseHandle(hSemGet);
    }

    T *GetQueueObject(BOOL fBlock = TRUE) {
        int iSlot;
        T *pObject;
        LONG lPrevious;

        if (fBlock) {
            WaitForSingleObject(hSemGet, INFINITE);
        } else {
            //
            // Check for something on the queue but don't wait.  If there
            //  is nothing in the queue then we'll let the caller deal with
            //  it.
            //
            DWORD dwr = WaitForSingleObject(hSemGet, 0);
            if (dwr == WAIT_TIMEOUT) {
                return NULL;
            }
        }

        EnterCriticalSection(&CritSect);
        iSlot = iNextGet;
        iNextGet = (iNextGet + 1) % nMax;
        pObject = QueueObjects[iSlot];
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to put an object onto our queue as there
        // is now space available in the queue.
        //
        ReleaseSemaphore(hSemPut, 1L, &lPrevious);
        return pObject;
    }

    void PutQueueObject(T *pObject) {
        int iSlot;
        LONG lPrevious;

        // Wait for someone to get something from our queue, returns straight
        // away is there is already an empty slot on the queue.
        //
        WaitForSingleObject(hSemPut, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextPut;
        iNextPut = (iNextPut + 1) % nMax;
        QueueObjects[iSlot] = pObject;
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to remove an object from our queue as there
        // is now an object available to be removed.
        //
        ReleaseSemaphore(hSemGet, 1L, &lPrevious);
    }
};


class CWaveInSample : public CMediaSample
{
public:
   CWaveInSample(
       IMemAllocator *pAllocator,
       HRESULT *phr,
       LPWAVEHDR pwh)
       :
       m_pwh(pwh),
       CMediaSample(NAME("WaveIn Sample"),
                    (CBaseAllocator *)pAllocator,
                    phr,
                    (LPBYTE)pwh->lpData,
                    (LONG)pwh->dwBufferLength)
       {
       };

   LPWAVEHDR GetWaveInHeader() {return m_pwh;};

private:
   const LPWAVEHDR m_pwh;
};


/* This is an allocator based on the abstract CBaseAllocator class
   that allocates sample buffers  */

class CWaveInAllocator : public CBaseAllocator
{
    LPWAVEFORMATEX	m_lpwfxA;
    BOOL		m_fBuffersLocked;
    HWAVE		m_hw;
    DWORD               m_dwAdvise;
    CNBQueue<CWaveInSample> *m_pQueue;
    CNBQueue<CWaveInSample> *m_pDownQueue;

protected:
    CCritSec m_csDownQueue;	// to protect dicking with the down queue

private:
    // override this to free the memory when we are inactive
    void Free(void);

    // override this to allocate and prepare memory when we become active
    HRESULT Alloc(void);
    STDMETHODIMP Commit(void);

    // called by CMediaSample to return it to the free list and
    // block any pending GetSample call.
    STDMETHODIMP ReleaseBuffer(IMediaSample * pSample);

    // to avoid wave driver bugs
    BOOL m_fAddBufferDangerous;

public:

    /* Constructors and destructors */

    CWaveInAllocator(
        TCHAR *pName,
        LPWAVEFORMATEX lpwfx,
        HRESULT *phr);
    ~CWaveInAllocator();

    STDMETHODIMP SetProperties(
        ALLOCATOR_PROPERTIES* pRequest,
        ALLOCATOR_PROPERTIES* pActual
    );

    HRESULT LockBuffers(BOOL fLock = TRUE);
    HRESULT SetWaveHandle(HWAVE hw = NULL);

    friend class CWaveInFilter;
    friend class CWaveInWorker;
    friend class CWaveInOutputPin;
};


class CWaveInFilter;
class CWaveInOutputPin;

/* This is the COM object that represents a simple rendering filter. It
   supports IBaseFilter and IMediaFilter and has a single input stream (pin)

   It will also (soon!) support IDispatch to allow it to expose some
   simple properties....

*/


// worker thread object
class CWaveInWorker : public CAMThread
{

    CWaveInOutputPin * m_pPin;

    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    void DoRunLoop(void);

public:
    CWaveInWorker();

    BOOL Create(CWaveInOutputPin * pPin);

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT Run();
    HRESULT Stop();

    HRESULT Exit();
};



/* Class supporting the renderer input pin */

//
// This pin is still a separate object in case it wants to have a distinct
// IDispatch....
//
class CWaveInOutputPin : public CBaseOutputPin, public IAMStreamConfig,
			 public IAMBufferNegotiation, public CBaseStreamControl,
			 public IKsPropertySet, public IAMPushSource
{
    friend class CWaveInFilter;
    friend class CWaveInWorker;

private:

    CWaveInFilter *m_pFilter;         // The renderer that owns us

    CWaveInAllocator   *m_pOurAllocator;
    BOOL	    	m_fUsingOurAllocator;
    CWaveInWorker  	m_Worker;
    BOOL		m_fLastSampleDiscarded;
    REFERENCE_TIME	m_rtLastTimeSent;

    // for IAMBufferNegotiation
    ALLOCATOR_PROPERTIES m_propSuggested;

public:

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    CWaveInOutputPin(
	CWaveInFilter *pWaveInFilter,
	HRESULT *phr,
	LPCWSTR pPinName);

    ~CWaveInOutputPin();

    // IKsPropertySet stuff
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);
    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData,
		DWORD *pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID,
		DWORD *pTypeSupport);

    // IAMStreamConfig stuff
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt);
    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize);
    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC);

    // helper function for GetStreamCaps
    STDMETHODIMP InitWaveCaps(BOOL *pfDoesStereo, BOOL *pfDoes96, BOOL *pfDoes48, 
                              BOOL *pfDoes44,     BOOL *pfDoes22, BOOL *pfDoes16);

    HRESULT InitMediaTypes(void);

    /* IAMBufferNegotiation methods */
    STDMETHODIMP SuggestAllocatorProperties(const ALLOCATOR_PROPERTIES *prop);
    STDMETHODIMP GetAllocatorProperties(ALLOCATOR_PROPERTIES *pprop);

    // IAMPushSource
    STDMETHODIMP SetPushSourceFlags(ULONG Flags);
    STDMETHODIMP GetPushSourceFlags(ULONG *pFlags);
    STDMETHODIMP GetLatency( REFERENCE_TIME  *prtLatency );
    STDMETHODIMP SetStreamOffset( REFERENCE_TIME  rtOffset );
    STDMETHODIMP GetStreamOffset( REFERENCE_TIME  *prtOffset );
    STDMETHODIMP GetMaxStreamOffset( REFERENCE_TIME  *prtMaxOffset );
    STDMETHODIMP SetMaxStreamOffset( REFERENCE_TIME  rtMaxOffset );

    // return the allocator interface that this input pin
    // would like the output pin to use
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    // tell the input pin which allocator the output pin is actually
    // going to use.
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator);

    /* Lets us know where a connection ends */
    HRESULT BreakConnect();

    // enumerate supported input types
    HRESULT GetMediaType(int iPosition,CMediaType *pmt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType *pmt);

    // start using this mediatype
    HRESULT SetMediaType(const CMediaType *pmt);

    // negotiate the allocator and its buffer size/count
    // calls DecideBufferSize to call SetCountAndSize
    HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);

    // override this to set the buffer size and count. Return an error
    // if the size/count is not to your liking
    HRESULT DecideBufferSize(IMemAllocator * pAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);

    /* IMemInputPin virtual methods */

    /* Here's the next block of data from the stream.
       AddRef it if you are going to hold onto it. */
    STDMETHODIMP Receive(IMediaSample *pSample);

    void Reconnect();

    // override so we can decommit and commit our own allocator
    HRESULT Active(void);
    HRESULT Inactive(void);

    // for IAMStreamControl
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();

    // for IAMStreamOffset
    REFERENCE_TIME m_rtLatency;
    REFERENCE_TIME m_rtStreamOffset;
    REFERENCE_TIME m_rtMaxStreamOffset;

};


class CWaveInInputPin : public CBaseInputPin, public IAMAudioInputMixer
{
public:
    CWaveInInputPin(
        TCHAR *pObjectName,
        CWaveInFilter *pFilter,
	DWORD	dwLineID,
	DWORD dwMuxIndex,
        HRESULT * phr,
        LPCWSTR pName);

    virtual ~CWaveInInputPin();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition, CMediaType*pmt);

    // IAMAudioInputMixer methods
    STDMETHODIMP put_Enable(BOOL fEnable);
    STDMETHODIMP get_Enable(BOOL *pfEnable);
    STDMETHODIMP put_Mono(BOOL fMono);
    STDMETHODIMP get_Mono(BOOL *pfMono);
    STDMETHODIMP put_Loudness(BOOL fLoudness);
    STDMETHODIMP get_Loudness(BOOL *pfLoudness);
    STDMETHODIMP put_MixLevel(double Level);
    STDMETHODIMP get_MixLevel(double FAR* pLevel);
    STDMETHODIMP put_Pan(double Pan);
    STDMETHODIMP get_Pan(double FAR* pPan);
    STDMETHODIMP put_Treble(double Treble);
    STDMETHODIMP get_Treble(double FAR* pTreble);
    STDMETHODIMP get_TrebleRange(double FAR* pRange);
    STDMETHODIMP put_Bass(double Bass);
    STDMETHODIMP get_Bass(double FAR* pBass);
    STDMETHODIMP get_BassRange(double FAR* pRange);

private:
    HRESULT GetMixerControl(DWORD dwControlType, HMIXEROBJ *pID,
					int *pcChannels, MIXERCONTROL *pmc, DWORD dWLineID = 0xffffffff);
    // different version for BPC hack
    HRESULT GetMixerControlBPC(DWORD dwControlType, HMIXEROBJ *pID,
					int *pcChannels, MIXERCONTROL *pmc);

    CWaveInFilter * m_pFilter;  // parent
    DWORD	m_dwLineID;	// which input this pin controls
    double	m_Pan;		// the last value set by put_Pan
    
    DWORD	m_dwMuxIndex;
};


class CWaveInFilter : public CBaseFilter, public CCritSec,
		      public IAMAudioInputMixer,
                      public IPersistPropertyBag,
                      public CPersistStream,
                      public IAMResourceControl,
                      public ISpecifyPropertyPages,
                      public IAMFilterMiscFlags
{

public:
    // Implements the IBaseFilter and IMediaFilter interfaces

    DECLARE_IUNKNOWN
	
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    // for IAMStreamControl
    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

    // IAMAudioInputMixer methods
    STDMETHODIMP put_Enable(BOOL fEnable) { return E_NOTIMPL;};
    STDMETHODIMP get_Enable(BOOL *pfEnable) { return E_NOTIMPL;};
    STDMETHODIMP put_Mono(BOOL fMono);
    STDMETHODIMP get_Mono(BOOL *pfMono);
    STDMETHODIMP put_Loudness(BOOL fLoudness);
    STDMETHODIMP get_Loudness(BOOL *pfLoudness);
    STDMETHODIMP put_MixLevel(double Level);
    STDMETHODIMP get_MixLevel(double FAR* pLevel);
    STDMETHODIMP put_Pan(double Pan);
    STDMETHODIMP get_Pan(double FAR* pPan);
    STDMETHODIMP put_Treble(double Treble);
    STDMETHODIMP get_Treble(double FAR* pTreble);
    STDMETHODIMP get_TrebleRange(double FAR* pRange);
    STDMETHODIMP put_Bass(double Bass);
    STDMETHODIMP get_Bass(double FAR* pBass);
    STDMETHODIMP get_BassRange(double FAR* pRange);

    // IPersistPropertyBag methods
    STDMETHOD(InitNew)(THIS);
    STDMETHOD(Load)(THIS_ LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(THIS_ LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                    BOOL fSaveAllProperties);

    STDMETHODIMP GetClassID(CLSID *pClsid);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();

    HRESULT CreatePinsOnLoad();
    HRESULT LoadDefaultType();

    // IAMResourceControl
    STDMETHODIMP Reserve(
        /*[in]*/ DWORD dwFlags,          //  From _AMRESCTL_RESERVEFLAGS enum
        /*[in]*/ PVOID pvReserved        //  Must be NULL
    );

    ULONG STDMETHODCALLTYPE GetMiscFlags(void) { return AM_FILTER_MISC_FLAGS_IS_SOURCE; }

private:
    HRESULT GetMixerControl(DWORD dwControlType, HMIXEROBJ *pID,
					int *pcChannels, MIXERCONTROL *pmc);
public:

    CWaveInFilter(
        LPUNKNOWN pUnk,
        HRESULT *phr);

    virtual ~CWaveInFilter();

    /* Return the pins that we support */

    int GetPinCount();
    CBasePin *GetPin(int n);

    /* Override this to say what interfaces we support and where */

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // open the wave device if not already open
    // called by the wave allocator at Commit time
    HRESULT OpenWaveDevice( WAVEFORMATEX *pwfx = NULL );
    void CloseWaveDevice();

    //
    // --- ISpecifyPropertyPages ---
    //

    STDMETHODIMP GetPages(CAUUID *pPages);

private:

    void MakeSomeInputPins(int id, HRESULT *phr);

    /* The nested classes may access our private state */

    friend class CWaveInOutputPin;
    friend class CWaveInWorker;

    /* Member variables */
    CWaveInOutputPin *m_pOutputPin;      /* IPin interface */

    CRefTime	m_rtCurrent;
    BOOL	    m_fStopping;
    DWORD       m_ulPushSourceFlags;

    LONGLONG	m_llCurSample;	// which sample number is at beginning of buffer
    REFERENCE_TIME m_llBufferTime; // clock time for 1st sample in buffer
    int		m_nLatency;	// hack for latency

    DWORD	m_dwDstLineID;	// "recording controls" line
    HWAVEIN	m_hwi;
    struct
    {
        int devnum;             // which wave card to use?
        BOOL fSet;              // set through Load?
    } m_WaveDeviceToUse;

    // BPC
    BOOL m_fUseMixer;

    int 	m_cInputPins;				// how many?
    double	m_Pan;		// the last value set by put_Pan

    int     m_cTypes;                             // number of supported types
    LPWAVEFORMATEX m_lpwfxArray[g_cMaxPossibleTypes]; // the max size needed for our
                                                      // array of supported types (including 
                                                      // 1 extra for the default type)

public:
    DWORD m_dwLockCount;                 // For IAMResourceLock

private:
// !!! better be enough
#define MAX_INPUT_PINS 25
    CWaveInInputPin *m_pInputPin[MAX_INPUT_PINS];	// our input pins

    //IReferenceClock *m_pReferenceClock;     // Our reference clock
                                            // ??? Highly dubious.
                                            // our own, or external?

    static void WaveInCallback(HDRVR hdrvr, UINT uMsg, DWORD_PTR dwUser,
					DWORD_PTR dw1, DWORD_PTR dw2);

    friend class CWaveInInputPin;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twaveout\twpin.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
// Wave out test shell, David Maymudes, Sometime in 1995

#include <streams.h>
#include <windows.h>
#include <windowsx.h>
#include <ole2.h>
#include <wxdebug.h>
#include <mmsystem.h>
#include <waveout.h>
#include "twaveout.h"


// defined in twaveout.cpp - defines the currently loaded wave file
extern WAVEFORMATEX g_wfx;

// defined in twaveout.cpp - using the WAVEOUT allocator - or our own.
extern UINT uiConnectionType;

/* Constructor */

CShell::CImplOutputPin::CImplOutputPin(
    CBaseFilter *pBaseFilter,
    CShell *pShell,
    HRESULT *phr,
    LPCWSTR pPinName)
    : CBaseOutputPin(NAME("Test output pin"), pBaseFilter, pShell, phr, pPinName)
{
    m_pBaseFilter = pBaseFilter;
    m_pShell = pShell;
}


/* Propose with a MEDIATYPE_Audio and NULL subtype */
/* Pass the details of the loaded wave             */

HRESULT CShell::CImplOutputPin::ProposeMediaType(CMediaType *pmtOut)
{
    /* Set the media type we like */

    pmtOut->SetType(&MEDIATYPE_Audio);
    pmtOut->SetSubtype(&GUID_NULL);
    pmtOut->SetFormat((BYTE *) &g_wfx, sizeof(g_wfx));
    pmtOut->SetSampleSize(g_wfx.nBlockAlign);        // ?? huh ??
    pmtOut->SetTemporalCompression(FALSE);

    return NOERROR;
}


HRESULT CShell::CImplOutputPin::CheckMediaType(const CMediaType* pmtOut)
{
    OutputDebugString("CShell::CImplOutputPin::CheckMediaType(CMediaType* pmtOut)\n");
    // check here that the input type is OK
    //if  (pmtOut->FormatType() == &MEDIATYPE_Audio)
    // it looks like the type has not been set
     if (pmtOut->FormatLength() == sizeof(g_wfx))
     if (pmtOut->GetSampleSize() == g_wfx.nBlockAlign)
     if (!pmtOut->IsTemporalCompressed())
      {
	return S_OK;
    }
    return E_NOTIMPL;
}

HRESULT CShell::CImplOutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    // Return the media type that we support
    if (iPosition != 0) {
	return E_FAIL;
    }
    pMediaType->SetType(&MEDIATYPE_Audio);
    pMediaType->SetSubtype(&GUID_NULL);
    pMediaType->SetFormat((BYTE *) &g_wfx, sizeof(g_wfx));
    pMediaType->SetSampleSize(g_wfx.nBlockAlign);
    pMediaType->SetTemporalCompression(FALSE);
    return S_OK;
}


/* For simplicity we always ask for the maximum buffer ever required */

HRESULT CShell::CImplOutputPin::DecideBufferSize(
    IMemAllocator * pAllocator,
    ALLOCATOR_PROPERTIES *pProperties)
{
    ASSERT(pAllocator);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    pProperties->cBuffers = 5;
    pProperties->cbBuffer = MAX_SAMPLE_SIZE;

    ASSERT(pProperties->cbBuffer);

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAllocator->SetProperties(pProperties,&Actual);

    ASSERT(SUCCEEDED(hr));
    ASSERT(Actual.cbBuffer > 0);
    ASSERT(Actual.cBuffers > 0);
    ASSERT(Actual.cbAlign == 1);
    ASSERT(Actual.cbPrefix == 0);

    if (FAILED(hr)) {
	return hr;
    }
    return NOERROR;
}


/* We override the output pin connection to query for IDirectSound (not
   IMemInputPin)if the user requested we test the direct interface */

STDMETHODIMP CShell::CImplOutputPin::Connect(IPin *pReceivePin,const AM_MEDIA_TYPE *pmt)
{
    CAutoLock cObjectLock(m_pShell);

    // Direct sound comes later

    /* Let the output pin do it's usual work */

    HRESULT hr = CBaseOutputPin::Connect(pReceivePin,pmt);
    if (FAILED(hr)) {
	return hr;
    }

    return NOERROR;
}

// !!! need to allow choice of allocators here!!!!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twaveout\twaveout.h ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
// Audio renderer test shell, from original by Anthony Phillips, January 1995

#ifndef _TWAVEOUT_
#define _TWAVEOUT_

VOID CALLBACK SaveCustomProfile(LPCSTR pszProfileName);
VOID CALLBACK LoadCustomProfile(LPCSTR pszProfileName);

typedef void (*PDUMP)(void);

BOOL InitialiseTest();
void Log(UINT iLogLevel, LPTSTR text);

BOOL DumpTestObjects();
void StartStateChange();
void EndStateChange();

HRESULT ResetInterfaces();
HRESULT ReleaseInterfaces();
HRESULT LoadWAV(UINT uiMenuItem);
HRESULT DumpPalette(RGBQUAD *pRGBQuad, int iColours);
HRESULT CreateStream();
HRESULT CreateObjects();
HRESULT ReleaseStream();
HRESULT ConnectStream();
HRESULT DisconnectStream();
HRESULT EnumFilterPins(PFILTER pFilter);
HRESULT EnumeratePins();
HRESULT GetIMediaFilterInterfaces();
HRESULT GetIBasicAudioInterface();
HRESULT GetIPinInterfaces();
IPin *GetPin(IBaseFilter *pFilter, ULONG lPin);
HRESULT StartSystem();
HRESULT PauseSystem();
HRESULT StopSystem();
HRESULT StopWorkerThread();
HRESULT StartWorkerThread();
HRESULT SetStartTime();
HRESULT TestVolume();
HRESULT TestBalanceVolume();
HRESULT TestVolumeBalance();
void SetImageMenuCheck(UINT uiMenuItem);
void SetConnectionMenuCheck(UINT uiMenuItem);
void ChangeConnectionType(UINT uiMenuItem);
DWORD SampleLoop(LPVOID lpvThreadParm);
HRESULT PushSample(REFERENCE_TIME *pStart, REFERENCE_TIME *pEnd);
DWORD OverlayLoop(LPVOID lpvThreadParm);
HRESULT DisplayDefaultColourKey(IOverlay *pOverlay);
HRESULT DisplayCurrentColourKey(IOverlay *pOverlay);
HRESULT DisplayColourKey(COLORKEY *pColourKey);
HRESULT SetColourKey(IOverlay *pOverlay,DWORD dwColourIndex);
HRESULT GetClippingList(IOverlay *pOverlay);

HRESULT DisplayClippingInformation(RGNDATAHEADER *pRgnDataHeader,
                                   RECT *pRectangles);

HRESULT GetSystemPalette(IOverlay *pOverlay);
HRESULT DisplaySystemPalette(DWORD dwColours,PALETTEENTRY *pPalette);
BOOL CALLBACK SetTimeIncrDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

extern LRESULT FAR PASCAL MenuProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
extern BOOL InitOptionsMenu (LRESULT (CALLBACK* ManuProc)(HWND, UINT, WPARAM, LPARAM));
extern LRESULT FAR PASCAL tstAppWndProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

extern int expect (UINT uExpected, UINT uActual, LPSTR CaseDesc);
extern int FAR PASCAL execTest1(void);
extern int FAR PASCAL execTest2(void);
extern int FAR PASCAL execTest3(void);
extern int FAR PASCAL execTest4(void);
extern int FAR PASCAL execTest5(void);
extern int FAR PASCAL execTest6(void);
const UINT nTests = 6;

BOOL ValidateMemory(BYTE * ptr, LONG cBytes);
BOOL CheckHR(HRESULT hr, LPSTR lpszCase);
BOOL CheckLong(LONG lExpect, LONG lActual, LPSTR lpszCase);

/* Stops the logging intensive test */

#define VSTOPKEY VK_SPACE
#define SECTION_LENGTH 100

/* The string identifiers for the group's names */

#define GRP_BASIC           100
#define GRP_LAST            GRP_BASIC

/* The string identifiers for the test's names */

#define ID_TEST1            201
#define ID_TEST2            202
#define ID_TEST3            203
#define ID_TEST4            204
#define ID_TEST5            205
#define ID_TEST6            206
#define ID_TESTLAST         ID_TEST6

/* The test case identifier (used in the switch statement in execTest) */

#define FX_TEST1            301
#define FX_TESTFIRST        301
#define FX_TEST2            302
#define FX_TEST3            303
#define FX_TEST4            304
#define FX_TEST5            305
#define FX_TEST6            306
#define FX_TESTLAST         306

/* Windows identifiers */

#define ID_LISTBOX              100
#define IDM_CREATE              101
#define IDM_RELEASE             102
#define IDM_CONNECT             103
#define IDM_DISCONNECT          104
#define IDM_STOP                105
#define IDM_PAUSE               106
#define IDM_RUN                 107
#define IDM_EXIT                108

#define IDM_WAVEALLOC           109
#define IDM_OTHERALLOC          110
#define IDM_SETTIMEINCR         111
#define IDC_EDIT1               112
#define IDM_DUMP                113
#define IDM_BREAK               114

// Keep file choices contiguous
#define IDM_8M11                116
#define IDM_8M22                117
#define IDM_16M11               118
#define IDM_FILEFIRST           IDM_8M11
#define IDM_FILELAST            IDM_16M11

/* Identifies the test list section of the resource file */

#define TEST_LIST           500

/* Multiple platform support */

#define PLATFORM1           1
#define PLATFORM2           2
#define PLATFORM3           4

/* Window details such as menu item positions and defaults */

#define DEFAULT_WAVE            IDM_8M11
#define AUDIO_MENU_POS          2
#define CONNECTION_MENU_POS     3
#define DEFAULT_INDEX           0

/* Maximum image dimensions */

#define MAX_SAMPLE_RATE          22050      // samples/second
#define MAX_SAMPLE_LENGTH        5    	    // 5 seconds
#define MAX_SAMPLE_DEPTH         (16 / 8)   // bits / (bits/byte)
#define MAX_SAMPLE_SIZE          (MAX_SAMPLE_RATE * MAX_SAMPLE_DEPTH * MAX_SAMPLE_LENGTH)

/* Number of pins available and their index number */

const int NUMBERSHELLPINS = 1;      // Shell has one output pin
const int OUTPUTSHELLPIN = 0;       // The pin is numbered zero
const int INFO = 128;               // Size of information string

extern HWND ghwndTstShell;          // Handle to test shell main window
extern BOOL bCreated;               // Whether objects have been created

/* We create a pseudo filter object to synthesise a conenction with the
   renderer, the filter supports just one output pin that can only
   push data.  Later we will ask for a direct sound interface. */

class CShell : public CUnknown, public CCritSec
{

public:

    /* Constructors etc */

    CShell(LPUNKNOWN, HRESULT *);
    ~CShell();

    /* Override this to say what interfaces we support where */
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

public:

    /* Implements the IBaseFilter and IMediaFilter interfaces */

    class CImplFilter : public CBaseFilter
    {
        CShell *m_pShell;

    public:

        /* Constructors */

        CImplFilter(
            CShell *pShell,
            HRESULT *phr);

        /* Return the number of pins and their interfaces */

        CBasePin *GetPin(int n);
        int GetPinCount() {
            return NUMBERSHELLPINS;
        };

    };

    /* Implements the output pin */

    class CImplOutputPin : public CBaseOutputPin
    {
        CBaseFilter *m_pBaseFilter;
        CShell *m_pShell;

    public:

        /* Constructor */

        CImplOutputPin(
            CBaseFilter *pBaseFilter,
            CShell *pShell,
            HRESULT * phr,
            LPCWSTR pPinName);

        /* Override pure virtual - return the media type supported */
        HRESULT ProposeMediaType(CMediaType* mtIn);

        /* Check that we can support this output type */
        HRESULT CheckMediaType(const CMediaType* mtOut);

        /* Return the type of media we supply */
        HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

        /* Called from CBaseOutputPin to prepare the allocator's buffers */
        HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                                 ALLOCATOR_PROPERTIES *pProperties);

        /* Overriden to get audio specific interface */
        STDMETHODIMP Connect(IPin *pReceivePin,const AM_MEDIA_TYPE *pmt);

        // Override to handle quality messages
        STDMETHODIMP Notify(IBaseFilter * pSender, Quality q)
        {    return E_NOTIMPL;        // We do NOT handle this
        }

    };

public:

    /* Let the nested interfaces access out private state */

    friend class CImplFilter;
    friend class CImplOutputPin;

    CImplFilter        *m_pFilter;          // IBaseFilter interface
    CImplOutputPin     *m_pOutputPin;       // IPin and IMemOutputPin
    //IReferenceClock    *m_pClock;   Use the clock in the base class
    CMediaType         m_mtOut;             // Media type for the pin

};

#endif /* _TWAVEOUT_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\waveout\audprop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// AudProp.cpp
//

#include <streams.h>

#include "waveout.h"
#include "audprop.h"

// *
// * CAudioRendererProperties
// *

//
// CreateInstance
//
//
CUnknown *CAudioRendererProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CAudioRendererProperties(lpunk, phr);
    if (NULL == punk) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
} // Createinstance


//
// CAudioRendererProperties::Constructor
//
// initialise a CAudioRendererProperties object.

CAudioRendererProperties::CAudioRendererProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage( NAME("Audio Renderer Page")
                       , lpunk, IDD_AUDIOPROP, IDS_AUDIORENDERNAME)
    , m_pFilter(0)
{
    ASSERT(phr);
}


CAudioRendererProperties::~CAudioRendererProperties()
{
    CAudioRendererProperties::OnDisconnect();
};

INT_PTR CAudioRendererProperties::OnReceiveMessage
                            (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    switch (uMsg)
    {
	case WM_INITDIALOG:
	    return CBasePropertyPage::OnReceiveMessage(hwnd, uMsg, wParam, lParam);
	    break;

#if 0
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
		// This code should handle the buttons (if any)
		// in the dialog
            }
            SetDirty();
	    break;
#endif

        default:
	    return CBasePropertyPage::OnReceiveMessage(hwnd, uMsg, wParam, lParam);

    }
    return FALSE;

} // OnReceiveMessage

#ifdef DEBUG
#include <mmreg.h>
TCHAR* WhatFormatTag(int wFormatTag)
{
    switch (wFormatTag) {
        case  WAVE_FORMAT_PCM        : return TEXT("PCM");   /*  Microsoft Corporation  */
        case  WAVE_FORMAT_ADPCM      : return TEXT("ADPCM");   /*  Microsoft Corporation  */
        case  WAVE_FORMAT_IBM_CVSD   : return TEXT("IBM_CVSD");  /*  IBM Corporation  */
        case  WAVE_FORMAT_ALAW       : return TEXT("ALAW");  /*  Microsoft Corporation  */
        case  WAVE_FORMAT_MULAW      : return TEXT("MULAW");  /*  Microsoft Corporation  */
        case  WAVE_FORMAT_OKI_ADPCM  : return TEXT("OKI_ADPCM");  /*  OKI  */
        case  WAVE_FORMAT_DVI_ADPCM  : return TEXT("DVI_ADPCM"); /*  Intel Corporation  */
//        case  WAVE_FORMAT_IMA_ADPCM  (WAVE_FORMAT_DVI_ADPCM) /*  Intel Corporation  */
        case  WAVE_FORMAT_MEDIASPACE_ADPCM   : return TEXT("MEDIASPACE_ADPCM");  /*  Videologic  */
        case  WAVE_FORMAT_SIERRA_ADPCM       : return TEXT("SIERRA_ADPCM");  /*  Sierra Semiconductor Corp  */
        case  WAVE_FORMAT_G723_ADPCM : return TEXT("G723_ADPCM");  /*  Antex Electronics Corporation  */
        case  WAVE_FORMAT_DIGISTD    : return TEXT("DIGISTD");  /*  DSP Solutions, Inc.  */
        case  WAVE_FORMAT_DIGIFIX    : return TEXT("DIGIFIX");  /*  DSP Solutions, Inc.  */
        case  WAVE_FORMAT_DIALOGIC_OKI_ADPCM : return TEXT("DIALOGIC_OKI_ADPCM");  /*  Dialogic Corporation  */
        case  WAVE_FORMAT_YAMAHA_ADPCM       : return TEXT("YAMAHA_ADPCM");  /*  Yamaha Corporation of America  */
        case  WAVE_FORMAT_SONARC     : return TEXT("SONARC"); /*  Speech Compression  */
        case  WAVE_FORMAT_DSPGROUP_TRUESPEECH        : return TEXT("DSPGROUP_TRUESPEECH");  /*  DSP Group, Inc  */
        case  WAVE_FORMAT_ECHOSC1    : return TEXT("ECHOSC1");  /*  Echo Speech Corporation  */
        case  WAVE_FORMAT_AUDIOFILE_AF36     : return TEXT("AUDIOFILE_AF36");  /*    */
        case  WAVE_FORMAT_APTX       : return TEXT("APTX");  /*  Audio Processing Technology  */
        case  WAVE_FORMAT_AUDIOFILE_AF10     : return TEXT("AUDIOFILE_AF10");  /*    */
        case  WAVE_FORMAT_DOLBY_AC2  : return TEXT("DOLBY_AC2");  /*  Dolby Laboratories  */
        case  WAVE_FORMAT_GSM610     : return TEXT("GSM610");  /*  Microsoft Corporation  */
        case  WAVE_FORMAT_ANTEX_ADPCME       : return TEXT("ANTEX_ADPCME");  /*  Antex Electronics Corporation  */
        case  WAVE_FORMAT_CONTROL_RES_VQLPC  : return TEXT("CONTROL_RES_VQLPC"); /*  Control Resources Limited  */
        case  WAVE_FORMAT_DIGIREAL   : return TEXT("DIGIREAL");  /*  DSP Solutions, Inc.  */
        case  WAVE_FORMAT_DIGIADPCM  : return TEXT("DIGIADPCM");  /*  DSP Solutions, Inc.  */
        case  WAVE_FORMAT_CONTROL_RES_CR10   : return TEXT("CONTROL_RES_CR10");  /*  Control Resources Limited  */
        case  WAVE_FORMAT_NMS_VBXADPCM       : return TEXT("NMS_VBXADPCM");  /*  Natural MicroSystems  */
        case  WAVE_FORMAT_CS_IMAADPCM : return TEXT("CS_IMAADPCM"); /* Crystal Semiconductor IMA ADPCM */
        case  WAVE_FORMAT_G721_ADPCM : return TEXT("G721_ADPCM");  /*  Antex Electronics Corporation  */
        case  WAVE_FORMAT_MPEG       : return TEXT("MPEG");  /*  Microsoft Corporation  */
        case  WAVE_FORMAT_CREATIVE_ADPCM     : return TEXT("CREATIVE_ADPCM");  /*  Creative Labs, Inc  */
        case  WAVE_FORMAT_CREATIVE_FASTSPEECH8       : return TEXT("CREATIVE_FASTSPEECH8");  /*  Creative Labs, Inc  */
        case  WAVE_FORMAT_CREATIVE_FASTSPEECH10      : return TEXT("CREATIVE_FASTSPEECH10");  /*  Creative Labs, Inc  */
        case  WAVE_FORMAT_FM_TOWNS_SND       : return TEXT("FM_TOWNS_SND");  /*  Fujitsu Corp.  */
        case  WAVE_FORMAT_OLIGSM     : return TEXT("OLIGSM");  /*  Ing C. Olivetti & C., S.p.A.  */
        case  WAVE_FORMAT_OLIADPCM   : return TEXT("OLIADPCM");  /*  Ing C. Olivetti & C., S.p.A.  */
        case  WAVE_FORMAT_OLICELP    : return TEXT("OLICELP");  /*  Ing C. Olivetti & C., S.p.A.  */
        case  WAVE_FORMAT_OLISBC     : return TEXT("OLISBC");  /*  Ing C. Olivetti & C., S.p.A.  */
        case  WAVE_FORMAT_OLIOPR     : return TEXT("OLIOPR");  /*  Ing C. Olivetti & C., S.p.A.  */
        case  WAVE_FORMAT_EXTENSIBLE : return TEXT("EXTENSIBLE");  /*  Microsoft Coroporation  */
        case  WAVE_FORMAT_IEEE_FLOAT : return TEXT("IEEE_FLOAT");  /*  Microsoft Coroporation  */
#ifdef WAVE_FORMAT_DRM        
        case  WAVE_FORMAT_DRM        : return TEXT("DRM");  /*  Microsoft Corporation  */
#endif        
	default:
        /*    WAVE_FORMAT_UNKNOWN : */ return NULL;  // display the number
    }
}
#endif

//
// Fill in the property page details
//

HRESULT CAudioRendererProperties::OnActivate()
{

    if (m_pFilter->IsConnected()) {
        WAVEFORMATEX *pwfx = m_pFilter->WaveFormat();
        TCHAR buffer[50];

#ifdef DEBUG
	TCHAR * pString =
	WhatFormatTag(pwfx->wFormatTag);
	if (pString) {
	    SendDlgItemMessage(m_Dlg, IDD_WTAG, WM_SETTEXT, 0, (LPARAM) (LPSTR) pString);
	} else
#endif
	{
        wsprintf(buffer,TEXT("%d"), pwfx->wFormatTag);
        SendDlgItemMessage(m_Dlg, IDD_WTAG, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
	}
        wsprintf(buffer,TEXT("%d"), pwfx->nChannels);
        SendDlgItemMessage(m_Dlg, IDD_NCHANNELS, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        wsprintf(buffer,TEXT("%d"), pwfx->nSamplesPerSec);
        SendDlgItemMessage(m_Dlg, IDD_NSAMPLESPERSEC, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        wsprintf(buffer,TEXT("%d"), pwfx->nAvgBytesPerSec);
        SendDlgItemMessage(m_Dlg, IDD_NAVGBYTESPERSEC, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        wsprintf(buffer,TEXT("%d"), pwfx->nBlockAlign);
        SendDlgItemMessage(m_Dlg, IDD_NBLOCKALIGN, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);

	DWORD avgbytespersec = (static_cast<CWaveOutInputPin*>(m_pFilter->GetPin(0)))->GetBytesPerSec() * 1000;
	ASSERT(pwfx->nAvgBytesPerSec);
	avgbytespersec /= pwfx->nAvgBytesPerSec;
        wsprintf(buffer,TEXT("%d.%2.2d"), avgbytespersec/1000, (avgbytespersec/10)%100);

        SendDlgItemMessage(m_Dlg, IDD_NWAVERATE,   WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    } else {
        const TCHAR szZero[] = TEXT("0");
        SendDlgItemMessage(m_Dlg, IDD_WTAG, WM_SETTEXT, 0, (LPARAM) (LPSTR) szZero);
        SendDlgItemMessage(m_Dlg, IDD_NCHANNELS, WM_SETTEXT, 0, (LPARAM) (LPSTR) szZero);
        SendDlgItemMessage(m_Dlg, IDD_NSAMPLESPERSEC, WM_SETTEXT, 0, (LPARAM) (LPSTR) szZero);
        SendDlgItemMessage(m_Dlg, IDD_NAVGBYTESPERSEC, WM_SETTEXT, 0, (LPARAM) (LPSTR) szZero);
        SendDlgItemMessage(m_Dlg, IDD_NBLOCKALIGN, WM_SETTEXT, 0, (LPARAM) (LPSTR) szZero);
        SendDlgItemMessage(m_Dlg, IDD_NWAVERATE,   WM_SETTEXT, 0, (LPARAM) (LPSTR) szZero);
    }
    return NOERROR;
}

//
// OnConnect
//
HRESULT CAudioRendererProperties::OnConnect(IUnknown * punk)
{
    CheckPointer( punk, E_POINTER );
    CAudioRendererProperties::OnDisconnect();
    IBaseFilter * pIFilter;
    const HRESULT hr = punk->QueryInterface(IID_IBaseFilter, (void **) &pIFilter);
    m_pFilter = static_cast<CWaveOutFilter*>(pIFilter);
    return hr;
} // OnConnect


//
// OnDisconnect
//
HRESULT CAudioRendererProperties::OnDisconnect()
{
    if (m_pFilter)
    {
        m_pFilter->Release();
        m_pFilter = 0;
    }
    return(NOERROR);
} // OnDisconnect



#if 0
    // This is where we should make changes due to user action.
    // As the user cannot change anything in the property dialog
    // we have nothing to do.  Leave the skeleton here as a placeholder.

HRESULT CAudioRendererProperties::OnApplyChanges()
{
    return NOERROR;
}

#endif


// 
// CAudioRendererAdvancedProperties 
// 
// Property page for audio renderer detailed information. This includes
// slaving details and general buffer processing information.
// 

//
// CreateInstance
//
//
CUnknown *CAudioRendererAdvancedProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CAudioRendererAdvancedProperties(lpunk, phr);
    if (NULL == punk) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
} // Createinstance


//
// CAudioRendererAdvancedProperties::Constructor
//
// initialise a CAudioRendererAdvancedProperties object.

CAudioRendererAdvancedProperties::CAudioRendererAdvancedProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage( NAME("Audio Renderer Advanced Properties")
                       , lpunk, IDD_AUDIOPROP_ADVANCED, IDS_AUDIORENDERER_ADVANCED)
    , m_pStats(0)
{
    ASSERT(phr);
}


CAudioRendererAdvancedProperties::~CAudioRendererAdvancedProperties()
{
    CAudioRendererAdvancedProperties::OnDisconnect();
};

INT_PTR CAudioRendererAdvancedProperties::OnReceiveMessage
                            (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    switch (uMsg)
    {
        case WM_INITDIALOG:
    
// Important - perhaps we should allow a way to disable/enable this dynamic
//             refreshing of the property page
            SetTimer(m_Dlg, 1, 100, NULL);
	    
            return (LRESULT) 1;

        case WM_DESTROY:
        {
	        KillTimer(m_hwnd, 1);
	    
            return (LRESULT) 1;
        }

        case WM_TIMER:
            UpdateSettings();

    }
    return CBasePropertyPage::OnReceiveMessage(hwnd, uMsg, wParam, lParam);

} // OnReceiveMessage


TCHAR* WhatSlaveMode(DWORD dwSlaveMode)
{
    if( 0 == dwSlaveMode )
    {    
        return TEXT(" - ");
    }        
    else if( dwSlaveMode & AM_AUDREND_SLAVEMODE_LIVE_DATA )
    {
        if( dwSlaveMode & AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS )
            return TEXT("Live Fullness");
        else if( dwSlaveMode & AM_AUDREND_SLAVEMODE_TIMESTAMPS )
            return TEXT("Live Timestamps");        
        else if( dwSlaveMode & AM_AUDREND_SLAVEMODE_GRAPH_CLOCK )
            return TEXT("Live Graph Clock");        
        else if( dwSlaveMode & AM_AUDREND_SLAVEMODE_STREAM_CLOCK )
            return TEXT("Live Stream Clock");
        else
            return TEXT("Unknown Live Mode");
    }
    else if( dwSlaveMode & AM_AUDREND_SLAVEMODE_GRAPH_CLOCK )
    {
        return TEXT("Graph Clock");
    }        
    else
    {    
        return TEXT("Unknown");
    }
}


void CAudioRendererAdvancedProperties::UpdateSettings()
{

    DWORD dwParam, dwParam2, dwSlaveMode;
    HRESULT hr;
    TCHAR buffer[50];
    const TCHAR szNA[] = TEXT(" - ");

    // not slaving-specific
    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_DISCONTINUITIES
                               , &dwParam
                               , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_DISCONTINUITIES, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_DISCONTINUITIES, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
    
    
    // slaving-specific
    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SLAVE_MODE
                                    , &dwSlaveMode
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
    	TCHAR * pString = WhatSlaveMode(dwSlaveMode);
    	ASSERT( pString );
	    SendDlgItemMessage(m_Dlg, IDD_EDIT_SLAVEMODE, WM_SETTEXT, 0, (LPARAM) (LPSTR) pString);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SLAVEMODE, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
    
    
	hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SLAVE_RATE
                               , &dwParam
    	                       , 0 );
	if( SUCCEEDED( hr ) )
    {
    	wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SLAVERATE, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SLAVERATE, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
    
    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR
                               , &dwParam
                               , &dwParam2 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_HIGHERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        
        wsprintf(buffer,TEXT("%d"), dwParam2);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LOWERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
    {    
        SendDlgItemMessage(m_Dlg, IDD_EDIT_HIGHERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LOWERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
    }

    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR
                                    , &dwParam
                                    , &dwParam2 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LASTHIGHERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        
        wsprintf(buffer,TEXT("%d"), dwParam2);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LASTLOWERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
    {    
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LASTHIGHERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LASTLOWERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
    }
    
    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR
                                    , &dwParam
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_ACCUMERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_ACCUMERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);

    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR
                                    , &dwParam
                                    , &dwParam2 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_DROPPEDDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        
        wsprintf(buffer,TEXT("%d"), dwParam2);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SLAVESILENCEDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        
    }
    else
    {    
        SendDlgItemMessage(m_Dlg, IDD_EDIT_DROPPEDDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SLAVESILENCEDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
    }

    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR
                                    , &dwParam
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LASTBUFFERDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LASTBUFFERDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
#if 0
    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_JITTER
                                    , &dwParam
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_JITTER, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_JITTER, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
#endif
    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_BREAK_COUNT
                                    , &dwParam
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_NUMBREAKS, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_NUMBREAKS, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);


    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_BUFFERFULLNESS
                                    , &dwParam
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_FULLNESS, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_FULLNESS, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);



    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SILENCE_DUR
                                    , &dwParam
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SILENCEDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SILENCEDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);

}

//
// Fill in the property page details
//

HRESULT CAudioRendererAdvancedProperties::OnActivate()
{
    UpdateSettings();
    return NOERROR;
}

//
// OnConnect
//
HRESULT CAudioRendererAdvancedProperties::OnConnect(IUnknown * punk)
{
    CheckPointer( punk, E_POINTER );
    CAudioRendererAdvancedProperties::OnDisconnect();

    const HRESULT hr = punk->QueryInterface(IID_IAMAudioRendererStats, (void **) &m_pStats);

    return hr;
} // OnConnect


//
// OnDisconnect
//
HRESULT CAudioRendererAdvancedProperties::OnDisconnect()
{
    if (m_pStats)
    {
        m_pStats->Release();
        m_pStats = 0;
    }
    return(NOERROR);
} // OnDisconnect

#pragma warning(disable: 4514) // "unreferenced inline function has been removed"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\wavein\pins.cpp ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.
// Digital audio capture filter, Danny Miller, February 1997

#include <streams.h>
#include <mmsystem.h>
#include "wavein.h"

#define MAX_TREBLE 6.0		// !!! I HAVE NO IDEA HOW MANY dB THE RANGE IS!
#define MAX_BASS   6.0		// !!! I HAVE NO IDEA HOW MANY dB THE RANGE IS!

// CWaveInInputPin constructor
//
CWaveInInputPin::CWaveInInputPin(TCHAR *pObjectName, CWaveInFilter *pFilter,
	DWORD dwLineID, DWORD dwMuxIndex, HRESULT * phr, LPCWSTR pName)
   :
   CBaseInputPin(pObjectName, pFilter, pFilter, phr, pName),
   m_pFilter(pFilter),
   m_dwLineID(dwLineID),
   m_dwMuxIndex(dwMuxIndex),
   m_Pan(64.)	// no idea yet
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInInputPin constructor for line %08x"),
								dwLineID));
    ASSERT(pFilter);

// !!! TEST ONLY
#if 0
    int f;
    double d;
    put_Enable(FALSE);
    get_Enable(&f);
    put_Mono(TRUE);
    get_Mono(&f);
    get_TrebleRange(&d);
    put_MixLevel(1.);
    put_Pan(-.5);
#endif
}


CWaveInInputPin::~CWaveInInputPin()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying an input pin")));
};


STDMETHODIMP CWaveInInputPin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IAMAudioInputMixer) {
	return GetInterface((LPUNKNOWN)(IAMAudioInputMixer *)this, ppv);
    }

   return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
}


// we only connect our input pins using major type MEDIATYPE_AnalogAudio
//
HRESULT CWaveInInputPin::CheckMediaType(const CMediaType *pmt)
{
    // reject if not analog audio
    if (pmt->majortype != MEDIATYPE_AnalogAudio) {
	return E_INVALIDARG;
    }
    return S_OK; 
}


// We offer MEDIATYPE_AnalogAudio for BPC
//
HRESULT CWaveInInputPin::GetMediaType(int iPosition, CMediaType *pmt)
{
    if (iPosition != 0)
	return VFW_S_NO_MORE_ITEMS;

    pmt->SetType(&MEDIATYPE_AnalogAudio);
    pmt->SetSubtype(&MEDIASUBTYPE_None);
    pmt->SetFormatType(&FORMAT_None);
    return S_OK; 
}


//============================================================================

/////////////////////
// IAMAudioInputMixer
/////////////////////


// Get info about a control for this pin... eg. volume, mute, etc.
// Also get a handle for calling further mixer APIs
// Also get the number of channels for this pin (mono vs. stereo input)
//
HRESULT CWaveInInputPin::GetMixerControl(DWORD dwControlType, HMIXEROBJ *pID,
				int *pcChannels, MIXERCONTROL *pmc, DWORD dwLineID)
{
    int i, waveID;
    HMIXEROBJ ID;
    DWORD dw;
    MIXERLINE mixerinfo;
    MIXERLINECONTROLS mixercontrol;

    if (pID == NULL || pmc == NULL || pcChannels == NULL)
	return E_POINTER;

    ASSERT(m_pFilter->m_WaveDeviceToUse.fSet);
    // !!! this doesn't appear to work for wave mapper. oh uh.
    waveID = m_pFilter->m_WaveDeviceToUse.devnum;
    ASSERT(waveID != WAVE_MAPPER);

    // get an ID to talk to the Mixer APIs.  They are BROKEN if we don't do
    // it this way!
    UINT IDtmp;
    dw = mixerGetID((HMIXEROBJ)IntToPtr(waveID), &IDtmp, MIXER_OBJECTF_WAVEIN);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*ERROR getting mixer ID")));
	return E_FAIL;
    }

    ID = (HMIXEROBJ)UIntToPtr(IDtmp);
    *pID = ID;

    // get info about the input channel our pin represents
    mixerinfo.cbStruct = sizeof(mixerinfo);
    mixerinfo.dwLineID = dwLineID != 0xffffffff ? dwLineID : m_dwLineID;
    // mixerinfo.dwLineID = m_dwLineID;
    dw = mixerGetLineInfo(ID, &mixerinfo, MIXER_GETLINEINFOF_LINEID);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot get info for LineID %d"),
								m_dwLineID));
	return E_FAIL;
    }

    *pcChannels = mixerinfo.cChannels;

    // Get info about ALL the controls this channel has
#if 1
    MIXERCONTROL mxc;
    
    DbgLog((LOG_TRACE,1,TEXT("Trying to get line control"), dwControlType));
    mixercontrol.cbStruct = sizeof(mixercontrol);
    mixercontrol.dwLineID = mixerinfo.dwLineID;
    mixercontrol.dwControlID = dwControlType;
    mixercontrol.cControls = 1;
    mixercontrol.pamxctrl = &mxc;
    mixercontrol.cbmxctrl = sizeof(mxc);
    
    mxc.cbStruct = sizeof(mxc);
    
    dw = mixerGetLineControls(ID, &mixercontrol, MIXER_GETLINECONTROLSF_ONEBYTYPE);
    
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting line controls"), dw));
    } else {
	*pmc = mxc;
	
	return NOERROR;
    }
#else
    mixercontrol.cbStruct = sizeof(mixercontrol);
    mixercontrol.dwLineID = m_dwLineID;
    mixercontrol.cControls = mixerinfo.cControls;
    mixercontrol.pamxctrl = (MIXERCONTROL *)QzTaskMemAlloc(mixerinfo.cControls *
							sizeof(MIXERCONTROL));
    if (mixercontrol.pamxctrl == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot allocate control array")));
	return E_OUTOFMEMORY;
    }
    mixercontrol.cbmxctrl = sizeof(MIXERCONTROL);
    for (i = 0; i < (int)mixerinfo.cControls; i++) {
	mixercontrol.pamxctrl[i].cbStruct = sizeof(MIXERCONTROL);
    }
    dw = mixerGetLineControls(ID, &mixercontrol, MIXER_GETLINECONTROLSF_ALL);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %d getting line controls"), dw));
	QzTaskMemFree(mixercontrol.pamxctrl);
	return E_FAIL;
    }

    // Now find the control they are interested in and return it
    for (i = 0; i < (int)mixerinfo.cControls; i++) {
	if (mixercontrol.pamxctrl[i].dwControlType == dwControlType) {
            DbgLog((LOG_TRACE,1,TEXT("Found %x '%s' control"), 
				mixercontrol.pamxctrl[i].dwControlType,
				mixercontrol.pamxctrl[i].szName));
            DbgLog((LOG_TRACE,1,TEXT("Range %d-%d by %d"), 
				mixercontrol.pamxctrl[i].Bounds.dwMinimum,
				mixercontrol.pamxctrl[i].Bounds.dwMaximum,
				mixercontrol.pamxctrl[i].Metrics.cSteps));
	    CopyMemory(pmc, &mixercontrol.pamxctrl[i],
					mixercontrol.pamxctrl[i].cbStruct);
    	    QzTaskMemFree(mixercontrol.pamxctrl);
    	    return NOERROR;
	}
    }
    QzTaskMemFree(mixercontrol.pamxctrl);
#endif
    return E_NOTIMPL;	// ???
}


// This is a special version of GetMixerControl for the BPC guys to workaround
// driver bugs exposed by GetMixerControl.  There's a switch they can throw
// to cause this code to execute.
// CAUTION: the caller must close the mixer device
//
HRESULT CWaveInInputPin::GetMixerControlBPC(DWORD dwControlType, HMIXEROBJ *pID,
				int *pcChannels, MIXERCONTROL *pmc)
{
    int i, waveID;
    HMIXEROBJ ID;
    DWORD dw;
    MIXERLINE mixerinfo;
    MIXERLINECONTROLS mixercontrol;

    if (pID == NULL || pmc == NULL || pcChannels == NULL)
	return E_POINTER;

    if (m_pFilter->m_fUseMixer == FALSE)
	return E_UNEXPECTED;

    ASSERT(m_pFilter->m_WaveDeviceToUse.fSet);
    // !!! this doesn't appear to work for wave mapper. oh uh.
    waveID = m_pFilter->m_WaveDeviceToUse.devnum;
    ASSERT(waveID != WAVE_MAPPER);

    // The fUseMixer flag is for BPC... we talk talk to the mixer APIs using
    // a different method that worksaround some driver bugs for them
    dw = mixerOpen((HMIXER *)&ID, m_pFilter->m_WaveDeviceToUse.devnum, 0, 0,
							MIXER_OBJECTF_MIXER);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*ERROR getting mixer ID")));
	return E_FAIL;
    }
    //DbgLog((LOG_TRACE,2,TEXT("mixerGetID returns ID=%d"), ID));

    *pID = ID;

    // get info about the input channel our pin represents
    mixerinfo.cbStruct = sizeof(mixerinfo);
    mixerinfo.dwComponentType = MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY;
    dw = mixerGetLineInfo(ID, &mixerinfo, MIXER_GETLINEINFOF_COMPONENTTYPE |
			MIXER_OBJECTF_HMIXER);
    if (dw != 0) {
        mixerinfo.dwComponentType = MIXERLINE_COMPONENTTYPE_SRC_LINE;
        dw = mixerGetLineInfo(ID, &mixerinfo,
		MIXER_GETLINEINFOF_COMPONENTTYPE | MIXER_OBJECTF_HMIXER);
    }
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot get info for LineID %d"),
								m_dwLineID));
	mixerClose((HMIXER)ID);
	return E_FAIL;
    }

    *pcChannels = mixerinfo.cChannels;

    // Get info about ALL the controls this channel has
    mixercontrol.cbStruct = sizeof(mixercontrol);
    mixercontrol.dwLineID = mixerinfo.dwLineID;
    mixercontrol.cControls = mixerinfo.cControls;
    mixercontrol.pamxctrl = (MIXERCONTROL *)QzTaskMemAlloc(mixerinfo.cControls *
							sizeof(MIXERCONTROL));
    if (mixercontrol.pamxctrl == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot allocate control array")));
	mixerClose((HMIXER)ID);
	return E_OUTOFMEMORY;
    }
    mixercontrol.cbmxctrl = sizeof(MIXERCONTROL);
    for (i = 0; i < (int)mixerinfo.cControls; i++) {
	mixercontrol.pamxctrl[i].cbStruct = sizeof(MIXERCONTROL);
    }
    dw = mixerGetLineControls(ID, &mixercontrol, MIXER_GETLINECONTROLSF_ALL |
						MIXER_OBJECTF_HMIXER);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %d getting line controls"), dw));
	QzTaskMemFree(mixercontrol.pamxctrl);
	mixerClose((HMIXER)ID);
	return E_FAIL;
    }

    // Now find the control they are interested in and return it
    for (i = 0; i < (int)mixerinfo.cControls; i++) {
	if (mixercontrol.pamxctrl[i].dwControlType == dwControlType) {
            DbgLog((LOG_TRACE,1,TEXT("Found %x '%s' control"), 
				mixercontrol.pamxctrl[i].dwControlType,
				mixercontrol.pamxctrl[i].szName));
            DbgLog((LOG_TRACE,1,TEXT("Range %d-%d by %d"), 
				mixercontrol.pamxctrl[i].Bounds.dwMinimum,
				mixercontrol.pamxctrl[i].Bounds.dwMaximum,
				mixercontrol.pamxctrl[i].Metrics.cSteps));
	    CopyMemory(pmc, &mixercontrol.pamxctrl[i],
					mixercontrol.pamxctrl[i].cbStruct);
    	    QzTaskMemFree(mixercontrol.pamxctrl);
	    // caller must close the mixer handle
    	    return NOERROR;
	}
    }
    QzTaskMemFree(mixercontrol.pamxctrl);
    mixerClose((HMIXER)ID);
    return E_NOTIMPL;	// ???
}


HRESULT CWaveInInputPin::put_Enable(BOOL fEnable)
{
    HMIXEROBJ ID;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_Enable %d"), m_dwLineID, fEnable));

    // Get the mute switch control
    MIXERCONTROL mc;
    if (m_pFilter->m_fUseMixer) {
        hr = GetMixerControlBPC(MIXERCONTROL_CONTROLTYPE_MUTE, &ID, &cChannels,
								&mc);
    } else {
        hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MUTE, &ID, &cChannels,
								&mc);
    }

    if (hr != NOERROR && fEnable) {
	hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MUX, &ID, &cChannels,
			     &mc, m_pFilter->m_dwDstLineID);
	DbgLog((LOG_TRACE, 1, TEXT("using CONTROLTYPE_MIXER returned %x"), hr));
	
	if (hr == NOERROR && m_dwMuxIndex != 0xffffffff) {
	    MIXERCONTROLDETAILS_BOOLEAN *pmxcd_b;
	    
	    pmxcd_b = new MIXERCONTROLDETAILS_BOOLEAN[mc.cMultipleItems];
	    if (!pmxcd_b)
		return E_OUTOFMEMORY;
	    
	    mixerdetails.cbStruct = sizeof(mixerdetails);
	    mixerdetails.dwControlID = mc.dwControlID;
	    mixerdetails.cChannels = 1;
	    mixerdetails.cMultipleItems = mc.cMultipleItems;
	    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
	    mixerdetails.paDetails = pmxcd_b;
	    
	    for (DWORD dw = 0; dw < mc.cMultipleItems; dw++) {
		pmxcd_b[dw].fValue = (dw == m_dwMuxIndex);
	    }
	    
	    dw = mixerSetControlDetails(ID, &mixerdetails, MIXER_SETCONTROLDETAILSF_VALUE);
	    
	    delete[] pmxcd_b;
	    if (dw != 0) {
		DbgLog((LOG_ERROR,1,TEXT("*Error %d turning on/off mute"), dw));
		return E_FAIL;
	    }
	    
	    return NOERROR;
	    
	}
    }
    
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting mute control"), hr));
	return hr;
    }

    // !!! If that didn't work, I might be able to enable/disable the channel
    // through a mixer on the destination line, you know

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    mixerbool.fValue = fEnable ? FALSE : TRUE;
    DWORD dw = mixerSetControlDetails(ID, &mixerdetails, 
			m_pFilter->m_fUseMixer ? MIXER_OBJECTF_HMIXER : 0);
    if (m_pFilter->m_fUseMixer)
	mixerClose((HMIXER)ID);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d turning on/off mute"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInInputPin::get_Enable(BOOL *pfEnable)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_Enable"), m_dwLineID));

    if (pfEnable == NULL)
	return E_POINTER;

    // Get the mute switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MUTE, &ID, &cChannels, &mc);

    if (hr != NOERROR && m_dwMuxIndex != 0xffffffff) {
	hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MUX, &ID, &cChannels,
			     &mc, m_pFilter->m_dwDstLineID);
	DbgLog((LOG_TRACE, 1, TEXT("using CONTROLTYPE_MIXER returned %x"), hr));

	if (hr == NOERROR) {
	    MIXERCONTROLDETAILS_BOOLEAN *pmxcd_b;

	    pmxcd_b = new MIXERCONTROLDETAILS_BOOLEAN[mc.cMultipleItems];
	    if (!pmxcd_b)
		return E_OUTOFMEMORY;

	    mixerdetails.cbStruct = sizeof(mixerdetails);
	    mixerdetails.dwControlID = mc.dwControlID;
	    mixerdetails.cChannels = 1;
	    mixerdetails.cMultipleItems = mc.cMultipleItems;
	    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
	    mixerdetails.paDetails = pmxcd_b;

	    dw = mixerGetControlDetails(ID, &mixerdetails, MIXER_GETCONTROLDETAILSF_VALUE);

	    if (dw != 0) {
		DbgLog((LOG_ERROR,1,TEXT("*Error %d reading enabled from mixer"), dw));
		delete[] pmxcd_b;
		return E_FAIL;
	    }

	    ASSERT(m_dwMuxIndex < mc.cMultipleItems);
	    *pfEnable = pmxcd_b[m_dwMuxIndex].fValue ? TRUE : FALSE;

	    delete[] pmxcd_b;

	    return NOERROR;

	}
    }

    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting mute control"), hr));
	return hr;
    }

    // !!! If that didn't work, I might be able to enable/disable the channel
    // through a mixer on the destination line, you know

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting mute"), dw));
	return E_FAIL;
    }
    *pfEnable = mixerbool.fValue ? FALSE : TRUE;
    DbgLog((LOG_TRACE,1,TEXT("Enable = %d"), *pfEnable));
    return NOERROR;
}


HRESULT CWaveInInputPin::put_Mono(BOOL fMono)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_Mono %d"), m_dwLineID, fMono));

    // Get the Mono switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MONO, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting mono control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    mixerbool.fValue = fMono;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting mono control"), dw));
	return E_FAIL;
    }
    return NOERROR;
}


HRESULT CWaveInInputPin::get_Mono(BOOL *pfMono)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_Mono"), m_dwLineID));

    if (pfMono == NULL)
	return E_POINTER;

    // Get the mono switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MONO, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting mono control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting mono control"), dw));
	return E_FAIL;
    }
    *pfMono = mixerbool.fValue;
    DbgLog((LOG_TRACE,1,TEXT("Mono = %d"), *pfMono));
    return NOERROR;
}


HRESULT CWaveInInputPin::put_Loudness(BOOL fLoudness)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_Loudness %d"), m_dwLineID, fLoudness));

    // Get the loudness switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_LOUDNESS,&ID,&cChannels,&mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting loudness control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    mixerbool.fValue = fLoudness;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting loudness control"), dw));
	return E_FAIL;
    }
    return NOERROR;
}


HRESULT CWaveInInputPin::get_Loudness(BOOL *pfLoudness)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_Loudness"), m_dwLineID));

    if (pfLoudness == NULL)
	return E_POINTER;

    // Get the loudness switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_LOUDNESS,&ID,&cChannels,&mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting loudness control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting loudness"), dw));
	return E_FAIL;
    }
    *pfLoudness = mixerbool.fValue;
    DbgLog((LOG_TRACE,1,TEXT("Loudness = %d"), *pfLoudness));
    return NOERROR;
}


HRESULT CWaveInInputPin::put_MixLevel(double Level)
{
    HMIXEROBJ ID;
    DWORD dw, volume;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROL mc;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;
    double Pan;

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_MixLevel to %d"), m_dwLineID,
							(int)(Level * 10.)));

    // !!! double/int problem?
    // !!! actually use AGC? (BOOLEAN or BUTTON or ONOFF)
    if (Level == AMF_AUTOMATICGAIN)
	return E_NOTIMPL;

    if (Level < 0. || Level > 1.)
	return E_INVALIDARG;

    // Get the volume control
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    volume = (DWORD)(Level * mc.Bounds.dwMaximum);
    DbgLog((LOG_TRACE,1,TEXT("Setting volume to %d"), volume));
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;

    // if it's not stereo, I don't understand how to pan, so the mix level
    // is simply the value of the volume control
    if (cChannels != 2) {
        DbgLog((LOG_TRACE,1,TEXT("Not stereo - treat as mono")));
        mixerdetails.cChannels = 1;	// sets all channels to same value
        mixerdetails.cbDetails = sizeof(mu.muL);
        mixerdetails.paDetails = &mu.muL;
        mu.muL.dwValue = volume;
        dw = mixerSetControlDetails(ID, &mixerdetails, 0);

    // Stereo.  If we're panned, the channel favoured gets the value we're
    // setting, and the other channel is attenuated
    } else {
	hr = get_Pan(&Pan);
	// I don't know how to pan, so looks like we pretend we're mono
	if (hr != NOERROR || Pan == 0.) {
            DbgLog((LOG_TRACE,1,TEXT("Centre pan - treat as mono")));
            mixerdetails.cChannels = 1;	// sets all channels to same value
            mixerdetails.cbDetails = sizeof(mu.muL);
            mixerdetails.paDetails = &mu.muL;
            mu.muL.dwValue = volume;
            dw = mixerSetControlDetails(ID, &mixerdetails, 0);
	} else {
	    if (Pan < 0.) {
                DbgLog((LOG_TRACE,1,TEXT("panned left")));
                mixerdetails.cChannels = 2;
                mixerdetails.cbDetails = sizeof(mu.muL);
                mixerdetails.paDetails = &mu;
                mu.muL.dwValue = volume;
                mu.muR.dwValue = (DWORD)(volume * (1. - (Pan * -1.)));
                dw = mixerSetControlDetails(ID, &mixerdetails, 0);
	    } else {
                DbgLog((LOG_TRACE,1,TEXT("panned right")));
                mixerdetails.cChannels = 2;
                mixerdetails.cbDetails = sizeof(mu.muL);
                mixerdetails.paDetails = &mu;
                mu.muL.dwValue = (DWORD)(volume * (1. - Pan));
                mu.muR.dwValue = volume;
                dw = mixerSetControlDetails(ID, &mixerdetails, 0);
	    }
	}
    }

    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting volume"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInInputPin::get_MixLevel(double FAR* pLevel)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_MixLevel"), m_dwLineID));

    // !!! detect if we're using AGC? (BOOLEAN or BUTTON or ONOFF)

    if (pLevel == NULL)
	return E_POINTER;

    // Get the volume control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    // if this isn't a stereo control, pretend it's mono
    if (cChannels != 2)
	cChannels = 1;

    // get the current volume levels
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = cChannels;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(mu.muL);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting volume"), dw));
	return E_FAIL;
    }

    // what I consider the current volume is the highest of the channels
    // (pan may attenuate one channel)
    dw = mu.muL.dwValue;
    if (cChannels == 2 && mu.muR.dwValue > dw)
	dw = mu.muR.dwValue;
    *pLevel = (double)dw / mc.Bounds.dwMaximum;
    DbgLog((LOG_TRACE,1,TEXT("Volume: %dL %dR is %d"), mu.muL.dwValue,
						mu.muR.dwValue, dw));
    return NOERROR;
}


HRESULT CWaveInInputPin::put_Pan(double Pan)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;

    // !!! What if they actually support a pan control? SNDVOL32 doesn't care...

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_Pan %d"), m_dwLineID, (int)(Pan * 10.)));

    if (Pan < -1. || Pan > 1.)
	return E_INVALIDARG;

    // Get the volume control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    // if this isn't a stereo control, we can't pan
    if (cChannels != 2) {
        DbgLog((LOG_ERROR,1,TEXT("*Can't pan: not stereo!")));
	return E_NOTIMPL;
    }

    // get the current volume levels
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 2;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(mu.muL);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting volume"), dw));
	return E_FAIL;
    }

    // To pan, the favoured side gets the highest of the 2 current values and
    // the other is attenuated
    dw = max(mu.muL.dwValue, mu.muR.dwValue);
    if (Pan == 0.) {
	mu.muL.dwValue = dw;
	mu.muR.dwValue = dw;
    } else if (Pan < 0.) {
	mu.muL.dwValue = dw;
	mu.muR.dwValue = (DWORD)(dw * (1. - (Pan * -1.)));
    } else {
	mu.muL.dwValue = (DWORD)(dw * (1. - Pan));
	mu.muR.dwValue = dw;
    }
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting volume"), dw));
	return E_FAIL;
    }
    m_Pan = Pan;	// remember it
    return NOERROR;
}


HRESULT CWaveInInputPin::get_Pan(double FAR* pPan)
{
    HMIXEROBJ ID;
    DWORD dw, dwHigh, dwLow;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;

    // !!! What if they actually support a pan control? SNDVOL32 doesn't care...

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_Pan"), m_dwLineID));

    if (pPan == NULL)
	return E_POINTER;

    // Get the volume control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    // if this isn't a stereo control, we can't pan
    if (cChannels != 2) {
        DbgLog((LOG_ERROR,1,TEXT("*Can't pan: not stereo!")));
	return E_NOTIMPL;
    }

    // get the current volume levels
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 2;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(mu.muL);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting volume"), dw));
	return E_FAIL;
    }

    // The pan is the ratio of the lowest channel to highest channel
    dwHigh = max(mu.muL.dwValue, mu.muR.dwValue);
    dwLow = min(mu.muL.dwValue, mu.muR.dwValue);
    if (dwHigh == dwLow && dwLow == 0) {	// !!! dwMinimum?
	if (m_Pan != 64.)
	    *pPan = m_Pan;	// !!! try to be clever when both are zero?
	else
	    *pPan = 0.;
    } else {
	*pPan = 1. - ((double)dwLow / dwHigh);
	// negative means favouring left channel
	if (dwHigh == mu.muL.dwValue && dwLow != dwHigh)
	    *pPan *= -1.;
    }
    DbgLog((LOG_TRACE,1,TEXT("Pan: %dL %dR is %d"), mu.muL.dwValue,
					mu.muR.dwValue, (int)(*pPan * 10.)));
    return NOERROR;
}


HRESULT CWaveInInputPin::put_Treble(double Treble)
{
    HMIXEROBJ ID;
    DWORD dw, treble;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_Treble to %d"), m_dwLineID,
							(int)(Treble * 10.)));

    if (Treble < MAX_TREBLE * -1. || Treble > MAX_TREBLE)
	return E_INVALIDARG;

    // Get the treble control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_TREBLE, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting treble control"), hr));
	return hr;
    }

    treble = (DWORD)(Treble / MAX_TREBLE * mc.Bounds.dwMaximum);
    DbgLog((LOG_TRACE,1,TEXT("Setting treble to %d"), treble));
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;

    mixerdetails.cChannels = 1;	// sets all channels to same value
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    mu.dwValue = treble;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);

    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting treble"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInInputPin::get_Treble(double FAR* pTreble)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_Treble"), m_dwLineID));

    if (pTreble == NULL)
	return E_POINTER;

    // Get the treble control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_TREBLE, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting treble control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cChannels = 1;	// treat as mono
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting treble"), dw));
	return E_FAIL;
    }
    *pTreble = (mu.dwValue / mc.Bounds.dwMaximum * MAX_TREBLE);
    DbgLog((LOG_TRACE,1,TEXT("treble is %d"), (int)*pTreble));

    return NOERROR;
}


HRESULT CWaveInInputPin::get_TrebleRange(double FAR* pRange)
{
    HRESULT hr;
    MIXERCONTROL mc;
    HMIXEROBJ ID;
    int cChannels;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_TrebleRange"), m_dwLineID));

    if (pRange == NULL)
	return E_POINTER;

    // Do we even have a treble control?
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_TREBLE, &ID, &cChannels, &mc);
    if (hr != NOERROR)
	return E_NOTIMPL;

    *pRange = MAX_TREBLE;
    DbgLog((LOG_TRACE,1,TEXT("Treble range is %d.  I'M LYING !!!"),
								(int)*pRange));
    return NOERROR;
}


HRESULT CWaveInInputPin::put_Bass(double Bass)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;
    DWORD bass;

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_Bass to %d"), m_dwLineID,
							(int)(Bass * 10.)));

    if (Bass < MAX_BASS * -1. || Bass > MAX_BASS)
	return E_INVALIDARG;

    // Get the Bass control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_BASS, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting Bass control"), hr));
	return hr;
    }

    bass = (DWORD)(Bass / MAX_BASS * mc.Bounds.dwMaximum);
    DbgLog((LOG_TRACE,1,TEXT("Setting Bass to %d"), bass));
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;

    mixerdetails.cChannels = 1;	// sets all channels to same value
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    mu.dwValue = bass;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);

    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting Bass"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInInputPin::get_Bass(double FAR* pBass)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_Bass"), m_dwLineID));

    if (pBass == NULL)
	return E_POINTER;

    // Get the Bass control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_BASS, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting Bass control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cChannels = 1;	// treat as mono
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting Bass"), dw));
	return E_FAIL;
    }
    *pBass = mu.dwValue / mc.Bounds.dwMaximum * MAX_BASS;
    DbgLog((LOG_TRACE,1,TEXT("Bass is %d"), (int)*pBass));

    return NOERROR;
}


HRESULT CWaveInInputPin::get_BassRange(double FAR* pRange)
{
    HRESULT hr;
    MIXERCONTROL mc;
    HMIXEROBJ ID;
    int cChannels;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_BassRange"), m_dwLineID));

    if (pRange == NULL)
	return E_POINTER;

    // Do we even have a bass control?
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_BASS, &ID, &cChannels, &mc);
    if (hr != NOERROR)
	return E_NOTIMPL;

    *pRange = MAX_BASS;
    DbgLog((LOG_TRACE,1,TEXT("Bass range is %d.  I'M LYING !!!"),
								(int)*pRange));
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\test\twaveout\twtests.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
// Wave out test shell, David Maymudes, Sometime in 1995

#include <streams.h>    // Streams architecture
#include <windows.h>    // Include file for windows APIs
#include <windowsx.h>   // Windows macros etc.
#include <vfw.h>        // Video for windows
#include <tstshell.h>   // Include file for the test shell's APIs
#include <waveout.h>
#include "twaveout.h"   // Various includes, constants, prototypes, globals


//--------------------------------------------------------------------------
//
//  void YieldAndSleep
//
//  Description:
//      Sleep using tstWinYield to allow other threads to log messages
//      in the main window.
//
//  Arguments:
//      DWORD  cMilliseconds:   sleep time in milliseconds
//
//  Return:
//      None.
//
//--------------------------------------------------------------------------

void FAR PASCAL YieldAndSleep(DWORD cMilliseconds)
{
    DWORD   dwEndTime = GetTickCount() + cMilliseconds;
    DWORD   dwCurrentTime = GetTickCount();

    while
    (
	WAIT_TIMEOUT != MsgWaitForMultipleObjects(0,
						  NULL,
						  FALSE,
						  dwEndTime - dwCurrentTime,
						  QS_ALLINPUT)
    )
    {
	tstWinYield();
	if ((dwCurrentTime = GetTickCount()) >= dwEndTime) {
	    return;
	}
    }
}


//--------------------------------------------------------------------------
//
//  void YieldWithTimeout
//
//  Description:
//      Sleep using tstWinYield to allow other threads to log messages
//      in the main window. Terminate if a specified event is not signalled
//      within a timeout period.
//
//      The purpose is to allow tests which play through a wave file of unknown
//      length. The test can terminate after a selectable period of
//      inactivity (usually following the end of the audio).
//
//  Arguments:
//      HEVENT  hEvent:          event to wait for
//      DWORD   cMilliseconds:   sleep time in milliseconds
//
//  Return:
//      None.
//
//--------------------------------------------------------------------------

void FAR PASCAL YieldWithTimeout(HEVENT hEvent,         // event to wait on
				 DWORD cMilliseconds)   // timeout period
{
    DWORD   dwEndTime = GetTickCount() + cMilliseconds;
    DWORD   dwCurrentTime = GetTickCount();
    DWORD   dwEventID;

    while
    (
	WAIT_TIMEOUT !=
	   (dwEventID = MsgWaitForMultipleObjects(1,
						  (LPHANDLE) &hEvent,
						  FALSE,
						  dwEndTime - dwCurrentTime,
						  QS_ALLINPUT))
    )
    {
	// Reset timeout if hEvent was signalled

	if (WAIT_OBJECT_0 == dwEventID) {
	    dwEndTime = GetTickCount() + cMilliseconds;
	} else {
	    tstWinYield();        // Check the message queue
	}

	// Check if we have now timed out
	if ((dwCurrentTime = GetTickCount()) >= dwEndTime) {
	    return;
	}
    }
}


//--------------------------------------------------------------------------
//
//  int execTest1
//
//  Description:
//      Test 1, connect and disconnect renderer
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//--------------------------------------------------------------------------

int FAR PASCAL execTest1()
{
    int result;
    HRESULT hr;

    tstLog (TERSE, "Entering test #1");
    tstLogFlush();

    if (FAILED(CreateStream())) {
	tstLog (TERSE, "Failed to create stream in #1");
	return(TST_FAIL);
    }

    if (FAILED(ConnectStream())) {
	tstLog (TERSE, "Failed to connect stream in #1");
	ReleaseStream();
	return(TST_FAIL);
    }

    if (bCreated == TRUE) {
	hr = DisconnectStream();
	if (SUCCEEDED(hr)) {
	    hr = ReleaseStream();
	}
	if (FAILED(hr)) {
	    tstLog (TERSE, "Failed to disconnect or release stream in #1");
	    return(TST_FAIL);
	}
    }

    result = TST_PASS;
    tstLog (TERSE, "Exiting test #1");
    tstLogFlush();
    return result;
}


//--------------------------------------------------------------------------
//
//  int execTest2
//
//  Description:
//      Test 2, connect renderer, pause file and disconnect
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//--------------------------------------------------------------------------

int FAR PASCAL execTest2()
{
    int result = TST_PASS;

    tstLog (TERSE, "Entering test #2");
    tstLogFlush();

    if (FAILED(CreateStream())) {
	tstLog (TERSE, "Failed to create stream in #2");
	return(TST_FAIL);
    }

    if (FAILED(ConnectStream())) {
	tstLog (TERSE, "Failed to connect stream in #2");
	ReleaseStream();
	return(TST_FAIL);
    }

    tstBeginSection("Pause for 2 seconds");
    PauseSystem();
    YieldAndSleep(2000);
    tstEndSection();

    if (bCreated == TRUE) {
	HRESULT hr;
	tstLog (TERSE, "Expecting message about not being able to disconnect SHELL pin");
	//
	// we should not be able to disconnect the stream from Paused
	//
	hr = DisconnectStream();
	if (!FAILED(hr)) {
	    tstLog (TERSE, "Should not be able to disconnect stream in #2");
	    result = TST_FAIL;
	}

	//
	// stop and disconnect which will release all the resources
	// at this point it is legal to disconnect the stream
	//
	StopSystem();
	hr = DisconnectStream();

	if (SUCCEEDED(hr)) {
	    hr = ReleaseStream();
	}

	if (FAILED(hr)) {
	    tstLog (TERSE, "Failed to disconnect or release stream in #2");
	    result = TST_FAIL;

	}
    }

    tstLog (TERSE, "Exiting test #2");
    tstLogFlush();
    return result;
}


//--------------------------------------------------------------------------
//
//  int execTest3
//
//  Description:
//      Test 3, connect renderer, play file and disconnect
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//--------------------------------------------------------------------------

int FAR PASCAL execTest3()
{
    int result;

    tstLog (TERSE, "Entering test #3");
    tstLogFlush();

    if (FAILED(CreateStream())) {
	tstLog (TERSE, "Failed to create stream in #3");
	return(TST_FAIL);
    }

    if (FAILED(ConnectStream())) {
	tstLog (TERSE, "Failed to connect stream in #3");
	ReleaseStream();
	return(TST_FAIL);
    }

    tstBeginSection("Run for 5 seconds");
    StartSystem();
    YieldAndSleep(5000);       // Crude wait for sound clip to loop a few times
    tstEndSection();

    if (bCreated == TRUE) {
	DisconnectStream();
	ReleaseStream();
    }

    result = TST_PASS;
    tstLog (TERSE, "Exiting test #3");
    tstLogFlush();
    return result;
}

//--------------------------------------------------------------------------
//
//  int execTest4
//
//  Description:
//      Test 4, create renderer, check volume properties work
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//--------------------------------------------------------------------------

int FAR PASCAL execTest4()
{
    int result;

    tstLog (TERSE, "Entering test #4");
    tstLogFlush();

    if (FAILED(CreateStream())) {
	tstLog (TERSE, "Failed to create stream in #4");
	return(TST_FAIL);
    }

    if (FAILED(ConnectStream())) {
	tstLog (TERSE, "Failed to connect stream in #4");
	ReleaseStream();
	return(TST_FAIL);
    }

    tstBeginSection("Run and change the volume");
    StartSystem();
    TestVolume();
    tstEndSection();

    if (bCreated == TRUE) {
	DisconnectStream();
	ReleaseStream();
    }

    result = TST_PASS;
    tstLog (TERSE, "Exiting test #4");
    tstLogFlush();
    return result;
}

//--------------------------------------------------------------------------
//
//  int execTest5
//
//  Description:
//      Test 5, create & connect renderer, check balance does not affect volume"
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//--------------------------------------------------------------------------

int FAR PASCAL execTest5()
{
    int result;

    tstLog (TERSE, "Entering test #5");
    tstLogFlush();

    if (FAILED(CreateStream())) {
	tstLog (TERSE, "Failed to create stream in #5");
	return(TST_FAIL);
    }

    if (FAILED(ConnectStream())) {
	tstLog (TERSE, "Failed to connect stream in #5");
	ReleaseStream();
	return(TST_FAIL);
    }

    tstBeginSection("Run and change the volume");
    StartSystem();
    TestBalanceVolume();
    tstEndSection();

    if (bCreated == TRUE) {
	DisconnectStream();
	ReleaseStream();
    }

    result = TST_PASS;
    tstLog (TERSE, "Exiting test #5");
    tstLogFlush();
    return result;
}


//--------------------------------------------------------------------------
//
//  int execTest6
//
//  Description:
//     Test 5, create & connect renderer, check volume does not affect balance"
//
//  Arguments:
//      None.
//
//  Return (int): TST_PASS indicating success
//
//--------------------------------------------------------------------------

int FAR PASCAL execTest6()
{
    int result;

    tstLog (TERSE, "Entering test #6");
    tstLogFlush();

    if (FAILED(CreateStream())) {
	tstLog (TERSE, "Failed to create stream in #6");
	return(TST_FAIL);
    }

    if (FAILED(ConnectStream())) {
	tstLog (TERSE, "Failed to connect stream in #6");
	ReleaseStream();
	return(TST_FAIL);
    }

    tstBeginSection("Run and change the volume");
    StartSystem();
    TestVolumeBalance();
    tstEndSection();

    if (bCreated == TRUE) {
	DisconnectStream();
	ReleaseStream();
    }

    result = TST_PASS;
    tstLog (TERSE, "Exiting test #6");
    tstLogFlush();
    return result;
}

//--------------------------------------------------------------------------
//
//  int expect
//
//  Description:
//      Compares the expected result to the actual result. Note that this
//      function is not at all necessary; rather, it is a convenient
//      method of saving typing time and standardizing output. As an input,
//      you give it an expected value and an actual value, which are
//      unsigned integers in our example. It compares them and returns
//      TST_PASS indicating that the test was passed if they are equal, and
//      TST_FAIL indicating that the test was failed if they are not equal.
//      Note that the two inputs need not be integers. In fact, if you get
//      strings back, you can modify the function to use lstrcmp to compare
//      them, for example. This function is NOT to be copied to a test
//      application. Rather, it should serve as a model of construction to
//      similar functions better suited for the specific application in hand
//
//  Arguments:
//      UINT uExpected: The expected value
//
//      UINT uActual: The actual value
//
//      LPSTR CaseDesc: A description of the test case
//
//  Return (int): TST_PASS if the expected value is the same as the actual
//      value and TST_FAIL otherwise
//
//   History:
//      06/08/93    T-OriG (based on code by Fwong)
//
//--------------------------------------------------------------------------

int expect(UINT uExpected,
	   UINT uActual,
	   LPSTR CaseDesc)
{
    if(uExpected == uActual) {
	tstLog(TERSE, "PASS : %s",CaseDesc);
	return(TST_PASS);
    } else {
	tstLog(TERSE,"FAIL : %s",CaseDesc);
	return(TST_FAIL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\wav\audio\wavein\wavein.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
// Digital audio renderer, David Maymudes, January 1995

#include <streams.h>
#include <mmsystem.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif /* FILTER_DLL */
#include "wavein.h"
#include "audpropi.h"

// setup now done by the class manager
#if 0

const AMOVIESETUP_MEDIATYPE
sudwaveInFilterType = { &MEDIATYPE_Audio         // clsMajorType
                        , &MEDIASUBTYPE_NULL };  // clsMinorType

const AMOVIESETUP_PIN
psudwaveInFilterPins[] =  { L"Output"       // strName
                     , FALSE                // bRendered
                     , TRUE                 // bOutput
                     , FALSE                // bZero
                     , FALSE                // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L"Input"             // strConnectsToPin
                     , 1                    // nTypes
                     , &sudwaveInFilterType };// lpTypes

const AMOVIESETUP_FILTER
sudwaveInFilter  = { &CLSID_AudioRecord     // clsID
                 , L"Audio Capture Filter"  // strName
                 , MERIT_DO_NOT_USE         // dwMerit
                 , 1                        // nPins
                 , psudwaveInFilterPins };  // lpPin

#endif


#ifdef FILTER_DLL
/* List of class IDs and creator functions for class factory */

CFactoryTemplate g_Templates[] = {
    {L"Audio Capture Filter", &CLSID_AudioRecord, CWaveInFilter::CreateInstance },
    { L"Audio Input Properties", &CLSID_AudioInputMixerProperties, CAudioInputMixerProperties::CreateInstance }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

#endif /* FILTER_DLL */

#define ALIGNUP(dw,align) ((LONG_PTR)(((LONG_PTR)(dw)+(align)-1) / (align)) * (align))

// CWaveInAllocator

/* Constructor must initialise the base allocator */

CWaveInAllocator::CWaveInAllocator(
    TCHAR *pName,
    LPWAVEFORMATEX waveFormat,
    HRESULT *phr)
    : CBaseAllocator(pName, NULL, phr)
    , m_fBuffersLocked(FALSE)
    , m_hw(0)
    , m_dwAdvise(0)
    , m_fAddBufferDangerous(FALSE)
{
    if (!FAILED(*phr)) {
        DbgLog((LOG_TRACE,1,TEXT("CWaveInAllocator:: constructor")));

	// Keep a copy of the format

        int cbSize = sizeof(WAVEFORMATEX);
	int cbCopy;

	// We always allocate at least sizeof(WAVEFORMATEX) to ensure
	// that we can address waveFormat->cbSize even if the user passes us
	// a WAVEFORMAT.  In this latter case we only try and copy
	// sizeof(WAVEFORMAT).

        if (waveFormat->wFormatTag != WAVE_FORMAT_PCM) {
            cbCopy = cbSize += waveFormat->cbSize;
        } else {
	    cbCopy = sizeof(WAVEFORMAT);
	}

        if (m_lpwfxA = (LPWAVEFORMATEX) new BYTE[cbSize]) {
            ZeroMemory((PVOID)m_lpwfxA, cbSize);
            CopyMemory(m_lpwfxA, waveFormat, cbCopy);
	} else {
	    *phr = E_OUTOFMEMORY;
	}
    }
}

// Called from destructor and also from base class

// all buffers have been returned to the free list and it is now time to
// go to inactive state. Unprepare all buffers and then free them.
void CWaveInAllocator::Free(void)
{
    int i;

    // unprepare the buffers
    LockBuffers(FALSE);

    CWaveInSample *pSample;      // Pointer to next sample to delete
    WAVEHDR *pwh;                // Used to retrieve the WAVEHDR

    /* Should never be deleting this unless all buffers are freed */

    ASSERT(!m_fBuffersLocked);

    DbgLog((LOG_TRACE,1,TEXT("Waveallocator: Destroying %u buffers"),
                                m_lAllocated));

    /* Free up all the CWaveInSamples */

    for (i = 0; i < m_lAllocated; i ++) {

        /* Delete the CWaveInSample object but firstly get the WAVEHDR
           structure from it so that we can clean up it's resources */

        // A blocking Get would hang if the driver was buggy and didn't return
        // all the buffers it had been given.  Well, we've seen alot of buggy
        // drivers so lets be nice and avoid hanging by using a non-blocking
        // Get.  Also, we have a down queue with the samples that we've given
        // to the driver, so we can tell which buffers never came back.
        pSample = m_pQueue->GetQueueObject(FALSE);
        if (pSample == NULL && i < m_lAllocated) {
            pSample = m_pDownQueue->GetQueueObject(FALSE);

            //
            // If the sample wasn't in the processing queue and it wasn't
            // in the down queue I'm not sure where it's gone.
            //
            ASSERT(pSample != NULL);

            // If the audio driver holds onto buffers, we just give up and
            // do not free the resources.  We do not try to release them
            // because leaking memory is always preferable to hanging or crashing
            // the system.  The Winnov driver holds onto buffers after
            // waveInReset() is called.
            break;
        }
        pwh = pSample->GetWaveInHeader();

        // delete the actual memory buffer
        delete[] (BYTE *) (pwh);

        // delete the CWaveInSample object
        delete pSample;
    }

    /* Empty the lists themselves */

    m_lAllocated = 0;

    delete m_pQueue;
    delete m_pDownQueue;

}

// the commit and decommit handle preparing and unpreparing of
// the buffers. The filter calls this to tell us the wave handle just
// after opening and just before closing the device. It is the filter's
// responsibility to ensure that Commit or Decommit calls are called in
// the right order (Commit after this, Decommit before this).
HRESULT CWaveInAllocator::SetWaveHandle(HWAVE hw)
{
    m_hw = hw;

    return NOERROR;
}

HRESULT CWaveInAllocator::LockBuffers(BOOL fLock)
{
    int i;

    if (m_fBuffersLocked == fLock)
    return NOERROR;

    if (!m_hw)
    return NOERROR;

    if (m_lAllocated == 0)
    return NOERROR;

    /* Should never be doing this unless all buffers are freed */

    DbgLog((LOG_TRACE,2,TEXT("Calling waveIn%hsrepare on %u buffers"),
        fLock ? "P" : "Unp", m_lAllocated));

    /* Prepare/unprepare up all the CWaveInSamples */

#if 1
typedef MMRESULT (WINAPI *WAVEFN)(HANDLE, LPWAVEHDR, UINT);

    WAVEFN waveFn;
    waveFn = (fLock ? (WAVEFN)waveInPrepareHeader : (WAVEFN)waveInUnprepareHeader);
#endif

    for (i = 0; i < m_lAllocated; i ++) {
        CWaveInSample *pSample = (CWaveInSample *)m_pQueue->GetQueueObject();

        WAVEHDR *pwh = pSample->GetWaveInHeader();

    UINT err;
#if 1
    err = waveFn(m_hw, pwh, sizeof(WAVEHDR));
#else
    err = (fLock ? waveInPrepareHeader : waveInUnprepareHeader)
                    ((HWAVEIN) m_hw, pwh,
                    sizeof(WAVEHDR));
#endif
        if (err > 0) {
            DbgLog((LOG_ERROR,0,TEXT("Error in waveIn%hsrepare: %u"),
                            fLock ? "P" : "Unp", err));

            // !!! Need to unprepare everything....
            ASSERT(FALSE);
                m_pQueue->PutQueueObject(pSample);
            return E_FAIL; // !!!!
        }

        m_pQueue->PutQueueObject(pSample);
    }

    m_fBuffersLocked = fLock;

    return NOERROR;
}


/* The destructor ensures the shared memory DIBs are deleted */

CWaveInAllocator::~CWaveInAllocator()
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInAllocator:: destructor")));

    delete[] (BYTE *) m_lpwfxA;
}


// Agree the number and size of buffers to be used. No memory
// is allocated until the Commit call.
STDMETHODIMP CWaveInAllocator::SetProperties(
            ALLOCATOR_PROPERTIES* pRequest,
            ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pRequest,E_POINTER);
    CheckPointer(pActual,E_POINTER);

    ALLOCATOR_PROPERTIES Adjusted = *pRequest;

    // round the buffer size down to the requested alignment
    // !!! How important is this?  It might be undone by the next line
    Adjusted.cbBuffer -= (Adjusted.cbBuffer % m_lpwfxA->nBlockAlign);

    // round the buffer and prefix size up to the requested alignment
    Adjusted.cbBuffer = (DWORD)ALIGNUP(Adjusted.cbBuffer + Adjusted.cbPrefix,
                    Adjusted.cbAlign) - Adjusted.cbPrefix;

    if (Adjusted.cbBuffer <= 0) {
        return E_INVALIDARG;
    }

    // Don't call the base class ::SetProperties, it rejects anything
    // without align == 1! We need to connect to AVIMux, align=4, prefix=8

    /* Can't do this if already committed, there is an argument that says we
       should not reject the SetProperties call if there are buffers still
       active. However this is called by the source filter, which is the same
       person who is holding the samples. Therefore it is not unreasonable
       for them to free all their samples before changing the requirements */

    if (m_bCommitted) {
    return VFW_E_ALREADY_COMMITTED;
    }

    /* Must be no outstanding buffers */

    // !!! CQueue has no GetCount - how do we tell this?
    //if (m_lAllocated != m_lFree.GetCount())
    //    return VFW_E_BUFFERS_OUTSTANDING;

    /* There isn't any real need to check the parameters as they
       will just be rejected when the user finally calls Commit */

    pActual->cbBuffer = m_lSize = Adjusted.cbBuffer;
    pActual->cBuffers = m_lCount = Adjusted.cBuffers;
    pActual->cbAlign = m_lAlignment = Adjusted.cbAlign;
    pActual->cbPrefix = m_lPrefix = Adjusted.cbPrefix;

    DbgLog((LOG_TRACE,2,TEXT("Using: cBuffers-%d  cbBuffer-%d  cbAlign-%d  cbPrefix-%d"),
                m_lCount, m_lSize, m_lAlignment, m_lPrefix));
    m_bChanged = TRUE;
    return NOERROR;
}


// allocate and prepare the buffers

STDMETHODIMP CWaveInAllocator::Commit(void) {

    // !!! I can't commit until the wave device is open.
    if (m_hw == NULL)
        return S_OK;

    return CBaseAllocator::Commit();
}


// called from base class to alloc memory when moving to commit state.
// object locked by base class
HRESULT
CWaveInAllocator::Alloc(void)
{
    int i;

    /* Check the base class says it's ok to continue */

    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
        return hr;
    }

    // our FIFO stack of samples that are ready to deliver
    m_pQueue = new CNBQueue<CWaveInSample>(m_lCount, &hr );
    if( NULL == m_pQueue || FAILED( hr ) )
    {
        delete m_pQueue;
        m_pQueue = NULL;
        return E_OUTOFMEMORY;
    }

    m_pDownQueue = new CNBQueue<CWaveInSample>(m_lCount, &hr );
    if( NULL == m_pDownQueue || FAILED( hr ) )
    {
        delete m_pDownQueue;
        delete m_pQueue;
        m_pQueue = NULL;
        m_pDownQueue = NULL;
        return E_OUTOFMEMORY;
    }

    CWaveInSample *pSample;      // Pointer to the new sample

    // Be careful.  We are allocating memory which will look like this:
    // WAVEHDR | align bytes | prefix | memory
    // The Sample will be given "memory".  WAVEHDR.lpData will be given "memory"

    DbgLog((LOG_TRACE,1,TEXT("Allocating %d wave buffers, %d bytes each"), m_lCount, m_lSize));

    ASSERT(m_lAllocated == 0);
    for (; m_lAllocated < m_lCount; m_lAllocated++) {
        /* Create and initialise a buffer */
        BYTE * lpMem = new BYTE[m_lSize + m_lPrefix + m_lAlignment +
                                sizeof(WAVEHDR)];
        WAVEHDR * pwh = (WAVEHDR *) lpMem;
        LPBYTE lpData = (LPBYTE)ALIGNUP(lpMem + sizeof(WAVEHDR), m_lAlignment) +
                                m_lPrefix;

        if (lpMem == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Ack! Ran out of memory for buffers!")));
            hr = E_OUTOFMEMORY;
            break;
        }

        pwh->lpData = (LPSTR)lpData;
        pwh->dwBufferLength = m_lSize;
        pwh->dwFlags = 0;

        // Give our WaveInSample the start of the wavehdr.  It knows enough to
        // look at pwh->lpData as the spot to find it's data, and to
        // pwh->dwBufferLength for the size, but it will remember pwh so we
        // can get that back again

        pSample = new CWaveInSample(this, &hr, pwh);

        pwh->dwUser = (DWORD_PTR) pSample;

        /* Clean up the resources if we couldn't create the object */

        if (FAILED(hr) || pSample == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Ack! Couldn't make a new sample!")));
            delete[] lpMem;
            break;
        }

        /* Add the completed sample to the available list */

        m_pQueue->PutQueueObject(pSample);
    }

    // !!! Ack what if we ran out of memory and don't have enough buffers?

    LockBuffers(TRUE);

    /* Put all the media samples we have just created also onto the free list
       so they can be allocated. They all have a reference count of zero */

    for (i = 0; i < m_lAllocated; i++) {
        // for recording, this will actually add the buffers to the device's
        // queue....
        CWaveInSample *pSample = (CWaveInSample *)m_pQueue->GetQueueObject();

        // This is a hacky way of triggering the release code to call
        // waveInAddBuffer
        pSample->AddRef();
        pSample->Release();
    }

    return NOERROR;
}


// called by CWaveInSample to return it to the free list and
// block any pending GetSample call.
STDMETHODIMP
CWaveInAllocator::ReleaseBuffer(IMediaSample * pSample)
{
    if (m_hw && !m_bDecommitInProgress) {
        LPWAVEHDR pwh = ((CWaveInSample *)pSample)->GetWaveInHeader();

        // set to full size of buffer
        pwh->dwBufferLength = pSample->GetSize();

        if (!m_fAddBufferDangerous) {
            DbgLog((LOG_TRACE,4, TEXT("ReleaseBuffer: Calling WaveInAddBuffer: sample %X, %u byte buffer"),
                				    pSample, pwh->dwBufferLength));

 	    // Assume the add buffer will succeed, and put this buffer on our list
	    // of stuff given to the driver.  If it DOESN'T succeed, take it off
	    // the down Q, protected by the critical section for the Q, since
	    // we're playing around with it alot.  Do not hold the CS around
	    // AddBuffer, or the wave driver will hang because we sometimes
	    // take the CS in the wave callback, and the driver seems to not like
	    // that.
            m_pDownQueue->PutQueueObject((CWaveInSample*)pSample);
            UINT err = waveInAddBuffer((HWAVEIN) m_hw, pwh, sizeof(WAVEHDR));

            if (err > 0) {
                DbgLog((LOG_ERROR,1,TEXT("Error from waveInAddBuffer: %d"),
                                        err));
                // if the wave driver doesn't own it, we better put it back
                // on the queue ourselves, or we'll hang with an empty queue
                // make it empty so our thread will know something's wrong and
                // not try to Deliver it!
                pSample->SetActualDataLength(0);
                m_pQueue->PutQueueObject((CWaveInSample *)pSample);
                // !!! hr = E_FAIL;

	        // OOps.  Take it off the down Q
	        m_csDownQueue.Lock();
                CWaveInSample *pSearchSamp;
                int iSamp = m_lCount;
                while ((pSearchSamp = m_pDownQueue->GetQueueObject(FALSE)) != NULL
                					    && iSamp-- > 0) {
                    if (pSearchSamp == pSample) { break; }
                    m_pDownQueue->PutQueueObject(pSearchSamp);
	        }
                ASSERT(pSearchSamp == pSample);	// what happened to it?
	        m_csDownQueue.Unlock();

            } else {
                DbgLog((LOG_TRACE, 4, TEXT("ReleaseBuffer: Putting buffer %X in down queue"),
                    pSample));
            }
        } else {
            // !!! Most wave drivers I've seen have a bug where, if you send
            // them a buffer after calling waveInStop, they might never give
            // it back!  Well, that will hang the system, so if I'm in a paused
            // state now and was last in a running state, that means I'm in
            // that situation so I'm not giving the buffer to the driver.
            DbgLog((LOG_TRACE,1,TEXT("************************")));
            DbgLog((LOG_TRACE,1,TEXT("*** AVOIDING HANGING ***")));
            DbgLog((LOG_TRACE,1,TEXT("************************")));
            pSample->SetActualDataLength(0);
            m_pQueue->PutQueueObject((CWaveInSample *)pSample);
        }
    } else {
        DbgLog((LOG_TRACE,4,TEXT("ReleaseBuffer: Putting back on QUEUE")));
        m_pQueue->PutQueueObject((CWaveInSample *)pSample);
    }

    return NOERROR;
}


/* This goes in the factory template table to create new instances */

CUnknown *CWaveInFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CWaveInFilter(pUnk, phr);  // need cast here?
}

#pragma warning(disable:4355)
/* Constructor - initialise the base class */

CWaveInFilter::CWaveInFilter(
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseFilter(NAME("WaveInFilter"), pUnk, (CCritSec *) this, CLSID_AudioRecord)
    , CPersistStream(pUnk, phr)
    , m_fStopping(FALSE)
    , m_llCurSample(0)
    , m_llBufferTime(0)
    , m_cInputPins(0)
    , m_hwi(NULL)
    , m_pOutputPin(0)
    , m_dwLockCount(0)
    , m_cTypes(0)
    , m_ulPushSourceFlags( 0 )
    , m_dwDstLineID(0xffffffff)
{
    m_WaveDeviceToUse.fSet = FALSE;
    ZeroMemory( m_lpwfxArray, sizeof(DWORD) * g_cMaxPossibleTypes );
    DbgLog((LOG_TRACE,1,TEXT("CWaveInFilter:: constructor")));
}


#pragma warning(default:4355)

/* Destructor */

CWaveInFilter::~CWaveInFilter()
{

    DbgLog((LOG_TRACE,1,TEXT("CWaveInFilter:: destructor")));


    CloseWaveDevice();

    delete m_pOutputPin;

    int i;
    for (i = 0; i < m_cInputPins; i++)
    delete m_pInputPin[i];

    // our cached formats we can offer through GetMediaType
    while (m_cTypes-- > 0)
	    QzTaskMemFree(m_lpwfxArray[m_cTypes]);


}


/* Override this to say what interfaces we support and where */

STDMETHODIMP CWaveInFilter::NonDelegatingQueryInterface(REFIID riid,
                                                        void ** ppv)
{
    if (riid == IID_IAMAudioInputMixer) {
    return GetInterface((LPUNKNOWN)(IAMAudioInputMixer *)this, ppv);
    } else if (riid == IID_IPersistPropertyBag) {
        return GetInterface((IPersistPropertyBag*)this, ppv);
    } else if(riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    } else  if (riid == IID_IAMResourceControl) {
        return GetInterface((IAMResourceControl *)this, ppv);
    } else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages*)(this), ppv);
    } else if (riid == IID_IAMFilterMiscFlags) {
        return GetInterface((IAMFilterMiscFlags*)(this), ppv);
    }


    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}


// IBaseFilter stuff

CBasePin *CWaveInFilter::GetPin(int n)
{
    //  Note if m_pOutputPin is NULL this works by returning NULL
    //  for the first pin which is consistent with having 0 pins
    if (n == 0)
        return m_pOutputPin;
    else
    return m_pInputPin[n-1];
}


// tell the Stream control stuff what's going on
STDMETHODIMP CWaveInFilter::SetSyncSource(IReferenceClock *pClock)
{
    if (m_pOutputPin)
        m_pOutputPin->SetSyncSource(pClock);
    return CBaseFilter::SetSyncSource(pClock);
}


// tell the Stream control stuff what's going on
STDMETHODIMP CWaveInFilter::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);
    if (hr == S_OK && m_pOutputPin)
        m_pOutputPin->SetFilterGraph(m_pSink);
    return hr;
}


HRESULT CWaveInFilter::CreatePinsOnLoad()
{
    // !!! mixer barfs if we pick WAVE_MAPPER

    ASSERT(m_WaveDeviceToUse.fSet);

    // !!! NO LATENCY for capture pins
    //m_nLatency = GetProfileInt("wavein", "Latency", 666666);
    m_nLatency = 0;
    m_cTypes = 0; // we're initialized with no types

    HRESULT hr = S_OK;
    m_pOutputPin = new CWaveInOutputPin(this,        // Owning filter
                                        &hr,         // Result code
                                        L"Capture"); // Pin name
    if(m_pOutputPin == 0)
        return E_OUTOFMEMORY;
    if(SUCCEEDED(hr))
    {
        ASSERT(m_pOutputPin);

        // one for each input that can be mixed
        MakeSomeInputPins(m_WaveDeviceToUse.devnum, &hr);

        // !!! TEST ONLY
#if 0
        int f;
        double d;
        put_Enable(FALSE);
        get_Enable(&f);
        put_Mono(TRUE);
        get_Mono(&f);
        get_TrebleRange(&d);
        put_MixLevel(1.);
        put_Pan(-.5);
#endif

    }

    return hr;
}

// load a default format
HRESULT CWaveInFilter::LoadDefaultType()
{
    ASSERT( 0 == m_cTypes ); // should only be called once

    // initialize a default format to record in - could be variable size later
    m_lpwfxArray[0] = (LPWAVEFORMATEX)QzTaskMemAlloc(sizeof(WAVEFORMATEX));
    if (m_lpwfxArray[0] == NULL) {
        return E_OUTOFMEMORY;
    }
    MMRESULT mmrQueryOpen            = MMSYSERR_ERROR;

    m_lpwfxArray[0]->wFormatTag      = WAVE_FORMAT_PCM;
#if 0 // for TESTING ONLY!!
    m_lpwfxArray[0]->nSamplesPerSec  = GetProfileIntA("wavein", "Frequency", g_afiFormats[0].nSamplesPerSec);
    m_lpwfxArray[0]->nChannels       = (WORD)GetProfileIntA("wavein", "Channels", g_afiFormats[0].nChannels);
    m_lpwfxArray[0]->wBitsPerSample  = (WORD)GetProfileIntA("wavein", "BitsPerSample", g_afiFormats[0].wBitsPerSample);
    m_lpwfxArray[0]->nBlockAlign     = m_lpwfxArray[0]->nChannels * ((m_lpwfxArray[0]->wBitsPerSample + 7) / 8);
    m_lpwfxArray[0]->nAvgBytesPerSec = m_lpwfxArray[0]->nSamplesPerSec * m_lpwfxArray[0]->nBlockAlign;
    m_lpwfxArray[0]->cbSize          = 0;
    mmrQueryOpen = waveInOpen(NULL, m_WaveDeviceToUse.devnum, m_lpwfxArray[0], 0, 0, WAVE_FORMAT_QUERY );
#endif

    if (mmrQueryOpen != 0)
    {
        // find a type to make the default
        for (int i = 0; i < (g_cMaxFormats) && 0 != mmrQueryOpen ; i ++)
        {
            m_lpwfxArray[0]->wBitsPerSample  = g_afiFormats[i].wBitsPerSample;
            m_lpwfxArray[0]->nChannels       = g_afiFormats[i].nChannels;
            m_lpwfxArray[0]->nSamplesPerSec  = g_afiFormats[i].nSamplesPerSec;
            m_lpwfxArray[0]->nBlockAlign     = g_afiFormats[i].nChannels *
                                                          ((g_afiFormats[i].wBitsPerSample + 7)/8);
            m_lpwfxArray[0]->nAvgBytesPerSec = g_afiFormats[i].nSamplesPerSec *
                                                          m_lpwfxArray[0]->nBlockAlign;
            m_lpwfxArray[0]->cbSize          = 0;

            mmrQueryOpen = waveInOpen( NULL
                            , m_WaveDeviceToUse.devnum
                            , m_lpwfxArray[0]
                            , 0
                            , 0
                            , WAVE_FORMAT_QUERY );
        }
    }
    if (mmrQueryOpen != 0)
    {
        // ACK!  This device is useless! BAIL or not? !!!
        NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Query, mmrQueryOpen );

        DbgLog((LOG_ERROR,1,TEXT("*** Useless device can't record!")));
        DbgLog((LOG_ERROR,1,TEXT("Error in waveInOpen: %u"), mmrQueryOpen));

        QzTaskMemFree(m_lpwfxArray[0]);
        return E_FAIL;
    }
    m_cTypes = 1; // this means we've been successfully created with a default type

    return NOERROR;
}


// override GetState to report that we don't send any data when paused, so
// renderers won't starve expecting that
//
STDMETHODIMP CWaveInFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    if (m_State == State_Paused)
        return VFW_S_CANT_CUE;
    else
        return S_OK;
}


// switch the filter into stopped mode.
STDMETHODIMP CWaveInFilter::Stop()
{
    CAutoLock lock(this);

    // Shame on the base classes!
    if (m_State == State_Running) {
        HRESULT hr = Pause();
        if (FAILED(hr)) {
            return hr;
        }
    }

    if (m_pOutputPin)
        m_pOutputPin->NotifyFilterState(State_Stopped, 0);

    // next time we stream, start the sample count back at 0
    m_llCurSample = 0;

    return CBaseFilter::Stop();
}


STDMETHODIMP CWaveInFilter::Pause()
{
    CAutoLock lock(this);

    DbgLog((LOG_TRACE,1,TEXT("CWaveInFilter::Pause")));

    if (m_pOutputPin)
        m_pOutputPin->NotifyFilterState(State_Paused, 0);

    HRESULT hr = NOERROR;

    // don't do anything if we don't have a device to use or we aren't
    // connected up
    if(m_WaveDeviceToUse.fSet && m_pOutputPin->IsConnected())
    {
        /* Check we can PAUSE given our current state */

        if (m_State == State_Running) {
            ASSERT(m_hwi);

            DbgLog((LOG_TRACE,1,TEXT("Wavein: Running->Paused")));

            // hack for buggy wave drivers
            m_pOutputPin->m_pOurAllocator->m_fAddBufferDangerous = TRUE;
            MMRESULT mmr = waveInStop(m_hwi);
            if (mmr > 0)
            {
                NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Stop, mmr );
                DbgLog((LOG_ERROR,0,TEXT( "Error in waveInStop: %u" ), mmr ) );
            }
        } else {
            if (m_State == State_Stopped) {
                DbgLog((LOG_TRACE,1,TEXT("Wavein: Inactive->Paused")));

                // open the wave device. We keep it open until the
                // last buffer using it is released and the allocator
                // goes into Decommit mode.
                hr = OpenWaveDevice();
                if (FAILED(hr)) {
                    return hr;
                }
            }
        }
    }

    // tell the pin to go inactive and change state
    return CBaseFilter::Pause();
}


STDMETHODIMP CWaveInFilter::Run(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInFilter::Run at %d"),
                    (LONG)((CRefTime)tStart).Millisecs()));

    CAutoLock lock(this);

    HRESULT hr = NOERROR;
    DWORD dw;

    if (m_pOutputPin)
        m_pOutputPin->NotifyFilterState(State_Running, tStart);

    FILTER_STATE fsOld = m_State;

    // this will call Pause if currently stopped
    hr = CBaseFilter::Run(tStart);
    if (FAILED(hr)) {
        return hr;
    }

    // don't do anything if we're not connected
    if (fsOld != State_Running && m_WaveDeviceToUse.fSet && m_pOutputPin->IsConnected()) {

        DbgLog((LOG_TRACE,1,TEXT("Paused->Running")));

        ASSERT( m_pOutputPin->m_Worker.ThreadExists() );

        //
        // First ensure the worker processing thread isn't running when we
        // unset the m_fAddBufferDangerous flag (otherwise we could deadlock
        // on the call to m_Worker.Run() if the worker thread blocks waiting
        // to get a sample off the queue after a Run->Pause->Run transition).
        //
        hr = m_pOutputPin->m_Worker.Stop();
        if (FAILED(hr)) {
            return hr;
        }

        // hack for buggy wave drivers
        m_pOutputPin->m_pOurAllocator->m_fAddBufferDangerous = FALSE;

        // Start the run loop
        m_pOutputPin->m_Worker.Run();

        dw = waveInStart(m_hwi);
        if (dw != 0)
        {
            NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Start, dw );
            DbgLog((LOG_ERROR,1,TEXT("***Error %d from waveInStart"), dw));
        }

        // !!! assume the 1st sample in the 1st buffer will be captured now
        if (m_pClock)
            m_pClock->GetTime(&m_llBufferTime);
    }

    return NOERROR;
}

// open the wave device if not already open
// called by the wave allocator at Commit time
HRESULT
CWaveInFilter::OpenWaveDevice( WAVEFORMATEX *pwfx )
{
    //  If application has forced acquisition of resources just return
    if (m_dwLockCount != 0) {
        ASSERT(m_hwi);
        return S_OK;
    }

    if( !pwfx )
    {
        // use default type
        pwfx = (WAVEFORMATEX *) m_pOutputPin->m_mt.Format();
    }

    ASSERT(m_WaveDeviceToUse.fSet);

    DbgLog((LOG_TRACE,1,TEXT("Opening wave device....")));

    UINT err = waveInOpen(&m_hwi,
                           m_WaveDeviceToUse.devnum,
                           pwfx,
                           (DWORD_PTR) &CWaveInFilter::WaveInCallback,
                           (DWORD_PTR) this,
                           CALLBACK_FUNCTION);

    // Reset time to zero

    m_rtCurrent = 0;

    if (err != 0) {
        NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Open, err );
        DbgLog((LOG_ERROR,1,TEXT("Error opening wave device: %u"), err));
        return E_FAIL; // !!! resource management?
    }
    if( m_pOutputPin && m_pOutputPin->m_pOurAllocator )
    {
        // if we're opening the device in response to a SetFormat call, we rightly won't have an allocator
        m_pOutputPin->m_pOurAllocator->SetWaveHandle((HWAVE) m_hwi);
    }

    err = waveInStop(m_hwi);
    if (err != 0)
    {
        NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Stop, err );
        DbgLog((LOG_ERROR,1,TEXT("waveInStop returned error: %u"), err));
    }

    return NOERROR;

// !!! we don't report error properly!  We should throw exception!
}

//  Tidy up function
void CWaveInFilter::CloseWaveDevice( )
{
    if (m_hwi) {
        MMRESULT mmr = waveInClose((HWAVEIN)m_hwi);
        if (mmr != 0)
        {
            NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Close, mmr );
            DbgLog((LOG_ERROR,1,TEXT("waveInClose returned error: %u"), mmr));
        }
        m_hwi = NULL;
        if( m_pOutputPin && m_pOutputPin->m_pOurAllocator )
        {
            // if we're opening the device in response to a SetFormat call, we rightly won't have an allocator
            m_pOutputPin->m_pOurAllocator->SetWaveHandle((HWAVE) NULL);
        }
    }
}


/* ----- Implements the CWaveInWorker class ------------------------------ */


CWaveInWorker::CWaveInWorker()
{
    m_pPin = NULL;
}

BOOL
CWaveInWorker::Create(CWaveInOutputPin * pPin)
{
    CAutoLock lock(&m_AccessLock);

    if (m_pPin || pPin == NULL) {
    return FALSE;
    }
    m_pPin = pPin;
    m_pPin->m_fLastSampleDiscarded = FALSE;
    return CAMThread::Create();
}


HRESULT
CWaveInWorker::Run()
{
    return CallWorker(CMD_RUN);
}

HRESULT
CWaveInWorker::Stop()
{
    return CallWorker(CMD_STOP);
}


HRESULT
CWaveInWorker::Exit()
{
    CAutoLock lock(&m_AccessLock);

    HRESULT hr = CallWorker(CMD_EXIT);
    if (FAILED(hr)) {
    return hr;
    }

    // wait for thread completion and then close
    // handle (and clear so we can start another later)
    Close();

    m_pPin = NULL;
    return NOERROR;
}


// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD
CWaveInWorker::ThreadProc()
{
    DbgLog((LOG_TRACE,2,TEXT("Starting wave input background thread")));

    BOOL bExit = FALSE;
    while (!bExit) {

    Command cmd = GetRequest();

    switch (cmd) {

    case CMD_EXIT:
            bExit = TRUE;
            Reply(NOERROR);
            break;

    case CMD_RUN:
            Reply(NOERROR);
            DoRunLoop();
            break;

    case CMD_STOP:
            Reply(NOERROR);
            break;

        default:
            Reply(E_NOTIMPL);
            break;
        }
    }
    return NOERROR;
}


void
CWaveInWorker::DoRunLoop(void)
{
    // general strategy:
    // wait for data to come in, then send it.
    // when it comes back, put it back on the chain.

    HRESULT hr;
    DbgLog((LOG_TRACE,2,TEXT("Starting wave input background loop")));
    CWaveInSample *pSample;
    REFERENCE_TIME rtNoOffsetStart, rtNoOffsetEnd;
    while (1) {

// this tries to fix a problem that might not exist
#if 0
        // we'll hang if we try to get a queue object on an empty queue
        // that will never get anything on it.
        // This is the equivalent of GetBuffer failing if things are un
        // committed
        if (!m_pPin->m_pOurAllocator->m_bCommitted) {
            DbgLog((LOG_TRACE,1,TEXT("No allocator - can't get buffer")));
            break;
        }
#endif

        // get a buffer - this blocks!
        DbgLog((LOG_TRACE,4,TEXT("Calling GetQueueObject")));
        pSample = m_pPin->m_pOurAllocator->m_pQueue->GetQueueObject();
        DbgLog((LOG_TRACE,4,TEXT("GetQueueObject returned sample %X"),pSample));

        // we're supposed to stop - we shouldn't have gotten that sample
        // or, this buffer was never filled due to an error somewhere
        if (!m_pPin->m_pOurAllocator->m_bCommitted ||
             ( ( m_pPin->m_pOurAllocator->m_bDecommitInProgress ||
                 m_pPin->m_pOurAllocator->m_fAddBufferDangerous ) &&
               0 == pSample->GetActualDataLength() ) )
        {
            // put it back!
            DbgLog((LOG_TRACE,1,TEXT("EMPTY BUFFER - not delivering")));
            m_pPin->m_pOurAllocator->m_pQueue->PutQueueObject(pSample);
            break;
        }

        // The guy we deliver the sample to might not addref it if he doesn't
        // want it, but we have to make sure the sample gets ReleaseBuffer'd,
        // which only happens on a Release, so do this hack
        pSample->AddRef();

        // don't deliver 0-length samples since we don't timestamp them
        // (but remember that we still need to go through the AddRef and Release
        // exercise on the sample in order to reuse the buffer)
        if( 0 != pSample->GetActualDataLength() )
        {
             REFERENCE_TIME rtStart, rtEnd;
             BOOL bResetTime = FALSE;
             if (0 < m_pPin->m_rtStreamOffset &&
                 pSample->GetTime(&rtStart, &rtEnd) == NOERROR)
             {
                // If we're using an offset for timestamps:
                // for stream control to work (not block) we need to
                // give it sample times that don't use an offset

                rtNoOffsetStart = rtStart - m_pPin->m_rtStreamOffset;
                rtNoOffsetEnd   = rtEnd   - m_pPin->m_rtStreamOffset;
                pSample->SetTime( &rtNoOffsetStart, &rtNoOffsetEnd );
                bResetTime = TRUE;
             }

             int iState = m_pPin->CheckStreamState(pSample);

             if( bResetTime )
             {
                // now timestamp with the correct timestamps
                // (if we're using an offset for timestamps)!
                pSample->SetTime( &rtStart, &rtEnd );
             }

             // it's against the law to send a time stamp backwards in time from
             // the one sent last time.  This could happen if the graph was run,
             // paused, then run again
             if (pSample->GetTime(&rtStart, &rtEnd) == NOERROR) {
                 if (rtStart < m_pPin->m_rtLastTimeSent) {
                     DbgLog((LOG_TRACE,3,TEXT("Discarding back-in-time sample")));
                     iState = m_pPin->STREAM_DISCARDING;
                 }
             } else {
                 ASSERT(FALSE);    // shouldn't happen
                 rtStart = m_pPin->m_rtLastTimeSent;
             }

             if (iState == m_pPin->STREAM_FLOWING) {
                 DbgLog((LOG_TRACE,4,TEXT("Flowing samples...")));

                 CRefTime rt;
                 HRESULT hr = m_pPin->m_pFilter->StreamTime(rt);
                 DbgLog((LOG_TRACE, 8, TEXT("wavein: Stream time just before Deliver: %dms"), (LONG)(rt / 10000) ) );

                 if (m_pPin->m_fLastSampleDiscarded)
                     pSample->SetDiscontinuity(TRUE);

                 m_pPin->m_fLastSampleDiscarded = FALSE;
             } else {
                 DbgLog((LOG_TRACE,4,TEXT("Discarding samples...")));
                 m_pPin->m_fLastSampleDiscarded = TRUE;
             }

             // we INSIST on our own allocator
             ASSERT(m_pPin->m_fUsingOurAllocator);

             // check for loop exit here???
             if (iState == m_pPin->STREAM_FLOWING) {
                 // got a buffer back from the device, now send it to our friend
                 DbgLog((LOG_TRACE,4,TEXT("Delivering sample %X"), pSample));
                 hr = m_pPin->Deliver(pSample);
                 m_pPin->m_rtLastTimeSent = rtStart;    // remember last time sent

                 if (hr != S_OK) {
                     // stop the presses.
                     pSample->Release();
                     DbgLog((LOG_ERROR,1,TEXT("Error from Deliver: %lx"), hr));
                     break;
                 }
             }
        }

        // The guy we deliver the sample to might not addref it if he doesn't
        // want it, but we have to make sure the sample gets ReleaseBuffer'd,
        // which only happens on a Release, so do this hack
        pSample->Release();

        // any other requests ?
        Command com;
        if (CheckRequest(&com)) {

            // if it's a run command, then we're already running, so
            // eat it now.
            if (com == CMD_RUN) {
                GetRequest();
                Reply(NOERROR);
            } else {
                break;
            }
        }
    }
    DbgLog((LOG_TRACE,2,TEXT("Leaving wave input background loop")));
}

void
CALLBACK CWaveInFilter::WaveInCallback(HDRVR waveHeader, UINT callBackMessage,
    DWORD_PTR userData, DWORD_PTR dw1, DWORD_PTR dw2)
{
// really need a second worker thread here, because
// one shouldn't do this much in a wave callback.
// !!! is this why we are dropping samples????
//     just how expensive/(blocking?) are the quartz calls?

    CWaveInFilter *pFilter = (CWaveInFilter *) userData;

    switch (callBackMessage) {
    case WIM_DATA:
    {
        if( NULL == pFilter->m_pOutputPin || NULL == pFilter->m_pOutputPin->m_pOurAllocator )
        {
            ASSERT( pFilter->m_pOutputPin );
            ASSERT( pFilter->m_pOutputPin->m_pOurAllocator );

            // shouldn't happen, but get out of here if it does!
            return;
        }

        LPWAVEHDR waveBufferHeader = (LPWAVEHDR) dw1; // !!! verify?
        CWaveInSample *pSample = (CWaveInSample *) waveBufferHeader->dwUser;

        //
        // Walk through the down queue and look for our sample.  In
        //  the mean time if we come across buffers that aren't the one
        //  were looking for just push them back on the end.  Also
        //  just in case the driver fires a callback with some random
        //  address make sure we don't get in an infinite loop.
        //
        DbgLog((LOG_TRACE,4,TEXT("WIM_DATA: %x"), pSample));
        CWaveInSample *pSearchSamp;
        int iSamp = pFilter->m_pOutputPin->m_pOurAllocator->m_lCount;

	// we're going through the whole down queue.  Keep out!
	pFilter->m_pOutputPin->m_pOurAllocator->m_csDownQueue.Lock();

        while ((pSearchSamp = pFilter->m_pOutputPin->m_pOurAllocator->
                    m_pDownQueue->GetQueueObject(FALSE)) != NULL
                && iSamp-- > 0) {

            if (pSearchSamp == pSample) { break; }
            DbgLog((LOG_TRACE,4,TEXT("Found %x: back on queue"), pSearchSamp));
            pFilter->m_pOutputPin->m_pOurAllocator->m_pDownQueue->PutQueueObject(pSearchSamp);

        }

	pFilter->m_pOutputPin->m_pOurAllocator->m_csDownQueue.Unlock();
        ASSERT(pSearchSamp == pSample);

        HRESULT hr =
           pSample->SetActualDataLength(waveBufferHeader->dwBytesRecorded);
        ASSERT(SUCCEEDED(hr));
        CRefTime rtStart, rtEnd;

        // !!! something better if no clock?
        // we have no clock - stamp each buffer assuming starting at zero
        // and using the audio clock
        if (!pFilter->m_pClock) {
            // increment time by amount recorded
            rtStart = pFilter->m_rtCurrent;
            pFilter->m_rtCurrent +=
            CRefTime((LONG)(waveBufferHeader->dwBytesRecorded * 1000 /
             ((WAVEFORMATEX *) pFilter->m_pOutputPin->m_mt.Format())->nAvgBytesPerSec));
            pSample->SetTime((REFERENCE_TIME *) &rtStart,
                             (REFERENCE_TIME *) &pFilter->m_rtCurrent);

        // we have a clock.  see what time it thinks it was when the first
        // sample was captured.
        // !!! BAD HACK! This assumes the clock runs at the same rate as
        // the audio clock during the filling of the buffer, and it doesn't
        // take into account the random delay before getting the callback!!
        } else {
        CRefTime curtime;
        // what time is it now (at the end of the buffer)?
        pFilter->m_pClock->GetTime((REFERENCE_TIME *)&curtime);
        // what time was it at the beginning of the buffer?
        CRefTime rtBegin = pFilter->m_llBufferTime;
        // !!! assume 1st sample of next buffer is being captured NOW
        pFilter->m_llBufferTime = curtime;
        // make a stream time by subtracting the time we were run at
        rtStart = rtBegin - pFilter->m_tStart +
                        (LONGLONG)pFilter->m_nLatency +
                        pFilter->m_pOutputPin->m_rtStreamOffset;

        // calculate the end stream time of this block of samples
        rtEnd = curtime - pFilter->m_tStart +
                        (LONGLONG)pFilter->m_nLatency +
                        pFilter->m_pOutputPin->m_rtStreamOffset;

            pSample->SetTime((REFERENCE_TIME *)&rtStart,
                             (REFERENCE_TIME *)&rtEnd);
#ifdef DEBUG
            CRefTime rt;
            HRESULT hr = pFilter->StreamTime(rt);
            DbgLog((LOG_TRACE, 8, TEXT("wavein: Stream time in wavein callback: %dms"), (LONG)(rt / 10000) ) );
#endif
        }
        WAVEFORMATEX *lpwf = ((WAVEFORMATEX *)pFilter->
                        m_pOutputPin->m_mt.Format());
        LONGLONG llNext = pFilter->m_llCurSample + waveBufferHeader->
            dwBytesRecorded / (lpwf->wBitsPerSample *
            lpwf->nChannels / 8);
        pSample->SetMediaTime((LONGLONG *)&pFilter->m_llCurSample,
                             (LONGLONG *)&llNext);
        DbgLog((LOG_TRACE,3,
            TEXT("Stamps: Time(%d,%d) MediaTime(%d,%d)"),
            (LONG)rtStart.Millisecs(), (LONG)rtEnd.Millisecs(),
            (LONG)pFilter->m_llCurSample, (LONG)llNext));
        DbgLog((LOG_TRACE,4, TEXT("WIM_DATA (%x): Putting back on queue"),
                                pSample));
        pFilter->m_llCurSample = llNext;

        pFilter->m_pOutputPin->m_pOurAllocator->m_pQueue->PutQueueObject(
                                pSample);
    }
        break;

    case WIM_OPEN:
    case WIM_CLOSE:
        break;

    default:
        DbgLog((LOG_ERROR,1,TEXT("Unexpected wave callback message %d"),
           callBackMessage));
        break;
    }
}


// how many pins do we have?
//
int CWaveInFilter::GetPinCount()
{
    DbgLog((LOG_TRACE,5,TEXT("CWaveInFilter::GetPinCount")));

    // 1 outpin pin, maybe some input pins
    return m_pOutputPin ? 1 + m_cInputPins : 0;
}


/* Constructor */

CWaveInOutputPin::CWaveInOutputPin(
    CWaveInFilter *pFilter,
    HRESULT *phr,
    LPCWSTR pPinName)
    : CBaseOutputPin(NAME("WaveIn Output Pin"), pFilter, pFilter, phr, pPinName)
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInOutputPin:: constructor")));

    m_pFilter = pFilter;
    m_pOurAllocator = NULL;
    m_fUsingOurAllocator = FALSE;

    // no suggestion yet
    m_propSuggested.cBuffers = -1;
    m_propSuggested.cbBuffer = -1;
    m_propSuggested.cbAlign = -1;
    m_propSuggested.cbPrefix = -1;

    m_rtLatency = 0;
    m_rtStreamOffset = 0;
    m_rtMaxStreamOffset = 0;

// !!! TEST ONLY
#if 0
    ALLOCATOR_PROPERTIES prop;
    IAMBufferNegotiation *pBN;
    prop.cBuffers = GetProfileInt("wavein", "cBuffers", 4);
    prop.cbBuffer = GetProfileInt("wavein", "cbBuffer", 65536);
    prop.cbAlign = GetProfileInt("wavein", "cbAlign", 4);
    prop.cbPrefix = GetProfileInt("wavein", "cbPrefix", 0);
    HRESULT hr = QueryInterface(IID_IAMBufferNegotiation, (void **)&pBN);
    if (hr == NOERROR) {
    pBN->SuggestAllocatorProperties(&prop);
     pBN->Release();
    }
#endif

// !!! TEST ONLY
#if 0
    AUDIO_STREAM_CONFIG_CAPS ascc;
    int i, j;
    AM_MEDIA_TYPE *pmt;
    GetNumberOfCapabilities(&i, &j);
    DbgLog((LOG_TRACE,1,TEXT("%d capabilitie(s) supported"), i));
    GetStreamCaps(0, &pmt, (BYTE *) &ascc);
    DbgLog((LOG_TRACE,1,TEXT("Media type is format %d"),
                ((LPWAVEFORMATEX)(pmt->pbFormat))->wFormatTag));
    DbgLog((LOG_TRACE,1,TEXT("ch: %d %d  samp: %d %d (%d)  bits: %d %d (%d)"),
                                ascc.MinimumChannels,
                                ascc.MaximumChannels,
                                ascc.ChannelsGranularity,
                                ascc.MinimumSampleFrequency,
                                ascc.MaximumSampleFrequency,
                                ascc.SampleFrequencyGranularity,
                                ascc.MinimumBitsPerSample,
                                ascc.MaximumBitsPerSample,
                                ascc.BitsPerSampleGranularity));
    GetFormat(&pmt);
    DbgLog((LOG_TRACE,1,TEXT("GetFormat is %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec));
    ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec = 22050;
    ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels = 2;
    ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample = 16;
    SetFormat(pmt);
    ((LPWAVEFORMATEX)(pmt->pbFormat))->nBlockAlign = 2 * ((16 + 7) / 8);
    ((LPWAVEFORMATEX)(pmt->pbFormat))->nAvgBytesPerSec = 22050*2*((16 + 7) /8);
    SetFormat(pmt);
    GetFormat(&pmt);
    DbgLog((LOG_TRACE,1,TEXT("GetFormat is %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec));
    DeleteMediaType(pmt);
#endif
}

CWaveInOutputPin::~CWaveInOutputPin()
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInOutputPin:: destructor")));

    /* Release our allocator if we made one */

    if (m_pOurAllocator) {
        m_pOurAllocator->Release();
        m_pOurAllocator = NULL;
    }
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP CWaveInOutputPin::NonDelegatingQueryInterface(REFIID riid,
                                                        void ** ppv)
{
    if (riid == IID_IAMStreamConfig) {
    return GetInterface((LPUNKNOWN)(IAMStreamConfig *)this, ppv);
    } else if (riid == IID_IAMBufferNegotiation) {
    return GetInterface((LPUNKNOWN)(IAMBufferNegotiation *)this, ppv);
    } else if (riid == IID_IAMStreamControl) {
    return GetInterface((LPUNKNOWN)(IAMStreamControl *)this, ppv);
    } else if (riid == IID_IAMPushSource) {
    return GetInterface((LPUNKNOWN)(IAMPushSource *)this, ppv);
    } else if (riid == IID_IKsPropertySet) {
    return GetInterface((LPUNKNOWN)(IKsPropertySet *)this, ppv);
    }

    return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
}


// tell the stream control stuff we're flushing
HRESULT CWaveInOutputPin::BeginFlush()
{
    Flushing(TRUE);
    return CBaseOutputPin::BeginFlush();
}


// tell the stream control stuff we're flushing
HRESULT CWaveInOutputPin::EndFlush()
{
    Flushing(FALSE);
    return CBaseOutputPin::EndFlush();
}


/* This is called when a connection or an attempted connection is terminated
   and allows us to reset the connection media type to be invalid so that
   we can always use that to determine whether we are connected or not. We
   leave the format block alone as it will be reallocated if we get another
   connection or alternatively be deleted if the filter is finally released */

HRESULT CWaveInOutputPin::BreakConnect()
{
    /* Set the CLSIDs of the connected media type */

    m_mt.SetType(&GUID_NULL);
    m_mt.SetSubtype(&GUID_NULL);

    return CBaseOutputPin::BreakConnect();
}



HRESULT
CWaveInOutputPin::Active(void)
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInOutputPin::Active")));

    if (m_pOurAllocator == NULL) {
        return E_FAIL;
    }

    // make sure the first sample sent has a higher time than this
    m_rtLastTimeSent = -1000000;    // -100ms

    // commit and prepare our allocator. Needs to be done
    // if he is not using our allocator, and in any case needs to be done
    // before we complete our close of the wave device.

    HRESULT hr = m_pOurAllocator->Commit();
    if( FAILED( hr ) )
        return hr;

    if (m_pOurAllocator->m_hw == NULL)
        return E_UNEXPECTED;

    // start the thread
    if (!m_Worker.ThreadExists()) {
        if (!m_Worker.Create(this)) {
            return E_FAIL;
        }
    }

    return hr;
}

HRESULT
CWaveInOutputPin::Inactive(void)
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInOutputPin::Inactive")));

    if (m_pOurAllocator == NULL) {
        return E_FAIL;
    }

    // hack: downstream guy decommited us, so when the last callback happens
    // we hang decommiting again because of waveoutUnprepare and the last
    // callback not return
    // !!! why can't I remove this? Try full duplex wavein-->waveout?
    // m_pOurAllocator->Commit();

    // decommit the buffers - normally done by the output
    // pin, but we need to do it here ourselves, before we close
    // the device, and in any case if he is not using our allocator.
    // the output pin will also decommit the allocator if he
    // is using ours, but that's not a problem
    // !!! The base classes will set DecommitInProgress and leave it set (since
    // I never called CMemAllocator::Alloc to put anything on the free list)
    // and I'm counting on that!
    HRESULT hr = m_pOurAllocator->Decommit();

    // Call all the buffers back AFTER decomitting so none will get sent again
    if (m_pFilter->m_hwi)
    {
        MMRESULT mmr = waveInReset(m_pFilter->m_hwi);
        if (mmr != 0)
        {
            m_pFilter->NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Reset, mmr );
            DbgLog((LOG_ERROR,1,TEXT("waveInReset returned error: %u"), mmr));
        }
    }

    // hack for buggy wave drivers
    m_pOurAllocator->m_fAddBufferDangerous = FALSE;

    // now that we've reset the device, wait for the thread to stop using the
    // queue before we destroy it below!
    if (m_Worker.ThreadExists()) {
        hr = m_Worker.Stop();

        if (FAILED(hr)) {
            return hr;
        }

    hr = m_Worker.Exit();
    }

    // we don't use the base allocator's free list, so the allocator is not
    // freed automatically... let's do it now
    // !!! ouch
    m_pOurAllocator->Free();
    if (m_pFilter->m_dwLockCount == 0) {
        m_pFilter->CloseWaveDevice();
    }
    m_pOurAllocator->m_bDecommitInProgress = FALSE;
    m_pOurAllocator->Release();

    return hr;
}


// negotiate the allocator and its buffer size/count
// calls DecideBufferSize to call SetCountAndSize

HRESULT
CWaveInOutputPin::DecideAllocator(IMemInputPin * pPin, IMemAllocator ** ppAlloc)
{
    HRESULT hr;
    *ppAlloc = NULL;

    DbgLog((LOG_TRACE,1,TEXT("CWaveInOutputPin::DecideAllocator")));

    if (!m_pOurAllocator) {
    ASSERT(m_mt.Format());

    hr = S_OK;
    m_pOurAllocator = new CWaveInAllocator(
                    NAME("Wave Input Allocator"),
                                    (WAVEFORMATEX *) m_mt.Format(),
                    &hr);

    if (FAILED(hr) || !m_pOurAllocator) {
        DbgLog((LOG_ERROR,1,TEXT("Failed to create new allocator!")));
        if (m_pOurAllocator) {
        delete m_pOurAllocator;
        m_pOurAllocator = NULL;
        }
        return hr;
    }

    m_pOurAllocator->AddRef();
    }

    /* Get a reference counted IID_IMemAllocator interface */
    m_pOurAllocator->QueryInterface(IID_IMemAllocator,(void **)ppAlloc);
    if (*ppAlloc == NULL) {
    DbgLog((LOG_ERROR,1,TEXT("Couldn't get IMemAllocator from our allocator???")));
        return E_FAIL;
    }

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once

    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    hr = DecideBufferSize(*ppAlloc,&prop);
    if (FAILED(hr)) {
    DbgLog((LOG_ERROR,1,TEXT("Couldn't get set buffer size with our own allocator???")));
    (*ppAlloc)->Release();
        *ppAlloc = NULL;
        return E_FAIL;
    }

    // See if they like our allocator....
    m_fUsingOurAllocator = TRUE;

    // !!! We are not marking our buffers read only - somebody could hurt them
    hr = pPin->NotifyAllocator(*ppAlloc,FALSE);

    // if they don't, fall back to the default procedure.
    if (FAILED(hr)) {
    (*ppAlloc)->Release();
        *ppAlloc = NULL;

    m_fUsingOurAllocator = FALSE;

    // We don't work if we can't use our own allocator
    ASSERT(FALSE);
    //hr = CBaseOutputPin::DecideAllocator(pPin, ppAlloc);
    }

    return hr;
}


// !!! need code here to enumerate possible allowed types....
// but if SetFormat has been called, that's still the only one we enumerate

// return default media type & format
HRESULT
CWaveInOutputPin::GetMediaType(int iPosition, CMediaType* pt)
{
    DbgLog((LOG_TRACE,1,TEXT("GetMediaType")));

    // check it is the single type they want
    if (iPosition<0) {
        return E_INVALIDARG;
    }

    // build a complete list of media types to offer (if we haven't done it already)
    HRESULT hr = InitMediaTypes();
    if (FAILED (hr))
        return hr;

    if (iPosition >= m_pFilter->m_cTypes) {
        return VFW_S_NO_MORE_ITEMS;
    }

    if( 0 == iPosition && IsConnected() )
    {
        // if we're connected offer the connected type first.
        // this way GetFormat will return the connected type, regardless
        // of our default type
        *pt = m_mt;
    }
    else
    {

        hr = CreateAudioMediaType(m_pFilter->m_lpwfxArray[iPosition], pt, TRUE);
    }
    return hr;
}


// set the new media type
//
HRESULT CWaveInOutputPin::SetMediaType(const CMediaType* pmt)
{
    DbgLog((LOG_TRACE,1,TEXT("SetMediaType %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec));

    ASSERT(m_pFilter->m_State == State_Stopped);

    // We assume this format has been checked out already and is OK

    return CBasePin::SetMediaType(pmt);
}


// check if the pin can support this specific proposed type&format
HRESULT
CWaveInOutputPin::CheckMediaType(const CMediaType* pmt)
{
    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pmt->Format();

    DbgLog((LOG_TRACE,1,TEXT("CheckMediaType")));
    //DisplayType("wave format in CWaveOut::CheckMediaType", pmt);

    // reject non-Audio type
    if (pmt->majortype != MEDIATYPE_Audio ||
        pmt->formattype != FORMAT_WaveFormatEx) {
    return VFW_E_INVALIDMEDIATYPE;
    }

    ASSERT(m_pFilter->m_WaveDeviceToUse.fSet);
    UINT err = waveInOpen(NULL,
               m_pFilter->m_WaveDeviceToUse.devnum,
               pwfx,
               0,
               0,
               WAVE_FORMAT_QUERY);

    if (err != 0) {
    DbgLog((LOG_ERROR,1,TEXT("Error checking wave format: %u"), err));
    return VFW_E_TYPE_NOT_ACCEPTED;
    }

    return NOERROR;
}


// override this to set the buffer size and count. Return an error
// if the size/count is not to your liking
HRESULT
CWaveInOutputPin::DecideBufferSize(IMemAllocator * pAlloc,
                                   ALLOCATOR_PROPERTIES *pProperties)
{
    // the user wants a certain sized buffer
    if (m_propSuggested.cbBuffer > 0) {
        pProperties->cbBuffer = m_propSuggested.cbBuffer;
    } else {
        pProperties->cbBuffer = (LONG)(((LPWAVEFORMATEX)(m_mt.Format()))->
        nAvgBytesPerSec * GetProfileIntA("wavein", "BufferMS", 500) /
        1000.);
    }

    // the user wants a certain number of buffers
    if (m_propSuggested.cBuffers > 0) {
        pProperties->cBuffers = m_propSuggested.cBuffers;
    } else {
        pProperties->cBuffers = GetProfileIntA("wavein", "NumBuffers", 4);
    }

    // the user wants a certain prefix
    if (m_propSuggested.cbPrefix >= 0)
        pProperties->cbPrefix = m_propSuggested.cbPrefix;

    // the user wants a certain alignment
    if (m_propSuggested.cbAlign > 0)
        pProperties->cbAlign = m_propSuggested.cbAlign;

    // don't blow up
    if (pProperties->cbAlign == 0)
        pProperties->cbAlign = 1;

    m_rtLatency = ( pProperties->cbBuffer * UNITS ) /
                    (((LPWAVEFORMATEX)(m_mt.Format()))->nAvgBytesPerSec);
    m_rtMaxStreamOffset = m_rtLatency * pProperties->cBuffers;

    ALLOCATOR_PROPERTIES Actual;
    return pAlloc->SetProperties(pProperties,&Actual);
}


// Reconnect our output pin if necessary
//
void CWaveInOutputPin::Reconnect()
{
    if (IsConnected()) {
        DbgLog((LOG_TRACE,1,TEXT("Need to reconnect our output pin")));
        CMediaType cmt;
    GetMediaType(0, &cmt);
    if (S_OK == GetConnected()->QueryAccept(&cmt)) {
        m_pFilter->m_pGraph->Reconnect(this);
    } else {
        // we were promised this would work
        ASSERT(FALSE);
    }
    }
}


////////////////////////////////
// IAMStreamConfig stuff //
////////////////////////////////


HRESULT CWaveInOutputPin::SetFormat(AM_MEDIA_TYPE *pmt)
{
    HRESULT hr;

    if (pmt == NULL)
        return E_POINTER;

    // To make sure we're not in the middle of start/stop streaming
    CAutoLock cObjectLock(m_pFilter);

    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::SetFormat %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec));

    if (m_pFilter->m_State != State_Stopped)
        return VFW_E_NOT_STOPPED;

    // even if the format is the current format we should continue on, since there's no
    // guarantee that we've verified we can open the device for real with this format

    // see if we like this type
    if ((hr = CheckMediaType((CMediaType *)pmt)) != NOERROR)