ntGrxIds[1] = 0xff;
    pOEM->curFontGrxIds[2] = pOEM->curFontGrxIds[3] = 0xff;
    pOEM->curFontGrxIds[4] = pOEM->curFontGrxIds[5] = 0xff;
    pOEM->curFontGrxIds[6] = pOEM->curFontGrxIds[7] = 0xff;

    pOEM->tblPreviousFont.FontHeight = INIT;
    pOEM->tblPreviousFont.FontWidth  = INIT;
    pOEM->tblPreviousFont.MaxWidth   = INIT;
    pOEM->tblPreviousFont.AvgWidth   = INIT;
    pOEM->tblPreviousFont.Ascent     = INIT;
    pOEM->tblPreviousFont.Stretch    = INIT;
    pOEM->tblCurrentFont.FontHeight  = 50;
    pOEM->tblCurrentFont.FontWidth   = 25;
    pOEM->tblPreviousFont.MaxWidth   = 50;
    pOEM->tblPreviousFont.AvgWidth   = 25;
    pOEM->tblPreviousFont.Ascent     = 45;

    pOEM->OrnamentedChar[0] = pOEM->OrnamentedChar[1] = INIT;
    pOEM->OrnamentedChar[2] = pOEM->OrnamentedChar[3] = INIT;
    pOEM->OrnamentedChar[4] = INIT;
    pOEM->TextPath = INIT;
    pOEM->CharOrientation[0] = pOEM->CharOrientation[1] = INIT;
    pOEM->CharOrientation[2] = pOEM->CharOrientation[3] = INIT;

    pOEM->GLTable = INIT;
    pOEM->GRTable = INIT;
    pOEM->cachedfont  = 0; // We have no id 0 font.
    pOEM->papersize   = PAPER_DEFAULT; // A4
    pOEM->Escapement  = 0;
    pOEM->resolution  = 300;
    pOEM->unitdiv     = 2;
    // Vector command
    pOEM->wCurrentImage = 0;
#ifdef LIPS4C
    pOEM->flips4C = FALSE;
#endif // LIPS4C
// #213732: 1200dpi support
    pOEM->masterunit = 600;
// #228625: Stacker support
    pOEM->tray = INIT;
    pOEM->method = INIT;
    pOEM->staple = INIT;
// ntbug9#172276: Sorter support
    pOEM->sorttype = INIT;
// ntbug9#172276: CPCA support
    pOEM->fCPCA = FALSE;
    pOEM->fCPCA2 = FALSE;
    CPCAInit(pOEM);
// ntbug9#293002: Features are different from H/W options.
    pOEM->startbin = INIT;

    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    if(pdevobj->pdevOEM)
    {
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PLIPSPDEV pOEMOld, pOEMNew;

    pOEMOld = (PLIPSPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PLIPSPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL)
        *pOEMNew = *pOEMOld;

    return TRUE;
}

// BInitOEMExtraData() and BMergeOEMExtraData() has moved to common.c


static int
iDwtoA(LPSTR buf, DWORD n)
{
	int	 i, j;

	for( i = 0; n; i++ ) {
		buf[i] = (char)(n % 10 + '0');
		n /= 10;
	}

	/* n was zero */
	if( i == 0 )
		buf[i++] = '0';

	for( j = 0; j < i / 2; j++ ) {
		int tmp;

		tmp = buf[j];
		buf[j] = buf[i - j - 1];
		buf[i - j - 1] = (char)tmp;
	}

	buf[i] = '\0';

	return i;
}

// Support DRC
#if 0
WORD NEAR PASCAL VFormat(
long sParam, LPSTR lpStr)
{
    long  absParam = ABS(sParam);
    short  absTmp;
    WORD   wReturn;

    if (absParam <= 15)
    {
        *lpStr   = 0x20
                 + ((sParam >= 0)?0x10:0) // 0 is active value
                 + (BYTE)absParam;
        wReturn  = 1;
    }
    else if (absParam <= 1023)
    {
        *lpStr     = 0x40
                   + (BYTE)(absParam/16);
        *(lpStr+1) = 0x20
                   + ((sParam >= 0)?0x10:0)
                   + (BYTE)(absParam % 16);
        wReturn    = 2;
    }
    else
    {
        *lpStr     = 0x40
                   + (BYTE)(absParam / 1024);
        absTmp     = (short)(absParam % 1024);
        *(lpStr+1) = 0x40
                   + (BYTE)(absTmp / 16);
        *(lpStr+2) = 0x20
                   + ((sParam >= 0)? 0x10:0)
                   + (BYTE)(absTmp % 16);
        wReturn    = 3;
    }

    return wReturn;
}
#else // 0
static LPSTR
tovformat(long v, LPSTR bp, int bits)
{
	long		max, l;
	int		sign;

	sign = (v < 0);
	v = sign ? -v : v;
	max = 1 << bits;
	if (v >= max)
		bp = tovformat(v >> bits, bp, 6);
	l = (v & (max-1));
	if (bits == 4)
		l += sign ? ' ' : '0';
	else
		l += '@';
	*bp++ = (char)l;
	return bp;
}

WORD NEAR PASCAL VFormat(
    long sParam, LPSTR lpStr)
{
    LPSTR       lp;

    lp = tovformat(sParam, lpStr, 4);
    return (WORD)(lp - lpStr);
}
#endif // 0

//*****************************************************************
// Send current Font ID and Graphic set ID to printer anyway.
//*****************************************************************
void sendfontgrxid(pdevobj)
PDEVOBJ	pdevobj;
{
PLIPSPDEV  pOEM;
BYTE       ch[CCHMAXCMDLEN];
WORD       wlen;
uchar      tid;

pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

// Send font, grx ids x 4 x 2
if(pOEM->curFontGrxIds[0] != 0xff)
    {
    tid = pOEM->curFontGrxIds[0];
    // Font ID G0
    ch[0]      = 'T';
    if (tid <= 15)
        {
        ch[1]      = tid + 0x30;
        ch[2]      = 0x1E;
        wlen       = 3;
        }
     else
        {
        ch[1]      = 0x40 + tid / 16;
        ch[2]      = 0x30 + tid % 16;
        ch[3]      = 0x1E;
        wlen       = 4;
        }
    WRITESPOOLBUF(pdevobj, ch, wlen);
    }

if(pOEM->curFontGrxIds[1] != 0xff)
    {
    tid = pOEM->curFontGrxIds[1];
    // Font ID G1
    ch[0]      = 'm';
    if (tid <= 15)
        {
        ch[1]      = tid + 0x30;
        ch[2]      = 0x1E;
        wlen       = 3;
        }
     else
        {
        ch[1]      = 0x40 + tid / 16;
        ch[2]      = 0x30 + tid % 16;
        ch[3]      = 0x1E;
        wlen       = 4;
        }
    WRITESPOOLBUF(pdevobj, ch, wlen);
    }

if(pOEM->curFontGrxIds[2] != 0xff)
    {
    tid = pOEM->curFontGrxIds[2];
    // Font ID G2
    ch[0]      = 'n';
    if (tid <= 15)
        {
        ch[1]      = tid + 0x30;
        ch[2]      = 0x1E;
        wlen       = 3;
        }
     else
        {
        ch[1]      = 0x40 + tid / 16;
        ch[2]      = 0x30 + tid % 16;
        ch[3]      = 0x1E;
        wlen       = 4;
        }
    WRITESPOOLBUF(pdevobj, ch, wlen);
    }

if(pOEM->curFontGrxIds[3] != 0xff)
    {
    tid = pOEM->curFontGrxIds[3];
    // Font ID G3
    ch[0]      = 'o';
    if (tid <= 15)
        {
        ch[1]      = tid + 0x30;
        ch[2]      = 0x1E;
        wlen       = 3;
        }
     else
        {
        ch[1]      = 0x40 + tid / 16;
        ch[2]      = 0x30 + tid % 16;
        ch[3]      = 0x1E;
        wlen       = 4;
        }
    WRITESPOOLBUF(pdevobj, ch, wlen);
    }

if(pOEM->curFontGrxIds[4] != 0xff)
    {
    tid = pOEM->curFontGrxIds[4];
    // Grx ID G0
    ch[0]      = ']';
    if (tid <= 15)
        {
        ch[1]      = tid + 0x30;
        ch[2]      = 0x1E;
        wlen       = 3;
        }
     else
        {
        ch[1]      = 0x40 + tid / 16;
        ch[2]      = 0x30 + tid % 16;
        ch[3]      = 0x1E;
        wlen       = 4;
        }
    WRITESPOOLBUF(pdevobj, ch, wlen);
    }

if(pOEM->curFontGrxIds[5] != 0xff)
    {
    tid = pOEM->curFontGrxIds[5];
    // Grx ID G1
    ch[0]      = 0x60; // '`'
    if (tid <= 15)
        {
        ch[1]      = tid + 0x30;
        ch[2]      = 0x1E;
        wlen       = 3;
        }
     else
        {
        ch[1]      = 0x40 + tid / 16;
        ch[2]      = 0x30 + tid % 16;
        ch[3]      = 0x1E;
        wlen       = 4;
        }
    WRITESPOOLBUF(pdevobj, ch, wlen);
    }

if(pOEM->curFontGrxIds[6] != 0xff)
    {
    tid = pOEM->curFontGrxIds[6];
    // Grx ID G2
    ch[0]      = 'a';
    if (tid <= 15)
        {
        ch[1]      = tid + 0x30;
        ch[2]      = 0x1E;
        wlen       = 3;
        }
     else
        {
        ch[1]      = 0x40 + tid / 16;
        ch[2]      = 0x30 + tid % 16;
        ch[3]      = 0x1E;
        wlen       = 4;
        }
    WRITESPOOLBUF(pdevobj, ch, wlen);
    }

if(pOEM->curFontGrxIds[7] != 0xff)
    {
    tid = pOEM->curFontGrxIds[7];
    // Grx ID G3
    ch[0]      = 'b';
    if (tid <= 15)
        {
        ch[1]      = tid + 0x30;
        ch[2]      = 0x1E;
        wlen       = 3;
        }
     else
        {
        ch[1]      = 0x40 + tid / 16;
        ch[2]      = 0x30 + tid % 16;
        ch[3]      = 0x1E;
        wlen       = 4;
        }
    WRITESPOOLBUF(pdevobj, ch, wlen);
    }

// end of sendfontgrxid()
}

// **** Put PaperSize Select command
void selectpapersize(pdevobj, paperid)
PDEVOBJ	pdevobj;
char	paperid;
{
char i;
PLIPSPDEV pOEM;
DWORD x, y;
WORD wlen;
BYTE ch[CCHMAXCMDLEN];

pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

// if papersize was set already, it's skipped
if(pOEM->currentpapersize == paperid)
    return;

// ntbug9#254925: CUSTOM papers.

i = paperid - PAPER_FIRST;

if ((paperid != PAPER_PORT && paperid != PAPER_LAND) ||
    !pOEM->dwPaperWidth || !pOEM->dwPaperHeight) {
    wlen = (WORD)wsprintf(ch, cmdSelectPaper, PaperIDs[i]);
} else {
    // Custom forms
    // ntbug9#309695: top margin incorrect on custom:landscape:LIPS4c
    if (pOEM->flips4 || pOEM->flips4C)
        wlen = (WORD)wsprintf(ch, cmdSelectUnit4, pOEM->resolution);
    else
        wlen = (WORD)wsprintf(ch, cmdSelectUnit3);
    i = (paperid == PAPER_PORT) ? 80 : 81;
    x = pOEM->dwPaperWidth / (DWORD)pOEM->unitdiv;
    y = pOEM->dwPaperHeight / (DWORD)pOEM->unitdiv;
    wlen += (WORD)wsprintf(&ch[wlen], cmdSelectCustom, i, y, x);
}
WRITESPOOLBUF(pdevobj, ch, wlen);

// save papersize
pOEM->currentpapersize = paperid;
}


void NEAR PASCAL SetPenAndBrush(PDEVOBJ pdevobj, WORD wType)
{
    BYTE       ch[CCHMAXCMDLEN];
    unsigned short wlen;
    PLIPSPDEV	pOEM;

    pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);
    wlen = 0;

    if (SET_BRUSH == wType)
    {
        short sBrush;

        if (pOEM->sBrushStyle == INIT)
            pOEM->sBrushStyle = 0;

        if (pOEM->sBrushStyle & 0x20)
            sBrush = pOEM->sBrushStyle;
        else
            sBrush = BrushType[pOEM->sBrushStyle];

        // wlen = wsprintf(ch, CMD_SET_BRUSH_STYLE, sBrush,
        //         (pOEM->fVectCmd & VFLAG_PEN_NULL) ? '0' : '1');
	ch[wlen++] = 'I';
	ch[wlen++] = (BYTE)sBrush;
	ch[wlen++] = (pOEM->fVectCmd & VFLAG_PEN_NULL) ? '0' : '1';
	ch[wlen++] = 0x1E;
    }

    if (SET_PEN == wType)
    {
        if (!(pOEM->fVectCmd & VFLAG_PEN_NULL))
        {
            // wlen += wsprintf(&ch[wlen], CMD_SET_PEN_TYPE, pOEM->sPenStyle);
            ch[wlen++] = 'E';
            ch[wlen++] = '1';
	    wlen += (WORD)iDwtoA(&ch[wlen], pOEM->sPenStyle);
            ch[wlen++] = 0x1E;
            // wlen += (WORD)wsprintf(&ch[wlen], CMD_SET_PEN_STYLE, pOEM->sPenColor, 0x31);
	    ch[wlen++] = '}';
	    ch[wlen++] = 'G';
	    wlen += (WORD)iDwtoA(&ch[wlen], pOEM->sPenColor);
	    ch[wlen++] = '1';
            ch[wlen++] = 0x1E;

            ch[wlen++] = 'F';
            ch[wlen++] = '1';
            wlen += VFormat(pOEM->sPenWidth, (LPSTR)(ch+wlen));
            ch[wlen++] = 0x1E;
        }
        else {
            // wlen += (WORD)wsprintf(&ch[wlen], CMD_SET_PEN_STYLE, 2, 0x30);
	    ch[wlen++] = '}';
	    ch[wlen++] = 'G';
	    ch[wlen++] = '2';
	    ch[wlen++] = '0';
            ch[wlen++] = 0x1E;
	}
    }

    if (wlen > 0)
        WRITESPOOLBUF(pdevobj, ch, wlen);
}

// ntbug9#172276: CPCA support

/*
 *      PJLStart
 */
static void
PJLStart(PDEVOBJ pdevobj)
{
    PLIPSPDEV   pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);
    LPLIPSCmd   lp;
    short       res;
    INT         i;
    WORD        wlen;
    BYTE        ch[CCHMAXCMDLEN];

    WRITESPOOLBUF(pdevobj, cmdPJLTOP1.pCmdStr, cmdPJLTOP1.cbSize);
    WRITESPOOLBUF(pdevobj, cmdPJLTOP2.pCmdStr, cmdPJLTOP2.cbSize);

    // ntbug9#293002: Features are different from H/W options.
    switch (pOEM->tray) {
    default:
        break;
    case 0:     // AUTO
        i = 0;
        goto traycommon;
    case 100:   // DEFAULT
        i = 1;
        goto traycommon;
    case 101:   // SUBTRAY
        i = 2;
        goto traycommon;
    case 1:     // BIN1
    case 2:     // BIN2
    case 3:     // BIN3
        i = pOEM->tray + 2;
        // FALL THRU
    traycommon:
        wlen = (WORD)wsprintf(ch, cmdPJLBinSelect, cmdBinType[i]);
        WRITESPOOLBUF(pdevobj, ch, wlen);
        break;
    }

    // #213732: 1200dpi support
    res = pOEM->resolution;
    if(res == 1200)
        WRITESPOOLBUF(pdevobj, cmdPJLTOP3SUPERFINE.pCmdStr, cmdPJLTOP3SUPERFINE.cbSize);
    else if(res == 600)
        WRITESPOOLBUF(pdevobj, cmdPJLTOP3FINE.pCmdStr, cmdPJLTOP3FINE.cbSize);
    else
        WRITESPOOLBUF(pdevobj, cmdPJLTOP3QUICK.pCmdStr,cmdPJLTOP3QUICK.cbSize);

    // #228625: Stacker support
    switch (pOEM->method) {
    case METHOD_JOBOFFSET:
        WRITESPOOLBUF(pdevobj, cmdPJLTOP31JOBOFF.pCmdStr, cmdPJLTOP31JOBOFF.cbSize);
        break;

    case METHOD_STAPLE:
        if (pOEM->staple < 0 || pOEM->staple >= sizeof(cmdStapleModes) /
            sizeof(cmdStapleModes[0]))
            break;
        CopyMemory(ch, cmdPJLTOP31STAPLE.pCmdStr, cmdPJLTOP31STAPLE.cbSize);
        wlen = cmdPJLTOP31STAPLE.cbSize;
        lp = &cmdStapleModes[pOEM->staple];
        CopyMemory(&ch[wlen], lp->pCmdStr, lp->cbSize);
        wlen += lp->cbSize;
        ch[wlen++] = '\x0D';
        ch[wlen++] = '\x0A';
        WRITESPOOLBUF(pdevobj, ch, wlen);
        break;
    }

// ntbug9#293002: Features are different from H/W options.
    switch (pOEM->sorttype) {
    case SORTTYPE_SORT:
        i = 0;
        goto sortcommon;
    case SORTTYPE_GROUP:
        i = 1;
        goto sortcommon;
    case SORTTYPE_STAPLE:
        i = 2;
        // FALL THRU
    sortcommon:
        wlen = (WORD)wsprintf(ch, cmdPJLSorting, cmdSortType[i]);
        WRITESPOOLBUF(pdevobj, ch, wlen);
        break;
    }

    if (pOEM->startbin != INIT) {
        wlen = (WORD)wsprintf(ch, cmdPJLStartBin, pOEM->startbin);
        WRITESPOOLBUF(pdevobj, ch, wlen);
    }

    WRITESPOOLBUF(pdevobj, cmdPJLTOP4.pCmdStr, cmdPJLTOP4.cbSize);
    WRITESPOOLBUF(pdevobj, cmdPJLTOP5.pCmdStr, cmdPJLTOP5.cbSize);
}

/*
 *      PJLEnd
 */
static void
PJLEnd(PDEVOBJ pdevobj)
{
    WRITESPOOLBUF(pdevobj, cmdPJLBOTTOM1.pCmdStr, cmdPJLBOTTOM1.cbSize);
    WRITESPOOLBUF(pdevobj, cmdPJLBOTTOM2.pCmdStr, cmdPJLBOTTOM2.cbSize);
}

/*
 *	OEMCommandCallback
 */
INT APIENTRY OEMCommandCallback(
	PDEVOBJ pdevobj,
	DWORD   dwCmdCbID,
	DWORD   dwCount,
	PDWORD  pdwParams
	)
{
	INT			i, j, k;
	WORD			wlen;
	BYTE			*bp;
	BYTE			ch[CCHMAXCMDLEN];
	PLIPSPDEV               pOEM;
	LPGrxSetNo		pGS;	// #185762: Tilde isn't print
// ntbug9#98276: Support Color Bold
        DWORD                   r, g, b;

	// DbgPrint(DLLTEXT("OEMCommandCallback() entry.\r\n"));

	//
	// verify pdevobj okay
	//
	// ASSERT(VALID_PDEVOBJ(pdevobj));

	//
	// fill in printer commands
	//
	i = 0;
	pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

// Register PaperSize 40 - 65
if(dwCmdCbID >= PAPER_FIRST && dwCmdCbID <= PAPER_LAST)
    {
// ntbug9#254925: CUSTOM papers.
    pOEM->papersize = (char)dwCmdCbID;
    if (dwCount < 2 || !pdwParams)
        return 0;
    pOEM->dwPaperWidth = pdwParams[0];
    pOEM->dwPaperHeight = pdwParams[1];
    return 0;
    }

switch(dwCmdCbID)
    {
    long       cx,cy;
    short      res;

    case RES_SENDBLOCK:
	if (dwCount < 3 || !pdwParams)
	    break;
        cx = pOEM->ptCurrent.x;
        cy = pOEM->ptCurrent.y;

#ifdef LIPS4C
        // NOTE!: \x7DH cmd is not accepted when full color printing for
	//	  \x7DQ cmd.
        // Rasdd works as the following order when the model is not MD_SERIAL.
        // 1. Puts no white character.
        // 2. Puts graphics.
        // 3. Puts white character.
        // Therefore, black character is deleted when rasdd puts graphics due
        // to the design describing at NOTE!.
        // I have changed the type of printer model to MD_SERIAL.
        // Following \x7DH cmd is for grayscale printing.

	// #185744: White font isn't printed
	// These 'hack' code doesn't necessary on NT5.

        if(pOEM->flips4C) {
        if(pOEM->bLogicStyle != OR_MODE)
            {
            // "\x7DH1\x1E"
            ch[0]      = '\x7D';
            ch[1]      = 'H';
            ch[2]      = '1';
            ch[3]      = 0x1E;
            wlen       = 4;
            WRITESPOOLBUF(pdevobj, ch, wlen);

            pOEM->bLogicStyle = OR_MODE;
            }
	} else { // !flips4C
#endif // LIPS4C
        if (pOEM->fcolor) {
            if(pOEM->bLogicStyle != OVER_MODE) {
                pOEM->bLogicStyle = OVER_MODE;
                wlen = 0;
                ch[wlen++] = 0x7D;
                ch[wlen++] = 'H';
                ch[wlen++] = '0';
                ch[wlen++] = 0x1E;
                WRITESPOOLBUF(pdevobj, ch, wlen);
            }
        }
        else {
            if(pOEM->bLogicStyle != OR_MODE) {
                pOEM->bLogicStyle = OR_MODE;
                wlen = 0;
                ch[wlen++] = 0x7D;
                ch[wlen++] = 'H';
                ch[wlen++] = '1';
                ch[wlen++] = 0x1E;
                WRITESPOOLBUF(pdevobj, ch, wlen);
            }
        } // fcolor
#ifdef LIPS4C
	} // flips4C
#endif // LIPS4C

#ifdef LBP_2030
        if( pOEM->fcolor )
            {
            if( pOEM->fplane == 0 )
                {
                // "\x7DP{pt.X}{pt.Y}{36000}{36000}{Height}{Width}{1}{0}{1}{0}{0}{1}\x1E"
                ch[0]      = 0x7D;
                ch[1]      = 'P';
                wlen       = 2;

                wlen      += VFormat(cx, (LPSTR)(ch+wlen));
                wlen      += VFormat(cy, (LPSTR)(ch+wlen));

                res = pOEM->resolution;

// #213732: 1200dpi support
                if(res == 1200)
                    {
                    ch[wlen++] = 0x41; // 1200dpi x100 (x)
                    ch[wlen++] = 0x75;
                    ch[wlen++] = 0x4C;
                    ch[wlen++] = 0x30;
                    ch[wlen++] = 0x41; // 1200dpi x100 (y)
                    ch[wlen++] = 0x75;
                    ch[wlen++] = 0x4C;
                    ch[wlen++] = 0x30;
                    }
                else if(res == 600)
                    {
                    ch[wlen++] = 0x7a; // 600dpi x100 (x)
                    ch[wlen++] = 0x66;
                    ch[wlen++] = 0x30;
                    ch[wlen++] = 0x7a; // 600dpi x100 (y)
                    ch[wlen++] = 0x66;
                    ch[wlen++] = 0x30;
                    }
#ifdef LIPS4C
                else if(res == 360)
                    {
                    ch[wlen++] = 0x63; // 360dpi x100 (x)
                    ch[wlen++] = 0x4A;
                    ch[wlen++] = 0x30;
                    ch[wlen++] = 0x63; // 360dpi x100 (y)
                    ch[wlen++] = 0x4A;
                    ch[wlen++] = 0x30;
                    }
#endif // LIPS4C
                else if(res == 300)
                    {
                    ch[wlen++] = 0x5d; // 300dpi x100 (x)
                    ch[wlen++] = 0x53;
                    ch[wlen++] = 0x30;
                    ch[wlen++] = 0x5d; // 300dpi x100 (y)
                    ch[wlen++] = 0x53;
                    ch[wlen++] = 0x30;
                    }
                wlen      += VFormat(*(pdwParams+1),(LPSTR)(ch+wlen));
                if(pOEM->fcolor == COLOR)
                    {
                    // On 2030, specifying "RGB per line" data format did not
                    // work well (yellow ink was not printed.)  it seems that
                    // the same data can be printed out correctly if you
                    // specify "RGB per plane".
                    // (In this case we are sending out scan lines as planes
                    // with height 1.)

                    wlen      += VFormat(8*(*(pdwParams+2)), (LPSTR)(ch+wlen));
                    ch[wlen++] = 0x31; // bits per color: 1
                    ch[wlen++] = 0x3C; // data format: RGB per plane
                    }
                else if (pOEM->fcolor == COLOR_8BPP)
                    {
                    wlen      += VFormat(*(pdwParams+2), (LPSTR)(ch+wlen));
                    ch[wlen++] = 0x38;      // bits per color: 8
                    ch[wlen++] = 0x31;      // data format: color index
                    }
		else // COLOR_24BPP
                    {
                    wlen      += VFormat(*(pdwParams+2)/3, (LPSTR)(ch+wlen));
                    ch[wlen++] = 0x38;      // bits per color: 8
                    ch[wlen++] = 0x3A;      // data format: RGB per point
                    }
                ch[wlen++] = 0x30;      // Height Vector
                ch[wlen++] = 0x31;
                ch[wlen++] = 0x31;      // Width Vector
                ch[wlen++] = 0x30;
                ch[wlen++] = 0x1E;

                WRITESPOOLBUF(pdevobj, ch, wlen);

                }

            // "\x7DQ{1}{1}{0}{size of byte}\x1E"

            wlen = 0;
            ch[wlen++] = 0x7D;
            ch[wlen++] = 'Q';
            ch[wlen++] = 0x31;
            ch[wlen++] = (pOEM->fplane < pOEM->fplaneMax) ? 0x30 : 0x31;
            ch[wlen++] = pOEM->fcompress;
            wlen += VFormat( *pdwParams, (LPSTR)(ch + wlen));
            ch[wlen++] = 0x1E;
            WRITESPOOLBUF(pdevobj, ch, wlen);

            if (pOEM->fcolor == COLOR) {
                if (pOEM->fplane >= pOEM->fplaneMax)
                    pOEM->fplane = 0;
                else
                    pOEM->fplane++;
            }
            break;
            } // fcolor
#endif //LBP_2030

        // "\x7DP{pt.X}{pt.Y}{30000}{30000}{Height}{Width}{1}{0}{1}{0}{0}{1}\x1E"
        ch[0]      = 0x7D;
        ch[1]      = 'P';
        wlen       = 2;

        wlen      += VFormat(cx, (LPSTR)(ch+wlen));
        wlen      += VFormat(cy, (LPSTR)(ch+wlen));

        res = pOEM->resolution;

// #213732: 1200dpi support
	if(res == 1200)
	    {
	    ch[wlen++] = 0x41; // 1200dpi x100 (x)
	    ch[wlen++] = 0x75;
	    ch[wlen++] = 0x4C;
	    ch[wlen++] = 0x30;
	    ch[wlen++] = 0x41; // 1200dpi x100 (y)
	    ch[wlen++] = 0x75;
	    ch[wlen++] = 0x4C;
	    ch[wlen++] = 0x30;
	    }
        else if(res == 600)
            {
            ch[wlen++] = 0x7a; // 600dpi x100 (x)
            ch[wlen++] = 0x66;
            ch[wlen++] = 0x30;
            ch[wlen++] = 0x7a; // 600dpi x100 (y)
            ch[wlen++] = 0x66;
            ch[wlen++] = 0x30;
            }
#ifdef LIPS4C
        else if(res == 360)
            {
            ch[wlen++] = 0x63; // 360dpi x100 (x)
            ch[wlen++] = 0x4A;
            ch[wlen++] = 0x30;
            ch[wlen++] = 0x63; // 360dpi x100 (y)
            ch[wlen++] = 0x4A;
            ch[wlen++] = 0x30;
            }
#endif // LIPS4C
        else if(res == 300)
            {
            ch[wlen++] = 0x5d; // 300dpi x100 (x)
            ch[wlen++] = 0x53;
            ch[wlen++] = 0x30;
            ch[wlen++] = 0x5d; // 300dpi x100 (y)
            ch[wlen++] = 0x53;
            ch[wlen++] = 0x30;
            }
        else if(res == 150)
            {
            ch[wlen++] = 0x4e; // 150dpi x100 (x)
            ch[wlen++] = 0x69;
            ch[wlen++] = 0x38;
            ch[wlen++] = 0x4e; // 150dpi x100 (y)
            ch[wlen++] = 0x69;
            ch[wlen++] = 0x38;
            }
        else
            {
            ch[wlen++] = 0x5d; // 300dpi x100 (x)
            ch[wlen++] = 0x53;
            ch[wlen++] = 0x30;
            ch[wlen++] = 0x5d; // 300dpi x100 (y)
            ch[wlen++] = 0x53;
            ch[wlen++] = 0x30;
            }

        wlen      += VFormat((short)*(pdwParams+1),(LPSTR)(ch+wlen));
        wlen      += VFormat((short)(8*(*(pdwParams+2))), (LPSTR)(ch+wlen));
        ch[wlen++] = 0x31;
        ch[wlen++] = 0x30;
        ch[wlen++] = 0x30;
        ch[wlen++] = 0x31;
        ch[wlen++] = 0x31;
        ch[wlen++] = 0x30;
        // LIPS4 feature
        if(pOEM->flips4 == TRUE)
            {
            ch[wlen++] = 0x30;
            ch[wlen++] = 0x31; // batch image transfer
            }

        ch[wlen++] = 0x1E;

        WRITESPOOLBUF(pdevobj, ch, wlen);

        // "\x7DQ{1}{1}{0}{size of byte}\x1E"

        wlen = 0;
        ch[wlen++] = 0x7D;
        ch[wlen++] = 'Q';
        ch[wlen++] = 0x31;
        ch[wlen++] = 0x31;
        ch[wlen++] = pOEM->fcompress;
        wlen += VFormat(*pdwParams,(LPSTR)(ch+wlen));
        ch[wlen++] = 0x1E;
        WRITESPOOLBUF(pdevobj, ch, wlen);

        break;

    case BEGIN_COMPRESS:
        pOEM->fcompress = 0x37; // Method 1
        break;

    case BEGIN_COMPRESS_TIFF:
        pOEM->fcompress = 0x3b; // TIFF
        break;

// Support DRC
    case BEGIN_COMPRESS_DRC:
        pOEM->fcompress = 0x3c; // DRC
        break;

    case END_COMPRESS:
        pOEM->fcompress = 0x30; // No compression
        break;

    // Select Resolution
// #213732: 1200dpi support
    case SELECT_RES_1200:
        pOEM->resolution = 1200;
        pOEM->unitdiv    = 1;
        break;

    case SELECT_RES_600:
#ifdef LBP_2030
        pOEM->fcolor = MONOCHROME; // Initialize, defalut is monochrome
#endif

        pOEM->resolution = 600;
        pOEM->unitdiv    = 1;
        break;

#ifdef LIPS4C
    case SELECT_RES4C_360:
	pOEM->resolution = 360;
	pOEM->unitdiv = 1;
	if (pOEM->fcolor)
            WRITESPOOLBUF(pdevobj, cmdColorMode4C.pCmdStr, cmdColorMode4C.cbSize);
	else
            WRITESPOOLBUF(pdevobj, cmdMonochrome4C.pCmdStr, cmdMonochrome4C.cbSize);
	break;
#endif // LIPS4C

    case SELECT_RES_300:
#ifdef LBP_2030
        pOEM->fcolor = MONOCHROME; // Initialize, defalut is monochrome
#endif
        pOEM->resolution = 300;
        pOEM->unitdiv    = 2;
        break;

    case SELECT_RES_150:
#ifdef LBP_2030
        pOEM->fcolor = MONOCHROME; // Initialize, defalut is monochrome
#endif
        pOEM->resolution = 150;
        pOEM->unitdiv    = 2;
        // 150 dpi mode means only image data is 150dpi
        break;

    case OCD_BEGINDOC:
        pOEM->flips4     = FALSE;

        res = pOEM->resolution;
        if(res == 600)
            WRITESPOOLBUF(pdevobj, cmdBeginDoc600.pCmdStr, cmdBeginDoc600.cbSize);
        else if(res == 300)
            WRITESPOOLBUF(pdevobj, cmdBeginDoc300.pCmdStr, cmdBeginDoc300.cbSize);
        else if(res == 150) // 150dpi means only image data is 150dpi
            WRITESPOOLBUF(pdevobj, cmdBeginDoc300.pCmdStr, cmdBeginDoc300.cbSize);
        else
            WRITESPOOLBUF(pdevobj, cmdBeginDoc300.pCmdStr, cmdBeginDoc300.cbSize);

        WRITESPOOLBUF(pdevobj, cmdSoftReset.pCmdStr, cmdSoftReset.cbSize);
        pOEM->f1stpage = TRUE;
        pOEM->fvertical = FALSE;
        pOEM->currentpapersize = -1;
        break;

// ntbug9#278671: Finisher !work
    case OCD_BEGINDOC4_1200_CPCA2:
        pOEM->fCPCA2 = TRUE;
	/* FALL THRU */

// ntbug9#172276: CPCA support
    case OCD_BEGINDOC4_1200_CPCA:
        pOEM->fCPCA = TRUE;
	/* FALL THRU */

// #213732: 1200dpi support
    case OCD_BEGINDOC4_1200:
	pOEM->masterunit = 1200;
	// Adjust unitdiv
	pOEM->unitdiv = (SHORT)(pOEM->masterunit / pOEM->resolution);
	/* FALL THRU */

    case OCD_BEGINDOC4:
        pOEM->flips4     = TRUE;

// ntbug9#172276: CPCA support
        if (pOEM->fCPCA)
            CPCAStart(pdevobj);
        else
            PJLStart(pdevobj);
        goto setres;

#ifdef LBP_2030
    case OCD_BEGINDOC4_2030_CPCA:
        pOEM->fCPCA = TRUE;
	/* FALL THRU */

    case OCD_BEGINDOC4_2030:
        pOEM->flips4     = TRUE;
// ntbug9#172276: CPCA support
        if (pOEM->fCPCA)
            CPCAStart(pdevobj);
#endif

setres:

        res = pOEM->resolution;

// #213732: 1200dpi support
        if(res == 1200)
            WRITESPOOLBUF(pdevobj, cmdBeginDoc1200.pCmdStr, cmdBeginDoc1200.cbSize);
        else if(res == 600)
            WRITESPOOLBUF(pdevobj, cmdBeginDoc600.pCmdStr, cmdBeginDoc600.cbSize);
        else if(res == 300){

#ifdef LBP_2030
// ntbug9#195725: !printed on 300dpi
            if( dwCmdCbID == OCD_BEGINDOC4_2030 || dwCmdCbID == OCD_BEGINDOC4_2030_CPCA){
                WRITESPOOLBUF(pdevobj, cmdBeginDoc4_2030.pCmdStr,cmdBeginDoc4_2030.cbSize);
            }else{
#endif
                WRITESPOOLBUF(pdevobj, cmdBeginDoc3004.pCmdStr,cmdBeginDoc3004.cbSize);
#ifdef LBP_2030
            }
#endif

        } else {

            WRITESPOOLBUF(pdevobj, cmdBeginDoc600.pCmdStr, cmdBeginDoc600.cbSize);

        }

        // LIPS4 features for only 730
        // Set Smoothing, Dithering and Econo mode
        i = pOEM->fsmoothing;
        j = pOEM->fecono;
        k = pOEM->fdithering;

        if(i==DEVICESETTING && j==DEVICESETTING && k==DEVICESETTING)
            ; // do nothing
        else
            { // send \x1B[n;n;n'v
            ch[0] = 0x1B;
            ch[1] = '[';
            ch[2] = '0' + (char)i;
            ch[3] = ';';
            ch[4] = '0' + (char)j;
            ch[5] = ';';
            ch[6] = '0' + (char)k;
            ch[7] = 0x27; // '\''
            ch[8] = 'v';
            wlen = 9;

            WRITESPOOLBUF(pdevobj, ch, wlen);
            }

#ifndef LBP_2030
        WRITESPOOLBUF(pdevobj, cmdSoftReset.pCmdStr, cmdSoftReset.cbSize);
#endif
        pOEM->f1stpage = TRUE;
        pOEM->fvertical = FALSE;
        pOEM->currentpapersize = -1;

#ifdef LBP_2030
        // Send Color mode command
        if(pOEM->fcolor)            // COLOR or COLOR_24BPP or COLOR_8BPP
            {
            WRITESPOOLBUF(pdevobj, cmdColorMode.pCmdStr, cmdColorMode.cbSize);
            }
        else
            { // Send Monochrome mode command
            WRITESPOOLBUF(pdevobj, cmdMonochrome.pCmdStr, cmdMonochrome.cbSize);
            }

        WRITESPOOLBUF(pdevobj, cmdSoftReset.pCmdStr, cmdSoftReset.cbSize);
#endif

        break;

#ifdef LIPS4C
    case OCD_BEGINDOC4C:
	pOEM->flips4C = TRUE;
	pOEM->f1stpage = TRUE;
	pOEM->fvertical = FALSE;
	pOEM->currentpapersize = -1;
// #213732: 1200dpi support
	pOEM->masterunit = 360;
        WRITESPOOLBUF(pdevobj, cmdBeginDoc4C.pCmdStr, cmdBeginDoc4C.cbSize);
	break;
#endif // LIPS4C

// #304284: Duplex isn't effective
// Actually, BEGINDOC means StartJob.
    case OCD_STARTDOC:
	// pOEM->f1stpage = TRUE;       // 1stpage means 1stdoc
	pOEM->fvertical = FALSE;
	pOEM->currentpapersize = -1;
	break;

#ifdef LBP_2030
    case OCD_SETCOLORMODE:
        pOEM->fcolor = COLOR; // if not color mode, system doesn't path
                                // here.
        pOEM->fplane = 0;
        pOEM->fplaneMax = 2;
        break;
    case OCD_SETCOLORMODE_24BPP:
        pOEM->fcolor = COLOR_24BPP;
        pOEM->fplane = 0;
        pOEM->fplaneMax = 0;
        break;

    case OCD_SETCOLORMODE_8BPP:
        pOEM->fcolor = COLOR_8BPP;
        pOEM->fplane = 0;
        pOEM->fplaneMax = 0;
        break;

    case OCD_ENDDOC4_2030:
        WRITESPOOLBUF(pdevobj, cmdEndDoc4.pCmdStr, cmdEndDoc4.cbSize);
        break;
#endif

    case OCD_ENDDOC4:
// ntbug9#172276: CPCA support
        if (pOEM->fCPCA)
            CPCAEnd(pdevobj, FALSE);
        else {
            WRITESPOOLBUF(pdevobj, cmdEndDoc4.pCmdStr, cmdEndDoc4.cbSize);
            PJLEnd(pdevobj);
        }
        break;

    case OCD_ENDPAGE:
        WRITESPOOLBUF(pdevobj, cmdEndPage.pCmdStr, cmdEndPage.cbSize);
        break;

#if defined(LIPS4C) || defined(LBP_2030)
    // #137462: 'X000' is printed.
    case OCD_ENDDOC4C:
// ntbug9#172276: CPCA support
        if (pOEM->fCPCA)
            CPCAEnd(pdevobj, TRUE);
        else
            WRITESPOOLBUF(pdevobj, cmdEndDoc4C.pCmdStr, cmdEndDoc4C.cbSize);
        break;

// #399861: Orientation does not changed.
    case OCD_SOURCE_AUTO:
        pOEM->source = 0;
        break;

    case OCD_SOURCE_MANUAL:
        pOEM->source = 1;
        break;

// ntbug9#293002: Features are different from H/W options.
    case OCD_SOURCE_CASSETTE1:
    case OCD_SOURCE_CASSETTE2:
    case OCD_SOURCE_CASSETTE3:
    case OCD_SOURCE_CASSETTE4:
        pOEM->source = (char)(dwCmdCbID - OCD_SOURCE_CASSETTE1 + 11);
        break;

    case OCD_SOURCE_ENVELOPE:
        pOEM->source = 5;
        break;

    case OCD_BEGINPAGE4C:
	if (pOEM->f1stpage == FALSE)
	    WRITESPOOLBUF(pdevobj, cmdEndPicture.pCmdStr, cmdEndPicture.cbSize);

// #399861: Orientation does not changed.
// ntbug9#293002: Features are different from H/W options.
        wlen = (WORD)wsprintf(ch, cmdPaperSource, pOEM->source);
        WRITESPOOLBUF(pdevobj, ch, wlen);
	// Thru away
#endif

    case OCD_BEGINPAGE:
        // Do Nothing

        if (!(pOEM->fVectCmd & VFLAG_INIT_DONE))
        {
            pOEM->fVectCmd |= VFLAG_PEN_NULL| VFLAG_BRUSH_NULL | VFLAG_INIT_DONE;
            pOEM->sBrushStyle = 0;
            pOEM->sPenStyle = 0;
        }

        pOEM->bLogicStyle = INIT;
	// #120638: image shift to right
        pOEM->ptCurrent.x = pOEM->ptInLine.x = 0;
        pOEM->ptCurrent.y = pOEM->ptInLine.y = 0;
        pOEM->stringwidth = 0;
	// #289488: Vertical font doesn't rotated on 2nd page.
        pOEM->fvertical = FALSE;
        pOEM->CharOrientation[0] = pOEM->CharOrientation[1] = INIT;
        pOEM->CharOrientation[2] = pOEM->CharOrientation[3] = INIT;
        break;

    case OCD_PORTRAIT:
    case OCD_LANDSCAPE:

// ntbug9#172276: CPCA support
        if (pOEM->fCPCA) {
            // Set number of copies
            wlen = 0;
            ch[wlen++] = 0x1B;
            ch[wlen++] = '[';
            if (pOEM->sorttype != SORTTYPE_SORT)
                i = pOEM->copies;
            else
                i = 1;
	    wlen += (WORD)iDwtoA(&ch[wlen], i);
            ch[wlen++] = 'v';
            WRITESPOOLBUF(pdevobj, ch, wlen);
        }

        // Select Paper Size
        selectpapersize(pdevobj, pOEM->papersize);

// #185762: Tilde isn't printed
// #ifndef LIPS4
        // If first page, the registration data would be downloaded
        // It doesn't need on LIPS4
        if(pOEM->f1stpage == TRUE && pOEM->flips4 == FALSE)
//        if(pOEM->f1stpage == TRUE)
            {
            // Download Graphic Set Registration to keep the conpatibility
            // against Canon's 3.1 driver
            // "\x1b[743;1796;30;0;32;127;.\x7dIBM819"
            // It means to register Windows character set for SBCS Device
            // fonts.
#ifdef LIPS4C
	    if (pOEM->flips4C)
                WRITESPOOLBUF(pdevobj, cmdGSETREGST4C.pCmdStr, cmdGSETREGST4C.cbSize);
	    else
                WRITESPOOLBUF(pdevobj, cmdGSETREGST.pCmdStr, cmdGSETREGST.cbSize);
#else
            WRITESPOOLBUF(pdevobj, cmdGSETREGST.pCmdStr, cmdGSETREGST.cbSize);
#endif // LIPS4C

            // Download SBCS physical device fontface from Dutch-Roman(7)
            // ZapfCalligraphic-BoldItalic(41)
            // Between the fontfaces, put \x00, and at the end of face,
            // put \x00 x 2
            ch[0]      = 0x00;
            wlen       = 1;
            for(i=0; i<MaxSBCSNumber; ++i)
                { // download all SBCS (ANSI) facename
                  // (without Symbol, Dingbats, DBCS)
                WRITESPOOLBUF(pdevobj, ch, wlen); // put 0x00 at top of facename
                WRITESPOOLBUF(pdevobj, PSBCSList[i].facename, PSBCSList[i].len);
                }

            // and Graphic set registration command(REGDataSize = 193)
#ifdef LIPS4C
	    if(pOEM->flips4C)
                WRITESPOOLBUF(pdevobj, GrxData4C, REGDataSize4C);
	    else
                WRITESPOOLBUF(pdevobj, GrxData, REGDataSize);
#else
            WRITESPOOLBUF(pdevobj, GrxData, REGDataSize);
#endif // LIPS4C
            }
// #endif // !LIPS4

        // LIPS4 features
        if(pOEM->f1stpage == TRUE && pOEM->flips4 == TRUE)
            {
// ntbug9#254925: CUSTOM papers.
            // N x Pages support
            switch (pOEM->nxpages) {
            default:
                WRITESPOOLBUF(pdevobj, cmdx1Page.pCmdStr, cmdx1Page.cbSize);
                break;
            case OCD_PAPERQUALITY_2XL:
                k = 21;
                goto xnpagecom;
            case OCD_PAPERQUALITY_2XR:
                k = 22;
                goto xnpagecom;
            case OCD_PAPERQUALITY_4XL:
                k = 41;
                goto xnpagecom;
            case OCD_PAPERQUALITY_4XR:
                k = 42;
                goto xnpagecom;
            xnpagecom:
                i = pOEM->papersize - PAPER_FIRST;
                wlen = (WORD)wsprintf(ch, cmdxnPageX, k, PaperIDs[i]);
                WRITESPOOLBUF(pdevobj, ch, wlen);
                break;
            }

            // Duplexing support
            if(pOEM->fduplex == FALSE)
                {
                WRITESPOOLBUF(pdevobj, cmdDuplexOff.pCmdStr, cmdDuplexOff.cbSize);
                }
            else
                {
                WRITESPOOLBUF(pdevobj, cmdDuplexOn.pCmdStr, cmdDuplexOn.cbSize);
                if(pOEM->fduplextype == VERT) // Long edge
                    WRITESPOOLBUF(pdevobj, cmdDupLong.pCmdStr, cmdDupLong.cbSize);
                else
                    WRITESPOOLBUF(pdevobj, cmdDupShort.pCmdStr,cmdDupShort.cbSize);
                }
            }

// #228625: Stacker support
// ntbug9#293002: Features are different from H/W options.
        // These command does no longer used.
        // "\x1B[12;{tray#};{faceup}~"
        // We use PJL command instead.

        // Start Font & Graphic list
        // Send "\x1B[0&\x7D" : Enter Vector Mode (VDM)
        WRITESPOOLBUF(pdevobj, cmdBeginVDM.pCmdStr, cmdBeginVDM.cbSize);

        // Download phisical font list and graphic set list
        // Send "\x20<" : Start Font List
        WRITESPOOLBUF(pdevobj, cmdFontList.pCmdStr, cmdFontList.cbSize);

        // All Physical fonts which can be supported in LIPS are downloaded
        // <p facename><separater><p facename2><separater>....
        // ...<p facenameN><\x1e (end of font list)>
        for(i=0; i<MaxFontNumber-1; ++i)
            { // download all fonts which can be supported in LIPS
            WRITESPOOLBUF(pdevobj, PFontList[i].facename, PFontList[i].len);
            WRITESPOOLBUF(pdevobj, cmdListSeparater.pCmdStr, cmdListSeparater.cbSize);
            }
        WRITESPOOLBUF(pdevobj, PFontList[i].facename, PFontList[i].len);

        // End of font list, send \x1e
        ch[0]      = 0x1e;
        wlen       = 1;
        WRITESPOOLBUF(pdevobj, ch, wlen); // put 0x1e at end of facename

        // Initialize font height
        // When downloading font list, character heigh will be initialized.
        pOEM->tblPreviousFont.FontHeight = INIT;

        // All graphic set are downloaded
        // Send "\x20;" : Start Graphics set List
        WRITESPOOLBUF(pdevobj, cmdGrxList.pCmdStr, cmdGrxList.cbSize);

        // All Graphics sets which can be supported in LIPS are downloaded
        // <graphics set1><separater><graphics set2><separater>....
        // ...<graphics setN><\x1e (end of font list)>
	// #185762: Tilde isn't print
#ifdef LIPS4C
	if (pOEM->flips4C)
		pGS = GrxSetL4C;
	else
#endif
#ifdef LIPS4
	if (pOEM->flips4)
		pGS = GrxSetL4;
	else
#endif
		pGS = GrxSetL3;
        for(i=0; i<MaxGrxSetNumber-1; ++i, ++pGS)
            { // All Graphics sets which can be supported in LIPS are downloaded
            WRITESPOOLBUF(pdevobj, pGS->grxsetname, pGS->len);
            WRITESPOOLBUF(pdevobj, cmdListSeparater.pCmdStr, cmdListSeparater.cbSize);
            }
        WRITESPOOLBUF(pdevobj, pGS->grxsetname, pGS->len);


        res = pOEM->resolution;

        // Begin picture, set Scaling mode (in dots), Begin picture body
        // Send "\x1E#\x1E!0#\x1E$"
// #213732: 1200dpi support
        if(res == 1200)
            {
            WRITESPOOLBUF(pdevobj, cmdBeginPicture1200.pCmdStr
                            , cmdBeginPicture1200.cbSize);
            }
        else if(res == 600)
            {
            WRITESPOOLBUF(pdevobj, cmdBeginPicture600.pCmdStr
                            , cmdBeginPicture600.cbSize);
            }
#ifdef LIPS4C
        else if(res == 360)
            {
            WRITESPOOLBUF(pdevobj, cmdBeginPicture4C.pCmdStr
                            , cmdBeginPicture4C.cbSize);
            }
#endif // LIPS4C
        else
            {
            WRITESPOOLBUF(pdevobj, cmdBeginPicture.pCmdStr
                            , cmdBeginPicture.cbSize);
            }

#ifdef LBP_2030

        // Send Color Selection Mode command
        if(pOEM->fcolor)
            {
            if (pOEM->fcolor == COLOR_8BPP)
                {
                // We use Color Index for a text color [sueyas]
                // Send "\x1E!10"
                WRITESPOOLBUF(pdevobj, cmdColorIndex.pCmdStr, cmdColorIndex.cbSize);
                }
	    else
                {
                // We use RGB presentation
                // Send "\x1E!11"
                WRITESPOOLBUF(pdevobj, cmdColorRGB.pCmdStr, cmdColorRGB.cbSize);
                }
            }

        // Start VDM mode  (in dots), Begin picture body
        // Send "\x1E$"
        WRITESPOOLBUF(pdevobj, cmdEnterPicture.pCmdStr, cmdEnterPicture.cbSize);
#endif

        // If needed, Send VDC Extent

        // Specify a unit of text height (in dots), text clip mode (stroke)
        // Send "\x1E"\x7D#1\x1EU2\x1E"
// #213732: 1200dpi support
        if(res == 1200)
            {
            WRITESPOOLBUF(pdevobj, cmdTextClip1200.pCmdStr, cmdTextClip1200.cbSize);
            }
        else if(res == 600)
            {
            WRITESPOOLBUF(pdevobj, cmdTextClip600.pCmdStr, cmdTextClip600.cbSize);
            }
#ifdef LIPS4C
        else if (res == 360)
            {
            WRITESPOOLBUF(pdevobj, cmdTextClip4C.pCmdStr, cmdTextClip4C.cbSize);
            }
#endif // LIPS4C
        else
            {
            WRITESPOOLBUF(pdevobj, cmdTextClip.pCmdStr, cmdTextClip.cbSize);
            }

        // LIPS4 features
        // Send Poly line
        if(pOEM->flips4 == TRUE)
            {
            // send DMe80\x1E or DMe81\x1E
// #213732: 1200dpi support
	    wlen = 0;
            ch[wlen++] = 'D';
            ch[wlen++] = 'M';
	    if (res == 1200) {
                ch[wlen++] = 'A';
                ch[wlen++] = 'K';
                ch[wlen++] = '0';
	    } else if (res == 600) {
                ch[wlen++] = 'e';
                ch[wlen++] = '8';
	    } else {            // ntbug9#195725: !printed on 300dpi
                ch[wlen++] = 'R';
                ch[wlen++] = '<';
            }

            if(pOEM->nxpages == DEVICESETTING)
                { // send 0
                ch[wlen++] = '0';
                }
            else
                { // send 1
                ch[wlen++] = '0';
                }
            ch[wlen++] = 0x1E;
            // wlen = 6;

            WRITESPOOLBUF(pdevobj, ch, wlen);
            }

        // As downloading font list and graphics list, font and graphics
        // table is initilized. We have to specifiy font and graphics table
        // each page except 1st page.

        if (pOEM->f1stpage == TRUE) {
            pOEM->f1stpage = FALSE;
        }
        else {
            sendfontgrxid(pdevobj);
        }

        SetPenAndBrush(pdevobj, SET_PEN);
        // end of orientation and begin doc
        break;

    case OCD_PRN_DIRECTION:
	if (dwCount < 1 || !pdwParams)
	    break;
        pOEM->Escapement = (short)*pdwParams % 360;
        break;

    case OCD_BOLD_ON:
        pOEM->fbold = TRUE;
        break;

    case OCD_BOLD_OFF:
        pOEM->fbold = FALSE;
        break;

    case OCD_ITALIC_ON:
        pOEM->fitalic = TRUE;
        break;

    case OCD_ITALIC_OFF:
        pOEM->fitalic = FALSE;
        break;

//    case OCD_UNDERLINE_ON:
//    case OCD_UNDERLINE_OFF:
//    case OCD_DOUBLEUNDERLINE_ON:
//    case OCD_DOUBLEUNDERLINE_OFF:
//    case OCD_STRIKETHRU_ON:
//    case OCD_STRIKETHRU_OFF:
    case OCD_WHITE_TEXT_ON:
        pOEM->fwhitetext = TRUE;
        break;

    case OCD_WHITE_TEXT_OFF:
        pOEM->fwhitetext = FALSE;
        break;

    case OCD_SINGLE_BYTE:
        pOEM->fdoublebyte = FALSE;
        break;

    case OCD_DOUBLE_BYTE:
        pOEM->fdoublebyte = TRUE;
        break;

    case OCD_VERT_ON:
        pOEM->fvertical = TRUE;
        break;

    case OCD_VERT_OFF:
        pOEM->fvertical = FALSE;
        break;

    case CUR_XM_ABS:
	if (dwCount < 1 || !pdwParams)
	    break;
        pOEM->ptCurrent.x = pOEM->ptInLine.x  = (short)*pdwParams
                                           / (pOEM->unitdiv);

        pOEM->printedchars = 0;
        pOEM->stringwidth  = 0;
        return (INT)(*pdwParams);	// for NT5

    case CUR_YM_ABS:
	if (dwCount < 1 || !pdwParams)
	    break;
        pOEM->ptCurrent.y = pOEM->ptInLine.y  = (short)*pdwParams
                                           / (pOEM->unitdiv);
	// #120640: Some characters shifted to right
	// Because this driver was set AT_GRXDATA_ORIGIN on CursorXAfterSend-
	// BlockData. Some of cases unidrv will only sent YMove command.
	// So it should be clear when any cursor move command was sent.
	// #150061: Subscript fonts are overlapped.
	// Revised for #120640. #120640 was fixed by GDI and this fix has
	// some side effects. Therefore, should be removed.
        // pOEM->stringwidth  = 0;
        return (INT)(*pdwParams);	// for NT5

    case CUR_XM_REL:
	if (dwCount < 1 || !pdwParams)
	    break;
        pOEM->ptCurrent.x = pOEM->ptInLine.x  += ((short)*pdwParams
                                           / (pOEM->unitdiv));
        pOEM->stringwidth  = 0;		// #120640: See above.
        return (INT)(*pdwParams);	// for NT5

    case CUR_YM_REL:
	if (dwCount < 1 || !pdwParams)
	    break;
        pOEM->ptCurrent.y = pOEM->ptInLine.y  += ((short)*pdwParams
                                           / (pOEM->unitdiv));
        pOEM->stringwidth  = 0;		// #120640: See above.
        return (INT)(*pdwParams);	// for NT5


#if 0		// NT5 GPD doesn't support XYMoveAbs.
    case CUR_XY_ABS:
        lpLips->ptCurrent.x = lpLips->ptInLine.x  = (short)*lpdwParams
                                           / (lpLips->unitdiv);
        lpLips->ptCurrent.y = lpLips->ptInLine.y  = (short)*(lpdwParams+1)
                                           / (lpLips->unitdiv);

        lpLips->printedchars = 0;
        lpLips->stringwidth  = 0;
        break;
#endif // 0

    case CUR_CR:
        // Unidrv needs to send CR in order to set x dimension to 0.
        pOEM->ptCurrent.x = pOEM->ptInLine.x  = 0;

        pOEM->printedchars = 0;
        pOEM->stringwidth  = 0;

        break;

// LIPS4 Features
    // Duplexing support
    case OCD_DUPLEX_ON:
        pOEM->fduplex  = TRUE;

        break;
    case OCD_DUPLEX_VERT:
        pOEM->fduplex  = TRUE;		// should be set on NT5
        pOEM->fduplextype  = VERT;

        break;
    case OCD_DUPLEX_HORZ:
        pOEM->fduplex  = TRUE;		// should be set on NT5
        pOEM->fduplextype  = HORZ;

        break;

    // N Pages Support (2x, 4x), orders
    case OCD_PAPERQUALITY_2XL:
        pOEM->nxpages      = OCD_PAPERQUALITY_2XL;

        break;
    case OCD_PAPERQUALITY_2XR:
        pOEM->nxpages      = OCD_PAPERQUALITY_2XR;

        break;
    case OCD_PAPERQUALITY_4XL:
        pOEM->nxpages      = OCD_PAPERQUALITY_4XL;

        break;
    case OCD_PAPERQUALITY_4XR:
        pOEM->nxpages      = OCD_PAPERQUALITY_4XR;

        break;

    // Smoothing support
    case OCD_TEXTQUALITY_ON:
        pOEM->fsmoothing   = 2; // ON should be 2

        break;
    case OCD_TEXTQUALITY_OFF:
        pOEM->fsmoothing   = 1; // OFF should be 1

        break;
    // Toner economy mode
    case OCD_PRINTDENSITY_ON:
        pOEM->fecono       = 2; // ON should be 2

        break;
    case OCD_PRINTDENSITY_OFF:
        pOEM->fecono       = 1; // OFF should be 1

        break;
    // Dithering mode
    case OCD_IMAGECONTROL_ON:
        pOEM->fdithering   = 2; // ON should be 2

        break;
    case OCD_IMAGECONTROL_OFF:
        pOEM->fdithering   = 1; // OFF should be 1

        break;


#if 0	// NT5 GPD doesn't support vector mode yet.
// Vector command.
    case CAR_SET_PEN_COLOR:
        switch(*lpdwParams)
        {
        case PENCOLOR_WHITE:
            lpLips->sPenColor = 2;
            break;
        case PENCOLOR_BLACK:
        default:
            lpLips->sPenColor = 0;
            break;
        }
        SetPenAndBrush(lpdv, SET_PEN);
        break;

    case BRUSH_BYTE_2:
        lpLips->BrushImage[lpLips->wCurrentImage++] =  ~((BYTE) *lpdwParams);
        break;

    case BRUSH_END_1:
        for (i = 0;i < 32; i ++)
            for (j = 0; j < 4; j ++)
                ch[(i<<2) + j] = lpLips->BrushImage[i % 8];
        WriteSpoolBuf(lpdv, (LPSTR)ch, 128);
        lpLips->wCurrentImage = 0;
        break;
    case BRUSH_SELECT:
        lpLips->sBrushStyle =  *(LPSHORT)lpdwParams + 0x29 ;
        lpLips->fVectCmd &=  ~VFLAG_BRUSH_NULL;
        SetPenAndBrush(lpdv, SET_BRUSH);
        break;

    case BRUSH_NULL:
    case BRUSH_SOLID:
    case BRUSH_HOZI:
    case BRUSH_VERT:
    case BRUSH_FDIAG:
    case BRUSH_BDIAG:
    case BRUSH_CROSS:
    case BRUSH_DIACROSS:
        lpLips->sBrushStyle = wCmdCbId-BRUSH_NULL;
        if(wCmdCbId == BRUSH_NULL)
            lpLips->fVectCmd |= VFLAG_BRUSH_NULL;
        else
            lpLips->fVectCmd &=  ~VFLAG_BRUSH_NULL;

        SetPenAndBrush(lpdv, SET_BRUSH);
        break;

    case PEN_NULL:
    case PEN_SOLID:
    case PEN_DASH:
    case PEN_DOT:
    case PEN_DASHDOT:
    case PEN_DASHDOTDOT:
        if (wCmdCbId == PEN_NULL)
        {
            lpLips->fVectCmd |= VFLAG_PEN_NULL;
            lpLips->sPenStyle = 0;
        }
        else
        {
            lpLips->fVectCmd &= ~VFLAG_PEN_NULL;
            lpLips->sPenStyle = wCmdCbId-PEN_SOLID;
        }
        SetPenAndBrush(lpdv, SET_PEN);
        break;

    case PEN_WIDTH:
        lpLips->sPenWidth = *(LPSHORT)lpdwParams;
        SetPenAndBrush(lpdv, SET_PEN);
        break;

    case VECT_INIT:
        lpLips->fVectCmd |= VFLAG_VECT_MODE_ON;
        break;
#endif // 0

#if 0
// ntbug9#98276: Support Color Bold
// We no longer used software palette for full color mode.
// (See ntbug9#9127 for more details.)
#if defined(LBP_2030) || defined(LIPS4C)
    // #195162: Color font incorrectly
    case OCD_BEGINPALETTE:
	pOEM->maxpal = 0;
	break;

    case OCD_ENDPALETTE:
	break;

    case OCD_DEFINEPALETTE:
	if (dwCount < 3 || !pdwParams)
	    break;
	i = pOEM->maxpal++;
	pOEM->Palette[i].rgbtRed = (BYTE)pdwParams[0];
	pOEM->Palette[i].rgbtGreen = (BYTE)pdwParams[1];
	pOEM->Palette[i].rgbtBlue = (BYTE)pdwParams[2];
	break;

    case OCD_SELECTPALETTE:
	{
	DWORD		n, r, g, b;

	if (dwCount < 1 || !pdwParams)
	    break;
	n = pdwParams[0];
	r = ((DWORD)(pOEM->Palette[n].rgbtRed) * 200L) / 51L;
	g = ((DWORD)(pOEM->Palette[n].rgbtGreen) * 200L) / 51L;
	b = ((DWORD)(pOEM->Palette[n].rgbtBlue) * 200L) / 51L;
	wlen = 0;
	ch[wlen++] = 'X';	// Select font color
	wlen += VFormat(r, &ch[wlen]);
	wlen += VFormat(g, &ch[wlen]);
	wlen += VFormat(b, &ch[wlen]);
	ch[wlen++] = '\x1E';
	WRITESPOOLBUF(pdevobj, ch, wlen);
	}
	break;

#endif // LBP_2030 || LIPS4C
#endif // 0

// ntbug9#98276: Support Color Bold
    // Select 8 colors directly.
    case OCD_SELECTBLACK:
        r = 0;
        g = 0;
        b = 0;
        goto selcolor;
    case OCD_SELECTBLUE:
        r = 0;
        g = 0;
        b = 1000;
        goto selcolor;
    case OCD_SELECTGREEN:
        r = 0;
        g = 1000;
        b = 0;
        goto selcolor;
    case OCD_SELECTCYAN:
        r = 0;
        g = 1000;
        b = 1000;
        goto selcolor;
    case OCD_SELECTRED:
        r = 1000;
        g = 0;
        b = 0;
        goto selcolor;
    case OCD_SELECTMAGENTA:
        r = 1000;
        g = 0;
        b = 1000;
        goto selcolor;
    case OCD_SELECTYELLOW:
        r = 1000;
        g = 1000;
        b = 0;
        goto selcolor;
    case OCD_SELECTWHITE:
        r = 1000;
        g = 1000;
        b = 1000;
        goto selcolor;

    // Select full color.
    case OCD_SELECTCOLOR:
        if (dwCount < 3 || !pdwParams)
            break;
	r = (pdwParams[0] * 200L) / 51L;
	g = (pdwParams[1] * 200L) / 51L;
	b = (pdwParams[2] * 200L) / 51L;
    selcolor:
        wlen = 0;
        ch[wlen++] = 'X';	// Select font color
        wlen += VFormat(r, &ch[wlen]);
        wlen += VFormat(g, &ch[wlen]);
        wlen += VFormat(b, &ch[wlen]);
        ch[wlen++] = '\x1E';
        WRITESPOOLBUF(pdevobj, ch, wlen);
        // Remember the current color
        pOEM->CurColor.dwRed = r;
        pOEM->CurColor.dwGreen = g;
        pOEM->CurColor.dwBlue = b;
        break;

    // Select 256 color.
    case OCD_SELECTPALETTE:
        if (dwCount < 1 || !pdwParams)
            break;
        wlen = 0;
        ch[wlen++] = 'X';	// Select font color
        wlen += VFormat(pdwParams[0], &ch[wlen]);       // Palette index
        ch[wlen++] = '\x1E';
        WRITESPOOLBUF(pdevobj, ch, wlen);
        // Remember the current palette index
        pOEM->dwCurIndex = pdwParams[0];
        break;

	// #185185: Support RectFill
    case OCD_SETRECTWIDTH:
	if (dwCount < 1 || !pdwParams)
	    break;
	pOEM->RectWidth = *pdwParams / pOEM->unitdiv;
	break;
    case OCD_SETRECTHEIGHT:
	if (dwCount < 1 || !pdwParams)
	    break;
	pOEM->RectHeight = *pdwParams / pOEM->unitdiv;
	break;
    case OCD_RECTWHITEFILL:
	i = 0x29;
	goto fill;
    case OCD_RECTBLACKFILL:
	i = 0x31;
	goto fill;

   fill:
	{
	long	x, y;

	wlen = 0;
	if (pOEM->bLogicStyle != OVER_MODE) {
		ch[wlen++] = '\x7D';
		ch[wlen++] = 'H';
		ch[wlen++] = '0';
		ch[wlen++] = '\x1E';
		pOEM->bLogicStyle = OVER_MODE;
	}

        ch[wlen++] = 'I';	// specify fill pattern
        ch[wlen++] = (BYTE)i;
        ch[wlen++] = 0x30;
        ch[wlen++] = '\x1E';

        ch[wlen++] = '\x7D';
        ch[wlen++] = ':';	// fill rectangle
	x = pOEM->ptCurrent.x;
	wlen += VFormat(x, (LPSTR)(ch+wlen));
	x += pOEM->RectWidth;
	wlen += VFormat(x, (LPSTR)(ch+wlen));
	y = pOEM->ptCurrent.y;
	wlen += VFormat(y, (LPSTR)(ch+wlen));
	y += pOEM->RectHeight;
	wlen += VFormat(y, (LPSTR)(ch+wlen));
        ch[wlen++] = '\x1E';
	WRITESPOOLBUF(pdevobj, ch, wlen);
	}
	break;

// #228625: Stacker support
// ntbug9#293002: Features are different from H/W options.
    case OCD_TRAY_AUTO:
	pOEM->tray = 0;
	break;
    case OCD_TRAY_DEFAULT:
	pOEM->tray = 100;
	break;
    case OCD_TRAY_SUBTRAY:
	pOEM->tray = 101;
	break;
    case OCD_TRAY_BIN1:
    case OCD_TRAY_BIN2:
    case OCD_TRAY_BIN3:
    case OCD_TRAY_BIN4:
    case OCD_TRAY_BIN5:
    case OCD_TRAY_BIN6:
    case OCD_TRAY_BIN7:
    case OCD_TRAY_BIN8:
    case OCD_TRAY_BIN9:
    case OCD_TRAY_BIN10:
	pOEM->tray = (char)(dwCmdCbID - OCD_TRAY_BIN1 + 1);
	break;

    case OCD_JOBOFFSET:
	pOEM->method = METHOD_JOBOFFSET;
	break;
    case OCD_STAPLE:
	pOEM->method = METHOD_STAPLE;
	break;
    case OCD_FACEUP:
	pOEM->method = METHOD_FACEUP;
	break;

    case OCD_TOPLEFT:
    case OCD_TOPCENTER:
    case OCD_TOPRIGHT:
    case OCD_MIDLEFT:
    case OCD_MIDCENTER:
    case OCD_MIDRIGHT:
    case OCD_BOTLEFT:
    case OCD_BOTCENTER:
    case OCD_BOTRIGHT:
	pOEM->staple = (char)(dwCmdCbID - OCD_TOPLEFT);
	break;

// Support DRC
    case OCD_SETBMPWIDTH:
	if (dwCount < 1 || !pdwParams)
	    break;
	pOEM->dwBmpWidth = *pdwParams;
        break;

    case OCD_SETBMPHEIGHT:
	if (dwCount < 1 || !pdwParams)
	    break;
	pOEM->dwBmpHeight = *pdwParams;
        break;

// ntbug9#172276: Sorter support
    case OCD_SORT:
	pOEM->sorttype = SORTTYPE_SORT;
	break;
    case OCD_STACK:
	pOEM->sorttype = SORTTYPE_STACK;
	break;
// ntbug9#293002: Features are different from H/W options.
    case OCD_GROUP:
	pOEM->sorttype = SORTTYPE_GROUP;
	break;
    case OCD_SORT_STAPLE:
	pOEM->sorttype = SORTTYPE_STAPLE;
	break;

    case OCD_COPIES:
	if (dwCount < 1 || !pdwParams)
	    break;
	pOEM->copies = (WORD)pdwParams[0];
	break;

// ntbug9#293002: Features are different from H/W options.
    case OCD_STARTBIN0:
    case OCD_STARTBIN1:
    case OCD_STARTBIN2:
    case OCD_STARTBIN3:
    case OCD_STARTBIN4:
    case OCD_STARTBIN5:
    case OCD_STARTBIN6:
    case OCD_STARTBIN7:
    case OCD_STARTBIN8:
    case OCD_STARTBIN9:
    case OCD_STARTBIN10:
	pOEM->startbin = (char)(dwCmdCbID - OCD_STARTBIN0);
	break;

    }
	return 0;
}


/*
 *	OEMSendFontCmd
 */
VOID APIENTRY
OEMSendFontCmd(
	PDEVOBJ		pdevobj,
	PUNIFONTOBJ	pUFObj,
	PFINVOCATION	pFInv)
{
	PGETINFO_STDVAR pSV;
#define FI_HEIGHT	(pSV->StdVar[0].lStdVariable)
#define FI_WIDTH	(pSV->StdVar[1].lStdVariable)
#define FI_TEXTYRES	(pSV->StdVar[2].lStdVariable)
#define FI_TEXTXRES	(pSV->StdVar[3].lStdVariable)
	PBYTE		pubCmd;
	PIFIMETRICS	pIFI;
	DWORD 		lres, lheight, lvert, dwGetInfo;
	PLIPSPDEV       pOEM;
	BYTE		fontid, tid;
	WORD		wlen, firstchar, lastchar, unitdiv;
	WORD		i, ii;
// 2/5/98 takashim GETINFO_FONTOBJ	FO;
	DWORD		adwStdVariable[2+2*4];
	BYTE		ch[CCHMAXCMDLEN];

	// DbgPrint(DLLTEXT("OEMSendFontCmd() entry.\r\n"));

	pubCmd = pFInv->pubCommand;
	if (pubCmd == NULL) {
		// DbgPrint(DLLTEXT("Invalid SelectFont command.\r\n"));
		return;
	}
	pIFI = pUFObj->pIFIMetrics;
	pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

#if 0 // 2/5/98 takashim (FONTOBJ not always available)
	//
	// GETINFO_FONTOBJ
	//
	FO.dwSize = sizeof(GETINFO_FONTOBJ);
	FO.pFontObj = NULL;
	dwGetInfo = FO.dwSize;

	if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_FONTOBJ, &FO,
		dwGetInfo, &dwGetInfo)) {
		// DbgPrint(DLLTEXT("UFO_GETINFO_FONTOBJ failed.\r\n"));
		return;
	}
#endif // 2/5/98 takashim

	//
	// Get standard variables.
	//

	pSV = (PGETINFO_STDVAR)adwStdVariable;
	pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
	pSV->dwNumOfVariable = 4;
	pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
	pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
	pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
	pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
	dwGetInfo = pSV->dwSize;
	if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
		dwGetInfo, &dwGetInfo)) {
		// DbgPrint(DLLTEXT("UFO_GETINFO_STDVARIABLE failed.\r\n"));
		return;
	}

	lres = pOEM->resolution;
	// #120640: It doesn't need on NT5 unidrv
	// 150dpi means only image data is 150dpi
	// if(lres == 150)
	//     lres = 300;

	// use 1/300 inch unit, which should have already been set.
	// convert font height to 1/300 inch units
	lvert = FI_TEXTYRES;
	lheight = FI_HEIGHT / pOEM->unitdiv;

	pOEM->tblCurrentFont.FontHeight = (short)((lheight
	    * lres + lvert/2) / lvert);
	//pOEM->tblCurrentFont.FontHeight = (short)(((lheight
	//    - (long)(lpFont->dfInternalLeading)) * lres + lvert/2) / lvert);
	pOEM->tblCurrentFont.FontWidth = (short)(FI_WIDTH / pOEM->unitdiv);
	// lpLips->tblCurrentFont.MaxWidth  = (short)(lpFont->dfMaxWidth);
	pOEM->tblCurrentFont.MaxWidth  = (short)(pIFI->fwdAveCharWidth * 2);
	pOEM->tblCurrentFont.AvgWidth  = (short)(pIFI->fwdAveCharWidth);
	// #120474: font shift to right
	pOEM->tblCurrentFont.Ascent    = (short)(pOEM->tblCurrentFont.FontHeight
		* pIFI->fwdWinAscender / (pIFI->fwdWinAscender +
		pIFI->fwdWinDescender));

    // Obtain X/Y size ratio and calculate horizontal
    // expansion factor (supporting non-square scaling.)
    pOEM->tblCurrentFont.Stretch = (SHORT)(100
        * FI_WIDTH * FH_IFI(pIFI) / FI_HEIGHT / FW_IFI(pIFI));

	// Get font ID
	fontid = pubCmd[0]; // the first character means font Id

	if(fontid < FirstLogicalFont)
	    {
	//    ch[0]      = fontid;
	//    wlen       = 1;
	//    WriteSpoolBuf(lpdv, ch, wlen);
	    return;
	    }

	// Send font, grx ids x 4 x 2
	tid = LFontList[fontid - FirstLogicalFont][0];
	//if(lpLips->curFontGrxIds[0] != tid)
	//    {  // Font ID G0
	    ch[0]      = 'T';
	    if (tid <= 15)
		{
		ch[1]      = tid + 0x30;
		ch[2]      = 0x1E;
		wlen       = 3;
		}
	     else
		{
		ch[1]      = 0x40 + tid / 16;
		ch[2]      = 0x30 + tid % 16;
		ch[3]      = 0x1E;
		wlen       = 4;
		}
	    WRITESPOOLBUF(pdevobj, ch, wlen);
	    pOEM->curFontGrxIds[0] = tid;
	//    }
	tid = LFontList[fontid - FirstLogicalFont][1];
	//if(lpLips->curFontGrxIds[1] != tid)
	//    {  // Font ID G1
	    ch[0]      = 'm';
	    if (tid <= 15)
		{
		ch[1]      = tid + 0x30;
		ch[2]      = 0x1E;
		wlen       = 3;
		}
	     else
		{
		ch[1]      = 0x40 + tid / 16;
		ch[2]      = 0x30 + tid % 16;
		ch[3]      = 0x1E;
		wlen       = 4;
		}
	    WRITESPOOLBUF(pdevobj, ch, wlen);
	    pOEM->curFontGrxIds[1] = tid;
	//    }
	tid = LFontList[fontid - FirstLogicalFont][2];
	//if(lpLips->curFontGrxIds[2] != tid)
	//    {  // Font ID G2
	    ch[0]      = 'n';
	    if (tid <= 15)
		{
		ch[1]      = tid + 0x30;
		ch[2]      = 0x1E;
		wlen       = 3;
		}
	     else
		{
		ch[1]      = 0x40 + tid / 16;
		ch[2]      = 0x30 + tid % 16;
		ch[3]      = 0x1E;
		wlen       = 4;
		}
	    WRITESPOOLBUF(pdevobj, ch, wlen);
	    pOEM->curFontGrxIds[2] = tid;
	//    }
	tid = LFontList[fontid - FirstLogicalFont][3];
	//if(lpLips->curFontGrxIds[3] != tid)
	//    {  // Font ID G3
	    ch[0]      = 'o';
	    if (tid <= 15)
		{
		ch[1]      = tid + 0x30;
		ch[2]      = 0x1E;
		wlen       = 3;
		}
	     else
		{
		ch[1]      = 0x40 + tid / 16;
		ch[2]      = 0x30 + tid % 16;
		ch[3]      = 0x1E;
		wlen       = 4;
		}
	    WRITESPOOLBUF(pdevobj, ch, wlen);
	    pOEM->curFontGrxIds[3] = tid;
	//    }
	tid = LFontList[fontid - FirstLogicalFont][4];
	//if(lpLips->curFontGrxIds[4] != tid)
	//    {  // Grx ID G0
	    ch[0]      = ']';
	    if (tid <= 15)
		{
		ch[1]      = tid + 0x30;
		ch[2]      = 0x1E;
		wlen       = 3;
		}
	     else
		{
		ch[1]      = 0x40 + tid / 16;
		ch[2]      = 0x30 + tid % 16;
		ch[3]      = 0x1E;
		wlen       = 4;
		}
	    WRITESPOOLBUF(pdevobj, ch, wlen);
	    pOEM->curFontGrxIds[4] = tid;
	//    }
	tid = LFontList[fontid - FirstLogicalFont][5];
	//if(lpLips->curFontGrxIds[5] != tid)
	//    {  // Grx ID G1
	    ch[0]      = 0x60; // '`'
	    if (tid <= 15)
		{
		ch[1]      = tid + 0x30;
		ch[2]      = 0x1E;
		wlen       = 3;
		}
	     else
		{
		ch[1]      = 0x40 + tid / 16;
		ch[2]      = 0x30 + tid % 16;
		ch[3]      = 0x1E;
		wlen       = 4;
		}
	    WRITESPOOLBUF(pdevobj, ch, wlen);
	    pOEM->curFontGrxIds[5] = tid;
	//    }
	tid = LFontList[fontid - FirstLogicalFont][6];
	//if(lpLips->curFontGrxIds[6] != tid)
	//    {  // Grx ID G2
	    ch[0]      = 'a';
	    if (tid <= 15)
		{
		ch[1]      = tid + 0x30;
		ch[2]      = 0x1E;
		wlen       = 3;
		}
	     else
		{
		ch[1]      = 0x40 + tid / 16;
		ch[2]      = 0x30 + tid % 16;
		ch[3]      = 0x1E;
		wlen       = 4;
		}
	    WRITESPOOLBUF(pdevobj, ch, wlen);
	    pOEM->curFontGrxIds[6] = tid;
	//    }
	tid = LFontList[fontid - FirstLogicalFont][7];
	//if(lpLips->curFontGrxIds[7] != tid)
	//    {  // Grx ID G3
	    ch[0]      = 'b';
	    if (tid <= 15)
		{
		ch[1]      = tid + 0x30;
		ch[2]      = 0x1E;
		wlen       = 3;
		}
	     else
		{
		ch[1]      = 0x40 + tid / 16;
		ch[2]      = 0x30 + tid % 16;
		ch[3]      = 0x1E;
		wlen       = 4;
		}
	    WRITESPOOLBUF(pdevobj, ch, wlen);
	    pOEM->curFontGrxIds[7] = tid;
	//    }

	    pOEM->GLTable = INIT;
	    pOEM->GRTable = INIT;
	// #150055: White device font isn't printed out
	    pOEM->OrnamentedChar[0] = pOEM->OrnamentedChar[1] = INIT;

	//*******************************************************************
	// Propotional Character Width Table
	// This buffer is saved character widths of LIPS device font to
	// caluculate a location of text in OEMOutputChar(). In LIPS, we
	// have to specify a location of text when printing the text every
	// time. But we can't get the information of lacation of text from
	// Unidriver every calling. So we need to manage the location of
	// text by ourselves in OEMOutputChar().
	//
	// By Hitoshis at March 28, 1995
	//*******************************************************************

	// Set Pitch of the font
	// if (pIFI->flInfo &
	//     (FM_INFO_OPTICALLY_FIXED_PITCH|FM_INFO_DBCS_FIXED_PITCH))
	// #120640: for the proportional fonts
	if (pIFI->jWinPitchAndFamily & 0x01)
	    pOEM->fpitch = FIXED;
	else
	    pOEM->fpitch = PROP;

	// Do not need FIXED pitch status for NT5 driver
	// pOEM->fpitch = PROP;

	// Checking if this font is used in the previous time.
	// If this font is prop and and scalable, the size of font is changed,
	// we need to update width table.
	#if 0
	if(lpLips->cachedfont == fontid)
	    return;
	#endif

	// The bottom of lpFont is character width table which has scaled
	// as device metrix. The character range are between a gereral first
	// char (32) - a gereral last char (255). So I don't check the
	// overflow. If pfm data is broken, I don't care...
	// Unidriver already scaled all character widthes in realize().

	// lpWidth = (LPSHORT)((LPSTR)lpFont + sizeof(PFMHEADER));
	// firstchar = pIFI->chFirstChar;
	// lastchar  = pIFI->chLastChar);
	// unitdiv   = pOEM->unitdiv;

	/***
	    for (i = 0; i < firstchar; i++) {
		lpLips->widthbuffer[i] = 0;
	    }
	    for (ii = 0; i <= lastchar; i++, ii++) {
		lpLips->widthbuffer[i] = (lpWidth[ii] + unitdiv/2) / unitdiv;
	    }
	    for (; i < 256; i++) {
		lpLips->widthbuffer[i] = 0;
	    }
	***/

	// Save cached font in this time
	pOEM->cachedfont = fontid;
}


// **** Text path
BOOL settextpath(pdevobj, vert)
PDEVOBJ	pdevobj;
BOOL	vert;
{
PLIPSPDEV  pOEM;
BYTE       ch[CCHMAXCMDLEN];
WORD       wlen;
char       c1;
BOOL       ret;

pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

if(vert == TRUE) // Vertical writing mode
   c1 = 0x33;
else // Horisontal writing mode
   c1 = 0x30;

    // Now send out printer commands if necessary.

    ret = FALSE;

    if (pOEM->TextPath != c1)
        {
        // set horizontal or vertical writing mode
        pOEM->TextPath = c1;
        ret = TRUE;
        }

    return ret;
}

// **** Character orientation
BOOL setcharorient(pdevobj, vert)
PDEVOBJ	pdevobj;
BOOL	vert;
{
PLIPSPDEV  pOEM;
BYTE       ch[CCHMAXCMDLEN];
WORD       wlen;
short      s1, s2, s3, s4;
short      t1, t2, t3, t4;
BOOL       ret;
short      esc;

pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

if(pOEM->fitalic == TRUE && vert != TRUE)
    {
    // if Italic and horisontal writing mode
    s1 = 208; // x of up vecter
    s2 = -978; // y of up vecter
    s3 = 1000; // x of base vecter
    s4 = 0; // y of base vecter
    }
else if(pOEM->fitalic != TRUE && vert != TRUE)
    {
    // if non Italic and horisontal writing mode
    s1 = 0; // x of up vecter
    s2 = -1000; // y of up vecter
    s3 = 1000; // x of base vecter
    s4 = 0; // y of base vecter
    }
else if(pOEM->fitalic == TRUE && vert == TRUE)
    {
    // if Italic and vertical writing mode
    s1 = -1000; // x of up vecter
    s2 = 0; // y of up vecter
    s3 = 208; // x of base vecter
    s4 = -978; // y of base vecter
    }
else
    {
    // if non Italic and vertical writing mode
    s1 = -1000; // x of up vecter
    s2 = 0; // y of up vecter
    s3 = 0; // x of base vecter
    s4 = -1000; // y of base vecter
    }

// calculate print direction
t1 = s1; t2 = s2; t3 = s3; t4 = s4;
esc = (pOEM->Escapement)/90;
switch(esc)
    {
    case 0:
        break;

    case 1: // 90
        s1 = t2; // x of up vecter
        s2 = -t1; // y of up vecter
        s3 = t4; // x of base vecter
        s4 = -t3; // y of base vecter
        break;

    case 2: // 180
        s1 = -t1; // x of up vecter
        s2 = -t2; // y of up vecter
        s3 = -t3; // x of base vecter
        s4 = -t4; // y of base vecter
        break;

    case 3: // 270
        s1 = -t2; // x of up vecter
        s2 = t1; // y of up vecter
        s3 = -t4; // x of base vecter
        s4 = t3; // y of base vecter
        break;
    }

    // Now send out printer commands if necessary.

    ret = FALSE;

    if (pOEM->CharOrientation[0] != s1 ||
        pOEM->CharOrientation[1] != s2 ||
        pOEM->CharOrientation[2] != s3 ||
        pOEM->CharOrientation[3] != s4)
        {
        // save character orientation vector
        pOEM->CharOrientation[0] = s1;
        pOEM->CharOrientation[1] = s2;
        pOEM->CharOrientation[2] = s3;
        pOEM->CharOrientation[3] = s4;
        ret = TRUE;
    }

    return ret;
}


// **** Check cursor positoin after printing text
// Prop DBCS support
void updateposition(pdevobj, lpstr, len, width, bDBCSFont)
PDEVOBJ	pdevobj;
LPSTR   lpstr;
short   len;
short	width;
BOOL bDBCSFont;
{
PLIPSPDEV pOEM;
char i;

pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

if(pOEM->fpitch == FIXED)
    {
    long       lmw, lc, s1;

    // lmw = (long)(pOEM->tblCurrentFont.MaxWidth);
    // lc = (long)len;
    // #120640: should be used FontHeight instead of MaxWidth
    // lmw = (long)(pOEM->tblCurrentFont.FontHeight);
    // #394067: Compute font width with font stretching.
    s1 = pOEM->tblCurrentFont.Stretch;
    lmw = (long)(pOEM->tblCurrentFont.FontHeight * s1) / 100;
    if (len != 2)	// for single byte chars
	lmw /= 2;

    // pOEM->stringwidth += (long)((lmw*lc+1)/2);
    pOEM->stringwidth += lmw - 1;
    }
else if (bDBCSFont)
    // Prop DBCS support
    {
    long    w;

// #371640: Suisu and Dacchi isn't printed correctly on 150dpi.
    w = (width * 300) / pOEM->resolution;
    // #394067: Compute font width with font stretching.
    w = (w * pOEM->tblCurrentFont.Stretch) / 100;
    pOEM->stringwidth += ((long)(pOEM->tblCurrentFont.FontHeight) * w) / 1000;
    }
#if 0   // Prop DBCS support
else if(pOEM->fpitch != FIXED && len == 2)
    {
    long       lmw;

    // If len = 2, we assume the character is DBCS. And DBCS
    // character width is always fixed pitch.
    lmw = (long)(pOEM->tblCurrentFont.FontHeight);

    pOEM->stringwidth += lmw - 1;
    }
#endif // 0
else
    {
    // Save a printed string width for device propotional character
    for(i=0; i<len; ++i)
        {
	short	res, pow;
        // short sc;
	long	w;

        // sc = (short)((uchar)(lpstr[i])); // getting character code
        // pOEM->stringwidth += (long)((pOEM->widthbuffer)[sc]);
	// #120640: I don't know why it should be power of 2 but it should be
	// need to add for NT5 unidrv.	1/14/98 yasuho
	res = pOEM->resolution;
	w = width;
        // #394067: Compute font width with font stretching.
        w = (w * pOEM->tblCurrentFont.Stretch) / 100;
#ifdef LIPS4C
	// #185704: Font overlaps each other.
	// Adjust font width calculation. This printers resolution does
	// not divisible by integer calculation.
	if (res == 360) {
		pow = 1 * 2;
		w = (long)width * 600L / res;
	} else
#endif
// #213732: 1200dpi support
	if (res == 1200)
		pow = 1;
	else if (res == 600)
		pow = 1 * 2;
	else if (res == 300)
		pow = 2 * 2;
	else if (res == 150)
		pow = 4 * 2;
// #441431: PREFIX: "pow" will be uninitialized if "res" is not one of
//          the checked values.
        else
                pow = 1 * 2;
        pOEM->stringwidth += ((long)(pOEM->tblCurrentFont.FontHeight) *
		(long)(w * pow)) / 1000;
        }
    }
}

// **** Put location of the text
VOID
puttextlocation(
    PDEVOBJ pdevobj,
    LONG *pCx,
    LONG *pCy
)
{

PLIPSPDEV  pOEM;
long       cx, cy;
short      esc;

pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

esc = (pOEM->Escapement)/90;

switch(esc)
    {
    case 0:
        pOEM->ptInLine.x += (short)(pOEM->stringwidth);
        cx = pOEM->ptInLine.x;
        cy = pOEM->ptInLine.y;
        if(pOEM->fvertical == TRUE) // Vertical writing mode
            {
            cy += (pOEM->tblCurrentFont.FontHeight / 2)
                         - pOEM->tblCurrentFont.Ascent;
            }
        break;

    case 1: // 90
        pOEM->ptInLine.y -= (short)(pOEM->stringwidth);
        cx = pOEM->ptInLine.x;
        cy = pOEM->ptInLine.y;
        if(pOEM->fvertical == TRUE) // Vertical writing mode
            {
            cx -= (pOEM->tblCurrentFont.FontHeight / 2)
                         + pOEM->tblCurrentFont.Ascent
                         - pOEM->tblCurrentFont.FontHeight;
            }
        break;

    case 2: // 180
        pOEM->ptInLine.x -= (short)(pOEM->stringwidth);
        cx = pOEM->ptInLine.x;
        cy = pOEM->ptInLine.y;
        if(pOEM->fvertical == TRUE) // Vertical writing mode
            {
            cy -= (pOEM->tblCurrentFont.FontHeight / 2)
                         - pOEM->tblCurrentFont.Ascent;
            }
        break;

    case 3: // 270
        pOEM->ptInLine.y += (short)(pOEM->stringwidth);
        cx = pOEM->ptInLine.x;
        cy = pOEM->ptInLine.y;
        if(pOEM->fvertical == TRUE) // Vertical writing mode
            {
            cx += (pOEM->tblCurrentFont.FontHeight / 2)
                         + pOEM->tblCurrentFont.Ascent
                         - pOEM->tblCurrentFont.FontHeight;
            }
        break;
    }

    *pCx = cx;
    *pCy = cy;

pOEM->stringwidth = 0;
}

/***************************************************************************
    Function Name : oemOutputChar

    Parameters    : LPDV	lpdv		Private Device Structure
                    LPSTR	lpstr		Print String
                    WORD	len		Length
                    WORD	rcID		Font ID

    Note          :

***************************************************************************/
short WINAPI oemOutputChar(pdevobj, lpstr, len, pIFI, width)
PDEVOBJ	pdevobj;
LPSTR lpstr;
WORD len;
PIFIMETRICS pIFI;
WORD width;
{
// #define MAKEWORD(l, h)  ((WORD)(((BYTE)(l)) | (((WORD)((BYTE)(h))) << 8)))

// #define bIsDBCSLeadByte(c) \
//     ((c) >= 0x81 && (c) <= 0x9f || (c) >= 0xe0 && (c) <=0xfc)
#define bIsControlChar(c) \
    ((c) >= 0x00 && (c) <= 0x1f || (c) >= 0x80 && (c) <= 0x9f)

WORD	wJIScode;

BYTE *pStr;
PLIPSPDEV  pOEM;
BYTE       ch[CCHMAXCMDLEN];
WORD       wlen;
short      i;
char       c1, c2;
char       p1, p2;
short      s1;
short      tsh, tsw;

BOOL bDBCSFont;
WORD wlenCtrl;
BYTE chCtrl[CCHMAXCMDLEN];
INT fTemp, fTempNew;
WORD wCount;
LONG cX, cY;
BOOL bVert;
BOOL bTemp;
BOOL bIsDBCS;

pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

    // pOEM->fvertical = RcidIsDBCSVertFont( rcID );
    // bDBCSFont = RcidIsDBCSFont( rcID );
    pStr = (BYTE *)pIFI + pIFI->dpwszFaceName;
    pOEM->fvertical = (pStr[0] == '@' && pStr[1] == '\0'); // vertical font
    bDBCSFont = (pIFI->jWinCharSet == SHIFTJIS_CHARSET);
    bIsDBCS = (len == 2);

// **** Logic style
// Send logic style
if (pOEM->fcolor) {

    // If it is full-color mode, set logic to PATCOPY
    // (same value as B/W OR_MODE)

    if (pOEM->bLogicStyle != OR_MODE)
    {
    wlen = 0;
    ch[wlen++] = '\x7D';
    ch[wlen++] = 'H';
    ch[wlen++] = '1';
    ch[wlen++] = 0x1E;
    WRITESPOOLBUF(pdevobj, ch, wlen);
    pOEM->bLogicStyle = OR_MODE;
    }

} else {

    if(pOEM->fwhitetext == TRUE && pOEM->bLogicStyle != AND_MODE)
    {
    // "\x7DH0\x0E" If White text mode, we should set AND mode
    ch[0]      = '\x7D';
    ch[1]      = 'H';
    ch[2]      = '3';
    ch[3]      = 0x1E;
    wlen       = 4;
    WRITESPOOLBUF(pdevobj, ch, wlen);
    pOEM->bLogicStyle = AND_MODE;
    }

if(pOEM->fwhitetext != TRUE && pOEM->bLogicStyle != OR_MODE)
    {
    // "\x7DH1\x0E" If Black text mode, we should set OR mode
    ch[0]      = '\x7D';
    ch[1]      = 'H';
    ch[2]      = '1';
    ch[3]      = 0x1E;
    wlen       = 4;
    WRITESPOOLBUF(pdevobj, ch, wlen);
    pOEM->bLogicStyle = OR_MODE;
    }

} // fcolor

// ntbug9#98276: Support Color Bold
if (pOEM->fbold && pOEM->fcolor) {
    if ((pOEM->fcolor == COLOR_8BPP && pOEM->dwCurIndex != pOEM->dwOutIndex) ||
        (pOEM->fcolor != COLOR_8BPP &&
        (pOEM->CurColor.dwRed != pOEM->OutColor.dwRed ||
        pOEM->CurColor.dwGreen != pOEM->OutColor.dwGreen ||
        pOEM->CurColor.dwBlue != pOEM->OutColor.dwBlue))) {
        PBYTE   pch;

        // Select Outline color.
        // We also need to specify the outline color for expand the character.
        pch = ch;
        *pch++ = 0x7D;          // Select Outline color
        *pch++ = 'X';
        if (pOEM->fcolor == COLOR_8BPP) { // palette mode
            pch += VFormat(pOEM->dwCurIndex, pch);
            pOEM->dwOutIndex = pOEM->dwCurIndex;
        } else {
            pch += VFormat(pOEM->CurColor.dwRed, pch);
            pch += VFormat(pOEM->CurColor.dwGreen, pch);
            pch += VFormat(pOEM->CurColor.dwBlue, pch);
            pOEM->OutColor = pOEM->CurColor;
        }
        *pch++ = 0x1E;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));
    }
}

// **** Ornamented character
if(pOEM->fwhitetext == TRUE)
    c1 = -9; // white fill
else
    c1 = 1; // black fill

if(pOEM->fbold == TRUE)
    {
    short y;
    short res;

    y   = pOEM->tblCurrentFont.FontHeight;
    res = pOEM->resolution;

    // OrnamentedChar[1] : means how much bold is per Character Height
    // 0 regular,-2 < 48point,-3 < 96point,-4 >= 96points
    // 150dpi : 0 regular,-2 < 200dots,-3 < 400dots,-4 >= 400dots
    // 300dpi : 0 regular,-2 < 200dots,-3 < 400dots,-4 >= 400dots
    // 600dpi : 0 regular,-2 < 400dots,-3 < 800dots,-4 >= 800dots
    // (150dpi means only image date is 150dpi)
    //
    // ntbug9#98276: Support Color Bold
    // Calculate the expanded factor for the color mode.
    if (pOEM->fcolor) {
        c2 = (y / (res / 6)) + 1;
    } else {
// #213732: 1200dpi support
    if(res == 1200)
        {
        if(y < 400)
            c2 = -2; // Bold
        else if(y < 800)
            c2 = -3; // Bold
        else if(y >= 800)
            c2 = -4; // Bold
        }
    else if(res == 600)
        {
        if(y < 400)
            c2 = -2; // Bold
        else if(y < 800)
            c2 = -3; // Bold
        else if(y >= 800)
            c2 = -4; // Bold
        }
#ifdef LIPS4C
    else if(res == 360)
        {
        if(y < 240)
            c2 = -2; // Bold
        else if(y < 480)
            c2 = -3; // Bold
        else if(y >= 480)
            c2 = -4; // Bold
        }
#endif // LIPS4C
    else if(res == 300)
        {
        if(y < 200)
            c2 = -2; // Bold
        else if(y < 400)
            c2 = -3; // Bold
        else if(y >= 400)
            c2 = -4; // Bold
        }
    else if(res == 150)
        {
        if(y < 200)
            c2 = -2; // Bold
        else if(y < 400)
            c2 = -3; // Bold
        else if(y >= 400)
            c2 = -4; // Bold
        }
    else
        {
        c2 = 0; // Regular
        }
    } // fcolor
    } // fbold
// #441432: PREFIX: "c2" does not initialized if pOEM->fbold is FALSE.
else
    c2 = 0; // Regular

// Output OrnamentedCharacter
p1 = pOEM->OrnamentedChar[0]; // fill mode
p2 = pOEM->OrnamentedChar[1]; // weight bold

if(c1==p1 && c2==p2)
    ;  // we don't need to send this command
else
    // ntbug9#98276: Support Color Bold
    if (pOEM->fcolor) {
        PBYTE   pch;

        // Character effects instruction #2.
        // We should use this command to bold the font for color models
        // because "<7D>^" command does not worked correctly on the color mode.
        pch = ch;
        *pch++ = 0x7D;
        *pch++ = '_';
        *pch++ = (c1 == -9) ? 0x29 : 0x31;      // White text
        *pch++ = '0';
        *pch++ = '0';
        *pch++ = '0';
        *pch++ = '1';
        *pch++ = '0';
        *pch++ = '0';
        *pch++ = '0';
        pch += VFormat(c2, pch);        // Outline size
        *pch++ = 0x1E;
        WRITESPOOLBUF(pdevobj, ch, (DWORD)(pch - ch));

        // save current mode
        pOEM->OrnamentedChar[0] = c1;
        pOEM->OrnamentedChar[1] = c2; //XXX
    } else {
    // \x7D^
    ch[0]      = '\x7D';
    ch[1]      = 0x5E;
    // fill mode
    if(c1==-9)
        {
        ch[2]      = 0x29; // -9 : white text
        }
    else
        {
        ch[2]      = 0x31; //  1 : black text
        }

    // save fill mode
    pOEM->OrnamentedChar[0] = c1;

    // bold mode
    if(c2==-4)
        ch[3]      = 0x24; // -4 : 7 dots bold text
    else if(c2==-3)
        ch[3]      = 0x23; // -3 : 5 dots bold text
    else if(c2==-2)
        ch[3]      = 0x22; // -2 : 3 dots bold text
    else // should be c2 == 0
        ch[3]      = 0x30; //  0 : regular text
    // save bold mode
    pOEM->OrnamentedChar[1] = c2;

    ch[4]      = 0x1E;
    wlen       = 5;
    WRITESPOOLBUF(pdevobj, ch, wlen);

    }

#if 0	// #137882: Black fonts doesn't printed.
	// According to Canon, these commands doesn't necessary.
if(pOEM->fwhitetext == TRUE)
    {
    WRITESPOOLBUF(pdevobj, cmdWhiteBold.pCmdStr, cmdWhiteBold.cbSize);
    }
#endif

// **** Character height
s1 = pOEM->tblCurrentFont.FontHeight;
if(s1 == pOEM->tblPreviousFont.FontHeight)
    ; // we don't need to send this command
else
    {
    ch[0]        = 'Y';
    wlen         = 1;
    wlen        += VFormat((long)s1, (LPSTR)(ch+wlen));
    ch[wlen++]   = 0x1E;
    WRITESPOOLBUF(pdevobj, ch, wlen);
    // save character height
    pOEM->tblPreviousFont.FontHeight = s1;
    }

// **** Character expansion factor
// support TC_SF_X_YINDEP
//tsh = pOEM->tblCurrentFont.FontHeight;
//tsw = pOEM->tblCurrentFont.MaxWidth;

// #120460: NT5 should be set 100 to expansion factor at this time
//s1 = 100;

// if(tsh == tsw || pOEM->fpitch == PROP)
//     {
//     s1 = 100;
//     }
// else
//     {
//     s1 = (100 * tsw + tsh / 2) / tsh;
//     }

s1 = pOEM->tblCurrentFont.Stretch;
if(s1 == pOEM->tblPreviousFont.Stretch)
    ; // we don't need to send this command
else
    {
    ch[0]        = 'V';
    wlen         = 1;
    wlen        += VFormat((long)s1, (LPSTR)(ch+wlen));
    ch[wlen++]   = 0x1E;
    WRITESPOOLBUF(pdevobj, ch, wlen);
    // restore character expansion factor
    pOEM->tblPreviousFont.Stretch = s1;
    }

    pStr = (BYTE *)lpstr;

// **** Set writing mode

    wlen = 0;
    bVert = FALSE;
    if (bDBCSFont) {
        if (bIsDBCS) {
            if (pOEM->fvertical)
                bVert = TRUE;
        }
    }

    if (settextpath(pdevobj, bVert)) {
        ch[wlen++] = '[';
        ch[wlen++] = pOEM->TextPath;
        ch[wlen++] = 0x1E;
        }

    if (setcharorient(pdevobj, bVert)) {
        ch[wlen++] = 'Z';
        wlen += VFormat(
            pOEM->CharOrientation[0],
            &ch[+wlen]);
        wlen += VFormat(
            pOEM->CharOrientation[1],
            &ch[+wlen]);
        wlen += VFormat(
            pOEM->CharOrientation[2],
            &ch[+wlen]);
        wlen += VFormat(
            pOEM->CharOrientation[3],
            &ch[+wlen]);
        ch[wlen++]= 0x1e;
    }

// Normal Text mode
// **** Put location of the text

    bTemp = pOEM->fvertical;
    pOEM->fvertical = (char)bVert;
    puttextlocation(pdevobj, &cX, &cY);
    pOEM->fvertical = (char)bTemp;
    ch[wlen++] = '4';
    ch[wlen++] = '0';
    wlen += VFormat(cX, &ch[wlen]);
    wlen += VFormat(cY, &ch[wlen]);

    // Check if we need switching between halfwidth and fulwidth.
    // We also check the existence of control characters.
    // Both of these require text data are send in separate chunks.

    fTemp = -1;
    wCount = 0;
    for (i = 0; i < len; i++) {
        if (bDBCSFont) {
            if (bIsDBCS) {
                fTempNew = 3;
                i++;
            }
            else if (bIsControlChar(pStr[i])) {
                fTempNew = 0;
            }
            else {
                fTempNew = 2;
            }
        }
        else {
            if (bIsControlChar(pStr[i])) {
                fTempNew = 0;
            }
            else {
                fTempNew = 1;
            }
        }

        // Status changed

        if (fTemp != fTempNew) {
            wCount++;
            fTemp = fTempNew;
        }
    }

    fTemp = -1;
    wlenCtrl = 0;
    for (i = 0; i < len; i++) {

        if (bDBCSFont) {
            if (bIsDBCS) {
                fTempNew = 3;
            }
            else if (bIsControlChar(pStr[i])) {
                fTempNew = 0;
            }
            else {
                fTempNew = 2;
            }
        }
        else {
            if (bIsControlChar(pStr[i])) {
                fTempNew = 0;
            }
            else {
                fTempNew = 1;
            }
        }

        if (fTemp != fTempNew) {

            wCount--;

            if (fTemp == 0) {
                wlen += VFormat((LONG)wlenCtrl, &ch[wlen]);
                ch[wlen++] = 0x1E; // IS2
                WRITESPOOLBUF(pdevobj, ch, wlen);
                WRITESPOOLBUF(pdevobj, chCtrl, wlenCtrl);
                wlen = 0;
                wlenCtrl = 0;
                ch[wlen++] = '4';
                ch[wlen++] = '1';
            }

            if (fTempNew == 0) {
                ch[wlen++] = '0';
                ch[wlen++] = 0x1E; // IS2
                ch[wlen++] = '4';
                ch[wlen++] = '!';
                ch[wlen++] = '1';
            }

            ch[wlen++] = (wCount > 0) ? '0' : '1';

            if (fTempNew == 3) {
                if (pOEM->fvertical == TRUE) {

                    if (pOEM->GLTable != 3) {
                        ch[wlen++] = 0x1B; // LS3
                        ch[wlen++] = 0x6F; // LS3
                        pOEM->GLTable = 3;
                    }

                    bTemp = FALSE;
                    if (settextpath(pdevobj, TRUE)) {
                        if (bTemp == FALSE) {
                            ch[wlen++] = 0x1e;
                            bTemp = TRUE;
                        }
                        ch[wlen++] = '[';
                        ch[wlen++] = pOEM->TextPath;
                        ch[wlen++] = 0x1E;
                    }

                    if (setcharorient(pdevobj, TRUE)) {
                        if (bTemp == FALSE) {
                            ch[wlen++] = 0x1e;
                            bTemp = TRUE;
                        }
                        ch[wlen++] = 'Z';
                        wlen += VFormat(
                            pOEM->CharOrientation[0],
                            &ch[+wlen]);
                        wlen += VFormat(
                            pOEM->CharOrientation[1],
                            &ch[+wlen]);
                        wlen += VFormat(
                            pOEM->CharOrientation[2],
                            &ch[+wlen]);
                        wlen += VFormat(
                            pOEM->CharOrientation[3],
                            &ch[+wlen]);
                        ch[wlen++]= 0x1e;
                    }

                    if (bTemp != FALSE) {
                        puttextlocation(pdevobj, &cX, &cY);
                        ch[wlen++] = '4';
                        ch[wlen++] = '0';
                        wlen += VFormat(cX, &ch[wlen]);
                        wlen += VFormat(cY, &ch[wlen]);
                        ch[wlen++] = (wCount > 0) ? '0' : '1';
                    }

                }
                else {
                    if (pOEM->GLTable != 2) {
                        ch[wlen++] = 0x1B; // LS2
                        ch[wlen++] = 0x6E; // LS2
                        pOEM->GLTable = 2;
                    }
                }
            }
            else {

                if (pOEM->GLTable != 0) {
                    ch[wlen++] = 0x0F; // SI
                    pOEM->GLTable = 0;
                }

                if (pOEM->GRTable != 1) {
                    ch[wlen++] = 0x1B; // LS1R
                    ch[wlen++] = 0x7E; // LS1R
                    pOEM->GRTable = 1;
                }
            }

        }

        if (fTempNew == 3) {

            /* Shift JIS to JIS */
            // wJIScode = MAKEWORD(pStr[i + 1], pStr[i]);
            // wJIScode = sjis2jis( wJIScode );
            ch[wlen++] = pStr[i];
            ch[wlen++] = pStr[i+1];
            // If len = 2, we assume the character is DBCS. And DBCS
            // character width is always fixed pitch.
            updateposition(pdevobj, &ch[wlen - 2], 2, width, bDBCSFont);
            i++;
        }
        else if (fTempNew == 0) {
            chCtrl[wlenCtrl++] = pStr[i];
            updateposition(pdevobj, &pStr[i], 1, width, bDBCSFont);
        }
        else {

            if (bDBCSFont) {
                 if(pOEM->fvertical == TRUE) // Vertical writing mode
                     { // Hankaku mode always requires Horisontal writing
                     // **** Set writing mode

                    bTemp = FALSE;
                    if (settextpath(pdevobj, FALSE)) {
                        if (bTemp == FALSE) {
                            ch[wlen++] = 0x1e;
                            bTemp = TRUE;
                        }
                        ch[wlen++] = '[';
                        ch[wlen++] = pOEM->TextPath;
                        ch[wlen++] = 0x1E;
                    }

                    if (setcharorient(pdevobj, FALSE)) {
                        if (bTemp == FALSE) {
                            ch[wlen++] = 0x1e;
                            bTemp = TRUE;
                        }
                        ch[wlen++] = 'Z';
                        wlen += VFormat(
                            pOEM->CharOrientation[0],
                            &ch[+wlen]);
                        wlen += VFormat(
                            pOEM->CharOrientation[1],
                            &ch[+wlen]);
                        wlen += VFormat(
                            pOEM->CharOrientation[2],
                            &ch[+wlen]);
                        wlen += VFormat(
                            pOEM->CharOrientation[3],
                            &ch[+wlen]);
                        ch[wlen++]= 0x1e;
                    }

                    if (bTemp != FALSE) {
                        pOEM->fvertical = FALSE;
                        puttextlocation(pdevobj, &cX, &cY);
                        ch[wlen++] = '4';
                        ch[wlen++] = '0';
                        wlen += VFormat(cX, &ch[wlen]);
                        wlen += VFormat(cY, &ch[wlen]);
                        ch[wlen++] = (wCount > 0) ? '0' : '1';
                        pOEM->fvertical = TRUE;
                    }
                }
            }

            ch[wlen++] = pStr[i];
            updateposition(pdevobj, &pStr[i], 1, width, bDBCSFont);
        }

        // Status changed
        if (fTemp != fTempNew) {
            fTemp = fTempNew;
        }
    }

    // Terminait string

    if (fTempNew == 0) {
        wlen += VFormat((LONG)wlenCtrl, &ch[wlen]);
        ch[wlen++] = 0x1E; // IS2
        WRITESPOOLBUF(pdevobj, ch, wlen);
        WRITESPOOLBUF(pdevobj, chCtrl, wlenCtrl);
    }
    else {
        ch[wlen++] = 0x1E;
        WRITESPOOLBUF(pdevobj, ch, wlen);
    }

    return len;
}

/*
 *	OEMOutputCharStr
 */
VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    PGETINFO_STDVAR	pSV;
    DWORD		adwStdVariable[2+2*2];
#define FI_FONTID	(pSV->StdVar[0].lStdVariable)
#undef	FI_WIDTH
#define FI_WIDTH	(pSV->StdVar[1].lStdVariable)
    GETINFO_GLYPHSTRING GStr;
    GETINFO_GLYPHWIDTH	GWidth;
    //
    //	#185776: Some objects doesn't print
    //	There were moved to DEVOBJ.
    //
    // BYTE  aubBuff[256];
    // LONG  widBuf[64];
    // WCHAR  uniBuff[256/sizeof(WCHAR)];	// #185762: Tilde isn't printed
// #333653: Change I/F for GETINFO_GLYPHSTRING
    PTRANSDATA pTrans, aTrans;
    PDWORD pdwGlyphID;
    PWORD  pwUnicode;
    DWORD  dwI, dwGetInfo, width;
    PLIPSPDEV pOEM;
    PIFIMETRICS pIFI;
    // Prop DBCS support
    DWORD w;

    // DbgPrint(DLLTEXT("OEMOutputCharStr() entry.\r\n"));
    pOEM = (PLIPSPDEV)(pdevobj->pdevOEM);

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:
        // DbgPrint(DLLTEXT("dwType = TYPE_GLYPHHANDLE\n"));

        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_UNICODE;
        GStr.pGlyphOut = pOEM->aubBuff;
	dwGetInfo = GStr.dwSize;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
		dwGetInfo, &dwGetInfo))
        {
            // DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            return;
        }

	CopyMemory(pOEM->uniBuff, pOEM->aubBuff, dwCount * sizeof(WCHAR));

        // pwUnicode = (PWORD)pOEM->aubBuff;
        // for (dwI = 0; dwI < dwCount; dwI ++)
        // {
        //     DbgPrint(DLLTEXT("Unicode[%d] = %x\r\n"), dwI, pwUnicode[dwI]);
        // }

        GStr.dwTypeOut = TYPE_TRANSDATA;
// #333653: Change I/F for GETINFO_GLYPHSTRING
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;
        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
		dwGetInfo, &dwGetInfo) || !GStr.dwGlyphOutSize)
        {
            // DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            return;
        }
        if ((aTrans = (PTRANSDATA)MemAlloc(GStr.dwGlyphOutSize)) == NULL) {
            // DbgPrint(DLLTEXT("MemAlloc failed.\r\n"));
            return;
        }
        GStr.pGlyphOut = aTrans;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
		dwGetInfo, &dwGetInfo))
        {
            // DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            goto out;
        }

	//
	// Get standard variables.
	//

	pSV = (PGETINFO_STDVAR)adwStdVariable;
	pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
	pSV->dwNumOfVariable = 2;
	pSV->StdVar[0].dwStdVarID = FNT_INFO_CURRENTFONTID;
	pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
	dwGetInfo = pSV->dwSize;
	if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV,
		dwGetInfo, &dwGetInfo)) {
		// DbgPrint(DLLTEXT("UFO_GETINFO_STDVARIABLE failed.\r\n"));
		goto out;
	}

	GWidth.dwSize = sizeof(GETINFO_GLYPHWIDTH);
	GWidth.dwCount = dwCount;
	GWidth.dwType = TYPE_GLYPHHANDLE;
	GWidth.pGlyph = pGlyph;
	GWidth.plWidth = pOEM->widBuf;
	if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHWIDTH, &GWidth,
		dwGetInfo, &dwGetInfo)) {
		// DbgPrint(DLLTEXT("UFO_GETINFO_GLYPHWIDTH failed.\r\n"));
		goto out;
	}

        // pTrans = (PTRANSDATA)pOEM->aubBuff;
        pTrans = aTrans;
	pIFI = pUFObj->pIFIMetrics;
	width = FI_WIDTH / pOEM->unitdiv;
        for (dwI = 0; dwI < dwCount; dwI++, pTrans++)
        {
            // DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubCodePageID:0x%x\n"),pTrans->ubCodePageID);
            // DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubType:0x%x\n"),pTrans->ubType);
            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
	    // #185762: Tilde isn't printed
            case MTYPE_COMPOSE:
		pTrans->uCode.ubCode = (BYTE)pOEM->uniBuff[dwI];
		// FALL THRU
            case MTYPE_DIRECT:
                // DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubCode:0x%x\n"),pTrans->uCode.ubCode);
                oemOutputChar(pdevobj, &pTrans->uCode.ubCode, 1, pIFI,
			pOEM->widBuf[dwI]);
                break;
            case MTYPE_PAIRED:
                // DbgPrint(DLLTEXT("TYPE_TRANSDATA:ubPairs:0x%x\n"),*(PWORD)(pTrans->uCode.ubPairs));
                // Prop DBCS support
                w = (pOEM->fpitch == PROP) ? pOEM->widBuf[dwI] : width;
		if (pTrans->uCode.ubPairs[0])
			oemOutputChar(pdevobj, pTrans->uCode.ubPairs, 2, pIFI, w);
		else
			oemOutputChar(pdevobj, &(pTrans->uCode.ubPairs[1]), 1, pIFI, w);
                break;
            }
        }
out:
        MemFree(aTrans);
        break;

    case TYPE_GLYPHID:
        // DbgPrint(DLLTEXT("dwType = TYPE_GLYPHID\n"));

        GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHID;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_GLYPHHANDLE;
        GStr.pGlyphOut = pOEM->aubBuff;
	dwGetInfo = GStr.dwSize;

        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
		dwGetInfo, &dwGetInfo))
        {
            // DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        }
        pdwGlyphID = (PDWORD)pOEM->aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            // DbgPrint(DLLTEXT("GlyphHandle[%d] = %d\r\n"), dwI, pdwGlyphID[dwI]);
        }

        GStr.dwTypeOut = TYPE_UNICODE;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr,
		dwGetInfo, &dwGetInfo))
        {
            // DbgPrint(DLLTEXT("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        }
        pwUnicode = (PWORD)pOEM->aubBuff;
        for (dwI = 0; dwI < dwCount; dwI ++)
        {
            // DbgPrint(DLLTEXT("Unicode[%d] = %x\r\n"), dwI, pwUnicode[dwI]);
        }

        for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)
        {
            // DbgPrint(DLLTEXT("TYEP_GLYPHID:0x%x\n"), *(PDWORD)pGlyph);
            pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj,
                                                 (PBYTE)pGlyph,
                                                 1);
        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

// #289908: pOEMDM -> pdevOEM
static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    // DbgPrint(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        // DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        // DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPTSTR OEMDevMode_fMode[] = {   __TEXT("NULL"),
                                    __TEXT("OEMDM_SIZE"),
                                    __TEXT("OEMDM_DEFAULT"),
                                    __TEXT("OEMDM_CONVERT"),
                                    __TEXT("OEMDM_MERGE"),
                                };

    // DbgPrint(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]);

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        // DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        // DbgPrint(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            // DbgPrint(__TEXT("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
#if 0
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));
#endif

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
#if 0
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }
#endif

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        // DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        // DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        // DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        // DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        // DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        // DbgPrint(__TEXT("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        // DbgPrint(__TEXT("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        // DbgPrint(__TEXT("\tcbSize = %d.\r\n"), pOEMDevModeParam->cbSize);
        // DbgPrint(__TEXT("\thPrinter = %#lx.\r\n"), pOEMDevModeParam->hPrinter);
        // DbgPrint(__TEXT("\thModule = %#lx.\r\n"), pOEMDevModeParam->hModule);
        // DbgPrint(__TEXT("\tpPublicDMIn = %#lx.\r\n"), pOEMDevModeParam->pPublicDMIn);
        // DbgPrint(__TEXT("\tpPublicDMOut = %#lx.\r\n"), pOEMDevModeParam->pPublicDMOut);
        // DbgPrint(__TEXT("\tpOEMDMIn = %#lx.\r\n"), pOEMDevModeParam->pOEMDMIn);
        // DbgPrint(__TEXT("\tpOEMDMOut = %#lx.\r\n"), pOEMDevModeParam->pOEMDMOut);
        // DbgPrint(__TEXT("\tcbBufSize = %d.\r\n"), pOEMDevModeParam->cbBufSize);
    }
}


#if 0
//
// Functions for outputting debug messages
//

VOID DbgPrint(IN LPCTSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
#endif // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

// LIPS4MS.H
// The description of LIPS Device font
// Due to register device fonts before using, and we can't know
// all fonts driver has, this header file must know all font of
// LIPS to download the facename.
// Jan. 1st, 1995 Hitoshi Sekine

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CNL4'      // Canon LIPS4 series dll
#define DLLTEXT(s)      __TEXT("CNL4:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L


//***************************************************
// general current status table
//***************************************************
typedef unsigned char uchar;

//***************************************************
// LIPS current status table
//***************************************************
typedef struct tagLIPSFDV {
    short FontHeight; // Y (dots) in SendScalableFontCmd()
    short FontWidth;  // X (dots) in SendScalableFontCmd()
    short MaxWidth;
    short AvgWidth;
    short Ascent;
    short Stretch; // Width extension factor
} LIPSFDV, FAR * LPLIPSFDV;

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
	OEM_DMEXTRAHEADER	dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

// ntbug9#98276: Support Color Bold
typedef struct _COLORVALUE {
        DWORD   dwRed, dwGreen, dwBlue;
} COLORVALUE;

// #289908: pOEMDM -> pdevOEM
typedef struct tag_LIPSPDEV {
	// private data as follows
    // short widthbuffer[256]; // buffer for device propotional character
    // Flags
    char  fbold; // uses Ornamented Character
    char  fitalic; // uses Char Orientatoin
    char  fwhitetext; // White Text mode
    char  fdoublebyte; // DBCS char mode
    char  fvertical; // Vertical writing mode
    char  funderline;
    char  fstrikesthu;
    char  fpitch;
    char  flpdx; // for only lpDx mode of ExtTextOut()
    char  f1stpage;
    char  fcompress; // 0x30 (no comp), 0x37 (method 1), or 0x3b (tiff)
    // features specific to LIPS4
    char  flips4;
    char  fduplex; // on or off (default)
    char  fduplextype; // vertical or horisontal
    char  fsmoothing; // device setting, on or off
    char  fecono; // device setting, on or off
    char  fdithering; // device setting, on or off
#ifdef LBP_2030
    char  fcolor;
    short fplane;
    short fplaneMax;
#endif
#ifdef LIPS4C
    char  flips4C;
#endif

    // Variables
    POINT    ptCurrent; // absolute position by cursor command
    POINT    ptInLine; // absolute position on Inline
    char     bLogicStyle;
    char     savechar; // for only lpDx mode of ExtTextOut()
    short    printedchars; // total number of printed characters
    long     stringwidth; // total width of printed propotional character
    char     firstchar; // first character code of the pfm
    char     lastchar; // last character code of the pfm

    uchar curFontGrxIds[8]; // G0 T, G1 m, G2 n, G3 o of font indeies
                            // G0 ], G1 `, G2 a, G3 b of Graphic Set indeies
                            // for GetFontCmd(), in PFM data
    LIPSFDV  tblPreviousFont; // font attribute of printer setting
    LIPSFDV  tblCurrentFont;  // font attribute of driver setting
    char  OrnamentedChar[5]; // }^ Bold sumilation
                // 1-Pattern, 2-Outline, 3-Rotation, 4-Mirror, 5-Negative
                // 2-Outline
                //   < 48 points  -> -2 (3 dots)
                //   < 96 points  -> -3 (5 dots)
                //   96 =< points -> -4 (7 dots)
    char  TextPath; // [ Vertical Writing or Horisontal Writing
    short CharOrientation[4]; // Z  Italic sumilation
//    short CharExpansionFactor; // V for only ZapfChancery ???
    char GLTable;  // takes 0 (g0), 1 (g1), 2 (g2), 3 (g3) or -1 (none)
    char GRTable;  // takes 0 (g0), 1 (g1), 2 (g2), 3 (g3) or -1 (none)
    unsigned char  cachedfont; // font id of cached font
    char  papersize; // PaperSize ID
    char  currentpapersize; // PaperSize ID in printer
// ntbug9#254925: CUSTOM papers.
    DWORD dwPaperWidth;
    DWORD dwPaperHeight;
    short Escapement; // Print direction (0 - 360)
    short resolution; // resolution (600, 300, 150dpi)
		      // LIPS4C: (360, 180dpi)
    short unitdiv; // 600 / resolution (600 - 1, 300 - 2, 150 - 4)
		   // LIPS4C: (360 = 1, 180 = 2)
    // Lips4 feature
    char  nxpages; // 2xLeft, 2xRight, 4xLeft, 4xRight
//    short widthbuffer[256]; // buffer for device propotional character

    short sPenColor;
    short sPenWidth;
    short sBrushStyle;
    short sPenStyle;
    unsigned short fVectCmd;
    unsigned short  wCurrentImage;
#if 0
    char  BrushImage[128];  //32 x 32 Brush pattern
#endif // 0
    //
    //	#185776: Some objects doesn't print
    //	Any buffer doesn't enough to print the long strings.
    //
#define MAX_GLYPHLEN	512
    WCHAR  aubBuff[MAX_GLYPHLEN];
    LONG   widBuf[MAX_GLYPHLEN];
    WCHAR  uniBuff[MAX_GLYPHLEN];	// #185762: Tilde isn't printed
    // #195162: Color font incorrectly
#if 0
// ntbug9#98276: Support Color Bold
// We no longer used software palette for full color mode.
#define MAX_PALETTE	256
#if defined(LBP_2030) || defined(LIPS4C)
    short maxpal;
    RGBTRIPLE Palette[MAX_PALETTE];
#endif // LBP_2030 || LIPS4C
#endif // 0
    // #185185: Support RectFill
    LONG RectWidth;
    LONG RectHeight;
// #213732: 1200dpi support
    LONG masterunit;
// #228625: Stacker support
    char tray;          // Output tray: 0:auto, 1-N:binN,
                        //              100:default, 101:subtray
    char method;        // Output method: 0:JOB-OFFSET, 1:Staple, 2:Face up
    char staple;        // Staple mode: 0:TOPEFT, ... 9:BOTRIGHT
// #399861: Orientation does not changed.
    char source;        // Paper sources: 0:auto, 1:manual, 11:upper, 12:lower

// Support DRC
    DWORD dwBmpWidth;
    DWORD dwBmpHeight;

// ntbug9#98276: Support Color Bold
#if defined(LBP_2030) || defined(LIPS4C)
    // Remember current color to specify outline color.
    DWORD dwCurIndex, dwOutIndex;
    COLORVALUE CurColor, OutColor;
#endif // LBP_2030 || LIPS4C

// ntbug9#172276: CPCA support
    char fCPCA;        // Model which supported CPCA architecture.
// ntbug9#278671: Finisher !work
    char fCPCA2;       // for iR5000-6000
#define CPCA_PACKET_SIZE        20
    BYTE CPCAPKT[CPCA_PACKET_SIZE];     // CPCA Packet template buffer.
#define CPCA_BUFFER_SIZE        512
    BYTE CPCABuf[CPCA_BUFFER_SIZE];     // CPCA Packet cache buffer.
    DWORD CPCABcount;

// ntbug9#172276: Sorter support
    char sorttype;      // Sort method: 0:sort, 1:stack, 2:group
    WORD copies;

// ntbug9#293002: Features are different from H/W options.
    char startbin;      // Start bin

} LIPSPDEV, *PLIPSPDEV;

//***************************************************
// below the definitions of structure from PFM.H
//***************************************************

typedef struct
{
  SIZEL sizlExtent;
  POINTFX  pfxOrigin;
  POINTFX  pfxCharInc;
} BITMAPMETRICS, FAR * LPBITMAPMETRICS;
typedef BYTE FAR * LPDIBITS;

 typedef struct  {
    short	dfType;
    short	dfPoints;
    short	dfVertRes;
    short	dfHorizRes;
    short	dfAscent;
    short	dfInternalLeading;
    short	dfExternalLeading;
    BYTE	dfItalic;
    BYTE	dfUnderline;
    BYTE	dfStrikeOut;
    short	dfWeight;
    BYTE	dfCharSet;
    short	dfPixWidth;
    short	dfPixHeight;
    BYTE	dfPitchAndFamily;
    short	dfAvgWidth;
    short	dfMaxWidth;
    BYTE	dfFirstChar;
    BYTE	dfLastChar;
    BYTE	dfDefaultChar;
    BYTE	dfBreakChar;
    short	dfWidthBytes;
    DWORD	dfDevice;
    DWORD	dfFace;
    DWORD	dfBitsPointer;
    DWORD	dfBitsOffset;
    BYTE	dfReservedByte;
 } PFMHEADER, * PPFMHEADER, far * LPPFMHEADER;

//***************************************************
// Defines
//***************************************************
#define OVER_MODE      0
#define OR_MODE        1
#define AND_MODE       3
#define INIT          -1
#define FIXED          0
#define PROP           1
#define DEVICESETTING  0
#define VERT           2
#define HORZ           4

// #228625: Stacker support
#define METHOD_JOBOFFSET        1
#define METHOD_STAPLE           2
#define METHOD_FACEUP           3

// ntbug9#172276: Sorter support
#define SORTTYPE_SORT           1
#define SORTTYPE_STACK          2
// ntbug9#293002: Features are different from H/W options.
#define SORTTYPE_GROUP          3
#define SORTTYPE_STAPLE         4

// Support DRC
#ifdef LBP_2030
#define COLOR          1
#define COLOR_24BPP    2
#define COLOR_8BPP     4
#define MONOCHROME     0
#endif

typedef struct tagLIPSCmd {
	WORD	cbSize;
	PBYTE	pCmdStr;
} LIPSCmd, FAR * LPLIPSCmd;

#ifdef LIPS4_DRIVER

//***************************************************
// LIPS command lists
//***************************************************

LIPSCmd cmdPJLTOP1         = { 23, "\x1B%-12345X@PJL CJLMODE\x0D\x0A"};
LIPSCmd cmdPJLTOP2         = { 10, "@PJL JOB\x0D\x0A"};
// ntbug9#293002: Features are different from H/W options.
BYTE    cmdPJLBinSelect[]  = "@PJL SET BIN-SELECT = %s\r\n";
PBYTE   cmdBinType[] = {
    "AUTO",
    "OUTTRAY1",
    "OUTTRAY2",
    "BIN1",
    "BIN2",
    "BIN3",
};
// #213732: 1200dpi support
LIPSCmd cmdPJLTOP3SUPERFINE= { 33, "@PJL SET RESOLUTION = SUPERFINE\x0D\x0A"};
LIPSCmd cmdPJLTOP3FINE     = { 28, "@PJL SET RESOLUTION = FINE\x0D\x0A"};
LIPSCmd cmdPJLTOP3QUICK    = { 29, "@PJL SET RESOLUTION = QUICK\x0D\x0A"};
// #228625: Stacker support
LIPSCmd cmdPJLTOP31JOBOFF  = { 26, "@PJL SET JOB-OFFSET = ON\x0D\x0A"};
LIPSCmd cmdPJLTOP31STAPLE  = { 23, "@PJL SET STAPLE-MODE = "};
// ntbug9#293002: Features are different from H/W options.
BYTE    cmdPJLSorting[]   = "@PJL SET SORTING = %s\r\n";
PBYTE   cmdSortType[] = {
    "SORT",
    "GROUP",
    "STAPLE",
};
BYTE    cmdPJLStartBin[]   = "@PJL SET START-BIN = %d\r\n";
LIPSCmd cmdPJLTOP4         = { 33, "@PJL SET LPARAM : LIPS SW2 = ON\x0D\x0A"};
LIPSCmd cmdPJLTOP5         = { 28, "@PJL ENTER LANGUAGE = LIPS\x0D\x0A"};
LIPSCmd cmdPJLBOTTOM1      = { 42, "\x1B%-12345X@PJL SET LPARM : LIPS SW2 = OFF\x0D\x0A"};
LIPSCmd cmdPJLBOTTOM2      = { 19, "@PJL EOJ\x0D\x0A\x1B%-12345X"};

// If send this command, White Bold character can be printed. But I don't
// know what command means.
LIPSCmd cmdWhiteBold       = { 9, "}S1\x1E}RF4\x1E"};

#ifdef LIPS4C
LIPSCmd cmdBeginDoc4C      = { 16, "\x1B%@\x1BP41;360;1J\x1B\\"};
LIPSCmd cmdColorMode4C     = {  7, "\x1B[1\"p\x1B<"};
LIPSCmd cmdMonochrome4C    = {  7, "\x1B[0\"p\x1B<"};
LIPSCmd cmdPaperSource4C   = {  4, "\x1B[0q"};         // AutoSheetFeeder
LIPSCmd cmdBeginPicture4C  = {  7, "\x1E#\x1E!0!2"};
LIPSCmd cmdTextClip4C      = {  9, "\x1E}y!2\x1EU2\x1E"};
#endif // LIPS4C
#if defined(LIPS4C) || defined(LBP_2030)
LIPSCmd cmdEndDoc4C        = { 11, "%\x1E}p\x1E\x1BP0J\x1B\\"};
#endif

// #213732: 1200dpi support
// ntbug9#209691: Inappropriately command.
LIPSCmd cmdBeginDoc1200    = { 31, "\x1B%@\x1BP41;1200;1JMS NT40 4/1200\x1B\\"};
LIPSCmd cmdBeginDoc600     = { 29, "\x1B%@\x1BP41;600;1JMS NT40 4/600\x1B\\"};
LIPSCmd cmdBeginDoc3004    = { 29, "\x1B%@\x1BP41;300;1JMS NT40 4/300\x1B\\"};
LIPSCmd cmdBeginDoc300     = { 29, "\x1B%@\x1BP31;300;1JMS NT40 3/300\x1B\\"};
LIPSCmd cmdBeginDoc150     = { 29, "\x1B%@\x1BP31;300;1JMS NT40 3/150\x1B\\"};
LIPSCmd cmdSoftReset       = { 2, "\x1B<"};
LIPSCmd cmdEndPage         = { 6, "\x0C%\x1E}p\x1E"};
LIPSCmd cmdEndDoc4         = { 6, "\x1BP0J\x1B\\"};
// LIPSCmd cmdBeginPicture600 = { 9, "\x1E#\x1E!0\x65\x38\x1E$"};
// #213732: 1200dpi support
LIPSCmd cmdBeginPicture1200= { 8, "\x1E#\x1E!0AK0"};
#ifndef LBP_2030
LIPSCmd cmdBeginPicture600 = { 9, "\x1E#\x1E!0e8\x1E$"};
LIPSCmd cmdBeginPicture    = { 8, "\x1E#\x1E!0#\x1E$"};
#else
// ntbug9#209706: Incorrect cursor move unit command.
LIPSCmd cmdBeginPicture600 = { 7, "\x1E#\x1E!0e8"};
LIPSCmd cmdBeginPicture    = { 6, "\x1E#\x1E!0#"};
LIPSCmd cmdEnterPicture    = { 2, "\x1E$"};
#endif
// LIPSCmd cmdTextClip600     = {10, "\x1E}Y\x65\x381\x1EU2\x1E"};
// #213732: 1200dpi support
LIPSCmd cmdTextClip1200    = {11, "\x1E}YAK01\x1EU2\x1E"};
LIPSCmd cmdTextClip600     = {10, "\x1E}Ye81\x1EU2\x1E"};
LIPSCmd cmdTextClip        = { 9, "\x1E}Y#1\x1EU2\x1E"};
LIPSCmd cmdEndPicture      = { 5, "%\x1E}p\x1E"};

#ifdef LBP_2030
// ntbug9#209691: Inappropriately commands.
LIPSCmd cmdBeginDoc4_2030 = { 16, "\x1B%@\x1BP41;300;1J\x1B\\"};
LIPSCmd cmdColorMode    = {  5, "\x1B[1\"p"};
LIPSCmd cmdMonochrome   = {  5, "\x1B[0\"p"};
LIPSCmd cmdColorRGB     = {  4, "\x1E!11"};
LIPSCmd cmdColorIndex   = {  4, "\x1E!10"};
#endif

// N x Pages
LIPSCmd cmdx1Page          = { 5, "\x1B[;;o"};
// ntbug9#254925: CUSTOM papers.
BYTE cmdxnPageX[] = "\x1B[%d;;%do";

// Duplex
LIPSCmd cmdDuplexOff       = { 5, "\x1B[0#x"};
LIPSCmd cmdDuplexOn        = { 7, "\x1B[2;0#x"};
LIPSCmd cmdDupLong         = { 7, "\x1B[0;0#w"};
LIPSCmd cmdDupShort        = { 7, "\x1B[2;0#w"};

// #228625: Stacker support
LIPSCmd cmdStapleModes[]   = {
        { 7, "TOPLEFT" },       // 0
        { 9, "TOPCENTER" },     // 1
        { 8, "TOPRIGHT" },      // 2
        { 7, "MIDLEFT" },       // 3
        { 9, "MIDCENTER" },     // 4
        { 8, "MIDRIGHT" },      // 5
        { 7, "BOTLEFT" },       // 6
        { 9, "BOTCENTER" },     // 7
        { 8, "BOTRIGHT" },      // 8
};

// ntbug9#293002: Features are different from H/W options.
BYTE cmdPaperSource[] = "\x1B[%dq";

//***************************************************
// Command Call Back IDs
//***************************************************
#define OCD_BEGINDOC             1
#define OCD_BEGINDOC4          100 // to check LIPS4 printer (730)
// #213732: 1200dpi support
#define OCD_BEGINDOC4_1200     120
// ntbug9#172276: CPCA support
#define OCD_BEGINDOC4_1200_CPCA    121
// ntbug9#278671: Finisher !work
#define OCD_BEGINDOC4_1200_CPCA2   122
#ifdef LBP_2030
#define OCD_BEGINDOC4_2030     101 // to check LIPS4 printer (730)
#define OCD_ENDDOC4_2030       102
// ntbug9#172276: CPCA support
#define OCD_BEGINDOC4_2030_CPCA     104
#endif
#ifdef LIPS4C
#define OCD_BEGINDOC4C	       301
#endif // LIPS4C
#if defined(LIPS4C) || defined(LBP_2030)
#define OCD_BEGINPAGE4C        302 // #137462: 'X000' is printed.
#define OCD_ENDPAGE4C          303 // #137462: 'X000' is printed.
#define OCD_ENDDOC4C           304 // #137462: 'X000' is printed.
#endif
// #304284: Duplex isn't effective
#define OCD_STARTDOC           130

#define OCD_PORTRAIT             2
#define OCD_LANDSCAPE            3
#define OCD_PRN_DIRECTION        4
#define OCD_ENDPAGE              5
#define OCD_ENDDOC4             99
#define OCD_BEGINPAGE            6
#define RES_SENDBLOCK            7
// #213732: 1200dpi support
#define SELECT_RES_1200        108
#define SELECT_RES_600           8
#define SELECT_RES_300           9
#define SELECT_RES_150          10
#ifdef LIPS4C
#define SELECT_RES4C_360       308
#endif // LIPS4C
#define BEGIN_COMPRESS          11
#define BEGIN_COMPRESS_TIFF     103
#define END_COMPRESS            12
#define CUR_XM_ABS              15
#define CUR_YM_ABS              16
#define CUR_XY_ABS              17
#define CUR_CR                  18
#define OCD_BOLD_ON             20
#define OCD_BOLD_OFF            21
#define OCD_ITALIC_ON           22
#define OCD_ITALIC_OFF          23
#define OCD_UNDERLINE_ON        24
#define OCD_UNDERLINE_OFF       25
#define OCD_DOUBLEUNDERLINE_ON  26
#define OCD_DOUBLEUNDERLINE_OFF 27
#define OCD_STRIKETHRU_ON       28
#define OCD_STRIKETHRU_OFF      29
#define OCD_WHITE_TEXT_ON       30
#define OCD_WHITE_TEXT_OFF      31
#define OCD_SINGLE_BYTE         32
#define OCD_DOUBLE_BYTE         33
#define OCD_VERT_ON             34
#define OCD_VERT_OFF            35
#define CUR_XM_REL              36
#define CUR_YM_REL              37

#define OCD_DUPLEX_ON           13
#define OCD_DUPLEX_VERT         14
#define OCD_DUPLEX_HORZ         19

#define OCD_PAPERQUALITY_2XL    38
#define OCD_PAPERQUALITY_2XR    39
#define OCD_PAPERQUALITY_4XL    70
#define OCD_PAPERQUALITY_4XR    71

#define OCD_TEXTQUALITY_ON      72
#define OCD_TEXTQUALITY_OFF     73
#define OCD_PRINTDENSITY_ON     74
#define OCD_PRINTDENSITY_OFF    75
#define OCD_IMAGECONTROL_ON     76
#define OCD_IMAGECONTROL_OFF    77


#ifdef LBP_2030
#define OCD_SETCOLORMODE          200
#define OCD_SETCOLORMODE_24BPP    201
#define OCD_SETCOLORMODE_8BPP     202
#endif

#if 0
// ntbug9#98276: Support Color Bold
// We no longer used software palette for full color mode.
#if defined(LBP_2030) || defined(LIPS4C)
#define OCD_BEGINPALETTE	351
#define OCD_ENDPALETTE		352
// #195162: Color font incorrectly
#define OCD_DEFINEPALETTE	353
#define OCD_SELECTPALETTE	354
#endif
#endif // 0

// ntbug9#98276: Support Color Bold
#define OCD_SELECTBLACK         360
#define OCD_SELECTBLUE          361
#define OCD_SELECTGREEN         362
#define OCD_SELECTCYAN          363
#define OCD_SELECTRED           364
#define OCD_SELECTMAGENTA       365
#define OCD_SELECTYELLOW        366
#define OCD_SELECTWHITE         367
#define OCD_SELECTPALETTE       368
#define OCD_SELECTCOLOR         369

// #185185: Support RectFill
#define OCD_SETRECTWIDTH	401
#define OCD_SETRECTHEIGHT	402
#define OCD_RECTWHITEFILL	403
#define OCD_RECTBLACKFILL	404

// #228625: Stacker support
// ntbug9#293002: Features are different from H/W options.
// NOTE: Do not reorder between OCD_TOPLEFT and OCD_BOTRIGHT
#define OCD_TRAY_AUTO           410
#define OCD_TRAY_BIN1           411
#define OCD_TRAY_BIN2           412
#define OCD_TRAY_BIN3           413
#define OCD_TRAY_BIN4           414
#define OCD_TRAY_BIN5           415
#define OCD_TRAY_BIN6           416
#define OCD_TRAY_BIN7           417
#define OCD_TRAY_BIN8           418
#define OCD_TRAY_BIN9           419
#define OCD_TRAY_BIN10          420
#define OCD_TRAY_DEFAULT        428
#define OCD_TRAY_SUBTRAY        429

// NOTE: Do not reorder between OCD_TOPLEFT and OCD_BOTRIGHT
#define OCD_TOPLEFT             430
#define OCD_TOPCENTER           431
#define OCD_TOPRIGHT            432
#define OCD_MIDLEFT             433
#define OCD_MIDCENTER           434
#define OCD_MIDRIGHT            435
#define OCD_BOTLEFT             436
#define OCD_BOTCENTER           437
#define OCD_BOTRIGHT            438

// #399861: Orientation does not changed.
// ntbug9#293002: Features are different from H/W options.
// NOTE: DO NOT REORDER following values easier.
#define OCD_SOURCE_AUTO         450
#define OCD_SOURCE_CASSETTE1    451     // Upper
#define OCD_SOURCE_CASSETTE2    452     // Middle
#define OCD_SOURCE_CASSETTE3    453     // Lower
#define OCD_SOURCE_CASSETTE4    454
#define OCD_SOURCE_ENVELOPE     458
#define OCD_SOURCE_MANUAL       459

// ntbug9#172276: Sorter support
#define OCD_SORT                460
#define OCD_STACK               461
// ntbug9#293002: Features are different from H/W options.
#define OCD_GROUP               462
#define OCD_SORT_STAPLE         463     // special for MEDIO-B1

#define OCD_COPIES              465

// ntbug9#293002: Features are different from H/W options.
#define OCD_JOBOFFSET           470
#define OCD_STAPLE              471
#define OCD_FACEUP              472

// ntbug9#293002: Features are different from H/W options.
// NOTE: DO NOT REORDER following values easier.
#define OCD_STARTBIN0           480
#define OCD_STARTBIN1           481
#define OCD_STARTBIN2           482
#define OCD_STARTBIN3           483
#define OCD_STARTBIN4           484
#define OCD_STARTBIN5           485
#define OCD_STARTBIN6           486
#define OCD_STARTBIN7           487
#define OCD_STARTBIN8           488
#define OCD_STARTBIN9           489
#define OCD_STARTBIN10          490

// Support DRC
#define BEGIN_COMPRESS_DRC     510
#define OCD_SETBMPWIDTH        511
#define OCD_SETBMPHEIGHT       512

//*************************
// Paper Selection ID list
// \x1B[<Id>;;p
//*************************

// ntbug9#254925: CUSTOM papers.
BYTE cmdSelectPaper[] = "\x1B[%d;;p";
BYTE cmdSelectUnit4[] = "\x1B[?7;%d I";
BYTE cmdSelectUnit3[] = "\x1B[7 I";
BYTE cmdSelectCustom[] = "\x1B[%d;%d;%dp";

/* The definitions for Page Format command */
#define PAPER_DEFAULT           44 /* 14 : A4 210 x 297 mm */

#define PAPER_FIRST             40 /*  */
#define PAPER_PORT              40 /*  0 : Portlait */
#define PAPER_LAND              41 /*  1 : Landscape */
#define PAPER_A3                42 /* 12 : A3 297 x 420 mm */
#define PAPER_A3_LAND           43 /* 13 : A3 Landscape 420 x 297 mm */
#define PAPER_A4                44 /* 14 : A4 210 x 297 mm */
#define PAPER_A4_LAND           45 /* 15 : A4 Landscape 297 x 210 mm */
#define PAPER_A5                46 /* 16 : A5 148 x 210 mm */
#define PAPER_A5_LAND           47 /* 17 : A5 Landscape 210 x 148 mm */
#define PAPER_POSTCARD          48 /* 18 : Japanese Postcard 100 x 148 mm */
#define PAPER_POSTCARD_LAND     49 /* 19 : Japanese Postcard Landscape */
#define PAPER_B4                50 /* 24 : B4 (JIS) 257 x 364 mm */
#define PAPER_B4_LAND           51 /* 25 : B4 (JIS) Landscape 364 x 257 mm */
#define PAPER_B5                52 /* 26 : B5 (JIS) 182 x 257 mm */
#define PAPER_B5_LAND           53 /* 27 : B5 (JIS) Landscape 257 x 182 mm */
#define PAPER_B6                54 /* 28 : B6 (JIS) 128 x 182 mm */
#define PAPER_B6_LAND           55 /* 29 : B6 (JIS) Landscape 182 x 128 mm */
#define PAPER_LETTER            56 /* 30 : Letter 8 1/2 x 11 in */
#define PAPER_LETTER_LAND       57 /* 31 : Letter Landscape 11 x 8 1/2 in */
#define PAPER_LEGAL             58 /* 32 : Legal 8 1/2 x 14 in */
#define PAPER_LEGAL_LAND        59 /* 33 : Legal Landscape 14 x 8 1/2 in */
#define PAPER_TABLOID           60 /* 34 : Tabloid 11 x 17 in */
#define PAPER_TABLOID_LAND      61 /* 35 : Tabloid Landscape 17 x 11 in */
#define PAPER_EXECUTIVE         62 /* 40 : Executive 7 1/4 x 10 1/2 in */
#define PAPER_EXECUTIVE_LAND    63 /* 41 : Executive Landscape */
#define PAPER_JENV_YOU4         64 /* 50 : Japanese Envelope You #4 */
#define PAPER_JENV_YOU4_LAND    65 /* 51 : Japanese Envelope You #4 Landscape */
// #350602: Support new models for RC2
#define PAPER_DBL_POST          66 /* 20 : Japanese Double Postcard */
#define PAPER_DBL_POST_LAND     67 /* 21 : Japanese Double Postcard Landscape */
#define PAPER_JENV_YOU2         68 /* 52 : Japanese Envelope You #2 */
#define PAPER_JENV_YOU2_LAND    69 /* 53 : Japanese Envelope You #2 Landscape */
#define PAPER_LAST              69 /*  */

// Carousel
#define CAR_SET_PEN_COLOR       78

//Brush  50
#define BRUSH_SELECT            79
#define BRUSH_BYTE_2            80
#define BRUSH_END_1             81
#define BRUSH_NULL              82
#define BRUSH_SOLID             83
#define BRUSH_HOZI              84
#define BRUSH_VERT              85
#define BRUSH_FDIAG             86
#define BRUSH_BDIAG             87
#define BRUSH_CROSS             88
#define BRUSH_DIACROSS          89

#define PEN_NULL                90
#define PEN_SOLID               91
#define PEN_DASH                92
#define PEN_DOT                 93
#define PEN_DASHDOT             94
#define PEN_DASHDOTDOT          95

#define PEN_WIDTH               96

#define VECT_INIT               97

#define PENCOLOR_WHITE          0
#define PENCOLOR_BLACK          1

#define SET_PEN                 0
#define SET_BRUSH               1

#define VFLAG_PEN_NULL          0x01
#define VFLAG_BRUSH_NULL        0x02
#define VFLAG_INIT_DONE         0x04
#define VFLAG_VECT_MODE_ON      0x08

// ntbug9#254925: CUSTOM papers.
// All paper IDs
int PaperIDs[PAPER_LAST - PAPER_FIRST + 1] = {
{  0 }, /* PAPER_PORT           40 :  0 : Portlait */
{  1 }, /* PAPER_LAND           41 :  1 : Landscape */
{ 12 }, /* PAPER_A3             42 : 12 : A3 297 x 420 mm */
{ 13 }, /* PAPER_A3_LAND        43 : 13 : A3 Landscape 420 x 297 mm */
{ 14 }, /* PAPER_A4             44 : 14 : A4 210 x 297 mm */
{ 15 }, /* PAPER_A4_LAND        45 : 15 : A4 Landscape 297 x 210 mm */
{ 16 }, /* PAPER_A5             46 : 16 : A5 148 x 210 mm */
{ 17 }, /* PAPER_A5_LAND        47 : 17 : A5 Landscape 210 x 148 mm */
{ 18 }, /* PAPER_POSTCARD       48 : 18 : Japanese Postcard 100 x 148 mm */
{ 19 }, /* PAPER_POSTCARD_LAND  49 : 19 : Japanese Postcard Landscape */
{ 24 }, /* PAPER_B4             50 : 24 : B4 (JIS) 257 x 364 mm */
{ 25 }, /* PAPER_B4_LAND        51 : 25 : B4 (JIS) Landscape 364 x 257 mm */
{ 26 }, /* PAPER_B5             52 : 26 : B5 (JIS) 182 x 257 mm */
{ 27 }, /* PAPER_B5_LAND        53 : 27 : B5 (JIS) Landscape 257 x 182 mm */
{ 28 }, /* PAPER_B6             54 : 28 : B6 (JIS) 128 x 182 mm */
{ 29 }, /* PAPER_B6_LAND        55 : 29 : B6 (JIS) Landscape 182 x 128 mm */
{ 30 }, /* PAPER_LETTER         56 : 30 : Letter 8 1/2 x 11 in */
{ 31 }, /* PAPER_LETTER_LAND    57 : 31 : Letter Landscape 11 x 8 1/2 in */
{ 32 }, /* PAPER_LEGAL          58 : 32 : Legal 8 1/2 x 14 in */
{ 33 }, /* PAPER_LEGAL_LAND     59 : 33 : Legal Landscape 14 x 8 1/2 in */
{ 34 }, /* PAPER_TABLOID        60 : 34 : Tabloid 11 x 17 in */
{ 35 }, /* PAPER_TABLOID_LAND   61 : 35 : Tabloid Landscape 17 x 11 in */
{ 40 }, /* PAPER_EXECUTIVE      62 : 40 : Executive 7 1/4 x 10 1/2 in */
{ 41 }, /* PAPER_EXECUTIVE_LAND 63 : 41 : Executive Landscape */
{ 50 }, /* PAPER_JENV_YOU4      64 : 50 : Japanese Envelope You #4 */
{ 51 }, /* PAPER_JENV_YOU4_LAND 65 : 51 : JapaneseEnvelopeYou#4Landscape */
// #350602: Support new models for RC2
{ 20 }, /* PAPER_DBL_POST       66 : 20 : Japanese Double Postcard */
{ 21 }, /* PAPER_DBL_POST_LAND  67 : 21 : Japanese Dbl Postcard Landscape */
{ 52 }, /* PAPER_JENV_YOU2      68 : 52 : Japanese Envelope You #2 */
{ 53 }, /* PAPER_JENV_YOU2_LAND 69 : 53 : JapaneseEnvelopeYou#2Landscape */
};

//***************************************************
// All font of this driver must be described here
//***************************************************
LIPSCmd cmdFontList = { 2, "\x20<"}; // Font List Command
LIPSCmd cmdListSeparater = { 1, "\x1F"}; // Separater of FontList & Graphic set

// Prop DBCS support
// Courier support
#define MaxFontNumber   59
#define MaxFacename     32
// Font Index Structure
typedef struct tagFontNo{
	char	facename[MaxFacename];
	char	len;
} FontNo, FAR * LPFontNo;

// All phisical fonts
// {"Font name", length of name}
FontNo PFontList[MaxFontNumber+1] = {
{"Mincho-Medium-H", 15},             //  1
{"Mincho-Medium", 13},               //  2
{"Gothic-Medium-H", 15},             //  3
{"Gothic-Medium", 13},               //  4
{"RoundGothic-Light-H", 19},         //  5
{"RoundGothic-Light", 17},           //  6
{"Dutch-Roman", 11},                 //  7
{"Dutch-Bold", 10},                  //  8
{"Dutch-Italic", 12},                //  9
{"Dutch-BoldItalic", 16},            // 10
{"Swiss", 5},                        // 11
{"Swiss-Bold", 10},                  // 12
{"Swiss-Oblique", 13},               // 13
{"Swiss-BoldOblique", 17},           // 14
{"Symbol", 6},                       // 15
{"Kaisho-Medium-H", 15},             // 16
{"Kaisho-Medium", 13},               // 17
{"Kyokasho-Medium-H", 17},           // 18
{"Kyokasho-Medium", 15},             // 19
{"AvantGarde-Book", 15},             // 20
{"AvantGarde-Demi", 15},             // 21
{"AvantGarde-BookOblique", 22},      // 22
{"AvantGarde-DemiOblique", 22},      // 23
{"Bookman-Light", 13},               // 24
{"Bookman-Demi", 12},                // 25
{"Bookman-LightItalic", 19},         // 26
{"Bookman-DemiItalic", 18},          // 27
{"ZapfChancery-MediumItalic", 25},   // 28
{"ZapfDingbats", 12},                // 29
{"CenturySchlbk-Roman", 19},         // 30
{"CenturySchlbk-Bold", 18},          // 31
{"CenturySchlbk-Italic", 20},        // 32
{"CenturySchlbk-BoldItalic", 24},    // 33
{"Swiss-Narrow", 12},                // 34
{"Swiss-Narrow-Bold", 17},           // 35
{"Swiss-Narrow-Oblique", 20},        // 36
{"Swiss-Narrow-BoldOblique", 24},    // 37
{"ZapfCalligraphic-Roman", 22},      // 38
{"ZapfCalligraphic-Bold", 21},       // 39
{"ZapfCalligraphic-Italic", 23},     // 40
{"ZapfCalligraphic-BoldItalic", 27}, // 41
{"Mincho-Ultra-Bold-H-YM", 22},      // 42 TypeBank font
{"Mincho-Ultra-Bold-YM", 20},        // 43 TypeBank font
{"Gothic-Bold-H-YO", 16},            // 44 TypeBank font
{"Gothic-Bold-YO", 14},              // 45 TypeBank font
{"Gyosho-Medium-H", 15},             // 46
{"Gyosho-Medium", 13},               // 47
{"Mincho-UltraBold-H", 18},          // 48
{"Mincho-UltraBold", 16},            // 49
{"Gothic-UltraBold-H", 18},          // 50
{"Gothic-UltraBold", 16},            // 51
// Prop DBCS support
{"Mincho-Medium-HPS", 17},           // 52
{"Mincho-Medium-PS", 16},            // 53
{"Gothic-Medium-HPS", 17},           // 54
{"Gothic-Medium-PS", 16},            // 55
// Courier support
{"Ncourier", 8},                     // 56
{"Ncourier-Bold", 13},               // 57
{"Ncourier-Italic", 15},             // 58
{"Ncourier-BoldItalic", 19},         // 59
{""}                                 // 60
};

//***************************************************
// All Graphic Set of this driver must be described here
//***************************************************
LIPSCmd cmdGrxList = { 2, "\x20;"}; // Graphics Set List Command

#define MaxGrxSetNumber   12
#define MaxGrxSetName     5
// GrxSet Index Structure
typedef struct tagGrxSet{
	char	grxsetname[MaxGrxSetName];
	char	len; // length of Graphic set string
} GrxSetNo, FAR * LPGrxSetNo;

// {"Graphics set name", length of name}
#ifdef LIPS4
GrxSetNo GrxSetL4[MaxGrxSetNumber+1] = {
{"1J", 2},       //  1 - ISO_JPN
{"1I", 2},       //  2 -  KATA
{"2B", 2},       //  3 - J83
{"<B", 2},       //  4 - DBCS vertical character set
{"1! &1", 5}, //  5 - Win31L (1061)
{"1! &2", 5}, //  6 - Win31R (1062)
{"1\x22!!0", 5}, //  7 - 1"!!0  SYML (2110)
{"1\x22!!1", 5}, //  8 - 1"!!1  SYMR (2111)
{"1\x22!!2", 5}, //  9 - 1"!!2  DNGL (2112)
{"1\x22!!3", 5}, // 10 - 1"!!3  DNGR (2113)
{"2!',2", 5},    // 11 -        W90  (17C2)
{"<!',2", 5},    // 12 -        W90  (17C2) - for vertical
{""}          // 13
};
#endif // LIPS4
#ifdef LIPS4C
// {"Graphics set name", length of name}
GrxSetNo GrxSetL4C[MaxGrxSetNumber+1] = {
{"1J", 2},       //  1 - ISO_JPN
{"1I", 2},       //  2 -  KATA
{"2B", 2},       //  3 - J83
{"<B", 2},       //  4 - DBCS vertical character set
{"1\x22!$2", 5}, //  5 - 1"!$2  PSL (2142)
{"1\x27 4", 4},  //  6 - 1' 4  ?? (704) ANSI Windows char set, User defined
{"1\x22!!0", 5}, //  7 - 1"!!0  SYML (2110)
{"1\x22!!1", 5}, //  8 - 1"!!1  SYMR (2111)
{"1\x22!!2", 5}, //  9 - 1"!!2  DNGL (2112)
{"1\x22!!3", 5}, // 10 - 1"!!3  DNGR (2113)
{"2!',2", 5},    // 11 -        W90  (17C2)
{"<!',2", 5},    // 12 -        W90  (17C2) - for vertical
{""}          // 13
};
#endif // LIPS4C
// LIPS3
GrxSetNo GrxSetL3[MaxGrxSetNumber+1] = {
{"1J", 2},       //  1 - ISO_JPN
{"1I", 2},       //  2 -  KATA
{"2B", 2},       //  3 - J83
{"<B", 2},       //  4 - DBCS vertical character set
{"1\x27\x24\x32", 4},  //  5 - IBML (742)
{"1\x27\x20\x34", 4},  //  6 - IBM819 (704 - user defined)
{"1\x22!!0", 5}, //  7 - 1"!!0  SYML (2110)
{"1\x22!!1", 5}, //  8 - 1"!!1  SYMR (2111)
{"1\x22!!2", 5}, //  9 - 1"!!2  DNGL (2112)
{"1\x22!!3", 5}, // 10 - 1"!!3  DNGR (2113)
{"2!',2", 5},    // 11 -        W90  (17C2)
{"<!',2", 5},    // 12 -        W90  (17C2) - for vertical
{""}          // 13
};

//***************************************************
// LIPS font table
//***************************************************

// All logical fonts
/*
                   Font Index  Graphic Set Index
LFontList[Logical Font ID(PFM ID)].fontgrxids[GO,G1,G2,G3(font),G0,G1,G2,G3]
*/

// Prop DBCS support
// Courier support
#define   MaxLogicalFont   55
#define   FirstLogicalFont 101

// {font id x 4, grx id x 4}
// the index of array must be related with FontID in PFM file
// the index of array = FontID in PFM - 101
uchar LFontList[MaxLogicalFont+1][8] = {
{ 1, 1, 2, 2,  1,2,3,4},  //  1-"" (Mincho), "Mincho-Medium"
                          //  1-"W3" (HeiseiMinchoW7)
{ 3, 3, 4, 4,  1,2,3,4},  //  2-"" (Gothic), "Gothic-Medium"
                          //  2-"W5" (HeiseiGothicW9)
{ 5, 5, 6, 6,  1,2,3,4},  //  3-"" (RoundGothic), "RoundGothic-Medium"
{16,16,17,17,  1,2,3,4},  //  4-"" (Kaisho), "Kaisho-Medium"
{18,18,19,19,  1,2,3,4},  //  5-"" (Kyokasho), "Kyokasho-Medium"
{11, 3, 4, 4,  1,2,3,4},  //  6-"" (SUISU), "Swiss-Roman"
{12, 3, 4, 4,  1,2,3,4},  //  7-"" (SUISU), "Swiss-Bold"
{13, 3, 4, 4,  1,2,3,4},  //  8-"" (SUISU), "Swiss-Oblique"
{14, 3, 4, 4,  1,2,3,4},  //  9-"" (SUISU), "Swiss-BoldOblique"
{ 7, 1, 2, 2,  1,2,3,4},  // 10-"" (DACCHI), "Dutch-Roman"
{ 8, 1, 2, 2,  1,2,3,4},  // 11-"" (DACCHI), "Dutch-Bold"
{ 9, 1, 2, 2,  1,2,3,4},  // 12-"" (DACCHI), "Dutch-Italic"
{10, 1, 2, 2,  1,2,3,4},  // 13-"" (DACCHI), "Dutch-BoldItalic"
{11,11, 2, 2,  5,6,3,4},  // 14-"Swiss", "Swiss"
{12,12, 2, 2,  5,6,3,4},  // 15-"Swiss", "Swiss-Bold"
{13,13, 2, 2,  5,6,3,4},  // 16-"Swiss", "Swiss-Oblique"
{14,14, 2, 2,  5,6,3,4},  // 17-"Swiss", "Swiss-BoldOblique"
{ 7, 7, 2, 2,  5,6,3,4},  // 18-"Dutch", "Dutch-Roman"
{ 8, 8, 2, 2,  5,6,3,4},  // 19-"Dutch", "Dutch-Bold"
{ 9, 9, 2, 2,  5,6,3,4},  // 20-"Dutch", "Dutch-Italic"
{10,10, 2, 2,  5,6,3,4},  // 21-"Dutch", "Dutch-BoldItalic"
{15,15, 2, 2,  7,8,3,4},  // 22-"Symbol", "Symbol"
{20,20, 2, 2,  5,6,3,4},  // 23-"AvantGarde", "AvantGarde-Book"
{21,21, 2, 2,  5,6,3,4},  // 24-"AvantGarde", "AvantGarde-Demi"
{22,22, 2, 2,  5,6,3,4},  // 25-"AvantGarde", "AvantGarde-BookOblique"
{23,23, 2, 2,  5,6,3,4},  // 26-"AvantGarde", "AvantGarde-DemiOblique"
{24,24, 2, 2,  5,6,3,4},  // 27-"Bookman", "Bookman-Light"
{25,25, 2, 2,  5,6,3,4},  // 28-"Bookman", "Bookman-Demi"
{26,26, 2, 2,  5,6,3,4},  // 29-"Bookman", "Bookman-LightItalic"
{27,27, 2, 2,  5,6,3,4},  // 30-"Bookman", "Bookman-DemiItalic"
{28,28, 2, 2,  5,6,3,4},  // 31-"ZapfChancery", "ZapfChancery-MediumItalic"
{29,29, 2, 2,  9,10,3,4}, // 32-"ZapfDingbats", "ZapfDingbats"
{30,30, 2, 2,  5,6,3,4},  // 33-"CenturySchlbk", "CenturySchlbk-Roman"
{31,31, 2, 2,  5,6,3,4},  // 34-"CenturySchlbk", "CenturySchlbk-Bold"
{32,32, 2, 2,  5,6,3,4},  // 35-"CenturySchlbk", "CenturySchlbk-Italic"
{33,33, 2, 2,  5,6,3,4},  // 36-"CenturySchlbk", "CenturySchlbk-BoldItalic"
{34,34, 2, 2,  5,6,3,4},  // 37-"Swiss-Narrow", "Swiss-Narrow"
{35,35, 2, 2,  5,6,3,4},  // 38-"Swiss-Narrow", "Swiss-Narrow-Bold"
{36,36, 2, 2,  5,6,3,4},  // 39-"Swiss-Narrow", "Swiss-Narrow-Oblique"
{37,37, 2, 2,  5,6,3,4},  // 40-"Swiss-Narrow", "Swiss-Narrow-BoldOblique"
{38,38, 2, 2,  5,6,3,4},  // 41-"ZapfCalligraphic", "ZapfCalligraphic-Roman"
{39,39, 2, 2,  5,6,3,4},  // 42-"ZapfCalligraphic", "ZapfCalligraphic-Bold"
{40,40, 2, 2,  5,6,3,4},  // 43-"ZapfCalligraphic", "ZapfCalligraphic-Italic"
{41,41, 2, 2,  5,6,3,4},  // 44-"ZapfCalligraphic", "ZapfCalligraphic-BoldItalic"
{42,42,43,43,  1,2,3,4},  // 45-"H" (TypeBankMincho), "Mincho-Ultra-Bold"
{44,44,45,45,  1,2,3,4},  // 46-"B" (TypeBankGothic), "Gothic-Bold-YO"
{46,46,47,47,  1,2,3,4},  // 47-"s" (Gyosho), "Gyosho-Medium"

{48,48,49,49,  1,2,3,4},  // 48-"W7" (HeiseiMinchoW7), "Mincho-UltraBold"
{50,50,51,51,  1,2,3,4},  // 49-"W9" (HeiseiGothicW9), "Gothic-UltraBold"
// Prop DBCS support
{52,52,53,53,  1,2,11,12},// 50-" PS" (Mincho-PS), "Mincho-Medium-PS"
{54,54,55,55,  1,2,11,12},// 51-" PS" (Gothic-PS), "Gothic-Medium-PS"
// Courier support
{56,56, 2, 2,  5,6,3,4},  // 52-"Courier", "NCourier"
{57,57, 2, 2,  5,6,3,4},  // 53-"Courier", "NCourier-Bold"
{58,58, 2, 2,  5,6,3,4},  // 54-"Courier", "NCourier-Italic"
{59,59, 2, 2,  5,6,3,4},  // 55-"Courier", "NCourier-BoldItalic"
{0,0,0,0,0,0,0,0}    // 56
};

// Vertical font resource IDs
// They are used in OutputChar() to check with if a font is vertical
// face or not

#define RcidIsDBCSFont(k) ((k) >= 32 && (k) <= 63)
#define RcidIsDBCSVertFont(k) \
((k) == 41 || (k) == 43 || (k) == 45 || (k) == 47 || (k) == 49 ||\
(k) == 51 || (k) == 53 || (k) == 55 || (k) == 57 || (k) == 59 ||\
(k) == 61 || (k) == 63)

// #ifndef LIPS4

//***********************************************************
// Graphic Set registration data
// To keep the conpatibility against Canon's 3.1 driver 
//***********************************************************
// "\x1b[743;1796;30;0;32;127;.\x7dIBM819"
// '\x00'
//

LIPSCmd cmdGSETREGST =	{ 31, "\x1b[743;1796;30;0;32;127;.\x7dIBM819"};

// Download SBCS physical device fontface from Dutch-Roman(7)
// ZapfCalligraphic-BoldItalic(41)
// Between the fontfaces, put \x00, and at the end of face, 

#define REGDataSize  193

// put \x00 x 2
// and the following data
uchar GrxData[193+1] = {
0x00,0x00,
0x01,0x00,0x7d,0x00,0x2e,0x00,0x2f,
0x00,0x80,0x00,0x2c,0x00,0x13,0x00,0x35,0x00, // x9
0xc4,0x00,0xfc,0x00,0x94,0x00,0x21,0x00,0xc7,
0x00,0x24,0x00,0xfd,0x03,0x05,0x00,0x2b,0x00,
0x25,0x00,0xd0,0x00,0xd1,0x00,0xc2,0x00,0xa4,
0x00,0x39,0x00,0x85,0x00,0x8f,0x00,0xcf,0x00,
0x9a,0x00,0x22,0x00,0x46,0x00,0x44,0x00,0x48,
0x00,0x88,0x00,0xa8,0x00,0xa5,0x00,0xa6,0x00,
0xaa,0x00,0xa7,0x00,0xa9,0x00,0x93,0x00,0xab,
0x00,0xaf,0x00,0xac,0x00,0xad,0x00,0xae,0x00,
0xb3,0x00,0xb0,0x00,0xb1,0x00,0xb2,0x00,0x95,
0x00,0xb4,0x00,0xb8,0x00,0xb5,0x00,0xb6,0x00,
0xb9,0x00,0xb7,0x00,0x26,0x00,0x98,0x00,0xbe,
0x00,0xbb,0x00,0xbc,0x00,0xbd,0x00,0xc1,0x00,
0x96,0x00,0xa2,0x00,0xda,0x00,0xd7,0x00,0xd8,
0x00,0xdc,0x00,0xd9,0x00,0xdb,0x00,0x9b,0x00,
0xdd,0x00,0xe1,0x00,0xde,0x00,0xdf,0x00,0xe0,
0x00,0xe5,0x00,0xe2,0x00,0xe3,0x00,0xe4,0x00,
0xa3,0x00,0xe6,0x00,0xea,0x00,0xe7,0x00,0xe8,
0x00,0xeb,0x00,0xe9,0x00,0x27,0x00,0xa0,0x00,
0xf0,0x00,0xed,0x00,0xee,0x00,0xef,0x00,0xf3,
0x00,0x9e,0x00,0xf1};

#ifdef LIPS4C

LIPSCmd cmdGSETREGST4C =   { 30, "\x1b[807;1796;30;0;0;127;.\x7dIBM819"};

#define REGDataSize4C  257

// put \x00 x 2
// and the following data
uchar GrxData4C[257+1] = {
0x00,0x00,
0x01,0x00,0x01,0x00,0x86,
0x00,0x7F,0x00,0x87,0x00,0x14,0x00,0x37,
0x00,0x38,0x00,0x89,0x00,0x36,0x00,0xBA,
0x00,0x1F,0x00,0x99,0x00,0x01,0x00,0x01,
0x00,0x01,0x00,0x01,0x00,0x15,0x00,0x16,
0x00,0x17,0x00,0x18,0x00,0x04,0x00,0x84,
0x00,0x0E,0x00,0xF8,0x00,0xC6,0x00,0xEC,
0x00,0x20,0x00,0xA1,0x00,0x01,0x00,0x01,
0x00,0xBF,0x00,0x01,0x00,0x7D,0x00,0x2E,
0x00,0x2F,0x00,0x80,0x00,0x2C,0x00,0xC8,
0x00,0x35,0x00,0xC4,0x00,0xFC,0x00,0x94,
0x00,0x21,0x00,0xC7,0x00,0x0F,0x00,0xFD,
0x03,0x05,0x00,0x2B,0x00,0x25,0x00,0xD0,
0x00,0xD1,0x00,0x09,0x00,0xA4,0x00,0x39,
0x00,0x85,0x00,0x8F,0x00,0xCF,0x00,0x9A,
0x00,0x22,0x00,0x46,0x00,0x44,0x00,0x48,
0x00,0x88,0x00,0xA8,0x00,0xA5,0x00,0xA6,
0x00,0xAA,0x00,0xA7,0x00,0xA9,0x00,0x93,
0x00,0xAB,0x00,0xAF,0x00,0xAC,0x00,0xAD,
0x00,0xAE,0x00,0xB3,0x00,0xB0,0x00,0xB1,
0x00,0xB2,0x00,0x95,0x00,0xB4,0x00,0xB8,
0x00,0xB5,0x00,0xB6,0x00,0xB9,0x00,0xB7,
0x00,0x26,0x00,0x98,0x00,0xBE,0x00,0xBB,
0x00,0xBC,0x00,0xBD,0x00,0xC1,0x00,0x96,
0x00,0xA2,0x00,0xDA,0x00,0xD7,0x00,0xD8,
0x00,0xDC,0x00,0xD9,0x00,0xDB,0x00,0x9B,
0x00,0xDD,0x00,0xE1,0x00,0xDE,0x00,0xDF,
0x00,0xE0,0x00,0xE5,0x00,0xE2,0x00,0xE3,
0x00,0xE4,0x00,0xA3,0x00,0xE6,0x00,0xEA,
0x00,0xE7,0x00,0xE8,0x00,0xEB,0x00,0xE9,
0x00,0x27,0x00,0xA0,0x00,0xF0,0x00,0xED,
0x00,0xEE,0x00,0xEF,0x00,0xF3,0x00,0x9E,
0x00,0xF1};

#endif // LIPS4C

// #endif // !LIPS4

//***************************************************
// All SBCS(ANSI) font for the geristration of Graphic set
//***************************************************

#define MaxSBCSNumber   30
// #define MaxFacename     32
// Font Index Structure
// typedef struct tagFontNo{
// 	char	facename[MaxFacename];
// 	char	len;
// } FontNo, FAR * LPFontNo;

// All SBCS(ANSI) phisical fonts
FontNo PSBCSList[MaxFontNumber+1] = {
{"Dutch-Roman", 11},                 //  1
{"Dutch-Bold", 10},                  //  2
{"Dutch-Italic", 12},                //  3
{"Dutch-BoldItalic", 16},            //  4
{"Swiss", 5},                       //  5
{"Swiss-Bold", 10},                  //  6
{"Swiss-Oblique", 13},               //  7
{"Swiss-BoldOblique", 17},           //  8
{"AvantGarde-Book", 15},             //  9
{"AvantGarde-Demi", 15},             // 10
{"AvantGarde-BookOblique", 22},      // 11
{"AvantGarde-DemiOblique", 22},      // 12
{"Bookman-Light", 13},               // 13
{"Bookman-Demi", 12},                // 14
{"Bookman-LightItalic", 19},         // 15
{"Bookman-DemiItalic", 18},          // 16
{"ZapfChancery-MediumItalic", 25},   // 17
{"ZapfDingbats", 12},                // 18
{"CenturySchlbk-Roman", 19},         // 19
{"CenturySchlbk-Bold", 18},          // 20
{"CenturySchlbk-Italic", 20},        // 21
{"CenturySchlbk-BoldItalic", 24},    // 22
{"Swiss-Narrow", 12},                // 23
{"Swiss-Narrow-Bold", 17},           // 24
{"Swiss-Narrow-Oblique", 20},        // 25
{"Swiss-Narrow-BoldOblique", 24},    // 26
{"ZapfCalligraphic-Roman", 22},      // 27
{"ZapfCalligraphic-Bold", 21},       // 28
{"ZapfCalligraphic-Italic", 23},     // 29
{"ZapfCalligraphic-BoldItalic", 27}, // 30
{""}                             // 00
};

// Enter Vector mode
LIPSCmd cmdBeginVDM =	{ 5, "\x1b[0&}"};
#if defined(LBP_2030) || defined(LIPS4C)
LIPSCmd cmdEndVDM =	{ 3, "}p\x1E"};
LIPSCmd cmdBeginPalette = { 3, "^00"};
LIPSCmd cmdEndPalette =	{ 1, "\x1E"};
#endif // LBP_2030 || LIPS4C


// VectorMode commands
static char CMD_SET_PEN_WIDTH[] = "F1%s\x1E";

static char CMD_SET_PEN_TYPE[] = "E1%d\x1E";
static char CMD_SET_PEN_STYLE[]  =  "}G%d%c\x1E";
static char CMD_SET_BRUSH_STYLE[] =  "I%c%c\x1E";

//                         NULL   SOLID HOZI  VERT  FDIAG BDIAG CROSS DIACROSS
static char BrushType[8] = {0x30, 0x31, 0x25, 0x24, 0x23, 0x22, 0x27, 0x26};

void NEAR PASCAL SetPenAndBrush(PDEVOBJ , WORD);

#endif	// LIPS4_DRIVER

// Device font height and font width values calculated
// form the IFIMETRICS field values.  Must be the same way
// what Unidrv is doing to calculate stdandard variables.
// (Please check.)

#define FH_IFI(p) ((p)->fwdUnitsPerEm)
#define FW_IFI(p) ((p)->fwdAveCharWidth)

// ntbug9#172276: CPCA support

// External functions
VOID CPCAInit(PLIPSPDEV pOEM);
VOID CPCAStart(PDEVOBJ pdevobj);
VOID CPCAEnd(PDEVOBJ pdevobj, BOOL fColor);

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"

// ntbug9#172276: CPCA support
extern "C" {
BOOL APIENTRY
OEMWritePrinter(
    PDEVOBJ     pdevobj,
    PVOID       pBuf,
    DWORD       cbBuffer,
    PDWORD      pcbWritten);
}

////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    // DbgPrint(DLLTEXT("IOemCB: QueryInterface entry\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ; 
    }
// ntbug9#172276: CPCA support
    else if (iid == IID_IPrintOemUni2)
    {
        *ppv = static_cast<IPrintOemUni2*>(this) ;
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IPrintOemUni2.\n")) ; 
    }
    else
    {
        *ppv = NULL ;
        // DbgPrint(DLLTEXT("IOemCB:Return NULL.\n")) ; 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    // DbgPrint(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release() 
{
    // DbgPrint(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    // DbgPrint(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    // DbgPrint(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    // DbgPrint(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    // DbgPrint(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
//  return E_NOTIMPL;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
//  return E_NOTIMPL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    // DbgPrint(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    OEMDisablePDEV(pdevobj);
    return S_OK;
//  return E_NOTIMPL;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::GetInfo() entry.\r\n"));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    // DbgPrint(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    // DbgPrint(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
// Support DRC
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'D':
#if 0
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;
#endif
                else if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'E':
#if 0
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
#if 0
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
#if 0
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'I':
#if 0
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'M':
#if 0
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
#if 0
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
#endif
                break;
// ntbug9#172276: CPCA support
            case (WCHAR)'W':
                if (!strcmp(pstrWritePrinter, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        // DbgPrint(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        // DbgPrint(__TEXT("NOT supported\r\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    // DbgPrint(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    // DbgPrint(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    // if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
    //                     dwCallbackID, pIPParams))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    // DbgPrint(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));
    // pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuf, dwLen, &dwResult);
    
    // if (dwResult == dwLen)
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    // return E_NOTIMPL;
// Support DRC
    *piResult = OEMCompression(pdevobj, pInBuf, pOutBuf, dwInLen, dwOutLen);
    if (*piResult > 0)
        return S_OK;
    else
        return E_FAIL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    // DbgPrint(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    // DbgPrint(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));
    //*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));
    //*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));
    //*pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    // DbgPrint(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));
    OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    return S_OK;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    // DbgPrint(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    return S_OK;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    // DbgPrint(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}

// ntbug9#172276: CPCA support
LONG __stdcall IOemCB::WritePrinter(
    PDEVOBJ     pdevobj,
    PVOID       pBuf,
    DWORD       cbBuffer,
    DWORD       *pcbWritten)
{
    // DbgPrint(DLLTEXT("IOemCB::WritePrinter() entry.\r\n"));
    // return E_NOTIMPL;
    if (OEMWritePrinter(pdevobj, pBuf, cbBuffer, pcbWritten))
        return S_OK;
    else
        return S_FALSE;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //// DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //// DbgPrint(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID) ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID) ;
}
#endif

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\spool.c ===
/*
 *	spool.c - WritePrinter hook.
 *
 *	Need to be manipulate the spooler data for Canon CPCA architecture.
 */

#include "pdev.h"

// ntbug9#172276: CPCA support

#define MAX_CPCA_PACKET_SIZE    4096    // Must be <= 64KB-1

// CPCA Operation codes
#define CPCA_JobStart           0x0011
#define CPCA_JobEnd             0x0013
#define CPCA_BinderStart        0x0014
#define CPCA_SetBinder          0x0015
#define CPCA_BinderEnd          0x0016
#define CPCA_DocumentStart      0x0017
#define CPCA_SetDocument        0x0018
#define CPCA_DocumentEnd        0x0019
#define CPCA_Send               0x001A
#define CPCA_ExecutiveMethod    0x001D

// CPCA Flags
#define F_Cont                  0x02

// CPCA Attributes
#define ATT_DOCFORMAT           0x002E
#define     DOCFORMAT_LIPS          0x27
#define ATT_RESOLUTION          0x003A
#define     RESOLUTION_QUICK        0x05
#define     RESOLUTION_FINE         0x06
#define     RESOLUTION_SUPERFINE    0x07
#define ATT_COPIES              0x07D7
#define ATT_OUTPUT              0x07D8
#define     OUTPUT_NO_COLLATE       0x08
#define     OUTPUT_COLLATE          0x0B
#define     OUTPUT_GROUP_COLLATE    0x0F
#define ATT_OUTPUTBIN           0x07D9
#define     OUTPUTBIN_FACEUP        0x01
#define     OUTPUTBIN_FACEDOWN      0x02
#define     OUTPUTBIN_SORT          0x11
#define     OUTPUTBIN_NUMBER        0x12
#define     OUTPUTBIN_STACK         0x15
#define ATT_FINISHING           0x07DA
#define     FINISHING_STAPLE        0x0C
#define     FINISHING_COUNT_1       0x66
#define     FINISHING_COUNT_2       0x67
#define ATT_OUTPUTPARTITION     0x084A
#define     OUTPART_JOBOFFSET       0x01
#define     OUTPART_NONE            0x04
#define ATT_OUTPUTFACE          0x084B
#define     OUTPUTFACE_FACEUP       0x01
#define     OUTPUTFACE_FACEDOWN     0x02
#define     OUTPUTFACE_NONE         0x03

static WORD     wStapleModes[] = {
        0x00CA,         // top_left
        0x00D5,         // top
        0x00CC,         // top_right
        0x00D3,         // left
        0x00EE,         // center (NOT USED)
        0x00D4,         // right
        0x00CB,         // bottom_left
        0x00D6,         // bottom
        0x00CD,         // bottom_right
};

extern LIPSCmd  cmdEndDoc4;
extern LIPSCmd  cmdEndDoc4C;

/*
 *	FlushCPCABuffer
 */
static BOOL
FlushCPCABuffer(PDEVOBJ pdevobj, PLIPSPDEV pOEM)
{
    DWORD               dwCount;

    if (pOEM->CPCABcount == 0)
        return TRUE;

    if (!WritePrinter(pdevobj->hPrinter, pOEM->CPCABuf, pOEM->CPCABcount,
        &dwCount) || dwCount != pOEM->CPCABcount)
        return FALSE;
    pOEM->CPCABcount = 0;

    return TRUE;
}

/*
 *      SendCPCAPacket
 */
static BOOL
SendCPCAPacket(
    PDEVOBJ pdevobj,
    WORD wCmd,
    BYTE flags,
    PBYTE pParams,
    WORD nParams)
{
    PLIPSPDEV           pOEM;
    PBYTE               pBuf;
    DWORD               dwCount;

    pOEM = (PLIPSPDEV)pdevobj->pdevOEM;
    dwCount = pOEM->CPCABcount;
    if (dwCount + CPCA_PACKET_SIZE + nParams > CPCA_BUFFER_SIZE) {
        if (!FlushCPCABuffer(pdevobj, pOEM))
            return FALSE;
    }

    pBuf = pOEM->CPCAPKT;
    pBuf[3] = flags;
    pBuf[4] = HIBYTE(wCmd);
    pBuf[5] = LOBYTE(wCmd);
    pBuf[8] = HIBYTE(nParams);
    pBuf[9] = LOBYTE(nParams);

    CopyMemory(&pOEM->CPCABuf[dwCount], pOEM->CPCAPKT, CPCA_PACKET_SIZE);
    dwCount += CPCA_PACKET_SIZE;
    if (nParams) {
        CopyMemory(&pOEM->CPCABuf[dwCount], pParams, nParams);
        dwCount += nParams;
    }
    pOEM->CPCABcount = dwCount;

    return TRUE;
}

/*
 *      CPCAInit
 */
VOID
CPCAInit(PLIPSPDEV pOEM)
{
    pOEM->CPCAPKT[0] = 0xCD;    // Header ID
    pOEM->CPCAPKT[1] = 0xCA;
    pOEM->CPCAPKT[2] = 0x10;    // Version
    pOEM->CPCABcount = 0;
}

/*
 *      CPCAStart
 */
VOID
CPCAStart(PDEVOBJ pdevobj)
{
    PLIPSPDEV       pOEM = (PLIPSPDEV)pdevobj->pdevOEM;
    WORD            wTemp;
    BYTE            param[13];

    ZeroMemory(param, sizeof param);
    param[4] = 0x01;
    (VOID)SendCPCAPacket(pdevobj, CPCA_JobStart, 0, param, 13);

    // ZeroMemory(param, 4);
    (VOID)SendCPCAPacket(pdevobj, CPCA_BinderStart, 0, param, 4);

    param[0] = HIBYTE(ATT_COPIES);
    param[1] = LOBYTE(ATT_COPIES);
    if (pOEM->sorttype == SORTTYPE_SORT) {
        param[2] = HIBYTE(pOEM->copies);
        param[3] = LOBYTE(pOEM->copies);
    } else {
        param[2] = 0x00;
        param[3] = 0x01;
    }
    (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 4);

    // ntbug9#278671: Finisher !work
    // ntbug9#293002: Features are different from H/W options.
    if (pOEM->fCPCA2) {
        param[0] = HIBYTE(ATT_OUTPUT);
        param[1] = LOBYTE(ATT_OUTPUT);
        param[2] = OUTPUT_COLLATE;
        (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 3);
    }

    // ntbug9#203340: Output tray could not selected correctly.
    // ntbug9#293002: Features are different from H/W options.
    param[0] = HIBYTE(ATT_OUTPUTBIN);
    param[1] = LOBYTE(ATT_OUTPUTBIN);
    if (pOEM->tray == INIT || pOEM->tray == 100) {
        param[2] = OUTPUTBIN_FACEDOWN;
        ZeroMemory(&param[3], 4);
    } else if (pOEM->tray == 0) {
        param[2] = OUTPUTBIN_STACK;
        ZeroMemory(&param[3], 4);
    } else if (pOEM->tray == 101) {
        param[2] = OUTPUTBIN_FACEUP;
        ZeroMemory(&param[3], 4);
    } else {
        param[2] = OUTPUTBIN_NUMBER;
        param[3] = (BYTE)pOEM->tray;
        ZeroMemory(&param[4], 3);
    }
    (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 7);

    if (pOEM->method != INIT) {
        // Staple stacker
        param[0] = HIBYTE(ATT_OUTPUTPARTITION);
        param[1] = LOBYTE(ATT_OUTPUTPARTITION);
        param[2] = (pOEM->method == METHOD_JOBOFFSET) ?
            OUTPART_JOBOFFSET : OUTPART_NONE;
        (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 3);

        param[0] = HIBYTE(ATT_OUTPUTFACE);
        param[1] = LOBYTE(ATT_OUTPUTFACE);
        param[2] = (pOEM->method == METHOD_FACEUP) ?
            OUTPUTFACE_FACEUP : OUTPUTFACE_FACEDOWN;
        (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 3);

        if (pOEM->method == METHOD_STAPLE) {
            param[0] = HIBYTE(ATT_FINISHING);
            param[1] = LOBYTE(ATT_FINISHING);
            param[2] = 1;
            param[3] = FINISHING_STAPLE;
            wTemp = pOEM->staple;
            if (wTemp < 0 || wTemp >= 9)
                wTemp = 0;
// ntbug9#292998: Stapling operate incorrectly.
            switch (wTemp) {
            default:
                param[4] = FINISHING_COUNT_1;
                break;
            case 1:     // top
            case 3:     // left
            case 5:     // right
            case 7:     // center
                param[4] = FINISHING_COUNT_2;
                break;
            }
            wTemp = wStapleModes[wTemp];
            param[5] = HIBYTE(wTemp);
            param[6] = LOBYTE(wTemp);
            (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 7);
        } else {
            param[0] = HIBYTE(ATT_FINISHING);
            param[1] = LOBYTE(ATT_FINISHING);
            param[2] = 0;
            (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 3);
        }
    } else if (pOEM->sorttype != INIT) {
        // Sorter
        param[0] = HIBYTE(ATT_OUTPUTBIN);
        param[1] = LOBYTE(ATT_OUTPUTBIN);
        param[2] = (pOEM->sorttype == SORTTYPE_SORT) ?
            OUTPUTBIN_SORT : OUTPUTBIN_STACK;
        ZeroMemory(&param[3], 4);
        (VOID)SendCPCAPacket(pdevobj, CPCA_SetBinder, 0, param, 7);
    }

    ZeroMemory(param, 4);
    (VOID)SendCPCAPacket(pdevobj, CPCA_DocumentStart, 0, param, 4);

    param[0] = HIBYTE(ATT_DOCFORMAT);
    param[1] = LOBYTE(ATT_DOCFORMAT);
    param[2] = DOCFORMAT_LIPS;
    param[3] = 0;
    param[4] = 0;
    (VOID)SendCPCAPacket(pdevobj, CPCA_SetDocument, 0, param, 5);

    // ntbug9#244001: 1200dpi doesn't work on LBP-470.
    param[0] = HIBYTE(ATT_RESOLUTION);
    param[1] = LOBYTE(ATT_RESOLUTION);
    if (pOEM->resolution == 1200)
        param[2] = RESOLUTION_SUPERFINE;
    else if (pOEM->resolution == 600)
        param[2] = RESOLUTION_FINE;
    else
        param[2] = RESOLUTION_QUICK;
    ZeroMemory(&param[3], 4);
    (VOID)SendCPCAPacket(pdevobj, CPCA_SetDocument, 0, param, 7);

    param[0] = HIBYTE(ATT_COPIES);
    param[1] = LOBYTE(ATT_COPIES);
    if (pOEM->sorttype != SORTTYPE_SORT) {
        param[2] = HIBYTE(pOEM->copies);
        param[3] = LOBYTE(pOEM->copies);
    } else {
        param[2] = 0x00;
        param[3] = 0x01;
    }
    (VOID)SendCPCAPacket(pdevobj, CPCA_SetDocument, 0, param, 4);

    (VOID)FlushCPCABuffer(pdevobj, pOEM);
}

/*
 *      CPCAEnd
 */
VOID
CPCAEnd(PDEVOBJ pdevobj, BOOL fColor)
{
    PLIPSPDEV       pOEM = (PLIPSPDEV)pdevobj->pdevOEM;
    LIPSCmd         *pCmd;
    BYTE            param[32];

    param[0] = 0x01;
    pCmd = fColor ? &cmdEndDoc4C : &cmdEndDoc4;
    CopyMemory(&param[1], pCmd->pCmdStr, pCmd->cbSize);
    (VOID)SendCPCAPacket(pdevobj, CPCA_Send, 0, param, pCmd->cbSize + 1);

    (VOID)SendCPCAPacket(pdevobj, CPCA_DocumentEnd, 0, NULL, 0);

    (VOID)SendCPCAPacket(pdevobj, CPCA_BinderEnd, 0, NULL, 0);

    param[0] = 0x00;
    (VOID)SendCPCAPacket(pdevobj, CPCA_JobEnd, 0, param, 1);

    (VOID)FlushCPCABuffer(pdevobj, pOEM);
}

/*
 *	OEMWritePrinter
 */
BOOL APIENTRY
OEMWritePrinter(
    PDEVOBJ     pdevobj,
    PVOID       pBuf,
    DWORD       cbBuffer,
    PDWORD      pcbWritten)
{
    PLIPSPDEV           pOEM;
    PBYTE               pTemp, pCmd;
    DWORD               dwSize, dwCount, dwWritten;
    WORD                wCount;
    BYTE                cmd[CPCA_PACKET_SIZE+1];

    // This is used for UNIDRV to detect the plug-in.
    if (pBuf == NULL && cbBuffer == 0)
        return TRUE;

    pOEM = (PLIPSPDEV)pdevobj->pdevOEM;

    // If printer is not CPCA, pass through to the spooler.
    if (!pOEM->fCPCA)
        return WritePrinter(pdevobj->hPrinter, pBuf, cbBuffer, pcbWritten) &&
            cbBuffer == *pcbWritten;

    pTemp = (PBYTE)pBuf;
    dwSize = cbBuffer;
    while (dwSize > 0) {
        dwCount = min(dwSize, MAX_CPCA_PACKET_SIZE);
        // Build Send packet
        pCmd = pOEM->CPCAPKT;
        pCmd[3] = F_Cont;
        pCmd[4] = HIBYTE(CPCA_Send);
        pCmd[5] = LOBYTE(CPCA_Send);
        wCount = (WORD)(dwCount + 1);
        pCmd[8] = HIBYTE(wCount);
        pCmd[9] = LOBYTE(wCount);
        CopyMemory(cmd, pOEM->CPCAPKT, CPCA_PACKET_SIZE);
        cmd[CPCA_PACKET_SIZE] = 0x01;
        if (!WritePrinter(pdevobj->hPrinter, cmd, sizeof cmd, &dwWritten) ||
            sizeof cmd != dwWritten)
            return FALSE;
        if (!WritePrinter(pdevobj->hPrinter, pTemp, dwCount, &dwWritten) ||
            dwCount != dwWritten)
            return FALSE;
        pTemp += dwCount;
        dwSize -= dwCount;
    }

    *pcbWritten = cbBuffer;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\drc.c ===
/*
 *	drc.c - Support Delta Row Compression
 */

#include "pdev.h"


// Support DRC

/*
 *	PutDRCData
 */
static PBYTE
PutDRCData(
    PBYTE       pData,
    DWORD       dwOffset,
    DWORD       dwSize,
    PBYTE       pOut,
    PBYTE       pOutEnd)
{
    DWORD       dwCount, dwOff;

    while (dwSize > 0) {
        dwCount = min(dwSize, 8);
        // offset
        if (dwOffset > 30) {
            if (pOut >= pOutEnd)
                return NULL;
            *pOut++ = (BYTE)(((dwCount - 1) << 5) + 31);
            dwOffset -= 31;
            while (dwOffset >= 255) {
                dwOff = min(dwOffset, 255);
                if (pOut >= pOutEnd)
                    return NULL;
                *pOut++ = (BYTE)dwOff;
                dwOffset -= dwOff;
            }
            if (pOut >= pOutEnd)
                return NULL;
            *pOut++ = (BYTE)dwOffset;
        } else {
            if (pOut >= pOutEnd)
                return NULL;
            *pOut++ = (BYTE)(((dwCount - 1) << 5) + dwOffset);
        }
        dwOffset = 0;

        // data
        if (&pOut[dwCount] >= pOutEnd)
            return NULL;
        CopyMemory(pOut, pData, dwCount);
        pOut += dwCount;
        pData += dwCount;
        dwSize -= dwCount;
    }

    return pOut;
}

/*
 *	OEMCompression
 */
INT APIENTRY
OEMCompression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen)
{
    PLIPSPDEV   pOEM = (PLIPSPDEV)pdevobj->pdevOEM;
    PBYTE       pPre, pIn, pInEnd, pOut, pOutEnd, pStart, pBegin;
    PBYTE       pPre0, pIn0, pOutHead, pOut0, pOutEnd0;
    DWORD       dwI, dwLen, dwSize, dwOffset, dwCount;
    INT         rc;

#ifdef LBP_2030
    if (pOEM->fcolor == COLOR) // DRC can't support on 8color mode.
        return -1;
#endif
    if (pOEM->dwBmpWidth == 0 || pOEM->dwBmpHeight == 0 ||
        (pOEM->dwBmpWidth * pOEM->dwBmpHeight) != dwInLen)
            return -1;

    // Do DRC compression
    rc = -1;
    pPre = NULL;
    pIn = pInBuf;
    pOut = pOutBuf;
    pOutEnd = &pOut[dwOutLen];

    for (dwI = 0; dwI < pOEM->dwBmpHeight; dwI++) {
        pStart = pBegin = pIn;
        pInEnd = &pIn[pOEM->dwBmpWidth];
        pOutHead = pOut;
        while (pIn < pInEnd) {
            if (pPre == NULL) {
                if (*pIn == 0) {
                    pIn++;
                    continue;
                }
            } else if (*pPre == *pIn) {
                pPre++, pIn++;
                continue;
            }
            pIn0 = pIn;
            if (pPre == NULL) {
                do {
                    pIn++;
                } while (pIn < pInEnd && *pIn);
            } else {
                do {
                    pPre++, pIn++;
                } while (pIn < pInEnd && *pPre != *pIn);
            }
            dwOffset = (DWORD)(pIn0 - pStart);
            dwSize = (DWORD)(pIn - pIn0);
            if (!(pOut = PutDRCData(pIn0, dwOffset, dwSize, pOut, pOutEnd)))
                goto out;
            pStart = pIn;
        }

        // Insert length of raster data
        if (pOut == pOutHead) {
            // identical
            if (pOut >= pOutEnd)
                goto out;
            *pOut++ = 0;
        } else {
            dwSize = (DWORD)(pOut - pOutHead);
            dwCount = (dwSize / 255) + 1;
            if (&pOut[dwCount] >= pOutEnd)
                goto out;
            pPre0 = pOut;
            pOut0 = pOut = &pOut[dwCount];
            while (pPre0 >= pOutHead)
                *--pOut0 = *--pPre0;
            pOut0 = pOutHead;
            while (dwSize >= 255) {
                dwLen = min(dwSize, 255);
                *pOut0++ = (BYTE)dwLen;
                dwSize -= dwLen;
            }
            *pOut0++ = (BYTE)dwSize;
        }

        // set to previous raster
        pPre = pBegin;
    }

    rc = (INT)(pOut - pOutBuf);

out:
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\sources.inc ===
!IF 0

Copyright (C) 1996 - 1999 Microsoft Corporation

Module Name:

    sources.

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

GPDDIR=$(PRNROOT)\gpd\canon\$(ALT_PROJECT)

TARGETNAME=cnl4jres
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLBASE=0x70000000
RCCODEPAGE=932

INCLUDES=$(PRNROOT)\inc

MSC_WARNING_LEVEL=/W3 /WX

SOURCES= ..\cnl4jres.rc \
         ..\cnl4jres.c \
         ..\common.c \
         ..\drc.c

UMTYPE=windows

MISCFILES=\
	$(GPDDIR)\cnl1510j.gpd \
	$(GPDDIR)\cnl1610j.gpd \
	$(GPDDIR)\cnl1710j.gpd \
	$(GPDDIR)\cnl1810j.gpd \
	$(GPDDIR)\cnl2030j.gpd \
	$(GPDDIR)\cnl2040j.gpd \
	$(GPDDIR)\cnl2160j.gpd \
	$(GPDDIR)\cnl2200j.gpd \
	$(GPDDIR)\cnl2260j.gpd \
	$(GPDDIR)\cnl2300j.gpd \
	$(GPDDIR)\cnl2360j.gpd \
	$(GPDDIR)\cnl310j.gpd \
	$(GPDDIR)\cnl320j.gpd \
	$(GPDDIR)\cnl320pj.gpd \
	$(GPDDIR)\cnl350j.gpd \
	$(GPDDIR)\cnl34e2j.gpd \
	$(GPDDIR)\cnl34ej.gpd \
	$(GPDDIR)\cnl34g2j.gpd \
	$(GPDDIR)\cnl39g2j.gpd \
	$(GPDDIR)\cnl404j.gpd \
	$(GPDDIR)\cnl430j.gpd \
	$(GPDDIR)\cnl44ej.gpd \
	$(GPDDIR)\cnl44fj.gpd \
	$(GPDDIR)\cnl44g2j.gpd \
	$(GPDDIR)\cnl450j.gpd \
	$(GPDDIR)\cnl45jj.gpd \
	$(GPDDIR)\cnl46dj.gpd \
	$(GPDDIR)\cnl46e2j.gpd \
	$(GPDDIR)\cnl46ej.gpd \
	$(GPDDIR)\cnl46g2j.gpd \
	$(GPDDIR)\cnl46gj.gpd \
	$(GPDDIR)\cnl46sj.gpd \
	$(GPDDIR)\cnl470j.gpd \
	$(GPDDIR)\cnl5030j.gpd \
	$(GPDDIR)\cnl66a1j.gpd \
	$(GPDDIR)\cnl66b1j.gpd \
	$(GPDDIR)\cnl68b1j.gpd \
	$(GPDDIR)\cnl720j.gpd \
	$(GPDDIR)\cnl730j.gpd \
	$(GPDDIR)\cnl740j.gpd \
	$(GPDDIR)\cnl750j.gpd \
	$(GPDDIR)\cnl830j.gpd \
	$(GPDDIR)\cnl840j.gpd \
	$(GPDDIR)\cnl850j.gpd \
	$(GPDDIR)\cnl870j.gpd \
	$(GPDDIR)\cnl880j.gpd \
	$(GPDDIR)\cnl910j.gpd \
	$(GPDDIR)\cnl930j.gpd \
	$(GPDDIR)\cnl930xj.gpd \
	$(GPDDIR)\cnl950j.gpd \
	$(GPDDIR)\cnlc680j.gpd \
	$(GPDDIR)\cnlc880j.gpd \
	$(GPDDIR)\cnli325j.gpd \
	$(GPDDIR)\cnli500j.gpd \
	$(GPDDIR)\cnli600j.gpd \
	$(GPDDIR)\cnlmeb1j.gpd \
	$(GPDDIR)\cnlmed1j.gpd \
	$(GPDDIR)\cnlmee1j.gpd \
	$(GPDDIR)\cnlp300j.gpd \
	..\cnl4jres.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
// ntbug9#172276: CPCA support
class IOemCB:public IPrintOemUni2
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

// ntbug9#172276: CPCA support

    //
    // IPrintOemUni2 methods
    //

    //
    // Method for plugin to hook out spooler's WritePrinter API so it
    // can get access to output data Universal driver is generating
    //
    // At DrvEnablePDEV time, Universal driver will call this function with
    // pdevobj = NULL, pBuf = NULL, cbBuffer = 0 to detect if the plugin
    // implements this function. Plugin should return S_OK to indicate it is
    // implementing this function, or return E_NOTIMPL otherwise.
    //
    // In pcbWritten, plugins should return the number of bytes written to the
    // spooler's WritePrinter function. Zero doesn't carry a special meaning,
    // errors must be reported through the returned HRESULT.
    //

    STDMETHOD(WritePrinter) (THIS_   PDEVOBJ    pdevobj,
                                     PVOID      pBuf,
                                     DWORD      cbBuffer,
                                     PDWORD     pcbWritten);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\name.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
// ntbug9#172276: CPCA support
CONST CHAR pstrWritePrinter[] = "WritePrinter";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnrstres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\nt4\dllentry.cpp ===
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//		DllInitialize
//
//  PLATFORMS:	Windows NT
//
//

#include "pdev.h"

// Need to export these functions as c declarations.
extern "C" {

///////////////////////////////////////////////////////////
//
// DLL entry point
//

#ifndef WINNT_40

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#else // WINNT_40

// DllInitialize isn't called/used for user mode version.
BOOL WINAPI DllInitialize(ULONG ulReason)
{
	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));

            // In kernel mode version, initializes semaphore.
            DrvCreateInterlock();
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));

            // In kernel mode version, deletes semaphore.
            DrvDeleteInterlock();
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#endif // WINNT_40

}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnrstres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

#if 0
static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
#else // 0
extern BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
extern BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
#endif // 0
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    DBGPRINT(DBG_WARNING,(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    DBGPRINT(DBG_WARNING,(DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n")));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEM_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING, ("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


#if 0
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
#if 0
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));
#endif

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
#if 0
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }
#endif

    return TRUE;
}
#endif // 0


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING, ("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DBGPRINT(DBG_WARNING, ("\tcbSize = %d.\r\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING, ("\thPrinter = %#lx.\r\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING, ("\thModule = %#lx.\r\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING, ("\tpPublicDMIn = %#lx.\r\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING, ("\tpPublicDMOut = %#lx.\r\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING, ("\tpOEMDMIn = %#lx.\r\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING, ("\tpOEMDMOut = %#lx.\r\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING, ("\tcbBufSize = %d.\r\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\nt4\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(("IOemCB: QueryInterface entry\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(("IOemCB:Return pointer to IUnknown.\n")) ; 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        VERBOSE(("IOemCB:Return pointer to IPrintOemUni.\n")) ; 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE(("IOemCB:Return NULL.\n")) ; 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE(("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE(("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE(("IOemCB::EnableDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE(("IOemCB::DisaleDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(("IOemCB::PublishDriverInterface() entry.\r\n"));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE(("IOemCB::EnablePDEV() entry.\r\n"));
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
//  return E_NOTIMPL;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
//  return E_NOTIMPL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    VERBOSE(("IOemCB::DisablePDEV() entry.\r\n"));
    OEMDisablePDEV(pdevobj);
    return S_OK;
//  return E_NOTIMPL;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(("IOemCB::GetInfo() entry.\r\n"));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    VERBOSE(("IOemCB::GetImplementedMethod() entry.\r\n"));
    VERBOSE(("        Function:%s:",pMethodName ));

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'D':
#if 0
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;
#endif
                else if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'E':
#if 0
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
#if 0
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
#if 0
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'I':
#if 0
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'M':
#if 0
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
#if 0
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
#endif
                break;
        }
    }

    if (lReturn)
    {
        // DbgPrint(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        // DbgPrint(__TEXT("NOT supported\r\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE(("IOemCB::DevMode() entry.\r\n"));
    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE(("IOemCB::CommandCallback() entry.\r\n"));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE(("IOemCB::ImageProcessing() entry.\r\n"));
    // if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
    //                     dwCallbackID, pIPParams))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    VERBOSE(("IOemCB::FilterGraphis() entry.\r\n"));
    // pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuf, dwLen, &dwResult);
    
    // if (dwResult == dwLen)
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE(("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE(("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE(("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE(("IOemCB::DownloadFontHeader() entry.\r\n"));
    //*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE(("IOemCB::DownloadCharGlyph() entry.\r\n"));
    //*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE(("IOemCB::TTDownloadMethod() entry.\r\n"));
    //*pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE(("IOemCB::OutputCharStr() entry.\r\n"));
    OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    return S_OK;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE(("IOemCB::SendFontCmd() entry.\r\n"));
    OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    return S_OK;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE(("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE(("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();

    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //VERBOSE(("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //VERBOSE(("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID) ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID) ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnrstres\cnrstres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
// 
// Copyright (C) 1994-1999 Microsoft Corporation
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

	// Private Extention
	pOEMExtra->wMediaType = MEDIATYPE_PLAIN;
	pOEMExtra->wPrintQuality = PRINTQUALITY_NORMAL;
	pOEMExtra->wInputBin = INPUTBIN_AUTO;
	
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        pdmOut->wMediaType = pdmIn->wMediaType;
        pdmOut->wPrintQuality = pdmIn->wPrintQuality;
		pdmOut->wInputBin= pdmIn->wInputBin;
    }
    return TRUE;
}

// #######

/*****************************************************************************/
/*                                                                           */
/*   INT APIENTRY OEMCommandCallback(                                        */
/*                PDEVOBJ pdevobj                                            */
/*                DWORD   dwCmdCbId                                          */
/*                DWORD   dwCount                                            */
/*                PDWORD  pdwParams                                          */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbId,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams)  // points to values of command params
{
    POEM_EXTRADATA      pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);
	BYTE				ESC_PRINT_MODE[] = "\x1B\x28\x63\x03\x00\x10\x00\x00";
	BYTE				ESC_INPUTBIN[]   = "\x1B\x28\x6C\x02\x00\x00\x00";

    switch(dwCmdCbId)
    {
		case CMD_BEGIN_PAGE:
			// Set Print mode setting command parameter
			ESC_PRINT_MODE[6] = 
				bPrintModeParamTable[pOEM->wPrintQuality][pOEM->wMediaType];
			
			// Set input bin command parameter
			ESC_INPUTBIN[5] = (pOEM->wInputBin == INPUTBIN_AUTO ? 0x14 : 0x11);
			ESC_INPUTBIN[6] = bInputBinMediaParamTable[pOEM->wMediaType];

			WRITESPOOLBUF(pdevobj, (PBYTE)ESC_PRINT_MODE, 8);
			WRITESPOOLBUF(pdevobj, (PBYTE)ESC_INPUTBIN,7 );
			break;

		// Media Type
		case CMD_MEDIA_PLAIN:
		case CMD_MEDIA_COAT:
		case CMD_MEDIA_OHP:
		case CMD_MEDIA_BPF:
		case CMD_MEDIA_FABRIC:
		case CMD_MEDIA_GLOSSY:
		case CMD_MEDIA_HIGHGLOSS:
		case CMD_MEDIA_HIGHRESO:
			pOEM->wMediaType = (WORD)(dwCmdCbId - MEDIATYPE_START);
			break;

		// Print Quality
		case CMD_QUALITY_NORMAL:
		case CMD_QUALITY_HIGHQUALITY:
		case CMD_QUALITY_DRAFT:
			pOEM->wPrintQuality = (WORD)(dwCmdCbId - PRINTQUALITY_START);
			break;

		case CMD_INPUTBIN_AUTO:
			pOEM->wInputBin = INPUTBIN_AUTO;
			break;
		case CMD_INPUTBIN_MANUAL:
			pOEM->wInputBin = INPUTBIN_MANUAL;
			break;

        default:
            break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnrstres\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
//     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
//     "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnrstres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

GPDDIR_CN=$(PRNROOT)\gpd\canon\$(ALT_PROJECT)
GPDDIR_QX=$(PRNROOT)\gpd\qnix\$(ALT_PROJECT)
UNIDIR=$(PRNROOT)\unidrv2
SRCDIR=..

!include $(PRNROOT)\print.inc

INCLUDES=$(PRNROOT)\inc;$(UNIDIR)\inc

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),cnrstres
!else
DLLBASE=0x8000000
!endif

TARGETNAME=cnrstres
TARGETPATH=obj
TARGETTYPE=DYNLINK

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\cnrstres.rc \
    $(SRCDIR)\cnrstres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\cnrstres.ini
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnrstres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnrstres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CNRS'      // Canon/Qnix resource DLL
#define DLLTEXT(s)      "CNRS: " s
#define OEM_VERSION      0x00010000L

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEM_EXTRADATA {
    OEM_DMEXTRAHEADER	dmExtraHdr;

    // Private extention
	WORD				wMediaType;
	WORD				wPrintQuality;
	WORD				wInputBin;
} OEM_EXTRADATA, *POEM_EXTRADATA;

////////////////////////////////////////////////////////
//      OEM Command Callback ID definition
////////////////////////////////////////////////////////
// Job Setup
#define CMD_BEGIN_PAGE				1

// Media Type
#define	CMD_MEDIA_PLAIN				20		// Plain Paper
#define CMD_MEDIA_COAT				21		// Coated Paper
#define	CMD_MEDIA_OHP				22		// Transparency
#define	CMD_MEDIA_BPF				23		// Back Print Film
#define	CMD_MEDIA_FABRIC			24		// Fabric Sheet
#define	CMD_MEDIA_GLOSSY			25		// Glossy Paper
#define	CMD_MEDIA_HIGHGLOSS			26		// High Gloss Paper
#define	CMD_MEDIA_HIGHRESO			27		// High Resolution Paper
#define	CMD_MEDIA_BJ     			28		// BJ Cross
#define	CMD_MEDIA_JPNPST			29		// JapanesePostcard

// Print Quality
#define CMD_QUALITY_NORMAL			30
#define	CMD_QUALITY_HIGHQUALITY		31
#define	CMD_QUALITY_DRAFT			32

// Input Bin
#define	CMD_INPUTBIN_AUTO			40
#define	CMD_INPUTBIN_MANUAL			41

////////////////////////////////////////////////////////
//      OEM private extention index
////////////////////////////////////////////////////////
// Media Type Index
#define	NUM_MEDIA					8
#define	MEDIATYPE_PLAIN				0
#define	MEDIATYPE_COAT				1
#define	MEDIATYPE_OHP				2
#define	MEDIATYPE_BPF				3
#define	MEDIATYPE_FABRIC			4
#define	MEDIATYPE_GLOSSY			5
#define	MEDIATYPE_HIGHGLOSS			6
#define	MEDIATYPE_HIGHRESO			7

#define	MEDIATYPE_START		CMD_MEDIA_PLAIN

// PrintQuality Index
#define	NUM_QUALITY					3
#define	PRINTQUALITY_NORMAL			0
#define	PRINTQUALITY_HIGHQUALITY	1
#define PRINTQUALITY_DRAFT			2

#define	PRINTQUALITY_START	CMD_QUALITY_NORMAL

// Input Bin Index
#define NUM_INPUTBIN				2
#define	INPUTBIN_AUTO				0
#define	INPUTBIN_MANUAL				1

////////////////////////////////////////////////////////
//      Command parameter table
////////////////////////////////////////////////////////
static BYTE	bPrintModeParamTable[NUM_QUALITY][NUM_MEDIA] = 
{
	// Quality Normal
	{
		0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70
	}, 
	// Quality High Quality
	{
		0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71
	},
	// Quality Draft
	{
		0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72
	}
};
static BYTE	bInputBinMediaParamTable[NUM_MEDIA] =
{
	0x00, 0x10, 0x20, 0x20, 0x00, 0x10, 0x10, 0x00
};

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\colmatch.h ===
//***************************************************************************************************
//    COLMATCH.H
//
//    Functions of color matching(C Header)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Include Header file
//---------------------------------------------------------------------------------------------------
#include "COLORDEF.H"
#include "N4DIZ.H"
#include "N403DIZ.H"

//---------------------------------------------------------------------------------------------------
//    Printer name
//---------------------------------------------------------------------------------------------------
#define PRN_N4      0
#define PRN_N403    1

//---------------------------------------------------------------------------------------------------
//    Data define
//---------------------------------------------------------------------------------------------------
#define No          0
#define Yes         1

#define XX_RES_300DPI            0
#define XX_RES_600DPI            1

#define XX_MONO                  0
#define XX_COLOR                 1
#define XX_COLOR_SINGLE          2
#define XX_COLOR_MANY            3

#define XX_DITHERING_OFF         0
#define XX_DITHERING_ON          1
#define XX_DITHERING_DET         2
#define XX_DITHERING_PIC         3
#define XX_DITHERING_GRA         4
#define XX_DITHERING_CAR         5
#define XX_DITHERING_GOSA        6

#define XX_COLORMATCH_NONE       0
#define XX_COLORMATCH_BRI        1
#define XX_COLORMATCH_VIV        2
#define XX_COLORMATCH_IRO        3
#define XX_COLORMATCH_NORMAL     4
#define XX_COLORMATCH_VIVCOL     5
#define XX_COLORMATCH_NATCOL     6

#define XX_BITFONT_OFF           0
#define XX_BITFONT_ON            1

#define XX_CMYBLACK_OFF          0
#define XX_CMYBLACK_ON           1

#define XX_COMPRESS_OFF          0
#define XX_COMPRESS_AUTO         1
#define XX_COMPRESS_RASTER       3

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PALETTE_SIZE    1

#define BYTE_LENGTH(s) (sizeof (s) - 1)

//===================================================================================================
//    Color matching structure
//===================================================================================================
typedef struct {
    WORD    wReso;                              // Resolution
    WORD    ColMon;                             // Color/Monochrome
    WORD    DatBit;                             // Data bit(1:2value 2:4value 4:16value)
    WORD    BytDot;                             // DPI (2value:8 4value:4 16value:2)
    struct {                                    // Strcture for color matching
        WORD        Mode;                       // Type of color matching
        WORD        Viv;                        // Vividly?(For N4-612Printer)
        WORD        KToner;                     // Gray color use black toner
        WORD        LutNum;                     // LUT table No.
        WORD        Diz;                        // Type od dithering
        SHORT       Toner;                      // Toner density(-30`30)
        WORD        TnrNum;                     // Toner density table No.
        WORD        CmyBlk;                     // Replace CMY by black toner
        WORD        Speed;                      // 0:high 1:normal
        WORD        Gos32;                      // GOSA?
        WORD        PColor;                     // Original color?
        WORD        SubDef;                     // Bright, contrast and gamma 
        SHORT       Bright;                     // bright
        SHORT       Contrast;                   // contrast
        WORD        GamRed;                     // Color balance(R)
        WORD        GamGreen;                   // Color balance(G)
        WORD        GamBlue;                    // Color balance(B)
    } Mch;
    union {
        struct {
            LPN4DIZINF      lpDizInf;           // Structure for control dithering and color-matching
        } N4;
        struct {
            LPN403DIZINF    lpDizInf;           // Structure for control dithering and color-matching
        } N403;
    };
} DEVCOL, FAR *LPDEVCOL;

//===================================================================================================
//    Bitmap buffer structure
//===================================================================================================
typedef struct {
    WORD    Diz;                                // Method of dithering
    WORD    Style;                              // Method of spooling
    WORD    DatBit;                             // Databit(1:2value 2:4value 4:16value)
    struct {
        struct {                                // Member of RGB buffer(for 1 line)
            WORD      AllWhite;                 // All data is white?
            DWORD     Siz;                      // Size
            LPRGB     Pnt;                      // Pointer
        } Rgb;
        struct {                                // Member of CMYK buffer(for 1 line)
            DWORD     Siz;                      // Size
            LPCMYK    Pnt;                      // Poiner
        } Cmyk;
        struct {                                // Member of CMYK(2/4/16value)bitmap buffer(maximum 64KB)
            DWORD     Siz;                      // Size
            WORD      BseLin;                   // The number of lines that require
            WORD      Lin;                      // The number of lines that allocate
            LPBYTE    Pnt[4];                   // Pointer
        } Bit;
    } Drv;
} BMPBIF, FAR* LPBMPBIF;

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Initialize the members of color-matching
//===================================================================================================
BOOL FAR PASCAL ColMatchInit(PDEVOBJ);

//===================================================================================================
//    DIB spools to the printer
//===================================================================================================
BOOL FAR PASCAL DIBtoPrn(PDEVOBJ, PBYTE, PBITMAPINFOHEADER, PBYTE, PIPPARAMS);

//===================================================================================================
//    Convert RGB data into CMYK data
//===================================================================================================
BOOL FAR PASCAL StrColMatching(PDEVOBJ, WORD, LPRGB, LPCMYK);

//===================================================================================================
//    Free dither table, toner density table , Lut table, N403DIZINF(N4DIZINF) structure buffer
//===================================================================================================
void FAR PASCAL DizLutTnrTblFree(PDEVOBJ);


// End of File

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\debug.c ===
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\colmatch.c ===
//***************************************************************************************************
//    COLMATCH.C
//
//    Functions of color matching
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    "PDEV.H"
//#include    "DEBUG.H"
#include    "PRNCTL.H"


//---------------------------------------------------------------------------------------------------
//    Byte/Bit table
//---------------------------------------------------------------------------------------------------
static const BYTE BitTbl[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};


//---------------------------------------------------------------------------------------------------
//    Table for numbering dither method
//---------------------------------------------------------------------------------------------------
static const WORD DizNumTbl[7] = {1,                       // XX_DITHERING_OFF
                                  1,                       // XX_DITHERING_ON
                                  0,                       // XX_DITHERING_DET
                                  1,                       // XX_DITHERING_PIC
                                  2,                       // XX_DITHERING_GRA
                                  0,                       // XX_DITHERING_CAR
                                  3                        // XX_DITHERING_GOSA
};

#define MAX_DIZNUM (sizeof DizNumTbl / sizeof DizNumTbl[0])

//---------------------------------------------------------------------------------------------------
//    Define LUT fine name
//---------------------------------------------------------------------------------------------------
#define N4LUT000    L"CPN4RGB0.LUT"                         // For N4 printer
#define N4LUT001    L"CPN4RGB1.LUT"
#define N4LUT002    L"CPN4RGB2.LUT"
#define N4LUT003    L"CPN4RGB3.LUT"
#define N4LUT004    L"CPN4RGB4.LUT"
#define N4LUT005    L"CPN4RGB5.LUT"
#define N403LUTX    L"CPN4RGBX.LUT"                         // For N4-612 printer
#define N403LUTY    L"CPN4RGBY.LUT"

//---------------------------------------------------------------------------------------------------
//    Define DLL name
//---------------------------------------------------------------------------------------------------
#define CSN46RESDLL    L"CSN46RES.DLL"

//---------------------------------------------------------------------------------------------------
//    Define data
//---------------------------------------------------------------------------------------------------
#define DPI300    300
#define DPI600    600

static BYTE ORG_MODE_IN[]     = "\x1Bz\xD0\x01";
static BYTE ORG_MODE_OUT[]    = "\x1Bz\x00\x01";
static BYTE PALETTE_SELECT[]  = "Cd,%d,%d*";
static BYTE PLANE_RESET[]     = "Da,0,0,0,0*";

#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

//***************************************************************************************************
//    Prototype declaration
//***************************************************************************************************
static BOOL DizTblSetN4(PDEVOBJ, WORD);
static BOOL DizTblSetN403(PDEVOBJ, WORD);
static BOOL LutFileLoadN4(PDEVOBJ, WORD, WORD, WORD);
static BOOL LutFileLoadN403(PDEVOBJ, WORD, WORD);
static BOOL TnrTblSetN4(PDEVOBJ, SHORT);
static BOOL TnrTblSetN403(PDEVOBJ, SHORT);
static BOOL ColGosTblSet(LPN4DIZINF, WORD);
static void ColGosTblFree(LPN4DIZINF);
static void ColRgbGos(PDEVOBJ, WORD, WORD, WORD, LPBYTE);
static BOOL BmpBufAlloc(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, WORD, WORD, LPBMPBIF);
static void BmpBufFree(LPBMPBIF);
static void BmpBufClear(LPBMPBIF);
static WORD Dithering001(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, LPBYTE, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
static void BmpPrint(PDEVOBJ, LPBMPBIF, POINT, WORD, WORD, WORD);
static void BmpRGBCnv(LPRGB, LPBYTE, WORD, WORD, WORD, LPRGBQUAD);

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Initialize the members of color-matching
//===================================================================================================
BOOL FAR PASCAL ColMatchInit(
    PDEVOBJ        pdevobj                                  // Pointer to PDEVOBJ structure
)
{
    LPN4DIZINF     lpN4DizInf;                              // N4DIZINF structure
    LPN403DIZINF   lpN403DizInf;                            // N403DIZINF structure

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    pOEM->Col.Mch.Mode       = pOEM->iColorMatching;
    pOEM->Col.Mch.Diz        = pOEM->iDithering;
    pOEM->Col.Mch.PColor     = No;
    pOEM->Col.Mch.Toner      = 0;
    if (pOEM->iCmyBlack == XX_CMYBLACK_ON) {                // Replace K with CMY?
        pOEM->Col.Mch.CmyBlk = 1;
    } else {
        pOEM->Col.Mch.CmyBlk = 0;                           // Use black toner
    }
                                                            // 0 fixed
    pOEM->Col.Mch.Bright     = 0;
                                                            // 0 fixed
    pOEM->Col.Mch.Contrast   = 0;
                                                            // Color balance(R) : 10 fixed
    pOEM->Col.Mch.GamRed     = 10;
                                                            // Color balance(G) : 10 fixed
    pOEM->Col.Mch.GamGreen   = 10;
                                                            // Color balance(B) : 10 fixed
    pOEM->Col.Mch.GamBlue    = 10;
    pOEM->Col.Mch.Speed      = pOEM->iBitFont;
    pOEM->Col.Mch.Gos32      = No;
    pOEM->Col.Mch.LutNum     = 0;                           // LUT table number

    pOEM->Col.Mch.TnrNum     = 0;                           // Toner density table number

    pOEM->Col.Mch.SubDef     = Yes;                         // Not change setting of color balance, bright and contrast?

    CM_VERBOSE(("CMINit ENT Tn=%d Col=%d Mod=%d DZ=%d Cyk=%d Sp=%d Prt=%d\n", pOEM->iTone, pOEM->iColor, pOEM->Col.Mch.Mode,pOEM->Col.Mch.Diz,pOEM->Col.Mch.CmyBlk,pOEM->Col.Mch.Speed,pOEM->Printer));

    if (pOEM->Printer != PRN_N403) {                        // N4 printer

        if ((pOEM->Col.N4.lpDizInf = MemAllocZ(sizeof(N4DIZINF))) == NULL) {
            ERR(("Alloc ERROR!!\n"));
            return 0;
        }
        lpN4DizInf = pOEM->Col.N4.lpDizInf;

        if (pOEM->iColor != XX_MONO) {
            lpN4DizInf->ColMon = N4_COL;                      // Color
        } else {
            lpN4DizInf->ColMon = N4_MON;                      // Monochrome
        }
        if (pOEM->iResolution == XX_RES_300DPI) {
            pOEM->Col.wReso = DPI300;
        }
        pOEM->Col.DatBit = 1;
        pOEM->Col.BytDot = 8;                              // Numbers of DPI(2 value)

        if (pOEM->iBitFont == XX_BITFONT_OFF) {
            pOEM->Col.Mch.Gos32 = Yes;
        }
        pOEM->Col.Mch.Speed = Yes;

        if (pOEM->Col.Mch.Diz != XX_DITHERING_GOSA) {
            // Make dither table for N4 printer
            if (DizTblSetN4(pdevobj, pOEM->Col.Mch.Diz) == FALSE) {
                ERR(("DizTblSetN4 ERROR!!\n"));
                return 0;
            }
        }
        if (lpN4DizInf->ColMon == N4_COL) {

            if (pOEM->Col.Mch.Mode != XX_COLORMATCH_NONE) {
                // Load LUT file
                if (LutFileLoadN4(pdevobj,
                                  pOEM->Col.Mch.Mode,
                                  pOEM->Col.Mch.Diz,
                                  pOEM->Col.Mch.Speed) == FALSE) {
                    ERR(("LutFileLoadN4 ERROR!!\n"));
                    return 0;
                }
                pOEM->Col.Mch.LutNum = 0;                    // Lut table number
            }
            // Make toner density table
            if (TnrTblSetN4(pdevobj, pOEM->Col.Mch.Toner) == FALSE) {
                ERR(("TnrTblSetN4 ERROR!!\n"));
                return 0;
            }
            pOEM->Col.Mch.TnrNum = 0;                        // Toner density table number
        }
    } else {                                                 // N403 printer

        if ((pOEM->Col.N403.lpDizInf = MemAllocZ(sizeof(N403DIZINF))) == NULL) {
            ERR(("Init Alloc ERROR!!\n"));
            return 0;
        }
        lpN403DizInf = pOEM->Col.N403.lpDizInf;

        if (pOEM->Col.Mch.Mode == XX_COLORMATCH_VIV) {
            pOEM->Col.Mch.Viv = 20;
        }
        pOEM->Col.wReso = (pOEM->iResolution == XX_RES_300DPI) ? DPI300 : DPI600;

        if (pOEM->iColor != XX_MONO) {
            lpN403DizInf->ColMon = N403_COL;                     // Color
        } else {
            lpN403DizInf->ColMon = N403_MON;                     // Monochrome
        }

        if (pOEM->iColor == XX_COLOR_SINGLE) {
            lpN403DizInf->PrnMod = (pOEM->iResolution == XX_RES_300DPI) ? N403_MOD_300B1 : N403_MOD_600B1;
        }
        if (pOEM->iColor == XX_COLOR_MANY) {
            lpN403DizInf->PrnMod = (pOEM->iResolution == XX_RES_300DPI) ? N403_MOD_300B4 : N403_MOD_600B2;
        }

        if (lpN403DizInf->PrnMod == N403_MOD_300B1) {            // 300DPI 2 value
            CM_VERBOSE(("N403_MOD_300B1\n"));
            pOEM->Col.DatBit = 1;
            pOEM->Col.BytDot = 8;                                // Number of DPI(2 value)
        } else if (lpN403DizInf->PrnMod == N403_MOD_300B4) {     // 300DPI 16 value
            CM_VERBOSE(("N403_MOD_300B4\n"));
            pOEM->Col.DatBit = 4;
            pOEM->Col.BytDot = 2;
        } else if (lpN403DizInf->PrnMod == N403_MOD_600B1) {     // 600DPI 2 value
            CM_VERBOSE(("N403_MOD_600B1\n"));
            pOEM->Col.DatBit = 1;
            pOEM->Col.BytDot = 8;
        } else {                                                 // 600DPI 4 value
            CM_VERBOSE(("N403_MOD_600B2\n"));
            pOEM->Col.DatBit = 2;
            pOEM->Col.BytDot = 4;
        }

        // Make dither table for N4-612 printer
        if (DizTblSetN403(pdevobj, pOEM->Col.Mch.Diz) == FALSE) {
            ERR(("diztblset n403 ERROR!!\n"));
            return 0;
        }
        if (lpN403DizInf->ColMon == N403_COL) {

            if (pOEM->Col.Mch.Mode != XX_COLORMATCH_NONE) {
                // Load LUT file
                if (LutFileLoadN403(pdevobj,
                                    pOEM->Col.Mch.Mode,
                                    pOEM->Col.Mch.Speed) == FALSE) {
                    ERR(("lutfileloadn4 ERROR!!\n"));
                    return 0;
                }
                pOEM->Col.Mch.LutNum = 0;
            }
            // Make toner density table
            if (TnrTblSetN403(pdevobj, pOEM->Col.Mch.Toner) == FALSE) {
                ERR(("tnrtblsetn4 ERROR!!\n"));
                return 0;
            }
            pOEM->Col.Mch.TnrNum = 0;
        }

    }
    CM_VERBOSE(("ColMatchInit End pOEM->Col.wReso= %d\n",pOEM->Col.wReso));

    return TRUE;
}


//===================================================================================================
//    DIB spools to the printer
//===================================================================================================
BOOL FAR PASCAL DIBtoPrn(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBmp,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    PIPPARAMS           pIPParams)
{

    BMPBIF      bmpBuf;                             // BMPBIF structure
    POINT       drwPos;                             // Start position for spooling
    WORD        dstWByt;                            // X size of destination bitmap data
    LONG        dstX;                               // X coordinates of destination bitmap data
    LONG        dstY;                               // Y coordinates of destination bitmap data
    LONG        dstYEnd;                            // The last Y coordinates(+1) of destination bitmap data
    WORD        dstScn;                             // Number of destination bitmap data lines
    WORD        srcY;                               // Y coordinates of source bitmap data
    LONG        srcWByt;                            // Y size of source bitmap data
    WORD        setCnt;                             // count
    LPCMYK      lpCMYK;                             // CMYK temporary data buffer
    BYTE        Cmd[64];
    WORD        wlen;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    CM_VERBOSE(("   ImagePro ENTRY Dx=%d Dy=%d SxSiz=%d SySiz=%d BC=%d Sz=%d ",
                    pIPParams->ptOffset.x, pIPParams->ptOffset.y,
                    pBitmapInfoHeader->biWidth, pBitmapInfoHeader->biHeight, pBitmapInfoHeader->biBitCount,
                    pIPParams->dwSize));

    if (pOEM->Printer != PRN_N403) {                        // N4 printer
        if (pOEM->iDithering == XX_DITHERING_GOSA) {
            if (pOEM->Col.N4.lpDizInf->GosRGB.Siz < (DWORD)pBitmapInfoHeader->biWidth) {
                ColGosTblFree(pOEM->Col.N4.lpDizInf);
                if ((ColGosTblSet(pOEM->Col.N4.lpDizInf, (WORD)pBitmapInfoHeader->biWidth)) == FALSE) {
                    return FALSE;
                }
            }
        }
    }

    // Initialization of
    // RGB buffer            :(X size of source bitmap data) * 3
    // CMYK buffer           :(X size of source bitmap data) * 4
    // CMYK bit buffer       :((X size of source bitmap data) * (Magnification of X) + 7) / 8 * (Y size of source bitmap data) * (Magnification of Y))
    memset(&bmpBuf, 0x00, sizeof(BMPBIF));
    if (BmpBufAlloc(pdevobj, (WORD)pBitmapInfoHeader->biWidth, (WORD)pBitmapInfoHeader->biHeight, 0, 0, 1, 1, 1, 1, &bmpBuf) == FALSE) {
        ERR(("Alloc ERROR!!\n"));
        return FALSE;
    }

    bmpBuf.Diz = pOEM->iDithering;
    bmpBuf.Style = 0;
    bmpBuf.DatBit = pOEM->Col.DatBit;

    dstWByt = (WORD)((pBitmapInfoHeader->biWidth + pOEM->Col.BytDot - 1) / pOEM->Col.BytDot);

    srcWByt = (pBitmapInfoHeader->biWidth * pBitmapInfoHeader->biBitCount + 31L) / 32L * 4L;

    drwPos.x = dstX = pIPParams->ptOffset.x;
    dstY = pIPParams->ptOffset.y;
    srcY = 0;
    dstYEnd = pIPParams->ptOffset.y + pBitmapInfoHeader->biHeight;

                                                        // Convert DIB and spool to the printer
    for (;dstY < dstYEnd; ) {
        BmpBufClear(&bmpBuf);
        drwPos.y = dstY;
        for (dstScn = 0; dstY < dstYEnd && dstScn < bmpBuf.Drv.Bit.Lin; dstScn++, dstY++) {    

            // Convert 1 line RGB bitmap data into  24bit (for 1pixel) RGB bitmap data
            BmpRGBCnv(bmpBuf.Drv.Rgb.Pnt, pSrcBmp, pBitmapInfoHeader->biBitCount, 0,
                     (WORD)pBitmapInfoHeader->biWidth, (LPRGBQUAD)pColorTable);

            if (pOEM->Col.Mch.Gos32 == Yes) {
                ColRgbGos(pdevobj, (WORD)pBitmapInfoHeader->biWidth, (WORD)dstX, (WORD)dstY, (LPBYTE)bmpBuf.Drv.Rgb.Pnt);
            }

            // Convert RGB into CMYK
            bmpBuf.Drv.Rgb.AllWhite = (WORD)StrColMatching(pdevobj, (WORD)pBitmapInfoHeader->biWidth, bmpBuf.Drv.Rgb.Pnt, bmpBuf.Drv.Cmyk.Pnt);

            lpCMYK = bmpBuf.Drv.Cmyk.Pnt;
            if (pOEM->iDithering == XX_DITHERING_OFF) {
                for (setCnt = 0; setCnt < pBitmapInfoHeader->biWidth; setCnt++) {
                    if (lpCMYK[setCnt].Cyn != 0) { lpCMYK[setCnt].Cyn = 255; }
                    if (lpCMYK[setCnt].Mgt != 0) { lpCMYK[setCnt].Mgt = 255; }
                    if (lpCMYK[setCnt].Yel != 0) { lpCMYK[setCnt].Yel = 255; }
                    if (lpCMYK[setCnt].Bla != 0) { lpCMYK[setCnt].Bla = 255; }
                }
            }

            Dithering001(pdevobj, (WORD)pOEM->iDithering, (WORD)pBitmapInfoHeader->biWidth, (WORD)dstX, (WORD)dstY,
                         srcY, (WORD)bmpBuf.Drv.Rgb.AllWhite, (LPBYTE)bmpBuf.Drv.Cmyk.Pnt,
                         bmpBuf.Drv.Bit.Pnt[CYAN]   + dstWByt * dstScn,
                         bmpBuf.Drv.Bit.Pnt[MGENTA] + dstWByt * dstScn,
                          bmpBuf.Drv.Bit.Pnt[YELLOW] + dstWByt * dstScn,
                          bmpBuf.Drv.Bit.Pnt[BLACK]  + dstWByt * dstScn);

            srcY++;
            pSrcBmp += srcWByt;
        }

        if (dstScn != 0) {
                                                        // Spool to printer
            BmpPrint(pdevobj, &bmpBuf, drwPos, (WORD)pBitmapInfoHeader->biWidth, dstScn, dstWByt);
        }
    }

    // Set back palette (Palette No. is fixed  , All plane(CMYK) is OK )
    // Same as palette state before OEMImageProcessing call 
    WRITESPOOLBUF(pdevobj, ORG_MODE_IN, BYTE_LENGTH(ORG_MODE_IN));
    wlen = (WORD)wsprintf(Cmd, PALETTE_SELECT, 0, DEFAULT_PALETTE_INDEX);
    WRITESPOOLBUF(pdevobj, Cmd, wlen);
    WRITESPOOLBUF(pdevobj, PLANE_RESET, BYTE_LENGTH(PLANE_RESET));
    WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));

    BmpBufFree(&bmpBuf);

    CM_VERBOSE(("ImagePro End\n"));

    return TRUE;
}


//===================================================================================================
//    Convert RGB data into CMYK data
//===================================================================================================
BOOL FAR PASCAL StrColMatching(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           MchSiz,                                  // X size of RGB
    LPRGB          lpRGB,                                   // RGB buffer
    LPCMYK         lpCMYK                                   // CMYK buffer
)
{
    LPN4DIZINF     lpN4DizInf;                              // N4DIZINF structure
    LPN403DIZINF   lpN403DizInf;                            // N403DIZINF structure
    WORD           chkCnt;                                  // RGB white data check count
    DWORD          bCnv;                                    // Replace black

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    for (chkCnt = 0; chkCnt < MchSiz; chkCnt++) {           // Check RGB data
        if (lpRGB[chkCnt].Blue != 0xff || lpRGB[chkCnt].Green != 0xff || lpRGB[chkCnt].Red != 0xff) {
            break;                                          // There are data except white data
        }
    }
    if (chkCnt >= MchSiz) {
        return Yes;                                         // All RGB data is white
    }
    if (pOEM->Printer != PRN_N403) {                        // N4 printer
        lpN4DizInf = pOEM->Col.N4.lpDizInf;
        bCnv = pOEM->Col.Mch.CmyBlk;
        if (lpN4DizInf->ColMon == N4_COL) {                   // Color

            // Convert RGB data
            if (pOEM->Col.Mch.Diz == XX_DITHERING_OFF) {
                N4ColCnvLin(lpN4DizInf, lpRGB, lpCMYK, (DWORD)MchSiz);

            } else if (/*pOEM->Col.Mch.KToner == Yes && */MchSiz == 1 &&
                       lpRGB->Blue == lpRGB->Green && lpRGB->Blue == lpRGB->Red) {
                                                            // For monochrome
                N4ColCnvMon(lpN4DizInf, (DWORD)DizNumTbl[pOEM->Col.Mch.Diz], lpRGB, lpCMYK, (DWORD)MchSiz);

            } else if (pOEM->Col.Mch.Mode != XX_COLORMATCH_NONE) {
                if (pOEM->Col.Mch.Speed == Yes) {
                    N4ColMch000(lpN4DizInf, lpRGB, lpCMYK, (DWORD)MchSiz, bCnv);
                } else {
                    N4ColMch001(lpN4DizInf, lpRGB, lpCMYK, (DWORD)MchSiz, bCnv);
                }
            } else {
                N4ColCnvSld(lpN4DizInf, lpRGB, lpCMYK, (DWORD)MchSiz);
            }
        } else {                                            // For monochrome
            N4ColCnvMon(lpN4DizInf, (DWORD)DizNumTbl[pOEM->Col.Mch.Diz], lpRGB, lpCMYK, (DWORD)MchSiz);
        }
    } else {                                                // N403 printer
        lpN403DizInf = pOEM->Col.N403.lpDizInf;
        bCnv = pOEM->Col.Mch.CmyBlk;
        if (lpN403DizInf->ColMon == N403_COL) {                 // Color

            if (pOEM->Col.Mch.Diz == XX_DITHERING_OFF) {

                N403ColCnvL02(lpN403DizInf, lpRGB, lpCMYK, (DWORD)MchSiz);

            } else if (/*pOEM->Col.Mch.KToner == Yes && */MchSiz == 1 &&
                       lpRGB->Blue == lpRGB->Green && lpRGB->Blue == lpRGB->Red) {
                                                            // For monochrome
                N403ColCnvMon(lpN403DizInf, lpRGB, lpCMYK, (DWORD)MchSiz);
            } else if (pOEM->Col.Mch.Mode != XX_COLORMATCH_NONE) {
                if (pOEM->Col.Mch.Speed == Yes) {
                    N403ColMch000(lpN403DizInf, lpRGB, lpCMYK, (DWORD)MchSiz, bCnv);
                } else {
                    N403ColMch001(lpN403DizInf, lpRGB, lpCMYK, (DWORD)MchSiz, bCnv);
                }
                if (pOEM->Col.Mch.Mode == XX_COLORMATCH_VIV) {
                    N403ColVivPrc(lpN403DizInf, lpCMYK, (DWORD)MchSiz, (DWORD)pOEM->Col.Mch.Viv);
                }
            } else {
                N403ColCnvSld(lpN403DizInf, lpRGB, lpCMYK, (DWORD)MchSiz, bCnv);
            }
        } else {                                            // For monochrome
            N403ColCnvMon(lpN403DizInf, lpRGB, lpCMYK, (DWORD)MchSiz);
        }
    }
    return No;                                              // There are data except white data
}


//===================================================================================================
//    Allocate GOSA-KAKUSAN table (Only for N4 printer)
//===================================================================================================
BOOL ColGosTblSet(
    LPN4DIZINF      lpN4DizInf,                             // Pointer to N4DIZINF structure
    WORD            XSize                                   // Xsize
)
{
    if ((lpN4DizInf->GosRGB.Tbl[0] = MemAllocZ((DWORD)(XSize + 2) * sizeof(SHORT) * 3)) == NULL) {
        return 0;
    }
    if ((lpN4DizInf->GosRGB.Tbl[1] = MemAllocZ((DWORD)(XSize + 2) * sizeof(SHORT) * 3)) == NULL) {
        return 0;
    }
    if ((lpN4DizInf->GosCMYK.Tbl[0] = MemAllocZ((DWORD)(XSize + 2) * sizeof(SHORT) * 4)) == NULL) {
        return 0;
    }
    if ((lpN4DizInf->GosCMYK.Tbl[1] = MemAllocZ((DWORD)(XSize + 2) * sizeof(SHORT) * 4)) == NULL) {
        return 0;
    }

    lpN4DizInf->GosRGB.Num  = 0;
    lpN4DizInf->GosCMYK.Num = 0;
    lpN4DizInf->GosRGB.Siz  = XSize;
    lpN4DizInf->GosCMYK.Siz = XSize;
    lpN4DizInf->GosRGB.Yax  = 0xffffffff;
    lpN4DizInf->GosCMYK.Yax = 0xffffffff;
    return TRUE;
}


//===================================================================================================
//    Free GOSA-KAKUSAN table (Only for N4 printer)
//===================================================================================================
void ColGosTblFree(
    LPN4DIZINF        lpN4DizInf                            // Pointer to N4DIZINF structure
)
{
    if (lpN4DizInf->GosRGB.Tbl[0]) {
        MemFree(lpN4DizInf->GosRGB.Tbl[0]);
        lpN4DizInf->GosRGB.Tbl[0] = NULL;
    }
    if (lpN4DizInf->GosRGB.Tbl[1]) {
        MemFree(lpN4DizInf->GosRGB.Tbl[1])
        lpN4DizInf->GosRGB.Tbl[1] = NULL;
    }
    if (lpN4DizInf->GosCMYK.Tbl[0]) {
        MemFree(lpN4DizInf->GosCMYK.Tbl[0]);
        lpN4DizInf->GosCMYK.Tbl[0] = NULL;
    }
    if (lpN4DizInf->GosCMYK.Tbl[1]) {
        MemFree(lpN4DizInf->GosCMYK.Tbl[1]);
        lpN4DizInf->GosCMYK.Tbl[1] = NULL;
    }
    return;
}


//===================================================================================================
//    RGB data conversion(For GOSA-KAKUSAN, only for N4)
//===================================================================================================
void ColRgbGos(
    PDEVOBJ        pdevobj,
    WORD           XSize,
    WORD           XPos,
    WORD           YOff,
    LPBYTE         lpRGB
)
{
    LPN4DIZINF     lpN4DizInf;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (pOEM->Printer == PRN_N403) {
        return;
    }
    lpN4DizInf = pOEM->Col.N4.lpDizInf;

    N4RgbGos(lpN4DizInf, (DWORD)XSize, (DWORD)XPos, (DWORD)YOff, lpRGB);
    return;
}


//===================================================================================================
//    Free dither table, toner density table , Lut table, N403DIZINF(N4DIZINF) structure buffer
//===================================================================================================
void FAR PASCAL DizLutTnrTblFree(
    PDEVOBJ     pdevobj
)
{
    int     i;
    DWORD   dizNum;
    WORD    alcCnt;
    WORD    alcTbl;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (pOEM->Printer != PRN_N403
        && NULL != pOEM->Col.N4.lpDizInf) {

        // N4 printer

        CM_VERBOSE(("OEMDisablePDEV N4\n"));

        if (pOEM->Col.Mch.Diz != XX_DITHERING_GOSA) {
            dizNum = DizNumTbl[pOEM->Col.Mch.Diz];          // Dither number
            for (i = 0; i < 4; i++) {
                if (pOEM->Col.N4.lpDizInf->Diz.Tbl[dizNum][i]) {
                    MemFree(pOEM->Col.N4.lpDizInf->Diz.Tbl[dizNum][i]);
                    pOEM->Col.N4.lpDizInf->Diz.Tbl[dizNum][i] = NULL;
                }
            }
        }
        if (pOEM->Col.N4.lpDizInf->Tnr.Tbl) {
           MemFree(pOEM->Col.N4.lpDizInf->Tnr.Tbl);
           pOEM->Col.N4.lpDizInf->Tnr.Tbl = NULL;
        }
        if (pOEM->Col.Mch.Mode != XX_COLORMATCH_NONE) {
            if (pOEM->Col.N4.lpDizInf->Lut.Tbl) {
                MemFree(pOEM->Col.N4.lpDizInf->Lut.Tbl);
                pOEM->Col.N4.lpDizInf->Lut.Tbl = NULL;
            }
            if (pOEM->Col.Mch.Speed == No) {
                if (pOEM->Col.N4.lpDizInf->Lut.CchRgb) {
                    MemFree(pOEM->Col.N4.lpDizInf->Lut.CchRgb);
                    pOEM->Col.N4.lpDizInf->Lut.CchRgb = NULL;
                }
                if (pOEM->Col.N4.lpDizInf->Lut.CchCmy) {
                    MemFree(pOEM->Col.N4.lpDizInf->Lut.CchCmy);
                    pOEM->Col.N4.lpDizInf->Lut.CchCmy = NULL;
                }
            }
        }

        if (pOEM->iDithering == XX_DITHERING_GOSA) {
            ColGosTblFree(pOEM->Col.N4.lpDizInf);
        }

        if (pOEM->Col.N4.lpDizInf) {
            MemFree(pOEM->Col.N4.lpDizInf);
            pOEM->Col.N4.lpDizInf = NULL;
        }

    } else if (NULL != pOEM->Col.N403.lpDizInf) {

        // N4-612 printer

        CM_VERBOSE(("OEMDisablePDEV N403\n"));

        dizNum = DizNumTbl[pOEM->Col.Mch.Diz];

        if (pOEM->Col.N403.lpDizInf->PrnMod == N403_MOD_600B2 && pOEM->Col.Mch.Diz == XX_DITHERING_DET) {
            alcTbl = 1;
        } else {
            alcTbl = 4;
        }
        for (alcCnt = 0; alcCnt < alcTbl; alcCnt++) {
            if (pOEM->Col.N403.lpDizInf->Diz.Tbl[dizNum][alcCnt]) {
                MemFree(pOEM->Col.N403.lpDizInf->Diz.Tbl[dizNum][alcCnt]);
                pOEM->Col.N403.lpDizInf->Diz.Tbl[dizNum][alcCnt] = NULL;
            }
        }
        if (pOEM->Col.N403.lpDizInf->PrnMod == N403_MOD_600B2) {
            for (i = 0; i < 4; i++) {
                if (pOEM->Col.N403.lpDizInf->EntDiz.Tbl[i]) {
                    MemFree(pOEM->Col.N403.lpDizInf->EntDiz.Tbl[i]);
                    pOEM->Col.N403.lpDizInf->EntDiz.Tbl[i] = NULL;
                }
            }
        }

        if (pOEM->Col.N403.lpDizInf->Tnr.Tbl) {
            MemFree(pOEM->Col.N403.lpDizInf->Tnr.Tbl);
            pOEM->Col.N403.lpDizInf->Tnr.Tbl = NULL;
        }

        if (pOEM->Col.Mch.Mode != XX_COLORMATCH_NONE) {
            if (pOEM->Col.N403.lpDizInf->Lut.Tbl) {
                MemFree(pOEM->Col.N403.lpDizInf->Lut.Tbl);
                pOEM->Col.N403.lpDizInf->Lut.Tbl = NULL;
            }
            if (pOEM->Col.Mch.Speed == No) {
                if (pOEM->Col.N403.lpDizInf->Lut.CchRgb) {
                    MemFree(pOEM->Col.N403.lpDizInf->Lut.CchRgb);
                    pOEM->Col.N403.lpDizInf->Lut.CchRgb = NULL;
                }
                if (pOEM->Col.N403.lpDizInf->Lut.CchCmy) {
                    MemFree(pOEM->Col.N403.lpDizInf->Lut.CchCmy);
                    pOEM->Col.N403.lpDizInf->Lut.CchCmy = NULL;
                }
            }
        }

        if (pOEM->Col.N403.lpDizInf) {
            MemFree(pOEM->Col.N403.lpDizInf);
            pOEM->Col.N403.lpDizInf = NULL;
        }
    }
}


//===================================================================================================
//    Allocate bitmap data buffer
//---------------------------------------------------------------------------------------------------
//    Allocate size
//          RGB buffer              :Source bitmap Xsize * 3
//          CMYK buffer             :Source bitmap Xsize * 4
//          CMYK bit buffer         :2 value    (Source Xsize * XNrt + 7) / 8 * Source Ysize * YNrt
//                                  :4 value    (Source Xsize * XNrt + 3) / 4 * Source Ysize * YNrt
//                                  :16 value   (Source Xsize * XNrt + 1) / 2 * Source Ysize * YNrt
//===================================================================================================
BOOL BmpBufAlloc(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           SrcXSiz,                                 // Source bitmap data Xsize
    WORD           SrcYSiz,                                 // Source bitmap data Ysize
    WORD           SrcXOff,                                 // Source X offset
    WORD           SrcYOff,                                 // Source Y offset
    WORD           XNrt,                                    // Magnification of X (numerator)
    WORD           XDnt,                                    // Magnification of X (denominator)
    WORD           YNrt,                                    // Magnification of Y (numerator)
    WORD           YDnt,                                    // Magnification of Y (denominator)
    LPBMPBIF       lpBmpBuf                                 // Pointer to bitmap buffer structure
)
{
    WORD           setSiz;
    WORD           setCnt;
    WORD           alcErr;                                  // Allocate error?
    WORD           bytDot;                                  // DPI
    WORD           xSiz;
    WORD           ySiz;
    WORD           alcLin;
    DWORD          alcSiz;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    alcErr = Yes;

    bytDot = pOEM->Col.BytDot;

    xSiz = (WORD)(((DWORD)SrcXOff + SrcXSiz) * XNrt / XDnt);
    xSiz -= (WORD)((DWORD)SrcXOff * XNrt / XDnt);

    ySiz = (WORD)(((DWORD)SrcYOff + SrcYSiz + 2) * YNrt / YDnt);
    ySiz -= (WORD)((DWORD)SrcYOff * YNrt / YDnt);
                                                            // The size of CMYK bit buffer
    if (((DWORD)((xSiz + bytDot - 1) / bytDot) * ySiz) < (64L * 1024L - 1L)) {
        alcLin = ySiz;
    } else {                                                // Over 64kb?
        alcLin = (WORD)((64L * 1024L - 1L) / ((xSiz + bytDot - 1) / bytDot));
    }

    alcSiz = ((xSiz + bytDot - 1) / bytDot) * alcLin;       // The size of CMYK bit buffer(8bit boundary)

    for ( ; ; ) {                                           // Allocation
                                                            // The number of lines that required.
        lpBmpBuf->Drv.Bit.BseLin = (WORD)((DWORD)(YNrt + YDnt - 1) / YDnt);
        if (lpBmpBuf->Drv.Bit.BseLin > alcLin) {
            break;
        }
        lpBmpBuf->Drv.Rgb.Siz = SrcXSiz * 3;                // RGB buffer
        if ((lpBmpBuf->Drv.Rgb.Pnt = (LPRGB)MemAllocZ(lpBmpBuf->Drv.Rgb.Siz)) == NULL) {
            break;
        }
        lpBmpBuf->Drv.Cmyk.Siz = SrcXSiz * 4;               // CMYK buffer
        if ((lpBmpBuf->Drv.Cmyk.Pnt = (LPCMYK)MemAllocZ(lpBmpBuf->Drv.Cmyk.Siz)) == NULL) {
            break;
        }
        if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {    // Color?
            setSiz = 4;                                     // CMYK
        } else {                                            // Mono?
            setSiz = 1;                                     // K
        }
                                                            // CMYK bit buffer
        for (setCnt = 0; setCnt < setSiz; setCnt++) {
            if ((lpBmpBuf->Drv.Bit.Pnt[setCnt] = MemAllocZ(alcSiz)) == NULL) {
                break;
            }
        }
        if (setCnt == setSiz) {
            lpBmpBuf->Drv.Bit.Siz = alcSiz;
            lpBmpBuf->Drv.Bit.Lin = alcLin;
            alcErr = No;                                    // Allocate OK
        }
        break;
    }
    if (alcErr == Yes) {                                    // Allocate error?
        BmpBufFree(lpBmpBuf);
        return FALSE;
    }

    return TRUE;
}


//===================================================================================================
//    Free bitmap data buffer
//===================================================================================================
void BmpBufFree(
    LPBMPBIF       lpBmpBuf                                 // Pointer to bitmap buffer structure
)
{
    WORD           chkCnt;

    if (lpBmpBuf->Drv.Rgb.Pnt) {                            // Free RGB buffer
        MemFree(lpBmpBuf->Drv.Rgb.Pnt);
        lpBmpBuf->Drv.Rgb.Pnt = NULL;
    }
    if (lpBmpBuf->Drv.Cmyk.Pnt) {                           // Free CMYK buffer
        MemFree(lpBmpBuf->Drv.Cmyk.Pnt);
        lpBmpBuf->Drv.Cmyk.Pnt = NULL;
    }
                                                            // CMYK bit buffer
    for (chkCnt = 0; chkCnt < 4; chkCnt++) {                // CMYK(2/4/16value)bitmap buffer
        if (lpBmpBuf->Drv.Bit.Pnt[chkCnt]) {
            MemFree(lpBmpBuf->Drv.Bit.Pnt[chkCnt]);
            lpBmpBuf->Drv.Bit.Pnt[chkCnt] = NULL;
        }
    }
    return;
}


//===================================================================================================
//    Clear CMYK bitmap data buffer
//===================================================================================================
void BmpBufClear(
    LPBMPBIF       lpBmpBuf                                 // Pointer to bitmap buffer structure
)
{
    WORD           chkCnt;

    for (chkCnt = 0; chkCnt < 4; chkCnt++) {                // Clear CMYK(2/4/16value)bit buffer
        if (lpBmpBuf->Drv.Bit.Pnt[chkCnt]) {
            memset(lpBmpBuf->Drv.Bit.Pnt[chkCnt], 0x00, (WORD)lpBmpBuf->Drv.Bit.Siz);
        }
    }
    return;
}


//===================================================================================================
//    Dithering
//===================================================================================================
WORD Dithering001(                                          // Number of lines
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Diz,                                     // Type of dither
    WORD           XSize,                                   // Numer of Xpixel
    WORD           XPos,                                    // Start X position for spooling
    WORD           YPos,                                    // Start Y position for spooling
    WORD           YOff,                                    // Y offset(Only for GOSA-KAKUSAN)
    WORD           AllWhite,                                // All white data?
    LPBYTE         lpCMYKBuf,                               // CMYK buffer
    LPBYTE         lpCBuf,                                  // Line buffer(C)
    LPBYTE         lpMBuf,                                  // Line buffer(M)
    LPBYTE         lpYBuf,                                  // Line buffer(Y)
    LPBYTE         lpKBuf                                   // Line buffer(K)
)
{
    DWORD          dizLin = 0;  /* 441436: Assume failing dither => 0 lines */
                                /* NOTE: Nobody uses the return value of Dithering001 */
    LPN4DIZINF     lpN4DizInf;
    LPN403DIZINF   lpN403DizInf;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (AllWhite == Yes) {
        return 1;                                           // Number of line
    }
    if (pOEM->Printer != PRN_N403) {                        // N4 printer
        lpN4DizInf = pOEM->Col.N4.lpDizInf;
        if (Diz == XX_DITHERING_GOSA) {
            dizLin = N4Gos001(lpN4DizInf,
                                 (DWORD)XSize, (DWORD)XPos, (DWORD)YPos, lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
        } else {
            lpN4DizInf->Diz.Num = DizNumTbl[Diz];
            dizLin = N4Diz001(lpN4DizInf,
                                 (DWORD)XSize, (DWORD)XPos, (DWORD)YPos, lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
        }
    } else {                                                // N4-612 printer
        lpN403DizInf = pOEM->Col.N403.lpDizInf;
        lpN403DizInf->Diz.Num = DizNumTbl[Diz];
        if (lpN403DizInf->PrnMod == N403_MOD_300B1 || lpN403DizInf->PrnMod == N403_MOD_600B1) {
            dizLin = N403Diz002(lpN403DizInf,
                                   (DWORD)XSize,
                                   (DWORD)XPos, (DWORD)YPos,
                                   (DWORD)0, (DWORD)0,
                                   (DWORD)1, (DWORD)1,
                                   (DWORD)1, (DWORD)1,
                                   (LPCMYK)lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
/*        } else if (lpN403DizInf->PrnMod == N403_MOD_300B2) {
            dizLin = N403Diz004(lpN403DizInf,
                                   (DWORD)XSize,
                                   (DWORD)XPos, (DWORD)YPos,
                                   (DWORD)0, (DWORD)0,
                                   (DWORD)1, (DWORD)1,
                                   (DWORD)1, (DWORD)1,
                                   (LPCMYK)lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
*/        } else if (lpN403DizInf->PrnMod == N403_MOD_600B2) {
            if (lpN403DizInf->ColMon == N403_MON || Diz == XX_DITHERING_ON) {
                dizLin = N403Diz004(lpN403DizInf,
                                       (DWORD)XSize,
                                       (DWORD)XPos, (DWORD)YPos,
                                       (DWORD)0, (DWORD)0,
                                       (DWORD)1, (DWORD)1,
                                       (DWORD)1, (DWORD)1,
                                       (LPCMYK)lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
            } else if (lpN403DizInf->ColMon == N403_MON || Diz == XX_DITHERING_DET) {
                dizLin = N403DizSml(lpN403DizInf,
                                       (DWORD)XSize,
                                       (DWORD)XPos, (DWORD)YPos,
                                       (DWORD)0, (DWORD)0,
                                       (DWORD)1, (DWORD)1,
                                       (DWORD)1, (DWORD)1,
                                       (LPCMYK)lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
            }
        } else {
            dizLin = N403Diz016(lpN403DizInf,
                                   (DWORD)XSize,
                                   (DWORD)XPos, (DWORD)YPos,
                                   (DWORD)0, (DWORD)0,
                                   (DWORD)1, (DWORD)1,
                                   (DWORD)1, (DWORD)1,
                                   (LPCMYK)lpCMYKBuf, lpCBuf, lpMBuf, lpYBuf, lpKBuf);
        }
    }
    return (WORD)dizLin;
}


//===================================================================================================
//    Spool bitmap data
//===================================================================================================
void BmpPrint(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    LPBMPBIF       lpBmpBuf,                                // Pointer to bitmap buffer structure
    POINT          Pos,                                     // Start position for spooling
    WORD           Width,                                   // Width(dot)
    WORD           Height,                                  // Height(dot)
    WORD           WidthByte                                // Width(byte)
)
{
    DRWBMP         drwBmp;                                  // For Spooling bitmap data structure
    DRWBMPCMYK     drwBmpCMYK;                              // For Spooling CMYK bitmap data structure
    WORD           colCnt;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    static const CMYK colTbl[4] = {                         // CMYK table
        {  0,   0,   0, 255},                               // Black
        {  0,   0, 255,   0},                               // Yellow
        {  0, 255,   0,   0},                               // Magenta
        {255,   0,   0,   0}                                // Cyan
    };

    static const WORD plnTbl[4] = {                         // Plane table
        PLN_BLACK,
        PLN_YELLOW,
        PLN_MGENTA,
        PLN_CYAN
    };
    static const WORD frmTbl[4] = {0, 3, 2, 1};             // Frame table(For N4-612)

                                                            // Not N4-612 printer?
    if (pOEM->Printer != PRN_N403) {
        drwBmp.Style = lpBmpBuf->Style;
        drwBmp.DrawPos = Pos;
        drwBmp.Diz = lpBmpBuf->Diz;
        drwBmp.Width = Width;
        drwBmp.Height = Height;
        drwBmp.WidthByte = WidthByte;
                                                            // Color?
        if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {

            for (colCnt = 0; colCnt < 4; colCnt++) {        // Setting value for spooling bitmap data
                drwBmp.Plane = plnTbl[colCnt];              // For each plane
                drwBmp.Color = colTbl[colCnt];
                drwBmp.lpBit = lpBmpBuf->Drv.Bit.Pnt[colCnt]/* + WidthByte*/;
                PrnBitmap(pdevobj, &drwBmp);                // Spool bitmap data
            }
        } else {                                            // Mono
                                                            // Setting value for spooling bitmap data
            drwBmp.Color = colTbl[0];
            drwBmp.lpBit = lpBmpBuf->Drv.Bit.Pnt[0]/* + WidthByte*/;

            PrnBitmap(pdevobj, &drwBmp);                    // Spool bitmap data

        }
    } else {                                                // N4-612 printer?
        drwBmpCMYK.Style = lpBmpBuf->Style;
        drwBmpCMYK.DataBit = lpBmpBuf->DatBit;
        drwBmpCMYK.DrawPos = Pos;
        drwBmpCMYK.Width = Width;
        drwBmpCMYK.Height = Height;
        drwBmpCMYK.WidthByte = WidthByte;
                                                            // Color?
        if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {

            for (colCnt = 0; colCnt < 4; colCnt++) {        // Setting value for spooling bitmap data
                                                            // For each plane
                drwBmpCMYK.Plane = PLN_ALL;                 // All Plane is OK
                drwBmpCMYK.Frame = frmTbl[colCnt];
                drwBmpCMYK.lpBit = lpBmpBuf->Drv.Bit.Pnt[colCnt]/* + WidthByte*/;
                PrnBitmapCMYK(pdevobj, &drwBmpCMYK);        // Spool bitmap data
            }
        } else {                                            // Mono
                                                            // Setting value for spooling bitmap data
            drwBmpCMYK.Plane = plnTbl[0];
            drwBmpCMYK.Frame = frmTbl[0];
            drwBmpCMYK.lpBit = lpBmpBuf->Drv.Bit.Pnt[0]/* + WidthByte*/;
            PrnBitmapCMYK(pdevobj, &drwBmpCMYK);            // Spool bitmap data
        }
    }
    return;
}


//===================================================================================================
//     Allocate dither table(N4 printer)
//===================================================================================================
BOOL DizTblSetN4(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           Diz                                      // Type of dither
)
{
    DWORD          dizNum;
    LPN4DIZINF     lpN4DizInf;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpN4DizInf = pOEM->Col.N4.lpDizInf;
    dizNum = DizNumTbl[Diz];
    lpN4DizInf->Diz.Num = dizNum;

    if ((lpN4DizInf->Diz.Tbl[dizNum][0] = MemAllocZ(N4_DIZSIZ_CM)) == NULL) {
         return 0;
    }
    if ((lpN4DizInf->Diz.Tbl[dizNum][1] = MemAllocZ(N4_DIZSIZ_CM)) == NULL) {
         return 0;
    }
    if ((lpN4DizInf->Diz.Tbl[dizNum][2] = MemAllocZ(N4_DIZSIZ_YK)) == NULL) {
         return 0;
    }
    if ((lpN4DizInf->Diz.Tbl[dizNum][3] = MemAllocZ(N4_DIZSIZ_YK)) == NULL) {
         return 0;
    }
    N4DizPtnMak(lpN4DizInf, dizNum, dizNum);                // Make dither pattern
    return TRUE;
}


//===================================================================================================
//     Allocate dither table(N4-612 printer)
//===================================================================================================
BOOL DizTblSetN403(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           Diz                                      // Type of dither
)
{
    DWORD          dizNum;
    DWORD          alcSiz;
    WORD           alcCnt;
    WORD           alcTbl;
    LPN403DIZINF   lpN403DizInf;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpN403DizInf = pOEM->Col.N403.lpDizInf;
    dizNum = DizNumTbl[Diz];
    lpN403DizInf->Diz.Num = dizNum;

    if (lpN403DizInf->PrnMod == N403_MOD_300B1 || lpN403DizInf->PrnMod == N403_MOD_600B1) {
        alcSiz = N403_DIZSIZ_B1;
    } else if (/*lpN403DizInf->PrnMod == N403_MOD_300B2 ||*/ lpN403DizInf->PrnMod == N403_MOD_600B2) {
        alcSiz = N403_DIZSIZ_B2;
    } else {
        alcSiz = N403_DIZSIZ_B4;
    }

    if (lpN403DizInf->ColMon == N403_COL && lpN403DizInf->PrnMod == N403_MOD_600B2 && Diz == XX_DITHERING_DET) {
        alcTbl = 1;
    } else {
        alcTbl = 4;
    }
    for (alcCnt = 0; alcCnt < alcTbl; alcCnt++) {
        if ((lpN403DizInf->Diz.Tbl[dizNum][alcCnt] = MemAllocZ(alcSiz)) == NULL) {
            ERR(("DizTbl ALLOC ERROR!!\n"));
            return 0;
        }
    }

    if (lpN403DizInf->ColMon == N403_COL && lpN403DizInf->PrnMod == N403_MOD_600B2) {
        alcSiz = N403_ENTDIZSIZ_B2;
        for (alcCnt = 0; alcCnt < 4; alcCnt++) {
            if ((lpN403DizInf->EntDiz.Tbl[alcCnt] = MemAllocZ(alcSiz)) == NULL) {
                ERR(("EntDizTbl ALLOC ERROR!!\n"));
                return 0;
            }
        }
    }
    N403DizPtnMak(lpN403DizInf, dizNum, dizNum);            // Make dither pattern
    return TRUE;
}


//===================================================================================================
//    Load LUT file(For N4 printer)
//===================================================================================================
BOOL LutFileLoadN4(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           Mch,                                     // Type of color match
    WORD           Diz,                                     // Type of dither
    WORD           Speed                                    // speed?
)
{
    HANDLE         fp_Lut;
    OFSTRUCT       opeBuf;
    WORD           setCnt;
    LPBYTE         lpDst;
    LPN4DIZINF     lpN4DizInf;
    DWORD          nSize;
    WCHAR          LutName[MAX_PATH], *pTemp;
    int            i;

    BOOL           bRet;
    DWORD          dwRet;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    nSize = GetModuleFileName(pdevobj->hOEM, LutName, MAX_PATH);
    nSize -= (sizeof (CSN46RESDLL) / sizeof (WCHAR) - 1);

    // Choice of LUT file
    pTemp = N4LUT000;           // Default value.
    if (Mch == XX_COLORMATCH_NORMAL) {
        if (Diz != XX_DITHERING_GOSA) {
            pTemp = N4LUT000;
        } else {
            pTemp = N4LUT003;
        }
    } else if (Mch == XX_COLORMATCH_VIVCOL) {
        if (Diz != XX_DITHERING_GOSA) {
            pTemp = N4LUT001;
        } else {
            pTemp = N4LUT004;
        }
    } else if (Mch == XX_COLORMATCH_NATCOL) {
        if (Diz != XX_DITHERING_GOSA) {
            pTemp = N4LUT002;
        } else {
            pTemp = N4LUT005;
        }
    }

    lstrcpy(&LutName[nSize], pTemp);

    CM_VERBOSE(("n403 Newbuf--> %ws\n", LutName));

    // Open LUT file
    if (INVALID_HANDLE_VALUE == (fp_Lut = CreateFile(LutName,
            GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))) {

        ERR(("Error opening LUT file %ws (%d)\n",
                LutName, GetLastError()));
        return 0;
    }

    lpN4DizInf = pOEM->Col.N4.lpDizInf;

    if ((lpN4DizInf->Lut.Tbl = MemAllocZ((DWORD)N4_LUTTBLSIZ)) == NULL) {
        CloseHandle(fp_Lut);    /* 441434 */
        return 0;
    }
    lpDst = (LPBYTE)(lpN4DizInf->Lut.Tbl);
                                                            // Load LUT data
    for(setCnt = 0 ; setCnt < (N4_GLDNUM / 8) ; setCnt++) {

        if (FALSE == ReadFile(fp_Lut,
                &lpDst[(DWORD)setCnt * 8L * N4_GLDNUM * N4_GLDNUM * 4L],
                (8L * N4_GLDNUM * N4_GLDNUM * 4L), &dwRet, NULL)
            || 0 == dwRet) {

            ERR(("Error reading LUT file %ws (%d)\n",
                    LutName, GetLastError()));

            // Abort
            CloseHandle(fp_Lut);
            return FALSE;
        }
    }

    // Close LUT file
    if (FALSE == CloseHandle(fp_Lut)) {
        ERR(("Error closing LUT file %ws (%d)\n",
                LutName, GetLastError()));
    }

    if (Speed == No) {
        if ((lpN4DizInf->Lut.CchRgb = MemAllocZ(N4_CCHRGBSIZ)) == NULL) {
            return 0;
        }
        if ((lpN4DizInf->Lut.CchCmy = MemAllocZ(N4_CCHCMYSIZ)) == NULL) {
            return 0;
        }
        memset(lpN4DizInf->Lut.CchRgb, 0xff, N4_CCHRGBSIZ);
        memset(lpN4DizInf->Lut.CchCmy, 0x00, N4_CCHCMYSIZ);
    }
    return TRUE;
}


//===================================================================================================
//    Load LUT file(For N4-612 printer)
//===================================================================================================
BOOL LutFileLoadN403(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           Mch,                                     // Type of color matching
    WORD           Speed
)
{
    HANDLE         fp_Lut;
    OFSTRUCT       opeBuf;
    WORD           setCnt;
    LPBYTE         lpDst;
    LPN403DIZINF   lpN403DizInf;
    DWORD          nSize;
    WCHAR          LutName[MAX_PATH], *pTemp;
    int            i;

    BOOL           bRet;
    DWORD          dwRet;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    nSize = GetModuleFileName(pdevobj->hOEM, LutName, MAX_PATH);
    nSize -= (sizeof (CSN46RESDLL) / sizeof (WCHAR) - 1);

    // Choice of LUT file
    if (Mch == XX_COLORMATCH_IRO) {
        pTemp = N403LUTY;
    } else {
        pTemp = N403LUTX;
    }

    lstrcpy(&LutName[nSize], pTemp);

    CM_VERBOSE(("n403 Newbuf--> %ws\n", LutName));

    // Open LUT file
    if (INVALID_HANDLE_VALUE == (fp_Lut = CreateFile( LutName,
            GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))) {

        ERR(("Error opening LUT file %ws (%d)\n",
                LutName, GetLastError()));
        return 0;
    }

    lpN403DizInf = pOEM->Col.N403.lpDizInf;

    if ((lpN403DizInf->Lut.Tbl = MemAllocZ((DWORD)N403_LUTTBLSIZ))== NULL) {
        CloseHandle(fp_Lut);    /* 441433 */
        return 0;
    }
    lpDst = (LPBYTE)(lpN403DizInf->Lut.Tbl);
                                                            // Load LUT data
    for(setCnt = 0 ; setCnt < (N403_GLDNUM / 8) ; setCnt++) {

        if (FALSE == ReadFile(fp_Lut,
                &lpDst[(DWORD)setCnt * 8L * N403_GLDNUM * N403_GLDNUM * 4L],
                (8L * N403_GLDNUM * N403_GLDNUM * 4L), &dwRet, NULL)
            || 0 == dwRet) {

            ERR(("Error reading LUT file %ws (%d)\n",
                    LutName, GetLastError()));

            // Abort
            CloseHandle(fp_Lut);
            return FALSE;
        }
    }

    // Close LUT file
    if (FALSE == CloseHandle(fp_Lut)) {
        ERR(("Error closing LUT file %ws (%d)\n",
                LutName, GetLastError()));
    }

    if (Speed == No) {
        if ((lpN403DizInf->Lut.CchRgb = MemAllocZ(N403_CCHRGBSIZ)) == NULL) {
            return 0;
        }
        if ((lpN403DizInf->Lut.CchCmy = MemAllocZ(N403_CCHCMYSIZ)) == NULL) {
            return 0;
        }
        memset(lpN403DizInf->Lut.CchRgb, 0xff, N403_CCHRGBSIZ);
        memset(lpN403DizInf->Lut.CchCmy, 0x00, N403_CCHCMYSIZ);
    }
    return TRUE;
}


//===================================================================================================
//    Allocate toner density table(For N4 printer)
//===================================================================================================
BOOL TnrTblSetN4(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    SHORT          Tnr                                      // Toner density(-30~30)
)
{
    LPN4DIZINF     lpN4DizInf;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpN4DizInf = pOEM->Col.N4.lpDizInf;
    if ((lpN4DizInf->Tnr.Tbl = MemAllocZ(N4_TNRTBLSIZ)) == NULL) {
        return 0;
    }

    N4TnrTblMak(lpN4DizInf, (LONG)Tnr);
    return TRUE;
}


//===================================================================================================
//    Allocate toner density table(For N4-612 printer)
//===================================================================================================
BOOL TnrTblSetN403(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    SHORT          Tnr                                      // Toner density(-30~30)
)
{
    LPN403DIZINF   lpN403DizInf;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpN403DizInf = pOEM->Col.N403.lpDizInf;

    if ((lpN403DizInf->Tnr.Tbl = MemAllocZ(N403_TNRTBLSIZ)) == NULL) {
        return 0;
    }

    N403TnrTblMak(lpN403DizInf, (LONG)Tnr);
    return TRUE;
}


//===================================================================================================
//    Convert 1 line RGB bitmap data into  24bit (for 1pixel) RGB bitmap data
//===================================================================================================
void BmpRGBCnv(
    LPRGB          lpRGB,                                   // Pointer to destination bitmap data
    LPBYTE         lpSrc,                                   // Pointer to source bitmap data
    WORD           SrcBit,                                  // Pixel of source bitmap data
    WORD           SrcX,                                    // X coordinates of source bitmap data
    WORD           SrcXSiz,                                 // X size of source bitmap data
    LPRGBQUAD      lpPlt                                    // Color palette table of source bitmap data(1/4/8pixel)
)
{
    WORD           setCnt;
    BYTE           colNum;
    LPWORD         lpWSrc;

    switch (SrcBit) {
        case 1:                                             // 1 bit
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, SrcX++) {
                                                            // Foreground color?
                if (!(lpSrc[SrcX / 8] & BitTbl[SrcX & 0x0007])) {
                    lpRGB[setCnt].Blue  = lpPlt[0].rgbBlue;
                    lpRGB[setCnt].Green = lpPlt[0].rgbGreen;
                    lpRGB[setCnt].Red   = lpPlt[0].rgbRed;
                } else {
                    lpRGB[setCnt].Blue  = lpPlt[1].rgbBlue;
                    lpRGB[setCnt].Green = lpPlt[1].rgbGreen;
                    lpRGB[setCnt].Red   = lpPlt[1].rgbRed;
                }
            }
            break;
        case 4:                                             // 4bit
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, SrcX++) {
                if (!(SrcX & 0x0001)) {                     // A even number coordinates?
                    colNum = lpSrc[SrcX / 2] / 16;
                } else {
                    colNum = lpSrc[SrcX / 2] % 16;
                }
                lpRGB[setCnt].Blue  = lpPlt[colNum].rgbBlue;
                lpRGB[setCnt].Green = lpPlt[colNum].rgbGreen;
                lpRGB[setCnt].Red   = lpPlt[colNum].rgbRed;
            }
            break;
        case 8:                                             // 8bit
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, SrcX++) {
                colNum = lpSrc[SrcX];
                lpRGB[setCnt].Blue  = lpPlt[colNum].rgbBlue;
                lpRGB[setCnt].Green = lpPlt[colNum].rgbGreen;
                lpRGB[setCnt].Red   = lpPlt[colNum].rgbRed;
            }
            break;
        case 16:                                            // 16bit
            lpWSrc = (LPWORD)lpSrc + SrcX;
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, lpWSrc++) {
                lpRGB[setCnt].Blue  = (BYTE)((*lpWSrc & 0x001f) << 3);
                lpRGB[setCnt].Green = (BYTE)((*lpWSrc & 0x03e0) >> 2);
                lpRGB[setCnt].Red   = (BYTE)((*lpWSrc / 0x0400) << 3);
            }
            break;
        case 24:                                            // 24 bit
            lpSrc += SrcX * 3;
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, lpSrc += 3) {
                lpRGB[setCnt].Red    = lpSrc[0];
                lpRGB[setCnt].Green    = lpSrc[1];
                lpRGB[setCnt].Blue    = lpSrc[2];
//                lpRGB[setCnt].Blue    = lpSrc[0];
//                lpRGB[setCnt].Green    = lpSrc[1];
//                lpRGB[setCnt].Red    = lpSrc[2];
            }
//            memcpy(lpRGB, lpSrc, SrcXSiz * 3);
            break;
        case 32:                                            // 32bit
            lpSrc += SrcX * 4;
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, lpSrc += 4) {
                lpRGB[setCnt].Blue  = lpSrc[0];
                lpRGB[setCnt].Green = lpSrc[1];
                lpRGB[setCnt].Red   = lpSrc[2];
            }
            break;
    }
    return;
}



// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\colordef.h ===
//***************************************************************************************************
//    COLORDEF.H
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Structure for RGB Color
//---------------------------------------------------------------------------------------------------
typedef DWORD         COLORREF;
typedef struct {
    BYTE        Blue;                                       // Density 0`255
    BYTE        Green;                                      // 
    BYTE        Red;                                        // 
} RGBS, FAR *LPRGB;

//---------------------------------------------------------------------------------------------------
//    Structure for CMYK Color
//---------------------------------------------------------------------------------------------------
typedef struct {
    BYTE        Cyn;                                        // Density 0`255
    BYTE        Mgt;                                        // 
    BYTE        Yel;                                        // 
    BYTE        Bla;                                        // 
} CMYK, FAR *LPCMYK;

//---------------------------------------------------------------------------------------------------
//    Color number
//---------------------------------------------------------------------------------------------------
#define    BLACK           0
#define    YELLOW          1
#define    MGENTA          2
#define    CYAN            3


//    End of COLORDEF.H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "PDEV.H"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{

public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE(("IOemCB: QueryInterface entry\n"));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE(("IOemCB:Return pointer to IUnknown.\n")); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE(("IOemCB:Return pointer to IPrintOemUni.\n")); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE(("IOemCB:Return NULL.\n")); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE(("IOemCB::AddRef() entry.\n"));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE(("IOemCB::Release() entry.\n"));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE(("IOemCB::GetInfo() entry.\n"));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE(("IOemCB::DevMode() entry.\n"));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE(("IOemCB::EnableDriver() entry.\n"));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE(("IOemCB::DisaleDriver() entry.\n"));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE(("IOemCB::EnablePDEV() entry.\n"));

        *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName,
            cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo,
            cjDevInfo, pDevInfo, pded);

        if (*pDevOem)
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE(("IOemCB::DisablePDEV() entry.\n"));

        OEMDisablePDEV(pdevobj);

        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
//      VERBOSE(("IOemCB::ResetPDEV() entry.\n"));
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE(("IOemCB::PublishDriverInterface() entry.\n"));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE(("IOemCB::GetImplementedMethod() entry.\n"));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE(("IOemCB::CommandCallback() entry.\n"));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE(("IOemCB::ImageProcessing() entry.\n"));

        *ppbResult = OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable, dwCallbackID, pIPParams);

        return S_OK;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE(("IOemCB::FilterGraphis() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE(("IOemCB::Compression() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE(("IOemCB::HalftonePattern() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE(("IOemCB::MemoryUsage() entry.\n"));

        OEMMemoryUsage(pdevobj, pMemoryUsage);

        return S_OK;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::DownloadFontHeader() entry.\n"));

#if DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::DownloadCharGlyph() entry.\n"));

#if DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::TTDownloadMethod() entry.\n"));
#if DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE(("IOemCB::OutputCharStr() entry.\n"));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE(("IOemCB::SendFontCmd() entry.\n"));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE(("IOemCB::DriverDMS() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE(("IOemCB::TextOutAsBitmap() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE(("IOemCB::TTYGetInfo() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE(("IOemCF::CreateInstance() called\n."));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE(("DllGetClassObject:\tCreate class factory."));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\n403diz.h ===
//***************************************************************************************************
//    N403DIZ.H
//
//    C Header (Functions of dither and color matching (For N4-612 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************

//***************************************************************************************************
//    Data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Color/Monochrome
//---------------------------------------------------------------------------------------------------
#define    N403_COL            0
#define    N403_MON            1

//---------------------------------------------------------------------------------------------------
//    Printer mode
//---------------------------------------------------------------------------------------------------
#define    N403_MOD_300B1        0
#define    N403_MOD_300B2        1
#define    N403_MOD_300B4        2
#define    N403_MOD_600B1        3
#define    N403_MOD_600B2        4

//---------------------------------------------------------------------------------------------------
//    Type of dithering
//---------------------------------------------------------------------------------------------------
#define    N403_DIZ_SML        0
#define    N403_DIZ_MID        1
#define    N403_DIZ_RUG        2

//---------------------------------------------------------------------------------------------------
//    Dither pattern
//---------------------------------------------------------------------------------------------------
#define    N403_ALLDIZNUM        64
#define    N403_DIZSPC            4

//---------------------------------------------------------------------------------------------------
//    size of each table
//---------------------------------------------------------------------------------------------------
#define    N403_DIZSIZ_B1        (32 * 32)                  // dither table size (2value)
#define    N403_DIZSIZ_B2        (16 * 16 *  3)             // dither table size (4value)
#define    N403_DIZSIZ_B4        ( 8 *  8 * 15)             // dither table size (16value)
#define    N403_ENTDIZSIZ_B2    (16 * 16 *  3)              // entry dither table size (4value)
#define    N403_TNRTBLSIZ        256                        // toner density table size
#define    N403_GLDNUM            32                        // LUT table grid
#define    N403_GLDSPC            8                         // LUT table grid interval
                                                            // LUT table size
#define    N403_LUTTBLSIZ        ((DWORD)N403_GLDNUM * N403_GLDNUM * N403_GLDNUM * sizeof(CMYK))
#define    N403_CCHNUM            256                            // Number of cache tables
#define    N403_CCHRGBSIZ        (N403_CCHNUM * sizeof(RGBS))    // Cache table size(RGB)
#define    N403_CCHCMYSIZ        (N403_CCHNUM * sizeof(CMYK))    // Cache table size(CMYK)


//---------------------------------------------------------------------------------------------------
//    Structure for control dithering and color-matching
//---------------------------------------------------------------------------------------------------
typedef    struct {
    DWORD        ColMon;                                    // Color/Monochrome
    DWORD        PrnMod;                                    // Printermode
    struct {                                                // Structure for dither pattern
        DWORD        Num;                                   // Table current number(0`2)
        LPBYTE       Tbl[3][4];                             // Data table
    } Diz;
    struct {                                                // Structure for entry dither pattern
        LPBYTE       Tbl[4];                                // Data table
    } EntDiz;
    struct {                                                // Structure for toner density table
        LPBYTE       Tbl;                                   // Data table
    } Tnr;
    struct {                                                // Structure for LUT table 
        LPCMYK       Tbl;                                   // Data table
        LPRGB        CchRgb;                                // Cache table(RGB)
        LPCMYK       CchCmy;                                // Cache table(CMYK)
    } Lut;
    DWORD        DizSiz[4];                                 // dither pattern size
} N403DIZINF, *LPN403DIZINF;



//***************************************************************************************************
//    Functions
//***************************************************************************************************
VOID WINAPI N403DizPtnMak(LPN403DIZINF, DWORD, DWORD);
VOID WINAPI N403TnrTblMak(LPN403DIZINF, LONG);
DWORD WINAPI N403Diz002(LPN403DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCMYK, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N403Diz004(LPN403DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCMYK, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N403Diz016(LPN403DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCMYK, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N403DizSml(LPN403DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCMYK, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N403DizPrn(LPN403DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPCMYK, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
VOID WINAPI N403ColMch000(LPN403DIZINF, LPRGB, LPCMYK, DWORD, DWORD);
VOID WINAPI N403ColMch001(LPN403DIZINF, LPRGB, LPCMYK, DWORD, DWORD);
VOID WINAPI N403ColVivPrc(LPN403DIZINF, LPCMYK, DWORD, DWORD);
VOID WINAPI N403ColCnvSld(LPN403DIZINF, LPRGB, LPCMYK, DWORD, DWORD);
VOID WINAPI N403ColCnvL02(LPN403DIZINF, LPRGB, LPCMYK, DWORD);
VOID WINAPI N403ColCnvMon(LPN403DIZINF, LPRGB, LPCMYK, DWORD);


//    End of N403DIZ.H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\n403diz.c ===
//***************************************************************************************************
//    N403DIZ.C
//
//    Functions of dither and color matching (For N4-612 printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "PDEV.H"

static    BYTE            InnTblCmy[256];
/*----------------------------------------------------------------------------
    Pattern original(300dpi)
----------------------------------------------------------------------------*/
/*---- magenta(cyan) ----*/
//const static BYTE        StrMgt002 = 16;
static BYTE        StrMgt002 = 16;
//const static BYTE        MgtTil302[4][4] = {
static BYTE        MgtTil302[4][4] = {
    {  6,  4, 14, 12 },
    { 10,  8,  3,  1 },
    { 15, 13,  7,  5 },
    {  2,  0, 11,  9 }
};
/*---- yellow ----*/
//const static BYTE        YelTil302[4][4] = {
static BYTE        YelTil302[4][4] = {
    { 15, 13,  7,  5 },
    {  2,  0, 11,  9 },
    {  6,  4, 14, 12 },
    { 10,  8,  3,  1 }
};
/*---- black ----*/
//const static BYTE        BlaTil302[4][4] = {
static BYTE        BlaTil302[4][4] = {
    {  6,  4, 14, 12 },
    { 10,  8,  3,  1 },
    { 15, 13,  7,  5 },
    {  2,  0, 11,  9 }
};
/*----------------------------------------------------------------------------
    Pattern original(300dpi)
----------------------------------------------------------------------------*/
/*---- magenta (cyan) ----*/
//const static BYTE        MgtTil304[5][5][3] = {
static BYTE        MgtTil304[5][5][3] = {
    { {27,37,47},{10,20,30},{ 0, 5,15},{58,68,73},{42,52,62} },
    { {59,69,74},{40,50,60},{25,35,45},{13,23,33},{ 3, 8,18} },
    { {14,24,34},{ 4, 9,19},{56,66,71},{43,53,63},{28,38,48} },
    { {44,54,64},{29,39,49},{11,21,31},{ 1, 6,16},{57,67,72} },
    { { 2, 7,17},{55,65,70},{41,51,61},{26,36,46},{12,22,32} }
};
/*---- yellow ----*/
//const static BYTE        YelTil304[4][4][3] = {
static BYTE        YelTil304[4][4][3] = {
    { {32,40,44},{ 8,16,24},{34,42,46},{10,18,26} },
    { { 0, 4,12},{20,28,36},{ 2, 6,14},{22,30,38} },
    { {35,43,47},{11,19,27},{33,41,45},{ 9,17,25} },
    { { 3, 7,15},{23,31,39},{ 1, 5,13},{21,29,37} }

};
/*---- black ----*/
//const static BYTE        BlaTil304[4][4][3] = {
static BYTE        BlaTil304[4][4][3] = {
    { { 0, 4,12},{20,28,36},{ 1, 5,13},{21,29,37} },
    { {32,40,44},{ 8,16,24},{33,41,45},{ 9,17,25} },
    { { 3, 7,15},{23,31,39},{ 2, 6,14},{22,30,38} },
    { {35,43,47},{11,19,27},{34,42,46},{10,18,26} }
};
/*----------------------------------------------------------------------------
    Pattern original(300dpi)
----------------------------------------------------------------------------*/
/*---- magenta(cyan) ----*/
//const static BYTE        MgtTil316[5][5] = {
static BYTE        MgtTil316[5][5] = {
    { 12,  5,  0, 23, 17 },
    { 24, 15, 10,  8,  3 },
    {  9,  4, 21, 18, 13 },
    { 19, 14,  6,  1, 22 },
    {  2, 20, 16, 11,  7 }
};
/*---- yellow ----*/
//const static BYTE        YelTil316[4][4] = {
static BYTE        YelTil316[4][4] = {
//    { 12,  4, 14,  6 },
//    {  0,  8,  2, 10 },
//    { 15,  7, 13,  5 },
//    {  3, 11,  1,  9 }
    {  6,  4, 15, 13 },
    { 10,  8,  3,  1 },
    { 14, 12,  7,  5 },
    {  2,  0, 11,  9 }
};
/*---- black ----*/
//const static BYTE        BlaTil316[4][4] = {
static BYTE        BlaTil316[4][4] = {
    {  0,  8,  1,  9 },
    { 12,  4, 13,  5 },
    {  3, 11,  2, 10 },
    { 15,  7, 14,  6 }
};
/*----------------------------------------------------------------------------
    Pattern original(600dpi)
----------------------------------------------------------------------------*/
/*---- cyan ----*/
//const static BYTE        CynTil600[10][10] = {
static BYTE        CynTil600[10][10] = {
    {  4, 24, 72, 57, 37, 77, 94, 99, 54,  9 },
    { 14, 44, 80, 85, 65, 25, 45, 60, 34, 19 },
    { 39, 79, 90, 95, 50,  5,  0, 20, 74, 59 },
    { 66, 26, 46, 61, 30, 15, 10, 40, 81, 86 },
    { 51,  6,  1, 21, 70, 55, 35, 75, 91, 96 },
    { 31, 16, 11, 41, 83, 88, 68, 28, 48, 63 },
    { 71, 56, 36, 76, 93, 98, 53,  8,  3, 23 },
    { 82, 87, 67, 27, 47, 62, 33, 18, 13, 43 },
    { 92, 97, 52,  7,  2, 22, 73, 58, 38, 78 },
    { 49, 64, 32, 17, 12, 42, 84, 89, 69, 29 }

};
/*---- magenta ----*/
//const static BYTE        MgtTil600[10][10] = {
static BYTE        MgtTil600[10][10] = {
    {  4, 54, 99, 94, 77, 37, 57, 72, 24,  9 },
    { 14, 34, 60, 45, 25, 65, 85, 80, 44, 19 },
    { 59, 74, 20,  5,  0, 50, 95, 90, 79, 39 },
    { 86, 81, 40, 15, 10, 30, 61, 46, 26, 66 },
    { 96, 91, 75, 35, 55, 70, 21,  6,  1, 51 },
    { 63, 48, 28, 68, 88, 83, 41, 16, 11, 31 },
    { 23,  8,  3, 53, 98, 93, 76, 36, 56, 71 },
    { 43, 18, 13, 33, 62, 47, 27, 67, 87, 82 },
    { 78, 38, 58, 73, 22,  7,  2, 52, 97, 92 },
    { 29, 69, 89, 84, 42, 17, 12, 32, 64, 49 }

};
/*---- yellow ----*/
//const static BYTE        YelTil600[6][6] = {
static BYTE        YelTil600[6][6] = {
//    {  5, 17, 35, 33, 21,  7 },
//    { 27,  8, 22, 14, 10, 19 },
//    { 30, 12,  2,  0, 24, 28 },
//    { 32, 20,  6,  4, 16, 34 },
//    { 15, 11, 18, 26,  9, 23 },
//    {  1, 25, 29, 31, 13,  3 }

    /* for smoothing */
    {  5, 13, 31, 29, 15,  7 },
    {  9, 21, 35, 33, 23, 11 },
    { 24, 16,  2,  0, 18, 26 },
    { 28, 14,  6,  4, 12, 30 },
    { 32, 22, 10,  8, 20, 34 },
    {  1, 19, 27, 25, 17,  3 }
};
/*---- black ----*/
//const static BYTE        BlaTil600[4][4] = {
static BYTE        BlaTil600[4][4] = {
    { 12,  9,  5, 13 },
    {  4,  1,  0, 10 },
    {  8,  3,  2,  6 },
    { 15,  7, 11, 14 }
};
/*----------------------------------------------------------------------------
    Pattern original(600dpi)
----------------------------------------------------------------------------*/
//const static BYTE DizPatPrn[4][64] = {
static BYTE DizPatPrn[4][64] = {
    /*---- cyan ----*/
    {  61, 45, 20, 12,  8, 28, 41, 57,
        1, 25, 36, 52, 48, 32, 17,  5,
        9, 29, 43, 59, 63, 47, 21, 13,
       49, 33, 19,  7,  3, 27, 37, 53,
       62, 46, 23, 15, 11, 31, 42, 58,
        2, 26, 39, 55, 51, 35, 18,  6,
       10, 30, 40, 56, 60, 44, 22, 14,
       50, 34, 16,  4,  0, 24, 38, 54    },
    /*---- magenta ----*/
    {  49, 13,  9, 61, 50, 14, 10, 62,
       33, 29, 25, 45, 34, 30, 26, 46,
       16, 40, 39, 23, 19, 43, 36, 20,
        0, 56, 55,  7,  3, 59, 52,  4,
        8, 60, 51, 15, 11, 63, 48, 12,
       24, 44, 35, 31, 27, 47, 32, 28,
       37, 21, 17, 41, 38, 22, 18, 42,
       53,  5,  1, 57, 54,  6,  2, 58    },
    /*---- yellow ----*/
    {  48, 36, 20, 52, 50, 38, 22, 54,
       16,  4,  0, 40, 18,  6,  2, 42,
       32, 12,  8, 24, 34, 14, 10, 26,
       60, 28, 44, 56, 62, 30, 46, 58,
       51, 39, 23, 55, 49, 37, 21, 53,
       19,  7,  3, 43, 17,  5,  1, 41,
       35, 15, 11, 27, 33, 13,  9, 25,
       63, 31, 47, 59, 61, 29, 45, 57    },
    /*---- black ----*/
    {   9, 25, 35, 15, 11, 27, 33, 13,
       45, 57, 63, 31, 47, 59, 61, 29,
       22, 54, 48, 36, 20, 52, 50, 38,
        2, 42, 16,  4,  0, 40, 18,  6,
       10, 26, 32, 12,  8, 24, 34, 14,
       46, 58, 60, 28, 44, 56, 62, 30,
       21, 53, 51, 39, 23, 55, 49, 37,
        1, 41, 19,  7,  3, 43, 17,  5    }
};
/*----------------------------------------------------------------------------
    Pattern original(monochrome)
----------------------------------------------------------------------------*/
//const static BYTE        Mon4x4Bun[8 * 8] = {
static BYTE        Mon4x4Bun[8 * 8] = {
     0,    32,     8,    40,     2,    34,    10,    42,
    48,    16,    56,    24,    50,    18,    58,    26,
    12,    44,     4,    36,    14,    46,     6,    38,
    60,    28,    52,    20,    62,    30,    54,    22,
     3,    35,    11,    43,     1,    33,     9,    41,
    51,    19,    59,    27,    49,    17,    57,    25,
    15,    47,     7,    39,    13,    45,     5,    37,
    63,    31,    55,    23,    61,    29,    53,    21
};
//const static BYTE        Mon4x4Ami[8 * 8] = {
static BYTE        Mon4x4Ami[8 * 8] = {
     8,  0, 56, 48, 10,  2, 58, 50,
    40, 32, 28, 20, 42, 34, 30, 22,
    60, 52, 12,  4, 62, 54, 14,  6,
    24, 16, 44, 36, 26, 18, 46, 38,
    11,  3, 59, 51,  9,  1, 57, 49,
    43, 35, 31, 23, 41, 33, 29, 21,
    63, 55, 15,  7, 61, 53, 13,  5,
    27, 19, 47, 39, 25, 17, 45, 37
};
//const static BYTE        Mon4x4Syu[8 * 8] = {
static BYTE        Mon4x4Syu[8 * 8] = {
    48, 36, 20, 52, 50, 38, 22, 54,
    16,  4,  0, 40, 18,  6,  2, 42,
    32, 12,  8, 24, 34, 14, 10, 26,
    60, 28, 44, 56, 62, 30, 46, 58,
    51, 39, 23, 55, 49, 37, 21, 53,
    19,  7,  3, 43, 17,  5,  1, 41,
    35, 15, 11, 27, 33, 13,  9, 25,
    63, 31, 47, 59, 61, 29, 45, 57
};
//const static BYTE        Mon8x8Ami[8 * 8] = {
static BYTE        Mon8x8Ami[8 * 8] = {
     7, 13, 39, 59, 58, 43, 17,  5,
    23, 31, 49, 44, 36, 50, 25, 15,
    41, 52, 26, 18, 10, 28, 53, 33,
    61, 34,  8,  2,  0, 20, 46, 60,
    62, 42, 16,  6,  4, 12, 38, 63,
    37, 55, 24, 14, 22, 30, 54, 45,
    11, 29, 48, 32, 40, 51, 27, 19,
     3, 21, 47, 56, 57, 35,  9,  1
};
//const static BYTE        Mon8x8Syu[8 * 8] = {
static BYTE        Mon8x8Syu[8 * 8] = {
    60, 57, 49, 34, 33, 45, 53, 61,
    52, 40, 29, 21, 17, 25, 41, 58,
    44, 24, 12,  9,  5, 13, 30, 50,
    32, 16,  4,  1,  0, 10, 22, 38,
    36, 20,  8,  3,  2,  6, 18, 34,
    48, 28, 15,  7, 11, 14, 26, 46,
    56, 43, 27, 19, 23, 31, 42, 54,
    63, 55, 47, 35, 39, 51, 59, 62
};
/*----------------------------------------------------------------------------
    pattern disposition table
----------------------------------------------------------------------------*/
//const static BYTE    MgtTilNum[17] = {
static BYTE    MgtTilNum[17] = {
    2, 11, 13, 4, 15, 6, 3, 12, 1, 10, 16, 7, 14, 5, 8, 0, 9
};
//const static BYTE Bun6x6All[36] = {
static BYTE Bun6x6All[36] = {
      0, 32,  8,  2, 34, 10,
     20, 16, 28, 22, 18, 30,
     12, 24,  4, 14, 26,  6,
      3, 35, 11,  1, 33,  9,
     23, 19, 31, 21, 17, 29,
     15, 27,  7, 13, 25,  5
};
//const static BYTE Bun4x4All[16] = {
static BYTE Bun4x4All[16] = {
      0,  8,  2, 10,
     12,  4, 14 , 6,
      3, 11,  1,  9,
     15,  7, 13,  5
};
//const static BYTE Bun3x3All[9] = {
static BYTE Bun3x3All[9] = {
      8,  3,  6,
      2,  4,  0,
      5,  1,  7
};
//const static BYTE Bun2x2All[4] = {
static BYTE Bun2x2All[4] = {
      0,  2,
      3,  1
};


/*============================================================================
    dot gain revision table
============================================================================*/
//const static BYTE GinTblP05[256] = {
static BYTE GinTblP05[256] = {
    /* 00 */    0x00,0x01,0x02,0x03,0x04,0x06,0x07,0x08,
    /* 08 */    0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x11,
    /* 10 */    0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,
    /* 18 */    0x1a,0x1c,0x1d,0x1e,0x1f,0x20,0x21,0x22,
    /* 20 */    0x23,0x24,0x25,0x27,0x28,0x29,0x2a,0x2b,
    /* 28 */    0x2c,0x2d,0x2e,0x2f,0x30,0x32,0x33,0x34,
    /* 30 */    0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,
    /* 38 */    0x3e,0x3f,0x40,0x41,0x42,0x43,0x44,0x45,
    /* 40 */    0x46,0x47,0x48,0x4a,0x4b,0x4c,0x4d,0x4e,
    /* 48 */    0x4f,0x50,0x51,0x52,0x53,0x54,0x56,0x57,
    /* 50 */    0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
    /* 58 */    0x60,0x61,0x62,0x63,0x65,0x66,0x67,0x68,
    /* 60 */    0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,0x70,
    /* 68 */    0x71,0x72,0x73,0x74,0x76,0x77,0x78,0x79,
    /* 70 */    0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,0x80,0x81,
    /* 78 */    0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
    /* 80 */    0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,
    /* 88 */    0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,
    /* 90 */    0x9a,0x9b,0x9c,0x9c,0x9d,0x9e,0x9f,0xa0,
    /* 98 */    0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,
    /* a0 */    0xa9,0xaa,0xab,0xac,0xac,0xad,0xae,0xaf,
    /* a8 */    0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,
    /* b0 */    0xb8,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,
    /* b8 */    0xbf,0xc0,0xc1,0xc2,0xc3,0xc3,0xc4,0xc5,
    /* c0 */    0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,
    /* c8 */    0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,
    /* d0 */    0xd5,0xd6,0xd7,0xd7,0xd8,0xd9,0xda,0xdb,
    /* d8 */    0xdc,0xdd,0xde,0xdf,0xe0,0xe0,0xe1,0xe2,
    /* e0 */    0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xe9,
    /* e8 */    0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,
    /* f0 */    0xf2,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
    /* f8 */    0xf9,0xfa,0xfb,0xfb,0xfc,0xfd,0xfe,0xff
};
//const static BYTE GinTblP10[256] = {
static BYTE GinTblP10[256] = {
    /* 00 */    0x00,0x01,0x02,0x04,0x05,0x06,0x07,0x09,
    /* 08 */    0x0a,0x0b,0x0c,0x0d,0x0f,0x10,0x11,0x12,
    /* 10 */    0x13,0x15,0x16,0x17,0x18,0x1a,0x1b,0x1c,
    /* 18 */    0x1d,0x1e,0x20,0x21,0x22,0x23,0x24,0x26,
    /* 20 */    0x27,0x28,0x29,0x2b,0x2c,0x2d,0x2e,0x2f,
    /* 28 */    0x31,0x32,0x33,0x34,0x35,0x37,0x38,0x39,
    /* 30 */    0x3a,0x3b,0x3d,0x3e,0x3f,0x40,0x41,0x43,
    /* 38 */    0x44,0x45,0x46,0x47,0x48,0x4a,0x4b,0x4c,
    /* 40 */    0x4d,0x4e,0x50,0x51,0x52,0x53,0x54,0x55,
    /* 48 */    0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5e,0x5f,
    /* 50 */    0x60,0x61,0x62,0x63,0x65,0x66,0x67,0x68,
    /* 58 */    0x69,0x6a,0x6b,0x6d,0x6e,0x6f,0x70,0x71,
    /* 60 */    0x72,0x73,0x74,0x76,0x77,0x78,0x79,0x7a,
    /* 68 */    0x7b,0x7c,0x7d,0x7e,0x7f,0x81,0x82,0x83,
    /* 70 */    0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,
    /* 78 */    0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,
    /* 80 */    0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,
    /* 88 */    0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,
    /* 90 */    0xa3,0xa4,0xa5,0xa5,0xa6,0xa7,0xa8,0xa9,
    /* 98 */    0xaa,0xab,0xac,0xac,0xad,0xae,0xaf,0xb0,
    /* a0 */    0xb1,0xb2,0xb3,0xb3,0xb4,0xb5,0xb6,0xb7,
    /* a8 */    0xb8,0xb9,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,
    /* b0 */    0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc4,
    /* b8 */    0xc5,0xc6,0xc7,0xc8,0xc9,0xc9,0xca,0xcb,
    /* c0 */    0xcc,0xcd,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,
    /* c8 */    0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd7,0xd8,
    /* d0 */    0xd9,0xda,0xdb,0xdb,0xdc,0xdd,0xde,0xdf,
    /* d8 */    0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe4,0xe5,
    /* e0 */    0xe6,0xe7,0xe8,0xe8,0xe9,0xea,0xeb,0xec,
    /* e8 */    0xec,0xed,0xee,0xef,0xf0,0xf0,0xf1,0xf2,
    /* f0 */    0xf3,0xf4,0xf5,0xf5,0xf6,0xf7,0xf8,0xf9,
    /* f8 */    0xf9,0xfa,0xfb,0xfc,0xfd,0xfd,0xfe,0xff
};
//const static BYTE GinTblP15[256] = {
static BYTE GinTblP15[256] = {
    /* 00 */    0x00,0x01,0x03,0x04,0x05,0x07,0x08,0x09,
    /* 08 */    0x0b,0x0c,0x0d,0x0f,0x10,0x11,0x13,0x14,
    /* 10 */    0x15,0x17,0x18,0x1a,0x1b,0x1c,0x1e,0x1f,
    /* 18 */    0x20,0x22,0x23,0x24,0x26,0x27,0x28,0x2a,
    /* 20 */    0x2b,0x2c,0x2e,0x2f,0x30,0x32,0x33,0x34,
    /* 28 */    0x35,0x37,0x38,0x39,0x3b,0x3c,0x3d,0x3f,
    /* 30 */    0x40,0x41,0x43,0x44,0x45,0x47,0x48,0x49,
    /* 38 */    0x4a,0x4c,0x4d,0x4e,0x50,0x51,0x52,0x53,
    /* 40 */    0x55,0x56,0x57,0x59,0x5a,0x5b,0x5c,0x5e,
    /* 48 */    0x5f,0x60,0x61,0x63,0x64,0x65,0x66,0x68,
    /* 50 */    0x69,0x6a,0x6b,0x6d,0x6e,0x6f,0x70,0x71,
    /* 58 */    0x73,0x74,0x75,0x76,0x77,0x79,0x7a,0x7b,
    /* 60 */    0x7c,0x7d,0x7e,0x80,0x81,0x82,0x83,0x84,
    /* 68 */    0x85,0x86,0x88,0x89,0x8a,0x8b,0x8c,0x8d,
    /* 70 */    0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,
    /* 78 */    0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,
    /* 80 */    0x9e,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,
    /* 88 */    0xa5,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,
    /* 90 */    0xab,0xac,0xad,0xae,0xaf,0xb0,0xb0,0xb1,
    /* 98 */    0xb2,0xb3,0xb4,0xb4,0xb5,0xb6,0xb7,0xb8,
    /* a0 */    0xb8,0xb9,0xba,0xbb,0xbc,0xbc,0xbd,0xbe,
    /* a8 */    0xbf,0xbf,0xc0,0xc1,0xc2,0xc3,0xc3,0xc4,
    /* b0 */    0xc5,0xc6,0xc6,0xc7,0xc8,0xc9,0xc9,0xca,
    /* b8 */    0xcb,0xcc,0xcd,0xcd,0xce,0xcf,0xd0,0xd0,
    /* c0 */    0xd1,0xd2,0xd3,0xd3,0xd4,0xd5,0xd5,0xd6,
    /* c8 */    0xd7,0xd8,0xd8,0xd9,0xda,0xdb,0xdb,0xdc,
    /* d0 */    0xdd,0xde,0xde,0xdf,0xe0,0xe1,0xe1,0xe2,
    /* d8 */    0xe3,0xe3,0xe4,0xe5,0xe6,0xe6,0xe7,0xe8,
    /* e0 */    0xe9,0xe9,0xea,0xeb,0xeb,0xec,0xed,0xee,
    /* e8 */    0xee,0xef,0xf0,0xf1,0xf1,0xf2,0xf3,0xf3,
    /* f0 */    0xf4,0xf5,0xf6,0xf6,0xf7,0xf8,0xf9,0xf9,
    /* f8 */    0xfa,0xfb,0xfb,0xfc,0xfd,0xfe,0xfe,0xff
};


static void DizMak302(LPN403DIZINF, DWORD);
static void DizMak304(LPN403DIZINF, DWORD);
static void DizMak316(LPN403DIZINF, DWORD);
static void DizMak602(LPN403DIZINF, DWORD);
static void DizMak604(LPN403DIZINF, DWORD);
static void DizMakSmlPrn(LPN403DIZINF, DWORD);
static void DizMakMon002(LPN403DIZINF, DWORD, LPBYTE, LPBYTE, LONG, LONG);
static void DizMakMon004(LPN403DIZINF, DWORD, LPBYTE, LPBYTE, LONG, LONG);
static void DizMakMon016(LPN403DIZINF, DWORD, LPBYTE, LPBYTE, LONG, LONG);


/*****************************************************************************
    Function
*****************************************************************************/
//===================================================================================================
//    Make dither pattern
//===================================================================================================
VOID WINAPI N403DizPtnMak(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum,
    DWORD          diz
)
{
    if(lpDiz->ColMon == N403_COL){
        /*---- Color ----*/
        if(lpDiz->PrnMod == N403_MOD_300B1){        DizMak302(lpDiz, dizNum);
        }else if(lpDiz->PrnMod == N403_MOD_300B2){    DizMak304(lpDiz, dizNum);
        }else if(lpDiz->PrnMod == N403_MOD_300B4){    DizMak316(lpDiz, dizNum);
        }else if(lpDiz->PrnMod == N403_MOD_600B1){    DizMak602(lpDiz, dizNum);
        }else if(lpDiz->PrnMod == N403_MOD_600B2){
            if(diz == N403_DIZ_MID){        DizMak604(lpDiz, dizNum);
            }else if(diz == N403_DIZ_SML){    DizMakSmlPrn(lpDiz, dizNum);
            }
        }
    }else{
        /*---- Mono ----*/
        if(lpDiz->PrnMod == N403_MOD_300B1){
            if(diz == N403_DIZ_MID){        DizMakMon002(lpDiz, dizNum, Mon4x4Ami, GinTblP05, 0, 24);
            }else if(diz == N403_DIZ_SML){    DizMakMon002(lpDiz, dizNum, Mon4x4Bun, GinTblP10, 0, 48);
            }else if(diz == N403_DIZ_RUG){    DizMakMon002(lpDiz, dizNum, Mon8x8Ami, NULL,      0, 0);
            }
        }else if(lpDiz->PrnMod == N403_MOD_300B2){
            if(diz == N403_DIZ_MID){        DizMakMon004(lpDiz, dizNum, Mon4x4Ami, GinTblP05, 6, 24);
            }else if(diz == N403_DIZ_SML){    DizMakMon004(lpDiz, dizNum, Mon4x4Bun, GinTblP10, 12, 48);
            }else if(diz == N403_DIZ_RUG){    DizMakMon004(lpDiz, dizNum, Mon8x8Ami, NULL,      0, 0);
            }
        }else if(lpDiz->PrnMod == N403_MOD_300B4){
            if(diz == N403_DIZ_MID){        DizMakMon016(lpDiz, dizNum, Mon4x4Ami, GinTblP05, 6, 24);
            }else if(diz == N403_DIZ_SML){    DizMakMon016(lpDiz, dizNum, Mon4x4Bun, GinTblP10, 24, 48);
            }else if(diz == N403_DIZ_RUG){    DizMakMon016(lpDiz, dizNum, Mon8x8Ami, NULL,      0, 0);
            }
        }else if(lpDiz->PrnMod == N403_MOD_600B1){
            if(diz == N403_DIZ_MID){        DizMakMon002(lpDiz, dizNum, Mon8x8Ami, GinTblP05, 8, 32);
            }else if(diz == N403_DIZ_SML){    DizMakMon002(lpDiz, dizNum, Mon4x4Syu, GinTblP10, 16, 64);
            }else if(diz == N403_DIZ_RUG){    DizMakMon002(lpDiz, dizNum, Mon8x8Syu, NULL,      0, 0);
            }
        }else if(lpDiz->PrnMod == N403_MOD_600B2){
            if(diz == N403_DIZ_MID){        DizMakMon004(lpDiz, dizNum, Mon8x8Ami, GinTblP05, 8, 32);
            }else if(diz == N403_DIZ_SML){    DizMakMon004(lpDiz, dizNum, Mon4x4Syu, GinTblP10, 16, 64);
            }else if(diz == N403_DIZ_RUG){    DizMakMon004(lpDiz, dizNum, Mon8x8Syu, NULL,      0, 0);
            }
        }
    }
}


/*----------------------------------------------------------------------------
    @300dpi  2value
----------------------------------------------------------------------------*/
static void DizMak302(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum
)
{
    DWORD          cntTil;
    DWORD          cntXax;
    DWORD          cntYax;
    LONG           num;
    LONG           num255;
    LONG           strXax;
    LONG           strYax;
    LPBYTE         DizTblC02;
    LPBYTE         DizTblM02;
    LPBYTE         DizTblY02;
    LPBYTE         DizTblB02;

    DizTblC02 = lpDiz->Diz.Tbl[dizNum][0];
    DizTblM02 = lpDiz->Diz.Tbl[dizNum][1];
    DizTblY02 = lpDiz->Diz.Tbl[dizNum][2];
    DizTblB02 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 17;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 24;

    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 0){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 0)*128/(128 - 0);
        }else if(num < (255 - 28)){
            num255 = 128 + (num - 128)*128/(128 - 28);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make magenta cyan pattern ----*/
    strXax = 6;
    strYax = -1;
    for(cntTil = 0; cntTil < 17; cntTil++){
        strXax += 4;    strYax += 1;
        num = (DWORD)StrMgt002 * 17 + MgtTilNum[cntTil];
        num255 = num * 255 / (17 * 17 - 1);
        if(num255){
            num = num * GinTblP05[num255] / num255;
            num255 = num * 255 / (17 * 17 - 1);
            if(num255){
                num = num * InnTblCmy[num255]/num255;
                num255 = num * 255 / (17 * 17 - 1);
            }
        }
        if(num255 > 254){ num255 = 254; }
        DizTblM02[(strYax % 17) * 32 + (strXax % 17)] = (BYTE)num255;
        DizTblC02[(strYax % 17) * 32 + (16 - strXax % 17)] = (BYTE)num255;
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                num = (DWORD)MgtTil302[cntYax][cntXax] * 17;
                num += MgtTilNum[cntTil];
                num255 = num * 255 / (17 * 17 - 1);
                if(num255){
                    num = num * GinTblP05[num255] / num255;
                    num255 = num * 255 / (17 * 17 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (17 * 17 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblM02[((strYax + cntYax + 1) % 17) * 32 + ((strXax + cntXax) % 17)] = (BYTE)num255;
                DizTblC02[(strYax + cntYax + 1) % 17 * 32 + (16 - ((strXax + cntXax) % 17))] = (BYTE)num255;
            }
        }
    }
    /*---- Make yellow pattern ----*/
    for(cntTil = 0; cntTil < 36; cntTil++){
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                num = (DWORD)YelTil302[cntYax][cntXax] * 36;
                num += Bun6x6All[cntTil];
                num255 = num * 255 / (24 * 24 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (24 * 24 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (24 * 24 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblY02[((cntTil/6)*4 + cntYax) * 32 + ((cntTil%6)*4 + cntXax)] = (BYTE)num255;
            }
        }
    }
    /*---- Make black pattern ----*/
    for(cntTil = 0; cntTil < 36; cntTil++){
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                num = (DWORD)BlaTil302[cntYax][cntXax] * 36;
                num += Bun6x6All[cntTil];
                num255 = num * 255 / (24 * 24 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (24 * 24 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (24 * 24 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblB02[((cntTil/6)*4 + cntYax) * 32 + ((cntTil%6)*4 + cntXax)] = (BYTE)num255;
            }
        }
    }
}


/*----------------------------------------------------------------------------
    A300dpi  4value
----------------------------------------------------------------------------*/
static void DizMak304(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum
)
{
    DWORD          cntTil;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          cnt;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblC04;
    LPBYTE         DizTblM04;
    LPBYTE         DizTblY04;
    LPBYTE         DizTblB04;

    DizTblC04 = lpDiz->Diz.Tbl[dizNum][0];
    DizTblM04 = lpDiz->Diz.Tbl[dizNum][1];
    DizTblY04 = lpDiz->Diz.Tbl[dizNum][2];
    DizTblB04 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 10;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 12;
    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 20){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 20)*128/(128 - 20);
        }else if(num < (255 - 40)){
            num255 = 128 + (num - 128)*128/(128 - 40);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make magenta cyan pattern ----*/
    for(cntTil = 0; cntTil < 4; cntTil++){
        for(cntYax = 0; cntYax < 5; cntYax++){
            for(cntXax = 0; cntXax < 5; cntXax++){
                for(cnt = 0; cnt < 3; cnt++){
                    num = (DWORD)MgtTil304[cntYax][cntXax][cnt] * 4;
                    num += Bun2x2All[cntTil];
                    num255 = num * 255 / (10 * 10 * 3 - 1);
                    if(num255){
                        num = num * GinTblP10[num255] / num255;
                        num255 = num * 255 / (10 * 10 * 3 - 1);
                        if(num255){
                            num = num * InnTblCmy[num255]/num255;
                            num255 = num * 255 / (10 * 10 * 3 - 1);
                        }
                    }
                    if(num255 > 254){ num255 = 254; }
                    DizTblM04[((cntTil / 2) * 5 + cntYax) * 16 * 3 +
                              ((cntTil % 2) * 5 + cntXax) * 3 + cnt] = (BYTE)num255;
                    DizTblC04[((cntTil / 2) * 5 + cntYax) * 16 * 3 +
                              (9 - ((cntTil % 2) * 5 + cntXax)) * 3 + cnt] = (BYTE)num255;
                }
            }
        }
    }
    /*---- Make yellow pattern ----*/
    for(cntTil = 0; cntTil < 9; cntTil++){
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                for(cnt = 0; cnt < 3; cnt++){
                    num = (DWORD)YelTil304[cntYax][cntXax][cnt] * 9;
                    num += Bun3x3All[cntTil];
                    num255 = num * 255 / (12 * 12 * 3 - 1);
                    if(num255){
                        num = num * GinTblP15[num255] / num255;
                        num255 = num * 255 / (12 * 12 * 3 - 1);
                        if(num255){
                            num = num * InnTblCmy[num255]/num255;
                            num255 = num * 255 / (12 * 12 * 3 - 1);
                        }
                    }
                    if(num255 > 254){ num255 = 254; }
                    DizTblY04[((cntTil / 3) * 4 + cntYax) * 16 * 3 +
                              ((cntTil % 3) * 4 + cntXax) * 3 + cnt] = (BYTE)num255;
                }
            }
        }
    }
    /*---- Make black pattern ----*/
    for(cntTil = 0; cntTil < 9; cntTil++){
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                for(cnt = 0; cnt < 3; cnt++){
                    num = (DWORD)BlaTil304[cntYax][cntXax][cnt] * 9;
                    num = ((num/4)*4*3 + num%4 + cnt*4)*9;
                    num += Bun3x3All[cntTil];
                    num255 = num * 255 / (12 * 12 * 3 - 1);
                    if(num255){
                        num = num * GinTblP15[num255] / num255;
                        num255 = num * 255 / (12 * 12 * 3 - 1);
                        if(num255){
                            num = num * InnTblCmy[num255]/num255;
                            num255 = num * 255 / (12 * 12 * 3 - 1);
                        }
                    }
                    if(num255 > 254){ num255 = 254; }
                    DizTblB04[((cntTil / 3) * 4 + cntYax) * 16 * 3 +
                              ((cntTil % 3) * 4 + cntXax) * 3 + cnt] = (BYTE)num255;
                }
            }
        }
    }
}


/*----------------------------------------------------------------------------
    B300dpi  16value
----------------------------------------------------------------------------*/
static void DizMak316(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          cnt;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblC16;
    LPBYTE         DizTblM16;
    LPBYTE         DizTblY16;
    LPBYTE         DizTblB16;

    DizTblC16 = lpDiz->Diz.Tbl[dizNum][0];
    DizTblM16 = lpDiz->Diz.Tbl[dizNum][1];
    DizTblY16 = lpDiz->Diz.Tbl[dizNum][2];
    DizTblB16 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 5;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 4;
    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 20){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 20)*128/(128 - 20);
        }else if(num < (255 - 40)){
            num255 = 128 + (num - 128)*128/(128 - 40);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make magenta cyan pattern ----*/
    for(cntYax = 0; cntYax < 5; cntYax++){
        for(cntXax = 0; cntXax < 5; cntXax++){
            for(cnt = 0; cnt < 15; cnt++){
                num = ((LONG)MgtTil316[cntYax][cntXax] / 5) * 5 * 15;
                num += cnt * 5 + MgtTil316[cntYax][cntXax] % 5;
                num255 = num * 255 / (5 * 5 * 15 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (5 * 5 * 15 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (5 * 5 * 15 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblM16[cntYax * 8 * 15 + cntXax * 15 + cnt] = (BYTE)num255;
                DizTblC16[cntYax * 8 * 15 + (4-cntXax) * 15 + cnt] = (BYTE)num255;
            }
        }
    }

    /*---- Make yellow pattern ----*/
    for(cntYax = 0; cntYax < 4; cntYax++){
        for(cntXax = 0; cntXax < 4; cntXax++){
            for(cnt = 0; cnt < 15; cnt++){
                num = ((LONG)YelTil316[cntYax][cntXax] / 4 * 4) * 15;
                num += cnt * 4 + YelTil316[cntYax][cntXax] % 4;
                num255 = num * 255 / (4 * 4 * 15 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (4 * 4 * 15 - 1);
                    if(num255 > 128){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (4 * 4 * 15 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblY16[cntYax * 8 * 15 + cntXax * 15 + cnt] = (BYTE)num255;
            }
        }
    }

    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 4; cntYax++){
        for(cntXax = 0; cntXax < 4; cntXax++){
            for(cnt = 0; cnt < 15; cnt++){
                num = ((LONG)BlaTil316[cntYax][cntXax] / 4 * 4) * 15;
                num += cnt * 4 + BlaTil316[cntYax][cntXax] % 4;
                num255 = num * 255 / (4 * 4 * 15 - 1);
                if(num255){
                    num = num * GinTblP15[num255] / num255;
                    num255 = num * 255 / (4 * 4 * 15 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (4 * 4 * 15 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblB16[cntYax * 8 * 15 + cntXax * 15 + cnt] = (BYTE)num255;
            }
        }
    }
}


/*----------------------------------------------------------------------------
    C600dpi  2value
----------------------------------------------------------------------------*/
static void DizMak602(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblC02;
    LPBYTE         DizTblM02;
    LPBYTE         DizTblY02;
    LPBYTE         DizTblB02;

    DizTblC02 = lpDiz->Diz.Tbl[dizNum][0];
    DizTblM02 = lpDiz->Diz.Tbl[dizNum][1];
    DizTblY02 = lpDiz->Diz.Tbl[dizNum][2];
    DizTblB02 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 20;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 24;
    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 24){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 24)*128/(128 - 24);
        }else if(num < (255 - 40)){
            num255 = 128 + (num - 128)*128/(128 - 40);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make cyan pattern ----*/
    for(cntYax = 0; cntYax < 20; cntYax++){
        for(cntXax = 0; cntXax < 20; cntXax++){
            num = (LONG)CynTil600[cntYax%10][cntXax%10];
            num = num*4 + Bun2x2All[(cntYax/10)*2 + cntXax/10];
            num255 = num * 255 / (20*20-1);
            if(num255){
                num = num * GinTblP10[num255] / num255;
                num255 = num * 255 / (20*20-1);
                if(num255){
                    num = num * InnTblCmy[num255] / num255;
                    num255 = num * 255 / (20*20-1);
                }
            }
            if(num255 > 254){ num255 = 254; }
            DizTblC02[cntYax * 32 + cntXax] = (BYTE)num255;
        }
    }
    /*---- Make magenta pattern ----*/
    for(cntYax = 0; cntYax < 20; cntYax++){
        for(cntXax = 0; cntXax < 20; cntXax++){
            num = (LONG)MgtTil600[cntYax%10][cntXax%10];
            num = num*4 + Bun2x2All[(cntYax/10)*2 + cntXax/10];
            num255 = num * 255 / (20*20-1);
            if(num255){
                num = num * GinTblP10[num255] / num255;
                num255 = num * 255 / (20*20-1);
                if(num255){
                    num = num * InnTblCmy[num255] / num255;
                    num255 = num * 255 / (20*20-1);
                }
            }
            if(num255 > 254){ num255 = 254; }
            DizTblM02[cntYax * 32 + cntXax] = (BYTE)num255;
        }
    }
    /*---- Make yellow pattern ----*/
    for(cntYax = 0; cntYax < 24; cntYax++){
        for(cntXax = 0; cntXax < 24; cntXax++){
            num = (LONG)YelTil600[cntYax%6][cntXax%6];
            num = num*16 + Bun4x4All[(cntYax/6)*4 + cntXax/6];
            num255 = num * 255 / (24*24-1);
            if(num255){
                num = num * GinTblP10[num255] / num255;
                num255 = num * 255 / (24*24-1);
                if(num255){
                    num = num * InnTblCmy[num255] / num255;
                    num255 = num * 255 / (24*24-1);
                }
            }
            if(num255 > 254){ num255 = 254; }
            DizTblY02[cntYax * 32 + cntXax] = (BYTE)num255;
        }
    }
    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 24; cntYax++){
        for(cntXax = 0; cntXax < 24; cntXax++){
            num = (LONG)BlaTil600[cntYax%4][cntXax%4];
            num = num*36 + Bun6x6All[(cntYax/4)*6 + cntXax/4];
            num255 = num * 255 / (24*24-1);
            if(num255){
                num = num * GinTblP10[num255] / num255;
                num255 = num * 255 / (24*24-1);
                if(num255){
                    num = num * InnTblCmy[num255] / num255;
                    num255 = num * 255 / (24*24-1);
                }
            }
            if(num255 > 254){ num255 = 254; }
            DizTblB02[cntYax * 32 + cntXax] = (BYTE)num255;
        }
    }
}


/*----------------------------------------------------------------------------
    D600dpi  4value
----------------------------------------------------------------------------*/
static void DizMak604(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          cnt;
    LONG           num;
    LONG           num255;
    LONG           tmpNum;
    LPBYTE         DizTblC04;
    LPBYTE         DizTblM04;
    LPBYTE         DizTblY04;
    LPBYTE         DizTblB04;

    DizTblC04 = lpDiz->Diz.Tbl[dizNum][0];
    DizTblM04 = lpDiz->Diz.Tbl[dizNum][1];
    DizTblY04 = lpDiz->Diz.Tbl[dizNum][2];
    DizTblB04 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 10;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 12;
    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 24){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 24)*128/(128 - 24);
        }else if(num < (255 - 40)){
            num255 = 128 + (num - 128)*128/(128 - 40);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make cyan pattern ----*/
    for(cntYax = 0; cntYax < 10; cntYax++){
        for(cntXax = 0; cntXax < 10; cntXax++){
            num = (LONG)CynTil600[cntYax][cntXax];
            num = (num/5)*5*3 + num%5;
            for(cnt = 0; cnt < 3; cnt++){
                tmpNum = num + cnt*5;
                num255 = tmpNum * 255 / (10*10*3-1);
                if(num255){
                    tmpNum = tmpNum * GinTblP10[num255] / num255;
                    num255 = tmpNum * 255 / (10*10*3-1);
                    if(num255){
                        tmpNum = tmpNum * InnTblCmy[num255]/num255;
                        num255 = tmpNum * 255 / (10*10*3-1);
                    }
                }
                if(num255 >= 255){ num255 = 254; }
                DizTblC04[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
    /*---- Make magenta pattern ----*/
    for(cntYax = 0; cntYax < 10; cntYax++){
        for(cntXax = 0; cntXax < 10; cntXax++){
            num = (LONG)MgtTil600[cntYax][cntXax];
            num = (num/5)*5*3 + num%5;
            for(cnt = 0; cnt < 3; cnt++){
                tmpNum = num + cnt*5;
                num255 = tmpNum * 255 / (10*10*3-1);
                if(num255){
                    tmpNum = tmpNum * GinTblP10[num255] / num255;
                    num255 = tmpNum * 255 / (10*10*3-1);
                    if(num255){
                        tmpNum = tmpNum * InnTblCmy[num255]/num255;
                        num255 = tmpNum * 255 / (10*10*3-1);
                    }
                }
                if(num255 >= 255){ num255 = 254; }
                DizTblM04[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
    /*---- Make yellow pattern ----*/
    for(cntYax = 0; cntYax < 12; cntYax++){
        for(cntXax = 0; cntXax < 12; cntXax++){
            num = (LONG)YelTil600[cntYax%6][cntXax%6] * 3;
            for(cnt = 0; cnt < 3; cnt++){
                tmpNum = (num + cnt)*4 + Bun2x2All[(cntYax/6)*2 + cntXax/6];
                num255 = tmpNum * 255 / (12*12*3-1);
                if(num255){
                    tmpNum = tmpNum * GinTblP10[num255] / num255;
                    num255 = tmpNum * 255 / (12*12*3-1);
                    if(num255){
                        tmpNum = tmpNum * InnTblCmy[num255]/num255;
                        num255 = tmpNum * 255 / (12*12*3-1);
                    }
                }
                if(num255 >= 255){ num255 = 254; }
                DizTblY04[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 12; cntYax++){
        for(cntXax = 0; cntXax < 12; cntXax++){
            num = (LONG)BlaTil600[cntYax%4][cntXax%4] * 3;
            for(cnt = 0; cnt < 3; cnt++){
                tmpNum = (num + cnt)*9 + Bun3x3All[(cntYax/4)*3 + cntXax/4];
                num255 = tmpNum * 255 / (12*12*3-1);
                if(num255){
                    tmpNum = tmpNum * GinTblP10[num255] / num255;
                    num255 = tmpNum * 255 / (12*12*3-1);
                    if(num255){
                        tmpNum = tmpNum * InnTblCmy[num255]/num255;
                        num255 = tmpNum * 255 / (12*12*3-1);
                    }
                }
                if(num255 >= 255){ num255 = 254; }
                DizTblB04[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
}


/*----------------------------------------------------------------------------
    E600dpi 4value DETAIL
----------------------------------------------------------------------------*/
static void DizMakSmlPrn(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          cnt;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblSml;
    LPBYTE         DizTblPc4;
    LPBYTE         DizTblPm4;
    LPBYTE         DizTblPy4;
    LPBYTE         DizTblPb4;

    DizTblSml = lpDiz->Diz.Tbl[dizNum][0];
    DizTblPc4 = lpDiz->EntDiz.Tbl[0];
    DizTblPm4 = lpDiz->EntDiz.Tbl[1];
    DizTblPy4 = lpDiz->EntDiz.Tbl[2];
    DizTblPb4 = lpDiz->EntDiz.Tbl[3];

    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 64){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 64)*128/(128 - 64);
        }else if(num < (255 - 48)){
            num255 = 128 + (num - 128)*128/(128 - 48);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }
    /*---- Make magenta pattern ----*/
    /*---- Make cyan pattern ----*/
    /*---- Make yellow pattern ----*/
    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 16; cntYax++){
        for(cntXax = 0; cntXax < 16; cntXax++){
            for(cnt = 0; cnt < 3; cnt++){
                num = BlaTil302[cntYax%4][cntXax%4] * 3 + cnt;
                num = num * 16 + Bun4x4All[cntYax/4*4 + cntXax/4];
                num255 = num * 255 / (16*16*3 - 1);
                if(num255){
                    num = num * GinTblP15[num255] / num255;
                    num255 = num * 255 / (16*16*3 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblSml[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }

    /*---- Make CMYK conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < 32){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - 32)*128/(128 - 32);
        }else if(num < (255 - 44)){
            num255 = 128 + (num - 128)*128/(128 - 44);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }
    /*---- Make cyan pattern ----*/
    for(cntYax = 0 ; cntYax < 16 ; cntYax ++){
        for(cntXax = 0 ; cntXax < 16 ; cntXax ++){
            for(cnt = 0; cnt < 3; cnt++){
                num = DizPatPrn[0][(cntYax%8)*8 + cntXax%8];
                num = num*4 + Bun2x2All[(cntYax/8)*2 + cntXax/8];
                num = num/16*16*3 + cnt*16 + num%16;
                num255 = num * 255 / (16*16*3 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (16*16*3 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255] / num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblPc4[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
    /*---- Make magenta pattern ----*/
    for(cntYax = 0 ; cntYax < 16 ; cntYax ++){
        for(cntXax = 0 ; cntXax < 16 ; cntXax ++){
            for(cnt = 0; cnt < 3; cnt++){
                num = DizPatPrn[1][(cntYax%8)*8 + cntXax%8];
                num = num*4 + Bun2x2All[(cntYax/8)*2 + cntXax/8];
                num = num/16*16*3 + cnt*16 + num%16;
                num255 = num * 255 / (16*16*3 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (16*16*3 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255] / num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblPm4[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
    /*---- Make yellow pattern ----*/
    for(cntYax = 0 ; cntYax < 16 ; cntYax ++){
        for(cntXax = 0 ; cntXax < 16 ; cntXax ++){
            for(cnt = 0; cnt < 3; cnt++){
                num = DizPatPrn[2][(cntYax%8)*8 + cntXax%8];
                num = num*4 + Bun2x2All[(cntYax/8)*2 + cntXax/8];
                num = num/16*16*3 + cnt*16 + num%16;
                num255 = num * 255 / (16*16*3 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (16*16*3 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255] / num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblPy4[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
    /*---- Make black pattern ----*/
    for(cntYax = 0 ; cntYax < 16 ; cntYax ++){
        for(cntXax = 0 ; cntXax < 16 ; cntXax ++){
            for(cnt = 0; cnt < 3; cnt++){
                num = DizPatPrn[3][(cntYax%8)*8 + cntXax%8];
                num = num*4 + Bun2x2All[(cntYax/8)*2 + cntXax/8];
                num = num/16*16*3 + cnt*16 + num%16;
                num255 = num * 255 / (16*16*3 - 1);
                if(num255){
                    num = num * GinTblP10[num255] / num255;
                    num255 = num * 255 / (16*16*3 - 1);
                    if(num255){
                        num = num * InnTblCmy[num255] / num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblPb4[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
}


/*----------------------------------------------------------------------------
    7 Monochrome  2value
----------------------------------------------------------------------------*/
static void DizMakMon002(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum,
    LPBYTE         tilTbl,
    LPBYTE         ginTbl,
    LONG           minCut,
    LONG           maxCut
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblB02;

    DizTblB02 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 32;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 32;
    /*---- Make conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < minCut){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - minCut)*128/(128 - minCut);
        }else if(num < (255 - maxCut)){
            num255 = 128 + (num - 128)*128/(128 - maxCut);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 32; cntYax++){
        for(cntXax = 0; cntXax < 32; cntXax++){
            num = (LONG)tilTbl[cntYax%8*8 + cntXax%8];
            num = num * 16 + Bun4x4All[cntYax/8*4 + cntXax/8];
            num255 = num * 255 / (32*32 - 1);
            if(num255){
                if(ginTbl != NULL){
                    num = num * ginTbl[num255] / num255;
                    num255 = num * 255 / (32*32 - 1);
                }
                if(num255){
                    num = num * InnTblCmy[num255]/num255;
                    num255 = num * 255 / (32*32 - 1);
                }
            }
            if(num255 > 254){ num255 = 254; }
            DizTblB02[cntYax * 32 + cntXax] = (BYTE)num255;
        }
    }
}


/*----------------------------------------------------------------------------
    GMonochrome 4value
----------------------------------------------------------------------------*/
static void DizMakMon004(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum,
    LPBYTE         tilTbl,
    LPBYTE         ginTbl,
    LONG           minCut,
    LONG           maxCut
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          cnt;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblB04;

    DizTblB04 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 16;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 16;
    /*---- Make conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < minCut){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - minCut)*128/(128 - minCut);
        }else if(num < (255 - maxCut)){
            num255 = 128 + (num - 128)*128/(128 - maxCut);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }

    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 16; cntYax++){
        for(cntXax = 0; cntXax < 16; cntXax++){
            for(cnt = 0; cnt < 3; cnt++){
                num = (LONG)tilTbl[cntYax%8*8 + cntXax%8] * 3 + cnt;
                num = num * 4 + Bun2x2All[cntYax/8*2 + cntXax/8];
                num255 = num * 255 / (16*16*3 - 1);
                if(num255){
                    if(ginTbl != NULL){
                        num = num * ginTbl[num255] / num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (16*16*3 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblB04[cntYax * 16 * 3 + cntXax * 3 + cnt] = (BYTE)num255;
            }
        }
    }
}


/*----------------------------------------------------------------------------
    Hmonochrome 16value
----------------------------------------------------------------------------*/
static void DizMakMon016(
    LPN403DIZINF   lpDiz,
    DWORD          dizNum,
    LPBYTE         tilTbl,
    LPBYTE         ginTbl,
    LONG           minCut,
    LONG           maxCut
)
{
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          cnt;
    LONG           num;
    LONG           num255;
    LPBYTE         DizTblB16;

    DizTblB16 = lpDiz->Diz.Tbl[dizNum][3];
    lpDiz->DizSiz[0] = lpDiz->DizSiz[1] = 8;
    lpDiz->DizSiz[2] = lpDiz->DizSiz[3] = 8;
    /*---- Make conversion table ----*/
    for(num = 0 ; num < 256 ; num++){
        if(num < minCut){
            num255 = 0;
        }else if(num < 128){
            num255 = (num - minCut)*128/(128 - minCut);
        }else if(num < (255 - maxCut)){
            num255 = 128 + (num - 128)*128/(128 - maxCut);
        }else{
            num255 = 255 - 1;
        }
        InnTblCmy[num] = (BYTE)num255;
    }
    /*---- Make black pattern ----*/
    for(cntYax = 0; cntYax < 8; cntYax++){
        for(cntXax = 0; cntXax < 8; cntXax++){
            for(cnt = 0; cnt < 15; cnt++){
                num = tilTbl[cntYax*8 + cntXax];
                num = num / 8 * 8 * 15 + cnt * 8 + num % 8;
                num255 = num * 255 / (8*8*15 - 1);
                if(num255){
                    if(ginTbl != NULL){
                        num = num * ginTbl[num255] / num255;
                        num255 = num * 255 / (8*8*15 - 1);
                    }
                    if(num255){
                        num = num * InnTblCmy[num255]/num255;
                        num255 = num * 255 / (8*8*15 - 1);
                    }
                }
                if(num255 > 254){ num255 = 254; }
                DizTblB16[cntYax * 8 * 15 + cntXax * 15 + cnt] = (BYTE)num255;
            }
        }
    }
}


//===================================================================================================
//    Make toner density control table
//===================================================================================================
VOID WINAPI N403TnrTblMak(
    LPN403DIZINF   lpDiz,
    LONG           tnrDns
)
{
    LONG           innNum;
    LONG           outNum;
    LPBYTE         innTblCmy;

    tnrDns *= 2;
    innTblCmy = lpDiz->Tnr.Tbl;
    /*---- Make CMYK conversion table ----*/
    if(tnrDns < 0){
        for(innNum = 0 ; innNum < 256 ; innNum++){
            if(innNum == 255){    outNum = 255;
            }else{                outNum = innNum * (255 + tnrDns) / 255;
            }
            innTblCmy[innNum] = (BYTE)outNum;
        }
    }else{
        for(innNum = 0 ; innNum < 256 ; innNum++){
            if(innNum == 0){    outNum = 0;
            }else{                outNum = (innNum + tnrDns) * 255 / (255 + tnrDns);
            }
            innTblCmy[innNum] = (BYTE)outNum;
        }
    }
}


//===================================================================================================
//    Dithering(2 value)
//===================================================================================================
DWORD WINAPI N403Diz002(
    LPN403DIZINF   lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    LPCMYK         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    DWORD          cntHrz;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          xaxSet;
    DWORD          yaxSet;
    DWORD          linByt;
    DWORD          tmpXax;
    DWORD          tmpBuf;
    DWORD          DizSizCyn;
    DWORD          DizSizMgt;
    DWORD          DizSizYel;
    DWORD          DizSizBla;
    LPBYTE         DizTblC02;
    LPBYTE         DizTblM02;
    LPBYTE         DizTblY02;
    LPBYTE         DizTblB02;
    LPBYTE         dizTblC02;
    LPBYTE         dizTblM02;
    LPBYTE         dizTblY02;
    LPBYTE         dizTblB02;
    CMYK           tmpCmy;
    BYTE           tmpByt;

    DizTblC02 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][0];
    DizTblM02 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][1];
    DizTblY02 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][2];
    DizTblB02 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][3];
    DizSizCyn = lpDiz->DizSiz[0];
    DizSizMgt = lpDiz->DizSiz[1];
    DizSizYel = lpDiz->DizSiz[2];
    DizSizBla = lpDiz->DizSiz[3];

    if((xaxNrt == xaxDnt)&&(yaxNrt == yaxDnt)){
        /*---- Not stretch ----*/
        dizTblC02 = DizTblC02 + strYax % DizSizCyn * 32;
        dizTblM02 = DizTblM02 + strYax % DizSizMgt * 32;
        dizTblY02 = DizTblY02 + strYax % DizSizYel * 32;
        dizTblB02 = DizTblB02 + strYax % DizSizBla * 32;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = *cmyBuf;    cmyBuf++;
            tmpByt = (BYTE)0x80 >> (cntHrz % 8);
            tmpBuf = cntHrz / 8;
            if(tmpCmy.Cyn){
                if (tmpCmy.Cyn > dizTblC02[strXax % DizSizCyn]) {
                    linBufCyn[tmpBuf] |= tmpByt;
                }
            }
            if(tmpCmy.Mgt){
                if (tmpCmy.Mgt > dizTblM02[strXax % DizSizMgt]) {
                    linBufMgt[tmpBuf] |= tmpByt;
                }
            }
            if(tmpCmy.Yel){
                if (tmpCmy.Yel > dizTblY02[strXax % DizSizYel]) {
                    linBufYel[tmpBuf] |= tmpByt;
                }
            }
            if(tmpCmy.Bla){
                if (tmpCmy.Bla > dizTblB02[strXax % DizSizBla]) {
                    linBufBla[tmpBuf] |= tmpByt;
                }
            }
            strXax++;
        }
        return 1;
    }
    /*---- Stretch ----*/
    linByt = (xaxOfs + xaxSiz) * xaxNrt / xaxDnt;
    linByt -= xaxOfs * xaxNrt / xaxDnt;
    linByt = (linByt + 7) / 8;
    yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
    yaxSet -= yaxOfs * yaxNrt / yaxDnt;
    for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
        dizTblC02 = DizTblC02 + strYax % DizSizCyn * 32;
        dizTblM02 = DizTblM02 + strYax % DizSizMgt * 32;
        dizTblY02 = DizTblY02 + strYax % DizSizYel * 32;
        dizTblB02 = DizTblB02 + strYax % DizSizBla * 32;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = cmyBuf[cntHrz];
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tmpByt = (BYTE)0x80 >> (tmpXax % 8);
                tmpBuf = tmpXax / 8;
                if(tmpCmy.Cyn){
                    if (tmpCmy.Cyn > dizTblC02[(strXax + tmpXax) % DizSizCyn]) {
                        linBufCyn[tmpBuf] |= tmpByt;
                    }
                }
                if(tmpCmy.Mgt){
                    if (tmpCmy.Mgt > dizTblM02[(strXax + tmpXax) % DizSizMgt]) {
                        linBufMgt[tmpBuf] |= tmpByt;
                    }
                }
                if(tmpCmy.Yel){
                    if (tmpCmy.Yel > dizTblY02[(strXax + tmpXax) % DizSizYel]) {
                        linBufYel[tmpBuf] |= tmpByt;
                    }
                }
                if(tmpCmy.Bla){
                    if (tmpCmy.Bla > dizTblB02[(strXax + tmpXax) % DizSizBla]) {
                        linBufBla[tmpBuf] |= tmpByt;
                    }
                }
                tmpXax++;
            }
        }
        linBufCyn += linByt;
        linBufMgt += linByt;
        linBufYel += linByt;
        linBufBla += linByt;
        strYax++;
    }
    return yaxSet;
}


//===================================================================================================
//    Dithering(4value)
//===================================================================================================
DWORD WINAPI N403Diz004(
    LPN403DIZINF   lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    LPCMYK         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    DWORD          cntHrz;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          xaxSet;
    DWORD          yaxSet;
    DWORD          linByt;
    DWORD          tmpXax;
    DWORD          tmpBuf;
    DWORD          DizSizCyn;
    DWORD          DizSizMgt;
    DWORD          DizSizYel;
    DWORD          DizSizBla;
    LPBYTE         DizTblC04;
    LPBYTE         DizTblM04;
    LPBYTE         DizTblY04;
    LPBYTE         DizTblB04;
    LPBYTE         dizTblC04;
    LPBYTE         dizTblM04;
    LPBYTE         dizTblY04;
    LPBYTE         dizTblB04;
    LPBYTE         dizTbl;
    CMYK           tmpCmy;
    BYTE           tmp001;
    BYTE           tmp002;
    BYTE           tmp003;

    DizTblC04 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][0];
    DizTblM04 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][1];
    DizTblY04 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][2];
    DizTblB04 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][3];
    DizSizCyn = lpDiz->DizSiz[0];
    DizSizMgt = lpDiz->DizSiz[1];
    DizSizYel = lpDiz->DizSiz[2];
    DizSizBla = lpDiz->DizSiz[3];

    if((xaxNrt == xaxDnt)&&(yaxNrt == yaxDnt)){
        /*---- Not stretch ----*/
        dizTblC04 = DizTblC04 + strYax % DizSizCyn * 16 * 3;
        dizTblM04 = DizTblM04 + strYax % DizSizMgt * 16 * 3;
        dizTblY04 = DizTblY04 + strYax % DizSizYel * 16 * 3;
        dizTblB04 = DizTblB04 + strYax % DizSizBla * 16 * 3;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmp003 = (BYTE)0xc0 >> (cntHrz % 4) * 2;
            tmp002 = (BYTE)0x80 >> (cntHrz % 4) * 2;
            tmp001 = (BYTE)0x40 >> (cntHrz % 4) * 2;
            tmpCmy = *cmyBuf;    cmyBuf++;
            tmpBuf = cntHrz / 4;
            /*--- cyan ----*/
            if(tmpCmy.Cyn){
                dizTbl = dizTblC04 + strXax % DizSizCyn * 3;
                if (tmpCmy.Cyn > dizTbl[0]) {
                    if (tmpCmy.Cyn > dizTbl[2]) {
                        linBufCyn[tmpBuf] |= tmp003;
                    } else if (tmpCmy.Cyn > dizTbl[1]) {
                        linBufCyn[tmpBuf] |= tmp002;
                    }else{
                        linBufCyn[tmpBuf] |= tmp001;
                    }
                }
            }
            /*--- magenta ----*/
            if(tmpCmy.Mgt){
                dizTbl = dizTblM04 + strXax % DizSizMgt * 3;
                if (tmpCmy.Mgt > dizTbl[0]) {
                    if (tmpCmy.Mgt > dizTbl[2]) {
                        linBufMgt[tmpBuf] |= tmp003;
                    } else if (tmpCmy.Mgt > dizTbl[1]) {
                        linBufMgt[tmpBuf] |= tmp002;
                    }else{
                        linBufMgt[tmpBuf] |= tmp001;
                    }
                }
            }
            /*--- yellow ----*/
            if(tmpCmy.Yel){
                dizTbl = dizTblY04 + strXax % DizSizYel * 3;
                if (tmpCmy.Yel > dizTbl[0]) {
                    if (tmpCmy.Yel > dizTbl[2]) {
                        linBufYel[tmpBuf] |= tmp003;
                    } else if (tmpCmy.Yel > dizTbl[1]) {
                        linBufYel[tmpBuf] |= tmp002;
                    }else{
                        linBufYel[tmpBuf] |= tmp001;
                    }
                }
            }
            /*--- black ----*/
            if(tmpCmy.Bla){
                dizTbl = dizTblB04 + strXax % DizSizBla * 3;
                if (tmpCmy.Bla > dizTbl[0]) {
                    if (tmpCmy.Bla > dizTbl[2]) {
                        linBufBla[tmpBuf] |= tmp003;
                    } else if (tmpCmy.Bla > dizTbl[1]) {
                        linBufBla[tmpBuf] |= tmp002;
                    }else{
                        linBufBla[tmpBuf] |= tmp001;
                    }
                }
            }
            strXax++;
        }
        return 1;
    }
    /*---- Stretch ----*/
    linByt = (xaxOfs + xaxSiz) * xaxNrt / xaxDnt;
    linByt -= xaxOfs * xaxNrt / xaxDnt;
    linByt = (linByt * 2 + 7) / 8;
    yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
    yaxSet -= yaxOfs * yaxNrt / yaxDnt;
    for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
        dizTblC04 = DizTblC04 + strYax % DizSizCyn * 16 * 3;
        dizTblM04 = DizTblM04 + strYax % DizSizMgt * 16 * 3;
        dizTblY04 = DizTblY04 + strYax % DizSizYel * 16 * 3;
        dizTblB04 = DizTblB04 + strYax % DizSizBla * 16 * 3;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = cmyBuf[cntHrz];
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tmp003 = (BYTE)0xc0 >> (tmpXax % 4) * 2;
                tmp002 = (BYTE)0x80 >> (tmpXax % 4) * 2;
                tmp001 = (BYTE)0x40 >> (tmpXax % 4) * 2;
                tmpBuf = tmpXax / 4;
                /*--- cyan ----*/
                if(tmpCmy.Cyn){
                    dizTbl = dizTblC04 + (strXax + tmpXax) % DizSizCyn * 3;
                    if (tmpCmy.Cyn > dizTbl[0]) {
                        if (tmpCmy.Cyn > dizTbl[2]) {
                            linBufCyn[tmpBuf] |= tmp003;
                        } else if (tmpCmy.Cyn > dizTbl[1]) {
                            linBufCyn[tmpBuf] |= tmp002;
                        }else{
                            linBufCyn[tmpBuf] |= tmp001;
                        }
                    }
                }
                /*--- magenta ----*/
                if(tmpCmy.Mgt){
                    dizTbl = dizTblM04 + (strXax + tmpXax) % DizSizMgt * 3;
                    if (tmpCmy.Mgt > dizTbl[0]) {
                        if (tmpCmy.Mgt > dizTbl[2]) {
                            linBufMgt[tmpBuf] |= tmp003;
                        } else if (tmpCmy.Mgt > dizTbl[1]) {
                            linBufMgt[tmpBuf] |= tmp002;
                        }else{
                            linBufMgt[tmpBuf] |= tmp001;
                        }
                    }
                }
                /*--- yellow ----*/
                if(tmpCmy.Yel){
                    dizTbl = dizTblY04 + (strXax + tmpXax) % DizSizYel * 3;
                    if (tmpCmy.Yel > dizTbl[0]) {
                        if (tmpCmy.Yel > dizTbl[2]) {
                            linBufYel[tmpBuf] |= tmp003;
                        } else if (tmpCmy.Yel > dizTbl[1]) {
                            linBufYel[tmpBuf] |= tmp002;
                        }else{
                            linBufYel[tmpBuf] |= tmp001;
                        }
                    }
                }
                /*--- balck ----*/
                if(tmpCmy.Bla){
                    dizTbl = dizTblB04 + (strXax + tmpXax) % DizSizBla * 3;
                    if (tmpCmy.Bla > dizTbl[0]) {
                        if (tmpCmy.Bla > dizTbl[2]) {
                            linBufBla[tmpBuf] |= tmp003;
                        } else if (tmpCmy.Bla > dizTbl[1]) {
                            linBufBla[tmpBuf] |= tmp002;
                        }else{
                            linBufBla[tmpBuf] |= tmp001;
                        }
                    }
                }
                tmpXax++;
            }
        }
        linBufCyn += linByt;
        linBufMgt += linByt;
        linBufYel += linByt;
        linBufBla += linByt;
        strYax++;
    }
    return yaxSet;
}


//===================================================================================================
//    Dithering(16value)
//===================================================================================================
DWORD WINAPI N403Diz016(
    LPN403DIZINF   lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    LPCMYK         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    DWORD          cntHrz;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          xaxSet;
    DWORD          yaxSet;
    DWORD          linByt;
    DWORD          tmpXax;
    DWORD          tmpBuf;
    DWORD          min;
    DWORD          max;
    DWORD          mid;
    DWORD          DizSizCyn;
    DWORD          DizSizMgt;
    DWORD          DizSizYel;
    DWORD          DizSizBla;
    LPBYTE         DizTblC16;
    LPBYTE         DizTblM16;
    LPBYTE         DizTblY16;
    LPBYTE         DizTblB16;
    LPBYTE         dizTblC16;
    LPBYTE         dizTblM16;
    LPBYTE         dizTblY16;
    LPBYTE         dizTblB16;
    LPBYTE         dizTbl;
    CMYK           tmpCmy;

    DizTblC16 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][0];
    DizTblM16 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][1];
    DizTblY16 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][2];
    DizTblB16 = lpDiz->Diz.Tbl[lpDiz->Diz.Num][3];
    DizSizCyn = lpDiz->DizSiz[0];
    DizSizMgt = lpDiz->DizSiz[1];
    DizSizYel = lpDiz->DizSiz[2];
    DizSizBla = lpDiz->DizSiz[3];


    if((xaxNrt == xaxDnt)&&(yaxNrt == yaxDnt)){
        /*---- Not stretch ----*/
        dizTblC16 = DizTblC16 + strYax % DizSizCyn * 8 * 15;
        dizTblM16 = DizTblM16 + strYax % DizSizMgt * 8 * 15;
        dizTblY16 = DizTblY16 + strYax % DizSizYel * 8 * 15;
        dizTblB16 = DizTblB16 + strYax % DizSizBla * 8 * 15;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = *cmyBuf;    cmyBuf++;
            tmpBuf = cntHrz / 2;
            /*--- cyan ----*/
            if(tmpCmy.Cyn){
                dizTbl = dizTblC16 + strXax % DizSizCyn * 15;
                if (tmpCmy.Cyn > dizTbl[0]) {
                    min = 0;    max = 14;    mid = 7;
                    while(min < max){
                        if (tmpCmy.Cyn > dizTbl[mid]) {
                            min = mid;
                        }else{
                            max = mid - 1;
                        }
                        mid = (min + max + 1) / 2;
                    }
                    linBufCyn[tmpBuf] |= (mid+1) << ((cntHrz+1)%2)*4;
                }
            }
            /*--- magenta ----*/
            if(tmpCmy.Mgt){
                dizTbl = dizTblM16 + strXax % DizSizMgt * 15;
                if (tmpCmy.Mgt > dizTbl[0]) {
                    min = 0;    max = 14;    mid = 7;
                    while(min < max){
                        if (tmpCmy.Mgt > dizTbl[mid]) {
                            min = mid;
                        }else{
                            max = mid - 1;
                        }
                        mid = (min + max + 1) / 2;
                    }
                    linBufMgt[tmpBuf] |= (mid+1) << ((cntHrz+1)%2)*4;
                }
            }
            /*--- yellow ----*/
            if(tmpCmy.Yel){
                dizTbl = dizTblY16 + strXax % DizSizYel * 15;
                if (tmpCmy.Yel > dizTbl[0]) {
                    min = 0;    max = 14;    mid = 7;
                    while(min < max){
                        if (tmpCmy.Yel > dizTbl[mid]) {
                            min = mid;
                        }else{
                            max = mid - 1;
                        }
                        mid = (min + max + 1) / 2;
                    }
                    linBufYel[tmpBuf] |= (mid+1) << ((cntHrz+1)%2)*4;
                }
            }
            /*--- balck ----*/
            if(tmpCmy.Bla){
                dizTbl = dizTblB16 + strXax % DizSizBla * 15;
                if (tmpCmy.Bla > dizTbl[0]) {
                    min = 0;    max = 14;    mid = 7;
                    while(min < max){
                        if (tmpCmy.Bla > dizTbl[mid]) {
                            min = mid;
                        }else{
                            max = mid - 1;
                        }
                        mid = (min + max + 1) / 2;
                    }
                    linBufBla[tmpBuf] |= (mid+1) << ((cntHrz+1)%2)*4;
                }
            }
            strXax++;
        }
        return 1;
    }
    /*---- Stretch ----*/
    linByt = (xaxOfs + xaxSiz) * xaxNrt / xaxDnt;
    linByt -= xaxOfs * xaxNrt / xaxDnt;
    linByt = (linByt * 4 + 7) / 8;
    yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
    yaxSet -= yaxOfs * yaxNrt / yaxDnt;
    for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
        dizTblC16 = DizTblC16 + strYax % DizSizCyn * 8 * 15;
        dizTblM16 = DizTblM16 + strYax % DizSizMgt * 8 * 15;
        dizTblY16 = DizTblY16 + strYax % DizSizYel * 8 * 15;
        dizTblB16 = DizTblB16 + strYax % DizSizBla * 8 * 15;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = cmyBuf[cntHrz];
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tmpBuf = tmpXax / 2;
                /*--- cyan ----*/
                if(tmpCmy.Cyn){
                    dizTbl = dizTblC16 + (strXax + tmpXax) % DizSizCyn * 15;
                    if (tmpCmy.Cyn > dizTbl[0]) {
                        min = 0;    max = 14;    mid = 7;
                        while(min < max){
                            if (tmpCmy.Cyn > dizTbl[mid]) {
                                min = mid;
                            }else{
                                max = mid - 1;
                            }
                            mid = (min + max + 1) / 2;
                        }
                        linBufCyn[tmpBuf] |= (mid+1) << ((tmpXax+1)%2)*4;
                    }
                }
                /*--- magenta ----*/
                if(tmpCmy.Mgt){
                    dizTbl = dizTblM16 + (strXax + tmpXax) % DizSizMgt * 15;
                    if (tmpCmy.Mgt > dizTbl[0]) {
                        min = 0;    max = 14;    mid = 7;
                        while(min < max){
                            if (tmpCmy.Mgt > dizTbl[mid]) {
                                min = mid;
                            }else{
                                max = mid - 1;
                            }
                            mid = (min + max + 1) / 2;
                        }
                        linBufMgt[tmpBuf] |= (mid+1) << ((tmpXax+1)%2)*4;
                    }
                }
                /*--- yellow ----*/
                if(tmpCmy.Yel){
                    dizTbl = dizTblY16 + (strXax + tmpXax) % DizSizYel * 15;
                    if (tmpCmy.Yel > dizTbl[0]) {
                        min = 0;    max = 14;    mid = 7;
                        while(min < max){
                            if (tmpCmy.Yel > dizTbl[mid]) {
                                min = mid;
                            }else{
                                max = mid - 1;
                            }
                            mid = (min + max + 1) / 2;
                        }
                        linBufYel[tmpBuf] |= (mid+1) << ((tmpXax+1)%2)*4;
                    }
                }
                /*--- black ----*/
                if(tmpCmy.Bla){
                    dizTbl = dizTblB16 + (strXax + tmpXax) % DizSizBla * 15;
                    if (tmpCmy.Bla > dizTbl[0]) {
                        min = 0;    max = 14;    mid = 7;
                        while(min < max){
                            if (tmpCmy.Bla > dizTbl[mid]) {
                                min = mid;
                            }else{
                                max = mid - 1;
                            }
                            mid = (min + max + 1) / 2;
                        }
                        linBufBla[tmpBuf] |= (mid+1) << ((tmpXax+1)%2)*4;
                    }
                }
                tmpXax++;
            }
        }
        linBufCyn += linByt;
        linBufMgt += linByt;
        linBufYel += linByt;
        linBufBla += linByt;
        strYax++;
    }
    return yaxSet;
}


//===================================================================================================
//    Dithering(600DPI 4value DETAIL)
//===================================================================================================
DWORD WINAPI N403DizSml(
    LPN403DIZINF   lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    LPCMYK         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    DWORD          cntHrz;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          xaxSet;
    DWORD          yaxSet;
    DWORD          linByt;
    DWORD          tmpXax;
    DWORD          tmpBuf;
    DWORD          tblNum;
    LPBYTE         DizTblSml;
    LPBYTE         dizTblSml;
    CMYK           tmpCmy;
    BYTE           lvl001;
    BYTE           lvl002;
    BYTE           lvl003;
    BYTE           tmp001;
    BYTE           tmp002;
    BYTE           tmp003;

    DizTblSml = lpDiz->Diz.Tbl[lpDiz->Diz.Num][0];

    if((xaxNrt == xaxDnt)&&(yaxNrt == yaxDnt)){
        /*---- Not stretch ----*/
        dizTblSml = DizTblSml + strYax % 16 * 16 * 3;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tblNum = strXax % 16 * 3;
            lvl001 = dizTblSml[tblNum + 0];
            lvl002 = dizTblSml[tblNum + 1];
            lvl003 = dizTblSml[tblNum + 2];
            tmp003 = (BYTE)0xc0 >> (cntHrz % 4) * 2;
            tmp002 = (BYTE)0x80 >> (cntHrz % 4) * 2;
            tmp001 = (BYTE)0x40 >> (cntHrz % 4) * 2;
            tmpCmy = *cmyBuf;    cmyBuf++;
            tmpBuf = cntHrz / 4;
            /*--- cyan ----*/
            if(tmpCmy.Cyn > lvl001){
                if(tmpCmy.Cyn > lvl003){
                    linBufCyn[tmpBuf] |= tmp003;
                }else if(tmpCmy.Cyn > lvl002){
                    linBufCyn[tmpBuf] |= tmp002;
                }else{
                    linBufCyn[tmpBuf] |= tmp001;
                }
            }
            /*--- magenta ----*/
            if(tmpCmy.Mgt > lvl001){
                if(tmpCmy.Mgt > lvl003){
                    linBufMgt[tmpBuf] |= tmp003;
                }else if(tmpCmy.Mgt > lvl002){
                    linBufMgt[tmpBuf] |= tmp002;
                }else{
                    linBufMgt[tmpBuf] |= tmp001;
                }
            }
            /*--- yellow ----*/
            if(tmpCmy.Yel > lvl001){
                if(tmpCmy.Yel > lvl003){
                    linBufYel[tmpBuf] |= tmp003;
                }else if(tmpCmy.Yel > lvl002){
                    linBufYel[tmpBuf] |= tmp002;
                }else{
                    linBufYel[tmpBuf] |= tmp001;
                }
            }
            /*--- black ----*/
            if(tmpCmy.Bla > lvl001){
                if(tmpCmy.Bla > lvl003){
                    linBufBla[tmpBuf] |= tmp003;
                }else if(tmpCmy.Bla > lvl002){
                    linBufBla[tmpBuf] |= tmp002;
                }else{
                    linBufBla[tmpBuf] |= tmp001;
                }
            }
            strXax++;
        }
        return 1;
    }
    /*---- Stretch ----*/
    linByt = (xaxOfs + xaxSiz) * xaxNrt / xaxDnt;
    linByt -= xaxOfs * xaxNrt / xaxDnt;
    linByt = (linByt * 2 + 7) / 8;
    yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
    yaxSet -= yaxOfs * yaxNrt / yaxDnt;
    for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
        dizTblSml = DizTblSml + strYax % 16 * 16 * 3;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = cmyBuf[cntHrz];
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tblNum = tmpXax % 16 * 3;
                lvl001 = dizTblSml[tblNum + 0];
                lvl002 = dizTblSml[tblNum + 1];
                lvl003 = dizTblSml[tblNum + 2];
                tmp003 = (BYTE)0xc0 >> (tmpXax % 4) * 2;
                tmp002 = (BYTE)0x80 >> (tmpXax % 4) * 2;
                tmp001 = (BYTE)0x40 >> (tmpXax % 4) * 2;
                tmpBuf = tmpXax / 4;
                /*--- cyan ----*/
                if(tmpCmy.Cyn > lvl001){
                    if(tmpCmy.Cyn > lvl003){
                        linBufCyn[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Cyn > lvl002){
                        linBufCyn[tmpBuf] |= tmp002;
                    }else{
                        linBufCyn[tmpBuf] |= tmp001;
                    }
                }
                /*--- magenta ----*/
                if(tmpCmy.Mgt > lvl001){
                    if(tmpCmy.Mgt > lvl003){
                        linBufMgt[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Mgt > lvl002){
                        linBufMgt[tmpBuf] |= tmp002;
                    }else{
                        linBufMgt[tmpBuf] |= tmp001;
                    }
                }
                /*--- yellow ----*/
                if(tmpCmy.Yel > lvl001){
                    if(tmpCmy.Yel > lvl003){
                        linBufYel[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Yel > lvl002){
                        linBufYel[tmpBuf] |= tmp002;
                    }else{
                        linBufYel[tmpBuf] |= tmp001;
                    }
                }
                /*--- black ----*/
                if(tmpCmy.Bla > lvl001){
                    if(tmpCmy.Bla > lvl003){
                        linBufBla[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Bla > lvl002){
                        linBufBla[tmpBuf] |= tmp002;
                    }else{
                        linBufBla[tmpBuf] |= tmp001;
                    }
                }
                tmpXax++;
            }
        }
        linBufCyn += linByt;
        linBufMgt += linByt;
        linBufYel += linByt;
        linBufBla += linByt;
        strYax++;
    }
    return yaxSet;
}


//===================================================================================================
//    Dithering(600DPI 4value NORMAL)
//===================================================================================================
DWORD WINAPI N403DizPrn(
    LPN403DIZINF   lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    LPCMYK         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    DWORD          cntHrz;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          xaxSet;
    DWORD          yaxSet;
    DWORD          linByt;
    DWORD          tmpXax;
    DWORD          tmpBuf;
    LPBYTE         DizTblPc4;
    LPBYTE         DizTblPm4;
    LPBYTE         DizTblPy4;
    LPBYTE         DizTblPb4;
    LPBYTE         dizTblPc4;
    LPBYTE         dizTblPm4;
    LPBYTE         dizTblPy4;
    LPBYTE         dizTblPb4;
    LPBYTE         dizTbl;
    CMYK           tmpCmy;
    BYTE           tmp001;
    BYTE           tmp002;
    BYTE           tmp003;

    DizTblPc4 = lpDiz->EntDiz.Tbl[0];
    DizTblPm4 = lpDiz->EntDiz.Tbl[1];
    DizTblPy4 = lpDiz->EntDiz.Tbl[2];
    DizTblPb4 = lpDiz->EntDiz.Tbl[3];

    if((xaxNrt == xaxDnt)&&(yaxNrt == yaxDnt)){
        dizTblPc4 = DizTblPc4 + strYax % 16 * 16 * 3;
        dizTblPm4 = DizTblPm4 + strYax % 16 * 16 * 3;
        dizTblPy4 = DizTblPy4 + strYax % 16 * 16 * 3;
        dizTblPb4 = DizTblPb4 + strYax % 16 * 16 * 3;
        /*---- Stretch ----*/
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmp003 = (BYTE)0xc0 >> (cntHrz % 4) * 2;
            tmp002 = (BYTE)0x80 >> (cntHrz % 4) * 2;
            tmp001 = (BYTE)0x40 >> (cntHrz % 4) * 2;
            tmpCmy = *cmyBuf;    cmyBuf++;
            tmpBuf = cntHrz / 4;
            /*--- cyan ----*/
            dizTbl = dizTblPc4 + strXax % 16 * 3;
            if(tmpCmy.Cyn > dizTbl[0]){
                if(tmpCmy.Cyn > dizTbl[2]){
                    linBufCyn[tmpBuf] |= tmp003;
                }else if(tmpCmy.Cyn > dizTbl[1]){
                    linBufCyn[tmpBuf] |= tmp002;
                }else{
                    linBufCyn[tmpBuf] |= tmp001;
                }
            }
            /*--- magenta ----*/
            dizTbl = dizTblPm4 + strXax % 16 * 3;
            if(tmpCmy.Mgt > dizTbl[0]){
                if(tmpCmy.Mgt > dizTbl[2]){
                    linBufMgt[tmpBuf] |= tmp003;
                }else if(tmpCmy.Mgt > dizTbl[1]){
                    linBufMgt[tmpBuf] |= tmp002;
                }else{
                    linBufMgt[tmpBuf] |= tmp001;
                }
            }
            /*--- yellow ----*/
            dizTbl = dizTblPy4 + strXax % 16 * 3;
            if(tmpCmy.Yel > dizTbl[0]){
                if(tmpCmy.Yel > dizTbl[2]){
                    linBufYel[tmpBuf] |= tmp003;
                }else if(tmpCmy.Yel > dizTbl[1]){
                    linBufYel[tmpBuf] |= tmp002;
                }else{
                    linBufYel[tmpBuf] |= tmp001;
                }
            }
            /*--- black ----*/
            dizTbl = dizTblPb4 + strXax % 16 * 3;
            if(tmpCmy.Bla > dizTbl[0]){
                if(tmpCmy.Bla > dizTbl[2]){
                    linBufBla[tmpBuf] |= tmp003;
                }else if(tmpCmy.Bla > dizTbl[1]){
                    linBufBla[tmpBuf] |= tmp002;
                }else{
                    linBufBla[tmpBuf] |= tmp001;
                }
            }
            strXax++;
        }
        return 1;
    }
    /*---- Stretch ----*/
    linByt = (xaxOfs + xaxSiz) * xaxNrt / xaxDnt;
    linByt -= xaxOfs * xaxNrt / xaxDnt;
    linByt = (linByt * 2 + 7) / 8;
    yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
    yaxSet -= yaxOfs * yaxNrt / yaxDnt;
    for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
        dizTblPc4 = DizTblPc4 + strYax % 16 * 16 * 3;
        dizTblPm4 = DizTblPm4 + strYax % 16 * 16 * 3;
        dizTblPy4 = DizTblPy4 + strYax % 16 * 16 * 3;
        dizTblPb4 = DizTblPb4 + strYax % 16 * 16 * 3;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpCmy = cmyBuf[cntHrz];
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tmp003 = (BYTE)0xc0 >> (tmpXax % 4) * 2;
                tmp002 = (BYTE)0x80 >> (tmpXax % 4) * 2;
                tmp001 = (BYTE)0x40 >> (tmpXax % 4) * 2;
                tmpBuf = tmpXax / 4;
                /*--- cyan ----*/
                dizTbl = dizTblPc4 + (strXax + tmpXax) % 16 * 3;
                if(tmpCmy.Cyn > dizTbl[0]){
                    if(tmpCmy.Cyn > dizTbl[2]){
                        linBufCyn[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Cyn > dizTbl[1]){
                        linBufCyn[tmpBuf] |= tmp002;
                    }else{
                        linBufCyn[tmpBuf] |= tmp001;
                    }
                }
                /*--- magenta ----*/
                dizTbl = dizTblPm4 + (strXax + tmpXax) % 16 * 3;
                if(tmpCmy.Mgt > dizTbl[0]){
                    if(tmpCmy.Mgt > dizTbl[2]){
                        linBufMgt[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Mgt > dizTbl[1]){
                        linBufMgt[tmpBuf] |= tmp002;
                    }else{
                        linBufMgt[tmpBuf] |= tmp001;
                    }
                }
                /*--- yellow ----*/
                dizTbl = dizTblPy4 + (strXax + tmpXax) % 16 * 3;
                if(tmpCmy.Yel > dizTbl[0]){
                    if(tmpCmy.Yel > dizTbl[2]){
                        linBufYel[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Yel > dizTbl[1]){
                        linBufYel[tmpBuf] |= tmp002;
                    }else{
                        linBufYel[tmpBuf] |= tmp001;
                    }
                }
                /*--- black ----*/
                dizTbl = dizTblPb4 + (strXax + tmpXax) % 16 * 3;
                if(tmpCmy.Bla > dizTbl[0]){
                    if(tmpCmy.Bla > dizTbl[2]){
                        linBufBla[tmpBuf] |= tmp003;
                    }else if(tmpCmy.Bla > dizTbl[1]){
                        linBufBla[tmpBuf] |= tmp002;
                    }else{
                        linBufBla[tmpBuf] |= tmp001;
                    }
                }
                tmpXax++;
            }
        }
        linBufCyn += linByt;
        linBufMgt += linByt;
        linBufYel += linByt;
        linBufBla += linByt;
        strYax++;
    }
    return yaxSet;
}


//===================================================================================================
//    Color matching(high speed)
//===================================================================================================
VOID WINAPI N403ColMch000(
    LPN403DIZINF   lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz,
    DWORD          blaCnv
)
{
    LPRGB          endAdr;
    LPCMYK         LokUppRgbCmy;
    LPBYTE         innTblCmy;
    LONG           tmpRed;
    LONG           tmpGrn;
    LONG           tmpBlu;
    LONG           tmpCal;
    CMYK           tmpCmy;

    LokUppRgbCmy = lpDiz->Lut.Tbl;
    innTblCmy = lpDiz->Tnr.Tbl;

    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Green;
        tmpBlu = rgbAdr->Blue;
        if((blaCnv == 0)&&((tmpRed | tmpGrn | tmpBlu) == 0)){
            tmpCmy.Cyn = 0;
            tmpCmy.Mgt = 0;
            tmpCmy.Yel = 0;
            tmpCmy.Bla = 255;
            *cmyAdr = tmpCmy;
            cmyAdr++;
            continue;
        }
        tmpCal  = tmpRed / N403_GLDSPC * N403_GLDNUM * N403_GLDNUM;
        tmpCal += tmpGrn / N403_GLDSPC * N403_GLDNUM;
        tmpCal += tmpBlu / N403_GLDSPC;
        tmpCmy = LokUppRgbCmy[tmpCal];
        tmpCmy.Cyn = innTblCmy[tmpCmy.Cyn];
        tmpCmy.Mgt = innTblCmy[tmpCmy.Mgt];
        tmpCmy.Yel = innTblCmy[tmpCmy.Yel];
        tmpCmy.Bla = innTblCmy[tmpCmy.Bla];
        *cmyAdr = tmpCmy;
        cmyAdr++;
    }
}


//===================================================================================================
//    Color matching(normal speed)
//===================================================================================================
VOID WINAPI N403ColMch001(
    LPN403DIZINF   lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz,
    DWORD          blaCnv
)
{
    LONG           tmpRed;
    LONG           tmpGrn;
    LONG           tmpBlu;
    LONG           tmpR01;
    LONG           tmpR02;
    LONG           tmpG01;
    LONG           tmpG02;
    LONG           tmpB01;
    LONG           tmpB02;
    LONG           ln1;
    LONG           ln2;
    LONG           ln3;

    LONG           tmpC00;
    LONG           tmpM00;
    LONG           tmpY00;
    LONG           tmpK00;
    LONG           tmpC01;
    LONG           tmpM01;
    LONG           tmpY01;
    LONG           tmpK01;
    LONG           tmpC02;
    LONG           tmpM02;
    LONG           tmpY02;
    LONG           tmpK02;
    LONG           tmpC03;
    LONG           tmpM03;
    LONG           tmpY03;
    LONG           tmpK03;

    LPCMYK         LokUppRgbCmy;
    LPBYTE         innTblCmy;
    LPRGB          CchRgb;
    LPCMYK         CchCmy;

    LPRGB          endAdr;
    DWORD          cch;
    RGBS           tmpRgb;
    CMYK           tmpCmy;

    LokUppRgbCmy = lpDiz->Lut.Tbl;
    innTblCmy = lpDiz->Tnr.Tbl;
    CchRgb = lpDiz->Lut.CchRgb;
    CchCmy = lpDiz->Lut.CchCmy;

    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        tmpRgb = *rgbAdr;
        tmpRed = tmpRgb.Red;
        tmpGrn = tmpRgb.Green;
        tmpBlu = tmpRgb.Blue;
        if((blaCnv == 0)&&((tmpRed | tmpGrn | tmpBlu) == 0)){
            tmpCmy.Cyn = 0;
            tmpCmy.Mgt = 0;
            tmpCmy.Yel = 0;
            tmpCmy.Bla = 255;
            *cmyAdr = tmpCmy;
            cmyAdr++;
            continue;
        }

        /*---- Cache color matching ----*/
        cch = ( tmpRed * 49 + tmpGrn * 9 + tmpBlu ) % N403_CCHNUM;
        if(    (CchRgb[cch].Red == tmpRgb.Red) &&
            (CchRgb[cch].Green == tmpRgb.Green) &&
            (CchRgb[cch].Blue == tmpRgb.Blue)
        ){
            *cmyAdr = CchCmy[cch];
            cmyAdr++;
            continue;
        }

        /*---- RGB -> CMYK ----*/
        tmpR01 = tmpRed * 31 / 255;
        tmpR02 = (tmpRed * 31 + 254) / 255;

        tmpG01 = tmpGrn * 31 / 255;
        tmpG02 = (tmpGrn * 31 + 254) / 255;

        tmpB01 = tmpBlu * 31 / 255;
        tmpB02 = (tmpBlu * 31 + 254) / 255;


        ln2 = tmpRed - tmpR01*255/31;
        if(ln2 == 0){
            tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB01];
            tmpC00 = tmpCmy.Cyn;
            tmpM00 = tmpCmy.Mgt;
            tmpY00 = tmpCmy.Yel;
            tmpK00 = tmpCmy.Bla;
            tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB02];
            tmpC01 = tmpCmy.Cyn;
            tmpM01 = tmpCmy.Mgt;
            tmpY01 = tmpCmy.Yel;
            tmpK01 = tmpCmy.Bla;
            tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB01];
            tmpC02 = tmpCmy.Cyn;
            tmpM02 = tmpCmy.Mgt;
            tmpY02 = tmpCmy.Yel;
            tmpK02 = tmpCmy.Bla;
            tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB02];
            tmpC03 = tmpCmy.Cyn;
            tmpM03 = tmpCmy.Mgt;
            tmpY03 = tmpCmy.Yel;
            tmpK03 = tmpCmy.Bla;
        }else{
            ln1 = tmpR02*255/31 - tmpRed;
            if(ln1 == 0){
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB01];
                tmpC00 = tmpCmy.Cyn;
                tmpM00 = tmpCmy.Mgt;
                tmpY00 = tmpCmy.Yel;
                tmpK00 = tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB02];
                tmpC01 = tmpCmy.Cyn;
                tmpM01 = tmpCmy.Mgt;
                tmpY01 = tmpCmy.Yel;
                tmpK01 = tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB01];
                tmpC02 = tmpCmy.Cyn;
                tmpM02 = tmpCmy.Mgt;
                tmpY02 = tmpCmy.Yel;
                tmpK02 = tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB02];
                tmpC03 = tmpCmy.Cyn;
                tmpM03 = tmpCmy.Mgt;
                tmpY03 = tmpCmy.Yel;
                tmpK03 = tmpCmy.Bla;
            }else{
                ln3 = ln1 + ln2;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB01];
                tmpC00 = ln1 * tmpCmy.Cyn;
                tmpM00 = ln1 * tmpCmy.Mgt;
                tmpY00 = ln1 * tmpCmy.Yel;
                tmpK00 = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB01];
                tmpC00 += ln2 * tmpCmy.Cyn;
                tmpM00 += ln2 * tmpCmy.Mgt;
                tmpY00 += ln2 * tmpCmy.Yel;
                tmpK00 += ln2 * tmpCmy.Bla;
                tmpC00 /= ln3;
                tmpM00 /= ln3;
                tmpY00 /= ln3;
                tmpK00 /= ln3;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB02];
                tmpC01  = ln1 * tmpCmy.Cyn;
                tmpM01  = ln1 * tmpCmy.Mgt;
                tmpY01  = ln1 * tmpCmy.Yel;
                tmpK01  = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG01 * N403_GLDNUM + tmpB02];
                tmpC01 += ln2 * tmpCmy.Cyn;
                tmpM01 += ln2 * tmpCmy.Mgt;
                tmpY01 += ln2 * tmpCmy.Yel;
                tmpK01 += ln2 * tmpCmy.Bla;
                tmpC01 /= ln3;
                tmpM01 /= ln3;
                tmpY01 /= ln3;
                tmpK01 /= ln3;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB01];
                tmpC02  = ln1 * tmpCmy.Cyn;
                tmpM02  = ln1 * tmpCmy.Mgt;
                tmpY02  = ln1 * tmpCmy.Yel;
                tmpK02  = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB01];
                tmpC02 += ln2 * tmpCmy.Cyn;
                tmpM02 += ln2 * tmpCmy.Mgt;
                tmpY02 += ln2 * tmpCmy.Yel;
                tmpK02 += ln2 * tmpCmy.Bla;
                tmpC02 /= ln3;
                tmpM02 /= ln3;
                tmpY02 /= ln3;
                tmpK02 /= ln3;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB02];
                tmpC03  = ln1 * tmpCmy.Cyn;
                tmpM03  = ln1 * tmpCmy.Mgt;
                tmpY03  = ln1 * tmpCmy.Yel;
                tmpK03  = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N403_GLDNUM * N403_GLDNUM + tmpG02 * N403_GLDNUM + tmpB02];
                tmpC03 += ln2 * tmpCmy.Cyn;
                tmpM03 += ln2 * tmpCmy.Mgt;
                tmpY03 += ln2 * tmpCmy.Yel;
                tmpK03 += ln2 * tmpCmy.Bla;
                tmpC03 /= ln3;
                tmpM03 /= ln3;
                tmpY03 /= ln3;
                tmpK03 /= ln3;
            }
        }


        ln2 = tmpGrn - tmpG01*255/31;
        if(ln2 != 0){
            ln1 = tmpG02*255/31 - tmpGrn;
            if(ln1 == 0){
                tmpC00 = tmpC02;
                tmpM00 = tmpM02;
                tmpY00 = tmpY02;
                tmpK00 = tmpK02;
                tmpC01 = tmpC03;
                tmpM01 = tmpM03;
                tmpY01 = tmpY03;
                tmpK01 = tmpK03;
            }else{
                ln3 = ln1 + ln2;
                tmpC00 = (ln1*tmpC00 + ln2*tmpC02) / ln3;
                tmpM00 = (ln1*tmpM00 + ln2*tmpM02) / ln3;
                tmpY00 = (ln1*tmpY00 + ln2*tmpY02) / ln3;
                tmpK00 = (ln1*tmpK00 + ln2*tmpK02) / ln3;
                tmpC01 = (ln1*tmpC01 + ln2*tmpC03) / ln3;
                tmpM01 = (ln1*tmpM01 + ln2*tmpM03) / ln3;
                tmpY01 = (ln1*tmpY01 + ln2*tmpY03) / ln3;
                tmpK01 = (ln1*tmpK01 + ln2*tmpK03) / ln3;
            }
        }


        ln2 = tmpBlu - tmpB01*255/31;
        if(ln2 != 0){
            ln1 = tmpB02*255/31 - tmpBlu;
            if(ln1 == 0){
                tmpC00 = tmpC01;
                tmpM00 = tmpM01;
                tmpY00 = tmpY01;
                tmpK00 = tmpK01;
            }else{
                ln3 = ln1 + ln2;
                tmpC00 = (ln1*tmpC00 + ln2*tmpC01) / ln3;
                tmpM00 = (ln1*tmpM00 + ln2*tmpM01) / ln3;
                tmpY00 = (ln1*tmpY00 + ln2*tmpY01) / ln3;
                tmpK00 = (ln1*tmpK00 + ln2*tmpK01) / ln3;
            }
        }

        tmpCmy.Cyn  = innTblCmy[tmpC00];
        tmpCmy.Mgt  = innTblCmy[tmpM00];
        tmpCmy.Yel  = innTblCmy[tmpY00];
        tmpCmy.Bla  = innTblCmy[tmpK00];
        *cmyAdr = tmpCmy;
        cmyAdr++;

        CchRgb[cch] = tmpRgb;
        CchCmy[cch] = tmpCmy;
    }
}


//===================================================================================================
//    CMYK data color vividly
//===================================================================================================
VOID WINAPI N403ColVivPrc(
    LPN403DIZINF   lpDiz,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz,
    DWORD          vivNum
)
{
    LPCMYK         endAdr;
    LONG           tmpCyn;
    LONG           tmpMgt;
    LONG           tmpYel;
    LONG           tmpMid;

    for(endAdr = cmyAdr+xaxSiz ; cmyAdr < endAdr ; cmyAdr++){
        tmpCyn = cmyAdr->Cyn;
        tmpMgt = cmyAdr->Mgt;
        tmpYel = cmyAdr->Yel;
        tmpMid = (tmpCyn + tmpMgt + tmpYel) / 3;
        tmpCyn += (tmpCyn - tmpMid) * (SHORT)vivNum / 100;
        tmpMgt += (tmpMgt - tmpMid) * (SHORT)vivNum / 100;
        tmpYel += (tmpYel - tmpMid) * (SHORT)vivNum / 100;
        if(tmpCyn < 0){tmpCyn = 0;}else if(tmpCyn > 255){tmpCyn = 255;}
        if(tmpMgt < 0){tmpMgt = 0;}else if(tmpMgt > 255){tmpMgt = 255;}
        if(tmpYel < 0){tmpYel = 0;}else if(tmpYel > 255){tmpYel = 255;}
        cmyAdr->Cyn = (BYTE)tmpCyn;
        cmyAdr->Mgt = (BYTE)tmpMgt;
        cmyAdr->Yel = (BYTE)tmpYel;
    }
}


//===================================================================================================
//    RGB -> CMYK conversion(No matching)
//===================================================================================================
VOID WINAPI N403ColCnvSld(
    LPN403DIZINF   lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz,
    DWORD          blaCnv
)
{
    LPRGB          endAdr;
    DWORD          tmpRed;
    DWORD          tmpGrn;
    DWORD          tmpBlu;
    LPBYTE         innTblCmy;

    innTblCmy = lpDiz->Tnr.Tbl;
    if(innTblCmy != NULL){
        for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
            tmpRed = rgbAdr->Red;
            tmpGrn = rgbAdr->Green;
            tmpBlu = rgbAdr->Blue;
            if((blaCnv == 0)&&((tmpRed | tmpGrn | tmpBlu) == 0)){
                cmyAdr->Cyn = 0;
                cmyAdr->Mgt = 0;
                cmyAdr->Yel = 0;
                cmyAdr->Bla = 255;
                cmyAdr++;
                continue;
            }
            cmyAdr->Cyn = innTblCmy[255 - GinTblP15[tmpRed]];
            cmyAdr->Mgt = innTblCmy[255 - GinTblP15[tmpGrn]];
            cmyAdr->Yel = innTblCmy[255 - GinTblP15[tmpBlu]];
            cmyAdr->Bla = 0;
            cmyAdr++;
        }
        return;
    }
    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Green;
        tmpBlu = rgbAdr->Blue;
        if((blaCnv == 0)&&((tmpRed | tmpGrn | tmpBlu) == 0)){
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            cmyAdr->Bla = 255;
            cmyAdr++;
            continue;
        }
        cmyAdr->Cyn = (BYTE)255 - GinTblP15[tmpRed];
        cmyAdr->Mgt = (BYTE)255 - GinTblP15[tmpGrn];
        cmyAdr->Yel = (BYTE)255 - GinTblP15[tmpBlu];
        cmyAdr->Bla = 0;
        cmyAdr++;
    }
}


//===================================================================================================
//    RGB -> CMYK conversion (for 1dot line)
//===================================================================================================
VOID WINAPI N403ColCnvL02(
    LPN403DIZINF   lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz
)
{
    LPRGB          endAdr;
    DWORD          tmpRed;
    DWORD          tmpGrn;
    DWORD          tmpBlu;
    DWORD          tmpMid;
    BYTE           tmpCyn;
    BYTE           tmpMgt;
    BYTE           tmpYel;

    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Green;
        tmpBlu = rgbAdr->Blue;
        tmpMid = (tmpRed + tmpGrn + tmpBlu) / 3;
        if(tmpMid > 240){
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            cmyAdr->Bla = 0;
            cmyAdr++;
            continue;
        }
        tmpCyn = 255;
        tmpMgt = 255;
        tmpYel = 255;
        tmpMid += (255 - tmpMid) / 8;
        if(tmpRed > tmpMid){ tmpCyn = 0; }
        if(tmpGrn > tmpMid){ tmpMgt = 0; }
        if(tmpBlu > tmpMid){ tmpYel = 0; }
        if((tmpCyn & tmpMgt & tmpYel) == 255){
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            cmyAdr->Bla = 255;
            cmyAdr++;
            continue;
        }
        cmyAdr->Cyn = tmpCyn;
        cmyAdr->Mgt = tmpMgt;
        cmyAdr->Yel = tmpYel;
        cmyAdr->Bla = 0;
        cmyAdr++;
    }
}


//===================================================================================================
//    RGB -> CMYK conversion (for monochrome)
//===================================================================================================
VOID WINAPI N403ColCnvMon(
    LPN403DIZINF   lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz
)
{
    LPRGB          endAdr;
    DWORD          red;
    DWORD          grn;
    DWORD          blu;
    BYTE           bla;
    LPBYTE         innTblCmy;

    innTblCmy = lpDiz->Tnr.Tbl;
    if(innTblCmy != NULL){
        for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
            red = rgbAdr->Red;
            grn = rgbAdr->Green;
            blu = rgbAdr->Blue;
            bla = innTblCmy[255 - GinTblP10[(red*3 + grn*5 + blu*2) / 10]];
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            cmyAdr->Bla = bla;
            cmyAdr++;
        }
        return;
    }
    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        red = rgbAdr->Red;
        grn = rgbAdr->Green;
        blu = rgbAdr->Blue;
        bla = (BYTE)255 - GinTblP10[(red*3 + grn*5 + blu*2) / 10];
        cmyAdr->Cyn = 0;
        cmyAdr->Mgt = 0;
        cmyAdr->Yel = 0;
        cmyAdr->Bla = bla;
        cmyAdr++;
    }
}


// End of N403DIZ.C

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\csn46res.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    Csn46res.c

Abstract:

    Implementation of GPD command callback for "Csn46j.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    09/10/97
        Created it.

--*/


#include "PDEV.H"
#include <stdio.h>
#include "PRNCTL.H"


//
// Misc definitions and declarations.
//
#define BUFFLEN                     256

#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

#define SWAPW(x) \
    ((WORD)(((WORD)(x))<<8)|(WORD)(((WORD)(x))>>8))

#define FONT_HEADER_SIZE            0x86            // format type 2
#define SIZE_SYMBOLSET              28
#define FONT_MIN_ID                 512
#define FONT_MAX_ID                 535
#define SJISCHR                     0x2000

#define IsValidDLFontID(x) \
    ((x) >= FONT_MIN_ID && (x) <= FONT_MAX_ID)

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes);

LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr);

//
// Command callback ID's
//
#define TEXT_FS_SINGLE_BYTE     21
#define TEXT_FS_DOUBLE_BYTE     22

#define DOWNLOAD_SET_FONT_ID    23
#define DOWNLOAD_SELECT_FONT_ID 24
#define DOWNLOAD_SET_CHAR_CODE  25
#define DOWNLOAD_DELETE_FONT    26

#define FS_BOLD_ON              27
#define FS_BOLD_OFF             28
#define FS_ITALIC_ON            29
#define FS_ITALIC_OFF           30

#define PC_BEGINDOC             82
#define PC_ENDDOC               83

#define PC_DUPLEX_NONE          90
#define PC_DUPLEX_VERT          91
#define PC_DUPLEX_HORZ          92
#define PC_PORTRAIT             93
#define PC_LANDSCAPE            94

#define PSRC_SELECT_CASETTE_1   100
#define PSRC_SELECT_CASETTE_2   101
#define PSRC_SELECT_CASETTE_3   102
#define PSRC_SELECT_MPF         103
#define PSRC_SELECT_AUTO        104

#define TONER_SAVE_NONE         110
#define TONER_SAVE_1            111
#define TONER_SAVE_2            112
#define TONER_SAVE_3            113
#define SMOOTHING_ON            120
#define SMOOTHING_OFF           121
#define JAMRECOVERY_ON          130
#define JAMRECOVERY_OFF         131
#define MEDIATYPE_1             140
#define MEDIATYPE_2             141
#define RECT_FILL_WIDTH         150
#define RECT_FILL_HEIGHT        151
#define RECT_FILL_GRAY          152
#define RECT_FILL_WHITE         153
#define RECT_FILL_BLACK         154

#define START_PAGE              160

#if 0   /* OEM doesn't want to fix minidriver */
/* Below is def. for hack code to fix #412276 */
#define COLOR_SELECT_BLACK      170
#define COLOR_SELECT_RED        171
#define COLOR_SELECT_GREEN      172
#define COLOR_SELECT_BLUE       173
#define COLOR_SELECT_YELLOW     174
#define COLOR_SELECT_MAGENTA    175
#define COLOR_SELECT_CYAN       176
#define COLOR_SELECT_WHITE      177

#define DUMP_RASTER_CYAN        180
#define DUMP_RASTER_MAGENTA     181
#define DUMP_RASTER_YELLOW      182
#define DUMP_RASTER_BLACK       183
/* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */


#define DEFINE_PALETTE_ENTRY    300
#define BEGIN_PALETTE_DEF       301
#define END_PALETTE_DEF         302
#define SELECT_PALETTE_ENTRY    303

#define OPT_DITHERING_ON        "Normal"
#define OPT_DITHERING_DET       "Detail"
#define OPT_DITHERING_OFF       "Diz_Off"

#define OPT_DITHERING_PIC       "PicImage"
#define OPT_DITHERING_GRA       "Graphic"
#define OPT_DITHERING_CAR       "Character"
#define OPT_DITHERING_GOSA      "Gosa"

#define OPT_N4_NONE             "N4_Off"
#define OPT_N403_NONE           "N4-612_Off"
#define OPT_COLORMATCH_NORMAL   "NormalCol"
#define OPT_COLORMATCH_VIVCOL   "VividCol"
#define OPT_COLORMATCH_NATCOL   "NaturalCol"
#define OPT_COLORMATCH_BRI      "ForBright"
#define OPT_COLORMATCH_VIV      "ForVivid"
#define OPT_COLORMATCH_IRO      "ForIro"

#define OPT_MONO                "Monochrome"
#define OPT_COLOR               "8 Color(Halftoned)"
#define OPT_COLOR_SINGLE        "Color_Single"
#define OPT_COLOR_MANY          "Color_Many"

#define OPT_1                   "Option1"
#define OPT_2                   "Option2"

#define OPT_AUTO                "Auto"
#define OPT_RASTER              "Raster"
#define OPT_PRESSOFF            "PressOff"


//
// ---- S T R U C T U R E  D E F I N E ----
//
typedef BYTE * LPDIBITS;

typedef struct {
   WORD Integer;
   WORD Fraction;
} FRAC;

typedef struct {
    BYTE bFormat;
    BYTE bDataDir;
    WORD wCharCode;
    WORD wBitmapWidth;
    WORD wBitmapHeight;
    WORD wLeftOffset;
    WORD wAscent;
    FRAC CharWidth;
} ESCPAGECHAR;

typedef struct {
   WORD wFormatType;
   WORD wDataSize;
   WORD wSymbolSet;
   WORD wCharSpace;
   FRAC CharWidth;
   FRAC CharHeight;
   WORD wFontID;
   WORD wWeight;
   WORD wEscapement;
   WORD wItalic;
   WORD wLast;
   WORD wFirst;
   WORD wUnderline;
   WORD wUnderlineWidth;
   WORD wOverline;
   WORD wOverlineWidth;
   WORD wStrikeOut;
   WORD wStrikeOutWidth;
   WORD wCellWidth;
   WORD wCellHeight;
   WORD wCellLeftOffset;
   WORD wCellAscender;
   FRAC FixPitchWidth;
} ESCPAGEHEADER, FAR * LPESCPAGEHEADER;

//
// Static data to be used by this minidriver.
//

BYTE bit_mask[] = {0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe};

BYTE BEGINDOC_EJL_BEGIN[] =
    "\x1bz\x00\x80"
    "\x1b\x01@EJL \x0a"
    "@EJL SET";
BYTE BEGINDOC_EJL_END[] =
    " ERRORCODE=ON"
    "\x0a"
    "@EJL EN LA=ESC/PAGE\x0a";
BYTE BEGINDOC_EPG_END[] =
    "\x1DrhE\x1D\x32\x34ifF\x1D\x31\x34isE"
    "\x1D\x32iaF\x1D\x31\x30ifF"
    "\x1D\x31ipP"
    "\x1B\x7A\xD0\x01\x43\x61\x2A\x1B\x7A\x00\x01"
    "\x1D\x30pmP";
BYTE ENDDOC_EJL_RESET[] = "\x1drhE"
    "\x1b\x01@EJL \x0a"
    "\x1b\x01@EJL \x0a"
    "\x1bz\xb0\x00";

BYTE CMD_START_PAGE[] =
    "\x1Bz\xD0\x01" "Ca*\x1Bz\x00\x01"
    "\x1D" "1alfP\x1D" "1affP\x1D"
    "0;0;0clfP\x1D" "0X\x1D" "0Y";

BYTE SET_FONT_ID[]        = "\x1D%d;%ddh{F";
BYTE DLI_SELECT_FONT_ID[] = "\x1D%ddcF\x1D\x30;-%dcoP";
BYTE DLI_DELETE_FONT[]    = "\x1D%dddcF";
BYTE SET_SINGLE_BMP[]     = "\x1D%d;%dsc{F";
BYTE SET_DOUBLE_BMP[]     = "\x1D%d;%d;%dsc{F";
BYTE SET_WIDTH_TBL[]      = "\x1D%d;%dcw{F";

BYTE FS_SINGLE_BYTE[]     = "\x1D\x31;0mcF";
BYTE FS_DOUBLE_BYTE[]     = "\x1D\x31;1mcF";
BYTE PRN_DIRECTION[]      = "\x1D%droF";
BYTE SET_CHAR_OFFSET[]    = "\x1D\x30;%dcoP";
BYTE SET_CHAR_OFFSET_XY[] = "\x1D%d;%dcoP";
BYTE VERT_FONT_SET[]      = "\x1D%dvpC";
BYTE BOLD_SET[]           = "\x1D%dweF";
BYTE ITALIC_SET[]         = "\x1D%dslF";

BYTE ORG_MODE_IN[]        = "\x1Bz\xD0\x01";
BYTE ORG_MODE_OUT[]       = "\x1Bz\x00\x01";
BYTE PALETTE_SELECT[]     = "Cd,%d,%d*";
BYTE PALETTE_DEFINE[]     = "Cf,%d,%d,%d,%d,%d*";

BYTE RECT_FILL[] = 
    "\x1D" "1owE"
    "\x1D" "1tsE"
    "\x1D" "0;0;%dspE"
    "\x1D" "1dmG"
    "\x1D" "%d;%d;%d;%d;0rG"
// do not turn overwrite mode off since it
// has bad effect over white-on-black texts
//    "\x1D" "0owE"
    "\x1D" "0tsE";

BYTE OVERWRITE[] = 
    "\x1D" "1owE"
    "\x1D" "1tsE"
    "\x1D" "1;0;100spE";

#define PSRC_CASETTE_1  0
#define PSRC_CASETTE_2  1
#define PSRC_CASETTE_3  2
#define PSRC_MPF        3
#define PSRC_AUTO       4
BYTE *EJL_SelectPsrc[] = {
   " PU=1", " PU=2", " PU=3", " PU=4", " PU=AU" };

BYTE *EJL_SelectOrient[] = {
   " ORIENTATION=PORTRAIT", " ORIENTATION=LANDSCAPE" };

BYTE *EJL_SelectRes[] = {
   " ##RZ=OFF",  " ##RZ=ON" };
BYTE *EPg_SelectRes[] = {
    "\x1D" "0;300;300drE\x1D" "1;300;300drE\x1D" "2;240;240drE",
    "\x1D" "0;600;600drE\x1D" "1;600;600drE\x1D" "2;240;240drE" };

BYTE *EJL_SetColorTone[] = {
    " ##LE=OFF", " ##LE=ON" };

#define DUPLEX_NONE   0
#define DUPLEX_SIDE   1
#define DUPLEX_UP     2
BYTE *EJL_SetDuplex[] = {
   " ##DC=OFF", " ##DC=DUPON", " ##DC=DUPUP" };

#define XX_TONER_NORMAL 0
#define XX_TONER_SAVE_1 1
#define XX_TONER_SAVE_2 2
#define XX_TONER_SAVE_3 3
BYTE *EJL_SetTonerSave[] = {
    " ##TS=NORMAL", " ##TS=1", " ##TS=2",  " ##TS=3" };

BYTE *EJL_SetColorMode[] = {
    " ##CM=OFF", " ##CM=ON" };

#define XX_SMOOTHING_OFF 0
#define XX_SMOOTHING_ON  1
BYTE *EJL_SetSmoohing[] = {
    " RI=OFF", " RI=ON" };

#define XX_JAMRECOVERY_OFF 0
#define XX_JAMRECOVERY_ON  1
BYTE *EJL_SetJamRecovery[] = {
    " ##JC=OFF", " ##JC=ON" };

#define XX_MEDIATYPE_1 1
#define XX_MEDIATYPE_2 2
BYTE *EJL_SetMediaType[] = {
    " PK=NM", " PK=OS" };

#if 0    /* OEM doesn't want to fix minidriver */
/* Below is def. for hack code to fix #412276 */
BYTE *COLOR_SELECT_COMMAND[] = {
    "\x1Bz\xD0\x01\x43\x63,0,0,0,255*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Black   */
    "\x1Bz\xD0\x01\x43\x62,255,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Red     */
    "\x1Bz\xD0\x01\x43\x62,0,255,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Green   */
    "\x1Bz\xD0\x01\x43\x62,0,0,255*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Blue    */
    "\x1Bz\xD0\x01\x43\x63,0,0,255,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Yellow  */
    "\x1Bz\xD0\x01\x43\x63,0,255,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Magenta */
    "\x1Bz\xD0\x01\x43\x63,255,0,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Cyan    */
    "\x1Bz\xD0\x01\x43\x63,0,0,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE"       /* White   */
};
DWORD COLOR_SELECT_COMMAND_LEN[] = { 42, 39, 39, 39, 42, 42, 42, 39 };

BYTE *DUMP_RASTER_COMMAND[] = {
    "\x1Bz\xD0\x01\x43\x63,255,0,0,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Cyan    */
    "\x1Bz\xD0\x01\x43\x63,0,255,0,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Magenta */
    "\x1Bz\xD0\x01\x43\x63,0,0,255,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Yellow  */
    "\x1Bz\xD0\x01\x43\x63,0,0,0,255*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE"       /* Black   */
};
#define DUMP_RASTER_COMMAND_LEN  31
/* End of hack code */
#endif   /* OEM doesn't want to fix minidriver */

#define MasterToDevice(p, i) \
     ((i) / ((PMYPDEV)(p))->iUnitFactor)

#define PARAM(p,n) \
    (*((p)+(n)))

VOID
VSetSelectDLFont(
    PDEVOBJ pdevobj,
    DWORD dwFontID)
{
    PMYPDEV pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    BYTE Cmd[BUFFLEN];
    WORD wlen = 0;

    wlen += (WORD)wsprintf(Cmd, DLI_SELECT_FONT_ID, 
        (dwFontID - FONT_MIN_ID), 0);

//    if(pOEM->fGeneral & FG_VERT) {
//        wlen += wsprintf(&Cmd[wlen], VERT_FONT_SET, 0);
//        pOEM->fGeneral &= ~FG_VERT;
//
//    }

    WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);

    pOEM->dwDLFontID = dwFontID;

    DL_VERBOSE(("Set/Select: dwFontID=%x\n", dwFontID));
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMEnablePDEV
//////////////////////////////////////////////////////////////////////////

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PMYPDEV         pOEM;
    BYTE            byOutput[64];
    DWORD           dwNeeded;
    DWORD           dwOptionsReturned;

    MY_VERBOSE(("\nOEMEnablePdev ENTRY\n"));

    if (!pdevobj->pdevOEM)
    {
        if (!(pdevobj->pdevOEM = MemAllocZ(sizeof(MYPDEV))))
        {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));
            return NULL;
        }
    }

    pOEM = (PMYPDEV)pdevobj->pdevOEM;

    pOEM->fGeneral = 0;
    pOEM->iEscapement = 0;
    pOEM->sHeightDiv = 0;
    pOEM->iDevCharOffset = 0;
    pOEM->iPaperSource = 0;
    pOEM->iDuplex = 0;
    pOEM->iTonerSave = 0;
    pOEM->iOrientation = 0;
    pOEM->iSmoothing = 0;
    pOEM->iJamRecovery = 0;
    pOEM->iMediaType = 0;
    pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
    pOEM->dwDLSelectFontID = UNKNOWN_DLFONT_ID;
    pOEM->dwDLSetFontID = UNKNOWN_DLFONT_ID;
    pOEM->wCharCode = 0;
    pOEM->iUnitFactor = 1;

    // Get MYPDEV member
    // ColorMatching
    if (!DRVGETDRIVERSETTING(pdevobj, "ColorMatching", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(ColorMatching) Failed\n"));
        pOEM->Printer = PRN_N4;
        pOEM->iColorMatching = XX_COLORMATCH_NONE;
    } else {
        MY_VERBOSE(("ColorMatching:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_COLORMATCH_BRI)) {
            pOEM->Printer = PRN_N403;
            pOEM->iColorMatching = XX_COLORMATCH_BRI;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_VIV)) {
            pOEM->Printer = PRN_N403;
            pOEM->iColorMatching = XX_COLORMATCH_VIV;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_IRO)) {
            pOEM->Printer = PRN_N403;
            pOEM->iColorMatching = XX_COLORMATCH_IRO;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_NORMAL)) {
            pOEM->Printer = PRN_N4;
            pOEM->iColorMatching = XX_COLORMATCH_NORMAL;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_VIVCOL)) {
            pOEM->Printer = PRN_N4;
            pOEM->iColorMatching = XX_COLORMATCH_VIVCOL;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_NATCOL)) {
            pOEM->Printer = PRN_N4;
            pOEM->iColorMatching = XX_COLORMATCH_NATCOL;
        } else if (!strcmp(byOutput, OPT_N4_NONE)) {
            pOEM->Printer = PRN_N4;
            pOEM->iColorMatching = XX_COLORMATCH_NONE;
        } else if (!strcmp(byOutput, OPT_N403_NONE)) {
            pOEM->Printer = PRN_N403;
            pOEM->iColorMatching = XX_COLORMATCH_NONE;
        } else {
            pOEM->Printer = PRN_N403;
            pOEM->iColorMatching = XX_COLORMATCH_NONE;
        }
    }

    // Resolution
    if (!DRVGETDRIVERSETTING(pdevobj, "Resolution", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(Resolution) Failed\n"));
        pOEM->iResolution = XX_RES_300DPI;
    } else {
        MY_VERBOSE(("Resolution:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_1)) {
            pOEM->iResolution = XX_RES_300DPI;
            pOEM->iUnitFactor = 4;
            pOEM->sHeightDiv = 1;
        } else if (!strcmp(byOutput, OPT_2)) {
            pOEM->iResolution = XX_RES_600DPI;
            pOEM->iUnitFactor = 2;
            pOEM->sHeightDiv = 4;
        }
    }

    // Dithering
    if (!DRVGETDRIVERSETTING(pdevobj, "Dithering", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(Dithering) Failed\n"));
        pOEM->iDithering = XX_DITHERING_OFF;
    } else {
        MY_VERBOSE(("Dithering:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_DITHERING_OFF)) {
            pOEM->iDithering = XX_DITHERING_OFF;
        } else if (!strcmp(byOutput, OPT_DITHERING_ON)) {
            pOEM->iDithering = XX_DITHERING_ON;
        } else if (!strcmp(byOutput, OPT_DITHERING_DET)) {
            pOEM->iDithering = XX_DITHERING_DET;
        } else if (!strcmp(byOutput, OPT_DITHERING_PIC)) {
            pOEM->iDithering = XX_DITHERING_PIC;
        } else if (!strcmp(byOutput, OPT_DITHERING_CAR)) {
            pOEM->iDithering = XX_DITHERING_CAR;
        } else if (!strcmp(byOutput, OPT_DITHERING_GRA)) {
            pOEM->iDithering = XX_DITHERING_GRA;
        } else if (!strcmp(byOutput, OPT_DITHERING_GOSA)) {
            pOEM->iDithering = XX_DITHERING_GOSA;
        } else {
            pOEM->iDithering = XX_DITHERING_OFF;
        }
    }

    // BitFont
    if (!DRVGETDRIVERSETTING(pdevobj, "BitFont", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(BitFont) Failed\n"));
        pOEM->iBitFont = XX_BITFONT_OFF;
    } else {
        MY_VERBOSE(("BitFont:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_2)) {
            pOEM->iBitFont = XX_BITFONT_OFF;
        } else if (!strcmp(byOutput, OPT_1)) {
            pOEM->iBitFont = XX_BITFONT_ON;
        } else {
            pOEM->iBitFont = XX_BITFONT_OFF;
        }
    }

    // CmyBlack
    if (!DRVGETDRIVERSETTING(pdevobj, "CmyBlack", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(CmyBlack) Failed\n"));
        pOEM->iCmyBlack = XX_CMYBLACK_OFF;
    } else {
        MY_VERBOSE(("CmyBlack:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_2)) {
            pOEM->iCmyBlack = XX_CMYBLACK_OFF;
        } else if (!strcmp(byOutput, OPT_1)) {
            pOEM->iCmyBlack = XX_CMYBLACK_ON;
        } else {
            pOEM->iCmyBlack = XX_CMYBLACK_OFF;
        }
    }

    // ColorMode
    if (!DRVGETDRIVERSETTING(pdevobj, "ColorMode", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(ColorMode) Failed\n"));
        pOEM->iColor = XX_COLOR;
    } else {
        MY_VERBOSE(("ColorMode:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_COLOR_SINGLE)) {
            pOEM->iColor = XX_COLOR_SINGLE;
        } else if (!strcmp(byOutput, OPT_COLOR_MANY)) {
            pOEM->iColor = XX_COLOR_MANY;
        } else if (!strcmp(byOutput, OPT_COLOR)) {
            pOEM->iColor = XX_COLOR;
        } else if (!strcmp(byOutput, OPT_MONO)) {
            pOEM->iColor = XX_MONO;
        }
    }

    // Compress
    if (!DRVGETDRIVERSETTING(pdevobj, "Compress", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(Compress) Failed\n"));
        pOEM->iCompress = XX_COMPRESS_OFF;
    } else {
        MY_VERBOSE(("Compress:%s\n", byOutput));
        if (!strcmp(byOutput, OPT_AUTO)) {
            pOEM->iCompress = XX_COMPRESS_AUTO;
        } else if (!strcmp(byOutput, OPT_RASTER)) {
            pOEM->iCompress = XX_COMPRESS_RASTER;
        } else {
            pOEM->iCompress = XX_COMPRESS_OFF;
        }
    }

    if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {
        if (ColMatchInit(pdevobj) == FALSE) {
            return NULL;
        }
    }
    MY_VERBOSE(("OEMEnablePdev END\n"));

    return pdevobj->pdevOEM;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMImageProcessing
//////////////////////////////////////////////////////////////////////////

PBYTE APIENTRY
OEMImageProcessing(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams)
{
    BOOL   bret;

    if (pIPParams->bBlankBand) {
        MY_VERBOSE(("BB=TRUE\n"));
        bret = TRUE;                // Not spool to printer
    }
    else {
        MY_VERBOSE(("BB=FALSE\n"));
        // DIB spool to printer
        bret = (DIBtoPrn(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable, pIPParams)) ? TRUE : FALSE;
    }

    return (PBYTE)IntToPtr(bret);
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDisablePDEV
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (pdevobj->pdevOEM)
    {
        if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {
            DizLutTnrTblFree(pdevobj);
        }

        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}


BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PMYPDEV pOEMOld, pOEMNew;
    INT i;

    pOEMOld = (PMYPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PMYPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL) {
//        *pOEMNew = *pOEMOld;
        pOEMNew->fGeneral         = pOEMOld->fGeneral;
        pOEMNew->iEscapement      = pOEMOld->iEscapement;
        pOEMNew->sHeightDiv       = pOEMOld->sHeightDiv;
        pOEMNew->iDevCharOffset   = pOEMOld->iDevCharOffset;
        pOEMNew->iPaperSource     = pOEMOld->iPaperSource;
        pOEMNew->iDuplex          = pOEMOld->iDuplex;
        pOEMNew->iTonerSave       = pOEMOld->iTonerSave;
        pOEMNew->iOrientation     = pOEMOld->iOrientation;
        pOEMNew->iResolution      = pOEMOld->iResolution; 
        pOEMNew->iColor           = pOEMOld->iColor;
        pOEMNew->iSmoothing       = pOEMOld->iSmoothing;
        pOEMNew->iJamRecovery     = pOEMOld->iJamRecovery;
        pOEMNew->iMediaType       = pOEMOld->iMediaType;
        pOEMNew->iUnitFactor      = pOEMOld->iUnitFactor;
        pOEMNew->iDithering       = pOEMOld->iDithering;
        pOEMNew->iColorMatching   = pOEMOld->iColorMatching;
        pOEMNew->iBitFont         = pOEMOld->iBitFont;
        pOEMNew->iCmyBlack        = pOEMOld->iCmyBlack;
        pOEMNew->iTone            = pOEMOld->iTone;
        pOEMNew->iPaperSize       = pOEMOld->iPaperSize;
        pOEMNew->iCompress        = pOEMOld->iCompress;
        pOEMNew->Printer          = pOEMOld->Printer;
        pOEMNew->wRectWidth       = pOEMOld->wRectWidth;
        pOEMNew->wRectHeight      = pOEMOld->wRectHeight;
        pOEMNew->dwDLFontID       = pOEMOld->dwDLFontID;
        pOEMNew->dwDLSelectFontID = pOEMOld->dwDLSelectFontID;
        pOEMNew->dwDLSetFontID    = pOEMOld->dwDLSetFontID;
        pOEMNew->wCharCode        = pOEMOld->wCharCode;

        pOEMNew->Col.wReso        = pOEMOld->Col.wReso;
        pOEMNew->Col.ColMon       = pOEMOld->Col.ColMon;
        pOEMNew->Col.DatBit       = pOEMOld->Col.DatBit;
        pOEMNew->Col.BytDot       = pOEMOld->Col.BytDot;
        pOEMNew->Col.Mch.Mode     = pOEMOld->Col.Mch.Mode;
        pOEMNew->Col.Mch.Viv      = pOEMOld->Col.Mch.Viv;
        pOEMNew->Col.Mch.KToner   = pOEMOld->Col.Mch.KToner;
        pOEMNew->Col.Mch.LutNum   = pOEMOld->Col.Mch.LutNum;
        pOEMNew->Col.Mch.Diz      = pOEMOld->Col.Mch.Diz;
        pOEMNew->Col.Mch.Toner    = pOEMOld->Col.Mch.Toner;
        pOEMNew->Col.Mch.TnrNum   = pOEMOld->Col.Mch.TnrNum;
        pOEMNew->Col.Mch.CmyBlk   = pOEMOld->Col.Mch.CmyBlk;
        pOEMNew->Col.Mch.Speed    = pOEMOld->Col.Mch.Speed;
        pOEMNew->Col.Mch.Gos32    = pOEMOld->Col.Mch.Gos32;
        pOEMNew->Col.Mch.PColor   = pOEMOld->Col.Mch.PColor;
        pOEMNew->Col.Mch.SubDef   = pOEMOld->Col.Mch.SubDef;
        pOEMNew->Col.Mch.Bright   = pOEMOld->Col.Mch.Bright;
        pOEMNew->Col.Mch.Contrast = pOEMOld->Col.Mch.Contrast;
        pOEMNew->Col.Mch.GamRed   = pOEMOld->Col.Mch.GamRed;
        pOEMNew->Col.Mch.GamGreen = pOEMOld->Col.Mch.GamGreen;
        pOEMNew->Col.Mch.GamBlue  = pOEMOld->Col.Mch.GamBlue;

        if (pOEMOld->Printer != PRN_N403) {
            if (NULL != pOEMNew->Col.N4.lpDizInf)
            {
//                MemFree(pOEMNew->Col.N4.lpDizInf);
                DizLutTnrTblFree(pdevobjNew);
            }
            pOEMNew->Col.N4.lpDizInf = pOEMOld->Col.N4.lpDizInf;
            pOEMOld->Col.N4.lpDizInf = NULL;
        }
        else {
            if (NULL != pOEMNew->Col.N403.lpDizInf) {
//                MemFree(pOEMNew->Col.N403.lpDizInf);
                DizLutTnrTblFree(pdevobjNew);
            }
            pOEMNew->Col.N403.lpDizInf = pOEMOld->Col.N403.lpDizInf;
            pOEMOld->Col.N403.lpDizInf = NULL;
        }
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMCommandCallback
//////////////////////////////////////////////////////////////////////////

INT
APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT             iRet = 0;
    BYTE            Cmd[BUFFLEN];
    PMYPDEV         pOEM;
    WORD            wlen;
    WORD            wGray;
    DWORD           dwTempX, dwTempY;
    CMYK            TmpCmyk;
    RGBS            TmpRgb;
// MSKK 99/6/24
    WORD            wPalID;

    MY_VERBOSE(("OEMCommandCallback() entry.\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    switch (dwCmdCbID) {
    case FS_BOLD_ON:
    case FS_BOLD_OFF:
        if(pdwParams[0])
            pOEM->fGeneral |=  FG_BOLD;
        else
            pOEM->fGeneral &=  ~FG_BOLD;

        wlen = (WORD)wsprintf(Cmd,BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0);
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

    case FS_ITALIC_ON:
    case FS_ITALIC_OFF:
        if(pdwParams[0])
            pOEM->fGeneral |=  FG_ITALIC;
        else
            pOEM->fGeneral &=  ~FG_ITALIC;

        wlen = (WORD)wsprintf(Cmd,ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0);
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

    case TEXT_FS_SINGLE_BYTE:
        strcpy(Cmd,FS_SINGLE_BYTE);
        wlen = (WORD)strlen( Cmd );
        wlen += (WORD)wsprintf(&Cmd[wlen],PRN_DIRECTION,pOEM->iEscapement);
        if (pOEM->fGeneral & FG_VERT)
        {
            wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 0);
        }
        pOEM->fGeneral &= ~FG_DOUBLE;
        wlen += (WORD)wsprintf(&Cmd[wlen],BOLD_SET, 
                         (pOEM->fGeneral & FG_BOLD)?15:0);
        wlen += (WORD)wsprintf(&Cmd[wlen],ITALIC_SET,
                         (pOEM->fGeneral & FG_ITALIC)?346:0);
        WRITESPOOLBUF(pdevobj, Cmd, wlen);
        break;

    case TEXT_FS_DOUBLE_BYTE:
        strcpy(Cmd,FS_DOUBLE_BYTE);
        wlen = (WORD)strlen( Cmd );
        wlen += (WORD)wsprintf(&Cmd[wlen],PRN_DIRECTION,pOEM->iEscapement);
        if (pOEM->fGeneral & FG_VERT)
        {
            wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 1);
        }
        pOEM->fGeneral |= FG_DOUBLE;
        wlen += (WORD)wsprintf(&Cmd[wlen],BOLD_SET, 
                         (pOEM->fGeneral & FG_BOLD)?15:0);
        wlen += (WORD)wsprintf(&Cmd[wlen],ITALIC_SET, 
                         (pOEM->fGeneral & FG_ITALIC)?346:0);
        WRITESPOOLBUF(pdevobj, Cmd, wlen);
        break;

    case PC_PORTRAIT:
        pOEM->iOrientation = 0;
        break;

    case PC_LANDSCAPE:
        pOEM->iOrientation = 1;
        break;

    case PC_DUPLEX_NONE:
        pOEM->iDuplex = (DUPLEX_NONE + 1);
        break;

    case PC_DUPLEX_VERT:
        pOEM->iDuplex =
                (pOEM->iOrientation ?
                (DUPLEX_UP + 1) : (DUPLEX_SIDE + 1));
        break;

    case PC_DUPLEX_HORZ:
        pOEM->iDuplex =
                (pOEM->iOrientation ?
                (DUPLEX_SIDE + 1) : (DUPLEX_UP + 1));
        break;

    case PSRC_SELECT_MPF:
        pOEM->iPaperSource = PSRC_MPF;
        break;

    case PSRC_SELECT_CASETTE_1:
        pOEM->iPaperSource = PSRC_CASETTE_1;
        break;

    case PSRC_SELECT_CASETTE_2:
        pOEM->iPaperSource = PSRC_CASETTE_2;
        break;

    case PSRC_SELECT_CASETTE_3:
        pOEM->iPaperSource = PSRC_CASETTE_3;
        break;

    case PSRC_SELECT_AUTO:
        pOEM->iPaperSource = PSRC_AUTO;
        break; 

    case PC_BEGINDOC:
        // EJL commands
        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EJL_BEGIN,
            BYTE_LENGTH(BEGINDOC_EJL_BEGIN));

        wlen = 0;
        strcpy( &Cmd[wlen],  EJL_SelectPsrc[pOEM->iPaperSource] );
        wlen += (WORD)strlen( &Cmd[wlen] );
        strcpy( &Cmd[wlen], EJL_SelectOrient[pOEM->iOrientation] );
        wlen += (WORD)strlen( &Cmd[wlen] );

        // CASIO extention

        strcpy( &Cmd[wlen],  EJL_SelectRes[pOEM->iResolution] );
        wlen += (WORD)strlen( &Cmd[wlen] );
        if (pOEM->iColor > 0) {
            strcpy( &Cmd[wlen],  EJL_SetColorMode[1] );
            wlen += (WORD)strlen( &Cmd[wlen] );
        }

        if (pOEM->iDuplex > 0) {
            strcpy( &Cmd[wlen],  EJL_SetDuplex[pOEM->iDuplex - 1] );
            wlen += (WORD)strlen( &Cmd[wlen] );
        }

        if (pOEM->iColor == XX_COLOR_MANY) {
            strcpy( &Cmd[wlen],  EJL_SetColorTone[1] );
        }
        else {
            strcpy( &Cmd[wlen],  EJL_SetColorTone[0] );
        }
        wlen += (WORD)strlen( &Cmd[wlen] );

        strcpy( &Cmd[wlen],  EJL_SetTonerSave[pOEM->iTonerSave] );
        wlen += (WORD)strlen( &Cmd[wlen] );

        strcpy( &Cmd[wlen],  EJL_SetSmoohing[pOEM->iSmoothing] );
        wlen += (WORD)strlen( &Cmd[wlen] );

        strcpy( &Cmd[wlen],  EJL_SetJamRecovery[pOEM->iJamRecovery] );
        wlen += (WORD)strlen( &Cmd[wlen] );

        strcpy( &Cmd[wlen], " ##SN=ON");
        wlen += (WORD)strlen( &Cmd[wlen] );

        if (pOEM->iMediaType > 0) {
            strcpy( &Cmd[wlen],  EJL_SetMediaType[pOEM->iMediaType - 1] );
            wlen += (WORD)strlen( &Cmd[wlen] );
        }

        WRITESPOOLBUF(pdevobj, Cmd, wlen );

        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EJL_END,
            BYTE_LENGTH(BEGINDOC_EJL_END));
        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EPG_END,
            BYTE_LENGTH(BEGINDOC_EPG_END));

        if(pOEM->iResolution == XX_RES_300DPI)
            WRITESPOOLBUF(pdevobj, "\x1D\x30;0.24muE", 10);
        else
            WRITESPOOLBUF(pdevobj, "\x1D\x30;0.12muE", 10);

        // ESC/Page commands
        wlen = 0;
        strcpy( &Cmd[wlen],  EPg_SelectRes[pOEM->iResolution] );
        wlen += (WORD)strlen( &Cmd[wlen] );
        WRITESPOOLBUF(pdevobj, Cmd, wlen );

        // Clear dwDLFontID
        // (There are data that contains a plural pages and
        //  also each page has different color mode.
        //  When page is changed, STARTDOC commands are spooled.
        //  It means that new DL font is set.
        //  That is why dwDLFontID got to be claer.)
        pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
        break;

    case PC_ENDDOC:
        WRITESPOOLBUF(pdevobj,
            ENDDOC_EJL_RESET,
            BYTE_LENGTH(ENDDOC_EJL_RESET));
        break;

    case TONER_SAVE_NONE:
        pOEM->iTonerSave = XX_TONER_NORMAL;
        break;

    case TONER_SAVE_1:
        pOEM->iTonerSave = XX_TONER_SAVE_1;
        break;

    case TONER_SAVE_2:
        pOEM->iTonerSave = XX_TONER_SAVE_2;
        break;

    case TONER_SAVE_3:
        pOEM->iTonerSave = XX_TONER_SAVE_3;
        break;

    case SMOOTHING_ON:
        pOEM->iSmoothing = XX_SMOOTHING_ON;
        break;

    case SMOOTHING_OFF:
        pOEM->iSmoothing = XX_SMOOTHING_OFF;
        break;

    case JAMRECOVERY_ON:
        pOEM->iJamRecovery = XX_JAMRECOVERY_ON;
        break;

    case JAMRECOVERY_OFF:
        pOEM->iJamRecovery = XX_JAMRECOVERY_OFF;
        break;

    case MEDIATYPE_1:
        pOEM->iMediaType = XX_MEDIATYPE_1;
        break;

    case MEDIATYPE_2:
        pOEM->iMediaType = XX_MEDIATYPE_2;
        break;

    case DEFINE_PALETTE_ENTRY:
        //RGB -> CMYK
        TmpRgb.Red   = (BYTE)(PARAM(pdwParams, 1));
        TmpRgb.Green = (BYTE)(PARAM(pdwParams, 2));
        TmpRgb.Blue  = (BYTE)(PARAM(pdwParams, 3));

        memset(&TmpCmyk, 0x00, sizeof(TmpCmyk)); 
        StrColMatching(pdevobj, (WORD)1, &TmpRgb, &TmpCmyk);

        wPalID = (WORD)(PARAM(pdwParams, 0));
        WRITESPOOLBUF(pdevobj, ORG_MODE_IN, BYTE_LENGTH(ORG_MODE_IN));
        wlen = (WORD)wsprintf(Cmd, PALETTE_DEFINE, wPalID, TmpCmyk.Cyn,
            TmpCmyk.Mgt, TmpCmyk.Yel, TmpCmyk.Bla);
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));

        MY_VERBOSE(("DEFINE_PALETTE_ENTRY No %d\n",
            (INT)(PARAM(pdwParams, wPalID))));
        break;

    case BEGIN_PALETTE_DEF:
        MY_VERBOSE(("CmdBeginPaletteDef\n"));
        break;

    case END_PALETTE_DEF:
        MY_VERBOSE(("CmdEndPaletteDef\n"));
        break;

    case SELECT_PALETTE_ENTRY:
        MY_VERBOSE(("SELECT_PALETTE_ENTRY "));

        wPalID = (WORD)(PARAM(pdwParams, 0));
        WRITESPOOLBUF(pdevobj, ORG_MODE_IN, BYTE_LENGTH(ORG_MODE_IN));
        wlen = (WORD)wsprintf(Cmd, PALETTE_SELECT, 0, wPalID);

        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));
        WRITESPOOLBUF(pdevobj, OVERWRITE, BYTE_LENGTH(OVERWRITE));
        break;

    case START_PAGE:
        WRITESPOOLBUF(pdevobj, CMD_START_PAGE, BYTE_LENGTH(CMD_START_PAGE));

        if (pOEM->iColor == XX_COLOR_MANY || pOEM->iColor == XX_COLOR_SINGLE) {
            //Initialize palette state (Spools pure black color command)
            wlen = 0;
            TmpRgb.Red = TmpRgb.Green = TmpRgb.Blue = 0;
            StrColMatching(pdevobj, (WORD)1, &TmpRgb, &TmpCmyk);
            strcpy( &Cmd[wlen], ORG_MODE_IN );
            wlen += (WORD)strlen( &Cmd[wlen] );
            wlen += (WORD)wsprintf(&Cmd[wlen], PALETTE_DEFINE,
                DEFAULT_PALETTE_INDEX,
                TmpCmyk.Cyn, TmpCmyk.Mgt, TmpCmyk.Yel, TmpCmyk.Bla);
            wlen += (WORD)wsprintf(&Cmd[wlen], PALETTE_SELECT,
                0, DEFAULT_PALETTE_INDEX);
            WRITESPOOLBUF(pdevobj, Cmd, wlen);
            WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));
        }
        break;

    case DOWNLOAD_SET_FONT_ID:

        if (!IsValidDLFontID(pdwParams[0])) {

            // Must not happen!!
            ERR(("DLSetFontID: Soft font ID %x invalid.\n",
                pdwParams[0]));
            break;
        }

        // Actual printer command is sent
        // within DownloadCharGlyph.
        pOEM->dwDLSetFontID = pdwParams[0];

        DL_VERBOSE(("SetFontID: dwDLSetFontID=%x\n",
            pOEM->dwDLSetFontID));
        break;

    case DOWNLOAD_SELECT_FONT_ID:

        if (!IsValidDLFontID(pdwParams[0])) {

            // Must not happen!!
            ERR(("DLSelectFontID: Soft font ID %x invalid.\n",
                pdwParams[0]));
            break;
        }

        pOEM->dwDLSelectFontID = pdwParams[0];

        DL_VERBOSE(("SelectFontID: dwDLSelectFontID=%x\n",
            pOEM->dwDLSelectFontID));

        if (pOEM->dwDLFontID != pOEM->dwDLSelectFontID)
            VSetSelectDLFont(pdevobj, pOEM->dwDLSelectFontID);
        break;

    case DOWNLOAD_SET_CHAR_CODE:
        pOEM->wCharCode=(WORD)pdwParams[0];
        break;

    case DOWNLOAD_DELETE_FONT:

        DL_VERBOSE(("DLDeleteFont: dwDLFontID=%x, %x\n",
            pOEM->dwDLFontID, pdwParams[0]));

        wlen = (WORD)wsprintf(Cmd, DLI_DELETE_FONT, (WORD)pdwParams[0]-FONT_MIN_ID);
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
        break;

    case RECT_FILL_WIDTH:
        pOEM->wRectWidth =
            (WORD)MasterToDevice(pOEM, pdwParams[0]);
        break;

    case RECT_FILL_HEIGHT:
        pOEM->wRectHeight =
            (WORD)MasterToDevice(pOEM, pdwParams[0]);
        break;

    case RECT_FILL_GRAY:
    case RECT_FILL_WHITE:
    case RECT_FILL_BLACK:
        if (RECT_FILL_GRAY == dwCmdCbID)
            wGray = (WORD)pdwParams[2];
        else if (RECT_FILL_WHITE == dwCmdCbID)
            wGray = 0;
        else
            wGray = 100;

        dwTempX = MasterToDevice(pOEM, pdwParams[0]);
        dwTempY = MasterToDevice(pOEM, pdwParams[1]);

        MY_VERBOSE(("RectFill:%d,x=%d,y=%d,w=%d,h=%d\n",
            wGray,
            (WORD)dwTempX,
            (WORD)dwTempY,
            pOEM->wRectWidth,
            pOEM->wRectHeight));

        wlen = (WORD)wsprintf(Cmd, RECT_FILL,
            wGray,
            (WORD)dwTempX,
            (WORD)dwTempY,
            (WORD)(dwTempX + pOEM->wRectWidth - 1),
            (WORD)(dwTempY + pOEM->wRectHeight - 1));
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    case COLOR_SELECT_BLACK:
    case COLOR_SELECT_RED:
    case COLOR_SELECT_GREEN:
    case COLOR_SELECT_BLUE:
    case COLOR_SELECT_YELLOW:
    case COLOR_SELECT_MAGENTA:
    case COLOR_SELECT_CYAN:
    case COLOR_SELECT_WHITE:
        /* Remember what color is select */
        pOEM->dwSelectedColor = dwCmdCbID;
        pOEM->iColorMayChange = 0;         /* Reset flag */

        /* Output Color Select Command */
        /* The logic supposes COLOR_SELECT_xxx starts with COLOR_SELECT_BLACK */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)COLOR_SELECT_COMMAND[dwCmdCbID - COLOR_SELECT_BLACK],
                       COLOR_SELECT_COMMAND_LEN[dwCmdCbID - COLOR_SELECT_BLACK] );
        break;

    case DUMP_RASTER_CYAN:
    case DUMP_RASTER_MAGENTA:
    case DUMP_RASTER_YELLOW:
    case DUMP_RASTER_BLACK:
        /* Remember what color may change */
        pOEM->iColorMayChange = 1;         /* Set flag */

        /* Output Dump Raster Command */
        /* The logic supposes DUMP_RASTER_xxx starts with DUMP_RASTER_CYAN */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)DUMP_RASTER_COMMAND[dwCmdCbID - DUMP_RASTER_CYAN],
                       DUMP_RASTER_COMMAND_LEN );
        break;

    /* End of hack code */
#endif   /* OEM doesn't want to fix minidriver */

    default:
        ERR(("Unknown callback ID = %d.\n", dwCmdCbID));
    }
    return iRet;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMSendFontCmdk
//////////////////////////////////////////////////////////////////////////

VOID
APIENTRY
OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[2+2*4];
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        aubCmd[128];
    PIFIMETRICS pIFI;
    DWORD       height, width;
    PMYPDEV pOEM;
    BYTE    Cmd[128];
    WORD    wlen;
    DWORD   dwNeeded;
    DWORD dwTemp;

    SC_VERBOSE(("OEMSendFontCmd() entry.\n"));

    pubCmd = pFInv->pubCommand;
    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    SC_VERBOSE(("ulFontID=%x\n", pUFObj->ulFontID));
    SC_VERBOSE(("FONTHEIGHT=%d\n", pSV->StdVar[0].lStdVariable));
    SC_VERBOSE(("FONTWIDTH=%d\n", pSV->StdVar[1].lStdVariable));

    // Initialize pOEM
    if (pIFI->jWinCharSet == 0x80)
        pOEM->fGeneral |= FG_DOUBLE;
    else
        pOEM->fGeneral &= ~FG_DOUBLE;
    pOEM->fGeneral &=  ~FG_BOLD;
    pOEM->fGeneral &=  ~FG_ITALIC;

    if('@' == *((LPSTR)pIFI+pIFI->dpwszFaceName))
        pOEM->fGeneral |= FG_VERT;
    else
        pOEM->fGeneral &= ~FG_VERT;

    if (pIFI->jWinPitchAndFamily & 0x01)
        pOEM->fGeneral &= ~FG_PROP;
    else
        pOEM->fGeneral |= FG_PROP;

    dwOut = 0;
    pOEM->fGeneral &= ~FG_DBCS;

    for( dwIn = 0; dwIn < pFInv->dwCount;) {
        if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'V') {
            // Specify font height in device unit (current
            // output resolution).  Note Unidrv gives us
            // font-height in master units
            height = pSV->StdVar[0].lStdVariable * 100;
            height = MasterToDevice(pOEM, height);
            SC_VERBOSE(("Height=%d\n", height));
            dwOut += LConvertFontSizeToStr(height, &aubCmd[dwOut]);
            dwIn += 2;
        } else if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'H') {
            if (pubCmd[dwIn+2] == 'S') {
                SC_VERBOSE(("HS: "));
                width = pSV->StdVar[1].lStdVariable;
                dwIn += 3;
                pOEM->fGeneral |= FG_DBCS;
            } else if (pubCmd[dwIn+2] == 'D') {
                SC_VERBOSE(("HD: "));
                width = pSV->StdVar[1].lStdVariable * 2;
                dwIn += 3;
                pOEM->fGeneral |= FG_DBCS;
            } else {
                SC_VERBOSE(("H: "));
                if (pSV->StdVar[1].lStdVariable)
                    width = pSV->StdVar[1].lStdVariable;
                else
                    width = pIFI->fwdAveCharWidth;
                dwIn += 2;
            }
            // Specify font width in CPI.
            width = (MASTER_UNIT * 100L) / width;
            SC_VERBOSE(("Width=%d\n", width));
            dwOut += LConvertFontSizeToStr(width, &aubCmd[dwOut]);
        } else {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }

    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

#if 0 //MSKK 98/12/22
    pOEM->iDevCharOffset = (pIFI->fwdWinDescender * pSV->StdVar[0].lStdVariable * 72)
                          / (pIFI->fwdUnitsPerEm * pSV->StdVar[2].lStdVariable / pOEM->sHeightDiv);
#else
    // Unidrv gives us raw IFIMETRICS block so we need to
    // translate its members into meaningful values.  n.b.
    // we assume font height passed from Unidrv = em value.
    dwTemp = MasterToDevice(pOEM, pSV->StdVar[0].lStdVariable)
        * pIFI->fwdWinDescender;
    dwTemp /= pIFI->fwdUnitsPerEm;
    pOEM->iDevCharOffset = (short)dwTemp;
#endif

    MY_VERBOSE(("Descender=%d\n", pOEM->iDevCharOffset));

    wlen = (WORD)wsprintf(Cmd, SET_CHAR_OFFSET,
        (pOEM->fGeneral & FG_DBCS)?pOEM->iDevCharOffset:0);

    if (pOEM->fGeneral & FG_VERT)
    {
        wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 1);
    }
    WRITESPOOLBUF(pdevobj, Cmd, wlen);

    // DL font will be unselectd
    pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
}

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes)
{
    LONG tmp = ((LONG)height * (LONG)7200) / (LONG)vertRes;

    //
    // round to the nearest quarter point.
    //
    return 25 * ((tmp + 12) / (LONG)25);
}

LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr)
{
    register long count;

    count = strlen(_ltoa(size / 100, pStr, 10));
    pStr[count++] = '.';
    count += strlen(_ltoa(size % 100, &pStr[count], 10));

    return count;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMOutputCharStr
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
    PTRANSDATA pTransOrg;
    WORD   id;
    DWORD  dwI;
    DWORD  dwNeeded;
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;

    WORD wLen;
    BYTE *pTemp;
    BOOL bRet;

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    pTrans = NULL;
    pTransOrg = NULL;

    MY_VERBOSE(("OEMOutputCharStr() entry.\n"));

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    if ( pOEM->iColorMayChange == 1 )
    {
        /* Output Color Select Command */
        /* The logic supposes COLOR_SELECT_xxx starts with COLOR_SELECT_BLACK */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)COLOR_SELECT_COMMAND[pOEM->dwSelectedColor - COLOR_SELECT_BLACK],
                       COLOR_SELECT_COMMAND_LEN[pOEM->dwSelectedColor - COLOR_SELECT_BLACK] );

        /* Reset flag, for ensuring color */
        pOEM->iColorMayChange = 0;
    }
    /* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:

        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;

        if ((FALSE != (bRet = pUFObj->pfnGetInfo(pUFObj,
                UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)))
            || 0 == GStr.dwGlyphOutSize)
        {
            ERR(("UFO_GETINFO_GRYPHSTRING faild - %d, %d.\n",
                bRet, GStr.dwGlyphOutSize));
            return;
        }

        pTrans = (TRANSDATA *)MemAlloc(GStr.dwGlyphOutSize);
        if (NULL == pTrans)
        {
            ERR(("MemAlloc faild.\n"));
            return;
        }
        pTransOrg = pTrans;
        GStr.pGlyphOut = pTrans;

        // convert glyph string to TRANSDATA
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));

            /* pTransOrg isn't NULL because the function have already ended if pTransOrg is NULL. */
            /* So, we need not check whether it is NULL. */
            MemFree(pTransOrg);
            return;
        }

        for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
        {
            MY_VERBOSE(("TYPE_TRANSDATA:ubCodePageID:0x%x\n",
                pTrans->ubCodePageID));
            MY_VERBOSE(("TYPE_TRANSDATA:ubType:0x%x\n",
                pTrans->ubType));

            switch (pTrans->ubType & MTYPE_DOUBLEBYTECHAR_MASK)
            {
            case MTYPE_SINGLE: 
                if(pOEM->fGeneral & FG_DOUBLE){
                    OEMCommandCallback(pdevobj, TEXT_FS_SINGLE_BYTE, 0, NULL );
                }
                break;
            case MTYPE_DOUBLE:
                if(!(pOEM->fGeneral & FG_DOUBLE)){
                    OEMCommandCallback(pdevobj, TEXT_FS_DOUBLE_BYTE, 0, NULL );
                }
                break;
            }

            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            case MTYPE_DIRECT: 
                MY_VERBOSE(("TYPE_TRANSDATA:ubCode:0x%x\n",
                    pTrans->uCode.ubCode));

                pTemp = (BYTE *)&pTrans->uCode.ubCode;
                wLen = 1;
                break;

            case MTYPE_PAIRED: 
                MY_VERBOSE(("TYPE_TRANSDATA:ubPairs:0x%x\n",
                    *(PWORD)(pTrans->uCode.ubPairs)));

                pTemp = (BYTE *)&(pTrans->uCode.ubPairs);
                wLen = 2;
                break;

            case MTYPE_COMPOSE:
                // ntbug9#398026: garbage print out when chars are high ansi.
                pTemp = (BYTE *)(pTransOrg) + pTrans->uCode.sCode;

                // first two bytes are the length of the string
                wLen = *pTemp + (*(pTemp + 1) << 8);
                pTemp += 2;
                break;

            default:
                wLen = 0;       // ntbug9#226623: PREFIX
                WARNING(("Unsupported MTYPE %d ignored\n",
                    (pTrans->ubType & MTYPE_FORMAT_MASK)));
            }

            if (wLen > 0)
            {
                WRITESPOOLBUF(pdevobj, pTemp, wLen);
            }
        }
        break;

    case TYPE_GLYPHID:

        DL_VERBOSE(("CharStr: dwDLFontID=%x, dwDLSelectFontID=%x\n",
            pOEM->dwDLFontID, pOEM->dwDLSelectFontID));

        // Make sure correct soft font is chosen
        if (pOEM->dwDLFontID != pOEM->dwDLSelectFontID)
            VSetSelectDLFont(pdevobj, pOEM->dwDLSelectFontID);

        for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)
        {

            DL_VERBOSE(("Glyph: %x\n", (*(PDWORD)pGlyph)));

            MY_VERBOSE(("TYPE_GLYPHID:0x%x\n", *(PDWORD)pGlyph));

// CASIO 98/11/24 ->
//            if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//                id = SWAPW( *(PDWORD)pGlyph + SJISCHR);
//                WRITESPOOLBUF(pdevobj, &id, 2);
//            }else{
                WRITESPOOLBUF(pdevobj, (PBYTE)pGlyph, 1);
//            }
// CASIO 98/11/24 <-
        }
        break;
    }

    /* pTransOrg isn't NULL because the function have already ended if pTransOrg is NULL. */
    /* So, we need not check whether it is NULL. */
    MemFree(pTransOrg);
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadFontHeader
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    )
{

    PGETINFO_STDVAR pSV;
    DWORD adwStdVariable[2+4*2];
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;
    ESCPAGEHEADER FontHeader;
    BYTE sFontName[54];
    BYTE Buff[32];
    int iSizeOfBuf,iSizeFontName;
    WORD id;
    DWORD dwNeeded;
    INT iCellLeftOffset, iTemp;
    WORD wCellHeight, wCellWidth;
    WORD wFontPitch;

    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    pIFI = pUFObj->pIFIMetrics;

    DL_VERBOSE(("OEMDownloadFontHeader() entry.\n"));

    DL_VERBOSE(("TT Font:\n"));
    DL_VERBOSE(("flInfo=%08x\n", pIFI->flInfo));
    DL_VERBOSE(("fwdMaxCharInc=%d\n", pIFI->fwdMaxCharInc));
    DL_VERBOSE(("fwdAveCharWidth=%d\n", pIFI->fwdAveCharWidth));
    DL_VERBOSE(("jWinCharSet=%d\n", pIFI->jWinCharSet));
    DL_VERBOSE(("rclFontBox=%d,%d,%d,%d\n",
        pIFI->rclFontBox.left, pIFI->rclFontBox.top,
        pIFI->rclFontBox.right, pIFI->rclFontBox.bottom));

//    if(pIFI->jWinPitchAndFamily & 0x01)
    if(pIFI->flInfo & FM_INFO_CONSTANT_WIDTH)
        pOEM->fGeneral &= ~FG_PROP;
    else
        pOEM->fGeneral |= FG_PROP;

//    id = (WORD)pUFObj->ulFontID;
    id = (WORD)pOEM->dwDLSetFontID;

    if(id > FONT_MAX_ID) return 0;
    if (pOEM->iResolution) return 0;

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE,
            pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return 0;
    }
    DL_VERBOSE(("FONTHEIGHT=%d\n", pSV->StdVar[0].lStdVariable));
    DL_VERBOSE(("FONTWIDTH=%d\n", pSV->StdVar[1].lStdVariable));
    DL_VERBOSE(("TEXTXRES=%d\n", pSV->StdVar[2].lStdVariable));
    DL_VERBOSE(("TEXTYRES=%d\n", pSV->StdVar[3].lStdVariable));

    wCellHeight = (WORD)pSV->StdVar[0].lStdVariable;
    wCellWidth = (WORD)pSV->StdVar[1].lStdVariable;

// CASIO 98/11/20 ->
     if ( MasterToDevice(pOEM,wCellHeight) > 64 )
     {
         DL_VERBOSE(("Abort OEMDownloadFontHeader: pt=%d\n",
             MasterToDevice(pOEM, wCellHeight)));
         return 0;
     }
// CASIO 98/11/20 <-

    //
    // rclFontBox.left may not be 0
    //

    iTemp = max(pIFI->rclFontBox.right -
        pIFI->rclFontBox.left + 1,
        pIFI->fwdAveCharWidth);

    iCellLeftOffset = (-pIFI->rclFontBox.left)
        * wCellWidth / iTemp;
    wFontPitch = pIFI->fwdAveCharWidth
        * wCellWidth / iTemp;

    FontHeader.wFormatType     = SWAPW(0x0002);
    FontHeader.wDataSize       = SWAPW(0x0086);
// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        FontHeader.wSymbolSet  = SWAPW(id-FONT_MIN_ID+0x4000+0x8000); //id-FONT_MIN_ID + 4000h + 8000h
//        FontHeader.wLast       = (WORD)SWAPW (0x23ff);
//        FontHeader.wFirst      = (WORD)SWAPW (0x2020);
//    }else{
        FontHeader.wSymbolSet  = SWAPW(id-FONT_MIN_ID+0x4000); //id-FONT_MIN_ID + 4000h
        FontHeader.wLast       = SWAPW (0xff);
        FontHeader.wFirst      = SWAPW (0x20);
//    }
// CASIO 98/11/24 <-

    if (pOEM->fGeneral & FG_PROP)
    {
        FontHeader.wCharSpace         = SWAPW(1);
        FontHeader.CharWidth.Integer = (WORD)SWAPW(0x0100);
        FontHeader.CharWidth.Fraction = 0;
    }
    else
    {
        FontHeader.wCharSpace         = 0;
        FontHeader.CharWidth.Integer
            = SWAPW(MasterToDevice(pOEM, wCellWidth));
        FontHeader.CharWidth.Fraction = 0;      
    }
    FontHeader.CharHeight.Integer
            = SWAPW(MasterToDevice(pOEM, wCellHeight));
    FontHeader.CharHeight.Fraction = 0;
    // in the range 128 - 255
    FontHeader.wFontID = SWAPW( id - FONT_MIN_ID + ( id < 0x80 ? 0x80 : 0x00));
    FontHeader.wWeight         = 0;
    FontHeader.wEscapement     = 0;
    FontHeader.wItalic         = 0;
    FontHeader.wUnderline      = 0;
    FontHeader.wUnderlineWidth = SWAPW(10);
    FontHeader.wOverline       = 0;
    FontHeader.wOverlineWidth  = 0;
    FontHeader.wStrikeOut      = 0;
    FontHeader.wStrikeOutWidth = 0;
    FontHeader.wCellWidth
        = SWAPW(MasterToDevice(pOEM, wCellWidth));
    FontHeader.wCellHeight
        = SWAPW(MasterToDevice(pOEM, wCellHeight));
    FontHeader.wCellLeftOffset = SWAPW(iCellLeftOffset);
    FontHeader.wCellAscender
        = SWAPW((pIFI->fwdWinAscender
        * MasterToDevice(pOEM, wCellHeight)));
    FontHeader.FixPitchWidth.Integer
        = SWAPW(MasterToDevice(pOEM, wFontPitch));
    FontHeader.FixPitchWidth.Fraction = 0;

    iSizeFontName = wsprintf(sFontName,
       "________________________EPSON_ESC_PAGE_DOWNLOAD_FONT%02d",id-FONT_MIN_ID);
    iSizeOfBuf = wsprintf(Buff,SET_FONT_ID,FONT_HEADER_SIZE,id-FONT_MIN_ID);
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, (LPSTR)&FontHeader,sizeof(ESCPAGEHEADER));
    WRITESPOOLBUF(pdevobj, sFontName,iSizeFontName);
    WRITESPOOLBUF(pdevobj, "EPC_PAGE_DOWNLOAD_FONT_INDEX", SIZE_SYMBOLSET);

//    iSizeOfBuf = wsprintf(Buff,DLI_SELECT_FONT_ID,id-FONT_MIN_ID,0);
//    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
//
    DL_VERBOSE(("DLFontHeader: ulFontID=%x, dwDLSetFontID=%x\n",
        pUFObj->ulFontID, pOEM->dwDLSetFontID));

    DL_VERBOSE(("FontHeader:\n"));
    DL_VERBOSE(("wFormatType=%d\n", SWAPW(FontHeader.wFormatType)));
    DL_VERBOSE(("wDataSize=%d\n", SWAPW(FontHeader.wDataSize)));
    DL_VERBOSE(("wSymbolSet=%d\n", SWAPW(FontHeader.wSymbolSet)));
    DL_VERBOSE(("wCharSpace=%d\n", SWAPW(FontHeader.wCharSpace)));
    DL_VERBOSE(("CharWidth=%d.%d\n",
        SWAPW(FontHeader.CharWidth.Integer),
        FontHeader.CharWidth.Fraction));
    DL_VERBOSE(("CharHeight=%d.%d\n",
        SWAPW(FontHeader.CharHeight.Integer),
        FontHeader.CharHeight.Fraction));
    DL_VERBOSE(("wFontID=%d\n", SWAPW(FontHeader.wFontID)));
    DL_VERBOSE(("wWeight=%d\n", SWAPW(FontHeader.wWeight)));
    DL_VERBOSE(("wEscapement=%d\n", SWAPW(FontHeader.wEscapement)));
    DL_VERBOSE(("wItalic=%d\n", SWAPW(FontHeader.wItalic)));
    DL_VERBOSE(("wLast=%d\n", SWAPW(FontHeader.wLast)));
    DL_VERBOSE(("wFirst=%d\n", SWAPW(FontHeader.wFirst)));
    DL_VERBOSE(("wUnderline=%d\n", SWAPW(FontHeader.wUnderline)));
    DL_VERBOSE(("wUnderlineWidth=%d\n", SWAPW(FontHeader.wUnderlineWidth)));
    DL_VERBOSE(("wOverline=%d\n", SWAPW(FontHeader.wOverline)));
    DL_VERBOSE(("wOverlineWidth=%d\n", SWAPW(FontHeader.wOverlineWidth)));
    DL_VERBOSE(("wStrikeOut=%d\n", SWAPW(FontHeader.wStrikeOut)));
    DL_VERBOSE(("wStrikeOutWidth=%d\n", SWAPW(FontHeader.wStrikeOutWidth)));
    DL_VERBOSE(("wCellWidth=%d\n", SWAPW(FontHeader.wCellWidth)));
    DL_VERBOSE(("wCellHeight=%d\n", SWAPW(FontHeader.wCellHeight)));
    DL_VERBOSE(("wCellLeftOffset=%d\n", SWAPW(FontHeader.wCellLeftOffset)));
    DL_VERBOSE(("wCellAscender=%d\n", SWAPW(FontHeader.wCellAscender)));
    DL_VERBOSE(("FixPitchWidth=%d.%d\n",
        SWAPW(FontHeader.FixPitchWidth.Integer),
        FontHeader.FixPitchWidth.Fraction));
    DL_VERBOSE(("FontName=%s\n", sFontName));

    return FONT_HEADER_SIZE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadCharGlyph
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth
    )
{
    GETINFO_GLYPHBITMAP GBmp;
    GLYPHDATA *pGdata;
    GLYPHBITS *pbit;
    DWORD  dwNeeded;
    WORD cp;
    ESCPAGECHAR ESCPageChar;
    WORD wWidth, Width, Hight;
    LPDIBITS lpSrc;
    BYTE mask;
    int iSizeOfBuf, i;
    DWORD dwSize, dwCellSize, dwAirSize;
    BYTE Buff[32];
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    MY_VERBOSE(("OEMDownloadCharGlyph() entry.\n"));

    cp = (WORD)pOEM->wCharCode;

    GBmp.dwSize    = sizeof (GETINFO_GLYPHBITMAP);
    GBmp.hGlyph    = hGlyph;
    GBmp.pGlyphData = NULL;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp, GBmp.dwSize, &dwNeeded))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\n"));
        return 0;
    }

    pGdata = GBmp.pGlyphData;
    pbit = pGdata->gdf.pgb;

    DL_VERBOSE(("DLCharGlyph: dwDLFont=%x, dwDLSetFont=%x, wCharCode=%x\n",
        pOEM->dwDLFontID, pOEM->dwDLSetFontID, pOEM->wCharCode));

    // Set font id if not already
    if (pOEM->dwDLFontID != pOEM->dwDLSetFontID)
        VSetSelectDLFont(pdevobj, pOEM->dwDLSetFontID);

    // fill in the charcter header information.
    ESCPageChar.bFormat       = 0x01;
    ESCPageChar.bDataDir      = 0x10;
// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        cp += SJISCHR;
//        ESCPageChar.wCharCode     = SWAPW(cp);
//    }else{
        ESCPageChar.wCharCode     = LOBYTE(cp);
//    }
// CASIO 98/11/24 <-

    ESCPageChar.wBitmapWidth       = SWAPW(pbit->sizlBitmap.cx);
    ESCPageChar.wBitmapHeight      = SWAPW(pbit->sizlBitmap.cy);

// MSKK 98/04/06 ->
//    ESCPageChar.wLeftOffset        = SWAPW(pbit->ptlOrigin.x);
//    ESCPageChar.wAscent            = SWAPW(pbit->ptlOrigin.y * -1);
    ESCPageChar.wLeftOffset = (pbit->ptlOrigin.x > 0 ? 
                                                SWAPW(pbit->ptlOrigin.x) : 0);
    ESCPageChar.wAscent     = (pbit->ptlOrigin.y < 0 ?
                                            SWAPW(pbit->ptlOrigin.y * -1) : 0);
// MSKK 98/04/06 <-

    ESCPageChar.CharWidth.Integer  = SWAPW(pGdata->fxD / 16);
    ESCPageChar.CharWidth.Fraction = 0;
    *pdwWidth = ESCPageChar.CharWidth.Integer;

    Width = LOWORD(pbit->sizlBitmap.cx);
    wWidth = (LOWORD(pbit->sizlBitmap.cx) + 7) >> 3;
    Hight = LOWORD(pbit->sizlBitmap.cy);

    // not multiple of 8, need to mask out unused last byte
    // This is done so that we do not advance beyond segment bound
    // which can happen if lpBitmap is just under 64K and adding
    // width to it will cause invalid segment register to be loaded.
    if (mask = bit_mask[LOWORD(Width) & 0x7])
    {
        lpSrc = pbit->aj + wWidth - 1;
        i = LOWORD(Hight);
        while (TRUE)
        {
            (*lpSrc) &= mask;
            i--;
            if (i > 0)
                lpSrc += wWidth;
            else
                break;
        }
    }

    dwCellSize = (DWORD)pbit->sizlBitmap.cy * wWidth;
    dwSize = (DWORD)(LOWORD(Hight)) * wWidth;

// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        iSizeOfBuf = wsprintf(Buff,SET_DOUBLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),HIBYTE(cp),LOBYTE(cp));
//    }else{
        iSizeOfBuf = wsprintf(Buff,SET_SINGLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),LOBYTE(cp));
//    }
// CASIO 98/11/24 <-
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);

    WRITESPOOLBUF(pdevobj, (LPSTR)&ESCPageChar, sizeof(ESCPAGECHAR));

    for (lpSrc = pbit->aj; dwSize; lpSrc += wWidth)
    {
        if ( dwSize > 0x4000 )
            wWidth = 0x4000;
        else
            wWidth = LOWORD(dwSize);

        dwSize -= wWidth;

        WRITESPOOLBUF(pdevobj, (LPSTR)lpSrc, (WORD)wWidth);
    }

    MY_VERBOSE(("ESCPageChar:\n"));
    MY_VERBOSE(("bFormat=%d\n", ESCPageChar.bFormat));
    MY_VERBOSE(("bDataDir=%d\n", ESCPageChar.bDataDir));
    MY_VERBOSE(("wCharCode=%d\n", SWAPW(ESCPageChar.wCharCode)));
    MY_VERBOSE(("wBitmapWidth=%d\n", SWAPW(ESCPageChar.wBitmapWidth)));
    MY_VERBOSE(("wBitmapHeight=%d\n", SWAPW(ESCPageChar.wBitmapHeight)));
    MY_VERBOSE(("wLeftOffset=%d\n", SWAPW(ESCPageChar.wLeftOffset)));
    MY_VERBOSE(("wAscent=%d\n", SWAPW(ESCPageChar.wAscent)));
    MY_VERBOSE(("CharWidth=%d.%d\n", SWAPW(ESCPageChar.CharWidth.Integer),
        ESCPageChar.CharWidth.Fraction));

    return sizeof(ESCPAGECHAR) + dwCellSize;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMTTDownloadMethod
//////////////////////////////////////////////////////////////////////////
DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    )
{
    DWORD dwRet;

    // Default is to download.
    dwRet = TTDOWNLOAD_BITMAP;

    DL_VERBOSE(("TTDLMethod: dwRet=%d\n", dwRet));

    return dwRet;
}

VOID APIENTRY
OEMMemoryUsage(
    PDEVOBJ pdevobj,
    POEMMEMORYUSAGE pMemoryUsage
    )
{
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {
        pMemoryUsage->dwFixedMemoryUsage = (pOEM->Printer == PRN_N403) ?
            N403_DIZSIZ_B1 * 4 + N403_ENTDIZSIZ_B2 * 4 + N403_LUTTBLSIZ +
            N403_CCHRGBSIZ + N403_CCHCMYSIZ + N403_TNRTBLSIZ :
            N4_DIZSIZ_CM * 2 + N4_DIZSIZ_YK * 2 + N4_LUTTBLSIZ + N4_CCHRGBSIZ +
            N4_CCHCMYSIZ + N4_TNRTBLSIZ;
        pMemoryUsage->dwPercentMemoryUsage = 100 * (pOEM->Col.DatBit * 4 + 24 + 32) / 32;

        MY_VERBOSE(("OEMMemOryUsage pOEM->Col.DatBit = %d\n",pOEM->Col.DatBit));
    }

    return;
}


// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\n4diz.c ===
//***************************************************************************************************
//    N4DIZ.C
//
//    Functions of dither and color matching (For N4 printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "PDEV.H"

//***************************************************************************************************
//    Data define
//***************************************************************************************************
/*----------------------------------------------------------------------------
    Pattern original(Ver.3)
----------------------------------------------------------------------------*/
const static BYTE    MgtGinTbl[3] = { 144, 136, 116 };
const static BYTE    MgtTilTbl[3][4][4] = {
    /*--- Dispersion ----*/
    {   {     0,    8,    2,   10    },
        {    12,    4,   14,    6    },
        {     3,   11,    1,    9    },
        {    15,    7,   13,    5    }    },
    /*--- Net ----*/
    {   {     1,    3,   14,   12    },
        {     8,   10,    4,    6    },
        {    15,   13,    0,    2    },
        {     5,    7,    9,   11    }    },
    /*--- Center ----*/
    {   {    12,    9,    5,   13    },
        {     4,    0,    1,   10    },
        {     8,    3,    2,    6    },
        {    15,    7,   11,   14    }    }
};
const static BYTE    YelGinTbl[3] = { 120, 120, 120 };
const static BYTE    YelTilTbl[3][4][4] = {
    /*--- Net ----*/
    {   {     0,    2,   14,   12    },
        {     8,   10,    5,    7    },
        {    15,   13,    1,    3    },
        {     4,    6,    9,   11    }    },
    /*--- Center ----*/
    {   {    12,    9,    5,   13    },
        {     4,    0,    1,   10    },
        {     8,    3,    2,    6    },
        {    15,    7,   11,   14    }    },
    /*--- Center ----*/
    {   {    12,    9,    5,   13    },
        {     4,    0,    1,   10    },
        {     8,    3,    2,    6    },
        {    15,    7,   11,   14    }    }
};
const static BYTE    BlaGinTbl[3] = { 100, 100, 100 };
const static BYTE    BlaTilTbl[3][4][4] = {
    /*--- Dispersion ----*/
    {   {     0,    8,    2,   10    },
        {    12,    4,   14,    6    },
        {     3,   11,    1,    9    },
        {    15,    7,   13,    5    }    },
    /*--- Dispersion ----*/
    {   {     0,    8,    2,   10    },
        {    12,    4,   14,    6    },
        {     3,   11,    1,    9    },
        {    15,    7,   13,    5    }    },
    /*--- Net ----*/
    {   {     0,    2,   14,   12    },
        {     8,   10,    5,    7    },
        {    15,   13,    1,    3    },
        {     4,    6,    9,   11    }    }
};
#define STRMGT 16
const static BYTE    MgtTilNum[17] = {
    2, 11, 13, 4, 15, 6, 3, 12, 1, 10, 16, 7, 14, 5, 8, 0, 9
};

/*----------------------------------------------------------------------------
    Pattern original(Ver.3) For enter to printer
----------------------------------------------------------------------------*/
const static BYTE Bun4x4All[16] = {                /* Dither pattern (4*4)    */
     0,     8,     2,    10,
    12,     4,    14,     6,
     3,    11,     1,     9,
    15,     7,    13,     5
};
const static BYTE Bun2x2All[16] = {                /* Dither pattern (2*2)    */
     0,     2,
     3,     1
};
/*==== Detail ====*/
const static BYTE Bun8x8Bla[64] = {                /* black   */
    /*---- Dispersion ----*/
    3,    35,    11,    43,    1,     33,    9,    41,
    51,   19,    59,    27,    49,    17,    57,   25,
    15,   47,    7,     39,    13,    45,    5,    37,
    63,   31,    55,    23,    61,    29,    53,   21,
    0,    32,    8,     40,    2,     34,    10,   42,
    48,   16,    56,    24,    50,    18,    58,   26,
    12,   44,    4,     36,    14,    46,    6,    38,
    60,   28,    52,    20,    62,    30,    54,   22
};
const static BYTE Bun8x8Cyn[64] = {                /* cyan     */
    /*---- Dispersion ----*/
    0,     63,    15,    51,    3,     60,    12,    48,
    16,    32,    31,    47,    19,    35,    28,    44,
    56,    8,     55,    7,     59,    11,    52,    4,
    36,    24,    40,    23,    39,    27,    43,    20,
    14,    50,    2,     61,    13,    49,    1,     62,
    30,    46,    18,    34,    29,    45,    17,    33,
    54,    6,     58,    10,    53,    5,     57,    9,
    41,    22,    38,    26,    42,    21,    37,    25
};
const static BYTE Bun8x8Mgt[64] = {                /* magenta    */
    /*---- Dispersion ----*/
    0,     31,    55,    39,    13,    17,    57,    41,
    48,    32,    8,     23,    61,    45,    5,     25,
    12,    16,    56,    40,    2,     29,    53,    37,
    60,    44,    4,     24,    50,    34,    10,    21,
    3,     28,    52,    36,    14,    18,    58,    42,
    51,    35,    11,    20,    62,    46,    6,     26,
    15,    19,    59,    43,    1,     30,    54,    38,
    63,    47,    7,     27,    49,    33,    9,     22
};
/*==== Normal ====*/
const static BYTE Mid8x8Cyn[64] = {                /* cyan     */
    /*---- Net ----*/
    32, 19, 14, 62, 63, 60,  2,  7,
    54,  4,  9, 31, 59, 22, 24, 58,
    50, 27, 42, 29, 16, 11, 40, 46,
    15, 37, 57, 53,  1,  6, 34, 38,
     0, 10, 45, 49, 25, 55, 51, 20,
     5, 36, 33, 18, 13, 43, 47, 35,
    56, 52, 39,  3,  8, 30, 41, 26,
    44, 48, 21, 23, 61, 28, 17, 12
};
const static BYTE Mid8x8Bla[64] = {                /* black   */
    /*---- Dispersion ----*/
    3,     35,    11,    43,    1,     33,    9,     41,
    51,    19,    59,    27,    49,    17,    57,    25,
    15,    47,    7,     39,    13,    45,    5,     37,
    63,    31,    55,    23,    61,    29,    53,    21,
    0,     32,    8,     40,    2,     34,    10,    42,
    48,    16,    56,    24,    50,    18,    58,    26,
    12,    44,    4,     36,    14,    46,    6,     38,
    60,    28,    52,    20,    62,    30,    54,    22
};
const static BYTE Mid8x8Mgt[64] = {                /* Magenta   */
    /*---- Net ----*/
    44, 48, 21, 23, 61, 28, 17, 12,
    56, 52, 39,  3,  8, 30, 41, 26,
     5, 36, 33, 18, 13, 43, 47, 35,
     0, 10, 45, 49, 25, 55, 51, 20,
    15, 37, 57, 53,  1,  6, 34, 38,
    50, 27, 42, 29, 16, 11, 40, 46,
    54,  4,  9, 31, 59, 22, 24, 58,
    32, 19, 14, 62, 63, 60,  2,  7
};
const static BYTE Mid8x8Yel[64] = {                /* Yellow  */
    /*---- Net ----*/
    50,    0,     8,     56,    48,    2,     10,    58,
    30,    32,    40,    20,    28,    34,    42,    22,
    14,    60,    52,    4,     12,    62,    54,    6,
    46,    16,    24,    36,    44,    18,    26,    38,
    49,    3,     11,    59,    51,    1,     9,     57,
    29,    35,    43,    23,    31,    33,    41,    21,
    13,    63,    55,    7,     15,    61,    53,    5,
    45,    19,    27,    39,    47,    17,    25,    37
};
/*==== collage ====*/
const static BYTE Syu8x8Cyn[64] = {                /* cyan        */
    /*---- center ----*/
    61,    45,    16,    12,    8,     28,    41,    57,
    5,     25,    36,    52,    48,    32,    21,    1,
    9,     29,    43,    59,    63,    47,    17,    13,
    49,    33,    23,    3,     7,     27,    37,    53,
    62,    46,    19,    15,    11,    31,    42,    58,
    6,     26,    39,    55,    51,    35,    22,    2,
    10,    30,    40,    56,    60,    44,    18,    14,
    50,    34,    20,    0,     4,     24,    38,    54
};
const static BYTE Syu8x8Mgt[64] = {                /* magenta   */
    /*---- center ----*/
    49,    13,    9,     61,    50,    14,    10,    62,
    33,    29,    25,    45,    34,    30,    26,    46,
    20,    40,    39,    19,    23,    43,    36,    16,
    4,     56,    55,    3,     7,     59,    52,    0,
    8,     60,    51,    15,    11,    63,    48,    12,
    24,    44,    35,    31,    27,    47,    32,    28,
    37,    17,    21,    41,    38,    18,    22,    42,
    53,    1,     5,     57,    54,    2,     6,     58
};
const static BYTE Syu8x8Yel[64] = {                /* yellow    */
    /*---- center ----*/
    5,     13,    39,    59,    58,    43,    17,    7,
    23,    31,    49,    44,    36,    50,    25,    15,
    41,    52,    26,    18,    10,    28,    53,    33,
    61,    34,    8,     0,     2,     20,    46,    60,
    62,    42,    16,    6,     4,     12,    38,    63,
    37,    55,    24,    14,    22,    30,    54,    45,
    11,    29,    48,    32,    40,    51,    27,    19,
    3,     21,    47,    56,    57,    35,    9,     1
};

const static BYTE Wgt001[8][8] = {
    {  0,  8, 56, 48,  2, 10, 58, 50 },
    { 32, 40, 20, 28, 34, 42, 22, 30 },
    { 60, 52,  4, 12, 62, 54,  6, 14 },
    { 16, 24, 36, 44, 18, 26, 38, 46 },
    {  3, 11, 59, 51,  1,  9, 57, 49 },
    { 35, 43, 23, 31, 33, 41, 21, 29 },
    { 63, 55,  7, 15, 61, 53,  5, 13 },
    { 19, 27, 39, 47, 17, 25, 37, 45 }
};
const static BYTE Wgt002[8][8] = {
    {  5, 13, 39, 59, 58, 43, 17,  7 },
    { 23, 31, 49, 44, 36, 50, 25, 15 },
    { 41, 52, 26, 18, 10, 28, 53, 33 },
    { 61, 34,  8,  0,  2, 20, 46, 60 },
    { 62, 42, 16,  6,  4, 12, 38, 63 },
    { 37, 55, 24, 14, 22, 30, 54, 45 },
    { 11, 29, 48, 32, 40, 51, 27, 19 },
    {  3, 21, 47, 56, 57, 35,  9,  1 }
};

const static SHORT SinTbl[256] = {
       0,    3,    6,    9,   12,   15,   18,   21,
      25,   28,   31,   34,   37,   40,   43,   46,
      49,   52,   54,   57,   60,   63,   66,   68,
      71,   73,   76,   79,   81,   83,   86,   88,
      90,   92,   95,   97,   99,  101,  103,  104,
     106,  108,  110,  111,  113,  114,  115,  117,
     118,  119,  120,  121,  122,  123,  124,  125,
     125,  126,  126,  127,  127,  127,  127,  127,
     127,  127,  127,  127,  127,  126,  126,  125,
     125,  124,  123,  123,  122,  121,  120,  119,
     117,  116,  115,  113,  112,  110,  109,  107,
     105,  104,  102,  100,   98,   96,   94,   91,
      89,   87,   85,   82,   80,   77,   75,   72,
      70,   67,   64,   61,   59,   56,   53,   50,
      47,   44,   41,   38,   35,   32,   29,   26,
      23,   20,   17,   14,   11,    7,    4,    1,
      -1,   -4,   -7,  -11,  -14,  -17,  -20,  -23,
     -26,  -29,  -32,  -35,  -38,  -41,  -44,  -47,
     -50,  -53,  -56,  -59,  -61,  -64,  -67,  -70,
     -72,  -75,  -77,  -80,  -82,  -85,  -87,  -89,
     -91,  -94,  -96,  -98, -100, -102, -104, -105,
    -107, -109, -110, -112, -113, -115, -116, -117,
    -119, -120, -121, -122, -123, -123, -124, -125,
    -125, -126, -126, -127, -127, -127, -127, -127,
    -127, -127, -127, -127, -127, -126, -126, -125,
    -125, -124, -123, -122, -121, -120, -119, -118,
    -117, -115, -114, -113, -111, -110, -108, -106,
    -104, -103, -101,  -99,  -97,  -95,  -92,  -90,
     -88,  -86,  -83,  -81,  -79,  -76,  -73,  -71,
     -68,  -66,  -63,  -60,  -57,  -54,  -52,  -49,
     -46,  -43,  -40,  -37,  -34,  -31,  -28,  -25,
     -21,  -18,  -15,  -12,   -9,   -6,   -3,    0
};

/*============================================================================
    Gamma revision table
============================================================================*/
const static BYTE GamTbl014[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
    0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04,
    0x05, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x08,
    0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0c, 0x0c, 0x0d,
    0x0d, 0x0e, 0x0f, 0x0f, 0x10, 0x11, 0x11, 0x12,
    0x13, 0x13, 0x14, 0x15, 0x15, 0x16, 0x17, 0x17,
    0x18, 0x19, 0x1a, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d,
    0x1e, 0x1f, 0x20, 0x20, 0x21, 0x22, 0x23, 0x23,
    0x24, 0x25, 0x26, 0x27, 0x28, 0x28, 0x29, 0x2a,
    0x2b, 0x2c, 0x2d, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
    0x32, 0x33, 0x34, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3e, 0x3f,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
    0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x60,
    0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
    0x69, 0x6a, 0x6b, 0x6c, 0x6e, 0x6f, 0x70, 0x71,
    0x72, 0x73, 0x74, 0x75, 0x76, 0x78, 0x79, 0x7a,
    0x7b, 0x7c, 0x7d, 0x7e, 0x80, 0x81, 0x82, 0x83,
    0x84, 0x85, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c,
    0x8e, 0x8f, 0x90, 0x91, 0x92, 0x94, 0x95, 0x96,
    0x97, 0x98, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xa0,
    0xa1, 0xa2, 0xa3, 0xa5, 0xa6, 0xa7, 0xa8, 0xaa,
    0xab, 0xac, 0xad, 0xaf, 0xb0, 0xb1, 0xb2, 0xb4,
    0xb5, 0xb6, 0xb7, 0xb9, 0xba, 0xbb, 0xbd, 0xbe,
    0xbf, 0xc0, 0xc2, 0xc3, 0xc4, 0xc6, 0xc7, 0xc8,
    0xca, 0xcb, 0xcc, 0xce, 0xcf, 0xd0, 0xd1, 0xd3,
    0xd4, 0xd5, 0xd7, 0xd8, 0xd9, 0xdb, 0xdc, 0xde,
    0xdf, 0xe0, 0xe2, 0xe3, 0xe4, 0xe6, 0xe7, 0xe8,
    0xea, 0xeb, 0xec, 0xee, 0xef, 0xf1, 0xf2, 0xf3,
    0xf5, 0xf6, 0xf8, 0xf9, 0xfa, 0xfc, 0xfd, 0xff
};

const static BYTE GamTbl016[256] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02,
    0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05,
    0x05, 0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08,
    0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c, 0x0c,
    0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f, 0x10, 0x11,
    0x11, 0x12, 0x12, 0x13, 0x13, 0x14, 0x15, 0x15,
    0x16, 0x17, 0x17, 0x18, 0x19, 0x19, 0x1a, 0x1b,
    0x1b, 0x1c, 0x1d, 0x1e, 0x1e, 0x1f, 0x20, 0x20,
    0x21, 0x22, 0x23, 0x23, 0x24, 0x25, 0x26, 0x27,
    0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2b, 0x2c, 0x2d,
    0x2e, 0x2f, 0x30, 0x30, 0x31, 0x32, 0x33, 0x34,
    0x35, 0x36, 0x37, 0x38, 0x38, 0x39, 0x3a, 0x3b,
    0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,
    0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,
    0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
    0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5b, 0x5c,
    0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x65,
    0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6d, 0x6e,
    0x6f, 0x70, 0x71, 0x72, 0x74, 0x75, 0x76, 0x77,
    0x78, 0x7a, 0x7b, 0x7c, 0x7d, 0x7f, 0x80, 0x81,
    0x82, 0x83, 0x85, 0x86, 0x87, 0x89, 0x8a, 0x8b,
    0x8c, 0x8e, 0x8f, 0x90, 0x92, 0x93, 0x94, 0x95,
    0x97, 0x98, 0x99, 0x9b, 0x9c, 0x9d, 0x9f, 0xa0,
    0xa1, 0xa3, 0xa4, 0xa5, 0xa7, 0xa8, 0xaa, 0xab,
    0xac, 0xae, 0xaf, 0xb0, 0xb2, 0xb3, 0xb5, 0xb6,
    0xb8, 0xb9, 0xba, 0xbc, 0xbd, 0xbf, 0xc0, 0xc2,
    0xc3, 0xc4, 0xc6, 0xc7, 0xc9, 0xca, 0xcc, 0xcd,
    0xcf, 0xd0, 0xd2, 0xd3, 0xd5, 0xd6, 0xd8, 0xd9,
    0xdb, 0xdc, 0xde, 0xdf, 0xe1, 0xe2, 0xe4, 0xe5,
    0xe7, 0xe8, 0xea, 0xec, 0xed, 0xef, 0xf0, 0xf2,
    0xf3, 0xf5, 0xf7, 0xf8, 0xfa, 0xfb, 0xfd, 0xff
};


//***************************************************************************************************
//    Function
//***************************************************************************************************
//===================================================================================================
//    Make dither pattern
//===================================================================================================
VOID WINAPI N4DizPtnMak(
    LPN4DIZINF     lpDiz,
    DWORD          dizNum,
    DWORD          diz                                      // Type of dithering
)
{
    WORD           cntTil;                                  // count
    WORD           cntXax;                                  // count
    WORD           cntYax;                                  // count
    WORD           strXax;
    WORD           strYax;
    WORD           dotGin;
    DWORD          num;
    LPBYTE         DizTblCyn;                               // Dither pattern table(CMYK)
    LPBYTE         DizTblMgt;
    LPBYTE         DizTblYel;
    LPBYTE         DizTblBla;

    DizTblCyn = lpDiz->Diz.Tbl[dizNum][0];
    DizTblMgt = lpDiz->Diz.Tbl[dizNum][1];
    DizTblYel = lpDiz->Diz.Tbl[dizNum][2];
    DizTblBla = lpDiz->Diz.Tbl[dizNum][3];

    /*---- Make black pattern for monochrome ----*/
    if(lpDiz->ColMon == N4_MON){
        for(cntTil = 0; cntTil < 4; cntTil++){
            for(cntYax = 0; cntYax < 8; cntYax++){
                for(cntXax = 0; cntXax < 8; cntXax++){
                    if(diz == N4_DIZ_SML){
                        num = (DWORD)Bun8x8Bla[cntYax*8+cntXax] * 4;
                    }else if(diz == N4_DIZ_MID){
                        num = (DWORD)Mid8x8Yel[cntYax*8+cntXax] * 4;
                    }else{
                        num = (DWORD)Syu8x8Yel[cntYax*8+cntXax] * 4;
                    }
                    num += (DWORD)Bun2x2All[cntTil];
//                    DizTblBla[(cntTil/2)*8+cntYax][(cntTil%2)*8+cntXax] = num;
                    DizTblBla[((cntTil / 2) * 8 + cntYax) * 16 + ((cntTil % 2) * 8 + cntXax)] = (BYTE)num;
                }
            }
        }
        return;
    }


    /*---- Make magenta cyan pattern ----*/
    strXax = 6;
    strYax = 0xffff;
    dotGin = MgtGinTbl[diz];
    for(cntTil = 0; cntTil < 17; cntTil++){
        strXax += 4;
        strYax += 1;
        num = (DWORD)STRMGT * 17 + (DWORD)MgtTilNum[cntTil];
        num = num * 255 / (17 * 17);
//        DizTblMgt[strYax % 17][strXax % 17] = num;
        DizTblMgt[(strYax % 17) * 17 + (strXax % 17)] = (BYTE)num;
        DizTblCyn[(strYax % 17) * 17 + (16 - strXax % 17)] = (BYTE)num;
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                num = (DWORD)MgtTilTbl[diz][cntYax][cntXax] * 17
                                        + (DWORD)MgtTilNum[cntTil];
                /* dot gain revision */
                if(num < (17*17/2)){
                    num = num * dotGin / 100;
                }else{
                    num -= 17*17/2;
                    num = num * (100 - dotGin/2) / 50;
                    num += (17*17/2) * dotGin / 100;
                }
                if(num < 4){ num = 4; }
                num = num * 255 / (17 * 17);
//                DizTblMgt[(strYax+cntYax+1)%17][(strXax+cntXax)%17] = num;
                DizTblMgt[((strYax + cntYax + 1) % 17) * 17 + ((strXax + cntXax) % 17)] = (BYTE)num;
//                DizTblCyn[(strYax+cntYax+1)%17][16-(strXax+cntXax)%17] = num;
                DizTblCyn[((strYax + cntYax + 1) % 17) * 17 + (16 - (strXax + cntXax) % 17)] = (BYTE)num;
            }
        }
    }
    /*---- Make yellow pattern ----*/
    dotGin = YelGinTbl[diz];
    for(cntTil = 0; cntTil < 16; cntTil++){
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                num = (DWORD)YelTilTbl[diz][cntYax][cntXax] * 16
                                        + (DWORD)Bun4x4All[cntTil];
                /* dot gain revision */
                if(num < (16*16/2)){
                    num = num * dotGin / 100;
                }else{
                    num -= 16*16/2;
                    num = num * (100 - dotGin/2) / 50;
                    num += (16*16/2) * dotGin / 100;
                }
                num *= 255;
                num /= 16 * 16;
                if(num < 4){ num = 4; }
//                DizTblYel[(cntTil/4)*4 + cntYax][(cntTil%4)*4 + cntXax] = num;
                DizTblYel[((cntTil / 4) * 4 + cntYax) * 16 + ((cntTil % 4) * 4 + cntXax)] = (BYTE)num;
            }
        }
    }
    /*---- Make black pattern ----*/
    dotGin = BlaGinTbl[diz];
    for(cntTil = 0; cntTil < 16; cntTil++){
        for(cntYax = 0; cntYax < 4; cntYax++){
            for(cntXax = 0; cntXax < 4; cntXax++){
                num = (DWORD)BlaTilTbl[diz][cntYax][cntXax] * 16
                                    + (DWORD)Bun4x4All[cntTil];
                /* dot gain revision */
                if(num < (16*16/2)){
                    num = num * dotGin / 100;
                }else{
                    num -= 16*16/2;
                    num = num * (100 - dotGin/2) / 50;
                    num += (16*16/2) * dotGin / 100;
                }
                num *= 255;
                num /= 16 * 16;
                if(num < 4){ num = 4; }
                
//                DizTblBla[(cntTil/4)*4 + cntYax][(cntTil%4)*4 + cntXax] = num;
                DizTblBla[((cntTil / 4) * 4 + cntYax) * 16 + ((cntTil % 4) * 4 + cntXax)] = (BYTE)num;
            }
        }
    }
}


//===================================================================================================
//     Make dither pattern (for printer entry)
//===================================================================================================
VOID WINAPI N4DizPtnPrn(
    LPN4DIZINF     lpDiz,
    DWORD          dizNum,
    DWORD          colNum,                                  // Color number(0:C 1:M 2:Y 3:K)
    DWORD          ptnSkl,                                  // Density(0`255)
    LPBYTE         ptnAdr                                   // Dither pattern
)
{
    WORD           nijRit;                                  /* dot gain(blot ratej        */
    DWORD          vldDot;
    DWORD          cnt064;                                  /* counter                    */
    DWORD          cnt016;                                  /* counter                    */
    DWORD          cntXax;                                  /* counter                    */
    DWORD          cntYax;                                  /* counter                    */
    LPBYTE         srcAdr;

    /*---- Source dither table address set ----*/
    if(dizNum == N4_DIZ_SML){
        switch(colNum){
            case 0:
                nijRit = 144;
                srcAdr = (LPBYTE)Bun8x8Cyn;
                break;
            case 1:
                nijRit = 144;
                srcAdr = (LPBYTE)Bun8x8Mgt;
                break;
            case 2:
                nijRit = 132;
                srcAdr = (LPBYTE)Mid8x8Yel;
                break;
            case 3:
            default:
                if (lpDiz->ColMon == N4_MON) {
                    nijRit = 100;
                    srcAdr = (LPBYTE)Bun8x8Bla;
                } else {
                    nijRit = 100;
                    srcAdr = (LPBYTE)Bun8x8Bla;
                }
                break;
        }
    }else if(dizNum == N4_DIZ_MID){
        switch(colNum){
            case 0:
                nijRit = 120;
                srcAdr = (LPBYTE)Mid8x8Cyn;
                break;
            case 1:
                nijRit = 120;
                srcAdr = (LPBYTE)Mid8x8Mgt;
                break;
            case 2:
                nijRit = 132;
                srcAdr = (LPBYTE)Mid8x8Yel;
                break;
            case 3:
            default:
                if (lpDiz->ColMon == N4_MON) {
                    nijRit = 100;
                    srcAdr = (LPBYTE)Mid8x8Yel;
                } else {
                    nijRit = 100;
                    srcAdr = (LPBYTE)Bun8x8Bla;
                }
                break;
        }
    }else if(dizNum == N4_DIZ_RUG) {
        switch(colNum){
            case 0:
                nijRit = 120;
                srcAdr = (LPBYTE)Syu8x8Cyn;
                break;
            case 1:
                nijRit = 120;
                srcAdr = (LPBYTE)Syu8x8Mgt;
                break;
            case 2:
                nijRit = 132;
                srcAdr = (LPBYTE)Mid8x8Yel;
                break;
            case 3:
            default:
                if (lpDiz->ColMon == N4_MON) {
                    nijRit = 100;
                    srcAdr = (LPBYTE)Syu8x8Yel;
                } else {
                    nijRit = 100;
                    srcAdr = (LPBYTE)Bun8x8Bla;
                }
                break;
        }
    }else{
        nijRit = 100;
        switch(colNum){
            case 0:
                srcAdr = (LPBYTE)Bun8x8Cyn;
                break;
            case 1:
                srcAdr = (LPBYTE)Bun8x8Mgt;
                break;
            case 2:
                srcAdr = (LPBYTE)Mid8x8Yel;
                break;
            case 3:
            default:
                if (lpDiz->ColMon == N4_MON) {
                    srcAdr = (LPBYTE)Mid8x8Yel;
                } else {
                    srcAdr = (LPBYTE)Bun8x8Bla;
                }
                break;
        }
    }

    /*---- Get dot gain ----*/
    if(ptnSkl <= (DWORD)(255 * nijRit / 200)){
        vldDot = ((DWORD)32 * 32 * ptnSkl / 255) * 100 / nijRit;
    }else{
        vldDot = ((DWORD)20480 * ptnSkl - (DWORD)26112 * nijRit);
        vldDot /= ((DWORD)10200 - (DWORD)51 * nijRit);
        vldDot += 512;
    }

    /*---- Make pattern ----*/
    for(cntYax = 0 ; cntYax < 32 ; cntYax ++){
        ptnAdr[cntYax*4]     = 0x00;
        ptnAdr[cntYax*4 + 1] = 0x00;
        ptnAdr[cntYax*4 + 2] = 0x00;
        ptnAdr[cntYax*4 + 3] = 0x00;
        for(cntXax = 0 ; cntXax < 32 ; cntXax ++){
            /*---- 16 * 16 No ----*/
            cnt016 = Bun4x4All[4 * (cntYax/8) + cntXax/8];
            cnt064 = srcAdr[8*(cntYax%8) + cntXax%8];
            /*---- Make dither pattern ----*/
            if(vldDot > 16 * cnt064 + cnt016){
                ptnAdr[cntYax*4 + cntXax/8] |= ((BYTE)0x80 >> (cntXax % 8));
            }
        }
    }
}

//===================================================================================================
//    Make toner density table
//===================================================================================================
VOID WINAPI N4TnrTblMak(
    LPN4DIZINF     lpDiz,
    LONG           tnrDns
)
{
    LONG           innNum;
    LONG           outNum;
    LPBYTE         InnTblCmy;

    tnrDns *= 2;                                            // set twice as tnrdns
    InnTblCmy = lpDiz->Tnr.Tbl;
    /*---- Make CMYK conversion table ----*/
    if(tnrDns < 0){
        for(innNum = 0 ; innNum < 256 ; innNum++){
            if(innNum == 255){    outNum = 255;
            }else{                outNum = innNum * (255 + tnrDns) / 255;
            }
            InnTblCmy[innNum] = (BYTE)outNum;
        }
    }else{
        for(innNum = 0 ; innNum < 256 ; innNum++){
            if(innNum == 0){    outNum = 0;
            }else{                outNum = (innNum + tnrDns) * 255 / (255 + tnrDns);
            }
            InnTblCmy[innNum] = (BYTE)outNum;
        }
    }
}


//===================================================================================================
//    Dithering(Not stretch)
//===================================================================================================
DWORD WINAPI N4Diz001(                                      // Number of lines
    LPN4DIZINF     lpDiz,
    DWORD          xaxSiz,                                  // x pixel
    DWORD          strXax,                                  // x start position
    DWORD          strYax,                                  // y start position
    LPBYTE         cmyBuf,
    LPBYTE         linBufCyn,                               // Line buffer(C)
    LPBYTE         linBufMgt,                               // Line buffer(M)
    LPBYTE         linBufYel,                               // Line buffer(Y)
    LPBYTE         linBufBla                                // Line buffer(K)
)
{
    DWORD          cntHrz;
    BYTE           tmpByt;
    DWORD          dizNum;
    LPBYTE         DizTblCyn;
    LPBYTE         DizTblMgt;
    LPBYTE         DizTblYel;
    LPBYTE         DizTblBla;

    dizNum = lpDiz->Diz.Num;
    DizTblCyn = lpDiz->Diz.Tbl[dizNum][0];
    DizTblMgt = lpDiz->Diz.Tbl[dizNum][1];
    DizTblYel = lpDiz->Diz.Tbl[dizNum][2];
    DizTblBla = lpDiz->Diz.Tbl[dizNum][3];

    /*---- Not stretch ----*/
    if(lpDiz->ColMon == N4_COL){
        DizTblCyn += strYax % 17 * 17;
        DizTblMgt += strYax % 17 * 17;
        DizTblYel += strYax % 16 * 16;
        DizTblBla += strYax % 16 * 16;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpByt = (BYTE)0x80 >> (cntHrz % 8);
//            if(cmyBuf[cntHrz*4+0] > DizTblCyn[strYax%17][strXax%17]){
            if (cmyBuf[cntHrz * 4 + 0] > DizTblCyn[strXax % 17]) {
                linBufCyn[cntHrz / 8] |= tmpByt;
            }
//            if(cmyBuf[cntHrz*4+1] > DizTblMgt[strYax%17][strXax%17]){
            if (cmyBuf[cntHrz * 4 + 1] > DizTblMgt[strXax % 17]) {
                linBufMgt[cntHrz / 8] |= tmpByt;
            }
//            if(cmyBuf[cntHrz*4+2] > DizTblYel[strYax%16][strXax%16]){
            if (cmyBuf[cntHrz * 4 + 2] > DizTblYel[strXax % 16]) {
                linBufYel[cntHrz / 8] |= tmpByt;
            }
//            if(cmyBuf[cntHrz*4+3] > DizTblBla[strYax%16][strXax%16]){
            if (cmyBuf[cntHrz * 4 + 3] > DizTblBla[strXax % 16]) {
                linBufBla[cntHrz / 8] |= tmpByt;
            }
            strXax++;
        }
    } else {
        DizTblBla += strYax % 16 * 16;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
            tmpByt = (BYTE)0x80 >> (cntHrz % 8);
//            if(cmyBuf[cntHrz*4+3] > DizTblBla[strYax%16][strXax%16]){
            if (cmyBuf[ cntHrz * 4 + 3] > DizTblBla[strXax % 16]) {
                linBufBla[cntHrz / 8] |= tmpByt;
            }
            strXax++;
        }
    }
    return 1;
}


//===================================================================================================
//    Dither(Stretch )
//===================================================================================================
DWORD WINAPI N4Diz00n(
    LPN4DIZINF     lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    DWORD          linByt,
    LPBYTE         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    DWORD          cntHrz;
    DWORD          cntXax;
    DWORD          cntYax;
    DWORD          xaxSet;
    DWORD          yaxSet;
    DWORD          tmpXax;
    DWORD          tmpYax;
    DWORD          tmpBuf;
    BYTE           tmpByt;
    DWORD          dizNum;
    LPBYTE         DizTblCyn;
    LPBYTE         DizTblMgt;
    LPBYTE         DizTblYel;
    LPBYTE         DizTblBla;

    dizNum = lpDiz->Diz.Num;
    DizTblCyn = lpDiz->Diz.Tbl[dizNum][0];
    DizTblMgt = lpDiz->Diz.Tbl[dizNum][1];
    DizTblYel = lpDiz->Diz.Tbl[dizNum][2];
    DizTblBla = lpDiz->Diz.Tbl[dizNum][3];

    /*---- Stretch ----*/
    if(lpDiz->ColMon == N4_COL){
//        yaxSet = (USINT)(yaxOfs + 1) * yaxNrt / yaxDnt;
//        yaxSet -= (USINT)yaxOfs * yaxNrt / yaxDnt;
        yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
        yaxSet -= yaxOfs * yaxNrt / yaxDnt;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
//            xaxSet = (USINT)(xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
//            xaxSet -= (USINT)(xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tmpByt = (BYTE)0x80 >> (tmpXax % 8);
                tmpBuf = tmpXax / 8;
                tmpYax = strYax;
                for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
//                    if(cmyBuf[cntHrz*4+0] > DizTblCyn[tmpYax%17][strXax%17]){
                    if (cmyBuf[cntHrz * 4 + 0] > DizTblCyn[(tmpYax % 17) * 17 + (strXax % 17)]) {
                        linBufCyn[tmpBuf] |= tmpByt;
                    }
//                    if(cmyBuf[cntHrz*4+1] >    DizTblMgt[tmpYax%17][strXax%17]){
                    if (cmyBuf[cntHrz * 4 + 1] > DizTblMgt[(tmpYax % 17) * 17 + (strXax % 17)]) {
                        linBufMgt[tmpBuf] |= tmpByt;
                    }
//                    if(cmyBuf[cntHrz*4+2] >    DizTblYel[tmpYax%16][strXax%16]){
                    if (cmyBuf[cntHrz * 4 + 2] > DizTblYel[(tmpYax % 16) * 16 + (strXax % 16)]) {
                        linBufYel[tmpBuf] |= tmpByt;
                    }
//                    if(cmyBuf[cntHrz*4+3] >    DizTblBla[tmpYax%16][strXax%16]){
                    if (cmyBuf[cntHrz * 4 + 3] > DizTblBla[(tmpYax % 16) * 16 + (strXax % 16)]) {
                        linBufBla[tmpBuf] |= tmpByt;
                    }
                    tmpBuf += linByt;
                    tmpYax++;
                }
                strXax++;
                tmpXax++;
            }
        }
    } else {
//        yaxSet = (USHRT)(((USINT)yaxOfs + 1) * yaxNrt / yaxDnt);
//        yaxSet -= (USHRT)((USINT)yaxOfs * yaxNrt / yaxDnt);
        yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
        yaxSet -= yaxOfs * yaxNrt / yaxDnt;
        tmpXax = 0;
        for(cntHrz = 0 ; cntHrz < xaxSiz ; cntHrz++){
//            xaxSet = (USHRT)(((USINT)xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt);
//            xaxSet -= (USHRT)(((USINT)xaxOfs + cntHrz) * xaxNrt / xaxDnt);
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                tmpByt = (BYTE)0x80 >> (tmpXax % 8);
                tmpBuf = tmpXax / 8;
                tmpYax = strYax;
                for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
//                    if(cmyBuf[cntHrz*4+3] >    DizTblBla[tmpYax%16][strXax%16]){
                    if (cmyBuf[cntHrz * 4 + 3] > DizTblBla[(tmpYax % 16) * 16 + (strXax % 16)]) {
                        linBufBla[tmpBuf] |= tmpByt;
                    }
                    tmpBuf += linByt;
                    tmpYax++;
                }
                strXax++;
                tmpXax++;
            }
        }
    }
    return yaxSet;
}


#define CMYLOW        6
//===================================================================================================
//    GOSA-KAKUSAN(Not stretch)
//===================================================================================================
DWORD WINAPI N4Gos001(
    LPN4DIZINF     lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    LPBYTE         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    LONG           strHrz;
    LONG           endHrz;
    LONG           idc;
    LONG           i;
    LONG           k;
    SHORT          m00;
    SHORT          m01;
    SHORT          m02;
    SHORT          m03;
    SHORT          sum;
    SHORT          shiKii;
    SHORT          gos;
    SHORT          num;
    WORD           strCol;
    WORD           j;
    LPSHORT        CmyGo0;
    LPSHORT        CmyGo1;
    DWORD          GosTblXSize;
    DWORD          YaxOfsCmy;

    if ((strYax & 1) == 0) {
        CmyGo0 = lpDiz->GosCMYK.Tbl[0];
        CmyGo1 = lpDiz->GosCMYK.Tbl[1];
    } else {
        CmyGo0 = lpDiz->GosCMYK.Tbl[1];
        CmyGo1 = lpDiz->GosCMYK.Tbl[0];
    }
    GosTblXSize = lpDiz->GosCMYK.Siz;
    YaxOfsCmy = lpDiz->GosCMYK.Yax;
    CmyGo0 += 4;
    CmyGo1 += 4;
    if(lpDiz->ColMon == N4_COL){ strCol = 0; }else{ strCol = 3; }

    if(strYax - YaxOfsCmy != 1){
        for(i = 0 ; (DWORD)i < GosTblXSize * 4 ; i++){
            CmyGo1[i] = 0;
        }
    }
    YaxOfsCmy = strYax;
    CmyGo0 += strXax * 4;
    CmyGo1 += strXax * 4;

    /*---- filter set ----*/
    switch(strYax % 6){
        case 0:                                /*---- evn1 >> filter ----*/
            m00=3; m01=5; m02=3; m03=7; idc = +1;    break;
        case 1:                                /*---- odd1 >> filter ----*/
            m00=1; m01=5; m02=3; m03=7; idc = +1;    break;
        case 2:                                /*---- evn2 >> filter ----*/
            m00=4; m01=5; m02=4; m03=8; idc = +1;    break;
        case 3:                                /*---- odd2 << filter ----*/
            m00=1; m01=3; m02=0; m03=7; idc = -1;    break;
        case 4:                                /*---- evn3 << filter ----*/
            m00=2; m01=4; m02=0; m03=8; idc = -1;    break;
        case 5:                                /*---- odd4 >> filter ----*/
        default:
            m00=3; m01=8; m02=3; m03=8; idc = +1;    break;
    }
    sum = m00 + m01 + m02 + m03;
    if(idc == +1){
        strHrz = 0; endHrz = xaxSiz;
    }else{
        strHrz = xaxSiz - 1; endHrz = -1;
    }
    for(i = strHrz ; i != endHrz ; i+=idc){
        for(j = strCol ; j < 4 ; j++){
            k = i * 4 + j;
            num = cmyBuf[k];
            if(num < CMYLOW){ num = 0; }
            shiKii = num / 2 + 52;
            if(j != 2){                    /* except yellow               */
                if((num > 112)&&(num < 144)){
                    shiKii += 
                        ((SHORT)Wgt001[strYax%8][(i+strXax)%8]-32)*256/128;
                }else{
                    shiKii += 
                        ((SHORT)Wgt002[strYax%8][(i+strXax)%8]-32)*num/128;
                }
            }
            gos = (    CmyGo1[k - 4] * m00 + 
                    CmyGo1[k    ] * m01 +
                    CmyGo1[k + 4] * m02 +
                    CmyGo0[k - idc*4] * m03
                    ) / sum;
            if(gos + num > shiKii){
                CmyGo0[k] = num + gos - 255;
                /*---- enter line buffer ----*/
                if(j == 0){
                    linBufCyn[i/8] |= ((BYTE)0x80 >> (i%8));
                }else if(j == 1){
                    linBufMgt[i/8] |= ((BYTE)0x80 >> (i%8));
                }else if(j == 2){
                    linBufYel[i/8] |= ((BYTE)0x80 >> (i%8));
                }else{
                    linBufBla[i/8] |= ((BYTE)0x80 >> (i%8));
                }
            }else{
                CmyGo0[k] = num + gos;
            }
        }
    }
    lpDiz->GosCMYK.Yax = YaxOfsCmy;
    return    1;
}


//===================================================================================================
//    GOSA-KAKUSAN(Stretch)
//===================================================================================================
DWORD WINAPI N4Gos00n(
    LPN4DIZINF     lpDiz,
    DWORD          xaxSiz,
    DWORD          strXax,
    DWORD          strYax,
    DWORD          xaxOfs,
    DWORD          yaxOfs,
    DWORD          xaxNrt,
    DWORD          xaxDnt,
    DWORD          yaxNrt,
    DWORD          yaxDnt,
    DWORD          linByt,
    LPBYTE         cmyBuf,
    LPBYTE         linBufCyn,
    LPBYTE         linBufMgt,
    LPBYTE         linBufYel,
    LPBYTE         linBufBla
)
{
    LONG           cntHrz;
    LONG           cntYax;
    LONG           cntXax;
    LONG           yaxSet;
    LONG           xaxSet;
    LONG           strHrz;
    LONG           endHrz;
    LONG           idc;
    LONG           i;
    LONG           k;
    SHORT          m00;
    SHORT          m01;
    SHORT          m02;
    SHORT          m03;
    SHORT          sum;
    SHORT          shiKii;
    SHORT          gos;
    SHORT          num;
    LPSHORT        bak;
    WORD           strCol;
    WORD           j;
    LPSHORT        CmyGo0;
    LPSHORT        CmyGo1;
    DWORD          GosTblXSize;
    DWORD          YaxOfsCmy;

    if ((strYax & 1) == 0) {                                // y coordinates is even number?
        CmyGo0 = lpDiz->GosCMYK.Tbl[0];
        CmyGo1 = lpDiz->GosCMYK.Tbl[1];
    } else {
        CmyGo0 = lpDiz->GosCMYK.Tbl[1];
        CmyGo1 = lpDiz->GosCMYK.Tbl[0];
    }
    GosTblXSize = lpDiz->GosCMYK.Siz;
    YaxOfsCmy = lpDiz->GosCMYK.Yax;
    CmyGo0 += 4;
    CmyGo1 += 4;

    if(lpDiz->ColMon == N4_COL){ strCol = 0; }else{ strCol = 3; }

    if(strYax - YaxOfsCmy != 1){
        for(i = 0 ; (DWORD)i < GosTblXSize * 4 ; i++){
            CmyGo1[i] = 0;
        }
    }
    YaxOfsCmy = strYax;
    CmyGo0 += strXax * 4;
    CmyGo1 += strXax * 4;
    yaxSet = (yaxOfs + 1) * yaxNrt / yaxDnt;
    yaxSet -= yaxOfs * yaxNrt / yaxDnt;
    for(cntYax = 0 ; cntYax < yaxSet ; cntYax++){
        /*---- filter set ----*/
        switch(strYax % 6){
            case 0:                                /*---- evn1 >> filter ----*/
                m00=3; m01=5; m02=3; m03=7; idc = +1;    break;
            case 1:                                /*---- odd1 >> filter ----*/
                m00=1; m01=5; m02=3; m03=7; idc = +1;    break;
            case 2:                                /*---- evn2 >> filter ----*/
                m00=4; m01=5; m02=4; m03=8; idc = +1;    break;
            case 3:                                /*---- odd2 << filter ----*/
                m00=1; m01=3; m02=0; m03=7; idc = -1;    break;
            case 4:                                /*---- evn3 << filter ----*/
                m00=2; m01=4; m02=0; m03=8; idc = -1;    break;
            case 5:                                /*---- odd4 >> filter ----*/
            default:
                m00=3; m01=8; m02=3; m03=8; idc = +1;    break;
        }
        sum = m00 + m01 + m02 + m03;
        if(idc == +1){
            strHrz = 0; endHrz = xaxSiz;
            i = 0;
        }else{
            strHrz = xaxSiz - 1; endHrz = -1;
            i = (xaxOfs + xaxSiz) * xaxNrt / xaxDnt;
            i -= xaxOfs * xaxNrt / xaxDnt;
            i -= 1;
        }
        for(cntHrz = strHrz ; cntHrz != endHrz ; cntHrz+=idc){
            xaxSet = (xaxOfs + cntHrz + 1) * xaxNrt / xaxDnt;
            xaxSet -= (xaxOfs + cntHrz) * xaxNrt / xaxDnt;
            for(cntXax = 0 ; cntXax < xaxSet ; cntXax ++){
                for(j = strCol ; j < 4 ; j++){
                    k = i * 4 + j;
                    num = cmyBuf[cntHrz * 4 + j];
                    if(num < CMYLOW){ num = 0; }
                    shiKii = num / 2 + 52;
                    if(j != 2){                    /* except yellow        */
                        if((num > 112)&&(num < 144)){
                            shiKii += 
                            ((SHORT)Wgt001[strYax%8][(strXax+i)%8]-32)*256/128;
                        }else{
                            shiKii += 
                            ((SHORT)Wgt002[strYax%8][(strXax+i)%8]-32)*num/128;
                        }
                    }
                    gos = (    CmyGo1[k - 4] * m00 +
                            CmyGo1[k    ] * m01 +
                            CmyGo1[k + 4] * m02 +
                               CmyGo0[k - idc * 4] * m03
                               ) / sum;
                    if(gos + num > shiKii){
                        CmyGo0[k] = num + gos - 255;
                        /*---- enter line buffer ----*/
                        if(j == 0){
                            linBufCyn[i/8] |= ((BYTE)0x80 >> (i%8));
                        }else if(j == 1){
                            linBufMgt[i/8] |= ((BYTE)0x80 >> (i%8));
                        }else if(j == 2){
                            linBufYel[i/8] |= ((BYTE)0x80 >> (i%8));
                        }else{
                            linBufBla[i/8] |= ((BYTE)0x80 >> (i%8));
                        }
                    }else{
                        CmyGo0[k] = num + gos;
                    }
                }
                i += idc;
            }
        }
        bak = CmyGo1;
        CmyGo1 = CmyGo0;
        CmyGo0 = bak;
        linBufCyn += linByt;
        linBufMgt += linByt;
        linBufYel += linByt;
        linBufBla += linByt;
        strYax++;
    }
    if (yaxSet != 0) {
        lpDiz->GosCMYK.Yax = YaxOfsCmy + yaxSet - 1;
    }
    return    yaxSet;
}


#define BUNKAI    (SHORT)8
//===================================================================================================
//    RGB GOSA-Dispersion
//===================================================================================================
VOID WINAPI N4RgbGos(
    LPN4DIZINF     lpDiz,
    DWORD          xaxSiz,
    DWORD          drwXax,
    DWORD          yaxOfs,
    LPBYTE         rgbBuf
)
{
    SHORT          m00;
    SHORT          m01;
    SHORT          m02;
    SHORT          m03;
    SHORT          sum;
    SHORT          j;
    SHORT          gos;
    SHORT          out;
    LONG           i;
    LONG           k;
    LONG           idc;
    LONG           strXax;
    LONG           endXax;

    LPSHORT        RgbGo0;
    LPSHORT        RgbGo1;
    DWORD          GosTblXSize;
    DWORD          YaxOfsRgb;

    if ((yaxOfs & 1) == 0) {                                // Y coodinate is even number?
        RgbGo0 = lpDiz->GosRGB.Tbl[0];
        RgbGo1 = lpDiz->GosRGB.Tbl[1];
    } else {
        RgbGo0 = lpDiz->GosRGB.Tbl[1];
        RgbGo1 = lpDiz->GosRGB.Tbl[0];
    }
    GosTblXSize = lpDiz->GosRGB.Siz;
    YaxOfsRgb = lpDiz->GosRGB.Yax;
    RgbGo0 += 3;
    RgbGo1 += 3;
    if(yaxOfs - YaxOfsRgb != 1){
        for(i = 0 ; (DWORD)i < GosTblXSize * 3 ; i++){
            RgbGo1[i] = 0;
        }
    }
    lpDiz->GosRGB.Yax = yaxOfs;
    RgbGo0 += drwXax * 3;
    RgbGo1 += drwXax * 3;
    /*---- filter set ----*/
    switch(yaxOfs % 6){
        case 0:                                    /*---- evn1 >> filter ----*/
            m00=3; m01=5; m02=3; m03=7;
            idc = +1; strXax = 0; endXax = xaxSiz;
            break;
        case 1:                                    /*---- odd1 >> filter ----*/
            m00=1; m01=5; m02=3; m03=7;
            idc = +1; strXax = 0; endXax = xaxSiz;
            break;
        case 2:                                    /*---- evn2 >> filter ----*/
            m00=4; m01=5; m02=4; m03=8;
            idc = +1; strXax = 0; endXax = xaxSiz;
            break;
        case 3:                                    /*---- odd2 << filter ----*/
            m00=1; m01=3; m02=0; m03=7;
            idc = -1; strXax = xaxSiz - 1; endXax = -1;
            break;
        case 4:                                    /*---- evn3 << filter ----*/
            m00=2; m01=4; m02=0; m03=8;
            idc = -1; strXax = xaxSiz - 1; endXax = -1;
            break;
        case 5:                                    /*---- odd4 >> filter ----*/
        default:
            m00=3; m01=8; m02=3; m03=8;
            idc = +1; strXax = 0; endXax = xaxSiz;
            break;
    }
    sum = m00 + m01 + m02 + m03;

    /*---- GOSA-dispersion ----*/
    for(i = strXax ; i != endXax ; i += idc){
        for(j = 0 ; j < 3 ; j++){
            k = i * 3 + j;
            gos = (    m00 * RgbGo1[k - 3] + 
                    m01 * RgbGo1[k    ] +
                    m02 * RgbGo1[k + 3] +
                    m03 * RgbGo0[k - idc*3]
                    ) / sum;
            out = gos + rgbBuf[k];
            out = out / BUNKAI;
            out = out * BUNKAI;
            if(out > 255){ out = 255; }
            else if(out < 0){ out = 0; }
            RgbGo0[k] = (gos + (SHORT)rgbBuf[k]) - out;
            rgbBuf[k] = (BYTE)out;
        }
    }
    return;
}

//===================================================================================================
//    Color Matching(Speed is high)
//===================================================================================================
VOID WINAPI N4ColMch000(
    LPN4DIZINF     lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz,
    DWORD          blaCnv
)
{
    LPRGB          endAdr;
    LPCMYK         LokUppRgbCmy;                            // Lut table
    LPBYTE         innTblCmy;                               // Toner density table
    LONG           tmpRed;
    LONG           tmpGrn;
    LONG           tmpBlu;
    LONG           tmpCal;
    CMYK           tmpCmy;

    LokUppRgbCmy = lpDiz->Lut.Tbl;
    innTblCmy = lpDiz->Tnr.Tbl;

    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Green;
        tmpBlu = rgbAdr->Blue;
        if((blaCnv == 0)&&((tmpRed | tmpGrn | tmpBlu) == 0)){
            tmpCmy.Cyn = 0;
            tmpCmy.Mgt = 0;
            tmpCmy.Yel = 0;
            tmpCmy.Bla = 255;
            *cmyAdr = tmpCmy;
            cmyAdr++;
            continue;
        }
        tmpCal  = tmpRed / N4_GLDSPC * N4_GLDNUM * N4_GLDNUM;
        tmpCal += tmpGrn / N4_GLDSPC * N4_GLDNUM;
        tmpCal += tmpBlu / N4_GLDSPC;
        tmpCmy = LokUppRgbCmy[tmpCal];
        tmpCmy.Cyn = innTblCmy[tmpCmy.Cyn];
        tmpCmy.Mgt = innTblCmy[tmpCmy.Mgt];
        tmpCmy.Yel = innTblCmy[tmpCmy.Yel];
        tmpCmy.Bla = innTblCmy[tmpCmy.Bla];
        *cmyAdr = tmpCmy;
        cmyAdr++;
    }
}


//===================================================================================================
//    Color Matching(Speed is normal)
//===================================================================================================
VOID WINAPI N4ColMch001(
    LPN4DIZINF     lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz,
    DWORD          blaCnv
)
{
    LONG           tmpRed;
    LONG           tmpGrn;
    LONG           tmpBlu;
    LONG           tmpR01;
    LONG           tmpR02;
    LONG           tmpG01;
    LONG           tmpG02;
    LONG           tmpB01;
    LONG           tmpB02;
    LONG           ln1;
    LONG           ln2;
    LONG           ln3;

    LONG           tmpC00;
    LONG           tmpM00;
    LONG           tmpY00;
    LONG           tmpK00;
    LONG           tmpC01;
    LONG           tmpM01;
    LONG           tmpY01;
    LONG           tmpK01;
    LONG           tmpC02;
    LONG           tmpM02;
    LONG           tmpY02;
    LONG           tmpK02;
    LONG           tmpC03;
    LONG           tmpM03;
    LONG           tmpY03;
    LONG           tmpK03;

    LPCMYK         LokUppRgbCmy;
    LPBYTE         innTblCmy;
    LPRGB          CchRgb;
    LPCMYK         CchCmy;

    LPRGB          endAdr;
    DWORD          cch;
    RGBS           tmpRgb;
    CMYK           tmpCmy;

    LokUppRgbCmy = lpDiz->Lut.Tbl;
    innTblCmy = lpDiz->Tnr.Tbl;
    CchRgb = lpDiz->Lut.CchRgb;
    CchCmy = lpDiz->Lut.CchCmy;

    for(endAdr = rgbAdr+xaxSiz ; rgbAdr < endAdr ; rgbAdr++){
        tmpRgb = *rgbAdr;
        tmpRed = tmpRgb.Red;
        tmpGrn = tmpRgb.Green;
        tmpBlu = tmpRgb.Blue;
        if((blaCnv == 0)&&((tmpRed | tmpGrn | tmpBlu) == 0)){
            tmpCmy.Cyn = 0;
            tmpCmy.Mgt = 0;
            tmpCmy.Yel = 0;
            tmpCmy.Bla = 255;
            *cmyAdr = tmpCmy;
            cmyAdr++;
            continue;
        }

        cch = ( tmpRed * 49 + tmpGrn * 9 + tmpBlu ) % N4_CCHNUM;
        if(    (CchRgb[cch].Red == tmpRgb.Red) &&
            (CchRgb[cch].Green == tmpRgb.Green) &&
            (CchRgb[cch].Blue == tmpRgb.Blue)
        ){
            *cmyAdr = CchCmy[cch];
            cmyAdr++;
            continue;
        }

        /*---- RGB -> CMYK ----*/
        tmpR01 = tmpRed * 31 / 255;
        tmpR02 = (tmpRed * 31 + 254) / 255;

        tmpG01 = tmpGrn * 31 / 255;
        tmpG02 = (tmpGrn * 31 + 254) / 255;

        tmpB01 = tmpBlu * 31 / 255;
        tmpB02 = (tmpBlu * 31 + 254) / 255;


        ln2 = tmpRed - tmpR01*255/31;
        if(ln2 == 0){
            tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB01];
            tmpC00 = tmpCmy.Cyn;
            tmpM00 = tmpCmy.Mgt;
            tmpY00 = tmpCmy.Yel;
            tmpK00 = tmpCmy.Bla;
            tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB02];
            tmpC01 = tmpCmy.Cyn;
            tmpM01 = tmpCmy.Mgt;
            tmpY01 = tmpCmy.Yel;
            tmpK01 = tmpCmy.Bla;
            tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB01];
            tmpC02 = tmpCmy.Cyn;
            tmpM02 = tmpCmy.Mgt;
            tmpY02 = tmpCmy.Yel;
            tmpK02 = tmpCmy.Bla;
            tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB02];
            tmpC03 = tmpCmy.Cyn;
            tmpM03 = tmpCmy.Mgt;
            tmpY03 = tmpCmy.Yel;
            tmpK03 = tmpCmy.Bla;
        }else{
            ln1 = tmpR02*255/31 - tmpRed;
            if(ln1 == 0){
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB01];
                tmpC00 = tmpCmy.Cyn;
                tmpM00 = tmpCmy.Mgt;
                tmpY00 = tmpCmy.Yel;
                tmpK00 = tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB02];
                tmpC01 = tmpCmy.Cyn;
                tmpM01 = tmpCmy.Mgt;
                tmpY01 = tmpCmy.Yel;
                tmpK01 = tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB01];
                tmpC02 = tmpCmy.Cyn;
                tmpM02 = tmpCmy.Mgt;
                tmpY02 = tmpCmy.Yel;
                tmpK02 = tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB02];
                tmpC03 = tmpCmy.Cyn;
                tmpM03 = tmpCmy.Mgt;
                tmpY03 = tmpCmy.Yel;
                tmpK03 = tmpCmy.Bla;
            }else{
                ln3 = ln1 + ln2;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB01];
                tmpC00 = ln1 * tmpCmy.Cyn;
                tmpM00 = ln1 * tmpCmy.Mgt;
                tmpY00 = ln1 * tmpCmy.Yel;
                tmpK00 = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB01];
                tmpC00 += ln2 * tmpCmy.Cyn;
                tmpM00 += ln2 * tmpCmy.Mgt;
                tmpY00 += ln2 * tmpCmy.Yel;
                tmpK00 += ln2 * tmpCmy.Bla;
                tmpC00 /= ln3;
                tmpM00 /= ln3;
                tmpY00 /= ln3;
                tmpK00 /= ln3;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB02];
                tmpC01  = ln1 * tmpCmy.Cyn;
                tmpM01  = ln1 * tmpCmy.Mgt;
                tmpY01  = ln1 * tmpCmy.Yel;
                tmpK01  = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG01 * N4_GLDNUM + tmpB02];
                tmpC01 += ln2 * tmpCmy.Cyn;
                tmpM01 += ln2 * tmpCmy.Mgt;
                tmpY01 += ln2 * tmpCmy.Yel;
                tmpK01 += ln2 * tmpCmy.Bla;
                tmpC01 /= ln3;
                tmpM01 /= ln3;
                tmpY01 /= ln3;
                tmpK01 /= ln3;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB01];
                tmpC02  = ln1 * tmpCmy.Cyn;
                tmpM02  = ln1 * tmpCmy.Mgt;
                tmpY02  = ln1 * tmpCmy.Yel;
                tmpK02  = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB01];
                tmpC02 += ln2 * tmpCmy.Cyn;
                tmpM02 += ln2 * tmpCmy.Mgt;
                tmpY02 += ln2 * tmpCmy.Yel;
                tmpK02 += ln2 * tmpCmy.Bla;
                tmpC02 /= ln3;
                tmpM02 /= ln3;
                tmpY02 /= ln3;
                tmpK02 /= ln3;
                tmpCmy =  LokUppRgbCmy[tmpR01 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB02];
                tmpC03  = ln1 * tmpCmy.Cyn;
                tmpM03  = ln1 * tmpCmy.Mgt;
                tmpY03  = ln1 * tmpCmy.Yel;
                tmpK03  = ln1 * tmpCmy.Bla;
                tmpCmy =  LokUppRgbCmy[tmpR02 * N4_GLDNUM * N4_GLDNUM + tmpG02 * N4_GLDNUM + tmpB02];
                tmpC03 += ln2 * tmpCmy.Cyn;
                tmpM03 += ln2 * tmpCmy.Mgt;
                tmpY03 += ln2 * tmpCmy.Yel;
                tmpK03 += ln2 * tmpCmy.Bla;
                tmpC03 /= ln3;
                tmpM03 /= ln3;
                tmpY03 /= ln3;
                tmpK03 /= ln3;
            }
        }


        ln2 = tmpGrn - tmpG01*255/31;
        if(ln2 != 0){
            ln1 = tmpG02*255/31 - tmpGrn;
            if(ln1 == 0){
                tmpC00 = tmpC02;
                tmpM00 = tmpM02;
                tmpY00 = tmpY02;
                tmpK00 = tmpK02;
                tmpC01 = tmpC03;
                tmpM01 = tmpM03;
                tmpY01 = tmpY03;
                tmpK01 = tmpK03;
            }else{
                ln3 = ln1 + ln2;
                tmpC00 = (ln1*tmpC00 + ln2*tmpC02) / ln3;
                tmpM00 = (ln1*tmpM00 + ln2*tmpM02) / ln3;
                tmpY00 = (ln1*tmpY00 + ln2*tmpY02) / ln3;
                tmpK00 = (ln1*tmpK00 + ln2*tmpK02) / ln3;
                tmpC01 = (ln1*tmpC01 + ln2*tmpC03) / ln3;
                tmpM01 = (ln1*tmpM01 + ln2*tmpM03) / ln3;
                tmpY01 = (ln1*tmpY01 + ln2*tmpY03) / ln3;
                tmpK01 = (ln1*tmpK01 + ln2*tmpK03) / ln3;
            }
        }


        ln2 = tmpBlu - tmpB01*255/31;
        if(ln2 != 0){
            ln1 = tmpB02*255/31 - tmpBlu;
            if(ln1 == 0){
                tmpC00 = tmpC01;
                tmpM00 = tmpM01;
                tmpY00 = tmpY01;
                tmpK00 = tmpK01;
            }else{
                ln3 = ln1 + ln2;
                tmpC00 = (ln1*tmpC00 + ln2*tmpC01) / ln3;
                tmpM00 = (ln1*tmpM00 + ln2*tmpM01) / ln3;
                tmpY00 = (ln1*tmpY00 + ln2*tmpY01) / ln3;
                tmpK00 = (ln1*tmpK00 + ln2*tmpK01) / ln3;
            }
        }

        tmpCmy.Cyn  = innTblCmy[tmpC00];
        tmpCmy.Mgt  = innTblCmy[tmpM00];
        tmpCmy.Yel  = innTblCmy[tmpY00];
        tmpCmy.Bla  = innTblCmy[tmpK00];
        *cmyAdr = tmpCmy;
        cmyAdr++;

        CchRgb[cch] = tmpRgb;
        CchCmy[cch] = tmpCmy;
    }
}


//===================================================================================================
//    RGB -> CMYK Conversion(No matching)
//===================================================================================================
VOID WINAPI N4ColCnvSld(
    LPN4DIZINF     lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz
)
{
    LPRGB          endAdr;
    BYTE           red;
    BYTE           grn;
    BYTE           blu;
    BYTE           cyn;
    BYTE           mgt;
    BYTE           yel;
    BYTE           bla;
    LPBYTE         innTblCmy;

    innTblCmy = lpDiz->Tnr.Tbl;
    for(endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++, cmyAdr++){
        red = rgbAdr->Red;
        grn = rgbAdr->Green;
        blu = rgbAdr->Blue;
        if((red == 0)&&(grn == 0)&&(blu == 0)){
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            cmyAdr->Bla = 255;
        } else {
            cyn = 255 - red;
            mgt = 255 - grn;
            yel = 255 - blu;
            if(cyn > mgt){
                if(mgt > yel){
                    bla = yel / 4;
                }else{
                    bla = mgt / 4;
                }
            }else{
                if(cyn > yel){
                    bla = yel / 4;
                }else{
                    bla = cyn / 4;
                }
            }
            cyn -= bla;
            mgt -= bla;
            yel -= bla;
            if(innTblCmy != NULL){
                cmyAdr->Cyn = innTblCmy[GamTbl014[cyn]];
                cmyAdr->Mgt = innTblCmy[GamTbl014[mgt]];
                cmyAdr->Yel = innTblCmy[GamTbl014[yel]];
                cmyAdr->Bla = innTblCmy[bla];
            }else{
                cmyAdr->Cyn = GamTbl014[cyn];
                cmyAdr->Mgt = GamTbl014[mgt];
                cmyAdr->Yel = GamTbl014[yel];
                cmyAdr->Bla = bla;
            }
        }
    }
    return;
}


//===================================================================================================
//    RGB -> CMYK conversion
//===================================================================================================
VOID WINAPI N4ColCnvLin(
    LPN4DIZINF     lpDiz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz
)
{
    LPRGB          endAdr;
    WORD           red;
    WORD           grn;
    WORD           blu;
    WORD           mid;
    BYTE           cyn;
    BYTE           mgt;
    BYTE           yel;

    for(endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++, cmyAdr++){
        red = rgbAdr->Red;
        grn = rgbAdr->Green;
        blu = rgbAdr->Blue;
        mid = (red + grn + blu)/3;
        if(mid > 240){
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            cmyAdr->Bla = 0;
        } else {
            cyn = 255;
            mgt = 255;
            yel = 255;
            mid += (255 - mid)/8;
            if(red > mid){ cyn = 0; }
            if(grn > mid){ mgt = 0; }
            if(blu > mid){ yel = 0; }
            if((cyn & mgt & yel)==255){
                cmyAdr->Cyn = 0;
                cmyAdr->Mgt = 0;
                cmyAdr->Yel = 0;
                cmyAdr->Bla = 255;
            } else {
                cmyAdr->Cyn = cyn;
                cmyAdr->Mgt = mgt;
                cmyAdr->Yel = yel;
                cmyAdr->Bla = 0;
            }
        }
    }
    return;
}


//===================================================================================================
//    RGB -> CMYK conversion (for monochrome)
//===================================================================================================
VOID WINAPI N4ColCnvMon(
    LPN4DIZINF     lpDiz,
    DWORD          diz,
    LPRGB          rgbAdr,
    LPCMYK         cmyAdr,
    DWORD          xaxSiz
)
{
    LPRGB          endAdr;
    LONG           red;
    LONG           grn;
    LONG           blu;
    LONG           bla;
    LPBYTE         innTblCmy;

    innTblCmy = lpDiz->Tnr.Tbl;
    if (diz == N4_DIZ_SML) {
        for(endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++, cmyAdr++){
            red = rgbAdr->Red;
            grn = rgbAdr->Green;
            blu = rgbAdr->Blue;
            bla = 255 - (red*3 + grn*5 + blu*2) / 10;
            if(bla > 128) { bla += SinTbl[bla] / 4; } else { bla += SinTbl[bla] / 24; }
            if(bla != 0) { bla = (bla + 24) * 255 / (255 + 24); }
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            if(innTblCmy != NULL){
                cmyAdr->Bla = innTblCmy[GamTbl016[(BYTE)bla]];
            }else{
                cmyAdr->Bla = GamTbl016[(BYTE)bla];
            }
        }
    } else if (diz == N4_DIZ_MID) {
        for(endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++, cmyAdr++){
            red = rgbAdr->Red;
            grn = rgbAdr->Green;
            blu = rgbAdr->Blue;
            bla = 255 - (red*3 + grn*5 + blu*2) / 10;
            if(bla > 128) { bla += SinTbl[bla] / 8; } else { bla += SinTbl[bla] / 16; }
            if(bla != 0) { bla = (bla + 24) * 255 / (255 + 24); }
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            if(innTblCmy != NULL){
                cmyAdr->Bla = innTblCmy[GamTbl016[(BYTE)bla]];
            }else{
                cmyAdr->Bla = GamTbl016[(BYTE)bla];
            }
        }
    } else if (diz == N4_DIZ_RUG) {
        for(endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++, cmyAdr++){
            red = rgbAdr->Red;
            grn = rgbAdr->Green;
            blu = rgbAdr->Blue;
            bla = 255 - (red*3 + grn*5 + blu*2) / 10;
            if(bla > 128) { bla += SinTbl[bla] / 32; } else { bla += SinTbl[bla] / 8; }
            if(bla != 0) { bla = (bla + 24) * 255 / (255 + 24); }
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            if(innTblCmy != NULL){
                cmyAdr->Bla = innTblCmy[GamTbl016[(BYTE)bla]];
            }else{
                cmyAdr->Bla = GamTbl016[(BYTE)bla];
            }
        }
    } else {
        for(endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++, cmyAdr++){
            red = rgbAdr->Red;
            grn = rgbAdr->Green;
            blu = rgbAdr->Blue;
            bla = 255 - (red*3 + grn*5 + blu*2) / 10;
            if(bla > 128) { bla += SinTbl[bla] / 6; } else { bla += SinTbl[bla] / 24; }
            if(bla != 0) { bla = (bla + 24) * 255 / (255 + 24); }
            cmyAdr->Cyn = 0;
            cmyAdr->Mgt = 0;
            cmyAdr->Yel = 0;
            if(innTblCmy != NULL){
                cmyAdr->Bla = innTblCmy[GamTbl016[(BYTE)bla]];
            }else{
                cmyAdr->Bla = GamTbl016[(BYTE)bla];
            }
        }
    }
    return;
}


//    End of N4DIZ.C

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>

#include <prcomoem.h>
#include "COLMATCH.H"

//
// For debugging.
//

//#define MY_VERBOSE(x) DBGPRINT(DBG_WARNING, x)
#define MY_VERBOSE VERBOSE
//#define DL_VERBOSE MY_VERBOSE
#define DL_VERBOSE VERBOSE
//#define SC_VERBOSE MY_VERBOSE
#define SC_VERBOSE VERBOSE
//#define CM_VERBOSE MY_VERBOSE
#define CM_VERBOSE VERBOSE


//
// Misc definitions follows.
//

#define DOWNLOADFONT 1
//#define DOWNLOADFONT 0

#define DRVGETDRIVERSETTING(p, t, o, s, n, r) \
    ((p)->pDrvProcs->DrvGetDriverSetting(p, t, o, s, n, r))

#define DRVGETGPDDATA(p, t, i, b, s, n) \
  ((p)->pDrvProcs->DrvGetGPDData(p, t, i, b, s, n))

#define MINIPDEV_DATA(p) ((p)->pdevOEM)

#define MASTER_UNIT 1200

#define DEFAULT_PALETTE_INDEX   0

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " s

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////
//VOID DbgPrint(IN LPCTSTR pstrFormat,  ...);

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CSN4'      // EPSON ESC/Page printers
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

typedef struct {
    DWORD    fGeneral;
    int    iEscapement;
    short    sHeightDiv;
    short    iDevCharOffset;
    BYTE    iPaperSource;
    BYTE    iDuplex;
    BYTE    iTonerSave;
    BYTE    iOrientation;
    BYTE    iResolution; 
    BYTE    iColor;
    BYTE    iSmoothing;
    BYTE    iJamRecovery;
    BYTE    iMediaType;
    BYTE    iUnitFactor;         // factor of master unit
    BYTE    iDithering;
    BYTE    iColorMatching;
    BYTE    iBitFont;
    BYTE    iCmyBlack;
    BYTE    iTone;
    BYTE    iPaperSize;
    BYTE    iCompress;
    WORD    Printer;
    DEVCOL  Col;
    WORD    wRectWidth, wRectHeight;

#define UNKNOWN_DLFONT_ID (~0)

    DWORD dwDLFontID;         // device's current font ID
    DWORD dwDLSelectFontID;   // "SelectFont" font ID 
    DWORD dwDLSetFontID;      // "SetFont" font ID
    WORD wCharCode;

} MYPDEV, *PMYPDEV;

// Flags for fGeneral
#define FG_DBCS        0x00000001
#define FG_VERT        0x00000002
#define FG_PROP        0x00000004
#define FG_DOUBLE      0x00000008
#define FG_NULL_PEN    0x00000010
#define FG_BOLD        0x00000020
#define FG_ITALIC      0x00000040

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif    // _PDEV_H


// End of File

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\prnctl.c ===
//***************************************************************************************************
//    PRNCTL.C
//
//    Functions of controlling printer
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    "PDEV.H"
#include    <stdio.h>
#include    "PRNCTL.H"

#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

//***************************************************************************************************
//    Data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Type of pressing raster image
//---------------------------------------------------------------------------------------------------
#define   RASTER_COMP     0                         // Press
#define   RASTER_NONCOMP  1                         // Not press
#define   RASTER_EMPTY    2                         // Empty

//---------------------------------------------------------------------------------------------------
//    Buffer for setting command
//---------------------------------------------------------------------------------------------------
static BYTE        CmdBuf[1 * 1024];                // 1KB

//---------------------------------------------------------------------------------------------------
//    Structure for setting command
//---------------------------------------------------------------------------------------------------
typedef const struct {
    WORD        Size;                               // Command size
    LPBYTE      Cmd;                                // Command buffer
} CMDDEF, FAR *LPCMDDEF;

//===================================================================================================
//    Command define
//===================================================================================================
//---------------------------------------------------------------------------------------------------
//    Change mode
//---------------------------------------------------------------------------------------------------
static CMDDEF ModOrgIn =    { 4, "\x1b""z""\xd0\x01"};      // ESC/Page -> original
static CMDDEF ModOrgOut =   { 4, "\x1b""z""\x00\x01"};      // original -> ESC/Page

//---------------------------------------------------------------------------------------------------
//    Setting overwrite
//---------------------------------------------------------------------------------------------------
static CMDDEF CfgWrtMod =    { 6, "\x1d""%uowE"};           // Setting overwrite

//---------------------------------------------------------------------------------------------------
//    Setting spool positon
//---------------------------------------------------------------------------------------------------
static CMDDEF PosAbsHrz =    { 4, "\x1d""%dX"};             // Horizontal
static CMDDEF PosAbsVtc =    { 4, "\x1d""%dY"};             // Vertical

//---------------------------------------------------------------------------------------------------
//    Spool bitmap data
//---------------------------------------------------------------------------------------------------
static CMDDEF ImgDrw =       {16, "\x1d""%u;%u;%u;%dbi{I"}; // Spool bit image
static CMDDEF ImgRasStr =    {15, "\x1d""%u;%u;%u;%dbrI"};  // Start spool raster image
static CMDDEF ImgRasEnd =    { 4, "\x1d""erI"};             // End spool raster image
static CMDDEF ImgRasDrw =    { 6, "\x1d""%ur{I"};           // Spool raster image
static CMDDEF ImgRasNon =    { 6, "\x1d""%uu{I"};           // Spool raster image(Not press)
static CMDDEF ImgRasEpy =    { 5, "\x1d""%ueI"};            // Spool empty raster image

//---------------------------------------------------------------------------------------------------
//    CASIO original
//---------------------------------------------------------------------------------------------------
static CMDDEF OrgColCmy =    {15, "Cc,%u,%u,%u,%u*"};       // CMYK
static CMDDEF OrgDrwPln =    {15, "Da,%u,%u,%u,%u*"};       // Setting plane
static CMDDEF OrgImgCmy =    {26, "Cj%w,%u,%u,%u,%l,%l,%u,%u*"};   // CMYK bitimage

static BYTE OVERWRITE[] = 
    "\x1D" "1owE"                      //MOV1
    "\x1D" "0tsE";

//***************************************************************************************************
//    Prototype declaration
//***************************************************************************************************
static WORD        PlaneCmdStore(PDEVOBJ, LPBYTE, WORD);
static void        BitImgImgCmd(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, LPBYTE);
static BOOL        RasterImgCmd(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, WORD, LPBYTE, LPBYTE);
static WORD        RasterSize(WORD, WORD, WORD, WORD, LPBYTE);
static WORD        RasterComp(LPBYTE, WORD, LPBYTE, LPBYTE, LPWORD);
static void        CMYKImgCmd(PDEVOBJ, WORD, LONG, LONG, WORD, WORD, WORD, WORD, WORD, DWORD, DWORD, LPBYTE, LPBYTE, LONG, LONG);
static WORD        CmdCopy(LPBYTE, LPCMDDEF);
static WORD        CmdStore(LPBYTE, LPCMDDEF, LPINT);
static WORD        INTtoASC(LPBYTE, int);
static WORD        USINTtoASC(LPBYTE, WORD);
static WORD        LONGtoASC(LPBYTE, LONG);
static WORD        USLONGtoASC(LPBYTE, DWORD);

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Spool bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmap(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    LPDRWBMP       lpBmp                                    // Pointer to DRWBMP structure
)
{
    WORD           siz,size;
    WORD           comp;
    WORD           width;                                   // dot
    WORD           height;                                  // dot
    WORD           widthByte;                               // byte
    LPBYTE         lpTmpBuf;
    LPBYTE         lpSchBit;
    LPBYTE         lpBit;                                   // Pointer to Bitmap data
    POINT          drwPos;
    WORD           higSiz;                                  // dot
    WORD           higCnt;
    WORD           strHigCnt;
    WORD           widLCnt;                                 // Width from the left edge
    WORD           widRCnt;                                 // Width from the right edge
    WORD           invLft;                                  // Invalid size from the left edge
    WORD           invRgt;                                  // Invalid size from the right edge
    WORD           img1st;                                  // Spool first image data?
    int            pam[4];
    int            palm[1];

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpTmpBuf = NULL;
    width = lpBmp->Width;
    height = lpBmp->Height;
    widthByte = lpBmp->WidthByte;
    comp = No;

    MY_VERBOSE((" PB "));

    img1st = Yes;
    lpSchBit = lpBmp->lpBit;
    for (higCnt = 0; higCnt < height; higCnt++) {
        higSiz = 0;
        invLft = 0;
        invRgt = 0;
        for (; higCnt < height; higCnt++) {               // 1 Spool bitmap data
                                                          // Search NULL data from the left edge
            for (widLCnt = 0; widLCnt < widthByte; widLCnt++) {
                if (lpSchBit[widLCnt] != 0x00) {
                    if (higSiz == 0) {                    // first lineH
                        strHigCnt = higCnt;
                        invLft = widLCnt;                 // Invalid size from the left edge
                    } else {
                        if (invLft > widLCnt) {
                            invLft = widLCnt;             // Renew invalid size from the left edge
                        }
                    }
                                                          // Search NULL data from the right edge
                    for (widRCnt = 0; widRCnt < widthByte; widRCnt++) {
                        if (lpSchBit[widthByte - widRCnt - 1] != 0x00) {
                            if (higSiz == 0) {            // first lineH
                                invRgt = widRCnt;         // Invalid size from the right edge
                            } else {
                                if (invRgt > widRCnt) {
                                    invRgt = widRCnt;     // Renew invalid size from the right edge
                                }
                            }
                            break;
                        }
                    }
                    higSiz++;                             // Renew height size
                    break;
                }
            }
            lpSchBit += widthByte;                        // Next line bitmap data
            if (widLCnt == widthByte && higSiz != 0) {    // 1line all NULL data & There were data except NULL data in previous line
                break;                                    // Go to spool bitmap data
            }
        }
        if (higSiz != 0) {                                // There are data for spoolH
            if (img1st == Yes) {                          // Spool for the first time
                                                          // Compress?
                if (pOEM->iCompress != XX_COMPRESS_OFF) {
                    if ((lpTmpBuf = MemAllocZ(widthByte * height)) != NULL) {
                        comp = Yes;
                    }
                }
                // Original mode in
                siz = CmdCopy(CmdBuf, &ModOrgIn);
                // ColorH
                if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {
                    pam[0] = lpBmp->Color.Cyn;
                    pam[1] = lpBmp->Color.Mgt;
                    pam[2] = lpBmp->Color.Yel;
                    pam[3] = lpBmp->Color.Bla;
                    siz += CmdStore(CmdBuf + siz, &OrgColCmy, pam);

                    siz += PlaneCmdStore(pdevobj, CmdBuf + siz, lpBmp->Plane);
                }
                // Original mode out
                siz += CmdCopy(CmdBuf + siz, &ModOrgOut);
                if (siz != 0) {                         // There are data for spool?
                    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
                }
                img1st = No;                            // Not first time
            }

            drwPos.x = lpBmp->DrawPos.x + invLft * 8;   // x coordinates
            drwPos.y = lpBmp->DrawPos.y + strHigCnt;    // y coordinates
            palm[0] = drwPos.x;
            siz = CmdStore(CmdBuf, &PosAbsHrz, palm);
            palm[0] = drwPos.y;
            siz += CmdStore(CmdBuf + siz, &PosAbsVtc, palm);
            if (siz != 0) {                             // There are data for spool?
                WRITESPOOLBUF(pdevobj, CmdBuf, siz);
            }

            lpBit = lpBmp->lpBit + widthByte * strHigCnt;
            if (comp == Yes) {                          // Compress?

                if (RasterImgCmd(pdevobj, pOEM->iCompress, width, higSiz,
                                 widthByte, 0, invLft, invRgt, lpBit, lpTmpBuf) == No) {
                    comp = No;                          // But compress rate is poor, no compress
                }
            }
            if (comp == No) {                           // Not compress

                BitImgImgCmd(pdevobj, width, higSiz, widthByte, 0, invLft, invRgt, lpBit);
            }
        }
    }
    if (lpTmpBuf) {
        MemFree(lpTmpBuf);
    }
    return;
}


//===================================================================================================
//    Spool CMYK bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmapCMYK(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    LPDRWBMPCMYK   lpBmp                                    // Pointer to DRWBMPCMYK structure
)
{
    WORD           siz;
    WORD           comp;
    WORD           width;                                   // dot
    WORD           height;                                  // dot
    WORD           widthByte;
    LPBYTE         lpSchBit;                                // Pointer to bitmap data
    LPBYTE         lpBit;                                   // Pointer to bitmap data
    LONG           xPos;
    LONG           yPos;
    WORD           posClpLft;                               // Clipping dot size
    DWORD          posAdj;                                  // 1/7200inch
    WORD           higSiz;                                  // dot
    WORD           higCnt;
    WORD           strHigCnt;
    WORD           widLCnt;
    WORD           widRCnt;
    WORD           invLft;                                  // Invalid size from the left edge
    WORD           invRgt;                                  // Invalid size from the right edge
    DWORD          invLftBit;                               // Invalid bit size from the left edge
    DWORD          invRgtBit;                               // Invalid bit size from the right edge
    WORD           rgtBit;                                  // Valid bit size from the right edge
    WORD           img1st;                                  // Spool for the first time
    DWORD          dstSiz;
    LPBYTE         lpDst;
    LPBYTE         lpTmp;
    int            pam[1];
    WORD           img1st_2;                                // Spool for the first time

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE((" CM "));

    lpTmp = NULL;
    posAdj = 7200 / pOEM->Col.wReso;                        // 1/7200inch
    width = lpBmp->Width;
    height = lpBmp->Height;
    widthByte = lpBmp->WidthByte;
    comp = No;
    if (pOEM->iCompress != XX_COMPRESS_OFF) {

        if ((lpTmp = MemAllocZ(widthByte * height)) != NULL) {
            comp = Yes;
        }
    }
    img1st = Yes;
    img1st_2 = Yes;
    lpSchBit = lpBmp->lpBit;
    for (higCnt = 0; higCnt < height; higCnt++) {
        higSiz = 0;
        invLft = 0;
        invRgt = 0;
        for (; higCnt < height; higCnt++) {                // 1 Spool bitmap data
                                                           // Search NULL data from the left edge
            for (widLCnt = 0; widLCnt < widthByte; widLCnt++) {

                if (lpSchBit[widLCnt] != 0x00) {
                    if (higSiz == 0) {
                        strHigCnt = higCnt;                // first line
                        invLft = widLCnt;                  // Invalid size from the left edge
                    } else {
                        if (invLft > widLCnt) {
                            invLft = widLCnt;              // Renew invalid size from the left edge
                        }
                    }
                                                           // Search NULL data from the right edge
                    for (widRCnt = 0; widRCnt < widthByte; widRCnt++) {
                        if (lpSchBit[widthByte - widRCnt - 1] != 0x00) {
                            if (higSiz == 0) {             // first line
                                invRgt = widRCnt;          // Invalid size from the right edge
                            } else {
                                if (invRgt > widRCnt) {
                                    invRgt = widRCnt;      // Renew size from the right edge
                                }
                            }
                            break;
                        }
                    }
                    higSiz++;                              // Renew height size
                    break;
                }
            }
            lpSchBit += widthByte;                         // Next line bitmap data
            if (widLCnt == widthByte && higSiz != 0) {     // 1line all NULL data & There were data except NULL data in previous line
                break;                                     // goto spool
            }
        }
        if (higSiz != 0) {                                 // There are data for spool
            if (img1st_2 == Yes) {
                WRITESPOOLBUF(pdevobj, OVERWRITE, BYTE_LENGTH(OVERWRITE));
                img1st_2 = No;
            }
            // When Colormode is XX_COLOR_MANY ,not compress
            if (comp == Yes && pOEM->iColor == XX_COLOR_MANY) {
                comp = No;
            }
            if (comp == No && img1st == Yes) {
                // Original mode in
                siz = CmdCopy(CmdBuf, &ModOrgIn);
                                                            // Plane
                siz += PlaneCmdStore(pdevobj, CmdBuf + siz, lpBmp->Plane);
                if (siz != 0) {                             // There are data for spool
                    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
                }
                img1st = No;                                // not first
            }

            invLftBit = (DWORD)invLft * 8;
            if (invRgt != 0) {

                if ((rgtBit = (WORD)((DWORD)width * lpBmp->DataBit % 8)) == 0) {
                    rgtBit = 8;
                }
                if (rgtBit == 8) {
                    invRgtBit = (DWORD)invRgt * 8;
                } else {
                    invRgtBit = ((DWORD)invRgt - 1) * 8 + rgtBit;
                }
            } else {
                invRgtBit = 0;
            }
            posClpLft = (WORD)(invLftBit / lpBmp->DataBit);
                                                             // Start position of spooling
            xPos = ((LONG)lpBmp->DrawPos.x + posClpLft) * posAdj;
            yPos = ((LONG)lpBmp->DrawPos.y + strHigCnt) * posAdj;

            lpBit = lpBmp->lpBit + widthByte * strHigCnt;
                                                             // Spool CMYK bit image
            CMYKImgCmd(pdevobj, comp, xPos, yPos, lpBmp->Frame, lpBmp->DataBit, width, higSiz, widthByte,
                       invLftBit, invRgtBit, lpBit, lpTmp, (LONG)lpBmp->DrawPos.x + posClpLft, (LONG)lpBmp->DrawPos.y + strHigCnt);
        }
    }
    if (img1st == No) {                                      // Already spool 
        // Original mode out
        siz = CmdCopy(CmdBuf, &ModOrgOut);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
    }
    if (lpTmp) {
        MemFree(lpTmp);
    }
    return;
}


//===================================================================================================
//    Spool plane command
//===================================================================================================
WORD PlaneCmdStore(                                         // Size of command
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    LPBYTE         lpDst,
    WORD           Plane
)
{
    int            pam[4];
    WORD           siz;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (Plane & PLN_CYAN) {
        pam[0] = 0;                                         // Spool
    } else {
        pam[0] = 1;                                         // Not spool
    }
    if (Plane & PLN_MGENTA) {
        pam[1] = 0;                                         // Spool
    } else {
        pam[1] = 1;                                         // Not spool
    }
    if (Plane & PLN_YELLOW) {
        pam[2] = 0;                                         // Spool
    } else {
        pam[2] = 1;                                         // Not spool
    }
    if (Plane & PLN_BLACK) {
        pam[3] = 0;                                         // Spool
    } else {
        pam[3] = 1;                                         // Not spool
    }
    siz = CmdStore(lpDst, &OrgDrwPln, pam);
    return siz;
}


//===================================================================================================
//    Spool bitimage command data
//===================================================================================================
void BitImgImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           Rotation,                                // rotare(0fixed)
    WORD           InvLeft,                                 // Invalid size from the left edge
    WORD           InvRight,                                // Invalid size from the right edge
    LPBYTE         lpBit                                    // Bitmap data
)
{
    int            pam[10];
    WORD           siz;
    WORD           widByt;
    WORD           linCnt;

    if (InvLeft == 0 && InvRight == 0) {                    // There are no invalid size
        pam[0] = WidthByte * Height;                        // Number of Data byte
        pam[1] = Width;
        pam[2] = Height;
        pam[3] = Rotation;
        siz = CmdStore(CmdBuf, &ImgDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        WRITESPOOLBUF(pdevobj, lpBit, pam[0]);
    } else {                                                // There are invalid size
        widByt = WidthByte - InvLeft - InvRight;            // Width byte
        pam[0] = widByt * Height;
        if (InvRight == 0) {                                // There are no invalid size from the right edge
            pam[1] = Width - InvLeft * 8;                   // Width bit image
        } else {
            pam[1] = widByt * 8;                            // Width bit image
        }
        pam[2] = Height;                                    // Height bit image
        pam[3] = Rotation;
        siz = CmdStore(CmdBuf, &ImgDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        for (linCnt = 0; linCnt < Height; linCnt++) {       // Spool bitmap data by 1 line
            lpBit += InvLeft;
            WRITESPOOLBUF(pdevobj, lpBit, widByt);
            lpBit += widByt;
            lpBit += InvRight;
        }
    }
    return;
}


//===================================================================================================
//    Spool raster image command data
//===================================================================================================
BOOL RasterImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Comp,
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           Rotation,                                // rotate(0:fixed)
    WORD           InvLeft,                                 // Invalid size from the left edge
    WORD           InvRight,                                // Invalid size from the left edge
    LPBYTE         lpBit,                                   // Pointer to bitmap data
    LPBYTE         lpBuf                                    // Pointer to raster image data buffer
)
{
    int            pam[4];
    WORD           siz;
    WORD           widByt;
    WORD           setCnt;
    WORD           ras;                                     // Type of raster image
    WORD           befRas;                                  // Type of raster image(Privious line)
    LPBYTE         lpLas;                                   // Privious raster data
    WORD           dstSiz;                                  // byte size
    WORD           rasSiz;                                  // Raster image data byte size
    WORD           rasEpy;

    MY_VERBOSE((" RAS "));

    widByt = WidthByte - InvLeft - InvRight;                // Width byte (Not include invalid size)
    if (Comp == XX_COMPRESS_AUTO) {
                                                            // Get raster image size
        rasSiz = RasterSize(Height, widByt, InvLeft, InvRight, lpBit);
        if (rasSiz > (widByt * Height / 5 * 4)) {           // Raster rate is more than 80%
            return No;                                      // Error
        }
    }
    pam[0] = 4;
    if (InvRight == 0) {                                    // No invalid size from the right edge
        pam[1] = Width - InvLeft * 8;                       // Width
    } else {
        pam[1] = widByt * 8;                                // Width
    }
    pam[2] = Height;                                        // Height
    pam[3] = Rotation;
    siz = CmdStore(CmdBuf, &ImgRasStr, pam);
    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
    lpLas = NULL;
    rasSiz = 0;
    rasEpy = 0;
    for (setCnt = 0; setCnt < Height; setCnt++) {
        lpBit += InvLeft;
                                                            // Compress
        ras = RasterComp(lpBuf + rasSiz, widByt, lpBit, lpLas, &dstSiz);
        if (setCnt != 0 && befRas != ras) {                 // Not same as raster state of previous line
            if (befRas == RASTER_COMP) {
                pam[0] = rasSiz;
                siz = CmdStore(CmdBuf, &ImgRasDrw, pam);
                WRITESPOOLBUF(pdevobj, CmdBuf, siz);        // Spool command
                WRITESPOOLBUF(pdevobj, lpBuf, rasSiz);      // Spool data
                rasSiz = 0;
            } else if (befRas == RASTER_EMPTY) {
                pam[0] = rasEpy;
                siz = CmdStore(CmdBuf, &ImgRasEpy, pam);
                WRITESPOOLBUF(pdevobj, CmdBuf, siz);
                rasEpy = 0;
            }
        }                                                   // Spool state of current line
        if (ras == RASTER_COMP) {
            rasSiz += dstSiz;
        } else if (ras == RASTER_EMPTY) {
            rasEpy++;
        } else {
            pam[0] = dstSiz;
            siz = CmdStore(CmdBuf, &ImgRasNon, pam);
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);            // Spool command
            WRITESPOOLBUF(pdevobj, lpBit, dstSiz);          // Spool data
        }
        befRas = ras;                                       // Renew
        lpLas = lpBit;                                      // Renew
        lpBit += widByt;                                    // Renew
        lpBit += InvRight;
    }
    if (rasSiz != 0) {                                      // There are raster data without spooling
        pam[0] = rasSiz;
        siz = CmdStore(CmdBuf, &ImgRasDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);                // Spool command
        WRITESPOOLBUF(pdevobj, lpBuf, rasSiz);              // Spool data
    } else if (rasEpy != 0) {                               // There are empty raster data without spooling
        pam[0] = rasEpy;
        siz = CmdStore(CmdBuf, &ImgRasEpy, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);                // Spool command
    }
    siz = CmdCopy(CmdBuf, &ImgRasEnd);
    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
    return Yes;
}


//===================================================================================================
//    Get size of raster image
//===================================================================================================
WORD RasterSize(
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           InvLeft,
    WORD           InvRight,
    LPBYTE         lpBit
)
{
    WORD           rasSiz;
    WORD           chkCnt;
    WORD           rasEpy;
    LPBYTE         lpLas;
    WORD           dstCnt;
    WORD           srcCnt;
    WORD           empSiz;
    BYTE           cmpDat;
    WORD           equCnt;

    rasSiz = 0;
    rasEpy = 0;
    lpLas = NULL;
    for (chkCnt = 0; chkCnt < Height; chkCnt++) {           // Check size of raster image
        lpBit += InvLeft;
        srcCnt = WidthByte;
        for (; srcCnt != 0; srcCnt--) {
            if (lpBit[srcCnt - 1] != 0x00) {
                break;
            }
        }
        if (srcCnt == 0) {                                  // 1 line All white data?
            rasEpy++;
            lpLas = lpBit;
            lpBit += WidthByte;
            lpBit += InvRight;
            continue;
        }
        if (rasEpy != 0) {
            rasSiz += 8;
            rasEpy = 0;
        }
        empSiz = WidthByte - srcCnt;
        for (dstCnt = 0, srcCnt = 0; srcCnt < WidthByte; ) {
            if (lpLas != NULL) {
                if (lpLas[srcCnt] == lpBit[srcCnt]) {
                    equCnt = 1;
                    srcCnt++;
                    for (; srcCnt < WidthByte; srcCnt++) {

                        if (lpLas[srcCnt] != lpBit[srcCnt]) {
                            break;
                        }
                        equCnt++;
                    }
                    if (srcCnt == WidthByte) {
                        rasSiz++;
                        break;
                    }
                }
                rasSiz++;
                if (equCnt >= 63) {
                    rasSiz += ((equCnt / 255) + 1);
                }
            }

            if (srcCnt < (WidthByte - 1) && lpBit[srcCnt] == lpBit[srcCnt + 1]) {
                cmpDat = lpBit[srcCnt];
                equCnt = 2;

                for (srcCnt += 2; srcCnt < WidthByte; srcCnt++) {
                    if (cmpDat != lpBit[srcCnt]) {
                        break;
                    }
                    equCnt++;
                }
                rasSiz += 2;
                if (equCnt >= 63) {
                    rasSiz += equCnt / 255 + 1;
                }
            } else {
                if (WidthByte < (dstCnt + 9)) {
                    rasSiz += WidthByte - empSiz + 9;
                    break;
                }
                if ((WidthByte - srcCnt) < 8) {
                    rasSiz += WidthByte - srcCnt + 1;
                    srcCnt += WidthByte - srcCnt;
                } else {
                    rasSiz += 9;
                    srcCnt += 8;
                }
            }
        }
        lpLas = lpBit;
        lpBit += WidthByte;
        lpBit += InvRight;
    }
    return rasSiz;
}


//===================================================================================================
//    Compress raster image
//===================================================================================================
WORD RasterComp(
    LPBYTE         lpDst,
    WORD           Siz,
    LPBYTE         lpSrc,
    LPBYTE         lpLas,
    LPWORD         lpDstSiz
)
{
    WORD           dstCnt;
    WORD           srcCnt;
    WORD           empSiz;
    BYTE           cmpDat;
    WORD           equCnt;
    WORD           setCnt;
    BYTE           flgByt;
    WORD           flgPnt;

    static const BYTE flgTbl[8] = {0x00, 0x01, 0x02, 0x04,
                                   0x08, 0x10, 0x20, 0x40};

    srcCnt = Siz;
    for (; srcCnt != 0; srcCnt--) {
        if (lpSrc[srcCnt - 1] != 0x00) {
            break;
        }
    }
    if (srcCnt == 0) {
        *lpDstSiz = 0;
        return RASTER_EMPTY;
    }
    empSiz = Siz - srcCnt;
    for (dstCnt = 0, srcCnt = 0; srcCnt < Siz; ) {
        if (lpLas != NULL) {
            if (lpLas[srcCnt] == lpSrc[srcCnt]) {
                equCnt = 1;
                srcCnt++;
                for (; srcCnt < Siz; srcCnt++) {
                    if (lpLas[srcCnt] != lpSrc[srcCnt]) {
                        break;
                    }
                    equCnt++;
                }
                if (srcCnt == Siz) {
                    break;
                }
                if (Siz < (dstCnt + equCnt / 255 + 1)) {
                    *lpDstSiz = Siz - empSiz;
                    return RASTER_NONCOMP;
                }
                if (equCnt < 63) {
                    lpDst[dstCnt++] = 0x80 | (BYTE)equCnt;
                } else {
                    lpDst[dstCnt++] = 0x80 | 0x3f;
                    for (equCnt -= 63; equCnt >= 255; equCnt -= 255) {
                        lpDst[dstCnt++] = 0xff;
                    }
                    lpDst[dstCnt++] = (BYTE)equCnt;
                }
            }
        }

        if (srcCnt < (Siz - 1) && lpSrc[srcCnt] == lpSrc[srcCnt + 1]) {
            cmpDat = lpSrc[srcCnt];
            equCnt = 2;
            for (srcCnt += 2; srcCnt < Siz; srcCnt++) {
                if (cmpDat != lpSrc[srcCnt]) {
                    break;
                }
                equCnt++;
            }
            if (Siz < (dstCnt + equCnt / 255 + 2)) {
                *lpDstSiz = Siz - empSiz;
                return RASTER_NONCOMP;
            }
            if (equCnt < 63) {
                lpDst[dstCnt++] = 0xc0 | (BYTE)equCnt;
            } else {
                lpDst[dstCnt++] = 0xc0 | 0x3f;
                for (equCnt -= 63; equCnt >= 255; equCnt -= 255) {
                    lpDst[dstCnt++] = 0xff;
                }
                lpDst[dstCnt++] = (BYTE)equCnt;
            }
            lpDst[dstCnt++] = cmpDat;
        } else {
            if (Siz < (dstCnt + 9)) {
                *lpDstSiz = Siz - empSiz;
                return RASTER_NONCOMP;
            }
            flgPnt = dstCnt;
            dstCnt++;
            flgByt = 0x00;
            if (lpLas != NULL) {
                for (setCnt = 0; srcCnt < Siz && setCnt < 8; srcCnt++, setCnt++) {
                    if (lpLas[srcCnt] != lpSrc[srcCnt]) {
                        lpDst[dstCnt++] = lpSrc[srcCnt];
                        flgByt |= flgTbl[setCnt];
                    }
                }
            } else {

                for (setCnt = 0; srcCnt < Siz && setCnt < 8; srcCnt++, setCnt++) {
                    lpDst[dstCnt++] = lpSrc[srcCnt];
                    flgByt |= flgTbl[setCnt];
                }
            }
            lpDst[flgPnt] = flgByt;
        }
    }
    if (Siz == dstCnt) {
        *lpDstSiz = Siz - empSiz;
        return RASTER_NONCOMP;
    }
    lpDst[dstCnt++] = 0x80;
    *lpDstSiz = dstCnt;
    return RASTER_COMP;
}


//===================================================================================================
//    Spool CMYK Bit image command
//===================================================================================================
void CMYKImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Comp,
    LONG           XPos,
    LONG           YPos,
    WORD           Frame,
    WORD           DataBit,                                 // (1:2value 2:4value 4:16value)
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    DWORD          InvLeft,                                 // Invalid size from the left edge
    DWORD          InvRight,                                // Invalid size from the right edge
    LPBYTE         lpBit,
    LPBYTE         lpTmp,
    LONG           XPos_P,
    LONG           YPos_P
)
{
    int            pam[11];
    WORD           siz;
    WORD           widByt;                                  // Width byte(Not include invalid size)
    WORD           Plane;
    LPBYTE         lpDst;                                   // Memory copy
    LPBYTE         lpSrc;                                   // Memory copy
    WORD           linCnt;
    DWORD          widBit;                                  // Width bit(Not include invalid size)
    DWORD          dstSiz;
    DWORD          rasSiz;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    widBit = (DWORD)Width * DataBit - InvLeft - InvRight;

    if (Comp == Yes) {                                       // Compress
        siz = CmdCopy(CmdBuf, &ModOrgIn);                    // Original mode in

        if (pOEM->iColor == XX_COLOR_SINGLE || pOEM->iColor == XX_COLOR_MANY) {
            pam[0] = 0;
            pam[1] = 0;
            pam[2] = 0;
            pam[3] = 0;
            if (Frame == 1) {
                pam[0] = 255;
                Plane = PLN_CYAN;
            }
            if (Frame == 2) {
                pam[1] = 255;
                Plane = PLN_MGENTA;
            }
            if (Frame == 3) {
                pam[2] = 255;
                Plane = PLN_YELLOW;
            }
            if (Frame == 0) {
                pam[3] = 255;
                Plane = PLN_BLACK;
            }
            siz += CmdStore(CmdBuf + siz, &OrgColCmy, pam);

            siz += PlaneCmdStore(pdevobj, CmdBuf + siz, Plane);
        }
        siz += CmdCopy(CmdBuf + siz, &ModOrgOut);           // Original mode out
        if (siz != 0) {                                     // There are data for spoolH

            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        }
        pam[0] = XPos_P;
        siz = CmdStore(CmdBuf, &PosAbsHrz, pam);
        pam[0] = YPos_P;
        siz += CmdStore(CmdBuf + siz, &PosAbsVtc, pam);
        if (siz != 0) {                                     // There are data for spool
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        }

        if (RasterImgCmd(pdevobj, pOEM->iCompress, Width, Height,
                         WidthByte, 0, (WORD)((InvLeft + 7) / 8), (WORD)((InvRight + 7) / 8), lpBit, lpTmp) == No) {
            // Not compress because compress rate is poor
            BitImgImgCmd(pdevobj, Width, Height, WidthByte, 0, (WORD)((InvLeft + 7) / 8), (WORD)((InvRight + 7) / 8), lpBit);
        }
    }

    if (Comp == No) {                                        // Not compress
        pam[2] = 0;
        pam[3] = Frame;
        pam[4] = DataBit;
        pam[5] = HIWORD(XPos);
        pam[6] = LOWORD(XPos);
        pam[7] = HIWORD(YPos);
        pam[8] = LOWORD(YPos);
        pam[10] = Height;
        if (InvLeft == 0 && InvRight == 0) {                 // Not include invalid size
            pam[0] = 0;                                      // Data byte size (high byte)
            pam[1] = WidthByte * Height;                     // Data byte size (low byte)
            pam[9] = Width;
            siz = CmdStore(CmdBuf, &OrgImgCmy, pam);
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
            WRITESPOOLBUF(pdevobj, lpBit, pam[1]);
        } else {                                             // Include invalid size
            widByt = (WORD)((widBit + 7) / 8);
            pam[0] = 0;                                      // Data byte size (high byte)
            pam[1] = widByt * Height;                        // Data byte size (low byte)
            pam[9] = (WORD)(widBit / DataBit);
            siz = CmdStore(CmdBuf, &OrgImgCmy, pam);
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
            for (linCnt = 0; linCnt < Height; linCnt++) {    // Spool bitmap data by 1 line
                WRITESPOOLBUF(pdevobj, lpBit + (WORD)(InvLeft / 8), widByt);
                lpBit += WidthByte;
            }
        }
    }
    return;
}


//===================================================================================================
//    Copy command buffer
//===================================================================================================
WORD CmdCopy(
    LPBYTE         lpDst,
    LPCMDDEF       lpCmdInf
)
{
    WORD           siz;
    LPBYTE         lpCmd;

    lpCmd = lpCmdInf->Cmd;
    for (siz = 0; siz < lpCmdInf->Size; siz++) {
        lpDst[siz] = lpCmd[siz];
    }
    return siz;
}


//===================================================================================================
//    Copy command data
//===================================================================================================
WORD CmdStore(
    LPBYTE         lpDst,
    LPCMDDEF       CmdInf,
    LPINT          lpPam
)
{
    LPBYTE         lpCmd;
    BYTE           cmdDat;
    WORD           cmdCnt;
    WORD           setCnt;
    WORD           pamCnt;
    WORD           upmDat;
    int            pamDat;
    DWORD          dDat;
    LONG           lDat;

    setCnt = 0;
    pamCnt = 0;
    lpCmd = CmdInf->Cmd;
    for (cmdCnt = 0; cmdCnt < CmdInf->Size; cmdCnt++) {     // Copy
        cmdDat = *lpCmd++;
        if (cmdDat != '%') {
            lpDst[setCnt++] = cmdDat;
        } else {
            cmdCnt++;
            switch (cmdDat = *lpCmd++) {                    // Type
                case 'u':
                    setCnt += USINTtoASC(&lpDst[setCnt], (WORD)lpPam[pamCnt++]);
                    break;
                case 'd':
                    setCnt += INTtoASC(&lpDst[setCnt], lpPam[pamCnt++]);
                    break;
#if 0   /* 441435: Currently Not used */
                case 'y':
                    upmDat = (WORD)lpPam[pamCnt++];

                    if (upmDat == 0 || (upmDat / 100) != 0) {

                        setCnt += USINTtoASC(&lpDst[setCnt], (WORD)(upmDat / 100));
                    }
                    if ((upmDat % 100) != 0) {
                        lpDst[setCnt++] = '.';

                        setCnt += USINTtoASC(&lpDst[setCnt], (WORD)(upmDat % 100));
                    }
                    break;
                case 'z':
                    pamDat = lpPam[pamCnt++];

                    if (upmDat == 0 || (upmDat / 100) != 0) {

                        setCnt += INTtoASC(&lpDst[setCnt], (pamDat / 100));
                    }
                    if ((pamDat % 100) != 0) {
                        lpDst[setCnt++] = '.';
                        if (pamDat < 0) {
                            pamDat = 0 - pamDat;
                        }

                        setCnt += USINTtoASC(&lpDst[setCnt], (WORD)(pamDat % 100));
                    }
                    break;
#endif   /* 441435: Currently Not used */
                case 'w':
                    dDat = MAKELONG(lpPam[pamCnt + 1], lpPam[pamCnt]);
                    setCnt += USLONGtoASC(&lpDst[setCnt], dDat);
                    pamCnt += 2;
                    break;
                case 'l':
                    lDat = MAKELONG(lpPam[pamCnt + 1], lpPam[pamCnt]);
                    setCnt += LONGtoASC(&lpDst[setCnt], lDat);
                    pamCnt += 2;
                    break;
#if 0   /* 441435: Currently Not used */
                case 'b':
                    lpDst[setCnt++] = (BYTE)lpPam[pamCnt++];
                    break;
#endif   /* 441435: Currently Not used */
                case '%':
                    lpDst[setCnt++] = cmdDat;
                    break;
            }
        }
    }
    return setCnt;
}


//===================================================================================================
//    int -> ascii
//===================================================================================================
WORD INTtoASC(
    LPBYTE         lpDst,
    int            Dat                                      // Conversion data
)
{
    WORD           setCnt;
    WORD           divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    if (Dat < 0) {
        lpDst[setCnt++] = '-';
        Dat = 0 - Dat;
    }
    setVal = No;
    for (divDat = 10000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= (int)divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}


//===================================================================================================
//    usint -> ascii
//===================================================================================================
WORD USINTtoASC(
    LPBYTE         lpDst,
    WORD           Dat
)
{
    WORD           setCnt;
    WORD           divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    setVal = No;
    for (divDat = 10000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}


//===================================================================================================
//    long -> ascii
//===================================================================================================
WORD LONGtoASC(
    LPBYTE         lpDst,
    LONG           Dat
)
{
    WORD           setCnt;
    DWORD          divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    if (Dat < 0) {
        lpDst[setCnt++] = '-';
        Dat = 0 - Dat;
    }
    setVal = No;
    for (divDat = 1000000000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= (LONG)divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}


//===================================================================================================
//    uslong -> ascii
//===================================================================================================
WORD USLONGtoASC(
    LPBYTE         lpDst,
    DWORD          Dat
)
{
    WORD           setCnt;
    DWORD          divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    setVal = No;
    for (divDat = 1000000000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}



// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\n4diz.h ===
//***************************************************************************************************
//    N4DIZ.H
//
//    C Header (Functions of dither and color matching (For N4 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************

//***************************************************************************************************
//    data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Color or Monochrome
//---------------------------------------------------------------------------------------------------
#define    N4_COL                0
#define    N4_MON                1

//---------------------------------------------------------------------------------------------------
//    Dithering
//---------------------------------------------------------------------------------------------------
#define    N4_DIZ_SML            0
#define    N4_DIZ_MID            1
#define    N4_DIZ_RUG            2
#define    N4_DIZ_GOS            3

//---------------------------------------------------------------------------------------------------
//    Dither pattern
//---------------------------------------------------------------------------------------------------
#define    N4_ALLDIZNUM        64
#define    N4_DIZSPC            4

//---------------------------------------------------------------------------------------------------
//    Size of each table
//---------------------------------------------------------------------------------------------------
#define    N4_DIZSIZ_CM        (17 * 17)                    // Dither table size(CM)
#define    N4_DIZSIZ_YK        (16 * 16)                    // Dither table size(YK)
#define    N4_TNRTBLSIZ        256                          // Toner density 
#define    N4_GLDNUM            32                          // LUT table grid
#define    N4_GLDSPC            8                           // LUT table grid interval
                                                            // LUT table size
#define    N4_LUTTBLSIZ        ((DWORD)N4_GLDNUM * N4_GLDNUM * N4_GLDNUM * sizeof(CMYK))
#define    N4_CCHNUM            256                         // Number of Table
#define    N4_CCHRGBSIZ        (N4_CCHNUM * sizeof(RGBS))   // Table size(RGB)
#define    N4_CCHCMYSIZ        (N4_CCHNUM * sizeof(CMYK))   // Table size(CMYK)

//---------------------------------------------------------------------------------------------------
//    Structure for control dithering and color-matching
//---------------------------------------------------------------------------------------------------
typedef SHORT *LPSHORT;
typedef    struct {
    DWORD        ColMon;                                    // Color/Monochrome
    struct {                                                // Structure for dither pattern
        DWORD        Num;                                   // Table current number(0-2)
        LPBYTE       Tbl[3][4];                             // Data table
    } Diz;
    struct {                                                // Structure for toner density
        LPBYTE       Tbl;                                   // Data table
    } Tnr;
    struct {                                                // Structure for LUT table
        LPCMYK       Tbl;                                   // Data table
        LPRGB        CchRgb;                                // Cache table(RGB)
        LPCMYK       CchCmy;                                // Cache table(CMYK)
    } Lut;
    struct {                                                // Structure for GOSA-Dispersion(RGB) table
        DWORD        Num;                                   // Table current number(0-1)
        DWORD        Siz;                                   // Data table size
        DWORD        Yax;                                   // Y coordinates
        LPSHORT      Tbl[2];                                // Data table
    } GosRGB;
    struct {                                                // Structure for GOSA-Dispersion(CMYK) table
        DWORD        Num;                                   // Table current number(0-1)
        DWORD        Siz;                                   // Data table size
        DWORD        Yax;                                   // Y coordinates
        LPSHORT      Tbl[2];                                // Data table
    } GosCMYK;
} N4DIZINF, *LPN4DIZINF;


//***************************************************************************************************
//    Functions
//***************************************************************************************************
VOID WINAPI N4DizPtnMak(LPN4DIZINF, DWORD, DWORD);
VOID WINAPI N4DizPtnPrn(LPN4DIZINF, DWORD, DWORD, DWORD, LPBYTE);
VOID WINAPI N4TnrTblMak(LPN4DIZINF, LONG);
DWORD WINAPI N4Diz001(LPN4DIZINF, DWORD, DWORD, DWORD, LPBYTE, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N4Diz00n(LPN4DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPBYTE, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N4Gos001(LPN4DIZINF, DWORD, DWORD, DWORD, LPBYTE, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
DWORD WINAPI N4Gos00n(LPN4DIZINF, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, LPBYTE, LPBYTE, LPBYTE, LPBYTE, LPBYTE);
VOID WINAPI N4RgbGos(LPN4DIZINF, DWORD, DWORD, DWORD, LPBYTE);
VOID WINAPI N4ColMch000(LPN4DIZINF, LPRGB, LPCMYK, DWORD, DWORD);
VOID WINAPI N4ColMch001(LPN4DIZINF, LPRGB, LPCMYK, DWORD, DWORD);
VOID WINAPI N4ColCnvSld(LPN4DIZINF, LPRGB, LPCMYK, DWORD);
VOID WINAPI N4ColCnvLin(LPN4DIZINF, LPRGB, LPCMYK, DWORD);
VOID WINAPI N4ColCnvMon(LPN4DIZINF, DWORD, LPRGB, LPCMYK, DWORD);
VOID WINAPI N4ColCtr(LPN4DIZINF, LONG, LONG, LONG, LONG, LONG, DWORD, LPRGB);


//    End of N4DIZ.H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
    "DrvGetGPDData",
    "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
    "ImageProcessing",
    "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};


// End of File

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\casio\$(ALT_PROJECT)
SRCDIR=..
N4SRCDIR=..\..\casn4res

TARGETNAME=csn46res
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),csn46res
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\csn46res.rc \
    $(SRCDIR)\csn46res.c \
    $(SRCDIR)\colmatch.c \
    $(SRCDIR)\common.c \
    $(SRCDIR)\n403diz.c \
    $(SRCDIR)\n4diz.c \
    $(SRCDIR)\prnctl.c

MISCFILES=\
    $(SRCDIR)\csn46res.ini \
    $(SRCDIR)\lut\cpn4rgbx.lut \
    $(SRCDIR)\lut\cpn4rgby.lut \
    $(N4SRCDIR)\icm\csn4001.icm \
    $(N4SRCDIR)\icm\csn4002.icm \
    $(N4SRCDIR)\icm\csn4003.icm \
    $(GPDDIR)\csn46j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn46res\prnctl.h ===
//***************************************************************************************************
//    PRNCTL.H
//
//    C Header(Functions of controlling printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-1999 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************

//***************************************************************************************************
//    Data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Plane
//---------------------------------------------------------------------------------------------------
#define    PLN_CYAN        0x8000
#define    PLN_MGENTA      0x4000
#define    PLN_YELLOW      0x2000
#define    PLN_BLACK       0x1000

#define    PLN_ALL            (PLN_CYAN | PLN_MGENTA | PLN_YELLOW | PLN_BLACK)

//---------------------------------------------------------------------------------------------------
//    Structure of spooling bitmap data
//---------------------------------------------------------------------------------------------------
typedef struct {
    WORD        Style;                                      // Type of spool
    WORD        Plane;                                      // Plane
    CMYK        Color;                                      // CMYK
    WORD        Diz;                                        // Type of dithering
    POINT       DrawPos;                                    // Start position of spooling
    WORD        Width;                                      // dot
    WORD        Height;                                     // dot
    WORD        WidthByte;                                  // byte
    LPBYTE      lpBit;                                      // bitamp data
} DRWBMP, FAR *LPDRWBMP;

//---------------------------------------------------------------------------------------------------
//    Structure of spooling CMYK bitmap data
//---------------------------------------------------------------------------------------------------
typedef struct {
    WORD        Style;                                      // Type of spool
    WORD        Plane;                                      // Plane
    WORD        Frame;                                      // Frame
    WORD        DataBit;                                    // Databit
    POINT       DrawPos;                                    // Start position of spool
    WORD        Width;                                      // dot
    WORD        Height;                                     // dot
    WORD        WidthByte;                                  // byte
    LPBYTE      lpBit;                                      // Bitmap data
} DRWBMPCMYK, FAR *LPDRWBMPCMYK;


//***************************************************************************************************
//     Functions
//***************************************************************************************************
//===================================================================================================
//    Spool bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmap(PDEVOBJ, LPDRWBMP);

//===================================================================================================
//    Spool CMYK bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmapCMYK(PDEVOBJ, LPDRWBMPCMYK);

// End of File

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\coldef.h ===
//***************************************************************************************************
//    COLDEF.H
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Structure for RGB Color
//---------------------------------------------------------------------------------------------------
typedef struct {
    BYTE        Blu;                                        // Density 0 to 255
    BYTE        Grn;                                        // 
    BYTE        Red;                                        // 
} RGBS, *LPRGB;

//---------------------------------------------------------------------------------------------------
//    Structure for CMYK Color
//---------------------------------------------------------------------------------------------------
typedef struct {
    BYTE        Cyn;                                        // Density 0 tot 255
    BYTE        Mgt;                                        // 
    BYTE        Yel;                                        // 
    BYTE        Bla;                                        // 
} CMYK, *LPCMYK;

//---------------------------------------------------------------------------------------------------
//    Color number
//---------------------------------------------------------------------------------------------------
#define    BLACK           0
#define    YELLOW          1
#define    MGENTA          2
#define    CYAN            3

//---------------------------------------------------------------------------------------------------
//    Magnification
//---------------------------------------------------------------------------------------------------
typedef struct {
    UINT    Nrt;                                            // Numerator
    UINT    Dnt;                                            // Denominator
} MAG, FAR *LPMAG;

// End of COLDEF.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\colmatch.h ===
//***************************************************************************************************
//    COLMATCH.H
//
//    Functions of color matching(C Header)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Include Header file
//---------------------------------------------------------------------------------------------------
#include "COLDEF.H"
#include "COMDIZ.H"
#include "N501DIZ.H"

//---------------------------------------------------------------------------------------------------
//    Printer name
//---------------------------------------------------------------------------------------------------
#define PRN_N5      0

//---------------------------------------------------------------------------------------------------
//    Color Matching DLL name
//---------------------------------------------------------------------------------------------------
#define N501_ColCchIni          N501ColCchIni
#define N501_ColMchPrc          N501ColMchPrc
#define N501_ColCnvC2r          N501ColCnvC2r
#define N501_ColDizInfSet       N501ColDizInfSet
#define N501_ColDizPrc          N501ColDizPrc
#define	N501_ColLutMakGlbMon	N501ColLutMakGlbMon
#define N501_ColUcrTblMak       N501ColUcrTblMak
#define N501_ColPtcPrc          N501ColPtcPrc
#define N501_ColCtrRgb          N501ColCtrRgb
#define N501_ColCtrCmy          N501ColCtrCmy
#define N501_ColLutDatRdd       N501ColLutDatRdd
#define N501_ColLutMakGlb       N501ColLutMakGlb
#define N501_ColLutMak032       N501ColLutMak032
#define N501_ColColDatRdd       N501ColColDatRdd
#define N501_ColDrwInfSet       N501ColDrwInfSet
#define	N501_ColGryTblMak		N501ColGryTblMak
#define N501_ExeJpgDcdJdg       ExeJpgDcdJdg
#define N501_ExeJpgEcd          ExeJpgEcd
#define	Qty_BmpFilWrkSizGet		BmpFilWrkSizGet
#define	Qty_BmpFilterExe		BmpFilterExe
#define	Qty_BmpEnlWrkSizGet		BmpEnlWrkSizGet
#define	Qty_BmpEnlExe			BmpEnlExe

//---------------------------------------------------------------------------------------------------
//    Data define
//---------------------------------------------------------------------------------------------------
#define No          0
#define Yes         1

#define XX_RES_300DPI            0
#define XX_RES_600DPI            1

#define XX_MONO                  0
#define XX_COLOR                 1
#define XX_COLOR_SINGLE          2
#define XX_COLOR_MANY            3
#define XX_COLOR_MANY2           4

#define XX_DITH_IMG              0
#define XX_DITH_GRP              1
#define XX_DITH_TXT              2
#define XX_DITH_GOSA             3
#define XX_DITH_NORMAL           4
#define XX_DITH_HS_NORMAL        5
#define XX_DITH_DETAIL           6
#define XX_DITH_EMPTY            7
#define XX_DITH_SPREAD           8
#define XX_DITH_NON              9
#define XX_MAXDITH              10

#define XX_COLORMATCH_BRI        1
#define XX_COLORMATCH_TINT       2
#define XX_COLORMATCH_VIV        3
#define XX_COLORMATCH_NONE       4

#define XX_BITFONT_OFF           0
#define XX_BITFONT_ON            1

#define XX_CMYBLACK_GRYBLK       0
#define XX_CMYBLACK_BLKTYPE1     1
#define XX_CMYBLACK_BLKTYPE2     2
#define XX_CMYBLACK_BLACK        3
#define XX_CMYBLACK_TYPE1        4
#define XX_CMYBLACK_TYPE2        5
#define XX_CMYBLACK_NONE         6

#define XX_COMPRESS_OFF          0
#define XX_COMPRESS_AUTO         1
#define XX_COMPRESS_RASTER       3

#define XX_TONE_2                0
#define XX_TONE_4                1
#define XX_TONE_16               2

#define XX_ICM_NON               1
#define XX_ICM_USE               2

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PALETTE_SIZE    1

#define BYTE_LENGTH(s) (sizeof (s) - 1)

#define MagPixel(Dat, Nrt, Dnt)     ((((Dat) + 1) * (Nrt) / (Dnt)) - ((Dat) * (Nrt) / (Dnt)))

typedef char                            FAR *HPSTR;
typedef BYTE                            FAR *HPBYTE;

//===================================================================================================
//    Dither pattern buffer
//===================================================================================================
typedef struct {
    LPBYTE  lpC;                                // Cyan
    LPBYTE  lpM;                                // Magenta
    LPBYTE  lpY;                                // Yellow
    LPBYTE  lpK;                                // Black
} DIZBUF, FAR *LPDIZBUF;

//===================================================================================================
//    Read buffer size
//===================================================================================================
#define LUTFILESIZ      70L * 1024L             // N501 Buffer size for LUT file read
#define DIZFILESIZ      408L * 1024L            // N501 Buffer size for DIZ file read
#define LUT032SIZ       128L * 1024L            // N501 Buffer size for LUT32GRID
#define UCRTBLSIZ       2048L                   // N501 Buffer size for UCR table
#define UCRWRKSIZ       32768                   // N501 Buffer size for UCR table work
#define sRGBLUTFILESIZ  16L * 1024L             // N501 Buffer size for LUT file read (sRGB)
#define LUTMAKGLBSIZ    16L * 1024L             // N501 Buffer size for LUTMAKGLB
#define GRYTBLSIZ       256L                    // N501 Buffer size for Gray transfer table

//===================================================================================================
//    Color matching structure
//===================================================================================================
typedef struct {
    WORD    wReso;                              // Resolution
    WORD    ColMon;                             // Color/Monochrome
    WORD    DatBit;                             // Data bit(1:2value 2:4value 4:16value)
    WORD    BytDot;                             // DPI (2value:8 4value:4 16value:2)
    struct {                                    // Strcture for color matching
        WORD        Mode;                       // Type of color matching
        WORD        GryKToner;                  //+N5 Gray color use black toner ?
        WORD        Viv;                        // Vividly?(For N4-612Printer)
        WORD        LutNum;                     // LUT table No.
        WORD        Diz;                        // Type od dithering
        SHORT       Tnr;                        // Toner density(-30 to 30)
        WORD        CmyBlk;                     // Replace CMY by black toner ?
        WORD        Speed;                      // 0:high 1:normal
        WORD        Gos32;                      // GOSA?
        WORD        PColor;                     // Original color?
        WORD        Ucr;                        //+N5 Ucr
        WORD        SubDef;                     // Bright, contrast and gamma ?
        SHORT       Bright;                     // bright
        SHORT       Contrast;                   // contrast
        WORD        GamRed;                     // Color balance(R)
        WORD        GamGreen;                   // Color balance(G)
        WORD        GamBlue;                    // Color balance(B)
        LPRGBINF    lpRGBInf;                   //+N5 RGB transformation information
        LPCMYKINF   lpCMYKInf;                  //+N5 CMYK  transformation information
        LPCOLMCHINF lpColMch;                   //+N5 Color matching information
        LPDIZINF    lpDizInf;                   //+N5 Dithering pattern information
        UINT        CchMch;                     // Cache information for Color Matching
        UINT        CchCnv;                     // Cache information for use black toner
        RGBS        CchRGB;                     // Cache information for input RGB
        CMYK        CchCMYK;                    // Cache information for output CMYK
		WORD		LutMakGlb;					//+N5 Global LUT make ?
        WORD        KToner;                     // Black toner usage
    } Mch;
    UINT        InfSet;                         //+N5  Color information setting completion
    WORD        Dot;                            //+N5  Dot tone (TONE2, TONE4, TONE16)
    LPVOID      lpColIF;                        //+N5  RGBINF / CMYKINF / COLMCHINF / DIZINF pointer
    LPVOID      LutTbl;                         //+N5  Look-up table
    LPVOID      CchRGB;                         //+N5  Cache table for RGB
    LPVOID      CchCMYK;                        //+N5  Cache table for CMYK
    LPVOID      DizTbl[4];                      //+N5  Dither pattern table
    LPRGB       lpTmpRGB;                       //+N5  RGB convert area (*Temp area)
    LPCMYK      lpTmpCMYK;                      //+N5  CMYK convert area (*Temp area)
    LPDRWINF    lpDrwInf;                       //+N5  Draw information (*Temp area)
    LPBYTE      lpLut032;                       //+N5  LUT32GRID
    LPBYTE      lpUcr;                          //+N5  Ucr table
    LPBYTE      lpLutMakGlb;                    //+N5  LUTMAKGLB
    LPBYTE      lpGryTbl;                       //+N5  Gray transfer table 
} DEVCOL, FAR *LPDEVCOL;

//===================================================================================================
//    Bitmap buffer structure
//===================================================================================================
typedef struct {
    WORD    Diz;                                // Method of dithering
    WORD    Style;                              // Method of spooling
    WORD    DatBit;                             // Databit(1:2value 2:4value 4:16value)
    struct {
        struct {                                // Member of RGB buffer(for 1 line)
            WORD      AllWhite;                 // All data is white?
            DWORD     Siz;                      // Size
            LPRGB     Pnt;                      // Pointer
        } Rgb;
        struct {                                // Member of CMYK buffer(for 1 line)
            DWORD     Siz;                      // Size
            LPCMYK    Pnt;                      // Poiner
        } Cmyk;
        struct {                                // Member of CMYK(2/4/16value)bitmap buffer(maximum 64KB)
            DWORD     Siz;                      // Size
            WORD      BseLin;                   // The number of lines that require
            WORD      Lin;                      // The number of lines that allocate
            LPBYTE    Pnt[4];                   // Pointer
        } Bit;
    } Drv;
} BMPBIF, FAR* LPBMPBIF;

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Initialize the members of color-matching
//===================================================================================================
BOOL FAR PASCAL ColMatchInit(PDEVOBJ);

//===================================================================================================
//    Disable the color-matching
//===================================================================================================
BOOL FAR PASCAL ColMatchDisable(PDEVOBJ);

//===================================================================================================
//    DIB spools to the printer
//===================================================================================================
BOOL FAR PASCAL DIBtoPrn(PDEVOBJ, PBYTE, PBITMAPINFOHEADER, PBYTE, PIPPARAMS);

//===================================================================================================
//    Convert RGB data into CMYK data
//===================================================================================================
BOOL FAR PASCAL ColMatching(PDEVOBJ, UINT, UINT, LPRGB, UINT, LPCMYK);

//===================================================================================================
//    Convert CMYK data into Dither data
//===================================================================================================
UINT FAR PASCAL Dithering(PDEVOBJ, UINT, UINT, POINT, POINT, MAG, MAG, LPCMYK, DWORD, 
                          LPBYTE, LPBYTE, LPBYTE, LPBYTE);
//===================================================================================================
//    Color Control
//===================================================================================================
VOID FAR PASCAL ColControl(PDEVOBJ, LPRGB, UINT);


// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\comdiz.h ===
//***************************************************************************************************
//    COMDIZ.H
//
//    C Header (Functions of dither and color matching (For N5-XX1 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//***************************************************************************************************
//    Data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    DLL file name
//---------------------------------------------------------------------------------------------------
#if defined(CASIO)
#if defined(COLPRINTER)
    #define N403_DIZDLL     TEXT("CPN4DT32.DLL")
#else
    #define N403_DIZDLL     TEXT("CP70DT32.DLL")
#endif
#else
#if defined(MINOLTA)
    #define N403_DIZDLL     TEXT("MWXDT32.DLL")
#endif
#endif

#define N501_DIZDLL         TEXT("CPN5DT32.DLL")
#define E800_DIZDLL         TEXT("CP80DT32.DLL")

//---------------------------------------------------------------------------------------------------
//    Error code (N501 Only)
//---------------------------------------------------------------------------------------------------
#define ERRNON              0                               // Normal completion
#define ERRILLPRM           1                               // Invalid paramater
#define ERRDIZHED           2                               // Dither  Invalid Header
#define ERRDIZNON           3                               // Dither  Not found
#define ERRDIZSLS           4                               // Dither  Invalid Threshold sizes
#define ERRDIZSIZ           5                               // Dither  Invalid X/Y size
#define ERRDIZADJ           6                               // Dither  Invalid Adjustment value

//---------------------------------------------------------------------------------------------------
//    Color / Mono mode
//---------------------------------------------------------------------------------------------------
#define CMMCOL              0                               // Color
#define CMMMON              1                               // Mono

//---------------------------------------------------------------------------------------------------
//    Engine kind
//---------------------------------------------------------------------------------------------------
#define ENG621              0                               // IX-621
#define ENG516              1                               // IX-516

//---------------------------------------------------------------------------------------------------
//    Printer mode  *1:N501 Only  *2:CP-E8000 Only
//---------------------------------------------------------------------------------------------------
#define PRM302              0                               // 300DPI     2value
#define PRM316              1                               // 300DPI    16value
#define PRM602              2                               // 600DPI     2value
#define PRM604              3                               // 600DPI     4value
#define PRM616              4                               // 600DPI    16value  *1
#define PRM122              5                               // 1200DPI    2value  *2

//---------------------------------------------------------------------------------------------------
//    Color matching mode
//---------------------------------------------------------------------------------------------------
#define MCHFST              0                               // LUT First
#define MCHNML              1                               // LUT Normal
#define MCHSLD              2                               // No (Solid)
#define MCHPRG              3                               // Primary color (progressive)
#define MCHMON              4                               // Monochrome

//---------------------------------------------------------------------------------------------------
//    Printer model (CP70 Only)
//---------------------------------------------------------------------------------------------------
#define CP7100_MON          0                               // Mono printer(CP-7100)
#define CP7200_MON          1                               // Mono printer(CP-7200)
#define CP7300_MON          2                               // Mono printer(CP-7300)
#define CP7400_MON          3                               // Mono printer(CP-7400)
#define CP7500_MON          4                               // Mono printer(CP-7500)

//---------------------------------------------------------------------------------------------------
//    Black Tonaer replacement mode
//---------------------------------------------------------------------------------------------------
#define KCGNON              0                               // No
#define KCGBLA              1                               // Black (RGB=0)
#define KCGGRY              2                               // Glay  (R=G=B)

//---------------------------------------------------------------------------------------------------
//    UCR mode
//---------------------------------------------------------------------------------------------------
#define UCRNOO              0                               // No
#define UCR001              1                               // UCR (TypeT)
#define UCR002              2                               // UCR (TypeU)

//---------------------------------------------------------------------------------------------------
//    LUT mode (N501 Only)
//---------------------------------------------------------------------------------------------------
#define LUT_XD              0                               // Brightness
#define LUT_YD              1                               // Tincture
#define LUT_XL              2                               // Brightness(linear)
#define LUT_YL              3                               // Tincture(linear)

//---------------------------------------------------------------------------------------------------
//    Dither mode (N501 Only)
//---------------------------------------------------------------------------------------------------
#define KNDCHR              0                               // Text / Graphic
#define KNDIMG              1                               // Image

//---------------------------------------------------------------------------------------------------
//    Dither Pattern
//---------------------------------------------------------------------------------------------------
#define DIZCHA              0                               // Text / Graphic        *
#define DIZSML              1                               // Small
#define DIZMID              2                               // middle
#define DIZRUG              3                               // Rough
#define DIZGOS              4                               // Error dispersion      *
#define DIZSTO              5                               // Random number

//---------------------------------------------------------------------------------------------------
//    Dither pattern Tone (N4/N403/CP70 Only)
//---------------------------------------------------------------------------------------------------
#define ALLDIZNUM           64                              // All dither nuber
#define DIZSPC              4                               // Dithering interval

//---------------------------------------------------------------------------------------------------
//    Necessary size of each table(Byte) (N4/N403/CP70 Only)
//---------------------------------------------------------------------------------------------------
// N403
#define DIZSIZ_B1           (34 * 34)                       // Dither table size(2value)
#define DIZSIZ_B2           (34 * 34 * 3)                   // Dither table size(4value)
#define DIZSIZ_B4           (12 * 12 * 15)                  // Dither table size(16value)
// N4
#define DIZSIZ_CM           (17 * 17)                       // Dither table size(CM)
#define DIZSIZ_YK           (16 * 16)                       // Dither table size(YK)
// CP70
#define DIZSIZ              (32 * 32)                       // Dither table size

//---------------------------------------------------------------------------------------------------
//    LUT table RBG -> CMYK (old version)
//---------------------------------------------------------------------------------------------------
// N4/N403/CP70
#define GLDNUM              32                              // Table grid number
#define GLDSPC              8                               // Table grid interval
#define LUTSIZ              ((DWORD)GLDNUM * GLDNUM * GLDNUM)// LUT size(*CMYK=128k)
#define LUTTBLSIZ           ((DWORD)LUTSIZ * sizeof(CMYK))
// N501
#define GLDNUM016           16                              // Table grid number
#define GLDNUM032           32                              // Table grid number
#define LUTSIZ016           GLDNUM016 * GLDNUM016 * GLDNUM016   // LUT size
#define LUTSIZ032           GLDNUM032 * GLDNUM032 * GLDNUM032   // LUT size
#define LUTSIZRGB           LUTSIZ016 * sizeof(RGBS)        // LUT size
#define LUTSIZCMY           LUTSIZ016 * sizeof(CMYK)        // LUT size

//---------------------------------------------------------------------------------------------------
//    Color transformation table (N4/N403/CP70 Only)
//---------------------------------------------------------------------------------------------------
#define TNRTBLSIZ           256                             // Toner density table size
#define CCHRGBSIZ           (CCHTBLSIZ * sizeof(RGBS))      // Cache table size(RGB)
#define CCHCMYSIZ           (CCHTBLSIZ * sizeof(CMYK))      // Cache table size(CMYK)

//---------------------------------------------------------------------------------------------------
//    Cashe table size
//---------------------------------------------------------------------------------------------------
#define CCHTBLSIZ           256                             // Cache table size

//---------------------------------------------------------------------------------------------------
//    Work area size (N501 Only)
//---------------------------------------------------------------------------------------------------
#define LUTGLBWRK           32768                           // Sum LUT work area size
#define LUT032WRK           32768                           // First LUT work area size
#define DIZINFWRK           32768                           // Dither work area size

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Color designated table structure (N501 Only)
//===================================================================================================
typedef struct {
    BYTE            Red;                                    // Red   (0 to 255)
    BYTE            Grn;                                    // Green (0 to 255)
    BYTE            Blu;                                    // Blue  (0 to 255)
    BYTE            Cyn;                                    // Cyan    (0 to 255)
    BYTE            Mgt;                                    // Magenta (0 to 255)
    BYTE            Yel;                                    // Yellow  (0 to 255)
    BYTE            Bla;                                    // Black   (0 to 255)
} COLCOLDEF, FAR* LPCOLCOLDEF;

//===================================================================================================
//    RGB Color Control structure
//===================================================================================================
typedef struct {
    LONG            Lgt;                                    // brightness   (-100 to 100)
    LONG            Con;                                    // Contrast     (-100 to 100)
    LONG            Crm;                                    // Chroma       (-100 to 100)
    LONG            Gmr;                                    // Gamma(R)     (1 to 30)
    LONG            Gmg;                                    // Gamma(G)     (1 to 30)
    LONG            Gmb;                                    // Gamma(B)     (1 to 30)
    LPBYTE          Dns;                                    // Toner density table [DNSTBLSIZ]
    LONG            DnsRgb;                                 // RGB density  (-30 to 30)
} RGBINF, FAR* LPRGBINF;

//===================================================================================================
//    CMYK Color Control structure
//===================================================================================================
typedef struct {
    LONG            Viv;                                    // Vivid        (-100 to 100)
    LPBYTE          Dns;                                    // Toner density table [DNSTBLSIZ]
    LONG            DnsCyn;                                 // Toner density(C) (-30 to 30)
    LONG            DnsMgt;                                 // Toner density(M) (-30 to 30)
    LONG            DnsYel;                                 // Toner density(Y) (-30 to 30)
    LONG            DnsBla;                                 // Toner density(K) (-30 to 30)
} CMYKINF, FAR* LPCMYKINF;

//===================================================================================================
//    Color Matching information structure  *N4/N403/CP70
//===================================================================================================
typedef struct {
    DWORD           Mch;                                    // Color Matching       def
    DWORD           Bla;                                    // Black replacement    def
    DWORD           Ucr;                                    // UCR                  def
    DWORD           UcrCmy;                                 // UCR (UCR quantity)
    DWORD           UcrBla;                                 // UCR (Ink version generation quantity)
    DWORD           UcrTnr;                                 //+UCR (Toner gross weight)   CASIO 2001/02/15
    LPCMYK          UcrTbl;                                 // UCR table
    LPBYTE          GryTbl;                                 // Gray transfer table
    DWORD           LutGld;                                 // LUT Grid number          *
    LPCMYK          LutAdr;                                 // LUT address
    DWORD           ColQty;                                 // Color designated number
    LPCOLCOLDEF     ColAdr;                                 // Color designated table
    LPRGB           CchRgb;                                 // RGB Cache table[CCHTBLSIZ]
    LPCMYK          CchCmy;                                 // CMYK Cache table[CCHTBLSIZ]
} COLMCHINF, FAR* LPCOLMCHINF;

//===================================================================================================
//    Dither pattern information structure  *1:N4/N403/CP70  *2:N501(IX-621)/CP-E8000(IX-516)
//===================================================================================================
#ifndef LPSHORT
typedef SHORT FAR*  LPSHORT;
#endif
typedef struct {
    DWORD           ColMon;                                 // Color mode           def
    DWORD           PrnMod;                                 // DPI / TONE           def
    DWORD           PrnEng;                                 // Engin kind           def  *2
    DWORD           PrnKnd;                                 // Printer(Mono only)        *1
    DWORD           DizKnd;                                 // Dither kind          def
    DWORD           DizPat;                                 // Dither pattern       def
    DWORD           DizSls;                                 // Dither pattern Threshold
    DWORD           SizCyn;                                 // Dither pattern size Cyan
    DWORD           SizMgt;                                 // Dither pattern size Magenta
    DWORD           SizYel;                                 // Dither pattern size Yellow
    DWORD           SizBla;                                 // Dither pattern size Black
    LPBYTE          TblCyn;                                 // Dither pattern table Cyan
    LPBYTE          TblMgt;                                 // Dither pattern table Magenta
    LPBYTE          TblYel;                                 // Dither pattern table Yellow
    LPBYTE          TblBla;                                 // Dither pattern table Black
} DIZINF, FAR* LPDIZINF;

//===================================================================================================
//    Drawing information structure
//===================================================================================================
typedef struct {
    DWORD           XaxSiz;                                 // X Pixel size
    DWORD           StrXax;                                 // Start position for drawing X(dot)
    DWORD           StrYax;                                 // Start position for drawing Y(dot)
    DWORD           XaxNrt;                                 // X Magnification numerator
    DWORD           XaxDnt;                                 // X Magnification denominator
    DWORD           YaxNrt;                                 // Y Magnification numerator
    DWORD           YaxDnt;                                 // Y Magnification denominator
    DWORD           XaxOfs;                                 // X Offset
    DWORD           YaxOfs;                                 // Y Offset
    DWORD           LinDot;                                 // Destination, 1 line dot number
    DWORD           LinByt;                                 // Destination, 1 line byte number
    LPCMYK          CmyBuf;                                 // CMYK data buffer
    LPBYTE          LinBufCyn;                              // Line buffer(C)
    LPBYTE          LinBufMgt;                              // Line buffer(M)
    LPBYTE          LinBufYel;                              // Line buffer(Y)
    LPBYTE          LinBufBla;                              // Line buffer(K)
    DWORD           AllLinNum;                              // Housing line number
} DRWINF, FAR* LPDRWINF;

//===================================================================================================
//    Error dispersion information structure
//===================================================================================================
typedef struct {
    struct {
        DWORD       Num;                                    // Current table array number(0 to 1)
        DWORD       Siz[2];                                 // Data table size
        DWORD       Yax[2];                                 // Setting data table Y coordinate
        LPSHORT     Tbl[2][2];                              // Data table
    } GosRGB;
    struct {                                                // Error dispersion table information(CMYK)
        DWORD       Num;                                    // Current table array number(0 to 1)
        DWORD       Siz[2];                                 // Data table size
        DWORD       Yax[2];                                 // Setting data table Y coordinate
        LPSHORT     Tbl[2][2];                              // Data table
    } GosCMYK;
} GOSINF, FAR* LPGOSINF;

// End of COMDIZ.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "PDEV.H"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\colmatch.c ===
//***************************************************************************************************
//    COLMATCH.C
//
//    Functions of color matching
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    "PDEV.H"
#include    "PRNCTL.H"


//---------------------------------------------------------------------------------------------------
//    Byte/Bit table
//---------------------------------------------------------------------------------------------------
static const BYTE BitTbl[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};

//---------------------------------------------------------------------------------------------------
//    Define LUT file name
//---------------------------------------------------------------------------------------------------
#define N501LUTR    L"CPN5RGB.LT3"                          // For N5-XX1 printer

//---------------------------------------------------------------------------------------------------
//    Define Dither file name
//---------------------------------------------------------------------------------------------------
#define N501DIZ     L"CPN5NML.DIZ"                          // For N5-XX1 printer

//---------------------------------------------------------------------------------------------------
//    Define DLL name
//---------------------------------------------------------------------------------------------------
#define CSN5RESDLL    L"CSN5RES.DLL"                        // For N5-XX1 printer

//---------------------------------------------------------------------------------------------------
//    Define data
//---------------------------------------------------------------------------------------------------
#define DPI300    300
#define DPI600    600

static BYTE ORG_MODE_IN[]     = "\x1Bz\xD0\x01";
static BYTE ORG_MODE_OUT[]    = "\x1Bz\x00\x01";
static BYTE PALETTE_SELECT[]  = "Cd,%d,%d*";
static BYTE PLANE_RESET[]     = "Da,0,0,0,0*";

#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

//***************************************************************************************************
//    Prototype declaration
//***************************************************************************************************
static BOOL BmpBufAlloc(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, WORD, WORD, LPBMPBIF);
static void BmpBufFree(LPBMPBIF);
static void BmpBufClear(LPBMPBIF);
static void BmpPrint(PDEVOBJ, LPBMPBIF, POINT, WORD, WORD, WORD);
static void BmpRGBCnv(LPRGB, LPBYTE, WORD, WORD, WORD, LPRGBQUAD);

static BOOL ColMchInfSet(PDEVOBJ);
static BOOL DizInfSet(PDEVOBJ);
static UINT GetDizPat(PDEVOBJ);
static BOOL DizFileOpen(PDEVOBJ, LPDIZINF);
static BOOL ColUcrTblMak(PDEVOBJ, LPCMYK);
static BOOL ColGryTblMak(PDEVOBJ, LPCMYK);
static BOOL ColLutMakGlbMon(PDEVOBJ);

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Initialize the members of color-matching
//===================================================================================================
BOOL FAR PASCAL ColMatchInit(
    PDEVOBJ        pdevobj                                  // Pointer to PDEVOBJ structure
)
{
    LPBYTE          lpColIF;                                // N5 Color Matching information
    LPRGBINF        lpRGBInfImg;                            // RGB Color change information
    LPCMYKINF       lpCMYKInfImg;                           // CMYK Color information
    UINT            num001;
    SHORT           KToner;
    DWORD           allocSize;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("ColMatchInit() Start *****\n"));

    pOEM->Col.Mch.Mode       = pOEM->iColorMatching;
    pOEM->Col.Mch.Diz        = pOEM->iDithering;
    pOEM->Col.Mch.Bright     = 0;                           // 0 fixed
    pOEM->Col.Mch.Contrast   = 0;                           // 0 fixed
    pOEM->Col.Mch.GamRed     = 10;                          // Color balance(R) : 10 fixed
    pOEM->Col.Mch.GamGreen   = 10;                          // Color balance(G) : 10 fixed
    pOEM->Col.Mch.GamBlue    = 10;                          // Color balance(B) : 10 fixed
    pOEM->Col.Mch.Speed      = pOEM->iBitFont;
    pOEM->Col.Mch.LutNum     = 0;                           // LUT table number

    MY_VERBOSE(("CMINit ENT Tn=%d Col=%d Mod=%d DZ=%d Cyk=%d Sp=%d Prt=%d\n", pOEM->iTone, pOEM->iColor, 
         pOEM->Col.Mch.Mode,pOEM->Col.Mch.Diz,pOEM->Col.Mch.CmyBlk,pOEM->Col.Mch.Speed,pOEM->Printer));

    if (pOEM->Printer == PRN_N5) {                          // N5 printer
        if ((lpColIF = MemAllocZ(                           // RGB Color change/Color Matching/Dither pattern Information
            (DWORD)((sizeof(RGBINF) + sizeof(CMYKINF) + sizeof(COLMCHINF) + sizeof(DIZINF))))) == NULL) {
            ERR(("Init Alloc ERROR!!\n"));
            return 0;
        }
        pOEM->Col.lpColIF = lpColIF;                        // RGB Color change/Color Matching/Dither pattern Information
        pOEM->Col.Mch.lpRGBInf  = (LPRGBINF)lpColIF;    lpColIF += sizeof(RGBINF);
        pOEM->Col.Mch.lpCMYKInf = (LPCMYKINF)lpColIF;   lpColIF += sizeof(CMYKINF);
        pOEM->Col.Mch.lpColMch  = (LPCOLMCHINF)lpColIF; lpColIF += sizeof(COLMCHINF);
        pOEM->Col.Mch.lpDizInf  = (LPDIZINF)lpColIF;    lpColIF += sizeof(DIZINF);
        MY_VERBOSE(("ColMatchInit() MemAllocZ(lpColIF)\n"));

        pOEM->Col.wReso = (pOEM->iResolution == XX_RES_300DPI) ? DPI300 : DPI600;
        MY_VERBOSE(("ColMatchInit() pOEM->Col.wReso[%d] \n", pOEM->Col.wReso));

        if (pOEM->iColor == XX_COLOR_SINGLE 
         || pOEM->iColor == XX_COLOR_MANY
         || pOEM->iColor == XX_COLOR_MANY2) {               // Color?
            pOEM->Col.ColMon = CMMCOL;                      // Color
        } else {
            pOEM->Col.ColMon = CMMMON;                      // Monochrome
        }
        MY_VERBOSE(("ColMatchInit() pOEM->Col.ColMon[%d] \n", pOEM->Col.ColMon));

        if (pOEM->Col.ColMon == CMMCOL) {                   // Color?
            if (pOEM->Col.wReso == DPI300) {                // 300DPI?
                if (pOEM->iColor == XX_COLOR_SINGLE) {
                    pOEM->Col.Dot = XX_TONE_2;
                } else {
                    pOEM->Col.Dot = XX_TONE_16;
                }
            } else {                                        // 600DPI?
                if (pOEM->iColor == XX_COLOR_SINGLE) {
                    pOEM->Col.Dot = XX_TONE_2;
                } else if (pOEM->iColor == XX_COLOR_MANY) {
                    pOEM->Col.Dot = XX_TONE_4;
                } else {
                    pOEM->Col.Dot = XX_TONE_16;
                }
            }
            MY_VERBOSE(("ColMatchInit() Col.Dot[%d] \n", pOEM->Col.Dot));

            if (pOEM->Col.wReso == DPI300) {                // 300DPI?
                if (pOEM->Col.Dot == XX_TONE_2) {           // 2value?
                    CM_VERBOSE(("N5_MOD_300_TONE_2\n"));
                    pOEM->Col.DatBit = 1; pOEM->Col.BytDot = 8;
                } else {                                    // 16value
                    CM_VERBOSE(("N5_MOD_300_TONE_16\n"));
                    pOEM->Col.DatBit = 4; pOEM->Col.BytDot = 2;
                }
            } else {                                        // 600DPI
                if (pOEM->Col.Dot == XX_TONE_2) {           // 2value?
                    CM_VERBOSE(("N5_MOD_600_TONE_2\n"));
                    pOEM->Col.DatBit = 1; pOEM->Col.BytDot = 8;
                } else if (pOEM->Col.Dot == XX_TONE_4) {    // 4value?
                    CM_VERBOSE(("N5_MOD_600_TONE_4\n"));
                    pOEM->Col.DatBit = 2; pOEM->Col.BytDot = 4;
                } else {                                    // 16value?
                    CM_VERBOSE(("N5_MOD_600_TONE_16\n"));
                    pOEM->Col.DatBit = 4; pOEM->Col.BytDot = 2;
                }
            }
        }
        MY_VERBOSE(("ColMatchInit() DatBit[%d] BytDot[%d]\n", pOEM->Col.DatBit, pOEM->Col.BytDot));
                                                            // Color Matching setting
        pOEM->Col.Mch.CmyBlk = Yes;                         // Black replacement
        pOEM->Col.Mch.GryKToner = No;                       // Gray black toner print
        pOEM->Col.Mch.Ucr = UCRNOO;                         // UCR No
        pOEM->Col.Mch.KToner = pOEM->iCmyBlack;             // Black toner usage

        switch (pOEM->iCmyBlack) {
            case XX_CMYBLACK_GRYBLK:
                pOEM->Col.Mch.CmyBlk = Yes;
                pOEM->Col.Mch.GryKToner = Yes;
                pOEM->Col.Mch.Ucr = UCR001;                 //+CASIO 2001/02/15
                break;
            case XX_CMYBLACK_BLKTYPE1:
                pOEM->Col.Mch.Ucr = UCR001;
                pOEM->Col.Mch.CmyBlk = Yes;
                pOEM->Col.Mch.GryKToner = No;
                break;
            case XX_CMYBLACK_BLKTYPE2:
                pOEM->Col.Mch.Ucr = UCR002;
                pOEM->Col.Mch.CmyBlk = Yes;
                pOEM->Col.Mch.GryKToner = No;
                break;
            case XX_CMYBLACK_BLACK:
                pOEM->Col.Mch.CmyBlk = Yes;
                pOEM->Col.Mch.GryKToner = No;
                break;
            case XX_CMYBLACK_TYPE1:
                pOEM->Col.Mch.Ucr = UCR001;
                pOEM->Col.Mch.CmyBlk = No;
                break;
            case XX_CMYBLACK_TYPE2:
                pOEM->Col.Mch.Ucr = UCR002;
                pOEM->Col.Mch.CmyBlk = No;
                break;
            case XX_CMYBLACK_NONE:
                pOEM->Col.Mch.CmyBlk = No;
                break;
            default:
                break;
        }
        MY_VERBOSE(("ColMatchInit() Mch.CmyBlk[%d] Mch.KToner[%d] Mch.Ucr[%d] \n", 
                 pOEM->Col.Mch.CmyBlk, pOEM->Col.Mch.KToner, pOEM->Col.Mch.Ucr));

        pOEM->Col.Mch.PColor = No;                          // Primary color processing ?
        pOEM->Col.Mch.Tnr = 0;                              // Depth of color(Tonor)
        pOEM->Col.Mch.SubDef = Yes;                         // Not change setting of color balance, bright and contrast ?
        pOEM->Col.Mch.LutMakGlb = No;                       // Global LUT make ?

        pOEM->Col.Mch.CchMch = (UINT)-1;                    // Cache initialize
        pOEM->Col.Mch.CchCnv = (UINT)-1;
        pOEM->Col.Mch.CchRGB.Red = 255;
        pOEM->Col.Mch.CchRGB.Grn = 255;
        pOEM->Col.Mch.CchRGB.Blu = 255;

        lpRGBInfImg = pOEM->Col.Mch.lpRGBInf;               // RGB Color change information
        lpRGBInfImg->Lgt = 0;                               //  0 fixed Brightness adjustment
        lpRGBInfImg->Con = 0;                               //  0 fixed Contrast adjustment
        lpRGBInfImg->Crm = 0;                               //  0 fixed Chroma adjustment
        lpRGBInfImg->Gmr = 10;                              // 10 fixed Color balance(Gamma revision)(Red)
        lpRGBInfImg->Gmg = 10;                              // 10 fixed Color balance(Gamma revision)(Green)
        lpRGBInfImg->Gmb = 10;                              // 10 fixed Color balance(Gamma revision)(Blue)
        lpRGBInfImg->Dns = NULL;                            // NULL fixed Toner density table
        lpRGBInfImg->DnsRgb = 0;                            //  0 fixed RGB density

        lpCMYKInfImg = pOEM->Col.Mch.lpCMYKInf;             // CMYK Color change information
        if (pOEM->Col.Mch.Mode == XX_COLORMATCH_VIV) {      // Vivid?
            lpCMYKInfImg->Viv = 20;
        }
        lpCMYKInfImg->Dns  = NULL;                          // NULL fixed Toner density table
        lpCMYKInfImg->DnsCyn = 0;                           //  0 fixed Depth of color(Cyan)
        lpCMYKInfImg->DnsMgt = 0;                           //  0 fixed Depth of color(Magenta)
        lpCMYKInfImg->DnsYel = 0;                           //  0 fixed Depth of color(Yellow)
        lpCMYKInfImg->DnsBla = 0;                           //  0 fixed Depth of color(Black)

        MY_VERBOSE(("ColMatchInit() ColMchInfSet()\n"));
        if (ColMchInfSet(pdevobj) == FALSE) {               // Color Matching information setting
            return 0;
        }

        MY_VERBOSE(("ColMatchInit() DizInfSet()\n"));
        if (DizInfSet(pdevobj) == FALSE) {                  // Dither pattern information setting
            return 0;
        }
                                                            // RGB convert area (*Temp area)
        if ((pOEM->Col.lpTmpRGB = MemAlloc(sizeof(RGBS))) == NULL) {
            return 0;
        }
                                                            // CMYK convert area (*Temp area)
        allocSize = (pOEM->iColor != XX_MONO) ? sizeof(CMYK) : 1;
        if ((pOEM->Col.lpTmpCMYK = MemAlloc(allocSize)) == NULL) {
            return 0;
        }
                                                            // Draw information (*Temp area)
        if ((pOEM->Col.lpDrwInf = MemAlloc(sizeof(DRWINF))) == NULL) {
            return 0;
        }
    }

    return TRUE;
}

//===================================================================================================
//    Disable the color-matching
//===================================================================================================
BOOL FAR PASCAL ColMatchDisable(
    PDEVOBJ        pdevobj                                  // Pointer to PDEVOBJ structure
)
{
    UINT            num001;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("ColMatchDisable() Start\n"));
    if (pOEM->Col.lpLut032 != NULL) {                       // Free LUT32GRID
        MemFree(pOEM->Col.lpLut032);
    }
    if (pOEM->Col.lpUcr != NULL) {                          // Free UCR table
        MemFree(pOEM->Col.lpUcr);
    }
    if (pOEM->Col.lpLutMakGlb != NULL) {                    // Free LUTMAKGLG
        MemFree(pOEM->Col.lpLutMakGlb);
    }
    if (pOEM->Col.lpGryTbl != NULL) {                       // Free Gray transfer table
        MemFree(pOEM->Col.lpGryTbl);
    }

    if (pOEM->Col.lpColIF  != NULL) {                       // Free RGB Color change/Color Matching/Dither pattern Information
        MemFree(pOEM->Col.lpColIF);
    }
    if (pOEM->Col.LutTbl != NULL) {                         // Free Look-up table buffer
        MemFree(pOEM->Col.LutTbl);
    }
    if (pOEM->Col.CchRGB != NULL) {                         // Free Cache table for RGB
        MemFree(pOEM->Col.CchRGB);
    }
    if (pOEM->Col.CchCMYK != NULL) {                        // Free Cache table for CMYK
        MemFree(pOEM->Col.CchCMYK);
    }
    for (num001 = 0; num001 < 4; num001++) {                // Free Dither pattern table
        if (pOEM->Col.DizTbl[num001] != NULL) {
            MemFree(pOEM->Col.DizTbl[num001]);
        }
    }
    if (pOEM->Col.lpTmpRGB != NULL) {                       // Free RGB convert area (*Temp area)
        MemFree(pOEM->Col.lpTmpRGB);
    }
    if (pOEM->Col.lpTmpCMYK != NULL) {                      // Free CMYK convert area (*Temp area)
        MemFree(pOEM->Col.lpTmpCMYK);
    }
    if (pOEM->Col.lpDrwInf != NULL) {                       // Free Draw information (*Temp area)
        MemFree(pOEM->Col.lpDrwInf);
    }

    MY_VERBOSE(("ColMatchDisable() End\n"));
    return TRUE;
}

//===================================================================================================
//    DIB spools to the printer
//===================================================================================================
BOOL FAR PASCAL DIBtoPrn(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBmp,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    PIPPARAMS           pIPParams)
{

    BMPBIF      bmpBuf;                             // BMPBIF structure
    POINT       drwPos;                             // Start position for spooling
    WORD        dstWByt;                            // X size of destination bitmap data
    LONG        dstX;                               // X coordinates of destination bitmap data
    LONG        dstY;                               // Y coordinates of destination bitmap data
    LONG        dstYEnd;                            // The last Y coordinates(+1) of destination bitmap data
    WORD        dstScn;                             // Number of destination bitmap data lines
    WORD        srcY;                               // Y coordinates of source bitmap data
    LONG        srcWByt;                            // Y size of source bitmap data
    MAG         xMag;                               // X magnification
    MAG         yMag;                               // Y magnification
    POINT       pos;                                // Start position for drawing
    POINT       off;                                // coordinates of source bitmap data
    WORD        setCnt;                             // count
    LPCMYK      lpCMYK;                             // CMYK temporary data buffer
    LPRGB       lpRGB;                              // RGB temporary data buffer
    BYTE        Cmd[64];
    WORD        wlen;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("ImagePro DIBtoPrn() Start\n"));
    MY_VERBOSE(("ImagePro ENTRY Dx=%d Dy=%d SxSiz=%d SySiz=%d BC=%d Sz=%d\n", 
             pIPParams->ptOffset.x, pIPParams->ptOffset.y,
             pBitmapInfoHeader->biWidth, pBitmapInfoHeader->biHeight, pBitmapInfoHeader->biBitCount,
             pIPParams->dwSize));

    // Initialization of
    // RGB buffer            :(X size of source bitmap data) * 3
    // CMYK buffer           :(X size of source bitmap data) * 4
    // CMYK bit buffer       :((X size of source bitmap data) * (Magnification of X) + 7) / 8 * (Y size of source bitmap data) * (Magnification of Y))
    memset(&bmpBuf, 0x00, sizeof(BMPBIF));
    MY_VERBOSE(("ImagePro BmpBufAlloc()\n"));

    if (BmpBufAlloc(pdevobj, (WORD)pBitmapInfoHeader->biWidth, (WORD)pBitmapInfoHeader->biHeight, 0, 0, 1, 1, 1, 1, &bmpBuf) == FALSE) {
        ERR(("Alloc ERROR!!\n"));
        return FALSE;
    }

    bmpBuf.Diz = pOEM->iDithering;
    bmpBuf.Style = 0;
    bmpBuf.DatBit = pOEM->Col.DatBit;

    dstWByt = (WORD)((pBitmapInfoHeader->biWidth + pOEM->Col.BytDot - 1) / pOEM->Col.BytDot);

    srcWByt = (pBitmapInfoHeader->biWidth * pBitmapInfoHeader->biBitCount + 31L) / 32L * 4L;

    drwPos.x = dstX = pIPParams->ptOffset.x;
    dstY = pIPParams->ptOffset.y;
    srcY = 0;
    dstYEnd = pIPParams->ptOffset.y + pBitmapInfoHeader->biHeight;

    MY_VERBOSE(("ImagePro dstWByt[%d] srcWByt[%d]\n", dstWByt, srcWByt));
    MY_VERBOSE(("ImagePro dstX[%d] dstY[%d] dstYEnd[%d]\n", dstX, dstY, dstYEnd));

                                                            // Convert DIB and spool to the printer
    for (;dstY < dstYEnd;) {
        BmpBufClear(&bmpBuf);
        drwPos.y = dstY;
        MY_VERBOSE(("ImagePro drwPos.x[%d] drwPos.y[%d] Drv.Bit.Lin[%d]\n", drwPos.x, drwPos.y, bmpBuf.Drv.Bit.Lin));

        for (dstScn = 0; dstY < dstYEnd && dstScn < bmpBuf.Drv.Bit.Lin; dstScn++, dstY++) {    

            MY_VERBOSE(("ImagePro dstY[%d] dstScn[%d]\n", dstY, dstScn));
            MY_VERBOSE(("ImagePro BmpRGBCnv()\n"));
//            DUMP_VERBOSE(pSrcBmp,64);
            //----------------------------------------------------------------------------------------------------
            // Convert 1 line RGB bitmap data into  24bit (for 1pixel) RGB bitmap data
            BmpRGBCnv(bmpBuf.Drv.Rgb.Pnt,
                      pSrcBmp,
                      pBitmapInfoHeader->biBitCount,
                      0,
                     (WORD)pBitmapInfoHeader->biWidth,
                     (LPRGBQUAD)pColorTable);
            
            // Convert RGB=0 into RGB=1
            lpRGB = bmpBuf.Drv.Rgb.Pnt;
            if ((pOEM->iCmyBlack == XX_CMYBLACK_BLKTYPE1) 
            ||  (pOEM->iCmyBlack == XX_CMYBLACK_BLKTYPE2)) {
                for (setCnt = 0; setCnt < pBitmapInfoHeader->biWidth; setCnt++) {
                    if ((lpRGB[setCnt].Blu | lpRGB[setCnt].Grn |lpRGB[setCnt].Red) == 0) {
                        lpRGB[setCnt].Blu = 1; lpRGB[setCnt].Grn = 1; lpRGB[setCnt].Red = 1;
                    }
                }
            }
//            DUMP_VERBOSE((LPBYTE)bmpBuf.Drv.Rgb.Pnt,64);

            MY_VERBOSE(("ImagePro ColMatching()\n"));
            //----------------------------------------------------------------------------------------------------
            // Convert RGB into CMYK
            bmpBuf.Drv.Rgb.AllWhite = (WORD)ColMatching(
                pdevobj,
                No,
                No,
                (LPRGB)bmpBuf.Drv.Rgb.Pnt,
                (WORD)pBitmapInfoHeader->biWidth,
                (LPCMYK)bmpBuf.Drv.Cmyk.Pnt);
//            DUMP_VERBOSE((LPBYTE)bmpBuf.Drv.Cmyk.Pnt,64);

            lpCMYK = bmpBuf.Drv.Cmyk.Pnt;
            if (pOEM->iDithering == XX_DITH_NON) {
                for (setCnt = 0; setCnt < pBitmapInfoHeader->biWidth; setCnt++) {
                    if (lpCMYK[setCnt].Cyn != 0) { lpCMYK[setCnt].Cyn = 255; }
                    if (lpCMYK[setCnt].Mgt != 0) { lpCMYK[setCnt].Mgt = 255; }
                    if (lpCMYK[setCnt].Yel != 0) { lpCMYK[setCnt].Yel = 255; }
                    if (lpCMYK[setCnt].Bla != 0) { lpCMYK[setCnt].Bla = 255; }
                }
            }

            MY_VERBOSE(("ImagePro Dithering()\n"));
            //----------------------------------------------------------------------------------------------------
            pos.x = dstX; pos.y = dstY;                     // Drawing start position
            off.x = 0; off.y = 0;                           // Coordinates of source bitmap data
            xMag.Nrt = 1; xMag.Dnt = 1;                     // X magnification
            yMag.Nrt = 1; yMag.Dnt = 1;                     // Y magnification
            Dithering(
                pdevobj,
                (WORD)bmpBuf.Drv.Rgb.AllWhite,
                (WORD)pBitmapInfoHeader->biWidth,
                pos,
                off,
                xMag,
                yMag,
                (LPCMYK)bmpBuf.Drv.Cmyk.Pnt,
                (DWORD)dstWByt,
                 bmpBuf.Drv.Bit.Pnt[CYAN]   + dstWByt * dstScn,
                 bmpBuf.Drv.Bit.Pnt[MGENTA] + dstWByt * dstScn,
                 bmpBuf.Drv.Bit.Pnt[YELLOW] + dstWByt * dstScn,
                 bmpBuf.Drv.Bit.Pnt[BLACK]  + dstWByt * dstScn
                );
//            DUMP_VERBOSE((LPBYTE)bmpBuf.Drv.Bit.Pnt[CYAN]   + dstWByt * dstScn,64);    MY_VERBOSE(("\n"));
//            DUMP_VERBOSE((LPBYTE)bmpBuf.Drv.Bit.Pnt[MGENTA]   + dstWByt * dstScn,64);  MY_VERBOSE(("\n"));
//            DUMP_VERBOSE((LPBYTE)bmpBuf.Drv.Bit.Pnt[YELLOW]   + dstWByt * dstScn,64);  MY_VERBOSE(("\n"));
//            DUMP_VERBOSE((LPBYTE)bmpBuf.Drv.Bit.Pnt[BLACK]   + dstWByt * dstScn,64);   MY_VERBOSE(("\n"));

            srcY++;
            pSrcBmp += srcWByt;
        }

        if (dstScn != 0) {
                                                        // Spool to printer

            MY_VERBOSE(("ImagePro BmpPrint()\n"));
            BmpPrint(pdevobj, &bmpBuf, drwPos, (WORD)pBitmapInfoHeader->biWidth, dstScn, dstWByt);
        }
    }

    // Set back palette (Palette No. is fixed  , All plane(CMYK) is OK )
    // Same as palette state before OEMImageProcessing call 
    MY_VERBOSE(("ImagePro WRITESPOOLBUF()\n"));
    WRITESPOOLBUF(pdevobj, ORG_MODE_IN, BYTE_LENGTH(ORG_MODE_IN));
    wlen = (WORD)wsprintf(Cmd, PALETTE_SELECT, 0, DEFAULT_PALETTE_INDEX);
    WRITESPOOLBUF(pdevobj, Cmd, wlen);
    WRITESPOOLBUF(pdevobj, PLANE_RESET, BYTE_LENGTH(PLANE_RESET));
    WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));

    BmpBufFree(&bmpBuf);

    CM_VERBOSE(("ImagePro End\n\n"));

    return TRUE;
}


//===================================================================================================
//    Convert RGB data into CMYK data
//===================================================================================================
BOOL FAR PASCAL ColMatching(                                // AllWhite?
    PDEVOBJ         pdevobj,                                // Pointer to pdevobj structure
    UINT            PColor,                                 // 1 dot line / Char12P or less point?
    UINT            BCnvFix,                                // Black replacement fixation?(No:dialog use)
    LPRGB           lpInRGB,                                // RGB line(Input)
    UINT            MchSiz,                                 // RGB size
    LPCMYK          lpInCMYK                                // CMYK line(Output)
)
{
    LPRGB           lpRGB;                                  // RGB line
    LPCMYK          lpCMYK;                                 // CMYK line
    LPCMYKINF       lpCMYKInf;                              // CMYK Color change information
    UINT            chkCnt;                                 // RGB check counter for white
    LPCOLMCHINF     lpColMch;                               // Color Matching Information
    UINT            cMch;                                   // Color Matching type
    UINT            bCnv;                                   // Black replacement
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (MchSiz == 1) {                                      // RGB size=1 ?
        lpRGB  = pOEM->Col.lpTmpRGB;                        // RGB convert area (*Temp area)
        lpCMYK = pOEM->Col.lpTmpCMYK;                       // CMYK convert area (*Temp area)
        *lpRGB = *lpInRGB;                                  // Input RGB
    } else {
        lpRGB  = lpInRGB;                                   // RGB line
        lpCMYK = lpInCMYK;                                  // CMYK line
    }
    for (chkCnt = 0; chkCnt < MchSiz; chkCnt++) {           // check of All white
        if ((lpRGB[chkCnt].Blu & lpRGB[chkCnt].Grn & lpRGB[chkCnt].Red) != 0xff) { break; }
    }
    if (chkCnt >= MchSiz) {                                 // All white data?
        if (MchSiz == 1) {                                  // White set to CMYK
            lpInCMYK->Cyn = 0x00;
            lpInCMYK->Mgt = 0x00;
            lpInCMYK->Yel = 0x00;
            lpInCMYK->Bla = 0x00;
        }
        return Yes;                                         // All white
    }
    if (chkCnt != 0) {                                      // White data existence in the left end?
        memset(lpCMYK, 0x00, chkCnt * sizeof(CMYK));        // White set to CMYK
        (HPBYTE)lpCMYK   += chkCnt * sizeof(CMYK);          // Change of the head position of CMYK area
        (HPBYTE)lpInCMYK += chkCnt * sizeof(CMYK);          // Change of the head position of CMYK area
        (HPBYTE)lpRGB    += chkCnt * sizeof(RGBS);          // Change of the head position of RGB area
        MchSiz -= chkCnt;                                   // Change of RGB size
    }
    if (pOEM->Col.ColMon == CMMCOL) {                       // Color?
        if ((PColor == Yes && pOEM->Col.Mch.PColor == Yes) || pOEM->Col.Mch.Diz == XX_DITH_NON) {
            cMch = MCHPRG;                                  // Color Matching  progressive
        } else if (pOEM->Col.Mch.Mode == XX_COLORMATCH_NONE) {
            cMch = MCHSLD;                                  // Color Matching  Solid
        } else {
            if (pOEM->Col.Mch.Speed == Yes) {               // Color Matching  High speed?
                cMch = MCHFST;                              // Color Matching  LUT First
            } else {
                cMch = MCHNML;                              // Color Matching  LUT Normal
            }
        }

        bCnv = KCGNON;                                      // Black unreplacement(Three color toner printings of black)
        if ((pOEM->Col.Mch.CmyBlk == Yes && pOEM->Col.Mch.GryKToner == No) ||  
            (BCnvFix == Yes)) {
            bCnv = KCGBLA;                                  // Black replacement (RGB=0 -> K)
        }
        if (pOEM->Col.Mch.CmyBlk == Yes && pOEM->Col.Mch.GryKToner == Yes) {
            bCnv = KCGGRY;                                  // Black & gray replacement (R=G=B -> K)
        }

                                                            // UCR?
        if (pOEM->Col.Mch.CmyBlk == No && pOEM->Col.Mch.Ucr != UCRNOO && BCnvFix == No) {
            bCnv = KCGNON;                                  // Black unreplacement(Three color toner printings of black)
        }
        
        MY_VERBOSE(("   ColMatching  ICM USE !! [%d]\n", pOEM->iIcmMode));
        if (pOEM->iIcmMode == XX_ICM_USE && BCnvFix == No) {// ICM ?
            cMch = MCHSLD;                                  // Color Matching  Solid
            bCnv = KCGNON;                                  // Black unreplacement
        }

    } else {
        cMch = MCHMON;                                      // Color Matching MONO
        bCnv = KCGNON;                                      // Black unreplacement
    }
    if (MchSiz == 1) {
        if (pOEM->Col.Mch.CchMch   == cMch &&               // With cash information all same?
            pOEM->Col.Mch.CchCnv   == bCnv &&
            pOEM->Col.Mch.CchRGB.Red == lpRGB->Red &&
            pOEM->Col.Mch.CchRGB.Grn == lpRGB->Grn &&
            pOEM->Col.Mch.CchRGB.Blu == lpRGB->Blu) {
            *lpInCMYK = pOEM->Col.Mch.CchCMYK;              // Output CMYK setting
            return No;                                      // Existence except for white data
        } else {
            pOEM->Col.Mch.CchMch = cMch;                    // Update cache (CMYK is eliminated)
            pOEM->Col.Mch.CchCnv = bCnv;
            pOEM->Col.Mch.CchRGB = *lpRGB;
        }
    }

//  if (pOEM->Col.Mch.LutMakGlb == No && pOEM->Col.Mch.SubDef == No) {
//      ColControl(pdevobj, lpRGB, MchSiz);             // RGB Color cotrol
//  }

    lpCMYKInf = pOEM->Col.Mch.lpCMYKInf;                    // CMYK Color cotrol information

    lpColMch  = pOEM->Col.Mch.lpColMch;                     // Color Matching information
    lpColMch->Mch = (DWORD)cMch;                            // Color Matching
    lpColMch->Bla = (DWORD)bCnv;                            // Black replacement

    MY_VERBOSE(("N501_ColMchPrc()  Mch=[%d] Bla=[%d] Ucr=[%d] UcrCmy=[%d] UcrTnr=[%d] UcrBla=[%d]\n",
             lpColMch->Mch, lpColMch->Bla, lpColMch->Ucr, lpColMch->UcrCmy, lpColMch->UcrTnr, lpColMch->UcrBla));
    MY_VERBOSE(("                  LutGld=[%d] ColQty=[%d]\n",lpColMch->LutGld, lpColMch->ColQty));

    N501_ColMchPrc((DWORD)MchSiz, lpRGB, lpCMYK, lpColMch);
    if (pOEM->Col.Mch.LutMakGlb == No && (lpCMYKInf->Viv != 0 || lpCMYKInf->Dns != NULL)) {

        MY_VERBOSE(("N501_ColCtrCmy()  Viv=[%d] DnsCyn=[%d] DnsMgt=[%d] DnsYel=[%d] DnsBla=[%d]\n",
                    lpCMYKInf->Viv, lpCMYKInf->DnsCyn, lpCMYKInf->DnsMgt, lpCMYKInf->DnsYel, lpCMYKInf->DnsBla));
        N501_ColCtrCmy((DWORD)MchSiz, lpCMYK, lpCMYKInf);
    }

    if (MchSiz == 1) {                                      // RGB size=1 ?
        *lpInCMYK = *lpCMYK;                                // output CMYK setting
        pOEM->Col.Mch.CchCMYK = *lpCMYK;                    // Update cache (CMYK)
    }
    return No;                                              // Existence except for white data
}

//===================================================================================================
//    Convert CMYK data into Dither data
//===================================================================================================
UINT FAR PASCAL Dithering(                                  // Output line count
    PDEVOBJ         pdevobj,                                // Pointer to pdevobj structure
    UINT            AllWhite,                               // All white data?
    UINT            XSize,                                  // X Size
    POINT           Pos,                                    // Start position for drawing
    POINT           Off,                                    // Y size of source bitmap data
    MAG             XMag,                                   // X magnification
    MAG             YMag,                                   // Y magnification
    LPCMYK          lpCMYK,                                 // CMYK line
    DWORD           LinByt,                                 // Dither pattern buffer size(Byte / 1Line)
    LPBYTE          lpCBuf,                                 // Line buffer(C)
    LPBYTE          lpMBuf,                                 // Line buffer(M)
    LPBYTE          lpYBuf,                                 // Line buffer(Y)
    LPBYTE          lpKBuf                                  // Line buffer(K)
)
{
    LPDIZINF        lpDiz;
    LPDRWINF        lpDrw;
    UINT            linNum;
    DWORD           whtByt;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("ImagePro Dithering() Start\n"));

    if (AllWhite == Yes) {                                  // All White data?
        linNum = MagPixel(Off.y, YMag.Nrt, YMag.Dnt);       // Housing line number
        whtByt = (DWORD)LinByt * linNum;                    // White set byte number
        MY_VERBOSE(("ImagePro Dithering() linNum[%d] whtByt[%d] \n", linNum, whtByt));
        if (pOEM->Col.ColMon == CMMCOL) {                   // Color?
            memset(lpCBuf, 0x00, whtByt);                   // White set to CMYK
            memset(lpMBuf, 0x00, whtByt);
            memset(lpYBuf, 0x00, whtByt);
        }
        memset(lpKBuf, 0x00, whtByt);
        MY_VERBOSE(("ImagePro Dithering() AllWhite=Yes\n"));
        return linNum;
    }

    lpDiz = pOEM->Col.Mch.lpDizInf;                         // Dither pattern information
    MY_VERBOSE(("                     ColMon=[%d] PrnMod=[%d] PrnKnd=[%d] DizKnd=[%d] DizPat=[%d]\n",
             lpDiz->ColMon, lpDiz->PrnMod, lpDiz->PrnKnd, lpDiz->DizKnd, lpDiz->DizPat));
    MY_VERBOSE(("                     DizSls=[%d] SizCyn=[%d] SizMgt=[%d] SizYel=[%d] SizBla=[%d]\n",
             lpDiz->DizSls, lpDiz->SizCyn, lpDiz->SizMgt, lpDiz->SizYel, lpDiz->SizBla));

    lpDrw = pOEM->Col.lpDrwInf;                             // Draw information (*Temp area)
    lpDrw->XaxSiz    = (DWORD)XSize;                        // X Pixel number
    lpDrw->StrXax    = (DWORD)Pos.x;                        // Start position for drawing X
    lpDrw->StrYax    = (DWORD)Pos.y;                        // Start position for drawing Y
    lpDrw->XaxNrt    = (DWORD)XMag.Nrt;                     // X Magnification numerator
    lpDrw->XaxDnt    = (DWORD)XMag.Dnt;                     // X Magnification Denominator
    lpDrw->YaxNrt    = (DWORD)YMag.Nrt;                     // Y Magnification Numerator
    lpDrw->YaxDnt    = (DWORD)YMag.Dnt;                     // Y Magnification Denominator
    lpDrw->XaxOfs    = (DWORD)Off.x;                        // X Offset
    lpDrw->YaxOfs    = (DWORD)Off.y;                        // Y Offset
    lpDrw->LinDot    = (DWORD)XSize;                        // Destination, 1 line dot number
    lpDrw->LinByt    = (DWORD)LinByt;                       // Destination, 1 line byte number
    lpDrw->CmyBuf    = (LPCMYK)lpCMYK;                      // CMYK data buffer
    lpDrw->LinBufCyn = lpCBuf;                              // Destination buffer(CMYK)
    lpDrw->LinBufMgt = lpMBuf;
    lpDrw->LinBufYel = lpYBuf;
    lpDrw->LinBufBla = lpKBuf;
    lpDrw->AllLinNum = 0;                                   // Total of the line number for Image

    MY_VERBOSE(("N501_ColDizPrc()  XaxSiz=[%d] StrXax=[%d] StrYax=[%d] XaxNrt=[%d] XaxDnt=[%d]\n",
                lpDrw->XaxSiz, lpDrw->StrXax, lpDrw->StrYax, lpDrw->XaxNrt, lpDrw->XaxDnt));
    MY_VERBOSE(("N501_ColDizPrc()  YaxNrt=[%d] YaxDnt=[%d] XaxOfs=[%d] YaxOfs=[%d] LinDot=[%d] LinByt=[%d]\n",
                lpDrw->YaxNrt, lpDrw->YaxDnt, lpDrw->XaxOfs, lpDrw->YaxOfs, lpDrw->LinDot, lpDrw->LinByt));

    N501_ColDizPrc(lpDiz, lpDrw);                           // Dithering

    MY_VERBOSE(("Dithering() End\n"));
    return (WORD)lpDrw->AllLinNum;                          // Housing line number
}

//===================================================================================================
//      Color control
//===================================================================================================
VOID FAR PASCAL ColControl(
    PDEVOBJ         pdevobj,                                // Pointer to pdevobj structure
    LPRGB           lpRGB,                                  // RGB Line
    UINT            RGBSiz                                  // RGB Size
)
{
    LPRGBINF        lpRGBInf;                               // RGB Color change information
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpRGBInf = pOEM->Col.Mch.lpRGBInf;
    N501_ColCtrRgb((DWORD)RGBSiz, lpRGB, lpRGBInf);         // RGB Color cntrol
    return;
}

//===================================================================================================
//    Allocate bitmap data buffer
//---------------------------------------------------------------------------------------------------
//    Allocate size
//          RGB buffer              :Source bitmap Xsize * 3
//          CMYK buffer             :Source bitmap Xsize * 4
//          CMYK bit buffer         :2 value    (Source Xsize * XNrt + 7) / 8 * Source Ysize * YNrt
//                                  :4 value    (Source Xsize * XNrt + 3) / 4 * Source Ysize * YNrt
//                                  :16 value   (Source Xsize * XNrt + 1) / 2 * Source Ysize * YNrt
//===================================================================================================
BOOL BmpBufAlloc(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    WORD           SrcXSiz,                                 // Source bitmap data Xsize
    WORD           SrcYSiz,                                 // Source bitmap data Ysize
    WORD           SrcXOff,                                 // Source X offset
    WORD           SrcYOff,                                 // Source Y offset
    WORD           XNrt,                                    // Magnification of X (numerator)
    WORD           XDnt,                                    // Magnification of X (denominator)
    WORD           YNrt,                                    // Magnification of Y (numerator)
    WORD           YDnt,                                    // Magnification of Y (denominator)
    LPBMPBIF       lpBmpBuf                                 // Pointer to bitmap buffer structure
)
{
    WORD           setSiz;
    WORD           setCnt;
    WORD           alcErr;                                  // Allocate error?
    WORD           bytDot;                                  // DPI
    WORD           xSiz;
    WORD           ySiz;
    WORD           alcLin;
    DWORD          alcSiz;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    alcErr = Yes;

    bytDot = pOEM->Col.BytDot;

    xSiz = (WORD)(((DWORD)SrcXOff + SrcXSiz) * XNrt / XDnt);
    xSiz -= (WORD)((DWORD)SrcXOff * XNrt / XDnt);
    MY_VERBOSE(("BmpBufAlloc() xSiz[%d] \n", xSiz));

    ySiz = (WORD)(((DWORD)SrcYOff + SrcYSiz + 2) * YNrt / YDnt);
    ySiz -= (WORD)((DWORD)SrcYOff * YNrt / YDnt);
    MY_VERBOSE(("BmpBufAlloc() ySiz[%d] \n", ySiz));
                                                            // The size of CMYK bit buffer
    if (((DWORD)((xSiz + bytDot - 1) / bytDot) * ySiz) < (64L * 1024L - 1L)) {
        alcLin = ySiz;
    } else {                                                // Over 64KB?
        alcLin = (WORD)((64L * 1024L - 1L) / ((xSiz + bytDot - 1) / bytDot));
    }
    MY_VERBOSE(("BmpBufAlloc() bytDot[%d] \n", bytDot));

    alcSiz = ((xSiz + bytDot - 1) / bytDot) * alcLin;       // The size of CMYK bit buffer(8bit boundary)
    MY_VERBOSE(("BmpBufAlloc() alcLin[%d] \n", alcLin));
    MY_VERBOSE(("BmpBufAlloc() alcSiz[%ld] \n", alcSiz));

    for ( ; ; ) {                                           // Allocation
                                                            // The number of lines that required
        lpBmpBuf->Drv.Bit.BseLin = (WORD)((DWORD)(YNrt + YDnt - 1) / YDnt);
        if (lpBmpBuf->Drv.Bit.BseLin > alcLin) {
            break;
        }
        MY_VERBOSE(("BmpBufAlloc() Drv.Bit.BseLin[%d] \n", lpBmpBuf->Drv.Bit.BseLin));

        lpBmpBuf->Drv.Rgb.Siz = SrcXSiz * 3;                // RGB buffer
        if ((lpBmpBuf->Drv.Rgb.Pnt = (LPRGB)MemAllocZ(lpBmpBuf->Drv.Rgb.Siz)) == NULL) {
            break;
        }
        MY_VERBOSE(("BmpBufAlloc() Drv.Rgb.Siz[%d] \n", lpBmpBuf->Drv.Rgb.Siz));

        lpBmpBuf->Drv.Cmyk.Siz = SrcXSiz * 4;               // CMYK buffer
        if ((lpBmpBuf->Drv.Cmyk.Pnt = (LPCMYK)MemAllocZ(lpBmpBuf->Drv.Cmyk.Siz)) == NULL) {
            break;
        }
        MY_VERBOSE(("BmpBufAlloc() Drv.Cmyk.Siz[%d] \n", lpBmpBuf->Drv.Cmyk.Siz));

        if (pOEM->iColor == XX_COLOR_SINGLE 
         || pOEM->iColor == XX_COLOR_MANY
         || pOEM->iColor == XX_COLOR_MANY2) {               // Color?
            setSiz = 4;                                     // CMYK
        } else {                                            // Mono?
            setSiz = 1;                                     // K
        }
        MY_VERBOSE(("BmpBufAlloc() setSiz[%d] \n", setSiz));
                                                            // CMYK bit buffer
        for (setCnt = 0; setCnt < setSiz; setCnt++) {
            if ((lpBmpBuf->Drv.Bit.Pnt[setCnt] = MemAllocZ(alcSiz)) == NULL) {
                break;
            }
        }
        if (setCnt == setSiz) {
            lpBmpBuf->Drv.Bit.Siz = alcSiz;
            lpBmpBuf->Drv.Bit.Lin = alcLin;
            alcErr = No;                                    // Allocate OK
        }
        break;
    }
    if (alcErr == Yes) {                                    // Allocate error?
        BmpBufFree(lpBmpBuf);
        return FALSE;
    }

    return TRUE;
}


//===================================================================================================
//    Free bitmap data buffer
//===================================================================================================
void BmpBufFree(
    LPBMPBIF       lpBmpBuf                                 // Pointer to bitmap buffer structure
)
{
    WORD           chkCnt;

    if (lpBmpBuf->Drv.Rgb.Pnt) {                            // Free RGB buffer
        MemFree(lpBmpBuf->Drv.Rgb.Pnt);
        lpBmpBuf->Drv.Rgb.Pnt = NULL;
    }
    if (lpBmpBuf->Drv.Cmyk.Pnt) {                           // Free CMYK buffer
        MemFree(lpBmpBuf->Drv.Cmyk.Pnt);
        lpBmpBuf->Drv.Cmyk.Pnt = NULL;
    }
                                                            // CMYK bit buffer
    for (chkCnt = 0; chkCnt < 4; chkCnt++) {                // CMYK(2/4/16value)bitmap buffer
        if (lpBmpBuf->Drv.Bit.Pnt[chkCnt]) {
            MemFree(lpBmpBuf->Drv.Bit.Pnt[chkCnt]);
            lpBmpBuf->Drv.Bit.Pnt[chkCnt] = NULL;
        }
    }
    return;
}


//===================================================================================================
//    Clear CMYK bitmap data buffer
//===================================================================================================
void BmpBufClear(
    LPBMPBIF       lpBmpBuf                                 // Pointer to bitmap buffer structure
)
{
    WORD           chkCnt;

    MY_VERBOSE(("BmpBufClear() Siz[%ld] \n", lpBmpBuf->Drv.Bit.Siz));
    for (chkCnt = 0; chkCnt < 4; chkCnt++) {                // Clear CMYK(2/4/16value)bit buffer
        if (lpBmpBuf->Drv.Bit.Pnt[chkCnt]) {
            memset(lpBmpBuf->Drv.Bit.Pnt[chkCnt], 0x00, (WORD)lpBmpBuf->Drv.Bit.Siz);
        }
    }
    return;
}

//===================================================================================================
//    Spool bitmap data
//===================================================================================================
void BmpPrint(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    LPBMPBIF       lpBmpBuf,                                // Pointer to bitmap buffer structure
    POINT          Pos,                                     // Start position for spooling
    WORD           Width,                                   // Width(dot)
    WORD           Height,                                  // Height(dot)
    WORD           WidthByte                                // Width(byte)
)
{
    DRWBMP         drwBmp;                                  // For Spooling bitmap data structure
    DRWBMPCMYK     drwBmpCMYK;                              // For Spooling CMYK bitmap data structure
    WORD           colCnt;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    static const CMYK colTbl[4] = {                         // CMYK table
        {  0,   0,   0, 255},                               // Black
        {  0,   0, 255,   0},                               // Yellow
        {  0, 255,   0,   0},                               // Magenta
        {255,   0,   0,   0}                                // Cyan
    };

    static const WORD plnTbl[4] = {                         // Plane table
        PLN_BLACK,
        PLN_YELLOW,
        PLN_MGENTA,
        PLN_CYAN
    };
    static const WORD frmTbl[4] = {0, 3, 2, 1};             // Frame table

    drwBmpCMYK.Style = lpBmpBuf->Style;
    drwBmpCMYK.DataBit = lpBmpBuf->DatBit;
    drwBmpCMYK.DrawPos = Pos;
    drwBmpCMYK.Width = Width;
    drwBmpCMYK.Height = Height;
    drwBmpCMYK.WidthByte = WidthByte;
    MY_VERBOSE(("BmpPrint() Style[%d] DatBit[%d]\n", drwBmpCMYK.Style, lpBmpBuf->DatBit));
    MY_VERBOSE(("          Width[%d] Height[%d] WidthByte[%d]\n", Width, Height, WidthByte));
                                                            // Color?
    if (pOEM->iColor == XX_COLOR_SINGLE 
     || pOEM->iColor == XX_COLOR_MANY
     || pOEM->iColor == XX_COLOR_MANY2) {

        for (colCnt = 0; colCnt < 4; colCnt++) {            // Setting value for spooling bitmap data
            MY_VERBOSE(("          colCnt[%d]\n", colCnt));
            drwBmpCMYK.Plane = PLN_ALL;                     // All Plane is OK
            drwBmpCMYK.Frame = frmTbl[colCnt];
            drwBmpCMYK.lpBit = lpBmpBuf->Drv.Bit.Pnt[colCnt]/* + WidthByte*/;
            PrnBitmapCMYK(pdevobj, &drwBmpCMYK);            // Spool bitmap data
        }
    } else {                                                // Mono
                                                            // Setting value for spooling bitmap data
        drwBmpCMYK.Plane = plnTbl[0];
        drwBmpCMYK.Frame = frmTbl[0];
        drwBmpCMYK.lpBit = lpBmpBuf->Drv.Bit.Pnt[0]/* + WidthByte*/;
        PrnBitmapCMYK(pdevobj, &drwBmpCMYK);                // Spool bitmap data
    }

    return;
}

//===================================================================================================
//    Convert 1 line RGB bitmap data into  24bit (for 1pixel) RGB bitmap data
//===================================================================================================
void BmpRGBCnv(
    LPRGB          lpRGB,                                   // Pointer to destination bitmap data
    LPBYTE         lpSrc,                                   // Pointer to source bitmap data
    WORD           SrcBit,                                  // Pixel of source bitmap data
    WORD           SrcX,                                    // X coordinates of source bitmap data
    WORD           SrcXSiz,                                 // X size of source bitmap data
    LPRGBQUAD      lpPlt                                    // Color palette table of source bitmap data(1/4/8pixel)
)
{
    WORD           setCnt;
    BYTE           colNum;
    LPWORD         lpWSrc;

    MY_VERBOSE(("BmpRGBCnv SrcBit[%d]\n", SrcBit));
    switch (SrcBit) {
        case 1:                                             // 1 bit
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, SrcX++) {
                                                            // Foreground color?
                if (!(lpSrc[SrcX / 8] & BitTbl[SrcX & 0x0007])) {
                    lpRGB[setCnt].Blu = lpPlt[0].rgbBlue;
                    lpRGB[setCnt].Grn = lpPlt[0].rgbGreen;
                    lpRGB[setCnt].Red = lpPlt[0].rgbRed;
                } else {
                    lpRGB[setCnt].Blu = lpPlt[1].rgbBlue;
                    lpRGB[setCnt].Grn = lpPlt[1].rgbGreen;
                    lpRGB[setCnt].Red = lpPlt[1].rgbRed;
                }
            }
            break;
        case 4:                                             // 4bit
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, SrcX++) {
                if (!(SrcX & 0x0001)) {                     // A even number coordinates?
                    colNum = lpSrc[SrcX / 2] / 16;
                } else {
                    colNum = lpSrc[SrcX / 2] % 16;
                }
                lpRGB[setCnt].Blu = lpPlt[colNum].rgbBlue;
                lpRGB[setCnt].Grn = lpPlt[colNum].rgbGreen;
                lpRGB[setCnt].Red = lpPlt[colNum].rgbRed;
            }
            break;
        case 8:                                             // 8bit
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, SrcX++) {
                colNum = lpSrc[SrcX];
                lpRGB[setCnt].Blu = lpPlt[colNum].rgbBlue;
                lpRGB[setCnt].Grn = lpPlt[colNum].rgbGreen;
                lpRGB[setCnt].Red = lpPlt[colNum].rgbRed;
            }
            break;
        case 16:                                            // 16bit
            lpWSrc = (LPWORD)lpSrc + SrcX;
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, lpWSrc++) {
                lpRGB[setCnt].Blu = (BYTE)((*lpWSrc & 0x001f) << 3);
                lpRGB[setCnt].Grn = (BYTE)((*lpWSrc & 0x03e0) >> 2);
                lpRGB[setCnt].Red = (BYTE)((*lpWSrc / 0x0400) << 3);
            }
            break;
        case 24:                                            // 24 bit
            lpSrc += SrcX * 3;
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, lpSrc += 3) {
                lpRGB[setCnt].Red    = lpSrc[0];
                lpRGB[setCnt].Grn    = lpSrc[1];
                lpRGB[setCnt].Blu    = lpSrc[2];
            }
            break;
        case 32:                                            // 32bit
            lpSrc += SrcX * 4;
            for (setCnt = 0; setCnt < SrcXSiz; setCnt++, lpSrc += 4) {
                lpRGB[setCnt].Blu = lpSrc[0];
                lpRGB[setCnt].Grn = lpSrc[1];
                lpRGB[setCnt].Red = lpSrc[2];
            }
            break;
    }
    return;
}

//===================================================================================================
//    Color Matching information setting
//===================================================================================================
BOOL ColMchInfSet(                                          // TRUE / FALSE
    PDEVOBJ        pdevobj                                  // Pointer to pdevobj structure
)
{
    static LPTSTR   N501LutNam[] = {                        // N501 LUT file name
        N501LUTR                                            // Color Matching
    };

    LPCOLMCHINF     lpColMch;                               // Color Matching information
    UINT            ColMch;                                 // Color Matching Method
    UINT            lutTbl;                                 // LUT file table number
    UINT            lutNum;                                 // LUT number(0:direct 1:linear *Except for N403:0Fixed)
    LPTSTR          lutNam;                                 // LUT file name
    LPTSTR          filNam;                                 // LUT file name(FULL PATH)
    DWORD           pthSiz;                                 // DRIVER PATH
    HANDLE          hFile;                                  // file handle
    HPBYTE          hpLoad;                                 // LUT pointer
    DWORD           seek;                                   // LUT seek
    LPBYTE          lpLut032Buf;                            // First LUT 32 GRID area
    LPBYTE          lpLut032Wrk;                            // First LUT 32 GRID work area
    LPBYTE          lpLutMakGlbBuf;                         // Sum LUT area
    LPBYTE          lpLutMakGlbWrk;                         // Sum LUT work area
    LPCMYK          LutAdr;
    DWORD           dwRet;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("\nColMchInfSet() Start\n"));
    lpColMch = pOEM->Col.Mch.lpColMch;                      // Color Matching Information
    lpColMch->Bla    = KCGNON;
    lpColMch->LutGld = 0;
    lpColMch->Ucr = pOEM->Col.Mch.Ucr;
    lpColMch->UcrCmy = 40;                                  // UCR quantity 40%
    lpColMch->UcrBla = 90;                                  // Ink version generation quantity 90%
    lpColMch->UcrTnr = 270;                                 //+Toner gross weight 270%  CASIO 20001/02/15
    lpColMch->UcrTbl = NULL;                                // UCK table
    lpColMch->GryTbl = NULL;                                // Gray transfer table

    if (pOEM->Col.ColMon == CMMMON) {                       // Mono?
        lpColMch->Mch = MCHMON;
//        if ((ColLutMakGlbMon(pdevobj)) == FALSE) {
//            return FALSE;
//        }
        return TRUE;
    }
    if (pOEM->Col.Mch.Speed == Yes) {                       // First?
        lpColMch->Mch = MCHFST;
    } else {
        lpColMch->Mch = MCHNML;
    }
    if (pOEM->Col.Mch.Diz == XX_DITH_NON) {                 // Not Dithering?
        lpColMch->Mch = MCHPRG;                             // progressive
        return TRUE;
    }
    lutNum = 0;                                             // LUT number(0:direct 1:linear *Except for N403:0Fixed)
    lutTbl = 0;                                             // number of LUT table array
    ColMch = pOEM->Col.Mch.Mode;                            // Color Matching mode
    if (pOEM->Printer == PRN_N5) {                          // N5 printer
        if (ColMch == XX_COLORMATCH_BRI 
         || ColMch == XX_COLORMATCH_VIV) {                  // Brightness or Vivid?
            lutTbl = 0;
            lutNum = LUT_XD;
        } else if (ColMch == XX_COLORMATCH_TINT) {          // tincture?
            lutTbl = 0;
            lutNum = LUT_YD;
        } else if (ColMch == XX_COLORMATCH_NONE) {
            lpColMch->Mch = MCHSLD;                         // Solid
            lutTbl = 0;
            lutNum = LUT_XD;
        }
        lutNam = N501LutNam[lutTbl];                        // LUT file name
    }

    if ((filNam = MemAllocZ(MAX_PATH * sizeof(TCHAR))) == NULL) {
        return FALSE;
    }
    pthSiz = GetModuleFileName(pdevobj->hOEM, filNam, MAX_PATH);
    pthSiz -= ((sizeof(CSN5RESDLL) / sizeof(WCHAR)) - 1);
    lstrcpy(&filNam[pthSiz], lutNam);

    MY_VERBOSE(("LUT filNam [%ws]\n", filNam));
    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(filNam,
            GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))) {

        ERR(("Error opening LUT file %ws (%d)\n", filNam, GetLastError()));
        MemFree(filNam);
        return FALSE;
    }
    MemFree(filNam);

    if ((hpLoad = MemAlloc(LUTFILESIZ)) == NULL) {          // LUT read buffer
        CloseHandle(hFile);
        return FALSE;
    }
    MY_VERBOSE(("ColMchInfSet() LUT file read\n"));
    if (FALSE == ReadFile(hFile,                            // LUT file read
        hpLoad, LUTFILESIZ, &dwRet, NULL)) {

        ERR(("Error reading LUT file %ws (%d)\n", filNam, GetLastError()));

        // Abort
        MemFree(hpLoad);
        CloseHandle(hFile);
        return FALSE;
    }

    MY_VERBOSE(("ColMchInfSet() N501_ColLutDatRdd()\n"));
    MY_VERBOSE(("ColMchInfSet() lutNum[%d] \n", lutNum));
//    if ((seek = (N501_ColLutDatRdd((LPBYTE)hpLoad, (DWORD)lutNum))) == 0) {
    if ((seek = (N501_ColLutDatRdd((LPBYTE)hpLoad, lutNum))) == 0) {
        MemFree(hpLoad);
        CloseHandle(hFile);
        return FALSE;
    }
    lpColMch->LutAdr = (LPCMYK)(hpLoad + seek);             // LUT file Head address + seek
    LutAdr = (LPCMYK)(hpLoad + seek);
    pOEM->Col.LutTbl = hpLoad;                              // LUT table

    if (lpColMch->Mch == MCHSLD) {                          // Color Matching Solid?
        MY_VERBOSE(("ColMchInfSet() Mch == MCHSLD \n"));
                                                            // Black & gray replacement ?
        if (pOEM->Col.Mch.GryKToner == Yes && pOEM->Col.Mch.CmyBlk == Yes) {
                                                            // Gray transfer table make
            if ((ColGryTblMak(pdevobj, LutAdr)) == FALSE) {
                MemFree(hpLoad);
                CloseHandle(hFile);
                return FALSE;
            }
        }

        if (lpColMch->Ucr != UCRNOO) {                      // UCR?
            MY_VERBOSE(("ColMchInfSet() Mch == MCHSLD && Ucr != UCRNOO \n"));
            if ((ColUcrTblMak(pdevobj,  (LPCMYK)(hpLoad + seek))) == FALSE) {
                MemFree(hpLoad);
                CloseHandle(hFile);
                return FALSE;
            }
        }
        CloseHandle(hFile);
        return TRUE;
    }

    MY_VERBOSE(("ColMchInfSet() Global LUT Start\n"));
    if (pOEM->Col.Mch.Mode == XX_COLORMATCH_VIV) {
        MY_VERBOSE(("ColMchInfSet() Global LUT area\n"));
                                                            // Global LUT area
        if ((lpLutMakGlbBuf = MemAlloc(LUTMAKGLBSIZ)) == NULL) {    
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }

                                                            // Global LUT work area
        MY_VERBOSE(("ColMchInfSet() Global LUT work area\n"));
        if ((lpLutMakGlbWrk = MemAlloc(LUTGLBWRK)) == NULL) {   
            MemFree(lpLutMakGlbBuf);
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }

                                                            // Make Global LUT 
        MY_VERBOSE(("ColMchInfSet() N501_ColLutMakGlb()\n"));
        if ((N501_ColLutMakGlb(NULL, (LPCMYK)(hpLoad + seek), pOEM->Col.Mch.lpRGBInf, pOEM->Col.Mch.lpCMYKInf,
                              (LPCMYK)lpLutMakGlbBuf, lpLutMakGlbWrk)) != ERRNON) {
            MemFree(lpLutMakGlbWrk);
            MemFree(lpLutMakGlbBuf);
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }
        pOEM->Col.lpLutMakGlb = lpLutMakGlbBuf;
        pOEM->Col.Mch.LutMakGlb = Yes;
        lpColMch->LutAdr = (LPCMYK)lpLutMakGlbBuf;
        LutAdr = (LPCMYK)lpLutMakGlbBuf;
        MemFree(lpLutMakGlbWrk);
    }

    if (pOEM->Col.Mch.Speed == Yes) {                       // First?
                                                            // First LUT 32 GRID area
        MY_VERBOSE(("ColMchInfSet() First LUT 32 GRID area\n"));
        if ((lpLut032Buf = MemAlloc(LUT032SIZ)) == NULL) {
            if (lpLutMakGlbBuf != NULL) {
                MemFree(lpLutMakGlbBuf);
            }
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }

                                                            // First LUT(32GRID) wark area
        if ((lpLut032Wrk = MemAlloc(LUT032WRK)) == NULL) {  
            if (lpLutMakGlbBuf != NULL) {
                MemFree(lpLutMakGlbBuf);
            }
            MemFree(lpLut032Buf);
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }

                                                            // First LUT(32GRID) Make
        MY_VERBOSE(("ColMchInfSet() N501_ColLutMak032()\n"));
        N501_ColLutMak032(LutAdr, (LPCMYK)lpLut032Buf, lpLut032Wrk);
        MemFree(lpLut032Wrk);
        lpColMch->LutAdr = (LPCMYK)lpLut032Buf;
        LutAdr = (LPCMYK)lpLut032Buf;
        pOEM->Col.lpLut032 = lpLut032Buf;
    }

    MY_VERBOSE(("ColMchInfSet() Black & gray replacement ?\n"));
                                                            // Black & gray replacement ?
    if (pOEM->Col.Mch.GryKToner == Yes && pOEM->Col.Mch.CmyBlk == Yes) {
        MY_VERBOSE(("ColMchInfSet() Black & gray replacement [Yes]\n"));
        if ((ColGryTblMak(pdevobj, LutAdr)) == FALSE) {     // Gray transfer table make
            if (lpLutMakGlbBuf != NULL) {
                MemFree(lpLutMakGlbBuf);
            }
            if (lpLut032Buf != NULL) {
                MemFree(lpLut032Buf);
            }
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }
    }

    if (lpColMch->Ucr != UCRNOO &&                          // UCR & (Normal or First)?
       (lpColMch->Mch == MCHFST || lpColMch->Mch == MCHNML) ) {
                                                            // UCR table create
        MY_VERBOSE(("ColMchInfSet() ColUcrTblMak()\n"));
        if ((ColUcrTblMak(pdevobj, LutAdr)) == FALSE) {
            if (lpLutMakGlbBuf != NULL) {
                MemFree(lpLutMakGlbBuf);
            }
            if (lpLut032Buf != NULL) {
                MemFree(lpLut032Buf);
            }
            MemFree(hpLoad);
            CloseHandle(hFile);
            return FALSE;
        }
        MY_VERBOSE(("ColMchInfSet() ColUcrTblMak() OK!!\n"));
    }

    CloseHandle(hFile);

    lpColMch->ColQty = (DWORD)0;                            // The color designated number
    lpColMch->ColAdr = NULL;                                // Color designated table

    if ((pOEM->Col.CchRGB = MemAlloc(CCHRGBSIZ)) == NULL)  {
        return FALSE;
    }
    if ((pOEM->Col.CchCMYK = MemAlloc(CCHCMYSIZ)) == NULL)  {
        MemFree(pOEM->Col.CchRGB);
        return FALSE;
    }
    lpColMch->CchRgb = (LPRGB)pOEM->Col.CchRGB;
    lpColMch->CchCmy = (LPCMYK)pOEM->Col.CchCMYK;

    MY_VERBOSE(("ColMchInfSet() N501_ColCchIni()\n"));
    N501_ColCchIni(lpColMch);                               // Cache table initialize

    MY_VERBOSE(("ColMchInfSet() End\n"));
    return TRUE;
}


//===================================================================================================
//    Dither information setting
//===================================================================================================
BOOL DizInfSet(                                             // TRUE / FALSE
    PDEVOBJ        pdevobj                                  // Pointer to pdevobj structure
)
{
    LPDIZINF        lpDiz;                                  // Dither pattern information
    DWORD           dizSizC;                                // Dither pattern size(C)
    DWORD           dizSizM;                                // Dither pattern size(M)
    DWORD           dizSizY;                                // Dither pattern size(Y)
    DWORD           dizSizK;                                // Dither pattern size(K)
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("DizInfSet() Start\n"));
    lpDiz = pOEM->Col.Mch.lpDizInf;                         // Dither pattern information
    if (pOEM->Col.ColMon == CMMCOL) {                       // Color?
        lpDiz->ColMon = CMMCOL;
    } else {                                                // Mono
        lpDiz->ColMon = CMMMON;
    }                                                       // Get dither pattern
    if ((lpDiz->DizPat = (DWORD)GetDizPat(pdevobj)) == 0xff) {
        return TRUE;                                        // TRUE(Not dithering)
    }
    if (pOEM->Printer == PRN_N5) {                          // N5 printer
        if (pOEM->Col.wReso == DPI300) {                    // 300DPI?
            if (pOEM->Col.Dot == XX_TONE_2) {               // 2value?
                MY_VERBOSE(("DizInfSet() PrnMod=PRM302\n"));
                lpDiz->PrnMod = PRM302;
            } else {                                        // 16value
                MY_VERBOSE(("DizInfSet() PrnMod=PRM316\n"));
                lpDiz->PrnMod = PRM316;
            }
        } else {                                            // 600DPI
            if (pOEM->Col.Dot == XX_TONE_2) {               // 2value?
                MY_VERBOSE(("DizInfSet() PrnMod=PRM602\n"));
                lpDiz->PrnMod = PRM602;
            } else if (pOEM->Col.Dot == XX_TONE_4){         // 4value?
                MY_VERBOSE(("DizInfSet() PrnMod=PRM604\n"));
                lpDiz->PrnMod = PRM604;
            } else if (pOEM->Col.Dot == XX_TONE_16){        // 16value?
                MY_VERBOSE(("DizInfSet() PrnMod=PRM616\n"));
                lpDiz->PrnMod = PRM616;
            }
        }

        lpDiz->TblCyn = NULL;                               // To acquire dither pattern size
        lpDiz->TblMgt = NULL;
        lpDiz->TblYel = NULL;
        lpDiz->TblBla = NULL;

        MY_VERBOSE(("DizInfSet() DizFileOpen()\n"));
        lpDiz->DizKnd = KNDIMG;                             // Dither Kind
        if ((DizFileOpen(pdevobj, lpDiz)) == FALSE) {       // Get dither pattern size
            return FALSE;
        }
        dizSizC = lpDiz->SizCyn * lpDiz->SizCyn * lpDiz->DizSls;
        dizSizM = lpDiz->SizMgt * lpDiz->SizMgt * lpDiz->DizSls;
        dizSizY = lpDiz->SizYel * lpDiz->SizYel * lpDiz->DizSls;
        dizSizK = lpDiz->SizBla * lpDiz->SizBla * lpDiz->DizSls;
        MY_VERBOSE(("DizInfSet() dizSizC[%d] M[%d] Y[%d] K[%d]\n", dizSizC, dizSizM, dizSizY, dizSizK));
    }

    MY_VERBOSE(("DizInfSet() Dither pattern table area Alloc\n"));
    if (lpDiz->ColMon == CMMCOL) {                          // Color?
        lpDiz->SizCyn = dizSizC;                            // Dither pattern table(Cyan)
        if ((pOEM->Col.DizTbl[0] = MemAlloc(dizSizC)) == NULL) {
            return FALSE;
        }
        lpDiz->TblCyn = (LPBYTE)pOEM->Col.DizTbl[0];

        lpDiz->SizMgt = dizSizM;                            // Dither pattern table(Magenta)
        if ((pOEM->Col.DizTbl[1] = MemAlloc(dizSizM)) == NULL) {
            return FALSE;
        }
        lpDiz->TblMgt = (LPBYTE)pOEM->Col.DizTbl[1];

        lpDiz->SizYel = dizSizY;                            // Dither pattern table(Yellow)
        if ((pOEM->Col.DizTbl[2] = MemAlloc(dizSizY)) == NULL) {
            return FALSE;
        }
        lpDiz->TblYel = (LPBYTE)pOEM->Col.DizTbl[2];
    }

    lpDiz->SizBla = dizSizK;                                // Dither pattern table(Black)
    if ((pOEM->Col.DizTbl[3] = MemAlloc(dizSizK)) == NULL) {
        return FALSE;
    }
    lpDiz->TblBla = (LPBYTE)pOEM->Col.DizTbl[3];

    MY_VERBOSE(("DizInfSet() DizFileOpen()\n"));
    if ((DizFileOpen(pdevobj, lpDiz)) == FALSE) {           // Make dither pattern
        return FALSE;
    }

    MY_VERBOSE(("DizInfSet() End\n"));
    return TRUE;                                            // TRUE
}

//===================================================================================================
//    Get Dither pattern type
//===================================================================================================
UINT GetDizPat(                                             // Dither pattern(0xff: Not dithering)
    PDEVOBJ        pdevobj                                  // Pointer to pdevobj structure
)
{
    static const WORD DizNumTbl[XX_MAXDITH] = {DIZMID,      // DITH_IMG
                                            DIZRUG,         // DITH_GRP
                                            DIZSML,         // DITH_TXT
                                            0xff,           // DITH_GOSA
                                            DIZMID,         // DITH_NORMAL
                                            DIZMID,         // DITH_HS_NORMAL
                                            DIZSML,         // DITH_DETAIL
                                            DIZRUG,         // DITH_EMPTY
                                            DIZSTO,         // DITH_SPREAD
                                            DIZMID          // DITH_NON
    };
    UINT            dizPat;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;
    dizPat = DizNumTbl[pOEM->Col.Mch.Diz];
    return dizPat;
}


//===================================================================================================
//    Read dither file
//===================================================================================================
BOOL DizFileOpen(
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    LPDIZINF       lpDiz                                    // Dither pattern
)
{
    LPTSTR          drvPth;
    LPTSTR          filNam;
    DWORD           pthSiz;
    HANDLE          hFile;
    LPBYTE          lpDizBuf;
    LPBYTE          lpDizWrkBuf;
    DWORD           dwRet;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("DizFileOpen() Start\n"));

    if ((filNam = MemAllocZ(MAX_PATH * sizeof(TCHAR))) == NULL) {
        return FALSE;
    }
    pthSiz = GetModuleFileName(pdevobj->hOEM, filNam, MAX_PATH);
    pthSiz -= ((sizeof(CSN5RESDLL) / sizeof(WCHAR)) - 1);
    lstrcpy(&filNam[pthSiz], N501DIZ);                      // Dither file name (FULL PATH)

    MY_VERBOSE(("DIZ filNam [%ws]\n", filNam));
    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(filNam,
            GENERIC_READ, FILE_SHARE_READ, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL))) {

        ERR(("Error opening DIZ file %ws (%d)\n", filNam, GetLastError()));
        MemFree(filNam);
        return 0;
    }
    MemFree(filNam);

    if ((lpDizBuf = MemAlloc(DIZFILESIZ)) == NULL) {
        CloseHandle(hFile);
        return FALSE;
    }

    if ((lpDizWrkBuf = MemAlloc(DIZINFWRK)) == NULL) {
        MemFree(lpDizBuf);
        CloseHandle(hFile);
        return FALSE;
    }

    if (FALSE == ReadFile(hFile, lpDizBuf, DIZFILESIZ, &dwRet, NULL)) {

        ERR(("Error reading DIZ file %ws (%d)\n", filNam, GetLastError()));

        // Abort
        MemFree(lpDizWrkBuf);
        MemFree(lpDizBuf);
        CloseHandle(hFile);
        return FALSE;
    }

    MY_VERBOSE(("N501_ColDizInfSet()  ColMon=[%d] PrnMod=[%d] PrnKnd=[%d] DizKnd=[%d] DizPat=[%d]\n",
                lpDiz->ColMon, lpDiz->PrnMod, lpDiz->PrnKnd, lpDiz->DizKnd, lpDiz->DizPat));
    MY_VERBOSE(("                     DizSls=[%d] SizCyn=[%d] SizMgt=[%d] SizYel=[%d] SizBla=[%d]\n",
                lpDiz->DizSls, lpDiz->SizCyn, lpDiz->SizMgt, lpDiz->SizYel, lpDiz->SizBla));
    if ((N501_ColDizInfSet((LPBYTE)lpDizBuf, lpDiz, lpDizWrkBuf)) != ERRNON) {
        MemFree(lpDizWrkBuf);
        MemFree(lpDizBuf);
        CloseHandle(hFile);
        return FALSE;
    }

    MemFree(lpDizWrkBuf);
    MemFree(lpDizBuf);
    CloseHandle(hFile);
    MY_VERBOSE(("DizFileOpen() End\n"));

    return TRUE;
}

//#if defined(CPN5SERIES)                                       // N501
//===================================================================================================
//    Make UCR table
//===================================================================================================
BOOL ColUcrTblMak(                                          // TRUE / FALSE
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    LPCMYK         LutAdr                                   // LUT address
)
{
    LPCOLMCHINF     lpColMch;
    LPBYTE          lpUcrTbl;
    LPBYTE          lpUcrWrk;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("\nColUcrTblMak() MemAlloc(UCRTBLSIZ)\n"));
    lpColMch = pOEM->Col.Mch.lpColMch;
    if ((lpUcrTbl = MemAlloc(UCRTBLSIZ)) == NULL) {
        return FALSE;
    }
    MY_VERBOSE(("ColUcrTblMak() MemAlloc(UCRWRKSIZ)\n"));
    if ((lpUcrWrk = MemAlloc(UCRWRKSIZ)) == NULL) {
        MemFree(lpUcrTbl);
        return FALSE;
    }
    MY_VERBOSE(("ColUcrTblMak() N501_ColUcrTblMak()\n"));
    if ((N501_ColUcrTblMak(lpColMch->Mch, LutAdr, (LPCMYK)lpUcrTbl, lpUcrWrk)) != ERRNON) {
        MemFree(lpUcrWrk);
        MemFree(lpUcrTbl);
        return FALSE;
    }
    lpColMch->UcrTbl = (LPCMYK)lpUcrTbl;
    pOEM->Col.lpUcr = lpUcrTbl;
    MemFree(lpUcrWrk);

    MY_VERBOSE(("ColUcrTblMak() End\n"));
    return TRUE;
}

//===================================================================================================
//    Make Gray transfer table
//===================================================================================================
BOOL ColGryTblMak(                                          // TRUE / FALSE
    PDEVOBJ        pdevobj,                                 // Pointer to pdevobj structure
    LPCMYK          LutAdr                                  // LUT address
)
{
    LPCOLMCHINF     lpColMch;
    LPBYTE          lpGryTbl;
    LPBYTE          lpCmpBuf;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("\nColGryTblMak() \n"));
    lpColMch = pOEM->Col.Mch.lpColMch;

    if ((lpGryTbl = MemAlloc(GRYTBLSIZ)) == NULL) {         // Gray transfer table area
        return FALSE;
    }
    if ((lpCmpBuf = MemAlloc(LUTGLBWRK)) == NULL) {         // Gray transfer table work area
        MemFree(lpGryTbl);
        return FALSE;
    }
                                                            // Make Gray transfer table
    if ((N501_ColGryTblMak(lpColMch->Mch, LutAdr, lpGryTbl, lpCmpBuf)) != ERRNON) {
        MemFree(lpCmpBuf);
        MemFree(lpGryTbl);
        return FALSE;
    }

    lpColMch->GryTbl = (LPBYTE)lpGryTbl;
    pOEM->Col.lpGryTbl = lpGryTbl;
    MemFree(lpCmpBuf);
    MY_VERBOSE(("ColGryTblMak() End\n"));

    return TRUE;
}
//#endif

//#if defined(CPN5SERIES) || defined(CPE8SERIES)                                      // N501
//===================================================================================================
//    Make LUT table (MONO)
//===================================================================================================
BOOL ColLutMakGlbMon(                                       // TRUE / FALSE
    PDEVOBJ        pdevobj                                  // Pointer to pdevobj structure
)
{
    LPCOLMCHINF     lpColMch;
    LPRGB           lpRGB;
    LPBYTE          lpLutMakGlbBuf;
    LPBYTE          lpLutMakGlbWrk;
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE(("\nColLutMakGlbMon() \n"));
    lpColMch = pOEM->Col.Mch.lpColMch;
    lpRGB = NULL;                                           // Not sRGB

                                                            // Global LUT area
    if ((lpLutMakGlbBuf = MemAlloc(LUTMAKGLBSIZ)) == NULL) {
        return FALSE;
    }

    if ((lpLutMakGlbWrk = MemAlloc(LUTGLBWRK)) == NULL) {   // Global LUT work area
        MemFree(lpLutMakGlbBuf);
        return FALSE;
    }
                                                            // Make Gray transfer table (MONO)
    if ((N501_ColLutMakGlbMon(lpRGB, pOEM->Col.Mch.lpRGBInf, pOEM->Col.Mch.lpCMYKInf,
                          (LPCMYK)lpLutMakGlbBuf, lpLutMakGlbWrk)) != ERRNON) {
        MemFree(lpLutMakGlbWrk);
        MemFree(lpLutMakGlbBuf);
        return FALSE;
    }

    lpColMch->LutAdr = (LPCMYK)lpLutMakGlbBuf;
    pOEM->Col.lpLutMakGlb = lpLutMakGlbBuf;
    pOEM->Col.Mch.LutMakGlb = Yes;
    MemFree(lpLutMakGlbWrk);
    MY_VERBOSE(("ColLutMakGlbMon() End\n"));

    return TRUE;
}
//#endif

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\csn5res.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    Csn5res.c

Abstract:

    Implementation of GPD command callback for "Csn5j.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    09/10/97
        Created it.

--*/


#include "PDEV.H"
#include <stdio.h>
#include "PRNCTL.H"


//
// Misc definitions and declarations.
//
#define BUFFLEN                     256

#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

#define SWAPW(x) \
    ((WORD)(((WORD)(x))<<8)|(WORD)(((WORD)(x))>>8))

#define FONT_HEADER_SIZE            0x86            // format type 2
#define SIZE_SYMBOLSET              28
#define FONT_MIN_ID                 512
#define FONT_MAX_ID                 535
#define SJISCHR                     0x2000

#define IsValidDLFontID(x) \
    ((x) >= FONT_MIN_ID && (x) <= FONT_MAX_ID)

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes);

LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr);

//
// Command callback ID's
//
#define TEXT_FS_SINGLE_BYTE     21
#define TEXT_FS_DOUBLE_BYTE     22

#define DOWNLOAD_SET_FONT_ID    23
#define DOWNLOAD_SELECT_FONT_ID 24
#define DOWNLOAD_SET_CHAR_CODE  25
#define DOWNLOAD_DELETE_FONT    26

#define FS_BOLD_ON              27
#define FS_BOLD_OFF             28
#define FS_ITALIC_ON            29
#define FS_ITALIC_OFF           30

#define PC_BEGINDOC             82
#define PC_ENDDOC               83

#define PC_DUPLEX_NONE          90
#define PC_DUPLEX_VERT          91
#define PC_DUPLEX_HORZ          92
#define PC_PORTRAIT             93
#define PC_LANDSCAPE            94

#define PSRC_SELECT_CASETTE_1   100
#define PSRC_SELECT_CASETTE_2   101
#define PSRC_SELECT_CASETTE_3   102
#define PSRC_SELECT_CASETTE_4   103
#define PSRC_SELECT_CASETTE_5   104
#define PSRC_SELECT_CASETTE_6   105
#define PSRC_SELECT_MPF         106
#define PSRC_SELECT_AUTO        107

#define TONER_SAVE_NONE         110
#define TONER_SAVE_1            111
#define TONER_SAVE_2            112
#define SMOOTHING_ON            120
#define SMOOTHING_OFF           121
#define JAMRECOVERY_ON          130
#define JAMRECOVERY_OFF         131
#define MEDIATYPE_1             140
#define MEDIATYPE_2             141
#define MEDIATYPE_3             142
#define RECT_FILL_WIDTH         150
#define RECT_FILL_HEIGHT        151
#define RECT_FILL_GRAY          152
#define RECT_FILL_WHITE         153
#define RECT_FILL_BLACK         154

#define START_PAGE              160

#if 0   /* OEM doesn't want to fix minidriver */
/* Below is def. for hack code to fix #412276 */
#define COLOR_SELECT_BLACK      170
#define COLOR_SELECT_RED        171
#define COLOR_SELECT_GREEN      172
#define COLOR_SELECT_BLUE       173
#define COLOR_SELECT_YELLOW     174
#define COLOR_SELECT_MAGENTA    175
#define COLOR_SELECT_CYAN       176
#define COLOR_SELECT_WHITE      177

#define DUMP_RASTER_CYAN        180
#define DUMP_RASTER_MAGENTA     181
#define DUMP_RASTER_YELLOW      182
#define DUMP_RASTER_BLACK       183
/* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

#define OUTBIN_SELECT_EXIT_1    190
#define OUTBIN_SELECT_EXIT_2    191

#define DEFINE_PALETTE_ENTRY    300
#define BEGIN_PALETTE_DEF       301
#define END_PALETTE_DEF         302
#define SELECT_PALETTE_ENTRY    303

#define OPT_DITH_NORMAL         "Normal"
#define OPT_DITH_DETAIL         "Detail"
#define OPT_DITH_EMPTY          "Empty"
#define OPT_DITH_SPREAD         "Spread"
#define OPT_DITH_NON            "Diz_Off"

#define OPT_COLORMATCH_BRI      "ForBright"
#define OPT_COLORMATCH_BRIL     "ForBrightL"
#define OPT_COLORMATCH_TINT     "ForTint"
#define OPT_COLORMATCH_TINTL    "ForTintL"
#define OPT_COLORMATCH_VIV      "ForVivid"
#define OPT_COLORMATCH_NONE     "Mch_Off"

#define OPT_MONO                "Mono"
#define OPT_COLOR               "Color"
#define OPT_COLOR_SINGLE        "Color_Single"
#define OPT_COLOR_MANY          "Color_Many"
#define OPT_COLOR_MANY2         "Color_Many2"

#define OPT_1                   "Option1"
#define OPT_2                   "Option2"

#define OPT_CMYBLACK_GRYBLK     "GrayBlack"
#define OPT_CMYBLACK_BLKTYPE1   "BlackType1"
#define OPT_CMYBLACK_BLKTYPE2   "BlackType2"
#define OPT_CMYBLACK_BLACK      "Black"
#define OPT_CMYBLACK_TYPE1      "Type1"
#define OPT_CMYBLACK_TYPE2      "Type2"
#define OPT_CMYBLACK_NONE       "Non"

#define OPT_AUTO                "Auto"
#define OPT_RASTER              "Raster"
#define OPT_PRESSOFF            "PressOff"


//
// ---- S T R U C T U R E  D E F I N E ----
//
typedef BYTE * LPDIBITS;

typedef struct {
   WORD Integer;
   WORD Fraction;
} FRAC;

typedef struct {
    BYTE bFormat;
    BYTE bDataDir;
    WORD wCharCode;
    WORD wBitmapWidth;
    WORD wBitmapHeight;
    WORD wLeftOffset;
    WORD wAscent;
    FRAC CharWidth;
} ESCPAGECHAR;

typedef struct {
   WORD wFormatType;
   WORD wDataSize;
   WORD wSymbolSet;
   WORD wCharSpace;
   FRAC CharWidth;
   FRAC CharHeight;
   WORD wFontID;
   WORD wWeight;
   WORD wEscapement;
   WORD wItalic;
   WORD wLast;
   WORD wFirst;
   WORD wUnderline;
   WORD wUnderlineWidth;
   WORD wOverline;
   WORD wOverlineWidth;
   WORD wStrikeOut;
   WORD wStrikeOutWidth;
   WORD wCellWidth;
   WORD wCellHeight;
   WORD wCellLeftOffset;
   WORD wCellAscender;
   FRAC FixPitchWidth;
} ESCPAGEHEADER, FAR * LPESCPAGEHEADER;

//
// Static data to be used by this minidriver.
//

BYTE bit_mask[] = {0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe};

BYTE BEGINDOC_EJL_BEGIN[] =
    "\x1bz\x00\x80"
    "\x1b\x01@EJL \x0a"
    "@EJL SET";
BYTE BEGINDOC_EJL_END[] =
    " ERRORCODE=ON"
    "\x0a"
    "@EJL EN LA=ESC/PAGE\x0a";
BYTE BEGINDOC_EPG_END[] =
    "\x1DrhE\x1D\x32\x34ifF\x1D\x31\x34isE"
    "\x1D\x32iaF\x1D\x31\x30ifF"
    "\x1D\x31ipP"
    "\x1B\x7A\xD0\x01\x43\x61\x2A\x1B\x7A\x00\x01"
    "\x1D\x30pmP";
BYTE ENDDOC_EJL_RESET[] = "\x1drhE"
    "\x1b\x01@EJL \x0a"
    "\x1b\x01@EJL \x0a"
    "\x1bz\xb0\x00";

BYTE CMD_START_PAGE[] =
    "\x1Bz\xD0\x01" "Ca*\x1Bz\x00\x01"
    "\x1D" "1alfP\x1D" "1affP\x1D"
    "0;0;0clfP\x1D" "0X\x1D" "0Y";

BYTE SET_FONT_ID[]        = "\x1D%d;%ddh{F";
BYTE DLI_SELECT_FONT_ID[] = "\x1D%ddcF\x1D\x30;-%dcoP";
BYTE DLI_DELETE_FONT[]    = "\x1D%dddcF";
BYTE SET_SINGLE_BMP[]     = "\x1D%d;%dsc{F";
BYTE SET_DOUBLE_BMP[]     = "\x1D%d;%d;%dsc{F";
BYTE SET_WIDTH_TBL[]      = "\x1D%d;%dcw{F";

BYTE FS_SINGLE_BYTE[]     = "\x1D\x31;0mcF";
BYTE FS_DOUBLE_BYTE[]     = "\x1D\x31;1mcF";
BYTE PRN_DIRECTION[]      = "\x1D%droF";
BYTE SET_CHAR_OFFSET[]    = "\x1D\x30;%dcoP";
BYTE SET_CHAR_OFFSET_XY[] = "\x1D%d;%dcoP";
BYTE VERT_FONT_SET[]      = "\x1D%dvpC";
BYTE BOLD_SET[]           = "\x1D%dweF";
BYTE ITALIC_SET[]         = "\x1D%dslF";

BYTE ORG_MODE_IN[]        = "\x1Bz\xD0\x01";
BYTE ORG_MODE_OUT[]       = "\x1Bz\x00\x01";
BYTE PALETTE_SELECT[]     = "Cd,%d,%d*";
BYTE PALETTE_DEFINE[]     = "Cf,%d,%d,%d,%d,%d*";

BYTE RECT_FILL[] = 
    "\x1D" "1owE"
    "\x1D" "1tsE"
    "\x1D" "0;0;%dspE"
    "\x1D" "1dmG"
    "\x1D" "%d;%d;%d;%d;0rG"
// do not turn overwrite mode off since it
// has bad effect over white-on-black texts
//    "\x1D" "0owE"
    "\x1D" "0tsE";

BYTE OVERWRITE[] = 
    "\x1D" "1owE"
    "\x1D" "1tsE"
    "\x1D" "1;0;100spE";

#define PSRC_CASETTE_1  0
#define PSRC_CASETTE_2  1
#define PSRC_CASETTE_3  2
#define PSRC_CASETTE_4  3
#define PSRC_CASETTE_5  4
#define PSRC_CASETTE_6  5
#define PSRC_MPF        6
#define PSRC_AUTO       7
BYTE *EJL_SelectPsrc[] = {
   " PU=1", " PU=2", " PU=255", " PU=254", " PU=253", " PU=252", " PU=4", " PU=AU" };

BYTE *EJL_SelectOrient[] = {
   " ORIENTATION=PORTRAIT", " ORIENTATION=LANDSCAPE" };

BYTE *EJL_SelectRes[] = {
   " ##RZ=OFF",  " ##RZ=ON" };
BYTE *EPg_SelectRes[] = {
    "\x1D" "0;300;300drE\x1D" "1;300;300drE\x1D" "2;240;240drE",
    "\x1D" "0;600;600drE\x1D" "1;600;600drE\x1D" "2;240;240drE" };

BYTE *EJL_SetColorTone[] = {
    " ##LE=OFF", " ##LE=ON", " ##LE=16" };

#define DUPLEX_NONE   0
#define DUPLEX_SIDE   1
#define DUPLEX_UP     2
BYTE *EJL_SetDuplex[] = {
   " ##DC=OFF", " ##DC=DUPON", " ##DC=DUPUP" };

#define XX_TONER_NORMAL 0
#define XX_TONER_SAVE_1 1
#define XX_TONER_SAVE_2 2
BYTE *EJL_SetTonerSave[] = {
    " ##TS=NORMAL", " ##TS=1", " ##TS=2" };

BYTE *EJL_SetColorMode[] = {
    " ##CM=OFF", " ##CM=ON" };

#define XX_SMOOTHING_OFF 0
#define XX_SMOOTHING_ON  1
BYTE *EJL_SetSmoohing[] = {
    " RI=OFF", " RI=ON" };

#define XX_JAMRECOVERY_OFF 0
#define XX_JAMRECOVERY_ON  1
BYTE *EJL_SetJamRecovery[] = {
    " ##JC=OFF", " ##JC=ON" };

#define XX_MEDIATYPE_1 1
#define XX_MEDIATYPE_2 2
#define XX_MEDIATYPE_3 3
BYTE *EJL_SetMediaType[] = {
    " PK=NM", " PK=OS", " PK=TH" };

#define OUTBIN_EXIT_1 1
#define OUTBIN_EXIT_2 2
BYTE *EJL_SelectOutbin[] = {
   " ##ET=1", " ##ET=2" };

#if 0    /* OEM doesn't want to fix minidriver */
/* Below is def. for hack code to fix #412276 */
BYTE *COLOR_SELECT_COMMAND[] = {
    "\x1Bz\xD0\x01\x43\x63,0,0,0,255*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Black   */
    "\x1Bz\xD0\x01\x43\x62,255,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Red     */
    "\x1Bz\xD0\x01\x43\x62,0,255,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Green   */
    "\x1Bz\xD0\x01\x43\x62,0,0,255*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Blue    */
    "\x1Bz\xD0\x01\x43\x63,0,0,255,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Yellow  */
    "\x1Bz\xD0\x01\x43\x63,0,255,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Magenta */
    "\x1Bz\xD0\x01\x43\x63,255,0,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Cyan    */
    "\x1Bz\xD0\x01\x43\x63,0,0,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE"       /* White   */
};
DWORD COLOR_SELECT_COMMAND_LEN[] = { 42, 39, 39, 39, 42, 42, 42, 39 };

BYTE *DUMP_RASTER_COMMAND[] = {
    "\x1Bz\xD0\x01\x43\x63,255,0,0,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Cyan    */
    "\x1Bz\xD0\x01\x43\x63,0,255,0,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Magenta */
    "\x1Bz\xD0\x01\x43\x63,0,0,255,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Yellow  */
    "\x1Bz\xD0\x01\x43\x63,0,0,0,255*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE"       /* Black   */
};
#define DUMP_RASTER_COMMAND_LEN  31
/* End of hack code */
#endif   /* OEM doesn't want to fix minidriver */

#define MasterToDevice(p, i) \
     ((i) / ((PMYPDEV)(p))->iUnitFactor)

#define PARAM(p,n) \
    (*((p)+(n)))

VOID
VSetSelectDLFont(
    PDEVOBJ pdevobj,
    DWORD dwFontID)
{
    PMYPDEV pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    BYTE Cmd[BUFFLEN];
    WORD wlen = 0;

    wlen += (WORD)wsprintf(Cmd, DLI_SELECT_FONT_ID, 
        (dwFontID - FONT_MIN_ID), 0);

//    if(pOEM->fGeneral & FG_VERT) {
//        wlen += wsprintf(&Cmd[wlen], VERT_FONT_SET, 0);
//        pOEM->fGeneral &= ~FG_VERT;
//
//    }

    WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);

    pOEM->dwDLFontID = dwFontID;

    DL_VERBOSE(("Set/Select: dwFontID=%x\n", dwFontID));
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMEnablePDEV
//////////////////////////////////////////////////////////////////////////

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PMYPDEV         pOEM;
    BYTE            byOutput[64];
    DWORD           dwNeeded;
    DWORD           dwOptionsReturned;

    MY_VERBOSE(("\nOEMEnablePdev ENTRY\n"));

    if (!pdevobj->pdevOEM)
    {
        if (!(pdevobj->pdevOEM = MemAllocZ(sizeof(MYPDEV))))
        {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));
            return NULL;
        }
    }

    pOEM = (PMYPDEV)pdevobj->pdevOEM;

    pOEM->fGeneral = 0;
    pOEM->iEscapement = 0;
    pOEM->sHeightDiv = 0;
    pOEM->iDevCharOffset = 0;
    pOEM->iPaperSource = 0;
    pOEM->iDuplex = 0;
    pOEM->iTonerSave = 0;
    pOEM->iOrientation = 0;
    pOEM->iSmoothing = 0;
    pOEM->iJamRecovery = 0;
    pOEM->iMediaType = 0;
    pOEM->iOutBin = 0;                  //+N5
    pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
    pOEM->dwDLSelectFontID = UNKNOWN_DLFONT_ID;
    pOEM->dwDLSetFontID = UNKNOWN_DLFONT_ID;
    pOEM->wCharCode = 0;
    pOEM->iUnitFactor = 1;

    // Get MYPDEV member
    // ColorMatching
    if (!DRVGETDRIVERSETTING(pdevobj, "ColorMatching", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(ColorMatching) Failed\n"));
        pOEM->Printer = PRN_N5;
        pOEM->iColorMatching = XX_COLORMATCH_NONE;
    } else {
        MY_VERBOSE(("            ColorMatching:[%s]\n", byOutput));
        if (!strcmp(byOutput, OPT_COLORMATCH_BRI)) {
            pOEM->Printer = PRN_N5;
            pOEM->iColorMatching = XX_COLORMATCH_BRI;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_TINT)) {
            pOEM->Printer = PRN_N5;
            pOEM->iColorMatching = XX_COLORMATCH_TINT;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_VIV)) {
            pOEM->Printer = PRN_N5;
            pOEM->iColorMatching = XX_COLORMATCH_VIV;
        } else if (!strcmp(byOutput, OPT_COLORMATCH_NONE)) {
            pOEM->Printer = PRN_N5;
            pOEM->iColorMatching = XX_COLORMATCH_NONE;
        } else {
            pOEM->Printer = PRN_N5;
            pOEM->iColorMatching = XX_COLORMATCH_NONE;
        }
    }
    MY_VERBOSE(("            pOEM->Printer:[%d]\n", pOEM->Printer));
    MY_VERBOSE(("            pOEM->iColorMatching:[%d]\n", pOEM->iColorMatching));

    // Resolution
    if (!DRVGETDRIVERSETTING(pdevobj, "Resolution", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(Resolution) Failed\n"));
        pOEM->iResolution = XX_RES_300DPI;
    } else {
        MY_VERBOSE(("            Resolution:[%s]\n", byOutput));
        if (!strcmp(byOutput, OPT_1)) {
            pOEM->iResolution = XX_RES_300DPI;
            pOEM->iUnitFactor = 4;
            pOEM->sHeightDiv = 1;
        } else if (!strcmp(byOutput, OPT_2)) {
            pOEM->iResolution = XX_RES_600DPI;
            pOEM->iUnitFactor = 2;
            pOEM->sHeightDiv = 4;
        }
    }
    MY_VERBOSE(("            pOEM->iResolution:[%d]\n", pOEM->iResolution));
    MY_VERBOSE(("            pOEM->iUnitFactor:[%d]\n", pOEM->iUnitFactor));
    MY_VERBOSE(("            pOEM->sHeightDiv:[%d]\n", pOEM->sHeightDiv));

    // Dithering
    if (!DRVGETDRIVERSETTING(pdevobj, "Dithering", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(Dithering) Failed\n"));
        pOEM->iDithering = XX_DITH_NON;
    } else {
        MY_VERBOSE(("            Dithering:[%s]\n", byOutput));
        if (!strcmp(byOutput, OPT_DITH_NORMAL)) {
            pOEM->iDithering = XX_DITH_NORMAL;
        } else if (!strcmp(byOutput, OPT_DITH_DETAIL)) {
            pOEM->iDithering = XX_DITH_DETAIL;
        } else if (!strcmp(byOutput, OPT_DITH_EMPTY)) {
            pOEM->iDithering = XX_DITH_EMPTY;
        } else if (!strcmp(byOutput, OPT_DITH_SPREAD)) {
            pOEM->iDithering = XX_DITH_SPREAD;
        } else {
            pOEM->iDithering = XX_DITH_NON;
        }
    }
    MY_VERBOSE(("            pOEM->iDithering:[%d]\n", pOEM->iDithering));

    // BitFont
    if (!DRVGETDRIVERSETTING(pdevobj, "BitFont", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(BitFont) Failed\n"));
        pOEM->iBitFont = XX_BITFONT_OFF;
    } else {
        MY_VERBOSE(("            BitFont:[%s]\n", byOutput));
        if (!strcmp(byOutput, OPT_2)) {
            pOEM->iBitFont = XX_BITFONT_OFF;
        } else if (!strcmp(byOutput, OPT_1)) {
            pOEM->iBitFont = XX_BITFONT_ON;
        } else {
            pOEM->iBitFont = XX_BITFONT_OFF;
        }
    }
    MY_VERBOSE(("            pOEM->iBitFont:[%d]\n", pOEM->iBitFont));

    // CmyBlack
    if (!DRVGETDRIVERSETTING(pdevobj, "CmyBlack", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(CmyBlack) Failed\n"));
        pOEM->iCmyBlack = XX_CMYBLACK_NONE;
    } else {
        MY_VERBOSE(("            CmyBlack:[%s]\n", byOutput));
// CASIO 2001/02/15 ->
        if (pOEM->iDithering == XX_DITH_NON) {
            pOEM->iCmyBlack = XX_CMYBLACK_NONE;
//      if (!strcmp(byOutput, OPT_CMYBLACK_GRYBLK)) {
        } else if (!strcmp(byOutput, OPT_CMYBLACK_GRYBLK)) {
// CASIO 2001/02/15 <-
            pOEM->iCmyBlack = XX_CMYBLACK_GRYBLK;
        } else if (!strcmp(byOutput, OPT_CMYBLACK_BLKTYPE1)) {
            pOEM->iCmyBlack = XX_CMYBLACK_BLKTYPE1;
        } else if (!strcmp(byOutput, OPT_CMYBLACK_BLKTYPE2)) {
            pOEM->iCmyBlack = XX_CMYBLACK_BLKTYPE2;
        } else if (!strcmp(byOutput, OPT_CMYBLACK_BLACK)) {
            pOEM->iCmyBlack = XX_CMYBLACK_BLACK;
        } else if (!strcmp(byOutput, OPT_CMYBLACK_TYPE1)) {
            pOEM->iCmyBlack = XX_CMYBLACK_TYPE1;
        } else if (!strcmp(byOutput, OPT_CMYBLACK_TYPE2)) {
            pOEM->iCmyBlack = XX_CMYBLACK_TYPE2;
        } else {
            pOEM->iCmyBlack = XX_CMYBLACK_NONE;
        }
    }
    MY_VERBOSE(("            pOEM->iCmyBlack:[%d]\n", pOEM->iCmyBlack));

    // ColorMode
    if (!DRVGETDRIVERSETTING(pdevobj, "ColorMode", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(ColorMode) Failed\n"));
        pOEM->iColor = XX_COLOR;
    } else {
        MY_VERBOSE(("            ColorMode:[%s]\n", byOutput));
        if (!strcmp(byOutput, OPT_COLOR_SINGLE)) {
            pOEM->iColor = XX_COLOR_SINGLE;
        } else if (!strcmp(byOutput, OPT_COLOR_MANY)) {
            pOEM->iColor = XX_COLOR_MANY;
        } else if (!strcmp(byOutput, OPT_COLOR_MANY2)) {
            pOEM->iColor = XX_COLOR_MANY2;
        } else if (!strcmp(byOutput, OPT_COLOR)) {
            pOEM->iColor = XX_COLOR;
        } else if (!strcmp(byOutput, OPT_MONO)) {
            pOEM->iColor = XX_MONO;
        }
    }
    MY_VERBOSE(("            pOEM->iColor:[%d]\n", pOEM->iColor));

    // Compress
    if (!DRVGETDRIVERSETTING(pdevobj, "Compress", byOutput, 
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        ERR(("DrvGetDriverSetting(Compress) Failed\n"));
        pOEM->iCompress = XX_COMPRESS_OFF;
    } else {
        MY_VERBOSE(("            Compress:[%s]\n", byOutput));
        if (!strcmp(byOutput, OPT_AUTO)) {
            pOEM->iCompress = XX_COMPRESS_AUTO;
        } else if (!strcmp(byOutput, OPT_RASTER)) {
            pOEM->iCompress = XX_COMPRESS_RASTER;
        } else {
            pOEM->iCompress = XX_COMPRESS_OFF;
        }
    }
    MY_VERBOSE(("            pOEM->iCompress:[%d]\n", pOEM->iCompress));

    MY_VERBOSE(("            pdevobj->pPublicDM->dmICMMethod:[%d]\n", pdevobj->pPublicDM->dmICMMethod));
    if (pdevobj->pPublicDM->dmICMMethod == 1) {
        pOEM->iIcmMode = XX_ICM_NON;
    } else {
        pOEM->iIcmMode = XX_ICM_USE;
    }
    MY_VERBOSE(("            pOEM->iICMMethod:[%d]\n", pOEM->iIcmMode));

    if (pOEM->iColor == XX_COLOR_SINGLE 
     || pOEM->iColor == XX_COLOR_MANY 
     || pOEM->iColor == XX_COLOR_MANY2) {           //+N5
        if (ColMatchInit(pdevobj) == FALSE) {
            return NULL;
        }
    }
    MY_VERBOSE(("OEMEnablePdev END\n"));

    return pdevobj->pdevOEM;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMImageProcessing
//////////////////////////////////////////////////////////////////////////

PBYTE APIENTRY
OEMImageProcessing(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams)
{
    BOOL   bret;

    if (pIPParams->bBlankBand) {
        MY_VERBOSE(("BB=TRUE\n"));
        bret = TRUE;                // Not spool to printer
    }
    else {
        MY_VERBOSE(("BB=FALSE\n"));
        // DIB spool to printer
        bret = (DIBtoPrn(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable, pIPParams)) ? TRUE : FALSE;
    }

    return (PBYTE)IntToPtr(bret);
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDisablePDEV
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (pdevobj->pdevOEM)
    {
        if (pOEM->iColor == XX_COLOR_SINGLE 
         || pOEM->iColor == XX_COLOR_MANY
         || pOEM->iColor == XX_COLOR_MANY2) {       //+N5
            ColMatchDisable(pdevobj);
        }

        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}


BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PMYPDEV pOEMOld, pOEMNew;
    UINT            num001;

    MY_VERBOSE(("OEMResetPDEV() Start\n"));
    pOEMOld = (PMYPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PMYPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL) {
//        *pOEMNew = *pOEMOld;
        pOEMNew->fGeneral         = pOEMOld->fGeneral;
        pOEMNew->iEscapement      = pOEMOld->iEscapement;
        pOEMNew->sHeightDiv       = pOEMOld->sHeightDiv;
        pOEMNew->iDevCharOffset   = pOEMOld->iDevCharOffset;
        pOEMNew->iPaperSource     = pOEMOld->iPaperSource;
        pOEMNew->iDuplex          = pOEMOld->iDuplex;
        pOEMNew->iTonerSave       = pOEMOld->iTonerSave;
        pOEMNew->iOrientation     = pOEMOld->iOrientation;
        pOEMNew->iResolution      = pOEMOld->iResolution; 
        pOEMNew->iColor           = pOEMOld->iColor;
        pOEMNew->iSmoothing       = pOEMOld->iSmoothing;
        pOEMNew->iJamRecovery     = pOEMOld->iJamRecovery;
        pOEMNew->iMediaType       = pOEMOld->iMediaType;
        pOEMNew->iOutBin          = pOEMOld->iOutBin;
        pOEMNew->iIcmMode         = pOEMOld->iIcmMode;
        pOEMNew->iUnitFactor      = pOEMOld->iUnitFactor;
        pOEMNew->iDithering       = pOEMOld->iDithering;
        pOEMNew->iColorMatching   = pOEMOld->iColorMatching;
        pOEMNew->iBitFont         = pOEMOld->iBitFont;
        pOEMNew->iCmyBlack        = pOEMOld->iCmyBlack;
        pOEMNew->iTone            = pOEMOld->iTone;
        pOEMNew->iPaperSize       = pOEMOld->iPaperSize;
        pOEMNew->iCompress        = pOEMOld->iCompress;
        pOEMNew->Printer          = pOEMOld->Printer;
        pOEMNew->wRectWidth       = pOEMOld->wRectWidth;
        pOEMNew->wRectHeight      = pOEMOld->wRectHeight;
        pOEMNew->dwDLFontID       = pOEMOld->dwDLFontID;
        pOEMNew->dwDLSelectFontID = pOEMOld->dwDLSelectFontID;
        pOEMNew->dwDLSetFontID    = pOEMOld->dwDLSetFontID;
        pOEMNew->wCharCode        = pOEMOld->wCharCode;

        pOEMNew->Col.wReso        = pOEMOld->Col.wReso;
        pOEMNew->Col.ColMon       = pOEMOld->Col.ColMon;
        pOEMNew->Col.DatBit       = pOEMOld->Col.DatBit;
        pOEMNew->Col.BytDot       = pOEMOld->Col.BytDot;
        pOEMNew->Col.Mch.Mode     = pOEMOld->Col.Mch.Mode;
        pOEMNew->Col.Mch.GryKToner= pOEMOld->Col.Mch.GryKToner;
        pOEMNew->Col.Mch.Viv      = pOEMOld->Col.Mch.Viv;
        pOEMNew->Col.Mch.LutNum   = pOEMOld->Col.Mch.LutNum;
        pOEMNew->Col.Mch.Diz      = pOEMOld->Col.Mch.Diz;
        pOEMNew->Col.Mch.Tnr      = pOEMOld->Col.Mch.Tnr;
        pOEMNew->Col.Mch.CmyBlk   = pOEMOld->Col.Mch.CmyBlk;
        pOEMNew->Col.Mch.Speed    = pOEMOld->Col.Mch.Speed;
        pOEMNew->Col.Mch.Gos32    = pOEMOld->Col.Mch.Gos32;
        pOEMNew->Col.Mch.PColor   = pOEMOld->Col.Mch.PColor;
        pOEMNew->Col.Mch.Ucr      = pOEMOld->Col.Mch.Ucr;
        pOEMNew->Col.Mch.SubDef   = pOEMOld->Col.Mch.SubDef;
        pOEMNew->Col.Mch.Bright   = pOEMOld->Col.Mch.Bright;
        pOEMNew->Col.Mch.Contrast = pOEMOld->Col.Mch.Contrast;
        pOEMNew->Col.Mch.GamRed   = pOEMOld->Col.Mch.GamRed;
        pOEMNew->Col.Mch.GamGreen = pOEMOld->Col.Mch.GamGreen;
        pOEMNew->Col.Mch.GamBlue  = pOEMOld->Col.Mch.GamBlue;
        pOEMNew->Col.Mch.CchMch   = pOEMOld->Col.Mch.CchMch;
        pOEMNew->Col.Mch.CchCnv   = pOEMOld->Col.Mch.CchCnv;
        pOEMNew->Col.Mch.CchRGB   = pOEMOld->Col.Mch.CchRGB;
        pOEMNew->Col.Mch.CchCMYK  = pOEMOld->Col.Mch.CchCMYK;
        pOEMNew->Col.Mch.LutMakGlb= pOEMOld->Col.Mch.LutMakGlb;
        pOEMNew->Col.Mch.KToner   = pOEMOld->Col.Mch.KToner;

        pOEMNew->Col.Dot  = pOEMOld->Col.Dot;
        if (NULL != pOEMNew->Col.lpColIF) { MemFree(pOEMNew->Col.lpColIF); }
        pOEMNew->Col.lpColIF = pOEMOld->Col.lpColIF;
        pOEMOld->Col.lpColIF = NULL;
        pOEMNew->Col.Mch.lpRGBInf = pOEMOld->Col.Mch.lpRGBInf;
        pOEMNew->Col.Mch.lpCMYKInf = pOEMOld->Col.Mch.lpCMYKInf;
        pOEMNew->Col.Mch.lpColMch = pOEMOld->Col.Mch.lpColMch;
        pOEMNew->Col.Mch.lpDizInf = pOEMOld->Col.Mch.lpDizInf;
        pOEMOld->Col.Mch.lpRGBInf = NULL;
        pOEMOld->Col.Mch.lpCMYKInf = NULL;
        pOEMOld->Col.Mch.lpColMch = NULL;
        pOEMOld->Col.Mch.lpDizInf = NULL;
        if (NULL != pOEMNew->Col.LutTbl) { MemFree(pOEMNew->Col.LutTbl); }
        pOEMNew->Col.LutTbl = pOEMOld->Col.LutTbl;
        pOEMOld->Col.LutTbl = NULL;
        if (NULL != pOEMNew->Col.CchRGB) { MemFree(pOEMNew->Col.CchRGB); }
        pOEMNew->Col.CchRGB = pOEMOld->Col.CchRGB;
        pOEMOld->Col.CchRGB = NULL;
        if (NULL != pOEMNew->Col.CchCMYK) { MemFree(pOEMNew->Col.CchCMYK); }
        pOEMNew->Col.CchCMYK = pOEMOld->Col.CchCMYK;
        pOEMOld->Col.CchCMYK = NULL;
        for (num001 = 0; num001 < 4; num001++) {
            if (NULL != pOEMNew->Col.DizTbl[num001]) { MemFree(pOEMNew->Col.DizTbl[num001]); }
            pOEMNew->Col.DizTbl[num001] = pOEMOld->Col.DizTbl[num001];
            pOEMOld->Col.DizTbl[num001] = NULL;
        }
        if (NULL != pOEMNew->Col.lpTmpRGB) { MemFree(pOEMNew->Col.lpTmpRGB); }
        pOEMNew->Col.lpTmpRGB = pOEMOld->Col.lpTmpRGB;
        pOEMOld->Col.lpTmpRGB = NULL;
        if (NULL != pOEMNew->Col.lpTmpCMYK) { MemFree(pOEMNew->Col.lpTmpCMYK); }
        pOEMNew->Col.lpTmpCMYK = pOEMOld->Col.lpTmpCMYK;
        pOEMOld->Col.lpTmpCMYK = NULL;
        if (NULL != pOEMNew->Col.lpDrwInf) { MemFree(pOEMNew->Col.lpDrwInf); }
        pOEMNew->Col.lpDrwInf = pOEMOld->Col.lpDrwInf;
        pOEMOld->Col.lpDrwInf = NULL;
        if (NULL != pOEMNew->Col.lpLut032) { MemFree(pOEMNew->Col.lpLut032); }
        pOEMNew->Col.lpLut032 = pOEMOld->Col.lpLut032;
        pOEMOld->Col.lpLut032 = NULL;
        if (NULL != pOEMNew->Col.lpUcr) { MemFree(pOEMNew->Col.lpUcr); }
        pOEMNew->Col.lpUcr = pOEMOld->Col.lpUcr;
        pOEMOld->Col.lpUcr = NULL;
        if (NULL != pOEMNew->Col.lpLutMakGlb) { MemFree(pOEMNew->Col.lpLutMakGlb); }
        pOEMNew->Col.lpLutMakGlb = pOEMOld->Col.lpLutMakGlb;
        pOEMOld->Col.lpLutMakGlb = NULL;
        if (NULL != pOEMNew->Col.lpGryTbl) { MemFree(pOEMNew->Col.lpGryTbl); }
        pOEMNew->Col.lpGryTbl = pOEMOld->Col.lpGryTbl;
        pOEMOld->Col.lpGryTbl = NULL;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMCommandCallback
//////////////////////////////////////////////////////////////////////////

INT
APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT             iRet = 0;
    BYTE            Cmd[BUFFLEN];
    PMYPDEV         pOEM;
    WORD            wlen;
    WORD            wGray;
    DWORD           dwTempX, dwTempY;
    CMYK            TmpCmyk;
    RGBS            TmpRgb;
// MSKK 99/6/24
    WORD            wPalID;

    MY_VERBOSE(("OEMCommandCallback() entry.\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    switch (dwCmdCbID) {
    case FS_BOLD_ON:
    case FS_BOLD_OFF:
        if(pdwParams[0])
            pOEM->fGeneral |=  FG_BOLD;
        else
            pOEM->fGeneral &=  ~FG_BOLD;

        wlen = (WORD)wsprintf(Cmd,BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0);
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

    case FS_ITALIC_ON:
    case FS_ITALIC_OFF:
        if(pdwParams[0])
            pOEM->fGeneral |=  FG_ITALIC;
        else
            pOEM->fGeneral &=  ~FG_ITALIC;

        wlen = (WORD)wsprintf(Cmd,ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0);
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

    case TEXT_FS_SINGLE_BYTE:
        strcpy(Cmd,FS_SINGLE_BYTE);
        wlen = (WORD)strlen( Cmd );
        wlen += (WORD)wsprintf(&Cmd[wlen],PRN_DIRECTION,pOEM->iEscapement);
        if (pOEM->fGeneral & FG_VERT)
        {
            wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 0);
        }
        pOEM->fGeneral &= ~FG_DOUBLE;
        wlen += (WORD)wsprintf(&Cmd[wlen],BOLD_SET, 
                         (pOEM->fGeneral & FG_BOLD)?15:0);
        wlen += (WORD)wsprintf(&Cmd[wlen],ITALIC_SET,
                         (pOEM->fGeneral & FG_ITALIC)?346:0);
        WRITESPOOLBUF(pdevobj, Cmd, wlen);
        break;

    case TEXT_FS_DOUBLE_BYTE:
        strcpy(Cmd,FS_DOUBLE_BYTE);
        wlen = (WORD)strlen( Cmd );
        wlen += (WORD)wsprintf(&Cmd[wlen],PRN_DIRECTION,pOEM->iEscapement);
        if (pOEM->fGeneral & FG_VERT)
        {
            wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 1);
        }
        pOEM->fGeneral |= FG_DOUBLE;
        wlen += (WORD)wsprintf(&Cmd[wlen],BOLD_SET, 
                         (pOEM->fGeneral & FG_BOLD)?15:0);
        wlen += (WORD)wsprintf(&Cmd[wlen],ITALIC_SET, 
                         (pOEM->fGeneral & FG_ITALIC)?346:0);
        WRITESPOOLBUF(pdevobj, Cmd, wlen);
        break;

    case PC_PORTRAIT:
        pOEM->iOrientation = 0;
        break;

    case PC_LANDSCAPE:
        pOEM->iOrientation = 1;
        break;

    case PC_DUPLEX_NONE:
        pOEM->iDuplex = (DUPLEX_NONE + 1);
        break;

    case PC_DUPLEX_VERT:
        pOEM->iDuplex =
                (pOEM->iOrientation ?
                (DUPLEX_UP + 1) : (DUPLEX_SIDE + 1));
        break;

    case PC_DUPLEX_HORZ:
        pOEM->iDuplex =
                (pOEM->iOrientation ?
                (DUPLEX_SIDE + 1) : (DUPLEX_UP + 1));
        break;

    case PSRC_SELECT_MPF:
        pOEM->iPaperSource = PSRC_MPF;
        break;

    case PSRC_SELECT_CASETTE_1:
        pOEM->iPaperSource = PSRC_CASETTE_1;
        break;

    case PSRC_SELECT_CASETTE_2:
        pOEM->iPaperSource = PSRC_CASETTE_2;
        break;

    case PSRC_SELECT_CASETTE_3:
        pOEM->iPaperSource = PSRC_CASETTE_3;
        break;

    case PSRC_SELECT_CASETTE_4:
        pOEM->iPaperSource = PSRC_CASETTE_4;
        break;

    case PSRC_SELECT_CASETTE_5:
        pOEM->iPaperSource = PSRC_CASETTE_5;
        break;

    case PSRC_SELECT_CASETTE_6:
        pOEM->iPaperSource = PSRC_CASETTE_6;
        break;

    case PSRC_SELECT_AUTO:
        pOEM->iPaperSource = PSRC_AUTO;
        break; 

    case PC_BEGINDOC:
        // EJL commands
        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EJL_BEGIN,
            BYTE_LENGTH(BEGINDOC_EJL_BEGIN));

        wlen = 0;
        strcpy( &Cmd[wlen],  EJL_SelectPsrc[pOEM->iPaperSource] );
        wlen += (WORD)strlen( &Cmd[wlen] );
        strcpy( &Cmd[wlen], EJL_SelectOrient[pOEM->iOrientation] );
        wlen += (WORD)strlen( &Cmd[wlen] );

        // CASIO extention

        strcpy( &Cmd[wlen],  EJL_SelectRes[pOEM->iResolution] );
        wlen += (WORD)strlen( &Cmd[wlen] );
        if (pOEM->iColor > 0) {
            strcpy( &Cmd[wlen],  EJL_SetColorMode[1] );
            wlen += (WORD)strlen( &Cmd[wlen] );
        }

        if (pOEM->iDuplex > 0) {
            strcpy( &Cmd[wlen],  EJL_SetDuplex[pOEM->iDuplex - 1] );
            wlen += (WORD)strlen( &Cmd[wlen] );
        }

        if (pOEM->iColor == XX_COLOR_MANY) {
            strcpy( &Cmd[wlen],  EJL_SetColorTone[1] );
        } else if (pOEM->iColor == XX_COLOR_MANY2) {
            strcpy( &Cmd[wlen],  EJL_SetColorTone[2] );
        } else {
            strcpy( &Cmd[wlen],  EJL_SetColorTone[0] );
        }
        wlen += (WORD)strlen( &Cmd[wlen] );

        strcpy( &Cmd[wlen],  EJL_SetTonerSave[pOEM->iTonerSave] );
        wlen += (WORD)strlen( &Cmd[wlen] );

        strcpy( &Cmd[wlen],  EJL_SetSmoohing[pOEM->iSmoothing] );
        wlen += (WORD)strlen( &Cmd[wlen] );

        strcpy( &Cmd[wlen],  EJL_SetJamRecovery[pOEM->iJamRecovery] );
        wlen += (WORD)strlen( &Cmd[wlen] );

        strcpy( &Cmd[wlen], " ##SN=ON");
        wlen += (WORD)strlen( &Cmd[wlen] );

        if (pOEM->iMediaType > 0) {
            strcpy( &Cmd[wlen],  EJL_SetMediaType[pOEM->iMediaType - 1] );
            wlen += (WORD)strlen( &Cmd[wlen] );
        }
//+N5 Begin
        if (pOEM->iOutBin > 0) {
            strcpy( &Cmd[wlen],  EJL_SelectOutbin[pOEM->iOutBin -1] );
            wlen += (WORD)strlen( &Cmd[wlen] );
        }
//+N5 End

        WRITESPOOLBUF(pdevobj, Cmd, wlen );

        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EJL_END,
            BYTE_LENGTH(BEGINDOC_EJL_END));
        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EPG_END,
            BYTE_LENGTH(BEGINDOC_EPG_END));

        if(pOEM->iResolution == XX_RES_300DPI)
            WRITESPOOLBUF(pdevobj, "\x1D\x30;0.24muE", 10);
        else
            WRITESPOOLBUF(pdevobj, "\x1D\x30;0.12muE", 10);

        // ESC/Page commands
        wlen = 0;
        strcpy( &Cmd[wlen],  EPg_SelectRes[pOEM->iResolution] );
        wlen += (WORD)strlen( &Cmd[wlen] );
        WRITESPOOLBUF(pdevobj, Cmd, wlen );

        // Clear dwDLFontID
        // (There are data that contains a plural pages and
        //  also each page has different color mode.
        //  When page is changed, STARTDOC commands are spooled.
        //  It means that new DL font is set.
        //  That is why dwDLFontID got to be claer.)
        pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
        break;

    case PC_ENDDOC:
        WRITESPOOLBUF(pdevobj,
            ENDDOC_EJL_RESET,
            BYTE_LENGTH(ENDDOC_EJL_RESET));
        break;

    case TONER_SAVE_NONE:
        pOEM->iTonerSave = XX_TONER_NORMAL;
        break;

    case TONER_SAVE_1:
        pOEM->iTonerSave = XX_TONER_SAVE_1;
        break;

    case TONER_SAVE_2:
        pOEM->iTonerSave = XX_TONER_SAVE_2;
        break;

    case SMOOTHING_ON:
        pOEM->iSmoothing = XX_SMOOTHING_ON;
        break;

    case SMOOTHING_OFF:
        pOEM->iSmoothing = XX_SMOOTHING_OFF;
        break;

    case JAMRECOVERY_ON:
        pOEM->iJamRecovery = XX_JAMRECOVERY_ON;
        break;

    case JAMRECOVERY_OFF:
        pOEM->iJamRecovery = XX_JAMRECOVERY_OFF;
        break;

    case MEDIATYPE_1:
        pOEM->iMediaType = XX_MEDIATYPE_1;
        break;

    case MEDIATYPE_2:
        pOEM->iMediaType = XX_MEDIATYPE_2;
        break;
    case MEDIATYPE_3:
        pOEM->iMediaType = XX_MEDIATYPE_3;
        break;

    case OUTBIN_SELECT_EXIT_1:
        pOEM->iOutBin = OUTBIN_EXIT_1;
        break;

    case OUTBIN_SELECT_EXIT_2:
        pOEM->iOutBin = OUTBIN_EXIT_2;
        break;

    case DEFINE_PALETTE_ENTRY:
        //RGB -> CMYK
        TmpRgb.Red  = (BYTE)(PARAM(pdwParams, 1));
        TmpRgb.Grn  = (BYTE)(PARAM(pdwParams, 2));
        TmpRgb.Blu  = (BYTE)(PARAM(pdwParams, 3));

        memset(&TmpCmyk, 0x00, sizeof(TmpCmyk)); 
        ColMatching(pdevobj, No, No, &TmpRgb, (WORD)1, &TmpCmyk);

        wPalID = (WORD)(PARAM(pdwParams, 0));
        WRITESPOOLBUF(pdevobj, ORG_MODE_IN, BYTE_LENGTH(ORG_MODE_IN));
        wlen = (WORD)wsprintf(Cmd, PALETTE_DEFINE, wPalID, TmpCmyk.Cyn,
            TmpCmyk.Mgt, TmpCmyk.Yel, TmpCmyk.Bla);
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));

        MY_VERBOSE(("DEFINE_PALETTE_ENTRY No %d\n",
            (INT)(PARAM(pdwParams, wPalID))));
        break;

    case BEGIN_PALETTE_DEF:
        MY_VERBOSE(("CmdBeginPaletteDef\n"));
        break;

    case END_PALETTE_DEF:
        MY_VERBOSE(("CmdEndPaletteDef\n"));
        break;

    case SELECT_PALETTE_ENTRY:
        MY_VERBOSE(("SELECT_PALETTE_ENTRY "));

        wPalID = (WORD)(PARAM(pdwParams, 0));
        WRITESPOOLBUF(pdevobj, ORG_MODE_IN, BYTE_LENGTH(ORG_MODE_IN));
        wlen = (WORD)wsprintf(Cmd, PALETTE_SELECT, 0, wPalID);

        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));
        WRITESPOOLBUF(pdevobj, OVERWRITE, BYTE_LENGTH(OVERWRITE));
        break;

    case START_PAGE:
        MY_VERBOSE(("OEMCommandCallback() START_PAGE Start\n"));
        WRITESPOOLBUF(pdevobj, CMD_START_PAGE, BYTE_LENGTH(CMD_START_PAGE));

        if (pOEM->iColor == XX_COLOR_MANY 
         || pOEM->iColor == XX_COLOR_MANY2                  //+N5
         || pOEM->iColor == XX_COLOR_SINGLE) {
            //Initialize palette state (Spools pure black color command)
            wlen = 0;
            TmpRgb.Red = TmpRgb.Grn = TmpRgb.Blu = 0;
            MY_VERBOSE(("OEMCommandCallback() ColMatching()\n"));
            ColMatching(pdevobj, No, No, &TmpRgb, (WORD)1, &TmpCmyk);
            
            strcpy( &Cmd[wlen], ORG_MODE_IN );
            wlen += (WORD)strlen( &Cmd[wlen] );
            wlen += (WORD)wsprintf(&Cmd[wlen], PALETTE_DEFINE,
                DEFAULT_PALETTE_INDEX,
                TmpCmyk.Cyn, TmpCmyk.Mgt, TmpCmyk.Yel, TmpCmyk.Bla);
            wlen += (WORD)wsprintf(&Cmd[wlen], PALETTE_SELECT,
                0, DEFAULT_PALETTE_INDEX);
            WRITESPOOLBUF(pdevobj, Cmd, wlen);
            WRITESPOOLBUF(pdevobj, ORG_MODE_OUT, BYTE_LENGTH(ORG_MODE_OUT));
        }
        MY_VERBOSE(("OEMCommandCallback() START_PAGE End\n"));
        break;

    case DOWNLOAD_SET_FONT_ID:

        if (!IsValidDLFontID(pdwParams[0])) {

            // Must not happen!!
            ERR(("DLSetFontID: Soft font ID %x invalid.\n",
                pdwParams[0]));
            break;
        }

        // Actual printer command is sent
        // within DownloadCharGlyph.
        pOEM->dwDLSetFontID = pdwParams[0];

        DL_VERBOSE(("SetFontID: dwDLSetFontID=%x\n",
            pOEM->dwDLSetFontID));
        break;

    case DOWNLOAD_SELECT_FONT_ID:

        if (!IsValidDLFontID(pdwParams[0])) {

            // Must not happen!!
            ERR(("DLSelectFontID: Soft font ID %x invalid.\n",
                pdwParams[0]));
            break;
        }

        pOEM->dwDLSelectFontID = pdwParams[0];

        DL_VERBOSE(("SelectFontID: dwDLSelectFontID=%x\n",
            pOEM->dwDLSelectFontID));

        if (pOEM->dwDLFontID != pOEM->dwDLSelectFontID)
            VSetSelectDLFont(pdevobj, pOEM->dwDLSelectFontID);
        break;

    case DOWNLOAD_SET_CHAR_CODE:
        pOEM->wCharCode=(WORD)pdwParams[0];
        break;

    case DOWNLOAD_DELETE_FONT:

        DL_VERBOSE(("DLDeleteFont: dwDLFontID=%x, %x\n",
            pOEM->dwDLFontID, pdwParams[0]));

        wlen = (WORD)wsprintf(Cmd, DLI_DELETE_FONT, (WORD)pdwParams[0]-FONT_MIN_ID);
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
        break;

    case RECT_FILL_WIDTH:
        pOEM->wRectWidth =
            (WORD)MasterToDevice(pOEM, pdwParams[0]);
        break;

    case RECT_FILL_HEIGHT:
        pOEM->wRectHeight =
            (WORD)MasterToDevice(pOEM, pdwParams[0]);
        break;

    case RECT_FILL_GRAY:
    case RECT_FILL_WHITE:
    case RECT_FILL_BLACK:
        if (RECT_FILL_GRAY == dwCmdCbID)
            wGray = (WORD)pdwParams[2];
        else if (RECT_FILL_WHITE == dwCmdCbID)
            wGray = 0;
        else
            wGray = 100;

        dwTempX = MasterToDevice(pOEM, pdwParams[0]);
        dwTempY = MasterToDevice(pOEM, pdwParams[1]);

        MY_VERBOSE(("RectFill:%d,x=%d,y=%d,w=%d,h=%d\n",
            wGray,
            (WORD)dwTempX,
            (WORD)dwTempY,
            pOEM->wRectWidth,
            pOEM->wRectHeight));

        wlen = (WORD)wsprintf(Cmd, RECT_FILL,
            wGray,
            (WORD)dwTempX,
            (WORD)dwTempY,
            (WORD)(dwTempX + pOEM->wRectWidth - 1),
            (WORD)(dwTempY + pOEM->wRectHeight - 1));
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    case COLOR_SELECT_BLACK:
    case COLOR_SELECT_RED:
    case COLOR_SELECT_GREEN:
    case COLOR_SELECT_BLUE:
    case COLOR_SELECT_YELLOW:
    case COLOR_SELECT_MAGENTA:
    case COLOR_SELECT_CYAN:
    case COLOR_SELECT_WHITE:
        /* Remember what color is select */
        pOEM->dwSelectedColor = dwCmdCbID;
        pOEM->iColorMayChange = 0;         /* Reset flag */

        /* Output Color Select Command */
        /* The logic supposes COLOR_SELECT_xxx starts with COLOR_SELECT_BLACK */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)COLOR_SELECT_COMMAND[dwCmdCbID - COLOR_SELECT_BLACK],
                       COLOR_SELECT_COMMAND_LEN[dwCmdCbID - COLOR_SELECT_BLACK] );
        break;

    case DUMP_RASTER_CYAN:
    case DUMP_RASTER_MAGENTA:
    case DUMP_RASTER_YELLOW:
    case DUMP_RASTER_BLACK:
        /* Remember what color may change */
        pOEM->iColorMayChange = 1;         /* Set flag */

        /* Output Dump Raster Command */
        /* The logic supposes DUMP_RASTER_xxx starts with DUMP_RASTER_CYAN */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)DUMP_RASTER_COMMAND[dwCmdCbID - DUMP_RASTER_CYAN],
                       DUMP_RASTER_COMMAND_LEN );
        break;

    /* End of hack code */
#endif   /* OEM doesn't want to fix minidriver */

    default:
        ERR(("Unknown callback ID = %d.\n", dwCmdCbID));
    }
    return iRet;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMSendFontCmdk
//////////////////////////////////////////////////////////////////////////

VOID
APIENTRY
OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[2+2*4];
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        aubCmd[128];
    PIFIMETRICS pIFI;
    DWORD       height, width;
    PMYPDEV pOEM;
    BYTE    Cmd[128];
    WORD    wlen;
    DWORD   dwNeeded;
    DWORD dwTemp;

    SC_VERBOSE(("OEMSendFontCmd() entry.\n"));

    pubCmd = pFInv->pubCommand;
    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    SC_VERBOSE(("ulFontID=%x\n", pUFObj->ulFontID));
    SC_VERBOSE(("FONTHEIGHT=%d\n", pSV->StdVar[0].lStdVariable));
    SC_VERBOSE(("FONTWIDTH=%d\n", pSV->StdVar[1].lStdVariable));

    // Initialize pOEM
    if (pIFI->jWinCharSet == 0x80)
        pOEM->fGeneral |= FG_DOUBLE;
    else
        pOEM->fGeneral &= ~FG_DOUBLE;
    pOEM->fGeneral &=  ~FG_BOLD;
    pOEM->fGeneral &=  ~FG_ITALIC;

    if('@' == *((LPSTR)pIFI+pIFI->dpwszFaceName))
        pOEM->fGeneral |= FG_VERT;
    else
        pOEM->fGeneral &= ~FG_VERT;

    if (pIFI->jWinPitchAndFamily & 0x01)
        pOEM->fGeneral &= ~FG_PROP;
    else
        pOEM->fGeneral |= FG_PROP;

    dwOut = 0;
    pOEM->fGeneral &= ~FG_DBCS;

    for( dwIn = 0; dwIn < pFInv->dwCount;) {
        if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'V') {
            // Specify font height in device unit (current
            // output resolution).  Note Unidrv gives us
            // font-height in master units
            height = pSV->StdVar[0].lStdVariable * 100;
            height = MasterToDevice(pOEM, height);
            SC_VERBOSE(("Height=%d\n", height));
            dwOut += LConvertFontSizeToStr(height, &aubCmd[dwOut]);
            dwIn += 2;
        } else if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'H') {
            if (pubCmd[dwIn+2] == 'S') {
                SC_VERBOSE(("HS: "));
                width = pSV->StdVar[1].lStdVariable;
                dwIn += 3;
                pOEM->fGeneral |= FG_DBCS;
            } else if (pubCmd[dwIn+2] == 'D') {
                SC_VERBOSE(("HD: "));
                width = pSV->StdVar[1].lStdVariable * 2;
                dwIn += 3;
                pOEM->fGeneral |= FG_DBCS;
            } else {
                SC_VERBOSE(("H: "));
                if (pSV->StdVar[1].lStdVariable)
                    width = pSV->StdVar[1].lStdVariable;
                else
                    width = pIFI->fwdAveCharWidth;
                dwIn += 2;
            }
            // Specify font width in CPI.
            width = (MASTER_UNIT * 100L) / width;
            SC_VERBOSE(("Width=%d\n", width));
            dwOut += LConvertFontSizeToStr(width, &aubCmd[dwOut]);
        } else {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }

    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

#if 0 //MSKK 98/12/22
    pOEM->iDevCharOffset = (pIFI->fwdWinDescender * pSV->StdVar[0].lStdVariable * 72)
                          / (pIFI->fwdUnitsPerEm * pSV->StdVar[2].lStdVariable / pOEM->sHeightDiv);
#else
    // Unidrv gives us raw IFIMETRICS block so we need to
    // translate its members into meaningful values.  n.b.
    // we assume font height passed from Unidrv = em value.
    dwTemp = MasterToDevice(pOEM, pSV->StdVar[0].lStdVariable)
        * pIFI->fwdWinDescender;
    dwTemp /= pIFI->fwdUnitsPerEm;
    pOEM->iDevCharOffset = (short)dwTemp;
#endif

    MY_VERBOSE(("Descender=%d\n", pOEM->iDevCharOffset));

    wlen = (WORD)wsprintf(Cmd, SET_CHAR_OFFSET,
        (pOEM->fGeneral & FG_DBCS)?pOEM->iDevCharOffset:0);

    if (pOEM->fGeneral & FG_VERT)
    {
        wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 1);
    }
    WRITESPOOLBUF(pdevobj, Cmd, wlen);

    // DL font will be unselectd
    pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
}

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes)
{
    LONG tmp = ((LONG)height * (LONG)7200) / (LONG)vertRes;

    //
    // round to the nearest quarter point.
    //
    return 25 * ((tmp + 12) / (LONG)25);
}

LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr)
{
    register long count;

    count = strlen(_ltoa(size / 100, pStr, 10));
    pStr[count++] = '.';
    count += strlen(_ltoa(size % 100, &pStr[count], 10));

    return count;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMOutputCharStr
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
    PTRANSDATA pTransOrg;
    WORD   id;
    DWORD  dwI;
    DWORD  dwNeeded;
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;

    WORD wLen;
    BYTE *pTemp;
    BOOL bRet;

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    pTrans = NULL;
    pTransOrg = NULL;

    MY_VERBOSE(("OEMOutputCharStr() entry.\n"));

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    if ( pOEM->iColorMayChange == 1 )
    {
        /* Output Color Select Command */
        /* The logic supposes COLOR_SELECT_xxx starts with COLOR_SELECT_BLACK */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)COLOR_SELECT_COMMAND[pOEM->dwSelectedColor - COLOR_SELECT_BLACK],
                       COLOR_SELECT_COMMAND_LEN[pOEM->dwSelectedColor - COLOR_SELECT_BLACK] );

        /* Reset flag, for ensuring color */
        pOEM->iColorMayChange = 0;
    }
    /* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:

        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;

        if ((FALSE != (bRet = pUFObj->pfnGetInfo(pUFObj,
                UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)))
            || 0 == GStr.dwGlyphOutSize)
        {
            ERR(("UFO_GETINFO_GRYPHSTRING faild - %d, %d.\n",
                bRet, GStr.dwGlyphOutSize));
            return;
        }

        pTrans = (TRANSDATA *)MemAlloc(GStr.dwGlyphOutSize);
        if (NULL == pTrans)
        {
            ERR(("MemAlloc faild.\n"));
            return;
        }
        pTransOrg = pTrans;
        GStr.pGlyphOut = pTrans;

        // convert glyph string to TRANSDATA
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));

            /* pTransOrg isn't NULL because the function have already ended if pTransOrg is NULL. */
            /* So, we need not check whether it is NULL. */
            MemFree(pTransOrg);
            return;
        }

        for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
        {
            MY_VERBOSE(("TYPE_TRANSDATA:ubCodePageID:0x%x\n",
                pTrans->ubCodePageID));
            MY_VERBOSE(("TYPE_TRANSDATA:ubType:0x%x\n",
                pTrans->ubType));

            switch (pTrans->ubType & MTYPE_DOUBLEBYTECHAR_MASK)
            {
            case MTYPE_SINGLE: 
                if(pOEM->fGeneral & FG_DOUBLE){
                    OEMCommandCallback(pdevobj, TEXT_FS_SINGLE_BYTE, 0, NULL );
                }
                break;
            case MTYPE_DOUBLE:
                if(!(pOEM->fGeneral & FG_DOUBLE)){
                    OEMCommandCallback(pdevobj, TEXT_FS_DOUBLE_BYTE, 0, NULL );
                }
                break;
            }

            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            case MTYPE_DIRECT: 
                MY_VERBOSE(("TYPE_TRANSDATA:ubCode:0x%x\n",
                    pTrans->uCode.ubCode));

                pTemp = (BYTE *)&pTrans->uCode.ubCode;
                wLen = 1;
                break;

            case MTYPE_PAIRED: 
                MY_VERBOSE(("TYPE_TRANSDATA:ubPairs:0x%x\n",
                    *(PWORD)(pTrans->uCode.ubPairs)));

                pTemp = (BYTE *)&(pTrans->uCode.ubPairs);
                wLen = 2;
                break;

            case MTYPE_COMPOSE:
                // ntbug9#398026: garbage print out when chars are high ansi.
                pTemp = (BYTE *)(pTransOrg) + pTrans->uCode.sCode;

                // first two bytes are the length of the string
                wLen = *pTemp + (*(pTemp + 1) << 8);
                pTemp += 2;
                break;

            default:
                WARNING(("Unsupported MTYPE %d ignored\n",
                    (pTrans->ubType & MTYPE_FORMAT_MASK)));
            }

            if (wLen > 0)
            {
                WRITESPOOLBUF(pdevobj, pTemp, wLen);
            }
        }
        break;

    case TYPE_GLYPHID:

        DL_VERBOSE(("CharStr: dwDLFontID=%x, dwDLSelectFontID=%x\n",
            pOEM->dwDLFontID, pOEM->dwDLSelectFontID));

        // Make sure correct soft font is chosen
        if (pOEM->dwDLFontID != pOEM->dwDLSelectFontID)
            VSetSelectDLFont(pdevobj, pOEM->dwDLSelectFontID);

        for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)
        {

            DL_VERBOSE(("Glyph: %x\n", (*(PDWORD)pGlyph)));

            MY_VERBOSE(("TYPE_GLYPHID:0x%x\n", *(PDWORD)pGlyph));

// CASIO 98/11/24 ->
//            if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//                id = SWAPW( *(PDWORD)pGlyph + SJISCHR);
//                WRITESPOOLBUF(pdevobj, &id, 2);
//            }else{
                WRITESPOOLBUF(pdevobj, (PBYTE)pGlyph, 1);
//            }
// CASIO 98/11/24 <-
        }
        break;
    }

    /* pTransOrg isn't NULL because the function have already ended if pTransOrg is NULL. */
    /* So, we need not check whether it is NULL. */
    MemFree(pTransOrg);
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadFontHeader
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    )
{

    PGETINFO_STDVAR pSV;
    DWORD adwStdVariable[2+4*2];
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;
    ESCPAGEHEADER FontHeader;
    BYTE sFontName[54];
    BYTE Buff[32];
    int iSizeOfBuf,iSizeFontName;
    WORD id;
    DWORD dwNeeded;
    INT iCellLeftOffset, iTemp;
    WORD wCellHeight, wCellWidth;
    WORD wFontPitch;

    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    pIFI = pUFObj->pIFIMetrics;

    DL_VERBOSE(("OEMDownloadFontHeader() entry.\n"));

    DL_VERBOSE(("TT Font:\n"));
    DL_VERBOSE(("flInfo=%08x\n", pIFI->flInfo));
    DL_VERBOSE(("fwdMaxCharInc=%d\n", pIFI->fwdMaxCharInc));
    DL_VERBOSE(("fwdAveCharWidth=%d\n", pIFI->fwdAveCharWidth));
    DL_VERBOSE(("jWinCharSet=%d\n", pIFI->jWinCharSet));
    DL_VERBOSE(("rclFontBox=%d,%d,%d,%d\n",
        pIFI->rclFontBox.left, pIFI->rclFontBox.top,
        pIFI->rclFontBox.right, pIFI->rclFontBox.bottom));

//    if(pIFI->jWinPitchAndFamily & 0x01)
    if(pIFI->flInfo & FM_INFO_CONSTANT_WIDTH)
        pOEM->fGeneral &= ~FG_PROP;
    else
        pOEM->fGeneral |= FG_PROP;

//    id = (WORD)pUFObj->ulFontID;
    id = (WORD)pOEM->dwDLSetFontID;

    if(id > FONT_MAX_ID) return 0;
    if (pOEM->iResolution) return 0;

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE,
            pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return 0;
    }
    DL_VERBOSE(("FONTHEIGHT=%d\n", pSV->StdVar[0].lStdVariable));
    DL_VERBOSE(("FONTWIDTH=%d\n", pSV->StdVar[1].lStdVariable));
    DL_VERBOSE(("TEXTXRES=%d\n", pSV->StdVar[2].lStdVariable));
    DL_VERBOSE(("TEXTYRES=%d\n", pSV->StdVar[3].lStdVariable));

    wCellHeight = (WORD)pSV->StdVar[0].lStdVariable;
    wCellWidth = (WORD)pSV->StdVar[1].lStdVariable;

// CASIO 98/11/20 ->
     if ( MasterToDevice(pOEM,wCellHeight) > 64 )
     {
         DL_VERBOSE(("Abort OEMDownloadFontHeader: pt=%d\n",
             MasterToDevice(pOEM, wCellHeight)));
         return 0;
     }
// CASIO 98/11/20 <-

    //
    // rclFontBox.left may not be 0
    //

    iTemp = max(pIFI->rclFontBox.right -
        pIFI->rclFontBox.left + 1,
        pIFI->fwdAveCharWidth);

    iCellLeftOffset = (-pIFI->rclFontBox.left)
        * wCellWidth / iTemp;
    wFontPitch = pIFI->fwdAveCharWidth
        * wCellWidth / iTemp;

    FontHeader.wFormatType     = SWAPW(0x0002);
    FontHeader.wDataSize       = SWAPW(0x0086);
// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        FontHeader.wSymbolSet  = SWAPW(id-FONT_MIN_ID+0x4000+0x8000); //id-FONT_MIN_ID + 4000h + 8000h
//        FontHeader.wLast       = (WORD)SWAPW (0x23ff);
//        FontHeader.wFirst      = (WORD)SWAPW (0x2020);
//    }else{
        FontHeader.wSymbolSet  = SWAPW(id-FONT_MIN_ID+0x4000); //id-FONT_MIN_ID + 4000h
        FontHeader.wLast       = SWAPW (0xff);
        FontHeader.wFirst      = SWAPW (0x20);
//    }
// CASIO 98/11/24 <-

    if (pOEM->fGeneral & FG_PROP)
    {
        FontHeader.wCharSpace         = SWAPW(1);
        FontHeader.CharWidth.Integer = (WORD)SWAPW(0x0100);
        FontHeader.CharWidth.Fraction = 0;
    }
    else
    {
        FontHeader.wCharSpace         = 0;
        FontHeader.CharWidth.Integer
            = SWAPW(MasterToDevice(pOEM, wCellWidth));
        FontHeader.CharWidth.Fraction = 0;      
    }
    FontHeader.CharHeight.Integer
            = SWAPW(MasterToDevice(pOEM, wCellHeight));
    FontHeader.CharHeight.Fraction = 0;
    // in the range 128 - 255
    FontHeader.wFontID = SWAPW( id - FONT_MIN_ID + ( id < 0x80 ? 0x80 : 0x00));
    FontHeader.wWeight         = 0;
    FontHeader.wEscapement     = 0;
    FontHeader.wItalic         = 0;
    FontHeader.wUnderline      = 0;
    FontHeader.wUnderlineWidth = SWAPW(10);
    FontHeader.wOverline       = 0;
    FontHeader.wOverlineWidth  = 0;
    FontHeader.wStrikeOut      = 0;
    FontHeader.wStrikeOutWidth = 0;
    FontHeader.wCellWidth
        = SWAPW(MasterToDevice(pOEM, wCellWidth));
    FontHeader.wCellHeight
        = SWAPW(MasterToDevice(pOEM, wCellHeight));
    FontHeader.wCellLeftOffset = SWAPW(iCellLeftOffset);
    FontHeader.wCellAscender
        = SWAPW((pIFI->fwdWinAscender
        * MasterToDevice(pOEM, wCellHeight)));
    FontHeader.FixPitchWidth.Integer
        = SWAPW(MasterToDevice(pOEM, wFontPitch));
    FontHeader.FixPitchWidth.Fraction = 0;

    iSizeFontName = wsprintf(sFontName,
       "________________________EPSON_ESC_PAGE_DOWNLOAD_FONT%02d",id-FONT_MIN_ID);
    iSizeOfBuf = wsprintf(Buff,SET_FONT_ID,FONT_HEADER_SIZE,id-FONT_MIN_ID);
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, (LPSTR)&FontHeader,sizeof(ESCPAGEHEADER));
    WRITESPOOLBUF(pdevobj, sFontName,iSizeFontName);
    WRITESPOOLBUF(pdevobj, "EPC_PAGE_DOWNLOAD_FONT_INDEX", SIZE_SYMBOLSET);

//    iSizeOfBuf = wsprintf(Buff,DLI_SELECT_FONT_ID,id-FONT_MIN_ID,0);
//    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
//
    DL_VERBOSE(("DLFontHeader: ulFontID=%x, dwDLSetFontID=%x\n",
        pUFObj->ulFontID, pOEM->dwDLSetFontID));

    DL_VERBOSE(("FontHeader:\n"));
    DL_VERBOSE(("wFormatType=%d\n", SWAPW(FontHeader.wFormatType)));
    DL_VERBOSE(("wDataSize=%d\n", SWAPW(FontHeader.wDataSize)));
    DL_VERBOSE(("wSymbolSet=%d\n", SWAPW(FontHeader.wSymbolSet)));
    DL_VERBOSE(("wCharSpace=%d\n", SWAPW(FontHeader.wCharSpace)));
    DL_VERBOSE(("CharWidth=%d.%d\n",
        SWAPW(FontHeader.CharWidth.Integer),
        FontHeader.CharWidth.Fraction));
    DL_VERBOSE(("CharHeight=%d.%d\n",
        SWAPW(FontHeader.CharHeight.Integer),
        FontHeader.CharHeight.Fraction));
    DL_VERBOSE(("wFontID=%d\n", SWAPW(FontHeader.wFontID)));
    DL_VERBOSE(("wWeight=%d\n", SWAPW(FontHeader.wWeight)));
    DL_VERBOSE(("wEscapement=%d\n", SWAPW(FontHeader.wEscapement)));
    DL_VERBOSE(("wItalic=%d\n", SWAPW(FontHeader.wItalic)));
    DL_VERBOSE(("wLast=%d\n", SWAPW(FontHeader.wLast)));
    DL_VERBOSE(("wFirst=%d\n", SWAPW(FontHeader.wFirst)));
    DL_VERBOSE(("wUnderline=%d\n", SWAPW(FontHeader.wUnderline)));
    DL_VERBOSE(("wUnderlineWidth=%d\n", SWAPW(FontHeader.wUnderlineWidth)));
    DL_VERBOSE(("wOverline=%d\n", SWAPW(FontHeader.wOverline)));
    DL_VERBOSE(("wOverlineWidth=%d\n", SWAPW(FontHeader.wOverlineWidth)));
    DL_VERBOSE(("wStrikeOut=%d\n", SWAPW(FontHeader.wStrikeOut)));
    DL_VERBOSE(("wStrikeOutWidth=%d\n", SWAPW(FontHeader.wStrikeOutWidth)));
    DL_VERBOSE(("wCellWidth=%d\n", SWAPW(FontHeader.wCellWidth)));
    DL_VERBOSE(("wCellHeight=%d\n", SWAPW(FontHeader.wCellHeight)));
    DL_VERBOSE(("wCellLeftOffset=%d\n", SWAPW(FontHeader.wCellLeftOffset)));
    DL_VERBOSE(("wCellAscender=%d\n", SWAPW(FontHeader.wCellAscender)));
    DL_VERBOSE(("FixPitchWidth=%d.%d\n",
        SWAPW(FontHeader.FixPitchWidth.Integer),
        FontHeader.FixPitchWidth.Fraction));
    DL_VERBOSE(("FontName=%s\n", sFontName));

    return FONT_HEADER_SIZE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadCharGlyph
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth
    )
{
    GETINFO_GLYPHBITMAP GBmp;
    GLYPHDATA *pGdata;
    GLYPHBITS *pbit;
    DWORD  dwNeeded;
    WORD cp;
    ESCPAGECHAR ESCPageChar;
    WORD wWidth, Width, Hight;
    LPDIBITS lpSrc;
    BYTE mask;
    int iSizeOfBuf, i;
    DWORD dwSize, dwCellSize, dwAirSize;
    BYTE Buff[32];
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    MY_VERBOSE(("OEMDownloadCharGlyph() entry.\n"));

    cp = (WORD)pOEM->wCharCode;

    GBmp.dwSize    = sizeof (GETINFO_GLYPHBITMAP);
    GBmp.hGlyph    = hGlyph;
    GBmp.pGlyphData = NULL;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp, GBmp.dwSize, &dwNeeded))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\n"));
        return 0;
    }

    pGdata = GBmp.pGlyphData;
    pbit = pGdata->gdf.pgb;

    DL_VERBOSE(("DLCharGlyph: dwDLFont=%x, dwDLSetFont=%x, wCharCode=%x\n",
        pOEM->dwDLFontID, pOEM->dwDLSetFontID, pOEM->wCharCode));

    // Set font id if not already
    if (pOEM->dwDLFontID != pOEM->dwDLSetFontID)
        VSetSelectDLFont(pdevobj, pOEM->dwDLSetFontID);

    // fill in the charcter header information.
    ESCPageChar.bFormat       = 0x01;
    ESCPageChar.bDataDir      = 0x10;
// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        cp += SJISCHR;
//        ESCPageChar.wCharCode     = SWAPW(cp);
//    }else{
        ESCPageChar.wCharCode     = LOBYTE(cp);
//    }
// CASIO 98/11/24 <-

    ESCPageChar.wBitmapWidth       = SWAPW(pbit->sizlBitmap.cx);
    ESCPageChar.wBitmapHeight      = SWAPW(pbit->sizlBitmap.cy);

// MSKK 98/04/06 ->
//    ESCPageChar.wLeftOffset        = SWAPW(pbit->ptlOrigin.x);
//    ESCPageChar.wAscent            = SWAPW(pbit->ptlOrigin.y * -1);
    ESCPageChar.wLeftOffset = (pbit->ptlOrigin.x > 0 ? 
                                                SWAPW(pbit->ptlOrigin.x) : 0);
    ESCPageChar.wAscent     = (pbit->ptlOrigin.y < 0 ?
                                            SWAPW(pbit->ptlOrigin.y * -1) : 0);
// MSKK 98/04/06 <-

    ESCPageChar.CharWidth.Integer  = SWAPW(pGdata->fxD / 16);
    ESCPageChar.CharWidth.Fraction = 0;
    *pdwWidth = ESCPageChar.CharWidth.Integer;

    Width = LOWORD(pbit->sizlBitmap.cx);
    wWidth = (LOWORD(pbit->sizlBitmap.cx) + 7) >> 3;
    Hight = LOWORD(pbit->sizlBitmap.cy);

    // not multiple of 8, need to mask out unused last byte
    // This is done so that we do not advance beyond segment bound
    // which can happen if lpBitmap is just under 64K and adding
    // width to it will cause invalid segment register to be loaded.
    if (mask = bit_mask[LOWORD(Width) & 0x7])
    {
        lpSrc = pbit->aj + wWidth - 1;
        i = LOWORD(Hight);
        while (TRUE)
        {
            (*lpSrc) &= mask;
            i--;
            if (i > 0)
                lpSrc += wWidth;
            else
                break;
        }
    }

    dwCellSize = (DWORD)pbit->sizlBitmap.cy * wWidth;
    dwSize = (DWORD)(LOWORD(Hight)) * wWidth;

// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        iSizeOfBuf = wsprintf(Buff,SET_DOUBLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),HIBYTE(cp),LOBYTE(cp));
//    }else{
        iSizeOfBuf = wsprintf(Buff,SET_SINGLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),LOBYTE(cp));
//    }
// CASIO 98/11/24 <-
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);

    WRITESPOOLBUF(pdevobj, (LPSTR)&ESCPageChar, sizeof(ESCPAGECHAR));

    for (lpSrc = pbit->aj; dwSize; lpSrc += wWidth)
    {
        if ( dwSize > 0x4000 )
            wWidth = 0x4000;
        else
            wWidth = LOWORD(dwSize);

        dwSize -= wWidth;

        WRITESPOOLBUF(pdevobj, (LPSTR)lpSrc, (WORD)wWidth);
    }

    MY_VERBOSE(("ESCPageChar:\n"));
    MY_VERBOSE(("bFormat=%d\n", ESCPageChar.bFormat));
    MY_VERBOSE(("bDataDir=%d\n", ESCPageChar.bDataDir));
    MY_VERBOSE(("wCharCode=%d\n", SWAPW(ESCPageChar.wCharCode)));
    MY_VERBOSE(("wBitmapWidth=%d\n", SWAPW(ESCPageChar.wBitmapWidth)));
    MY_VERBOSE(("wBitmapHeight=%d\n", SWAPW(ESCPageChar.wBitmapHeight)));
    MY_VERBOSE(("wLeftOffset=%d\n", SWAPW(ESCPageChar.wLeftOffset)));
    MY_VERBOSE(("wAscent=%d\n", SWAPW(ESCPageChar.wAscent)));
    MY_VERBOSE(("CharWidth=%d.%d\n", SWAPW(ESCPageChar.CharWidth.Integer),
        ESCPageChar.CharWidth.Fraction));

    return sizeof(ESCPAGECHAR) + dwCellSize;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMTTDownloadMethod
//////////////////////////////////////////////////////////////////////////
DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    )
{
    DWORD dwRet;

    // Default is to download.
    dwRet = TTDOWNLOAD_BITMAP;

    DL_VERBOSE(("TTDLMethod: dwRet=%d\n", dwRet));

    return dwRet;
}

VOID APIENTRY
OEMMemoryUsage(
    PDEVOBJ pdevobj,
    POEMMEMORYUSAGE pMemoryUsage
    )
{
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (pOEM->iColor == XX_COLOR_SINGLE 
     || pOEM->iColor == XX_COLOR_MANY
     || pOEM->iColor == XX_COLOR_MANY2) {
        pMemoryUsage->dwFixedMemoryUsage = 
            LUTSIZ016 + LUTSIZ032 + LUTSIZRGB + LUTSIZCMY + 
            CCHRGBSIZ + CCHCMYSIZ + 
            LUTGLBWRK + LUT032WRK + DIZINFWRK + 
            LUTFILESIZ + DIZFILESIZ + LUT032SIZ + 
            UCRTBLSIZ + UCRWRKSIZ + sRGBLUTFILESIZ + LUTMAKGLBSIZ;
        pMemoryUsage->dwPercentMemoryUsage = 100 * (pOEM->Col.DatBit * 4 + 24 + 32) / 32;

        MY_VERBOSE(("OEMMemoryUsage()  dwFixedMemoryUsage:[%d]\n", pMemoryUsage->dwFixedMemoryUsage));
        MY_VERBOSE(("                  dwPercentMemoryUsage:[%d]\n", pMemoryUsage->dwPercentMemoryUsage));
        MY_VERBOSE(("                  pOEM->Col.DatBit:[%d]\n", pOEM->Col.DatBit));
        MY_VERBOSE(("OEMMemOryUsage pOEM->Col.DatBit = %d\n",pOEM->Col.DatBit));
    }

    return;
}


// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{

public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE(("IOemCB: QueryInterface entry\n"));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE(("IOemCB:Return pointer to IUnknown.\n")); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE(("IOemCB:Return pointer to IPrintOemUni.\n")); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE(("IOemCB:Return NULL.\n")); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE(("IOemCB::AddRef() entry.\n"));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE(("IOemCB::Release() entry.\n"));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE(("IOemCB::GetInfo() entry.\n"));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE(("IOemCB::DevMode() entry.\n"));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE(("IOemCB::EnableDriver() entry.\n"));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE(("IOemCB::DisaleDriver() entry.\n"));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE(("IOemCB::EnablePDEV() entry.\n"));

        *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName,
            cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo,
            cjDevInfo, pDevInfo, pded);

        if (*pDevOem)
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE(("IOemCB::DisablePDEV() entry.\n"));

        OEMDisablePDEV(pdevobj);

        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
//      VERBOSE(("IOemCB::ResetPDEV() entry.\n"));
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE(("IOemCB::PublishDriverInterface() entry.\n"));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE(("IOemCB::GetImplementedMethod() entry.\n"));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE(("IOemCB::CommandCallback() entry.\n"));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE(("IOemCB::ImageProcessing() entry.\n"));

        *ppbResult = OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable, dwCallbackID, pIPParams);

        return S_OK;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE(("IOemCB::FilterGraphis() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE(("IOemCB::Compression() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE(("IOemCB::HalftonePattern() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE(("IOemCB::MemoryUsage() entry.\n"));

        OEMMemoryUsage(pdevobj, pMemoryUsage);

        return S_OK;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::DownloadFontHeader() entry.\n"));

#if DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::DownloadCharGlyph() entry.\n"));

#if DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::TTDownloadMethod() entry.\n"));
#if DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE(("IOemCB::OutputCharStr() entry.\n"));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE(("IOemCB::SendFontCmd() entry.\n"));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE(("IOemCB::DriverDMS() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE(("IOemCB::TextOutAsBitmap() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE(("IOemCB::TTYGetInfo() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE(("IOemCF::CreateInstance() called\n."));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE(("DllGetClassObject:\tCreate class factory."));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\debug2.h ===
#ifndef _DEBUG2_H_
#define _DEBUG2_H_

// Select 'File output' Or 'Normal VERBOSE'
#define DEBUG2_FILE

#ifdef DEBUG2_FILE
#define DEBU2_FNAME     "C:\\TEMP\\unilog.txt"
//#define DEBUG2_DUMP_USE
    VOID DbgFPrint(LPCSTR,  ...);
    VOID DbgFDump(LPBYTE, UINT);
#endif  // DEBUG2_FILE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\debug2.c ===
#include <minidrv.h>
#include <stdio.h>
#include <process.h>
#include <stdarg.h>
#include "debug2.h"
//
// Functions for outputting debug messages
//

#if (DBG)

VOID DbgFPrint(LPCSTR pstrFormat,  ...)
{
    FILE *stream;
    va_list ap;

char wbuff[512];

    va_start(ap, pstrFormat);
    if ((stream = fopen( DEBU2_FNAME, "a" )) == NULL) {
        return;
    }
    vfprintf(stream, pstrFormat, ap);
    fclose(stream);
    va_end(ap);
}

#ifdef DEBUG2_DUMP_USE
VOID DbgFDump(LPBYTE src, UINT src_size)
{
    FILE *stream;
    LPBYTE cur_ptr;
    UINT cnt01;
    UINT cnt02;
    UINT line_max;
    UINT line_rem;
    BYTE d_dump_buff[256];
    
    if ((stream = fopen( DEBU2_FNAME, "a" )) == NULL) {
        return;
    }
    cur_ptr = src;

    line_max = src_size / 16;
    line_rem = src_size % 16;
    for (cnt01=0; cnt01 < line_max; cnt01++) {
        memset(d_dump_buff, 0x00, sizeof(d_dump_buff));
        for (cnt02=0; cnt02 < 16; cnt02++) {
            sprintf(d_dump_buff+(3*cnt02), " %02X", *(cur_ptr + cnt02));
        }
        fprintf(stream, d_dump_buff);
        fprintf(stream, "\n");

        cur_ptr += 16;
    }
    if (line_rem > 0) {
        memset(d_dump_buff, 0x00, sizeof(d_dump_buff));
        for (cnt02=0; cnt02 < 16 && cnt02 < line_rem; cnt02++) {
            sprintf(d_dump_buff+(3*cnt02), " %02X ", *(cur_ptr + cnt02));
        }
        fprintf(stream, d_dump_buff);
        fprintf(stream, "\n");
    }
    fclose(stream);
}
#else   // DEBUG2_DUMP_USE
VOID DbgFDump(LPBYTE src, UINT src_size)
{
    ;
}
#endif  // DEBUG2_DUMP_USE

#else   // DBG
VOID DbgFPrint(LPCSTR pstrFormat,  ...)
{
    ;
}
VOID DbgFDump(LPBYTE src, UINT src_size)
{
    ;
}
#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5colmh.c ===
//***************************************************************************************************
//    N5COLMH.C
//
//    Functions color matching (For N5 printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "COLDEF.H"
#include    "COMDIZ.H"
#include    "N5COLMH.H"


//===================================================================================================
//      Dot gain revision table
//===================================================================================================
//static BYTE GinTblP10[256] = {
//    /* 00 */    0x00,0x01,0x02,0x04,0x05,0x06,0x07,0x09,
//    /* 08 */    0x0a,0x0b,0x0c,0x0d,0x0f,0x10,0x11,0x12,
//    /* 10 */    0x13,0x15,0x16,0x17,0x18,0x1a,0x1b,0x1c,
//    /* 18 */    0x1d,0x1e,0x20,0x21,0x22,0x23,0x24,0x26,
//    /* 20 */    0x27,0x28,0x29,0x2b,0x2c,0x2d,0x2e,0x2f,
//    /* 28 */    0x31,0x32,0x33,0x34,0x35,0x37,0x38,0x39,
//    /* 30 */    0x3a,0x3b,0x3d,0x3e,0x3f,0x40,0x41,0x43,
//    /* 38 */    0x44,0x45,0x46,0x47,0x48,0x4a,0x4b,0x4c,
//    /* 40 */    0x4d,0x4e,0x50,0x51,0x52,0x53,0x54,0x55,
//    /* 48 */    0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5e,0x5f,
//    /* 50 */    0x60,0x61,0x62,0x63,0x65,0x66,0x67,0x68,
//    /* 58 */    0x69,0x6a,0x6b,0x6d,0x6e,0x6f,0x70,0x71,
//    /* 60 */    0x72,0x73,0x74,0x76,0x77,0x78,0x79,0x7a,
//    /* 68 */    0x7b,0x7c,0x7d,0x7e,0x7f,0x81,0x82,0x83,
//    /* 70 */    0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,
//    /* 78 */    0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,
//    /* 80 */    0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,
//    /* 88 */    0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,
//    /* 90 */    0xa3,0xa4,0xa5,0xa5,0xa6,0xa7,0xa8,0xa9,
//    /* 98 */    0xaa,0xab,0xac,0xac,0xad,0xae,0xaf,0xb0,
//    /* a0 */    0xb1,0xb2,0xb3,0xb3,0xb4,0xb5,0xb6,0xb7,
//    /* a8 */    0xb8,0xb9,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,
//    /* b0 */    0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc4,
//    /* b8 */    0xc5,0xc6,0xc7,0xc8,0xc9,0xc9,0xca,0xcb,
//    /* c0 */    0xcc,0xcd,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,
//    /* c8 */    0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd7,0xd8,
//    /* d0 */    0xd9,0xda,0xdb,0xdb,0xdc,0xdd,0xde,0xdf,
//    /* d8 */    0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe4,0xe5,
//    /* e0 */    0xe6,0xe7,0xe8,0xe8,0xe9,0xea,0xeb,0xec,
//    /* e8 */    0xec,0xed,0xee,0xef,0xf0,0xf0,0xf1,0xf2,
//    /* f0 */    0xf3,0xf4,0xf5,0xf5,0xf6,0xf7,0xf8,0xf9,
//    /* f8 */    0xf9,0xfa,0xfb,0xfc,0xfd,0xfd,0xfe,0xff
//};


//---------------------------------------------------------------------------------------------------
//      Color matching(high speed)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColMch000(
    DWORD,
    LPRGB,
    LPCMYK,
    LPCOLMCHINF
);
#endif

//---------------------------------------------------------------------------------------------------
//      Color matching(normal speed)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColMch001(
    DWORD,
    LPRGB,
    LPCMYK,
    LPCOLMCHINF
);
#endif

//---------------------------------------------------------------------------------------------------
//      Color matching(solid)
//---------------------------------------------------------------------------------------------------
static VOID ExeColCnvSld(
    DWORD,
    LPRGB,
    LPCMYK,
    LPCOLMCHINF
);

//---------------------------------------------------------------------------------------------------
//      RGB -> CMYK(2Level) conversion (for 1dot line)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColCnvL02(
    DWORD,
    LPRGB,
    LPCMYK
);
#endif

//---------------------------------------------------------------------------------------------------
//      RGB -> K conversion (for monochrome)
//---------------------------------------------------------------------------------------------------
static VOID ExeColCnvMon(
    DWORD,
    LPRGB,
    LPCMYK,
    LPCOLMCHINF
);

//---------------------------------------------------------------------------------------------------
//      Color matching(UCR)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColMchUcr(
    LPCMYK,
    LPRGB,
    DWORD,
    DWORD,
    DWORD,
    DWORD,                                                  //+ UCR (Toner gross weight)   CASIO 2001/02/15
    LPCMYK
);
#endif


//***************************************************************************************************
//      Function
//***************************************************************************************************
//===================================================================================================
//      Cache table initialize
//===================================================================================================
VOID WINAPI N501ColCchIni(                                  // Return value no
    LPCOLMCHINF mchInf                                      // Color matching information
)
{
    DWORD       cnt;
    RGBS        colRgb;
    CMYK        colCmy;
    LPRGB       cchRgb;
    LPCMYK      cchCmy;

    if ((mchInf->CchRgb == NULL) || (mchInf->CchCmy == NULL)) return;

    cchRgb = mchInf->CchRgb;
    cchCmy = mchInf->CchCmy;
    colRgb.Red = colRgb.Grn = colRgb.Blu = 255;
    colCmy.Cyn = colCmy.Mgt = colCmy.Yel = colCmy.Bla = 0;

    /*----- Cache table initialize -----------------------------------*/
    for (cnt = 0; cnt < CCHTBLSIZ; cnt++) {
        *cchRgb = colRgb;
        *cchCmy = colCmy;
        cchRgb++;
        cchCmy++;
    }

    return;
}


//===================================================================================================
//      Gray transfer table make
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColGryTblMak(                              // ERRNON    : OK
                                                            // ERRILLPRM : Parameter error
    DWORD       colMch,                                     // Color matching
    LPCMYK      lutAdr,                                     // LUT address
    LPBYTE      gryTbl,                                     // Gray transfer table          (*1)
    LPBYTE      wrk                                         // Work                         (*2)
)
{
    COLMCHINF   mchInf;                                     // Color matching information
    LPRGB       rgb;                                        // struct ColRgb rgb[256]
    LPCMYK      gry;                                        // struct ColCmy gry[256]
    DWORD       n, tmp, tmC, tmM, tmY;

    /*----- Input parameter check --------------------------------------------------*/
    if ((lutAdr == NULL) || (gryTbl == NULL) || (wrk == NULL)) return ERRILLPRM;

    /*----- Work buffer setting ----------------------------------------------------*/
    rgb = (LPRGB)wrk;                   /* Work for gray transformation RGB   768B  */
    gry = (LPCMYK)(wrk + (sizeof(RGBS) * 256));
                                        /* Work for gray transformation CMYK 1024B  */

    /*----- Color matching information setting for gray value table generation -----*/
    mchInf.Mch = MCHNML;                /* Color matching     nornal        */
    mchInf.Bla = KCGNON;                /* Black replacement  NO Fixed      */
    mchInf.Ucr = UCRNOO;                /* UCR                NO Fixed      */
    mchInf.LutAdr = lutAdr;             /* LUT address        input value   */
    mchInf.ColQty = (DWORD)0;           /* Color quality      0 Fixed       */
    mchInf.ColAdr = NULL;               /* Color address       NULL Fixed   */
    mchInf.CchRgb = NULL;               /* Cache for RGB       NULL Fixed   */
    mchInf.CchCmy = NULL;               /* Cache for CMYK      NULL Fixed   */

    /*----- Gray value(RGB value before transformation) setting --------------------*/
    for (n = 0; n < (DWORD)256; n++)
        rgb[n].Red = rgb[n].Grn = rgb[n].Blu = (BYTE)n;

    /*----- Gray value(RGB -> CMYK) ------------------------------------------------*/
    switch (colMch) {
        case MCHNML: ExeColMch001((DWORD)256, rgb, gry, &mchInf); break;
        default:     ExeColCnvSld((DWORD)256, rgb, gry, &mchInf); break;
    }

    /*----- Gray transfer table setting --------------------------------------------*/
    for (n = 0; n < (DWORD)256; n++) {
        tmC = gry[n].Cyn;
        tmM = gry[n].Mgt;
        tmY = gry[n].Yel;
        tmp = (tmC * (DWORD)30 + tmM * (DWORD)59 + tmY * (DWORD)11) / (DWORD)100;
        gryTbl[n] = (BYTE)tmp;
    }
    gryTbl[255] = (BYTE)0;              /* White is '0' fix */

    /*  gryTbl[0] ` [16] adjusted to line (gryTbl[0](Black) is '255' fix)      */
    tmp = (DWORD)255 - gryTbl[16];
    for (n = 0; n < (DWORD)16; n++) {
        gryTbl[n] = (BYTE)((tmp * ((DWORD)16 - n)) / (DWORD)16) + gryTbl[16];
    }

    return ERRNON;
}
#endif

//===================================================================================================
//      UCR table Make
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColUcrTblMak(                              // ERRNON    : OK
                                                            // ERRILLPRM : Parameter error
    DWORD       colMch,                                     // Color matching
    LPCMYK      lutAdr,                                     // LUT address
    LPCMYK      ucrTbl,                                     // Table for UCR
    LPBYTE      wrk                                         // Work
)
{
    COLMCHINF   mchInf;                                     // Color matching information
    LPRGB       rgb;                                        // struct ColRgb rgb[256]
    LPCMYK      gry;                                        // struct ColCmy gry[257]
    LPCMYK      gryCyn;                                     // Gray value    (Cyan conversion value)
    LPCMYK      dnsCyn;                                     // Density value (Cyan conversion value)
    DWORD       loC, hiC, loM, hiM, loY, hiY, loK, hiK, saC, saM, saY, saK, n, m;
    DWORD       tmp, tmC, tmM, tmY;

    /*----- Input parameter check --------------------------------------------------*/
    if ((colMch != MCHFST) && (colMch != MCHNML) && (colMch != MCHSLD))
        return ERRILLPRM;
    if ((lutAdr == NULL) || (ucrTbl == NULL) || (wrk == NULL)) return ERRILLPRM;

    /*----- Work buffer setting ----------------------------------------------------*/
    rgb = (LPRGB)wrk;                   /* Work for gray transformation RGB   768B  */
    gry = (LPCMYK)(wrk + (sizeof(RGBS) * 256));
                                        /* Work for gray transformation CMYK 1028B  */

    /*----- LUT table pointer setting ----------------------------------------------*/
    gryCyn = ucrTbl;
    dnsCyn = ucrTbl + 256;

    /*----- Color matching information setting for gray value table generation -----*/
    mchInf.Mch = colMch;                /* Color matching      input value  */
    mchInf.Bla = KCGNON;                /* Black replacement   NO Fixed     */
    mchInf.Ucr = UCRNOO;                /* UCR                 NO Fixed     */
    mchInf.LutAdr = lutAdr;             /* LUT address         input value  */
    mchInf.ColQty = (DWORD)0;           /* Color quality       0 Fixed      */
    mchInf.ColAdr = NULL;               /* Color address       NULL Fixed   */
    mchInf.CchRgb = NULL;               /* Cache for RGB       NULL Fixed   */
    mchInf.CchCmy = NULL;               /* Cache for CMYK      NULL Fixed   */

    /*----- Gray value(RGB value before transformation) setting ---------------------*/
    for (n = 0; n < (DWORD)256; n++)
        rgb[n].Red = rgb[n].Grn = rgb[n].Blu = (BYTE)(255 - n);

    /*----- Gray value(RGB -> CMYK) -------------------------------------------------*/
    switch (colMch) {
        case MCHFST: ExeColMch000((DWORD)256, rgb, gry, &mchInf); break;
        case MCHNML: ExeColMch001((DWORD)256, rgb, gry, &mchInf); break;
//      default:     ExeColCnvSld((DWORD)256, rgb, gry, mchInf.Bla); break;
        default:     ExeColCnvSld((DWORD)256, rgb, gry, &mchInf); break;
    }

    /*----- Gray value(K) setting ---------------------------------------------------*/
//    for (n = 0; n < (DWORD)256; n++) gry[n].Bla = GinTblP10[n];
    for (n = 0; n < (DWORD)256; n++) {
//CASIO 2001/02/15 ->
//      tmC = gry[255 - n].Cyn;
//      tmM = gry[255 - n].Mgt;
//      tmY = gry[255 - n].Yel;
        tmC = gry[n].Cyn;
        tmM = gry[n].Mgt;
        tmY = gry[n].Yel;
        tmp = (tmC * (DWORD)30 + tmM * (DWORD)59 + tmY * (DWORD)11) / (DWORD)100;
//      gry[n].Bla = (BYTE)(255 - tmp);
        gry[n].Bla = (BYTE)tmp;
//CASIO 2001/02/15 <-
    }

    /*  gry[0] ` [16].Bla adjusted to line (gry[0].Bla(White) is '0' fix)      */
    tmp = gry[16].Bla;
    for (n = 0; n < (DWORD)16; n++) {
        gry[n].Bla = (BYTE)((tmp * n + (DWORD)15) / (DWORD)16);
    }

    /*----- Gray value, Limiter value setting for density value calculation ---------*/
    gry[256].Cyn = gry[256].Mgt = gry[256].Yel = gry[256].Bla = (BYTE)255;

    /*----- Gray value, Density value(Each Cyan conversion value) calculation -------*/
    for (n = 0; n < (DWORD)256; n++) {
        loC = gry[n].Cyn; hiC = gry[n + 1].Cyn; saC = (hiC > loC)? hiC - loC: 0;
        loM = gry[n].Mgt; hiM = gry[n + 1].Mgt; saM = (hiM > loM)? hiM - loM: 0;
        loY = gry[n].Yel; hiY = gry[n + 1].Yel; saY = (hiY > loY)? hiY - loY: 0;
        loK = gry[n].Bla; hiK = gry[n + 1].Bla; saK = (hiK > loK)? hiK - loK: 0;
        for (m = 0; m < saC; m++) gryCyn[m + loC].Mgt = (BYTE)(saM * m / saC + loM);
        for (m = 0; m < saC; m++) gryCyn[m + loC].Yel = (BYTE)(saY * m / saC + loY);
        for (m = 0; m < saC; m++) gryCyn[m + loC].Bla = (BYTE)(saK * m / saC + loK);
        for (m = 0; m < saM; m++) dnsCyn[m + loM].Mgt = (BYTE)(saC * m / saM + loC);
        for (m = 0; m < saY; m++) dnsCyn[m + loY].Yel = (BYTE)(saC * m / saY + loC);
    }
//CASIO 2001/02/15 ->
    gryCyn[255].Mgt = gryCyn[255].Yel = gryCyn[255].Bla = 
    dnsCyn[255].Mgt = dnsCyn[255].Yel = (BYTE)255;
//CASIO 2001/02/15 <-

    return ERRNON;
}
#endif

//===================================================================================================
//      Color matching procedure
//---------------------------------------------------------------------------------------------------
//      RGB -> CMYK
//===================================================================================================
VOID WINAPI N501ColMchPrc(                                  // Return value no
    DWORD       xaxSiz,                                     // X Size (Pixel)
    LPRGB       rgbAdr,                                     // RGB (input)
    LPCMYK      cmyAdr,                                     // CMYK (output)
    LPCOLMCHINF mchInf                                      // Color matching information
)
{
    switch (mchInf->Mch) {
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
        case MCHFST:                                        // LUT transformation(high speed)
            ExeColMch000(xaxSiz, rgbAdr, cmyAdr, mchInf);
            break;
        case MCHNML:                                        // LUT transformation(normal speed)
            ExeColMch001(xaxSiz, rgbAdr, cmyAdr, mchInf);
            break;
        case MCHSLD:                                        // NO (solid)
//          ExeColCnvSld(xaxSiz, rgbAdr, cmyAdr, mchInf->Bla);
            ExeColCnvSld(xaxSiz, rgbAdr, cmyAdr, mchInf);
            break;
        case MCHPRG:                                        // Primary color(progressive)
            ExeColCnvL02(xaxSiz, rgbAdr, cmyAdr);
            break;
#endif
        case MCHMON:                                        // Monochrome
//            ExeColCnvMon(xaxSiz, rgbAdr, cmyAdr);
            ExeColCnvMon(xaxSiz, rgbAdr, cmyAdr, mchInf);
            break;
        default:                                            // Indistinct
//          ExeColCnvSld(xaxSiz, rgbAdr, cmyAdr, mchInf->Bla);
            ExeColCnvSld(xaxSiz, rgbAdr, cmyAdr, mchInf);
    }

    return;
}


//===================================================================================================
//      Palette table transformation procedure
//---------------------------------------------------------------------------------------------------
//      RGB -> CMYK
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000
VOID WINAPI N501ColPtcPrc(                                  // Return value no
    DWORD       colBit,                                     // Data bit value
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPBYTE      srcAdr,                                     // RGB (input)
    LPCMYK      dstAdr,                                     // CMYK (output)
    LPCMYK      pltAdr                                      // Palette table address
)
{
    DWORD       cntXax;
    DWORD       cntBit;
    DWORD       bitNum;
    BYTE        pltNum;

    /*===== 256 color (8bit) ===============================================*/
    if (colBit == 8) {
        for (cntXax = xaxSiz; cntXax > 0; cntXax--) {
            *dstAdr = pltAdr[*srcAdr]; dstAdr++;
            srcAdr++;
        }
        return;
    }

    /*===== 16 color (4bit) ================================================*/
    if (colBit == 4) {
        for (cntXax = xaxSiz / 2; cntXax > 0; cntXax--) {
            *dstAdr = pltAdr[*srcAdr >> 4]; dstAdr++; *srcAdr <<= 4;
            *dstAdr = pltAdr[*srcAdr >> 4]; dstAdr++;
            srcAdr++;
        }
        if (xaxSiz % 2) 
            *dstAdr = pltAdr[*srcAdr >> 4];
        return;
    }

    /*====  4 color (2bit) =================================================*/
    if (colBit == 2) {
        for (cntXax = xaxSiz / 4; cntXax > 0; cntXax--) {
            *dstAdr = pltAdr[*srcAdr >> 6]; dstAdr++; *srcAdr <<= 2;
            *dstAdr = pltAdr[*srcAdr >> 6]; dstAdr++; *srcAdr <<= 2;
            *dstAdr = pltAdr[*srcAdr >> 6]; dstAdr++; *srcAdr <<= 2;
            *dstAdr = pltAdr[*srcAdr >> 6]; dstAdr++;
            srcAdr++;
        }
        for (cntXax = xaxSiz % 4; cntXax > 0; cntXax--) {
            *dstAdr = pltAdr[*srcAdr >> 6]; dstAdr++; *srcAdr <<= 2;
        }
        return;
    }

    /*=====  2 color (1bit) ================================================*/
    if (colBit == 1) {
        for (cntXax = xaxSiz / 8; cntXax > 0; cntXax--) {
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++;
            srcAdr++;
        }
        for (cntXax = xaxSiz % 8; cntXax > 0; cntXax--) {
            *dstAdr = pltAdr[*srcAdr >> 7]; dstAdr++; *srcAdr <<= 1;
        }
        return;
    }

    /*===== Others(7, 6, 5, 3bit) =========================================*/
    bitNum = 0;
    for (cntXax = 0; cntXax < xaxSiz; cntXax++) {
        pltNum = (BYTE)0x00;
        for (cntBit = colBit; cntBit > 0; cntBit--) {
            if (srcAdr[bitNum / 8] & ((BYTE)0x80 >> bitNum % 8)) {
                pltNum |= ((BYTE)0x01 << (cntBit - 1));
            }
            bitNum++;
        }
        *dstAdr = pltAdr[pltNum]; dstAdr++;
    }

    return;
}
#endif

//===================================================================================================
//      CMYK -> RGB conversion
//===================================================================================================
VOID WINAPI N501ColCnvC2r(                                  // Return value no
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPCMYK      cmyAdr,                                     // CMYK (input)
    LPRGB       rgbAdr,                                     // RGB (output)
    DWORD       gldNum,                                     // LUT Grid number
    LPBYTE      lutTblRgb                                   // LUT Address (R->G->B)
)
{
    DWORD       tmpC00, tmpM00, tmpY00, tmpK00;
    DWORD       tmpC01, tmpM01, tmpY01, tmpK01;
    DWORD       lenCyn, lenMgt, lenYel, lenBla;
    DWORD       tmpRed, tmpGrn, tmpBlu;
    DWORD       calPrm;
    LPCMYK      endAdr;
    LPRGB       lutCmy;
    RGBS        tmpRgb, tmpRgbSav;
    LPRGB       lutTbl;
    RGBS        lutTbl000;

    lutTbl = (LPRGB)lutTblRgb;
    lutTbl000.Red = lutTbl->Blu;
    lutTbl000.Grn = lutTbl->Grn;
    lutTbl000.Blu = lutTbl->Red;

    for (endAdr = cmyAdr + xaxSiz; cmyAdr < endAdr; cmyAdr++) {
        tmpC00 = cmyAdr->Cyn;
        tmpM00 = cmyAdr->Mgt;
        tmpY00 = cmyAdr->Yel;
        tmpK00 = cmyAdr->Bla;

        /*----- Monochrome ----------------------------------------------------------*/
        if ((tmpC00 | tmpM00 | tmpY00) == 0) {
            if (tmpK00 == 0) { *rgbAdr = lutTbl000; rgbAdr++; continue; }
            tmpK01 = tmpK00;
            tmpK00 = tmpK00 * (gldNum - 1) / 255;
            lenBla = tmpK01 * (gldNum - 1) - tmpK00 * 255;
            tmpK01 = (tmpK01 * (gldNum - 1) + 254) / 255;

            calPrm = (DWORD)255 - lenBla;
            tmpRgb = lutTbl[tmpK00 * gldNum * gldNum * gldNum];
            tmpRed = calPrm * tmpRgb.Red;
            tmpGrn = calPrm * tmpRgb.Grn;
            tmpBlu = calPrm * tmpRgb.Blu;

            calPrm = lenBla;
            tmpRgb = lutTbl[tmpK01 * gldNum * gldNum * gldNum];
            tmpRed += calPrm * tmpRgb.Red;
            tmpGrn += calPrm * tmpRgb.Grn;
            tmpBlu += calPrm * tmpRgb.Blu;

            tmpRed += (DWORD)255 / 2;
            tmpGrn += (DWORD)255 / 2;
            tmpBlu += (DWORD)255 / 2;

//          tmpRgb.Red = (BYTE)(tmpRed / (DWORD)255);
//          tmpRgb.Blu = (BYTE)(tmpBlu / (DWORD)255);
            tmpRgb.Red = (BYTE)(tmpBlu / (DWORD)255);
            tmpRgb.Grn = (BYTE)(tmpGrn / (DWORD)255);
            tmpRgb.Blu = (BYTE)(tmpRed / (DWORD)255);

            *rgbAdr = tmpRgb;
            rgbAdr++;
            continue;
        }

        /*----- CMYK -> RGB ---------------------------------------------------------*/
        tmpC01 = tmpC00;
        tmpC00 = tmpC00 * (gldNum - 1) / 255;
        lenCyn = tmpC01 * (gldNum - 1) - tmpC00 * 255;
        tmpC01 = (tmpC01 * (gldNum - 1) + 254) / 255;

        tmpM01 = tmpM00;
        tmpM00 = tmpM00 * (gldNum - 1) / 255;
        lenMgt = tmpM01 * (gldNum - 1) - tmpM00 * 255;
        tmpM01 = (tmpM01 * (gldNum - 1) + 254) / 255;

        tmpY01 = tmpY00;
        tmpY00 = tmpY00 * (gldNum - 1) / 255;
        lenYel = tmpY01 * (gldNum - 1) - tmpY00 * 255;
        tmpY01 = (tmpY01 * (gldNum - 1) + 254) / 255;

        tmpK01 = tmpK00;
        tmpK00 = tmpK00 * (gldNum - 1) / 255;
        lenBla = tmpK01 * (gldNum - 1) - tmpK00 * 255;
        tmpK01 = (tmpK01 * (gldNum - 1) + 254) / 255;

        lutCmy = lutTbl + tmpK00 * gldNum * gldNum * gldNum;

        /* 0 */
        calPrm = ((DWORD)255-lenCyn)*((DWORD)255-lenMgt)*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM00)*gldNum+tmpY00];
        tmpRed = calPrm * tmpRgb.Red;
        tmpGrn = calPrm * tmpRgb.Grn;
        tmpBlu = calPrm * tmpRgb.Blu;
        /* 1 */
        calPrm = ((DWORD)255-lenCyn)*((DWORD)255-lenMgt)*lenYel;
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM00)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 2 */
        calPrm = ((DWORD)255-lenCyn)*lenMgt*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM01)*gldNum+tmpY00];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 3 */
        calPrm = ((DWORD)255-lenCyn)*lenMgt*lenYel;
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM01)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 4 */
        calPrm = lenCyn*((DWORD)255-lenMgt)*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM00)*gldNum+tmpY00];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 5 */
        calPrm = lenCyn*((DWORD)255-lenMgt)*lenYel;
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM00)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 6 */
        calPrm = lenCyn*lenMgt*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM01)*gldNum+tmpY00];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 7 */
        calPrm = lenCyn*lenMgt*lenYel;
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM01)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;

        tmpRed += (DWORD)255 * 255 * 255 / 2;
        tmpGrn += (DWORD)255 * 255 * 255 / 2;
        tmpBlu += (DWORD)255 * 255 * 255 / 2;
//      tmpRgbSav.Red = (BYTE)(tmpRed / ((DWORD)255 * 255 * 255));
//      tmpRgbSav.Blu = (BYTE)(tmpBlu / ((DWORD)255 * 255 * 255));
        tmpRgbSav.Red = (BYTE)(tmpBlu / ((DWORD)255 * 255 * 255));
        tmpRgbSav.Grn = (BYTE)(tmpGrn / ((DWORD)255 * 255 * 255));
        tmpRgbSav.Blu = (BYTE)(tmpRed / ((DWORD)255 * 255 * 255));

        if (tmpK01 == tmpK00) { *rgbAdr = tmpRgbSav; rgbAdr++; continue; }

        lutCmy = lutTbl + tmpK01 * gldNum * gldNum * gldNum;
        /* 0 */
        calPrm = ((DWORD)255-lenCyn)*((DWORD)255-lenMgt)*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM00)*gldNum+tmpY00];
        tmpRed = calPrm * tmpRgb.Red;
        tmpGrn = calPrm * tmpRgb.Grn;
        tmpBlu = calPrm * tmpRgb.Blu;
        /* 1 */
        calPrm = ((DWORD)255-lenCyn)*((DWORD)255-lenMgt)*lenYel;
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM00)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 2 */
        calPrm = ((DWORD)255-lenCyn)*lenMgt*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM01)*gldNum+tmpY00];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 3 */
        calPrm = ((DWORD)255-lenCyn)*lenMgt*lenYel;
        tmpRgb = lutCmy[((tmpC00*gldNum)+tmpM01)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 4 */
        calPrm = lenCyn*((DWORD)255-lenMgt)*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM00)*gldNum+tmpY00];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 5 */
        calPrm = lenCyn*((DWORD)255-lenMgt)*lenYel;
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM00)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 6 */
        calPrm = lenCyn*lenMgt*((DWORD)255-lenYel);
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM01)*gldNum+tmpY00];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;
        /* 7 */
        calPrm = lenCyn*lenMgt*lenYel;
        tmpRgb = lutCmy[((tmpC01*gldNum)+tmpM01)*gldNum+tmpY01];
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;

        tmpRed += (DWORD)255 * 255 * 255 / 2;
        tmpGrn += (DWORD)255 * 255 * 255 / 2;
        tmpBlu += (DWORD)255 * 255 * 255 / 2;
//      tmpRgb.Red = (BYTE)(tmpRed / ((DWORD)255 * 255 * 255));
//      tmpRgb.Blu = (BYTE)(tmpBlu / ((DWORD)255 * 255 * 255));
        tmpRgb.Red = (BYTE)(tmpBlu / ((DWORD)255 * 255 * 255));
        tmpRgb.Grn = (BYTE)(tmpGrn / ((DWORD)255 * 255 * 255));
        tmpRgb.Blu = (BYTE)(tmpRed / ((DWORD)255 * 255 * 255));

        calPrm = (DWORD)255 - lenBla;
        tmpRed = calPrm * tmpRgbSav.Red;
        tmpGrn = calPrm * tmpRgbSav.Grn;
        tmpBlu = calPrm * tmpRgbSav.Blu;

        calPrm = lenBla;
        tmpRed += calPrm * tmpRgb.Red;
        tmpGrn += calPrm * tmpRgb.Grn;
        tmpBlu += calPrm * tmpRgb.Blu;

        tmpRed += (DWORD)255 / 2;
        tmpGrn += (DWORD)255 / 2;
        tmpBlu += (DWORD)255 / 2;

        tmpRgb.Red = (BYTE)(tmpRed / (DWORD)255);
        tmpRgb.Grn = (BYTE)(tmpGrn / (DWORD)255);
        tmpRgb.Blu = (BYTE)(tmpBlu / (DWORD)255);

        *rgbAdr = tmpRgb;
        rgbAdr++;
    }

    return;
}


//***************************************************************************************************
//      Static functions
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//      Color matching(high speed) (for 32GridLUT)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColMch000(                                   // Return value no
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPRGB       rgbAdr,                                     // RGB (input)
    LPCMYK      cmyAdr,                                     // CMYK (output)
    LPCOLMCHINF mchInf                                      // Color matching information
)
{
    DWORD       tmpRed, tmpGrn, tmpBlu;
    DWORD       blaCnv, ucr;
    DWORD       ucrCmy, ucrBla;
    DWORD       ucrTnr;
    LPRGB       endAdr;
    LPCMYK      lutTbl, ucrTbl;
    CMYK        tmpCmy;
    LPBYTE      gryTbl;

    blaCnv = mchInf->Bla;
    ucr    = mchInf->Ucr;
    ucrCmy = mchInf->UcrCmy;
    ucrBla = mchInf->UcrBla;
    ucrTnr = mchInf->UcrTnr;                                //+CASIO 2001/02/15
    ucrTbl = mchInf->UcrTbl;
    gryTbl = mchInf->GryTbl;
    lutTbl = mchInf->LutAdr;
    for (endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++) {
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Grn;
        tmpBlu = rgbAdr->Blu;
        if (blaCnv == KCGGRY) {
            if ((tmpRed == tmpGrn) && (tmpRed == tmpBlu)) {
                tmpCmy.Cyn = tmpCmy.Mgt = tmpCmy.Yel = 0;
//                tmpCmy.Bla = 255 - GinTblP10[tmpRed];
                tmpCmy.Bla = gryTbl[tmpRed];
                *cmyAdr = tmpCmy;
                cmyAdr++;
                continue;
            }
        } else if (blaCnv == KCGBLA) {
            if ((tmpRed | tmpGrn | tmpBlu) == 0) {
                tmpCmy.Cyn = tmpCmy.Mgt = tmpCmy.Yel = 0;
                tmpCmy.Bla = 255;
                *cmyAdr = tmpCmy;
                cmyAdr++;
                continue;
            }
        }
        *cmyAdr = lutTbl[tmpRed / 8 * GLDNUM032 * GLDNUM032 + 
                         tmpGrn / 8 * GLDNUM032 + 
                         tmpBlu / 8];

        /*----- UCR Procedure -------------------------------------------------------*/
//      if (ucr != UCRNOO) ExeColMchUcr(cmyAdr, rgbAdr, ucr, ucrTbl);
        if (ucr != UCRNOO)
// CASIO 2001/02/15 ->
//          ExeColMchUcr(cmyAdr, rgbAdr, ucr, ucrCmy, ucrBla, ucrTbl);
            ExeColMchUcr(cmyAdr, rgbAdr, ucr, ucrCmy, ucrBla, ucrTnr, ucrTbl);
// CASIO 2001/02/15 <-

        cmyAdr++;
    }

    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Color matching(normal speed) (for 16Grid)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColMch001(                                   // Return value no
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPRGB       rgbAdr,                                     // RGB (input)
    LPCMYK      cmyAdr,                                     // CMYK (output)
    LPCOLMCHINF mchInf                                      // Color matching information
)
{
    DWORD       tmpR00, tmpG00, tmpB00;
    DWORD       lenRed, lenGrn, lenBlu;
    DWORD       lenR00, lenG00, lenB00;
    DWORD       tmpRxC, tmpGxM, tmpBxY, tmpBla;
    DWORD       calPrm;
    DWORD       cch;
    DWORD       blaCnv;
    DWORD       n, colDefQty, ucr, cchTblSiz;
    DWORD       ucrCmy, ucrBla;
    DWORD       ucrTnr;
    LPCMYK      lutTbl;
    LPCMYK      lutCur;
    LPCMYK      ucrTbl;
    RGBS        tmpRgb, cchBufRgb;
    LPRGB       cchRgb;
    CMYK        tmpCmy, cchBufCmy;
    LPCMYK      cchCmy;
    CMYK        cmyBla;
    LPCOLCOLDEF colDef;
    LPBYTE      gryTbl;

    blaCnv = mchInf->Bla;
    ucr    = mchInf->Ucr;
    ucrCmy = mchInf->UcrCmy;
    ucrBla = mchInf->UcrBla;
    ucrTnr = mchInf->UcrTnr;                                //+CASIO 2001/02/15
    ucrTbl = mchInf->UcrTbl;
    gryTbl = mchInf->GryTbl;
    lutTbl = mchInf->LutAdr;
    colDefQty = mchInf->ColQty;
    colDef = mchInf->ColAdr;
    if ((mchInf->CchRgb == NULL) || (mchInf->CchCmy == NULL)) {
        cchTblSiz = (DWORD)1;
        cchRgb = &cchBufRgb;
        cchCmy = &cchBufCmy;
        cchRgb->Red = cchRgb->Grn = cchRgb->Blu = (BYTE)255;
        cchCmy->Cyn = cchCmy->Mgt = cchCmy->Yel = cchCmy->Bla = (BYTE)0;
    } else {
        cchTblSiz = CCHTBLSIZ;
        cchRgb = mchInf->CchRgb;
        cchCmy = mchInf->CchCmy;
    }

    cmyBla.Cyn = cmyBla.Mgt = cmyBla.Yel = 0; cmyBla.Bla = 255;

    for (; xaxSiz > 0; xaxSiz--) {
        tmpRgb = *rgbAdr++;
        tmpB00 = tmpRgb.Blu; tmpG00 = tmpRgb.Grn; tmpR00 = tmpRgb.Red;

        if (blaCnv == KCGGRY) {
            if ((tmpR00 == tmpG00) && (tmpR00 == tmpB00)) {
                tmpCmy = cmyBla;
//                tmpCmy.Bla -= GinTblP10[tmpR00];
                tmpCmy.Bla = gryTbl[tmpR00];
                *cmyAdr++ = tmpCmy;
                continue;
            }
        } else if (blaCnv == KCGBLA) {
            if ((tmpR00 | tmpG00 | tmpB00) == 0) {
                *cmyAdr++ = cmyBla;
                continue;
            }
        }

        /*----- Color setting -------------------------------------------------------*/
        if (colDefQty) {
            for (n = 0; n < colDefQty; n++) {
                if ((colDef[n].Red == (BYTE)tmpR00) &&
                    (colDef[n].Grn == (BYTE)tmpG00) &&
                    (colDef[n].Blu == (BYTE)tmpB00)) {
                    cmyAdr->Cyn = colDef[n].Cyn;
                    cmyAdr->Mgt = colDef[n].Mgt;
                    cmyAdr->Yel = colDef[n].Yel;
                    cmyAdr->Bla = colDef[n].Bla;
                    cmyAdr++;
                    break;
                }
            }
            if (n != colDefQty) continue;
        }

        /*----- Color matching cache  -----------------------------------------------*/
        cch = (tmpR00 * 49 + tmpG00 * 9 + tmpB00) % cchTblSiz;
        if ((cchRgb[cch].Red == (BYTE)tmpR00) && 
            (cchRgb[cch].Grn == (BYTE)tmpG00) && 
            (cchRgb[cch].Blu == (BYTE)tmpB00)) { 
            *cmyAdr++ = cchCmy[cch];
            continue;
        }

        /*----- RGB -> CMYK transformation ------------------------------------------*/
        tmpRxC = tmpR00;
        tmpR00 = tmpRxC * (GLDNUM016 - 1) / 255;
        lenRed = tmpRxC * (GLDNUM016 - 1) - tmpR00 * 255;
        lenR00 = (DWORD)255 - lenRed;

        tmpGxM = tmpG00;
        tmpG00 = tmpGxM * (GLDNUM016 - 1) / 255;
        lenGrn = tmpGxM * (GLDNUM016 - 1) - tmpG00 * 255;
        lenG00 = (DWORD)255 - lenGrn;

        tmpBxY = tmpB00;
        tmpB00 = tmpBxY * (GLDNUM016 - 1) / 255;
        lenBlu = tmpBxY * (GLDNUM016 - 1) - tmpB00 * 255;
        lenB00 = (DWORD)255 - lenBlu;

        lutCur = &lutTbl[(tmpR00 * GLDNUM016 + tmpG00) * GLDNUM016 + tmpB00];

        /* 0 */
        calPrm = lenR00 * lenG00 * lenB00;
        tmpCmy = *lutCur;
        tmpRxC = calPrm * tmpCmy.Cyn;
        tmpGxM = calPrm * tmpCmy.Mgt;
        tmpBxY = calPrm * tmpCmy.Yel;
        tmpBla = calPrm * tmpCmy.Bla;

        /* 1 */
        if (lenBlu) {
            calPrm = lenR00 * lenG00 * lenBlu;
            tmpCmy = *(lutCur + 1);
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }
        /* 2 */
        if (lenGrn) {
            calPrm = lenR00 * lenGrn * lenB00;
            tmpCmy = *(lutCur + GLDNUM016);
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }
        /* 3 */
        if (lenGrn && lenBlu) {
            calPrm = lenR00 * lenGrn * lenBlu;
            tmpCmy = *(lutCur + (GLDNUM016 + 1));
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }
        /* 4 */
        if (lenRed) {
            calPrm = lenRed * lenG00 * lenB00;
            tmpCmy = *(lutCur + (GLDNUM016 * GLDNUM016));
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }
        /* 5 */
        if (lenRed && lenBlu) {
            calPrm = lenRed * lenG00 * lenBlu;
            tmpCmy = *(lutCur + (GLDNUM016 * GLDNUM016 + 1));
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }
        /* 6 */
        if (lenRed && lenGrn) {
            calPrm = lenRed * lenGrn * lenB00;
            tmpCmy = *(lutCur + ((GLDNUM016 + 1) * GLDNUM016));
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }
        /* 7 */
        if (lenRed && lenGrn && lenBlu) {
            calPrm = lenRed * lenGrn * lenBlu;
            tmpCmy = *(lutCur + ((GLDNUM016 + 1) * GLDNUM016 + 1));
            tmpRxC += calPrm * tmpCmy.Cyn;
            tmpGxM += calPrm * tmpCmy.Mgt;
            tmpBxY += calPrm * tmpCmy.Yel;
            tmpBla += calPrm * tmpCmy.Bla;
        }

        tmpRxC += (DWORD)255 * 255 * 255 / 2;
        tmpGxM += (DWORD)255 * 255 * 255 / 2;
        tmpBxY += (DWORD)255 * 255 * 255 / 2;
        tmpBla += (DWORD)255 * 255 * 255 / 2;

        tmpCmy.Cyn = (BYTE)(tmpRxC / ((DWORD)255 * 255 * 255));
        tmpCmy.Mgt = (BYTE)(tmpGxM / ((DWORD)255 * 255 * 255));
        tmpCmy.Yel = (BYTE)(tmpBxY / ((DWORD)255 * 255 * 255));
        tmpCmy.Bla = (BYTE)(tmpBla / ((DWORD)255 * 255 * 255));

        /*----- UCR proceure --------------------------------------------------------*/
//      if (ucr != UCRNOO) ExeColMchUcr(&tmpCmy, &tmpRgb, ucr, ucrTbl);
        if (ucr != UCRNOO)
// CASIO 2001/02/15 ->
//          ExeColMchUcr(&tmpCmy, &tmpRgb, ucr, ucrCmy, ucrBla, ucrTbl);
            ExeColMchUcr(&tmpCmy, &tmpRgb, ucr, ucrCmy, ucrBla, ucrTnr, ucrTbl);
// CASIO 2001/02/15 <-

        *cmyAdr++ = tmpCmy;

        /*----- Color matching cache ------------------------------------------------*/
        cchRgb[cch] = tmpRgb; cchCmy[cch] = tmpCmy;
    }

    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Color matching(solid)
//---------------------------------------------------------------------------------------------------
static VOID ExeColCnvSld(                                   // Return value no
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPRGB       rgbAdr,                                     // RGB (input)
    LPCMYK      cmyAdr,                                     // CMYK (output)
//  DWORD       blaCnv                                      // Black replacement 
    LPCOLMCHINF mchInf                                      // Color matching information
)
{
    DWORD       tmpRed, tmpGrn, tmpBlu;
    DWORD       blaCnv, ucr, ucrCmy, ucrBla;
    DWORD       ucrTnr;
    LPCMYK      ucrTbl;
    LPRGB       endAdr;
    LPBYTE      gryTbl;

    blaCnv = mchInf->Bla;
    ucr    = mchInf->Ucr;
    ucrCmy = mchInf->UcrCmy;
    ucrBla = mchInf->UcrBla;
    ucrTnr = mchInf->UcrTnr;                                //+CASIO 2001/02/15
    ucrTbl = mchInf->UcrTbl;
    gryTbl = mchInf->GryTbl;

    for (endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++) {
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Grn;
        tmpBlu = rgbAdr->Blu;
        if (blaCnv == KCGGRY) {
            if ((tmpRed == tmpGrn) && (tmpRed == tmpBlu)) {
                cmyAdr->Cyn = cmyAdr->Mgt = cmyAdr->Yel = 0;
//                cmyAdr->Bla = 255 - GinTblP10[tmpRed];
                cmyAdr->Bla = gryTbl[tmpRed];
                cmyAdr++;
                continue;
            }
        } else if (blaCnv == KCGBLA) {
            if ((tmpRed | tmpGrn | tmpBlu) == 0) {
                cmyAdr->Cyn = cmyAdr->Mgt = cmyAdr->Yel = 0;
                cmyAdr->Bla = 255;
                cmyAdr++;
                continue;
            }
        }
        cmyAdr->Cyn = (BYTE)(255 - tmpRed);
        cmyAdr->Mgt = (BYTE)(255 - tmpGrn);
        cmyAdr->Yel = (BYTE)(255 - tmpBlu);
        cmyAdr->Bla = 0;

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
        /*----- UCR proceure --------------------------------------------------------*/
        if (ucr != UCRNOO)
// CASIO 2001/02/15 ->
//          ExeColMchUcr(cmyAdr, rgbAdr, ucr, ucrCmy, ucrBla, ucrTbl);
            ExeColMchUcr(cmyAdr, rgbAdr, ucr, ucrCmy, ucrBla, ucrTnr, ucrTbl);
// CASIO 2001/02/15 <-
#endif

        cmyAdr++;
    }

    return;
}


//---------------------------------------------------------------------------------------------------
//      RGB -> CMYK(2Level) conversion (for 1dot line)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColCnvL02(                                   // Return value no
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPRGB       rgbAdr,                                     // RGB (input)
    LPCMYK      cmyAdr                                      // CMYK (output)
)
{
    DWORD       tmpRed, tmpGrn, tmpBlu;
    DWORD       tmpMid;
    LPRGB       endAdr;
    BYTE        tmpCyn, tmpMgt, tmpYel;

    for (endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++) {
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Grn;
        tmpBlu = rgbAdr->Blu;
        tmpMid = (tmpRed + tmpGrn + tmpBlu) / 3;
        if (tmpMid > 240) {
            cmyAdr->Cyn = cmyAdr->Mgt = cmyAdr->Yel = cmyAdr->Bla = 0;
            cmyAdr++;
            continue;
        }
        tmpCyn = tmpMgt = tmpYel = 255;
        tmpMid += (255 - tmpMid) / 8;
        if (tmpRed > tmpMid) tmpCyn = 0;
        if (tmpGrn > tmpMid) tmpMgt = 0;
        if (tmpBlu > tmpMid) tmpYel = 0;
        if ((tmpCyn & tmpMgt & tmpYel) == 255) {
            cmyAdr->Cyn = cmyAdr->Mgt = cmyAdr->Yel = 0;
            cmyAdr->Bla = 255;
            cmyAdr++;
            continue;
        }
        cmyAdr->Cyn = tmpCyn;
        cmyAdr->Mgt = tmpMgt;
        cmyAdr->Yel = tmpYel;
        cmyAdr->Bla = 0;
        cmyAdr++;
    }

    return;
}
#endif


//---------------------------------------------------------------------------------------------------
//      RGB -> K conversion (for monochrome)
//---------------------------------------------------------------------------------------------------
static VOID ExeColCnvMon(                                   // Return value no
    DWORD       xaxSiz,                                     // Xsize  (pixel)
    LPRGB       rgbAdr,                                     // RGB (input)
    LPCMYK      cmyAdr,                                     // CMYK (output)
    LPCOLMCHINF mchInf                                      // Color matching information
)
{
    DWORD       tmpRed, tmpGrn, tmpBlu;
    CMYK        tmpCmy;
    LPRGB       endAdr;
    LPBYTE      gryTbl;

    gryTbl = (LPBYTE)(mchInf->LutAdr);

    tmpCmy.Cyn = tmpCmy.Mgt = tmpCmy.Yel = 0;
    for (endAdr = rgbAdr + xaxSiz; rgbAdr < endAdr; rgbAdr++) {
        tmpRed = rgbAdr->Red;
        tmpGrn = rgbAdr->Grn;
        tmpBlu = rgbAdr->Blu;
//        tmpCmy.Bla = (BYTE)255 - GinTblP10[(tmpRed * 3 + tmpGrn * 5 + tmpBlu * 2) / 10];
        tmpCmy.Bla = gryTbl[(tmpRed*3 + tmpGrn*5 + tmpBlu*2) / 10];
        *cmyAdr = tmpCmy;
        cmyAdr++;
    }

    return;
}

//---------------------------------------------------------------------------------------------------
//      Color matching(UCR)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID ExeColMchUcr(                                   // Return value no
    LPCMYK      cmy,                                        // CMYK (input, output)
    LPRGB       rgb,                                        // RGB (input)
    DWORD       ucr,                                        // UCR type
    DWORD       ucrCmy,                                     // UCR (UCR quantity)
    DWORD       ucrBla,                                     // UCR (ink version generation quantity)
    DWORD       ucrTnr,                                     // UCR (Toner gross weight)
    LPCMYK      ucrTbl                                      // UCR table
)
{
    LPCMYK      gryCyn;                                     // Gray value (Cyan conversion value)
    LPCMYK      dnsCyn;                                     // Density value (Cyan conversion value)
    DWORD       blaGen, min, sub, rgbMin, rgbMax, tmp;
    DWORD       ttlTnr, adjVal;
    DWORD       ucrQty;
//  DWORD       gryRat, ucrRat, blaRat, gryDns;
    LONG        cyn, mgt, yel, bla;

    DWORD xx = 128;                                         /* @@@ */

    gryCyn = ucrTbl;
    dnsCyn = ucrTbl + 256;
    ucrTnr = (ucrTnr * (DWORD)255) / (DWORD)100;           //+CASIO 2001/02/15

    cyn = cmy->Cyn;
    mgt = cmy->Mgt;
    yel = cmy->Yel;
    bla = cmy->Bla;

    /*----- Minimum density calculation of CMY  --------------------------------------*/
    min = cyn;
    if (min > dnsCyn[mgt].Mgt) min = dnsCyn[mgt].Mgt;
    if (min > dnsCyn[yel].Yel) min = dnsCyn[yel].Yel;

    if (ucr == UCR001) {                /* TypeT(for char, graphic)    */

        /*----- Gray degree calculation ----------------------------------------------*/
        rgbMin = rgbMax = rgb->Red;
        if (rgbMin > rgb->Grn) rgbMin = rgb->Grn;
        if (rgbMin > rgb->Blu) rgbMin = rgb->Blu;
        if (rgbMax < rgb->Grn) rgbMax = rgb->Grn;
        if (rgbMax < rgb->Blu) rgbMax = rgb->Blu;

// CASIO 2001/02/15 ->
//      sub = (DWORD)255 - (rgbMax - rgbMin);
//      blaGen = min * sub / (DWORD)255;
//
//      gryRat = ((rgbMax - rgbMin) * 100) / 255;
//      gryRat = (gryRat < (DWORD)20)? (DWORD)20 - gryRat: (DWORD)0;
//                                      /* Gray rate [100%] = 20, [80% or less] = 0 */
//
//      /* UCR rate    case of gray-rate(gryRat) 100 to 80%, +20 to +0      */
//      ucrRat = ucrCmy + gryRat;
//      /* Black rate  case of gray-rate(gryRat) 100 to 80%, +10 to +0      */
//      blaRat = ucrBla + (gryRat / 2);
//
//      /* Black rate, case of gray-density(gryDns) 100 to 80%, +10 to +0   */
//      gryDns = rgbMin * 100 / 255;
//      gryDns = (gryDns < (DWORD)20)? (DWORD)20 - gryDns: (DWORD)0;
//      blaRat += (gryDns / 2);
//
//      if (ucrRat > (DWORD)100) ucrRat = (DWORD)100;
//      if (blaRat > (DWORD)100) blaRat = (DWORD)100;
//
//      ucrQty = (blaGen * ucrRat) / 100;
//      blaGen = (blaGen * blaRat) / 100;

        sub = rgbMax - rgbMin;
        if (sub > (DWORD)50) blaGen = (DWORD)0;
        else {
            if (sub <= (DWORD)10) {
                tmp = (DWORD)10 - sub;
                ucrCmy += tmp;
                ucrBla += tmp;
            }
            if (sub <= (DWORD)5) {
                tmp = ((DWORD)5 - sub) * (DWORD)2;
                ucrCmy += tmp;
            }
            if (ucrCmy > 100) ucrCmy = 100;
            if (ucrBla > 100) ucrBla = 100;

            tmp = (DWORD)50 - sub;
            blaGen = min * tmp / (DWORD)50;
        }
// CASIO 2001/02/15 <-

    } else {                            /* TypeU(for image)                */

// CASIO 2001/02/15 ->
//      /* UCR processing be NOP, */
//      /* in the case that minimum density is smaller than the prescription value (50%) */
//      if (min < 127) return;
//
//      /* Density revision (127-255 -> 0-255)                              */
////    min = ((min - 127) * 255 + 64) / 128;
//      min = ((min - 127) * 255 + 64) / xx;
//
//      /* Gamma 3.0 approximation (If the speed-up is necessary table transformation)   */
//      if      (min <=  63) blaGen = 0;
//      else if (min <= 127) blaGen = ((min -  63) * 15         + 32) / 64;
//      else if (min <= 191) blaGen = ((min - 127) * ( 79 - 15) + 32) / 64 + 15;
//      else                 blaGen = ((min - 191) * (255 - 79) + 32) / 64 + 79;
//
//      ucrQty = (blaGen * ucrCmy) / 100; /* UCR quantity                     */
//      blaGen = (blaGen * ucrBla) / 100; /* ink version generation quantity  */

        /* K generation no, */
        /* in the case that minimum density is smaller than the prescription value (50%) */
        if (min < 127) blaGen = 0;
        else {
            /* Density revision (127-255 -> 0-255)                              */
//          min = ((min - 127) * 255 + 64) / 128;
            min = ((min - 127) * 255 + 64) / xx;

            /* Gamma 3.0 approximation (If the speed-up is necessary table transformation)   */
            if      (min <=  63) blaGen = 0;
            else if (min <= 127) blaGen = ((min- 63) *      15  + 32) / 64;
            else if (min <= 191) blaGen = ((min-127) * ( 79-15) + 32) / 64 + 15;
            else                 blaGen = ((min-191) * (255-79) + 32) / 64 + 79;
        }
// CASIO 2001/02/15 <-
    }

    /*----- Toner gross weight calculation(input CMYK value) ------------------------*/
    ttlTnr = cyn + mgt + yel + bla;

    if ((blaGen == 0) && (ttlTnr <= ucrTnr)) return;

    /*----- Ink version generation (K replacement) ----------------------------------*/
// CASIO 2001/02/15 ->
//  if (blaGen == 0) return;
//
//  ucrQty = (blaGen * ucrCmy) / 100;   /* UCR quantity                     */
//  blaGen = (blaGen * ucrBla) / 100;   /* ink version generation quantity  */
//
////cyn -= blaGen;                      /* Adjustment with a gray value     */
//  cyn -= ucrQty;                      /* Adjustment with a gray value     */
////mgt -= gryCyn[blaGen].Mgt;
//  mgt -= gryCyn[ucrQty].Mgt;
////yel -= gryCyn[blaGen].Yel;
//  yel -= gryCyn[ucrQty].Yel;
//  bla += gryCyn[blaGen].Bla;
    if (blaGen) {
        ucrQty = (blaGen * ucrCmy) / 100; /* UCR quantity                   */
        blaGen = (blaGen * ucrBla) / 100; /* ink version generation quantity*/

        cyn -= ucrQty;                  /* Adjustment with a gray value     */
        mgt -= gryCyn[ucrQty].Mgt;
        yel -= gryCyn[ucrQty].Yel;
        bla += gryCyn[blaGen].Bla;

        ttlTnr = cyn + mgt + yel + bla; /* Toner gross weight calculation   */
    }

    /*----- Toner gross weight restriction ---------------------------------*/
    if (ttlTnr > ucrTnr) {
        adjVal = (ttlTnr - ucrTnr + 2) / 3;
        cyn -= adjVal;
        mgt -= adjVal;
        yel -= adjVal;
    }
// CASIO 2001/02/15 <-

    if (cyn <   0) cyn =   0;           /* BYTE value(0 - 255) adjustment   */
    if (mgt <   0) mgt =   0;
    if (yel <   0) yel =   0;
    if (bla <   0) bla =   0;
    if (cyn > 255) cyn = 255;
    if (mgt > 255) mgt = 255;
    if (yel > 255) yel = 255;
    if (bla > 255) bla = 255;

    cmy->Cyn = (BYTE)cyn;               /* UCR processing value setting     */
    cmy->Mgt = (BYTE)mgt;
    cmy->Yel = (BYTE)yel;
    cmy->Bla = (BYTE)bla;

    return;
}
#endif


// End of N5COLMH.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5colsb.c ===
//***************************************************************************************************
//    N5COLSB.C
//
//    Functions of color matching (For N5 printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "COLDEF.H"
#include    "COMDIZ.H"
#include    "N5COLSB.H"


//===================================================================================================
//      Gamma revision table (0.1 - 0.9)
//===================================================================================================
static BYTE GamTbl001[9][256] = {
    /*---- 0.1 ----*/
    {   0x00, 0x91, 0x9c, 0xa2, 0xa7, 0xab, 0xae, 0xb1,
        0xb3, 0xb5, 0xb7, 0xb9, 0xbb, 0xbc, 0xbe, 0xbf,
        0xc0, 0xc1, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc7,
        0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcc, 0xcd, 0xce,
        0xce, 0xcf, 0xd0, 0xd0, 0xd1, 0xd1, 0xd2, 0xd2,
        0xd3, 0xd4, 0xd4, 0xd5, 0xd5, 0xd6, 0xd6, 0xd6,
        0xd7, 0xd7, 0xd8, 0xd8, 0xd9, 0xd9, 0xd9, 0xda,
        0xda, 0xdb, 0xdb, 0xdb, 0xdc, 0xdc, 0xdd, 0xdd,
        0xdd, 0xde, 0xde, 0xde, 0xdf, 0xdf, 0xdf, 0xe0,
        0xe0, 0xe0, 0xe1, 0xe1, 0xe1, 0xe1, 0xe2, 0xe2,
        0xe2, 0xe3, 0xe3, 0xe3, 0xe3, 0xe4, 0xe4, 0xe4,
        0xe5, 0xe5, 0xe5, 0xe5, 0xe6, 0xe6, 0xe6, 0xe6,
        0xe7, 0xe7, 0xe7, 0xe7, 0xe7, 0xe8, 0xe8, 0xe8,
        0xe8, 0xe9, 0xe9, 0xe9, 0xe9, 0xea, 0xea, 0xea,
        0xea, 0xea, 0xeb, 0xeb, 0xeb, 0xeb, 0xeb, 0xec,
        0xec, 0xec, 0xec, 0xec, 0xed, 0xed, 0xed, 0xed,
        0xed, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xef,
        0xef, 0xef, 0xef, 0xef, 0xf0, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf0, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf3,
        0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf4, 0xf4, 0xf4,
        0xf4, 0xf4, 0xf4, 0xf4, 0xf5, 0xf5, 0xf5, 0xf5,
        0xf5, 0xf5, 0xf5, 0xf6, 0xf6, 0xf6, 0xf6, 0xf6,
        0xf6, 0xf6, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7,
        0xf7, 0xf7, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8,
        0xf8, 0xf8, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9,
        0xf9, 0xf9, 0xfa, 0xfa, 0xfa, 0xfa, 0xfa, 0xfa,
        0xfa, 0xfa, 0xfa, 0xfb, 0xfb, 0xfb, 0xfb, 0xfb,
        0xfb, 0xfb, 0xfb, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc,
        0xfc, 0xfc, 0xfc, 0xfc, 0xfd, 0xfd, 0xfd, 0xfd,
        0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfd, 0xfe, 0xfe,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xff  },

    /*---- 0.2 ----*/
    {   0x00, 0x53, 0x60, 0x68, 0x6e, 0x73, 0x78, 0x7b,
        0x7f, 0x82, 0x84, 0x87, 0x89, 0x8c, 0x8e, 0x90,
        0x92, 0x93, 0x95, 0x97, 0x98, 0x9a, 0x9b, 0x9d,
        0x9e, 0x9f, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,
        0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xac, 0xad, 0xae,
        0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb3, 0xb4, 0xb5,
        0xb6, 0xb7, 0xb7, 0xb8, 0xb9, 0xb9, 0xba, 0xbb,
        0xbc, 0xbc, 0xbd, 0xbe, 0xbe, 0xbf, 0xbf, 0xc0,
        0xc1, 0xc1, 0xc2, 0xc2, 0xc3, 0xc4, 0xc4, 0xc5,
        0xc5, 0xc6, 0xc6, 0xc7, 0xc7, 0xc8, 0xc8, 0xc9,
        0xc9, 0xca, 0xcb, 0xcb, 0xcb, 0xcc, 0xcc, 0xcd,
        0xcd, 0xce, 0xce, 0xcf, 0xcf, 0xd0, 0xd0, 0xd1,
        0xd1, 0xd1, 0xd2, 0xd2, 0xd3, 0xd3, 0xd4, 0xd4,
        0xd4, 0xd5, 0xd5, 0xd6, 0xd6, 0xd6, 0xd7, 0xd7,
        0xd8, 0xd8, 0xd8, 0xd9, 0xd9, 0xda, 0xda, 0xda,
        0xdb, 0xdb, 0xdb, 0xdc, 0xdc, 0xdc, 0xdd, 0xdd,
        0xde, 0xde, 0xde, 0xdf, 0xdf, 0xdf, 0xe0, 0xe0,
        0xe0, 0xe1, 0xe1, 0xe1, 0xe2, 0xe2, 0xe2, 0xe3,
        0xe3, 0xe3, 0xe3, 0xe4, 0xe4, 0xe4, 0xe5, 0xe5,
        0xe5, 0xe6, 0xe6, 0xe6, 0xe7, 0xe7, 0xe7, 0xe7,
        0xe8, 0xe8, 0xe8, 0xe9, 0xe9, 0xe9, 0xe9, 0xea,
        0xea, 0xea, 0xeb, 0xeb, 0xeb, 0xeb, 0xec, 0xec,
        0xec, 0xec, 0xed, 0xed, 0xed, 0xee, 0xee, 0xee,
        0xee, 0xef, 0xef, 0xef, 0xef, 0xf0, 0xf0, 0xf0,
        0xf0, 0xf1, 0xf1, 0xf1, 0xf1, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf3, 0xf3, 0xf3, 0xf3, 0xf4, 0xf4, 0xf4,
        0xf4, 0xf5, 0xf5, 0xf5, 0xf5, 0xf5, 0xf6, 0xf6,
        0xf6, 0xf6, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf8,
        0xf8, 0xf8, 0xf8, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9,
        0xfa, 0xfa, 0xfa, 0xfa, 0xfb, 0xfb, 0xfb, 0xfb,
        0xfb, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfd, 0xfd,
        0xfd, 0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xfe, 0xff  },

    /*---- 0.3 ----*/
    {   0x00, 0x30, 0x3b, 0x42, 0x49, 0x4e, 0x52, 0x56,
        0x59, 0x5d, 0x60, 0x62, 0x65, 0x68, 0x6a, 0x6c,
        0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x79, 0x7b,
        0x7d, 0x7e, 0x80, 0x81, 0x83, 0x84, 0x85, 0x87,
        0x88, 0x89, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90,
        0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
        0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9e, 0x9f, 0xa0,
        0xa1, 0xa2, 0xa3, 0xa4, 0xa4, 0xa5, 0xa6, 0xa7,
        0xa8, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xac, 0xad,
        0xae, 0xae, 0xaf, 0xb0, 0xb1, 0xb1, 0xb2, 0xb3,
        0xb3, 0xb4, 0xb5, 0xb5, 0xb6, 0xb7, 0xb7, 0xb8,
        0xb9, 0xb9, 0xba, 0xbb, 0xbb, 0xbc, 0xbc, 0xbd,
        0xbe, 0xbe, 0xbf, 0xbf, 0xc0, 0xc0, 0xc1, 0xc2,
        0xc2, 0xc3, 0xc3, 0xc4, 0xc4, 0xc5, 0xc5, 0xc6,
        0xc7, 0xc7, 0xc8, 0xc8, 0xc9, 0xc9, 0xca, 0xca,
        0xcb, 0xcb, 0xcc, 0xcc, 0xcd, 0xcd, 0xce, 0xce,
        0xcf, 0xcf, 0xd0, 0xd0, 0xd1, 0xd1, 0xd2, 0xd2,
        0xd3, 0xd3, 0xd3, 0xd4, 0xd4, 0xd5, 0xd5, 0xd6,
        0xd6, 0xd7, 0xd7, 0xd8, 0xd8, 0xd8, 0xd9, 0xd9,
        0xda, 0xda, 0xdb, 0xdb, 0xdb, 0xdc, 0xdc, 0xdd,
        0xdd, 0xde, 0xde, 0xde, 0xdf, 0xdf, 0xe0, 0xe0,
        0xe0, 0xe1, 0xe1, 0xe2, 0xe2, 0xe2, 0xe3, 0xe3,
        0xe4, 0xe4, 0xe4, 0xe5, 0xe5, 0xe6, 0xe6, 0xe6,
        0xe7, 0xe7, 0xe7, 0xe8, 0xe8, 0xe9, 0xe9, 0xe9,
        0xea, 0xea, 0xea, 0xeb, 0xeb, 0xeb, 0xec, 0xec,
        0xed, 0xed, 0xed, 0xee, 0xee, 0xee, 0xef, 0xef,
        0xef, 0xf0, 0xf0, 0xf0, 0xf1, 0xf1, 0xf1, 0xf2,
        0xf2, 0xf2, 0xf3, 0xf3, 0xf3, 0xf4, 0xf4, 0xf4,
        0xf5, 0xf5, 0xf5, 0xf6, 0xf6, 0xf6, 0xf7, 0xf7,
        0xf7, 0xf8, 0xf8, 0xf8, 0xf9, 0xf9, 0xf9, 0xfa,
        0xfa, 0xfa, 0xfb, 0xfb, 0xfb, 0xfb, 0xfc, 0xfc,
        0xfc, 0xfd, 0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xff  },

    /*---- 0.4 ----*/
    {   0x00, 0x1b, 0x24, 0x2a, 0x30, 0x34, 0x38, 0x3c,
        0x3f, 0x42, 0x45, 0x48, 0x4a, 0x4d, 0x4f, 0x51,
        0x54, 0x56, 0x58, 0x5a, 0x5b, 0x5d, 0x5f, 0x61,
        0x62, 0x64, 0x66, 0x67, 0x69, 0x6a, 0x6c, 0x6d,
        0x6e, 0x70, 0x71, 0x72, 0x74, 0x75, 0x76, 0x78,
        0x79, 0x7a, 0x7b, 0x7c, 0x7e, 0x7f, 0x80, 0x81,
        0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
        0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91,
        0x92, 0x93, 0x94, 0x95, 0x96, 0x96, 0x97, 0x98,
        0x99, 0x9a, 0x9b, 0x9c, 0x9c, 0x9d, 0x9e, 0x9f,
        0xa0, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa4, 0xa5,
        0xa6, 0xa7, 0xa7, 0xa8, 0xa9, 0xaa, 0xaa, 0xab,
        0xac, 0xad, 0xad, 0xae, 0xaf, 0xaf, 0xb0, 0xb1,
        0xb1, 0xb2, 0xb3, 0xb4, 0xb4, 0xb5, 0xb6, 0xb6,
        0xb7, 0xb7, 0xb8, 0xb9, 0xb9, 0xba, 0xbb, 0xbb,
        0xbc, 0xbd, 0xbd, 0xbe, 0xbe, 0xbf, 0xc0, 0xc0,
        0xc1, 0xc2, 0xc2, 0xc3, 0xc3, 0xc4, 0xc5, 0xc5,
        0xc6, 0xc6, 0xc7, 0xc7, 0xc8, 0xc9, 0xc9, 0xca,
        0xca, 0xcb, 0xcb, 0xcc, 0xcd, 0xcd, 0xce, 0xce,
        0xcf, 0xcf, 0xd0, 0xd0, 0xd1, 0xd1, 0xd2, 0xd2,
        0xd3, 0xd4, 0xd4, 0xd5, 0xd5, 0xd6, 0xd6, 0xd7,
        0xd7, 0xd8, 0xd8, 0xd9, 0xd9, 0xda, 0xda, 0xdb,
        0xdb, 0xdc, 0xdc, 0xdd, 0xdd, 0xde, 0xde, 0xdf,
        0xdf, 0xe0, 0xe0, 0xe1, 0xe1, 0xe2, 0xe2, 0xe3,
        0xe3, 0xe4, 0xe4, 0xe4, 0xe5, 0xe5, 0xe6, 0xe6,
        0xe7, 0xe7, 0xe8, 0xe8, 0xe9, 0xe9, 0xea, 0xea,
        0xea, 0xeb, 0xeb, 0xec, 0xec, 0xed, 0xed, 0xee,
        0xee, 0xef, 0xef, 0xef, 0xf0, 0xf0, 0xf1, 0xf1,
        0xf2, 0xf2, 0xf2, 0xf3, 0xf3, 0xf4, 0xf4, 0xf5,
        0xf5, 0xf5, 0xf6, 0xf6, 0xf7, 0xf7, 0xf8, 0xf8,
        0xf8, 0xf9, 0xf9, 0xfa, 0xfa, 0xfa, 0xfb, 0xfb,
        0xfc, 0xfc, 0xfc, 0xfd, 0xfd, 0xfe, 0xfe, 0xff  },

    /*---- 0.5 ----*/
    {   0x00, 0x0f, 0x16, 0x1b, 0x1f, 0x23, 0x26, 0x2a,
        0x2d, 0x2f, 0x32, 0x34, 0x37, 0x39, 0x3b, 0x3d,
        0x3f, 0x41, 0x43, 0x45, 0x47, 0x48, 0x4a, 0x4c,
        0x4e, 0x4f, 0x51, 0x52, 0x54, 0x55, 0x57, 0x58,
        0x5a, 0x5b, 0x5c, 0x5e, 0x5f, 0x60, 0x62, 0x63,
        0x64, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6c, 0x6d,
        0x6e, 0x6f, 0x70, 0x71, 0x72, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,
        0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86,
        0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8b, 0x8c, 0x8d,
        0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x93, 0x94,
        0x95, 0x96, 0x97, 0x98, 0x99, 0x99, 0x9a, 0x9b,
        0x9c, 0x9d, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa1,
        0xa2, 0xa3, 0xa4, 0xa5, 0xa5, 0xa6, 0xa7, 0xa8,
        0xa8, 0xa9, 0xaa, 0xab, 0xab, 0xac, 0xad, 0xae,
        0xae, 0xaf, 0xb0, 0xb0, 0xb1, 0xb2, 0xb3, 0xb3,
        0xb4, 0xb5, 0xb5, 0xb6, 0xb7, 0xb8, 0xb8, 0xb9,
        0xba, 0xba, 0xbb, 0xbc, 0xbc, 0xbd, 0xbe, 0xbe,
        0xbf, 0xc0, 0xc0, 0xc1, 0xc2, 0xc2, 0xc3, 0xc4,
        0xc4, 0xc5, 0xc6, 0xc6, 0xc7, 0xc7, 0xc8, 0xc9,
        0xc9, 0xca, 0xcb, 0xcb, 0xcc, 0xcd, 0xcd, 0xce,
        0xce, 0xcf, 0xd0, 0xd0, 0xd1, 0xd1, 0xd2, 0xd3,
        0xd3, 0xd4, 0xd4, 0xd5, 0xd6, 0xd6, 0xd7, 0xd7,
        0xd8, 0xd9, 0xd9, 0xda, 0xda, 0xdb, 0xdc, 0xdc,
        0xdd, 0xdd, 0xde, 0xde, 0xdf, 0xe0, 0xe0, 0xe1,
        0xe1, 0xe2, 0xe2, 0xe3, 0xe4, 0xe4, 0xe5, 0xe5,
        0xe6, 0xe6, 0xe7, 0xe7, 0xe8, 0xe9, 0xe9, 0xea,
        0xea, 0xeb, 0xeb, 0xec, 0xec, 0xed, 0xed, 0xee,
        0xee, 0xef, 0xf0, 0xf0, 0xf1, 0xf1, 0xf2, 0xf2,
        0xf3, 0xf3, 0xf4, 0xf4, 0xf5, 0xf5, 0xf6, 0xf6,
        0xf7, 0xf7, 0xf8, 0xf8, 0xf9, 0xf9, 0xfa, 0xfa,
        0xfb, 0xfb, 0xfc, 0xfc, 0xfd, 0xfd, 0xfe, 0xff  },

    /*---- 0.6 ----*/
    {   0x00, 0x09, 0x0d, 0x11, 0x14, 0x18, 0x1a, 0x1d,
        0x1f, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e,
        0x30, 0x32, 0x33, 0x35, 0x37, 0x38, 0x3a, 0x3c,
        0x3d, 0x3f, 0x40, 0x42, 0x43, 0x45, 0x46, 0x47,
        0x49, 0x4a, 0x4b, 0x4d, 0x4e, 0x4f, 0x51, 0x52,
        0x53, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5b, 0x5c,
        0x5d, 0x5e, 0x5f, 0x60, 0x62, 0x63, 0x64, 0x65,
        0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6d, 0x6e,
        0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e,
        0x7f, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85,
        0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8b, 0x8c,
        0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x93,
        0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x99, 0x9a,
        0x9b, 0x9c, 0x9d, 0x9e, 0x9e, 0x9f, 0xa0, 0xa1,
        0xa2, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa6, 0xa7,
        0xa8, 0xa9, 0xaa, 0xaa, 0xab, 0xac, 0xad, 0xad,
        0xae, 0xaf, 0xb0, 0xb1, 0xb1, 0xb2, 0xb3, 0xb4,
        0xb4, 0xb5, 0xb6, 0xb7, 0xb7, 0xb8, 0xb9, 0xba,
        0xba, 0xbb, 0xbc, 0xbd, 0xbd, 0xbe, 0xbf, 0xbf,
        0xc0, 0xc1, 0xc2, 0xc2, 0xc3, 0xc4, 0xc5, 0xc5,
        0xc6, 0xc7, 0xc7, 0xc8, 0xc9, 0xc9, 0xca, 0xcb,
        0xcc, 0xcc, 0xcd, 0xce, 0xce, 0xcf, 0xd0, 0xd0,
        0xd1, 0xd2, 0xd2, 0xd3, 0xd4, 0xd4, 0xd5, 0xd6,
        0xd7, 0xd7, 0xd8, 0xd9, 0xd9, 0xda, 0xdb, 0xdb,
        0xdc, 0xdd, 0xdd, 0xde, 0xde, 0xdf, 0xe0, 0xe0,
        0xe1, 0xe2, 0xe2, 0xe3, 0xe4, 0xe4, 0xe5, 0xe6,
        0xe6, 0xe7, 0xe8, 0xe8, 0xe9, 0xe9, 0xea, 0xeb,
        0xeb, 0xec, 0xed, 0xed, 0xee, 0xef, 0xef, 0xf0,
        0xf0, 0xf1, 0xf2, 0xf2, 0xf3, 0xf4, 0xf4, 0xf5,
        0xf5, 0xf6, 0xf7, 0xf7, 0xf8, 0xf8, 0xf9, 0xfa,
        0xfa, 0xfb, 0xfb, 0xfc, 0xfd, 0xfd, 0xfe, 0xff  },

    /*---- 0.7 ----*/
    {   0x00, 0x05, 0x08, 0x0b, 0x0d, 0x10, 0x12, 0x14,
        0x16, 0x18, 0x1a, 0x1c, 0x1d, 0x1f, 0x21, 0x22,
        0x24, 0x26, 0x27, 0x29, 0x2a, 0x2c, 0x2d, 0x2f,
        0x30, 0x32, 0x33, 0x34, 0x36, 0x37, 0x38, 0x3a,
        0x3b, 0x3c, 0x3e, 0x3f, 0x40, 0x41, 0x43, 0x44,
        0x45, 0x46, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
        0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x57,
        0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
        0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x67, 0x68,
        0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
        0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x77,
        0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
        0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e,
        0x8f, 0x90, 0x91, 0x91, 0x92, 0x93, 0x94, 0x95,
        0x96, 0x97, 0x98, 0x98, 0x99, 0x9a, 0x9b, 0x9c,
        0x9d, 0x9e, 0x9f, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3,
        0xa4, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xa9,
        0xaa, 0xab, 0xac, 0xad, 0xae, 0xae, 0xaf, 0xb0,
        0xb1, 0xb2, 0xb3, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
        0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbb, 0xbc, 0xbd,
        0xbe, 0xbf, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc3,
        0xc4, 0xc5, 0xc6, 0xc6, 0xc7, 0xc8, 0xc9, 0xca,
        0xca, 0xcb, 0xcc, 0xcd, 0xcd, 0xce, 0xcf, 0xd0,
        0xd1, 0xd1, 0xd2, 0xd3, 0xd4, 0xd4, 0xd5, 0xd6,
        0xd7, 0xd7, 0xd8, 0xd9, 0xda, 0xda, 0xdb, 0xdc,
        0xdd, 0xdd, 0xde, 0xdf, 0xe0, 0xe0, 0xe1, 0xe2,
        0xe2, 0xe3, 0xe4, 0xe5, 0xe5, 0xe6, 0xe7, 0xe8,
        0xe8, 0xe9, 0xea, 0xeb, 0xeb, 0xec, 0xed, 0xed,
        0xee, 0xef, 0xf0, 0xf0, 0xf1, 0xf2, 0xf2, 0xf3,
        0xf4, 0xf5, 0xf5, 0xf6, 0xf7, 0xf7, 0xf8, 0xf9,
        0xfa, 0xfa, 0xfb, 0xfc, 0xfc, 0xfd, 0xfe, 0xff  },

    /*---- 0.8 ----*/
    {   0x00, 0x03, 0x05, 0x07, 0x09, 0x0a, 0x0c, 0x0e,
        0x0f, 0x11, 0x13, 0x14, 0x16, 0x17, 0x18, 0x1a,
        0x1b, 0x1d, 0x1e, 0x1f, 0x21, 0x22, 0x23, 0x25,
        0x26, 0x27, 0x28, 0x2a, 0x2b, 0x2c, 0x2d, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x35, 0x36, 0x37, 0x38,
        0x39, 0x3a, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41,
        0x42, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a,
        0x4b, 0x4c, 0x4d, 0x4e, 0x50, 0x51, 0x52, 0x53,
        0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b,
        0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
        0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
        0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73,
        0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b,
        0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x82,
        0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a,
        0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x90, 0x91,
        0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99,
        0x9a, 0x9b, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0,
        0xa1, 0xa2, 0xa3, 0xa4, 0xa4, 0xa5, 0xa6, 0xa7,
        0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xac, 0xad, 0xae,
        0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb3, 0xb4, 0xb5,
        0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xba, 0xbb, 0xbc,
        0xbd, 0xbe, 0xbf, 0xc0, 0xc0, 0xc1, 0xc2, 0xc3,
        0xc4, 0xc5, 0xc6, 0xc6, 0xc7, 0xc8, 0xc9, 0xca,
        0xcb, 0xcc, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1,
        0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd6, 0xd7,
        0xd8, 0xd9, 0xda, 0xdb, 0xdb, 0xdc, 0xdd, 0xde,
        0xdf, 0xe0, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5,
        0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xe9, 0xea, 0xeb,
        0xec, 0xed, 0xee, 0xee, 0xef, 0xf0, 0xf1, 0xf2,
        0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf6, 0xf7, 0xf8,
        0xf9, 0xfa, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff  },

    /*---- 0.9 ----*/
    {   0x00, 0x01, 0x03, 0x04, 0x06, 0x07, 0x08, 0x09,
        0x0b, 0x0c, 0x0d, 0x0f, 0x10, 0x11, 0x12, 0x13,
        0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1c, 0x1d,
        0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x25, 0x26,
        0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x40,
        0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
        0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,
        0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
        0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60,
        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
        0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
        0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80,
        0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88,
        0x89, 0x8a, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
        0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
        0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
        0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6,
        0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae,
        0xaf, 0xb0, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5,
        0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd,
        0xbe, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4,
        0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcb,
        0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3,
        0xd4, 0xd5, 0xd6, 0xd6, 0xd7, 0xd8, 0xd9, 0xda,
        0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe1,
        0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9,
        0xea, 0xeb, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0,
        0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff  }
};

//===================================================================================================
//      Gamma revision table (1.2 to 3.0)
//===================================================================================================
static BYTE GamTbl002[10][256] = {
    /*---- 1.2 ----*/
    {   0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x03,
        0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x07, 0x08,
        0x09, 0x09, 0x0a, 0x0b, 0x0b, 0x0c, 0x0d, 0x0e,
        0x0e, 0x0f, 0x10, 0x11, 0x11, 0x12, 0x13, 0x14,
        0x15, 0x15, 0x16, 0x17, 0x18, 0x19, 0x19, 0x1a,
        0x1b, 0x1c, 0x1d, 0x1e, 0x1e, 0x1f, 0x20, 0x21,
        0x22, 0x23, 0x24, 0x24, 0x25, 0x26, 0x27, 0x28,
        0x29, 0x2a, 0x2b, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,
        0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
        0x47, 0x48, 0x49, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
        0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
        0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d,
        0x5e, 0x5f, 0x60, 0x61, 0x63, 0x64, 0x65, 0x66,
        0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e,
        0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
        0x88, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90,
        0x91, 0x92, 0x93, 0x94, 0x96, 0x97, 0x98, 0x99,
        0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xa0, 0xa1, 0xa2,
        0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xaa, 0xab,
        0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb3, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xbb, 0xbc, 0xbd,
        0xbe, 0xbf, 0xc0, 0xc1, 0xc3, 0xc4, 0xc5, 0xc6,
        0xc7, 0xc8, 0xc9, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd9,
        0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xe0, 0xe1, 0xe2,
        0xe3, 0xe4, 0xe5, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,
        0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf3, 0xf4, 0xf5,
        0xf6, 0xf7, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xff  },

    /*---- 1.4 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
        0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04,
        0x05, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x08,
        0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0c, 0x0c, 0x0d,
        0x0d, 0x0e, 0x0f, 0x0f, 0x10, 0x11, 0x11, 0x12,
        0x13, 0x13, 0x14, 0x15, 0x15, 0x16, 0x17, 0x17,
        0x18, 0x19, 0x1a, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d,
        0x1e, 0x1f, 0x20, 0x20, 0x21, 0x22, 0x23, 0x23,
        0x24, 0x25, 0x26, 0x27, 0x28, 0x28, 0x29, 0x2a,
        0x2b, 0x2c, 0x2d, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
        0x32, 0x33, 0x34, 0x34, 0x35, 0x36, 0x37, 0x38,
        0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3e, 0x3f,
        0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
        0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
        0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x60,
        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6a, 0x6b, 0x6c, 0x6e, 0x6f, 0x70, 0x71,
        0x72, 0x73, 0x74, 0x75, 0x76, 0x78, 0x79, 0x7a,
        0x7b, 0x7c, 0x7d, 0x7e, 0x80, 0x81, 0x82, 0x83,
        0x84, 0x85, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c,
        0x8e, 0x8f, 0x90, 0x91, 0x92, 0x94, 0x95, 0x96,
        0x97, 0x98, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xa0,
        0xa1, 0xa2, 0xa3, 0xa5, 0xa6, 0xa7, 0xa8, 0xaa,
        0xab, 0xac, 0xad, 0xaf, 0xb0, 0xb1, 0xb2, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb9, 0xba, 0xbb, 0xbd, 0xbe,
        0xbf, 0xc0, 0xc2, 0xc3, 0xc4, 0xc6, 0xc7, 0xc8,
        0xca, 0xcb, 0xcc, 0xce, 0xcf, 0xd0, 0xd1, 0xd3,
        0xd4, 0xd5, 0xd7, 0xd8, 0xd9, 0xdb, 0xdc, 0xde,
        0xdf, 0xe0, 0xe2, 0xe3, 0xe4, 0xe6, 0xe7, 0xe8,
        0xea, 0xeb, 0xec, 0xee, 0xef, 0xf1, 0xf2, 0xf3,
        0xf5, 0xf6, 0xf8, 0xf9, 0xfa, 0xfc, 0xfd, 0xff  },

    /*---- 1.6 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02,
        0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05,
        0x05, 0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08,
        0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c, 0x0c,
        0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f, 0x10, 0x11,
        0x11, 0x12, 0x12, 0x13, 0x13, 0x14, 0x15, 0x15,
        0x16, 0x17, 0x17, 0x18, 0x19, 0x19, 0x1a, 0x1b,
        0x1b, 0x1c, 0x1d, 0x1e, 0x1e, 0x1f, 0x20, 0x20,
        0x21, 0x22, 0x23, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2b, 0x2c, 0x2d,
        0x2e, 0x2f, 0x30, 0x30, 0x31, 0x32, 0x33, 0x34,
        0x35, 0x36, 0x37, 0x38, 0x38, 0x39, 0x3a, 0x3b,
        0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,
        0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b,
        0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
        0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5b, 0x5c,
        0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x65,
        0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6d, 0x6e,
        0x6f, 0x70, 0x71, 0x72, 0x74, 0x75, 0x76, 0x77,
        0x78, 0x7a, 0x7b, 0x7c, 0x7d, 0x7f, 0x80, 0x81,
        0x82, 0x83, 0x85, 0x86, 0x87, 0x89, 0x8a, 0x8b,
        0x8c, 0x8e, 0x8f, 0x90, 0x92, 0x93, 0x94, 0x95,
        0x97, 0x98, 0x99, 0x9b, 0x9c, 0x9d, 0x9f, 0xa0,
        0xa1, 0xa3, 0xa4, 0xa5, 0xa7, 0xa8, 0xaa, 0xab,
        0xac, 0xae, 0xaf, 0xb0, 0xb2, 0xb3, 0xb5, 0xb6,
        0xb8, 0xb9, 0xba, 0xbc, 0xbd, 0xbf, 0xc0, 0xc2,
        0xc3, 0xc4, 0xc6, 0xc7, 0xc9, 0xca, 0xcc, 0xcd,
        0xcf, 0xd0, 0xd2, 0xd3, 0xd5, 0xd6, 0xd8, 0xd9,
        0xdb, 0xdc, 0xde, 0xdf, 0xe1, 0xe2, 0xe4, 0xe5,
        0xe7, 0xe8, 0xea, 0xec, 0xed, 0xef, 0xf0, 0xf2,
        0xf3, 0xf5, 0xf7, 0xf8, 0xfa, 0xfb, 0xfd, 0xff  },

    /*---- 1.8 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03,
        0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05,
        0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08,
        0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c,
        0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f, 0x10,
        0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 0x14,
        0x15, 0x15, 0x16, 0x16, 0x17, 0x18, 0x18, 0x19,
        0x1a, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d, 0x1e, 0x1e,
        0x1f, 0x20, 0x21, 0x21, 0x22, 0x23, 0x24, 0x24,
        0x25, 0x26, 0x27, 0x27, 0x28, 0x29, 0x2a, 0x2b,
        0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x30, 0x31,
        0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
        0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40,
        0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
        0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x50, 0x51,
        0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
        0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x62, 0x63,
        0x64, 0x65, 0x66, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
        0x6e, 0x6f, 0x70, 0x71, 0x73, 0x74, 0x75, 0x76,
        0x78, 0x79, 0x7a, 0x7c, 0x7d, 0x7e, 0x80, 0x81,
        0x82, 0x84, 0x85, 0x86, 0x88, 0x89, 0x8a, 0x8c,
        0x8d, 0x8f, 0x90, 0x91, 0x93, 0x94, 0x96, 0x97,
        0x98, 0x9a, 0x9b, 0x9d, 0x9e, 0xa0, 0xa1, 0xa3,
        0xa4, 0xa6, 0xa7, 0xa9, 0xaa, 0xac, 0xad, 0xaf,
        0xb0, 0xb2, 0xb3, 0xb5, 0xb6, 0xb8, 0xb9, 0xbb,
        0xbd, 0xbe, 0xc0, 0xc1, 0xc3, 0xc5, 0xc6, 0xc8,
        0xc9, 0xcb, 0xcd, 0xce, 0xd0, 0xd2, 0xd3, 0xd5,
        0xd7, 0xd8, 0xda, 0xdc, 0xdd, 0xdf, 0xe1, 0xe2,
        0xe4, 0xe6, 0xe8, 0xe9, 0xeb, 0xed, 0xef, 0xf0,
        0xf2, 0xf4, 0xf6, 0xf7, 0xf9, 0xfb, 0xfd, 0xff  },

    /*---- 2.0 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
        0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
        0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05,
        0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08,
        0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b,
        0x0c, 0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f,
        0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13,
        0x14, 0x14, 0x15, 0x16, 0x16, 0x17, 0x17, 0x18,
        0x19, 0x19, 0x1a, 0x1b, 0x1b, 0x1c, 0x1d, 0x1d,
        0x1e, 0x1f, 0x1f, 0x20, 0x21, 0x21, 0x22, 0x23,
        0x24, 0x24, 0x25, 0x26, 0x27, 0x28, 0x28, 0x29,
        0x2a, 0x2b, 0x2c, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
        0x31, 0x32, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
        0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4f, 0x50,
        0x51, 0x52, 0x53, 0x54, 0x55, 0x57, 0x58, 0x59,
        0x5a, 0x5b, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x63,
        0x64, 0x65, 0x66, 0x68, 0x69, 0x6a, 0x6c, 0x6d,
        0x6e, 0x70, 0x71, 0x72, 0x74, 0x75, 0x76, 0x78,
        0x79, 0x7a, 0x7c, 0x7d, 0x7f, 0x80, 0x81, 0x83,
        0x84, 0x86, 0x87, 0x89, 0x8a, 0x8c, 0x8d, 0x8f,
        0x90, 0x92, 0x93, 0x95, 0x96, 0x98, 0x99, 0x9b,
        0x9c, 0x9e, 0xa0, 0xa1, 0xa3, 0xa4, 0xa6, 0xa8,
        0xa9, 0xab, 0xac, 0xae, 0xb0, 0xb1, 0xb3, 0xb5,
        0xb6, 0xb8, 0xba, 0xbc, 0xbd, 0xbf, 0xc1, 0xc3,
        0xc4, 0xc6, 0xc8, 0xca, 0xcb, 0xcd, 0xcf, 0xd1,
        0xd3, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 0xe0,
        0xe1, 0xe3, 0xe5, 0xe7, 0xe9, 0xeb, 0xed, 0xef,
        0xf1, 0xf3, 0xf5, 0xf7, 0xf9, 0xfb, 0xfd, 0xff  },

    /*---- 2.2 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04,
        0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06,
        0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08,
        0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b,
        0x0c, 0x0c, 0x0d, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f,
        0x0f, 0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13,
        0x13, 0x14, 0x14, 0x15, 0x16, 0x16, 0x17, 0x17,
        0x18, 0x19, 0x19, 0x1a, 0x1b, 0x1b, 0x1c, 0x1d,
        0x1d, 0x1e, 0x1f, 0x1f, 0x20, 0x21, 0x21, 0x22,
        0x23, 0x24, 0x24, 0x25, 0x26, 0x27, 0x28, 0x28,
        0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2d, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,
        0x3f, 0x40, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        0x48, 0x49, 0x4a, 0x4b, 0x4d, 0x4e, 0x4f, 0x50,
        0x51, 0x52, 0x54, 0x55, 0x56, 0x57, 0x58, 0x5a,
        0x5b, 0x5c, 0x5d, 0x5f, 0x60, 0x61, 0x63, 0x64,
        0x65, 0x67, 0x68, 0x69, 0x6b, 0x6c, 0x6d, 0x6f,
        0x70, 0x72, 0x73, 0x75, 0x76, 0x77, 0x79, 0x7a,
        0x7c, 0x7d, 0x7f, 0x80, 0x82, 0x83, 0x85, 0x86,
        0x88, 0x8a, 0x8b, 0x8d, 0x8e, 0x90, 0x92, 0x93,
        0x95, 0x97, 0x98, 0x9a, 0x9c, 0x9d, 0x9f, 0xa1,
        0xa2, 0xa4, 0xa6, 0xa8, 0xa9, 0xab, 0xad, 0xaf,
        0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbb, 0xbd,
        0xbf, 0xc1, 0xc3, 0xc5, 0xc7, 0xc9, 0xcb, 0xcd,
        0xcf, 0xd1, 0xd3, 0xd5, 0xd7, 0xd9, 0xdb, 0xdd,
        0xdf, 0xe1, 0xe3, 0xe5, 0xe7, 0xe9, 0xeb, 0xed,
        0xef, 0xf1, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xff  },

    /*---- 2.4 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
        0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04,
        0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06,
        0x06, 0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08,
        0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b,
        0x0c, 0x0c, 0x0d, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f,
        0x0f, 0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13,
        0x13, 0x14, 0x14, 0x15, 0x16, 0x16, 0x17, 0x17,
        0x18, 0x19, 0x19, 0x1a, 0x1a, 0x1b, 0x1c, 0x1c,
        0x1d, 0x1e, 0x1e, 0x1f, 0x20, 0x21, 0x21, 0x22,
        0x23, 0x24, 0x24, 0x25, 0x26, 0x27, 0x28, 0x28,
        0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
        0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
        0x40, 0x41, 0x42, 0x43, 0x45, 0x46, 0x47, 0x48,
        0x49, 0x4a, 0x4b, 0x4d, 0x4e, 0x4f, 0x50, 0x52,
        0x53, 0x54, 0x55, 0x57, 0x58, 0x59, 0x5a, 0x5c,
        0x5d, 0x5e, 0x60, 0x61, 0x63, 0x64, 0x65, 0x67,
        0x68, 0x6a, 0x6b, 0x6d, 0x6e, 0x6f, 0x71, 0x72,
        0x74, 0x76, 0x77, 0x79, 0x7a, 0x7c, 0x7d, 0x7f,
        0x81, 0x82, 0x84, 0x85, 0x87, 0x89, 0x8a, 0x8c,
        0x8e, 0x90, 0x91, 0x93, 0x95, 0x96, 0x98, 0x9a,
        0x9c, 0x9e, 0x9f, 0xa1, 0xa3, 0xa5, 0xa7, 0xa9,
        0xab, 0xad, 0xaf, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8,
        0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 0xc7, 0xc9,
        0xcb, 0xcd, 0xcf, 0xd1, 0xd3, 0xd5, 0xd8, 0xda,
        0xdc, 0xde, 0xe0, 0xe3, 0xe5, 0xe7, 0xe9, 0xec,
        0xee, 0xf0, 0xf3, 0xf5, 0xf7, 0xfa, 0xfc, 0xff  },

    /*---- 2.6 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x03,
        0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04,
        0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06,
        0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09,
        0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c,
        0x0c, 0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f,
        0x10, 0x10, 0x10, 0x11, 0x11, 0x12, 0x13, 0x13,
        0x14, 0x14, 0x15, 0x15, 0x16, 0x16, 0x17, 0x18,
        0x18, 0x19, 0x19, 0x1a, 0x1b, 0x1b, 0x1c, 0x1d,
        0x1e, 0x1e, 0x1f, 0x20, 0x20, 0x21, 0x22, 0x23,
        0x23, 0x24, 0x25, 0x26, 0x27, 0x27, 0x28, 0x29,
        0x2a, 0x2b, 0x2c, 0x2d, 0x2d, 0x2e, 0x2f, 0x30,
        0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
        0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3f, 0x40, 0x41,
        0x42, 0x43, 0x44, 0x45, 0x47, 0x48, 0x49, 0x4a,
        0x4b, 0x4d, 0x4e, 0x4f, 0x50, 0x52, 0x53, 0x54,
        0x56, 0x57, 0x58, 0x5a, 0x5b, 0x5c, 0x5e, 0x5f,
        0x61, 0x62, 0x64, 0x65, 0x67, 0x68, 0x6a, 0x6b,
        0x6d, 0x6e, 0x70, 0x71, 0x73, 0x75, 0x76, 0x78,
        0x79, 0x7b, 0x7d, 0x7e, 0x80, 0x82, 0x84, 0x85,
        0x87, 0x89, 0x8b, 0x8c, 0x8e, 0x90, 0x92, 0x94,
        0x96, 0x97, 0x99, 0x9b, 0x9d, 0x9f, 0xa1, 0xa3,
        0xa5, 0xa7, 0xa9, 0xab, 0xad, 0xaf, 0xb1, 0xb3,
        0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc5,
        0xc7, 0xc9, 0xcb, 0xce, 0xd0, 0xd2, 0xd5, 0xd7,
        0xd9, 0xdc, 0xde, 0xe0, 0xe3, 0xe5, 0xe8, 0xea,
        0xed, 0xef, 0xf2, 0xf4, 0xf7, 0xf9, 0xfc, 0xff  },

    /*---- 2.8 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03,
        0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05,
        0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x07,
        0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09, 0x09,
        0x09, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c, 0x0c,
        0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f, 0x10,
        0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 0x14,
        0x14, 0x15, 0x15, 0x16, 0x16, 0x17, 0x18, 0x18,
        0x19, 0x1a, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d, 0x1e,
        0x1e, 0x1f, 0x20, 0x21, 0x21, 0x22, 0x23, 0x24,
        0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2a,
        0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32,
        0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a,
        0x3b, 0x3c, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43,
        0x45, 0x46, 0x47, 0x48, 0x4a, 0x4b, 0x4c, 0x4d,
        0x4f, 0x50, 0x51, 0x53, 0x54, 0x56, 0x57, 0x58,
        0x5a, 0x5b, 0x5d, 0x5e, 0x60, 0x61, 0x63, 0x64,
        0x66, 0x67, 0x69, 0x6a, 0x6c, 0x6e, 0x6f, 0x71,
        0x73, 0x74, 0x76, 0x78, 0x7a, 0x7b, 0x7d, 0x7f,
        0x81, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e,
        0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
        0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xaf,
        0xb1, 0xb3, 0xb5, 0xb8, 0xba, 0xbc, 0xbe, 0xc1,
        0xc3, 0xc6, 0xc8, 0xca, 0xcd, 0xcf, 0xd2, 0xd4,
        0xd7, 0xd9, 0xdc, 0xde, 0xe1, 0xe3, 0xe6, 0xe9,
        0xeb, 0xee, 0xf1, 0xf3, 0xf6, 0xf9, 0xfc, 0xff  },

    /*---- 3.0 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03,
        0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04,
        0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06,
        0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x09,
        0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0c,
        0x0c, 0x0c, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f, 0x0f,
        0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x14,
        0x14, 0x15, 0x15, 0x16, 0x17, 0x17, 0x18, 0x19,
        0x19, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d, 0x1e, 0x1f,
        0x20, 0x21, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
        0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x36, 0x37, 0x38,
        0x39, 0x3b, 0x3c, 0x3d, 0x3f, 0x40, 0x42, 0x43,
        0x45, 0x46, 0x48, 0x49, 0x4b, 0x4c, 0x4e, 0x50,
        0x51, 0x53, 0x55, 0x57, 0x59, 0x5a, 0x5c, 0x5e,
        0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e,
        0x70, 0x73, 0x75, 0x77, 0x79, 0x7c, 0x7e, 0x80,
        0x83, 0x85, 0x88, 0x8a, 0x8d, 0x8f, 0x92, 0x95,
        0x97, 0x9a, 0x9d, 0xa0, 0xa2, 0xa5, 0xa8, 0xab,
        0xae, 0xb1, 0xb4, 0xb7, 0xbb, 0xbe, 0xc1, 0xc4,
        0xc8, 0xcb, 0xce, 0xd2, 0xd5, 0xd9, 0xdc, 0xe0,
        0xe4, 0xe7, 0xeb, 0xef, 0xf3, 0xf7, 0xfb, 0xff  }
};


//===================================================================================================
//      Toner density table make
//===================================================================================================
static VOID ColDnsMak(                                      // Return value no
    LONG,                                                   // Density(-30 to 30)
    LPBYTE                                                  // Density table address
);

//===================================================================================================
//      Brightness table make
//===================================================================================================
static VOID ColLgtMak(                                      // Return value no
    LONG,                                                   // Brightness(-100 to 100)
    LPBYTE                                                  // Brightness table address
);

//===================================================================================================
//      Contrast table make
//===================================================================================================
static VOID ColConMak(                                      // Return value no
    LONG,                                                   // Contrast(-100 to 100)
    LPBYTE                                                  // Contrast table address
);


//***************************************************************************************************
//      Functions
//***************************************************************************************************
//===================================================================================================
//      RBG color control
//===================================================================================================
VOID WINAPI N501ColCtrRgb(                                  // Return value no
    DWORD       xaxSiz,                                     // X Size (pioxel)
    LPRGB       rgbBuf,                                     // RGB buffer pointer
//  RGBINF      rgbInf                                      // RBG information
    LPRGBINF    rgbInf                                      // RBG information
)
{
    LONG        tmpRed, tmpGrn, tmpBlu;
    LONG        tmpMid;
    LPRGB       endAdr;
    LPBYTE      gamTblRed = 0;
    LPBYTE      gamTblGrn = 0;
    LPBYTE      gamTblBlu = 0;
    LPBYTE      dnsTbl = 0;
    LPBYTE      lgtTbl = 0, conTbl = 0;
    BYTE        tmpTbl[256], tmpTbl001[256], tmpTbl002[256];

    /*----- Gamma revision table address set ----------------------------------------*/
//  if ((rgbInf.Gmr > 0) && (rgbInf.Gmr < 10))
//      gamTblRed = GamTbl001[rgbInf.Gmr - 1];
//  else if ((rgbInf.Gmr > 10) && (rgbInf.Gmr < 31))
//      gamTblRed = GamTbl002[(rgbInf.Gmr - 11) / 2];
//
//  if ((rgbInf.Gmg > 0) && (rgbInf.Gmg < 10))
//      gamTblGrn = GamTbl001[rgbInf.Gmg - 1];
//  else if ((rgbInf.Gmg > 10) && (rgbInf.Gmg < 31))
//      gamTblGrn = GamTbl002[(rgbInf.Gmg - 11) / 2];
//
//  if ((rgbInf.Gmb > 0) && (rgbInf.Gmb < 10))
//      gamTblBlu = GamTbl001[rgbInf.Gmb - 1];
//  else if ((rgbInf.Gmb > 10) && (rgbInf.Gmb < 31))
//      gamTblBlu = GamTbl002[(rgbInf.Gmb - 11) / 2];
    if ((rgbInf->Gmr > 0) && (rgbInf->Gmr < 10))
        gamTblRed = GamTbl001[rgbInf->Gmr - 1];
    else if ((rgbInf->Gmr > 10) && (rgbInf->Gmr < 31))
        gamTblRed = GamTbl002[(rgbInf->Gmr - 11) / 2];

    if ((rgbInf->Gmg > 0) && (rgbInf->Gmg < 10))
        gamTblGrn = GamTbl001[rgbInf->Gmg - 1];
    else if ((rgbInf->Gmg > 10) && (rgbInf->Gmg < 31))
        gamTblGrn = GamTbl002[(rgbInf->Gmg - 11) / 2];

    if ((rgbInf->Gmb > 0) && (rgbInf->Gmb < 10))
        gamTblBlu = GamTbl001[rgbInf->Gmb - 1];
    else if ((rgbInf->Gmb > 10) && (rgbInf->Gmb < 31))
        gamTblBlu = GamTbl002[(rgbInf->Gmb - 11) / 2];

    /*----- Printing density table address set --------------------------------------*/
//  if (rgbInf.Dns) {
    if (rgbInf->DnsRgb) {
//      ColDnsMak(rgbInf.Dns * (-1), tmpTbl);
        ColDnsMak(rgbInf->DnsRgb * (-1), tmpTbl);
        dnsTbl = tmpTbl;
    }

    /*----- Brightness table address set --------------------------------------------*/
//  if (rgbInf.Lgt) {
    if (rgbInf->Lgt) {
//      ColLgtMak(rgbInf.Lgt, tmpTbl001);
        ColLgtMak(rgbInf->Lgt, tmpTbl001);
        lgtTbl = tmpTbl001;
    }

    /*----- Contrast table address set ----------------------------------------------*/
//  if (rgbInf.Con) {
    if (rgbInf->Con) {
//      ColConMak(rgbInf.Con, tmpTbl002);
        ColConMak(rgbInf->Con, tmpTbl002);
        conTbl = tmpTbl002;
    }

    /*===== RBG color control =================================================*/
    for (endAdr = rgbBuf + xaxSiz; rgbBuf < endAdr; rgbBuf++) {
        tmpRed = rgbBuf->Red;
        tmpGrn = rgbBuf->Grn;
        tmpBlu = rgbBuf->Blu;

        /*----- Printing density ----------------------------------------------------*/
        if (dnsTbl) {
            tmpRed = dnsTbl[tmpRed];
            tmpGrn = dnsTbl[tmpGrn];
            tmpBlu = dnsTbl[tmpBlu];
        }

        /*----- Brightness ----------------------------------------------------------*/
////    if (rgbInf.Lgt != 0) {
////        tmpRed += rgbInf.Lgt / 3;
////        tmpGrn += rgbInf.Lgt / 3;
////        tmpBlu += rgbInf.Lgt / 3;
        if (rgbInf->Lgt != 0) {
            tmpRed = lgtTbl[tmpRed];
            tmpGrn = lgtTbl[tmpGrn];
            tmpBlu = lgtTbl[tmpBlu];

            /****** Conventionally specification *************************************/
//          tmpRed += rgbInf->Lgt / 3;
//          tmpGrn += rgbInf->Lgt / 3;
//          tmpBlu += rgbInf->Lgt / 3;
//          if (tmpRed < 0) tmpRed = 0; else if (tmpRed > 255) tmpRed = 255;
//          if (tmpGrn < 0) tmpGrn = 0; else if (tmpGrn > 255) tmpGrn = 255;
//          if (tmpBlu < 0) tmpBlu = 0; else if (tmpBlu > 255) tmpBlu = 255;
        }

        /*----- Contrast ------------------------------------------------------------*/
//      if (rgbInf.Con != 0) {
        if (rgbInf->Con != 0) {
            tmpRed = conTbl[tmpRed];
            tmpGrn = conTbl[tmpGrn];
            tmpBlu = conTbl[tmpBlu];
        }

        /*----- Chroma (Old, contrast)-----------------------------------------------*/
//      if (rgbInf.Crm != 0) {
        if (rgbInf->Crm != 0) {
            tmpMid = (tmpRed + tmpGrn + tmpBlu) / 3;
//          tmpRed += (tmpRed - tmpMid) * rgbInf.Crm / 200;
//          tmpGrn += (tmpGrn - tmpMid) * rgbInf.Crm / 200;
//          tmpBlu += (tmpBlu - tmpMid) * rgbInf.Crm / 200;
            tmpRed += (tmpRed - tmpMid) * rgbInf->Crm / 200;
            tmpGrn += (tmpGrn - tmpMid) * rgbInf->Crm / 200;
            tmpBlu += (tmpBlu - tmpMid) * rgbInf->Crm / 200;
            if (tmpRed < 0) tmpRed = 0; else if (tmpRed > 255) tmpRed = 255;
            if (tmpGrn < 0) tmpGrn = 0; else if (tmpGrn > 255) tmpGrn = 255;
            if (tmpBlu < 0) tmpBlu = 0; else if (tmpBlu > 255) tmpBlu = 255;
        }

        /*----- Gamma ---------------------------------------------------------------*/
        if (gamTblRed) tmpRed = gamTblRed[tmpRed];
        if (gamTblGrn) tmpGrn = gamTblGrn[tmpGrn];
        if (gamTblBlu) tmpBlu = gamTblBlu[tmpBlu];

        rgbBuf->Red = (BYTE)tmpRed;
        rgbBuf->Grn = (BYTE)tmpGrn;
        rgbBuf->Blu = (BYTE)tmpBlu;
    }

    return;
}


//===================================================================================================
//      CMYK color control
//===================================================================================================
VOID WINAPI N501ColCtrCmy(                                  // Return value no
    DWORD       xaxSiz,                                     // X Size (pioxel)
    LPCMYK      cmyBuf,                                     // RGB buffer pointer
//  CMYKINF     cmyInf                                      // CMYK information
    LPCMYKINF   cmyInf                                      // CMYK information
)
{
    LONG        tmpCyn, tmpMgt, tmpYel, tmpBla;
    LONG        tmpMid;
    LPCMYK      endAdr;
    LPBYTE      dnsTblCyn = 0;
    LPBYTE      dnsTblMgt = 0;
    LPBYTE      dnsTblYel = 0;
    LPBYTE      dnsTblBla = 0;
    BYTE        tmpTblCyn[256], tmpTblMgt[256], tmpTblYel[256], tmpTblBla[256];

    /*----- Printing density table address set --------------------------------------*/
//  if (cmyInf.DnsCyn) {
//      ColDnsMak(cmyInf.DnsCyn, tmpTblCyn);
    if (cmyInf->DnsCyn) {
        ColDnsMak(cmyInf->DnsCyn, tmpTblCyn);
        dnsTblCyn = tmpTblCyn;
    }
//  if (cmyInf.DnsMgt) {
//      ColDnsMak(cmyInf.DnsMgt, tmpTblMgt);
    if (cmyInf->DnsMgt) {
        ColDnsMak(cmyInf->DnsMgt, tmpTblMgt);
        dnsTblMgt = tmpTblMgt;
    }
//  if (cmyInf.DnsYel) {
//      ColDnsMak(cmyInf.DnsYel, tmpTblYel);
    if (cmyInf->DnsYel) {
        ColDnsMak(cmyInf->DnsYel, tmpTblYel);
        dnsTblYel = tmpTblYel;
    }
//  if (cmyInf.DnsBla) {
//      ColDnsMak(cmyInf.DnsBla, tmpTblBla);
    if (cmyInf->DnsBla) {
        ColDnsMak(cmyInf->DnsBla, tmpTblBla);
        dnsTblBla = tmpTblBla;
    }

    /*===== CMYK color control ==============================================*/
    for (endAdr = cmyBuf + xaxSiz; cmyBuf < endAdr; cmyBuf++) {
        tmpCyn = cmyBuf->Cyn;
        tmpMgt = cmyBuf->Mgt;
        tmpYel = cmyBuf->Yel;
        tmpBla = cmyBuf->Bla;

        /*----- Vivid ---------------------------------------------------------------*/
//      if (cmyInf.Viv) {
        if (cmyInf->Viv) {
            tmpMid = (tmpCyn + tmpMgt + tmpYel) / 3;
//          tmpCyn += (tmpCyn - tmpMid) * cmyInf.Viv / 100;
//          tmpMgt += (tmpMgt - tmpMid) * cmyInf.Viv / 100;
//          tmpYel += (tmpYel - tmpMid) * cmyInf.Viv / 100;
            tmpCyn += (tmpCyn - tmpMid) * cmyInf->Viv / 100;
            tmpMgt += (tmpMgt - tmpMid) * cmyInf->Viv / 100;
            tmpYel += (tmpYel - tmpMid) * cmyInf->Viv / 100;
            if (tmpCyn < 0) tmpCyn = 0; else if (tmpCyn > 255) tmpCyn = 255;
            if (tmpMgt < 0) tmpMgt = 0; else if (tmpMgt > 255) tmpMgt = 255;
            if (tmpYel < 0) tmpYel = 0; else if (tmpYel > 255) tmpYel = 255;
        }

        /*----- Printing density adjustment -----------------------------------------*/
        if (dnsTblCyn) tmpCyn = dnsTblCyn[tmpCyn];
        if (dnsTblMgt) tmpMgt = dnsTblMgt[tmpMgt];
        if (dnsTblYel) tmpYel = dnsTblYel[tmpYel];
        if (dnsTblBla) tmpBla = dnsTblBla[tmpBla];

        cmyBuf->Cyn = (BYTE)tmpCyn;
        cmyBuf->Mgt = (BYTE)tmpMgt;
        cmyBuf->Yel = (BYTE)tmpYel;
        cmyBuf->Bla = (BYTE)tmpBla;
    }

    return;
}


//***************************************************************************************************
//      Static functions
//***************************************************************************************************
//===================================================================================================
//      Toner density table make
//===================================================================================================
static VOID ColDnsMak(                                      // Return value no
    LONG        prnDns,                                     // Density(-30 to 30)
    LPBYTE      dnsTbl                                      // Density table address
)
{
    LONG        innNum;
    LONG        outNum;

    prnDns *= 2;

//  dnsTbl[0] = (BYTE)0;
//  for (innNum = 1; innNum <= 254; innNum++) {
    for (innNum = 0; innNum <= 255; innNum++) {
        outNum = innNum + prnDns;
        if (outNum <   0) outNum =   0;
        if (outNum > 255) outNum = 255;
        dnsTbl[innNum] = (BYTE)outNum;
    }
//  dnsTbl[255] = (BYTE)255;

    return;
}


//===================================================================================================
//      Brightness table make
//===================================================================================================
static VOID ColLgtMak(                                      // Return value no
    LONG        lgt,                                        // Brightness(-100 to 100)
    LPBYTE      tbl                                         // Brightness table address
)
{
    LONG        prnDns;
    LPBYTE      dnsTbl;
    LONG        innNum, outNum;

    prnDns = lgt;
    dnsTbl = tbl;

    if (prnDns < 0) {
        for (innNum = 0; innNum < 256; innNum++) {
            if (innNum == 255) outNum = 255;
            else               outNum = innNum * (255 + prnDns) / 255;
            dnsTbl[innNum] = (BYTE)outNum;
        }
    } else {
        for (innNum = 0; innNum < 256; innNum++) {
            if (innNum == 0) outNum = 0;
            else             outNum = (innNum + prnDns) * 255 / (255 + prnDns);
            dnsTbl[innNum] = (BYTE)outNum;
        }
    }

    return;
}


//===================================================================================================
//      Contrast table make
//===================================================================================================
static VOID ColConMak(                                      // Return value no
    LONG        con,                                        // Contrast(-100 to 100)
    LPBYTE      tbl                                         // Contrast table address
)
{
    LONG        n, m, min, mid, max, rng;

    mid = (LONG)127;                                        /* The mean value be 127 fixation   */

    if (con > 0) {
        min = con * mid / (LONG)100;                        /* min (0 - 127)                    */
        max = (LONG)255 - min;                              /* max (128 to 255)                   */
        rng = max - min;                                    /* Inclination range                */

        /*----- Contrast up ---------------------------------------------------------*/
        for (n = 0; n <= min; n++) tbl[n] = (BYTE)0;
        for (m = 0; n <= max; n++, m++)
            tbl[n] = (BYTE)((m * (LONG)255) / rng);
        for (; n <= (LONG)255; n++) tbl[n] = (BYTE)255;

    } else {
        con *= (LONG)(-1);                                  /* Contrast value is integer                */
        min = con * mid / (LONG)100;                        /* min (0 to 127)                            */
        max = (LONG)255 - min;                              /* max (128 to 255)                          */
        rng = max - min;                                    /* Inclination range                        */

        /*----- Contrast down -------------------------------------------------------*/
        for (n = 0; n <= (LONG)255; n++) 
            tbl[n] = (BYTE)(((n * rng) / (LONG)255) + min);

    }

    return;
}


// End of N5COLSB.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5colmh.h ===
//***************************************************************************************************
//    N5COLMH.H
//
//    C Header (Functions of dither and color matching (For N5 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//***************************************************************************************************
//    Functions
//***************************************************************************************************
VOID  WINAPI N501ColCchIni(LPCOLMCHINF);

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColGryTblMak(DWORD, LPCMYK, LPBYTE, LPBYTE);
DWORD WINAPI N501ColUcrTblMak(DWORD, LPCMYK, LPCMYK, LPBYTE);
#endif

VOID  WINAPI N501ColMchPrc(DWORD, LPRGB, LPCMYK, LPCOLMCHINF);

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
VOID  WINAPI N501ColPtcPrc(DWORD, DWORD, LPBYTE, LPCMYK, LPCMYK);
#endif

VOID  WINAPI N501ColCnvC2r(DWORD, LPCMYK, LPRGB, DWORD, LPBYTE);

//  End of N5COLMH.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5colsb.h ===
//***************************************************************************************************
//    N5COLSB.H
//
//    C Header (Functions of dither and color matching (For N5 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//***************************************************************************************************
//    Functions
//***************************************************************************************************
VOID WINAPI N501ColCtrRgb(DWORD, LPRGB, LPRGBINF);
VOID WINAPI N501ColCtrCmy(DWORD, LPCMYK, LPCMYKINF);

//  End of N5COLSB.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\n501diz.h ===
//***************************************************************************************************
//    N501DIZ.H
//
//    C Header (Functions of dither and color matching (For N5 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//***************************************************************************************************
//    Functions
//***************************************************************************************************
VOID  WINAPI N501ColCchIni(LPCOLMCHINF);
DWORD WINAPI N501ColGryTblMak(DWORD, LPCMYK, LPBYTE, LPBYTE);
DWORD WINAPI N501ColUcrTblMak(DWORD, LPCMYK, LPCMYK, LPBYTE);
VOID  WINAPI N501ColMchPrc(DWORD, LPRGB, LPCMYK, LPCOLMCHINF);
VOID  WINAPI N501ColPtcPrc(DWORD, DWORD, LPBYTE, LPCMYK, LPCMYK);
VOID  WINAPI N501ColCnvC2r(DWORD, LPCMYK, LPRGB, DWORD, LPBYTE);
VOID  WINAPI N501ColCtrRgb(DWORD, LPRGB, LPRGBINF);
VOID  WINAPI N501ColCtrCmy(DWORD, LPCMYK, LPCMYKINF);
DWORD WINAPI N501ColLutDatRdd(LPBYTE, DWORD);
DWORD WINAPI N501ColLutMakGlb(LPRGB, LPCMYK, LPRGBINF, LPCMYKINF, LPCMYK, LPBYTE);
DWORD WINAPI N501ColLutMakGlbMon(LPRGB, LPRGBINF, LPCMYKINF, LPCMYK, LPBYTE);
VOID  WINAPI N501ColLutMak032(LPCMYK, LPCMYK, LPBYTE);
DWORD WINAPI N501ColColDatRdd(LPBYTE, LPDWORD);
DWORD WINAPI N501ColDizInfSet(LPBYTE, LPDIZINF, LPBYTE);
DWORD WINAPI N501ColDrwInfSet(LPDIZINF, LPDRWINF, DWORD);
VOID  WINAPI N501ColDizPrc(LPDIZINF, LPDRWINF);

//  End of N501DIZ.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5dizmk.c ===
//***************************************************************************************************
//    N5DIZMK.C
//
//    Functions dithering (For N5 printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "COLDEF.H"
#include    "COMDIZ.H"
#include    "N5COLMH.H"
#include    "N5COLSB.H"
#include    "N5DIZMK.H"


//===================================================================================================
//      Definition of the random number dithering pattern distinction bit
//===================================================================================================
#define NEWSTO          0x80000000      /* MSB ON                           */

//===================================================================================================
//      LUT data ID correspondence table
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
//static DWORD ColLutIdtTbl[4] =
//    /*  Brightness(Direct)  tincture(Direct)    Brightness(linear)  tincture(linear)        */
//    {   0x20000000,         0x20000002,         0x20000001,         0x20000003 };
static DWORD ColLutIdtTbl[2] =
    /*  Brightness(Direct)  tincture(Direct)    */
    {   0x20000000,         0x20000002 };
#endif

//===================================================================================================
//      Dithering pattern data ID correspondence table
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
//static DWORD ColDizDizIdtTbl[2][5][4][5] = {
static DWORD ColDizDizIdtTbl621[2][5][4][5] = {
/*        C           M           Y           K        Monochrome                   */
  /****** For Char, Graphic (8x8 size) **********************************************/
  {
    /*===== 300dpi 2value ==========================================================*/
  { { 0x20000000, 0x20000001, 0x20000002, 0x20000003, 0x20000038 },   /* fime       */
    { 0x20000000, 0x20000001, 0x20000002, 0x20000003, 0x20000038 },   /* middle     */
    { 0x20000000, 0x20000001, 0x20000002, 0x20000003, 0x20000038 },   /* rough      */
    { 0x20000000, 0x20000001, 0x20000002, 0x20000003, 0x20000038 } }, /* random     */
    /*===== 300dpi 16value =========================================================*/
  { { 0x20000004, 0x20000005, 0x20000006, 0x20000007, 0x20000039 },   /* fime       */
    { 0x20000004, 0x20000005, 0x20000006, 0x20000007, 0x20000039 },   /* middle     */
    { 0x20000004, 0x20000005, 0x20000006, 0x20000007, 0x20000039 },   /* rough      */
    { 0x20000004, 0x20000005, 0x20000006, 0x20000007, 0x20000039 } }, /* random     */
    /*===== 600dpi  2value =========================================================*/
  { { 0x20000008, 0x20000009, 0x2000000A, 0x2000000B, 0x2000003A },   /* fime       */
    { 0x20000008, 0x20000009, 0x2000000A, 0x2000000B, 0x2000003A },   /* middle     */
    { 0x20000008, 0x20000009, 0x2000000A, 0x2000000B, 0x2000003A },   /* rough      */
    { 0x20000008, 0x20000009, 0x2000000A, 0x2000000B, 0x2000003A } }, /* random     */
    /*===== 600dpi  4value =========================================================*/
  { { 0x2000000C, 0x2000000D, 0x2000000E, 0x2000000F, 0x2000003B },   /* fime       */
    { 0x2000000C, 0x2000000D, 0x2000000E, 0x2000000F, 0x2000003B },   /* middle     */
    { 0x2000000C, 0x2000000D, 0x2000000E, 0x2000000F, 0x2000003B },   /* rough      */
    { 0x2000000C, 0x2000000D, 0x2000000E, 0x2000000F, 0x2000003B } }, /* random     */
    /*===== 600dpi 16value =========================================================*/
  { { 0x20000010, 0x20000011, 0x20000012, 0x20000013, 0x2000003C },   /* fime       */
    { 0x20000010, 0x20000011, 0x20000012, 0x20000013, 0x2000003C },   /* middle     */
    { 0x20000010, 0x20000011, 0x20000012, 0x20000013, 0x2000003C },   /* rough      */
    { 0x20000010, 0x20000011, 0x20000012, 0x20000013, 0x2000003C } }  /* random     */
  }, 
  /****** For Image (Optional size) *************************************************/
  {
    /*===== 300dpi  2value =========================================================*/
  { { 0x20000014, 0x20000015, 0x20000016, 0x20000017, 0x2000003D },   /* fime       */
    { 0x20000014, 0x20000015, 0x20000016, 0x20000017, 0x2000003D },   /* middle     */
    { 0x20000014, 0x20000015, 0x20000016, 0x20000017, 0x2000003D },   /* rough      */
    { (NEWSTO+0), (NEWSTO+1), (NEWSTO+2), (NEWSTO+3), (NEWSTO+3) } }, /* random     */
    /*===== 300dpi 16value =========================================================*/
  { { 0x20000018, 0x20000019, 0x2000001A, 0x2000001B, 0x2000003E },   /* fime       */
    { 0x20000018, 0x20000019, 0x2000001A, 0x2000001B, 0x2000003E },   /* middle     */
    { 0x20000018, 0x20000019, 0x2000001A, 0x2000001B, 0x2000003E },   /* rough      */
    { (NEWSTO+4), (NEWSTO+5), (NEWSTO+6), (NEWSTO+7), (NEWSTO+7) } }, /* random     */
    /*===== 600dpi  2value =========================================================*/
  { { 0x2000001C, 0x2000001D, 0x2000001E, 0x20000051, 0x2000003F },   /* fime       */
    { 0x2000001C, 0x2000001D, 0x2000001E, 0x20000051, 0x2000001F },   /* middle     */
    { 0x2000001C, 0x2000001D, 0x2000001E, 0x20000051, 0x20000040 },   /* rough      */
    { (NEWSTO+8), (NEWSTO+9), (NEWSTO+10),(NEWSTO+11),(NEWSTO+11)} }, /* random     */
    /*===== 600dpi  4value =========================================================*/
  { { 0x20000020, 0x20000021, 0x20000022, 0x20000023, 0x20000023 },   /* fime       */
    { 0x20000024, 0x20000025, 0x20000026, 0x20000052, 0x20000027 },   /* middle     */
    { 0x20000047, 0x20000048, 0x2000002A, 0x2000002B, 0x2000002A },   /* rough      */
    { (NEWSTO+12),(NEWSTO+13),(NEWSTO+14),(NEWSTO+15),(NEWSTO+15)} }, /* random     */
    /*===== 600dpi 16value =========================================================*/
  { { 0x2000002C, 0x2000002D, 0x2000002E, 0x2000002F, 0x2000002F },   /* fime       */
    { 0x20000030, 0x20000031, 0x20000032, 0x20000053, 0x20000033 },   /* middle     */
    { 0x20000049, 0x2000004A, 0x20000036, 0x20000037, 0x20000036 },   /* rough      */
    { (NEWSTO+16),(NEWSTO+17),(NEWSTO+18),(NEWSTO+19),(NEWSTO+19)} }  /* random     */
  }
};
#endif

static DWORD ColDizDizIdtTbl516[2][3][4] = {
/*    fime        middle      rough       random                                    */
  /****** Characte or Graphic (8 x 8 size) ******************************************/
  { { 0x20000038, 0x20000038, 0x20000038, 0x20000038 },     /*  300dpi 2value       */
    { 0x2000003A, 0x2000003A, 0x2000003A, 0x2000003A },     /*  600dpi 2value       */
    { 0x30000000, 0x30000000, 0x30000000, 0x30000000 } },   /* 1200dpi 2value       */
  /****** Image (optional size) *****************************************************/
  { { 0x2000003D, 0x2000003D, 0x20000040, (NEWSTO+3) },     /*  300dpi 2value       */
    { 0x2000003F, 0x2000001F, 0x20000040, (NEWSTO+11) },    /*  600dpi 2value       */
    { 0x30000001, 0x30000002, 0x30000003, (NEWSTO+11) } }   /* 1200dpi 2value       */
};

//===================================================================================================
//      Revision value table data ID correspondence table
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
//static DWORD ColDizAdjIdtTbl[2][5][4][5] = {
static DWORD ColDizAdjIdtTbl621[2][5][4][5] = {
/*        C           M           Y           K        Monochrome                   */
  /****** For Char, Graphic (8x8 size) **********************************************/
  {
    /*===== 300dpi  2value =========================================================*/
  { { 0x20000000, 0x20000000, 0x20000001, 0x20000001, 0x20000001 },   /* fime       */
    { 0x20000000, 0x20000000, 0x20000001, 0x20000001, 0x20000001 },   /* middle     */
    { 0x20000000, 0x20000000, 0x20000001, 0x20000001, 0x20000001 },   /* rough      */
    { 0x20000000, 0x20000000, 0x20000001, 0x20000001, 0x20000001 } }, /* random     */
    /*===== 300dpi 16value =========================================================*/
  { { 0x20000002, 0x20000002, 0x20000003, 0x20000004, 0x20000004 },   /* fime       */
    { 0x20000002, 0x20000002, 0x20000003, 0x20000004, 0x20000004 },   /* middle     */
    { 0x20000002, 0x20000002, 0x20000003, 0x20000004, 0x20000004 },   /* rough      */
    { 0x20000002, 0x20000002, 0x20000003, 0x20000004, 0x20000004 } }, /* random     */
    /*===== 600dpi 2value =========================================================*/
  { { 0x20000005, 0x20000005, 0x20000006, 0x20000006, 0x20000006 },   /* fime       */
    { 0x20000005, 0x20000005, 0x20000006, 0x20000006, 0x20000006 },   /* middle     */
    { 0x20000005, 0x20000005, 0x20000006, 0x20000006, 0x20000006 },   /* rough      */
    { 0x20000005, 0x20000005, 0x20000006, 0x20000006, 0x20000006 } }, /* random     */
    /*===== 600dpi 4value =========================================================*/
  { { 0x20000007, 0x20000007, 0x20000008, 0x20000008, 0x20000008 },   /* fime       */
    { 0x20000007, 0x20000007, 0x20000008, 0x20000008, 0x20000008 },   /* middle     */
    { 0x20000007, 0x20000007, 0x20000008, 0x20000008, 0x20000008 },   /* rough      */
    { 0x20000007, 0x20000007, 0x20000008, 0x20000008, 0x20000008 } }, /* random     */
    /*===== 600dpi 16value =========================================================*/
  { { 0x20000009, 0x20000009, 0x2000000A, 0x2000000A, 0x2000000A },   /* fime       */
    { 0x20000009, 0x20000009, 0x2000000A, 0x2000000A, 0x2000000A },   /* middle     */
    { 0x20000009, 0x20000009, 0x2000000A, 0x2000000A, 0x2000000A },   /* rough      */
    { 0x20000009, 0x20000009, 0x2000000A, 0x2000000A, 0x2000000A } }  /* random     */
  }, 
  /****** For Image (Optional size) *************************************************/
  {
    /*===== 300dpi  2value =========================================================*/
  { { 0x2000000B, 0x2000000B, 0x20000001, 0x20000001, 0x20000001 },   /* fime       */
    { 0x2000000B, 0x2000000B, 0x20000001, 0x20000001, 0x20000001 },   /* middle     */
    { 0x2000000B, 0x2000000B, 0x20000001, 0x20000001, 0x20000001 },   /* rough      */
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 } }, /* random     */
    /*===== 300dpi 16value =========================================================*/
  { { 0x2000000C, 0x2000000C, 0x20000003, 0x20000004, 0x20000003 },   /* fime       */
    { 0x2000000C, 0x2000000C, 0x20000003, 0x20000004, 0x20000003 },   /* middle     */
    { 0x2000000C, 0x2000000C, 0x20000003, 0x20000004, 0x20000003 },   /* rough      */
    { 0x00000001, 0x00000001, 0x00000001, 0x00000001, 0x00000001 } }, /* random     */
    /*===== 600dpi  2value =========================================================*/
  { { 0x2000000D, 0x2000000D, 0x20000006, 0x20000023, 0x2000001F },   /* fime       */
    { 0x2000000D, 0x2000000D, 0x20000006, 0x20000023, 0x2000000E },   /* middle     */
    { 0x2000000D, 0x2000000D, 0x20000006, 0x20000023, 0x20000020 },   /* rough      */
    { 0x00000002, 0x00000002, 0x00000002, 0x00000002, 0x00000002 } }, /* random     */
    /*===== 600dpi  4value =========================================================*/
  { { 0x2000000F, 0x2000000F, 0x20000010, 0x20000011, 0x20000011 },   /* fime       */
    { 0x20000012, 0x20000012, 0x20000008, 0x20000024, 0x20000013 },   /* middle     */
    { 0x20000021, 0x20000021, 0x20000015, 0x20000016, 0x20000015 },   /* rough      */
    { 0x00000003, 0x00000003, 0x00000003, 0x00000003, 0x00000003 } }, /* random     */
    /*===== 600dpi 16value =========================================================*/
  { { 0x20000017, 0x20000017, 0x20000018, 0x20000019, 0x20000019 },   /* fime       */
    { 0x2000001A, 0x2000001A, 0x2000000A, 0x20000025, 0x2000001B },   /* middle     */
    { 0x20000022, 0x20000022, 0x2000001D, 0x2000001E, 0x2000001D },   /* rough      */
    { 0x00000004, 0x00000004, 0x00000004, 0x00000004, 0x00000004 } }  /* random     */
  }
};
#endif

static DWORD ColDizAdjIdtTbl516[2][3][4] = {
/*    fime        middle      rough       random                                    */
  /****** Characte or Graphic (8 x 8 size) ******************************************/
  { { 0x30000000, 0x30000000, 0x30000000, 0x30000000 },     /*  300dpi 2value       */
    { 0x30000001, 0x30000001, 0x30000001, 0x30000001 },     /*  600dpi 2value       */
    { 0x30000002, 0x30000002, 0x30000002, 0x30000002 } },   /* 1200dpi 2value       */
  /****** Image (optional size) *****************************************************/
  { { 0x30000000, 0x30000000, 0x30000003, 0x30000004 },     /*  300dpi 2value       */
    { 0x30000005, 0x30000006, 0x30000007, 0x30000008 },     /*  600dpi 2value       */
    { 0x30000009, 0x3000000A, 0x3000000B, 0x3000000C } }    /* 1200dpi 2value       */
};

//===================================================================================================
//      Random number dithering pattern inside ID correspondence table
//===================================================================================================
static struct {
    DWORD   Idt;                        /* Dithering pattern ID             */
    DWORD   IdtTbl;                     /* Many value mask table ID         */
    DWORD   Sls;                        /* Threshold                        */
    DWORD   OfsXax;                     /* Offset X (base pattern shift)    */
    DWORD   OfsYax;                     /* Offset Y (base pattern shift)    */
} ColDizIdtTblSto[20] = {
    /*  inside ID         Idt         TblIdt   Sls  OfsX  OfsY              */
    /* (NEWSTO+0)  */ { 0x00000000, 0xFFFFFFFF,  1,  181,  33 }, /* 302 C   */
    /* (NEWSTO+1)  */ { 0x00000000, 0xFFFFFFFF,  1,   53, 118 }, /* 302 M   */
    /* (NEWSTO+2)  */ { 0x00000000, 0xFFFFFFFF,  1,  138, 161 }, /* 302 Y   */
    /* (NEWSTO+3)  */ { 0x00000000, 0xFFFFFFFF,  1,    0,   0 }, /* 302 K   */
    /* (NEWSTO+4)  */ { 0x00000001, 0x00000005, 15,  181,  33 }, /* 316 C   */
    /* (NEWSTO+5)  */ { 0x00000001, 0x00000005, 15,   53, 118 }, /* 316 M   */
    /* (NEWSTO+6)  */ { 0x00000001, 0x00000005, 15,  138, 161 }, /* 316 Y   */
    /* (NEWSTO+7)  */ { 0x00000001, 0x00000005, 15,    0,   0 }, /* 316 K   */
    /* (NEWSTO+8)  */ { 0x00000000, 0xFFFFFFFF,  1,  181,  33 }, /* 602 C   */
    /* (NEWSTO+9)  */ { 0x00000000, 0xFFFFFFFF,  1,   53, 118 }, /* 602 M   */
    /* (NEWSTO+10) */ { 0x00000000, 0xFFFFFFFF,  1,  138, 161 }, /* 602 Y   */
    /* (NEWSTO+11) */ { 0x00000000, 0xFFFFFFFF,  1,    0,   0 }, /* 602 K   */
    /* (NEWSTO+12) */ { 0x00000001, 0x00000006,  3,  181,  33 }, /* 604 C   */
    /* (NEWSTO+13) */ { 0x00000001, 0x00000006,  3,   53, 118 }, /* 604 M   */
    /* (NEWSTO+14) */ { 0x00000001, 0x00000006,  3,  138, 161 }, /* 604 Y   */
    /* (NEWSTO+15) */ { 0x00000001, 0x00000006,  3,    0,   0 }, /* 604 K   */
    /* (NEWSTO+16) */ { 0x00000001, 0x00000007, 15,  181,  33 }, /* 616 C   */
    /* (NEWSTO+17) */ { 0x00000001, 0x00000007, 15,   53, 118 }, /* 616 M   */
    /* (NEWSTO+18) */ { 0x00000001, 0x00000007, 15,  138, 161 }, /* 616 Y   */
    /* (NEWSTO+19) */ { 0x00000001, 0x00000007, 15,    0,   0 }  /* 616 K   */
};

//===================================================================================================
//      Dot gain revision table
//===================================================================================================
static BYTE GinTblP10[256] = {
    /* 00 */    0x00,0x01,0x02,0x04,0x05,0x06,0x07,0x09,
    /* 08 */    0x0a,0x0b,0x0c,0x0d,0x0f,0x10,0x11,0x12,
    /* 10 */    0x13,0x15,0x16,0x17,0x18,0x1a,0x1b,0x1c,
    /* 18 */    0x1d,0x1e,0x20,0x21,0x22,0x23,0x24,0x26,
    /* 20 */    0x27,0x28,0x29,0x2b,0x2c,0x2d,0x2e,0x2f,
    /* 28 */    0x31,0x32,0x33,0x34,0x35,0x37,0x38,0x39,
    /* 30 */    0x3a,0x3b,0x3d,0x3e,0x3f,0x40,0x41,0x43,
    /* 38 */    0x44,0x45,0x46,0x47,0x48,0x4a,0x4b,0x4c,
    /* 40 */    0x4d,0x4e,0x50,0x51,0x52,0x53,0x54,0x55,
    /* 48 */    0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5e,0x5f,
    /* 50 */    0x60,0x61,0x62,0x63,0x65,0x66,0x67,0x68,
    /* 58 */    0x69,0x6a,0x6b,0x6d,0x6e,0x6f,0x70,0x71,
    /* 60 */    0x72,0x73,0x74,0x76,0x77,0x78,0x79,0x7a,
    /* 68 */    0x7b,0x7c,0x7d,0x7e,0x7f,0x81,0x82,0x83,
    /* 70 */    0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,
    /* 78 */    0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,
    /* 80 */    0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,
    /* 88 */    0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,
    /* 90 */    0xa3,0xa4,0xa5,0xa5,0xa6,0xa7,0xa8,0xa9,
    /* 98 */    0xaa,0xab,0xac,0xac,0xad,0xae,0xaf,0xb0,
    /* a0 */    0xb1,0xb2,0xb3,0xb3,0xb4,0xb5,0xb6,0xb7,
    /* a8 */    0xb8,0xb9,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,
    /* b0 */    0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc4,
    /* b8 */    0xc5,0xc6,0xc7,0xc8,0xc9,0xc9,0xca,0xcb,
    /* c0 */    0xcc,0xcd,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,
    /* c8 */    0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd7,0xd8,
    /* d0 */    0xd9,0xda,0xdb,0xdb,0xdc,0xdd,0xde,0xdf,
    /* d8 */    0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe4,0xe5,
    /* e0 */    0xe6,0xe7,0xe8,0xe8,0xe9,0xea,0xeb,0xec,
    /* e8 */    0xec,0xed,0xee,0xef,0xf0,0xf0,0xf1,0xf2,
    /* f0 */    0xf3,0xf4,0xf5,0xf5,0xf6,0xf7,0xf8,0xf9,
    /* f8 */    0xf9,0xfa,0xfb,0xfc,0xfd,0xfd,0xfe,0xff
};

//===================================================================================================
//      Gamma revision table for sRGB (1.2)
//===================================================================================================
static BYTE GamTbl[256] = 
    /*---- 1.2 ----*/
    {   0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x02, 0x03,
        0x03, 0x04, 0x05, 0x05, 0x06, 0x07, 0x07, 0x08,
        0x09, 0x09, 0x0a, 0x0b, 0x0b, 0x0c, 0x0d, 0x0e,
        0x0e, 0x0f, 0x10, 0x11, 0x11, 0x12, 0x13, 0x14,
        0x15, 0x15, 0x16, 0x17, 0x18, 0x19, 0x19, 0x1a,
        0x1b, 0x1c, 0x1d, 0x1e, 0x1e, 0x1f, 0x20, 0x21,
        0x22, 0x23, 0x24, 0x24, 0x25, 0x26, 0x27, 0x28,
        0x29, 0x2a, 0x2b, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x35, 0x36,
        0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e,
        0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46,
        0x47, 0x48, 0x49, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
        0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
        0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d,
        0x5e, 0x5f, 0x60, 0x61, 0x63, 0x64, 0x65, 0x66,
        0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e,
        0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
        0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
        0x88, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90,
        0x91, 0x92, 0x93, 0x94, 0x96, 0x97, 0x98, 0x99,
        0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xa0, 0xa1, 0xa2,
        0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xaa, 0xab,
        0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb3, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xbb, 0xbc, 0xbd,
        0xbe, 0xbf, 0xc0, 0xc1, 0xc3, 0xc4, 0xc5, 0xc6,
        0xc7, 0xc8, 0xc9, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
        0xd0, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd9,
        0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xe0, 0xe1, 0xe2,
        0xe3, 0xe4, 0xe5, 0xe7, 0xe8, 0xe9, 0xea, 0xeb,
        0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf3, 0xf4, 0xf5,
        0xf6, 0xf7, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xff  };

//===================================================================================================
//      Gamma revision table for sRGB MONO (1.4)
//===================================================================================================
static BYTE GamTblMon[256] = 
    /*---- 1.4 ----*/
    {   0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
        0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x04, 0x04,
        0x05, 0x05, 0x06, 0x06, 0x07, 0x07, 0x08, 0x08,
        0x09, 0x09, 0x0a, 0x0a, 0x0b, 0x0c, 0x0c, 0x0d,
        0x0d, 0x0e, 0x0f, 0x0f, 0x10, 0x11, 0x11, 0x12,
        0x13, 0x13, 0x14, 0x15, 0x15, 0x16, 0x17, 0x17,
        0x18, 0x19, 0x1a, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d,
        0x1e, 0x1f, 0x20, 0x20, 0x21, 0x22, 0x23, 0x23,
        0x24, 0x25, 0x26, 0x27, 0x28, 0x28, 0x29, 0x2a,
        0x2b, 0x2c, 0x2d, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
        0x32, 0x33, 0x34, 0x34, 0x35, 0x36, 0x37, 0x38,
        0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3e, 0x3f,
        0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
        0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
        0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
        0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x60,
        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6a, 0x6b, 0x6c, 0x6e, 0x6f, 0x70, 0x71,
        0x72, 0x73, 0x74, 0x75, 0x76, 0x78, 0x79, 0x7a,
        0x7b, 0x7c, 0x7d, 0x7e, 0x80, 0x81, 0x82, 0x83,
        0x84, 0x85, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c,
        0x8e, 0x8f, 0x90, 0x91, 0x92, 0x94, 0x95, 0x96,
        0x97, 0x98, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0xa0,
        0xa1, 0xa2, 0xa3, 0xa5, 0xa6, 0xa7, 0xa8, 0xaa,
        0xab, 0xac, 0xad, 0xaf, 0xb0, 0xb1, 0xb2, 0xb4,
        0xb5, 0xb6, 0xb7, 0xb9, 0xba, 0xbb, 0xbd, 0xbe,
        0xbf, 0xc0, 0xc2, 0xc3, 0xc4, 0xc6, 0xc7, 0xc8,
        0xca, 0xcb, 0xcc, 0xce, 0xcf, 0xd0, 0xd1, 0xd3,
        0xd4, 0xd5, 0xd7, 0xd8, 0xd9, 0xdb, 0xdc, 0xde,
        0xdf, 0xe0, 0xe2, 0xe3, 0xe4, 0xe6, 0xe7, 0xe8,
        0xea, 0xeb, 0xec, 0xee, 0xef, 0xf1, 0xf2, 0xf3,
        0xf5, 0xf6, 0xf8, 0xf9, 0xfa, 0xfc, 0xfd, 0xff  };


//===================================================================================================
//      Static functions
//===================================================================================================
//---------------------------------------------------------------------------------------------------
//      Dithering pattern ID , Get adjustment value table ID
//---------------------------------------------------------------------------------------------------
static VOID ColDizIdtGet(                                   // Return value no
    LPDIZINF,                                               // Dithering information
    DWORD,                                                  // Color number 0:C M:1 2:Y 3:K 4:Mono
    LPDWORD,                                                // (output) Dithering pattern ID
    LPDWORD                                                 // (output) Adjustment value table ID
);

//---------------------------------------------------------------------------------------------------
//      Dithering pattern file data reading
//---------------------------------------------------------------------------------------------------
static DWORD ColDizDatRdd(                                  // Error status
    LPBYTE,                                                 // Dithering file data
    DWORD,                                                  // Dithering pattern ID
    DWORD,                                                  // Adjustment value table ID
    DWORD,                                                  // Threshold(For confirmation)
    LPDWORD,                                                // Dithering pattern size housing address
    LPBYTE,                                                 // Dithering pattern data housing address
    LPBYTE                                                  // Work area
);

//---------------------------------------------------------------------------------------------------
//      Dithering pattern block head searching
//---------------------------------------------------------------------------------------------------
static DWORD ColDizDizSch(                                  // The dithering pattern block head
    LPBYTE,                                                 // Dithering pattern file data
    DWORD                                                   // Dithering pattern ID
);

//---------------------------------------------------------------------------------------------------
//      Adjustment value table block head searching
//---------------------------------------------------------------------------------------------------
static DWORD ColDizAdjSch(                                  // The adjustment value table block head
    LPBYTE,                                                 // Dithering pattern file data
    DWORD                                                   // adjustment value table ID
);

//---------------------------------------------------------------------------------------------------
//      4 byte (DWORD:32 bit) data read
//---------------------------------------------------------------------------------------------------
static DWORD FleRddLng(                                     // Reading data(DWORD)
    LPBYTE,                                                 // Reading file data
    DWORD                                                   // Reading position
);

//---------------------------------------------------------------------------------------------------
//      2 byte (WORD:16 bit) data read
//---------------------------------------------------------------------------------------------------
static WORD FleRddSht(                                      // Reading data(WORD)
    LPBYTE,                                                 // Reading file data
    DWORD                                                   // Reading position
);

//---------------------------------------------------------------------------------------------------
//      4 byte (DWORD:32 bit) data read
//---------------------------------------------------------------------------------------------------
static DWORD FleRddLngLtl(                                  // Reading data(DWORD)
    LPBYTE,                                                 // Reading file data
    DWORD                                                   // Reading position
);

//---------------------------------------------------------------------------------------------------
//      2 byte (WORD:16 bit) data read
//---------------------------------------------------------------------------------------------------
static WORD FleRddShtLtl(                                   // Reading data(WORD)
    LPBYTE,                                                 // Reading file data
    DWORD                                                   // Reading position
);


//***************************************************************************************************
//      Functions
//***************************************************************************************************
//===================================================================================================
//      LUT data read
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColLutDatRdd(                              // LUT pointer
    LPBYTE      lutDat,                                     // LUT file data
    DWORD       lutNum                                      // LUT number
)
{
    DWORD       n, num;
    DWORD       pnt, gldNum, qtyTbl, adrTbl;

    /*======================================================================*/
    /* LUT file format  Header information(128byte)                         */
    /*----------------------------------------------------------------------*/
    /*   0 -   3  LUT file distinction "LUT_"                               */
    /*   4 -  63  Text information (nonused)                                */
    /*  64 -  67  File format version                                       */
    /*  68 - 127  Reservation completion data                               */
    /*======================================================================*/
    /*----- LUT file distinction -------------------------------------------*/
    if ((lutDat[0] != 'L') || (lutDat[1] != 'U') || (lutDat[2] != 'T') || 
        (lutDat[3] != '_')) return 0L;

    /*----- LUT Procedure (each version) -----------------------------------*/
    switch (FleRddLngLtl(lutDat, 64L)) {
      case 101:                         /* Ver1.01                          */
        /*==================================================================*/
        /* Ver1.01                                                          */
        /*------------------------------------------------------------------*/
        /* 128 - 131  Housing LUT number(n)                                 */
        /* 132 - 135  LUT(0) Grid number                                    */
        /* 136 - 139  LUT(0) Data address                                   */
        /*     .                .                                           */
        /*     .                .                                           */
        /* xxx - xxx  LUT(n-1) Grid number                                  */
        /* xxx - xxx  LUT(n-1) Data address                                 */
        /*==================================================================*/
        if (lutNum == (DWORD)0xFFFFFFFF) lutNum = 0L;
                                    /* Custom LUT in the case of, head LUT  */
        if (lutNum >= FleRddLngLtl(lutDat, 128L)) /* Housing LUT number     */
            return 0L;
        pnt = 132L + lutNum * 8;                /* Reading pointer seek     */
        gldNum = FleRddLngLtl(lutDat, pnt);     /* Grid number              */
        return FleRddLngLtl(lutDat, pnt + 4L);  /* Table data address   */

      case 110:                         /* Ver1.10                          */
        /*==================================================================*/
        /* Ver1.10                                                          */
        /*------------------------------------------------------------------*/
        /* 128 - xxx  Mask ROM format ("LT95")                              */
        /*==================================================================*/
        /*----- Custom LUT -------------------------------------------------*/
        if (lutNum == (DWORD)0xFFFFFFFF) {
            adrTbl = FleRddLng(lutDat, 44L + 128L); /* LUT information address  */
            return FleRddLng(lutDat, adrTbl + 16L + 128L) + 128L;
                                        /* LUT pointer                      */
        }
        /*----- Uncustom LUT -----------------------------------------------*/
        switch (lutNum) {
            case LUT_XD: num = 0; break;        /* Brightness               */
            case LUT_YD: num = 1; break;        /* Tincture                 */
//            case LUT_XL: num = 2; break;        /* Brightness(linear)       */
//            case LUT_YL: num = 3; break;        /* Tincture(linear)         */
            default: return 0L;
        }

        qtyTbl = FleRddLng(lutDat, 40L + 128L); /* LUT number               */
        adrTbl = FleRddLng(lutDat, 44L + 128L); /* LUT information address  */
        for (n = 0; n < qtyTbl; n++) {
            if (ColLutIdtTbl[num] == FleRddLng(lutDat, adrTbl + 128L))
                return FleRddLng(lutDat, adrTbl + 16L + 128L) + 128L;
                                        /* LUT pointer                      */
            adrTbl += 20L;
        }
        return 0L;

      default:                          /* Other versions                   */
        return 0L;
    }
}
#endif

//===================================================================================================
//      Global LUT make
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColLutMakGlb(                              // ERRNON    : OK
                                                            // ERRILLPRM : Parameter error
    LPRGB       lutRgb,                                     // Transformation former LUT RGB->RGB
    LPCMYK      lutCmy,                                     // Transformation former LUT RGB->CMYK
    LPRGBINF    rgbInf,                                     // RGB information
    LPCMYKINF   cmyInf,                                     // cmyk information
    LPCMYK      lutGlb,                                     // Global LUT
    LPBYTE      wrk                                         // Work
)
{
    DWORD       n, red, grn, blu, pnt;
    LPRGB       tmpRgb;                                     // RGB->RGB
    COLMCHINF   mchInf;                                     // Color matching information
//  LPRGB       cchRgb;                                     // Color transformation cache table (RGB)
//  LPCMYK      cchCmy;                                     // Color transformation cache table (CMYK)

    tmpRgb = (LPRGB)wrk;                /* RGB temporary buffer     12288B  */

//  cchRgb = (LPRGB)wrk;                /* Cache buffer  RGB          768B  */
//  cchCmy = (LPCMYK)(wrk + (sizeof(RGBS) * CCHTBLSIZ));
//                                      /* Cache buffer CMYK         1024B  */
//  tmpRgb = (LPRGB)(wrk + (sizeof(RGBS) * CCHTBLSIZ + sizeof(CMYK) * CCHTBLSIZ));
//                                      /* RGB temporary buffer     12288B  */

    if ((lutCmy == NULL) || (rgbInf == NULL) || (cmyInf == NULL) || 
        (lutGlb == NULL)) return ERRILLPRM; /* Parameter error              */

    /*----- Transformation former LUT (RGB->RGB) ---------------------------*/
    if (lutRgb != NULL) {               /* RGB->RGB LUT use */
//      for (n = 0; n < (DWORD)LUTSIZ016; n++) tmpRgb[n] = lutRgb[n];
        for (n = 0; n < (DWORD)LUTSIZ016; n++) {
            tmpRgb[n].Red = lutRgb[n].Blu;
            tmpRgb[n].Grn = lutRgb[n].Grn;
            tmpRgb[n].Blu = lutRgb[n].Red;
        }
    } else {                            /* RGB->RGB LUT unused  */
        for (red = 0; red < 16; red++) {
            for (grn = 0; grn < 16; grn++) {
                for (blu = 0; blu < 16; blu++) {
                    pnt = red * 16 * 16 + grn * 16 + blu;
                    tmpRgb[pnt].Red = (BYTE)red * 17;
                    tmpRgb[pnt].Grn = (BYTE)grn * 17;
                    tmpRgb[pnt].Blu = (BYTE)blu * 17;
                }
            }
        }
    }

    /*----- RGB color control ----------------------------------------------*/
    if (    (rgbInf->Lgt) ||            /* Brightness       Except for 0    */
            (rgbInf->Con) ||            /* Contrast         Except for 0    */
            (rgbInf->Crm) ||            /* Chroma           Except for 0    */
            (rgbInf->Gmr != 10) ||      /* Gamma(R)         Except for 1.0  */
            (rgbInf->Gmg != 10) ||      /* Gamma(G)         Except for 1.0  */
            (rgbInf->Gmb != 10) ||      /* Gamma(B)         Except for 1.0  */
            (rgbInf->DnsRgb)        )   /*  RGB density     Except for 0    */
        N501ColCtrRgb((DWORD)LUTSIZ016, tmpRgb, rgbInf);

    /*----- Color matching information set ---------------------------------*/
    mchInf.Mch = MCHNML;                /* LUT: normal                      */
    mchInf.Bla = KCGNON;                /* Black replacement: NO            */
    mchInf.Ucr = UCRNOO;                /* UCR: NO                          */
    mchInf.UcrTbl = NULL;               /* UCR table: NO                    */
    mchInf.LutAdr = lutCmy;             /* LUT address (Transformation former LUT)  */
    mchInf.ColQty = 0;                  /* Color quality: 0                 */
    mchInf.ColAdr = NULL;               /* Color table: NO                  */
    mchInf.CchRgb = NULL;               /* RGB cache table: NO              */
    mchInf.CchCmy = NULL;               /* CMYK cache table: NO             */

    /*----- Color matching (RGB->CMYK) -------------------------------------*/
    N501ColCchIni(&mchInf);             /* Cache table initialize           */
    N501ColMchPrc((DWORD)LUTSIZ016, tmpRgb, lutGlb, &mchInf);

    /*----- CMYK color contorol --------------------------------------------*/
    if (    (cmyInf->Viv) ||            /* Vivid                Except for 0    */
            (cmyInf->DnsCyn) ||         /* Printing density(C)  Except for 0    */
            (cmyInf->DnsMgt) ||         /* Printing density(M)  Except for 0    */
            (cmyInf->DnsYel) ||         /* Printing density(Y)  Except for 0    */
            (cmyInf->DnsBla)        )   /* Printing density(K)  Except for 0    */
        N501ColCtrCmy((DWORD)LUTSIZ016, lutGlb, cmyInf);

    return ERRNON;
}
#endif

//===================================================================================================
//      Global LUT make (monochrome)
//===================================================================================================
DWORD WINAPI N501ColLutMakGlbMon(                           // ERRNON    : OK
                                                            // ERRILLPRM : Parameter error
    LPRGB       lutRgb,                                     // Transformation former LUT RGB->RGB
    LPRGBINF    rgbInf,                                     // RGB information
    LPCMYKINF   cmyInf,                                     // cmyk informatio
    LPCMYK      lutGlb,                                     // Global LUT
    LPBYTE      wrk                                         // Work
)
{
    DWORD       n, red, grn, blu, tmp;
    LPRGB       tmpRgb;                                     // RGB  -> RBG
    LPCMYK      tmpCmy;                                     // CMYK -> CMYK
    LPBYTE      lut;

    tmpRgb = (LPRGB)wrk;                /* RGB temporary buffer        768B */
    tmpCmy = (LPCMYK)(wrk + (DWORD)768);/* CMYK temporary buffer      1024B */

    if ((rgbInf == NULL) || (cmyInf == NULL) || (lutGlb == NULL)) 
        return ERRILLPRM;               /* Parameter error                  */

    /*----- Transformation former LUT (RGB -> RGB) -------------------------*/
    if (lutRgb != NULL) {               /* RGB->RGB LUT use                 */
        for (n = 0; n < (DWORD)256; n++) {
            tmpRgb[n].Red = tmpRgb[n].Grn = tmpRgb[n].Blu = GamTbl[n];
        }
    } else {                            /* RGB->RGB LUT unused              */
        for (n = 0; n < (DWORD)256; n++) {
            tmpRgb[n].Red = tmpRgb[n].Grn = tmpRgb[n].Blu = (BYTE)n;
        }
    }

    /*----- RGB color control ----------------------------------------------*/
    if (    (rgbInf->Lgt) ||            /* Brightness      Except for 0     */
            (rgbInf->Con) ||            /* Contrast        Except for 0     */
            (rgbInf->Crm) ||            /* Chroma          Except for 0     */
            (rgbInf->Gmr != 10) ||      /* Gamma(R)        Except for 1.0   */
            (rgbInf->Gmg != 10) ||      /* Gamma(G)        Except for 1.0   */
            (rgbInf->Gmb != 10) ||      /* Gamma(B)        Except for 1.0   */
            (rgbInf->Dns)           )   /* RGB density     Except for 0     */
        N501ColCtrRgb((DWORD)256, tmpRgb, rgbInf);

    /*----- Color matching (RGB->CMYK) -------------------------------------*/
    for (n = 0; n < (DWORD)256; n++) {
        red = GamTblMon[tmpRgb[n].Red];
        grn = GamTblMon[tmpRgb[n].Grn];
        blu = GamTblMon[tmpRgb[n].Blu];
        tmp = (red * (DWORD)3 + grn * (DWORD)5 + blu * (DWORD)2) / (DWORD)10;
        tmpCmy[n].Cyn = tmpCmy[n].Mgt = tmpCmy[n].Yel = (BYTE)0;
        tmpCmy[n].Bla = (BYTE)255 - GinTblP10[tmp];
    }

    /*----- CMYK color contorol --------------------------------------------*/
    if (    (cmyInf->Viv) ||            /* Vivid                Except for 0    */
            (cmyInf->DnsCyn) ||         /* Printing density(C)  Except for 0    */
            (cmyInf->DnsMgt) ||         /* Printing density(M)  Except for 0    */
            (cmyInf->DnsYel) ||         /* Printing density(Y)  Except for 0    */
            (cmyInf->DnsBla)        )   /* Printing density(K)  Except for 0    */
        N501ColCtrCmy((DWORD)LUTSIZ016, tmpCmy, cmyInf);

    /*----- Global LUT set --------------------------------------------------*/
    lut = (BYTE *)lutGlb;
    for (n = 0; n < (DWORD)256; n++) {
        lut[n] = tmpCmy[n].Bla;
    }

    return ERRNON;
}

//===================================================================================================
//      High speed LUT(32grid) make
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
VOID WINAPI N501ColLutMak032(                               // Return value no
    LPCMYK      lutBse,                                     // Transformation former LUT (16grid)
    LPCMYK      lut032,                                     // High speed LUT(32grid)
    LPBYTE      wrk                                         // Work
)
{
    COLMCHINF   mchInf;                                     // Color matching information
//  LPRGB       cchRgb;                                     // Color transformation cash table (RBG)
//  LPCMYK      cchCmy;                                     // Color transformation cash table (CMYK)
    DWORD       red, grn, blu;
    RGBS        rgb;
    LPRGB       srcRgb;

    srcRgb = (LPRGB)wrk;                /* RGB temporary buffer        96B  */

//  cchRgb = (LPRGB)wrk;                /* Cache buffer RGB           768B  */
//  cchCmy = (LPCMYK)(wrk + (sizeof(RGBS) * CCHTBLSIZ));
//                                      /* Cache buffer CMYK         1024B  */
//  srcRgb = (LPRGB)(wrk + (sizeof(RGBS) * CCHTBLSIZ + sizeof(CMYK) * CCHTBLSIZ));
//                                      /* RGB temporary buffer        96B  */

    /*----- Color matching information set ---------------------------------*/
    mchInf.Mch = MCHNML;                /* LUT: normal                      */
    mchInf.Bla = KCGNON;                /* Black replacement: NO            */
    mchInf.Ucr = UCRNOO;                /* UCR: NO                          */
    mchInf.UcrTbl = NULL;               /* UCR table: NO                    */
    mchInf.LutAdr = lutBse;             /* LUT address (Transformation former LUT)      */
    mchInf.ColQty = 0;                  /* Color quality: 0                 */
    mchInf.ColAdr = NULL;               /* Color table: NO                  */
    mchInf.CchRgb = NULL;               /* RGB cache table: NO              */
    mchInf.CchCmy = NULL;               /* CMYK cache table: NO             */

    /*----- 32grid LUT make ------------------------------------------------*/
    for (red = 0; red < GLDNUM032; red++) {
        rgb.Red = (BYTE)(red * 255 / (GLDNUM032 - 1));
        for (grn = 0; grn < GLDNUM032; grn++) {
            rgb.Grn = (BYTE)(grn * 255 / (GLDNUM032 - 1));
            for (blu = 0; blu < GLDNUM032; blu++) {
                rgb.Blu = (BYTE)(blu * 255 / (GLDNUM032 - 1));
                srcRgb[blu] = rgb;
            }
            N501ColMchPrc((DWORD)GLDNUM032, srcRgb, lut032, &mchInf);
            lut032 += GLDNUM032;
        }
    }
}
#endif

//===================================================================================================
//      Color data read
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColColDatRdd(                              // Color data pointer
    LPBYTE      colDat,                                     // Color data file data
    LPDWORD     colQty                                      // Color data quality
)
{
    /*======================================================================*/
    /* Color data file format    Header information(128byte)                */
    /*----------------------------------------------------------------------*/
    /*   0 -   3  Color data file distinction "CDF_"                        */
    /*   4 -  63  Text information  (nonused)                               */
    /*  64 -  67  File format version                                       */
    /*  68 - 127  Reserved                                          */
    /*======================================================================*/
    /*----- Color data file distinction ------------------------------------*/
    if ((colDat[0] != 'C') || (colDat[1] != 'D') || (colDat[2] != 'F') || 
        (colDat[3] != '_')) return 0L;

    /*----- Color data procedure (each version) ----------------------------*/
    switch (FleRddLngLtl(colDat, 64L)) {
      case 101:                         /* Ver1.01                          */
        /*==================================================================*/
        /* Ver1.01                                                          */
        /*------------------------------------------------------------------*/
        /* 128 - 131  Color data quality (n)                                */
        /* 132 - 138  Color value(RGB-CMYK) #1                              */
        /* 139 - 145  Color value(RGB-CMYK) #2                              */
        /*     .                .                                           */
        /*     .                .                                           */
        /* xxx - xxx  Color value(RGB-CMYK) #n-1                            */
        /* xxx - xxx  Color value(RGB-CMYK) #n                              */
        /*==================================================================*/
        if ((*colQty = (DWORD)FleRddLng(colDat, 128L)) == 0) /* Color data quality  */
            return 0L;                  /* Color data quality: 0            */
        return 132L;                    /* Color data pointer               */

      default:                          /* Other versions                   */
        return 0L;
    }
}
#endif

//===================================================================================================
//      Dithering pattern information set
//===================================================================================================
DWORD WINAPI N501ColDizInfSet(                              // ERRNON    : OK
                                                            // ERRDIZHED : Header error
                                                            // ERRDIZNON : Dithering data no
                                                            // ERRDIZSLS : Threshold error
                                                            // ERRDIZSIZ : X/Y size error
                                                            // ERRDIZADJ : Adjustment value error
    LPBYTE      dizDat,                                     // Dithering file data
    LPDIZINF    dizInf,                                     // Dithering information
    LPBYTE      wrk                                         // Work
)
{
    DWORD       sts, sls;
    DWORD       idtDiz, idtAdj;

    /*======================================================================*/
    /* Dithering file format   Header information(128byte)                  */
    /*----------------------------------------------------------------------*/
    /*   0 -   3  Dithering file distinction "DIZ_"                         */
    /*   4 -  63  Text information (nonused)                                */
    /*  64 -  67  File format version                                       */
    /*  68 - 127  Reserved                                                  */
    /*======================================================================*/
    /*----- Dithering file distinction -------------------------------------*/
    if ((dizDat[0] != 'D') || (dizDat[1] != 'I') || (dizDat[2] != 'Z') || 
        (dizDat[3] != '_')) return ERRDIZHED;

    /*----- Dithering procedure (each version) -----------------------------*/
    switch (FleRddLngLtl(dizDat, 64L)) {
      case 101:                         /* Ver1.01                          */
        /*==================================================================*/
        /* Ver1.01                                                          */
        /*------------------------------------------------------------------*/
        /* 128 - xxx  Mask ROM format ("DP95")                              */
        /*==================================================================*/
        switch (dizInf->PrnMod) {
            case PRM316: case PRM616: sls = 15; break;
            case PRM604:              sls =  3; break;
            default:                  sls =  1; break;
        }
        dizInf->DizSls = sls;

        dizDat += 128L;

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
        if (dizInf->ColMon == CMMCOL) {
            /*===== Color mode =============================================*/
            /*----- Cyn ----------------------------------------------------*/
            ColDizIdtGet(dizInf, 0, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizCyn), dizInf->TblCyn, wrk)) != ERRNON)
                return sts;
            /*----- Mgt ----------------------------------------------------*/
            ColDizIdtGet(dizInf, 1, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizMgt), dizInf->TblMgt, wrk)) != ERRNON)
                return sts;
            /*----- Yel ----------------------------------------------------*/
            ColDizIdtGet(dizInf, 2, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizYel), dizInf->TblYel, wrk)) != ERRNON)
                return sts;
            /*----- Bla ----------------------------------------------------*/
            ColDizIdtGet(dizInf, 3, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizBla), dizInf->TblBla, wrk)) != ERRNON)
                return sts;
        } else {
#endif
            /*===== Monochrome mode, Black =================================*/
            ColDizIdtGet(dizInf, 4, &idtDiz, &idtAdj);
            if ((sts = ColDizDatRdd(dizDat, idtDiz, idtAdj, sls, 
                            &(dizInf->SizBla), dizInf->TblBla, wrk)) != ERRNON)
                return sts;
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
        }
#endif
        return ERRNON;

      default:                          /* Other versions                   */
        return ERRDIZHED;
    }
}


//***************************************************************************************************
//      Static functions
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//      Dithering pattern ID , Get adjustment value table ID
//---------------------------------------------------------------------------------------------------
static VOID ColDizIdtGet(                                   // Return value no
    LPDIZINF    dizInf,                                     // Dithering information
    DWORD       col,                                        // Color number 0:C M:1 2:Y 3:K 4:Mono
    LPDWORD     idtDiz,                                     // (output) Dithering pattern ID
    LPDWORD     idtAdj                                      // (output) Adjustment value table ID
)
{
    DWORD       knd, mod, diz;

    knd = (dizInf->DizKnd == KNDCHR)? 0: 1;

//    switch (dizInf->PrnMod) {
//        case PRM316: mod = 1; break;
//        case PRM602: mod = 2; break;
//        case PRM604: mod = 3; break;
//        case PRM616: mod = 4; break;
//        case PRM122: mod = 2; break;  /* 1200dpi 2value   */
//        default:     mod = 0; break;
//    }

    switch (dizInf->DizPat) {
        case DIZSML: diz = 0; break;
        case DIZRUG: diz = 2; break;
        case DIZSTO: diz = 3; break;
        default:     diz = 1; break;
    }

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
    switch (dizInf->PrnEng) {
        case ENG516:                    /* IX-516 MONO 1200dpi/2value   */
#endif
            switch (dizInf->PrnMod) {
                case PRM602: mod = 1; break;
                case PRM122: mod = 2; break;
                default:     mod = 0; break;
            }
            *idtDiz = ColDizDizIdtTbl516[knd][mod][diz];
            *idtAdj = ColDizAdjIdtTbl516[knd][mod][diz];
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
            break;

        default:                        /* IX-621 COLOR 600dpi/16value  */
            switch (dizInf->PrnMod) {
                case PRM316: mod = 1; break;
                case PRM602: mod = 2; break;
                case PRM604: mod = 3; break;
                case PRM616: mod = 4; break;
                default:     mod = 0; break;
            }
            *idtDiz = ColDizDizIdtTbl621[knd][mod][diz][col];
            *idtAdj = ColDizAdjIdtTbl621[knd][mod][diz][col];
            break;
    }
#endif

//    *idtDiz = ColDizDizIdtTbl[knd][mod][diz][col];
//    *idtAdj = ColDizAdjIdtTbl[knd][mod][diz][col];
}

//---------------------------------------------------------------------------------------------------
//      Dithering pattern file data reading
//---------------------------------------------------------------------------------------------------
static DWORD ColDizDatRdd(                                  // ERRNON    : OK
                                                            // ERRDIZNON : Dithering data no
                                                            // ERRDIZSLS : Threshold error
                                                            // ERRDIZSIZ : X/Y size error
                                                            // ERRDIZADJ : Adjustment value error
    LPBYTE      dizDat,                                     // Dithering file data
    DWORD       idtDiz,                                     // Dithering pattern ID
    DWORD       idtAdj,                                     // Adjustment value table ID
    DWORD       chkSls,                                     // Threshold(For confirmation)
    LPDWORD     siz,                                        // Dithering pattern size housing address
    LPBYTE      tbl,                                        // Dithering pattern data housing address
    LPBYTE      wrk                                         // Work area
)
{
    DWORD       n, dimNum, datSiz, sls, ofsXax, ofsYax, ofsPnt, dst, src;
    BYTE        dat;
    LPBYTE      adjTbl, slsTbl;
    DWORD       idtTbl;
    USHORT      sizXax, sizYax;
    DWORD       pnt;

    adjTbl = wrk;                       /* Adjustment value table buffer    256B    */
    slsTbl = wrk + 256;                 /* Threshold table buffer          3825B    */

    if (tbl != NULL) {
        if (idtAdj != (DWORD)0xFFFFFFFF) {
            if ((pnt = ColDizAdjSch(dizDat, idtAdj)) == 0L)
                                        /* adjustment value table block head        */
                return ERRDIZNON;
            pnt = FleRddLng(dizDat, pnt + 16L);
                                        /* Adjustment value table address           */
            for (n = 0; n < 256; n++) adjTbl[n] = dizDat[pnt + n];
                                        /* Data copy                                */
        } else {
            for (n = 0; n < 256; n++) adjTbl[n] = (BYTE)n;
        }
    }

    /*----- Normal dithering pattern(Unrandom number dithering pattern) ----*/
    if (!(idtDiz & NEWSTO)) {
        if ((pnt = ColDizDizSch(dizDat, idtDiz)) == 0L)
                                        /* Dithering pattern block head     */
            return ERRDIZNON;           /* Dithering data no                */
        switch (FleRddSht(dizDat, pnt + 8L)) {  /* Data attribute           */
            case 0x1000: sls =  1; break;
            case 0x3000: sls =  3; break;
            case 0xF000: sls = 15; break;
            default: return ERRDIZSLS;          /* Threshold error          */
        }
        if (sls != chkSls) return ERRDIZSLS;    /* Threshold error          */
        sizXax = FleRddSht(dizDat, pnt + 12L);  /* X size                   */
        sizYax = FleRddSht(dizDat, pnt + 14L);  /* Y size                   */
        if (sizXax != sizYax) return ERRDIZSIZ; /* X/Y size error           */
        *siz = sizXax;                  /* Dithering pattern size set       */
        if (tbl == NULL) return ERRNON;

        pnt = FleRddLng(dizDat, pnt + 16L);
                                        /* Dithering pattern data address   */
        datSiz = sizXax * sizYax * sls;
        for (n = 0; n < datSiz; n++) tbl[n] = adjTbl[dizDat[pnt + n]];
                                        /* Dithering pattern data set       */
        return ERRNON;
    }

    /*----- Random number dithering pattern (NEW screen) -------------------*/
    dimNum = (DWORD)(idtDiz & ~(DWORD)NEWSTO);
    idtDiz = ColDizIdtTblSto[dimNum].Idt;
    idtTbl = ColDizIdtTblSto[dimNum].IdtTbl;
    sls    = ColDizIdtTblSto[dimNum].Sls;
    ofsXax = ColDizIdtTblSto[dimNum].OfsXax;
    ofsYax = ColDizIdtTblSto[dimNum].OfsYax;

    if (sls != chkSls) return ERRDIZSLS;        /* Threshold error          */

    if (tbl != NULL) {
        /* Many value mask table read                                       */
        datSiz = (DWORD)255 * sls;

        if (idtTbl != (DWORD)0xFFFFFFFF) {
            if ((pnt = ColDizAdjSch(dizDat, idtTbl)) == 0L)
                                        /* The many value mask table block head */
                return ERRDIZNON;       /* Dithering data no                */
            pnt = FleRddLng(dizDat, pnt + 16L);
            for (n = 0; n < datSiz; n++) slsTbl[n] = dizDat[pnt + n];
                                        /* Data copy                        */
        } else {
            for (n = 0; n < datSiz; n++) slsTbl[n] = (BYTE)n;
        }
    }

    if ((pnt = ColDizDizSch(dizDat, idtDiz)) == 0L)
                                        /* The dithering pattern block head */
        return ERRDIZNON;               /* Dithering data no                */
    if (FleRddSht(dizDat, pnt + 8L) != (USHORT)0x1000) { /* Data attribute  */
                                        /* random number DIZ, Basis mask=1(0x1000)  */
        return ERRDIZADJ;               /* Other is error               */
    }
    sizXax = FleRddSht(dizDat, pnt + 12L);      /* X size                   */
    sizYax = FleRddSht(dizDat, pnt + 14L);      /* Y size                   */
    if (sizXax != sizYax) return ERRDIZSIZ;     /* X/Y size orror           */

    *siz = sizXax;                      /* Dithering pattern size set       */
    if (tbl == NULL) return ERRNON;

    pnt = FleRddLng(dizDat, pnt + 16L); /* Dithering pattern data address   */

    datSiz = (DWORD)sizXax * sizYax;
    ofsXax %= sizXax;
    ofsYax %= sizYax;
    ofsPnt = ofsYax * sizXax + ofsXax;

    /* Shift different color and I do the data copy with 2 stages, to express   */
    for (dst = (datSiz - ofsPnt), src = 0; src < ofsPnt; dst++, src++) {
        dat = dizDat[pnt + src];
        for (n = 0; n < sls; n++) {
            tbl[dst * sls + n] = adjTbl[slsTbl[dat * sls + n]];
        }
    }
    for (dst = 0; src < datSiz; dst++, src++) {
        dat = dizDat[pnt + src];
        for (n = 0; n < sls; n++) {
            tbl[dst * sls + n] = adjTbl[slsTbl[dat * sls + n]];
        }
    }
    return ERRNON;
}

//===================================================================================================
//      Dithering pattern block head searching
//===================================================================================================
static DWORD ColDizDizSch(                                  // The dithering pattern block head
    LPBYTE      dizDat,                                     // Dithering pattern file data
    DWORD       idtDiz                                      // Dithering pattern ID
)
{
    DWORD       n;
    DWORD       qtyTbl, adrTbl;

    qtyTbl = FleRddLng(dizDat, 40L);    /* Dithering pattern quality                    */
    adrTbl = FleRddLng(dizDat, 44L);    /* Dithering pattern information bureau address */

    for (n = 0; n < qtyTbl; n++) {
        if (idtDiz == FleRddLng(dizDat, adrTbl)) return adrTbl;
        adrTbl += 20L;
    }
    return 0L;
}

//===================================================================================================
//      Adjustment value table block head searching
static DWORD ColDizAdjSch(                                  // The adjustment value table block head
    LPBYTE      adjDat,                                     // Dithering pattern file data
    DWORD       idtAdj                                      // adjustment value table ID
)
{
    DWORD       n;
    DWORD       qtyTbl, adrTbl;

    qtyTbl = FleRddLng(adjDat, 48L);    /* Adjustment table quality                 */
    adrTbl = FleRddLng(adjDat, 52L);    /* Adjustment table infomatiopn address     */

    for (n = 0; n < qtyTbl; n++) {
        if (idtAdj == FleRddLng(adjDat, adrTbl)) return adrTbl;
        adrTbl += 20L;
    }
    return 0L;
}

//===================================================================================================
//      File data read
//===================================================================================================
//---------------------------------------------------------------------------------------------------
//      4 byte (DWORD:32 bit) data read
//---------------------------------------------------------------------------------------------------
static DWORD FleRddLng(
    LPBYTE      fle,
    DWORD       pnt
)
{
    return (DWORD)fle[pnt + 3] + (DWORD)fle[pnt + 2] * 0x100 + 
                (DWORD)fle[pnt + 1] * 0x10000 + (DWORD)fle[pnt] * 0x1000000;
}

//---------------------------------------------------------------------------------------------------
//      2 byte (WORD:16 bit) data read
//---------------------------------------------------------------------------------------------------
static USHORT FleRddSht(
    LPBYTE      fle,
    DWORD       pnt
)
{
    return (USHORT)fle[pnt + 1] + (USHORT)fle[pnt] * 0x100;
}

//---------------------------------------------------------------------------------------------------
//      4 byte (DWORD:32 bit) data read
//---------------------------------------------------------------------------------------------------
static DWORD FleRddLngLtl(
    LPBYTE      fle,
    DWORD       pnt
)
{
    return (DWORD)fle[pnt] + (DWORD)fle[pnt + 1] * 0x100 + 
                (DWORD)fle[pnt + 2] * 0x10000 + (DWORD)fle[pnt + 3] * 0x1000000;
}

//---------------------------------------------------------------------------------------------------
//      2 byte (WORD:16 bit) data read
//---------------------------------------------------------------------------------------------------
static USHORT FleRddShtLtl(
    LPBYTE      fle,
    DWORD       pnt
)
{
    return (USHORT)fle[pnt] + (USHORT)fle[pnt + 1] * 0x100;
}


// End of N5DIZMK.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5dizmk.h ===
//***************************************************************************************************
//    N5DIZMK.H
//
//    C Header (Functions of dither and color matching (For N5 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//***************************************************************************************************
//    Functions
//***************************************************************************************************
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColLutDatRdd(LPBYTE, DWORD);
DWORD WINAPI N501ColLutMakGlb(LPRGB, LPCMYK, LPRGBINF, LPCMYKINF, LPCMYK, LPBYTE);
#endif

DWORD WINAPI N501ColLutMakGlbMon(LPRGB, LPRGBINF, LPCMYKINF, LPCMYK, LPBYTE);

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
VOID  WINAPI N501ColLutMak032(LPCMYK, LPCMYK, LPBYTE);
DWORD WINAPI N501ColColDatRdd(LPBYTE, LPDWORD);
#endif
DWORD WINAPI N501ColDizInfSet(LPBYTE, LPDIZINF, LPBYTE);

//  End of N5DIZMK.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5dizpc.c ===
//***************************************************************************************************
//    N5DIZPC.C
//
//    Functions of dithering (For N5 printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    <WINDOWS.H>
#include    <WINBASE.H>
#include    "COLDEF.H"
#include    "COMDIZ.H"
#include    "N5DIZPC.H"


//===================================================================================================
//      Structure for dithering information (each color)
//===================================================================================================
typedef struct {
    struct {
        LPBYTE      Cyn;
        LPBYTE      Mgt;
        LPBYTE      Yel;
        LPBYTE      Bla;
    } Cur;
    struct {
        LPBYTE      Cyn;
        LPBYTE      Mgt;
        LPBYTE      Yel;
        LPBYTE      Bla;
    } Xsp;
    struct {
        LPBYTE      Cyn;
        LPBYTE      Mgt;
        LPBYTE      Yel;
        LPBYTE      Bla;
    } Xep;
    struct {
        LPBYTE      Cyn;
        LPBYTE      Mgt;
        LPBYTE      Yel;
        LPBYTE      Bla;
    } Ysp;
    struct {
        LPBYTE      Cyn;
        LPBYTE      Mgt;
        LPBYTE      Yel;
        LPBYTE      Bla;
    } Yep;
    struct {
        DWORD       Cyn;
        DWORD       Mgt;
        DWORD       Yel;
        DWORD       Bla;
    } DYY;
} DIZCOLINF, FAR* LPDIZCOLINF;


//===================================================================================================
//      Static functions
//===================================================================================================
//---------------------------------------------------------------------------------------------------
//      Dithering (color 2value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcC02(                                      // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (color 4value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcC04(                                      // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (color 16value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcC16(                                      // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (mono 2value)
//---------------------------------------------------------------------------------------------------
static VOID DizPrcM02(                                      // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);

//---------------------------------------------------------------------------------------------------
//      Dithering (mono 4value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcM04(                                      // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (mono 16value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcM16(                                      // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering procedure (For DRIVER)
//---------------------------------------------------------------------------------------------------
static VOID ColDizPrcNln(                                   // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Source data line number
);

//---------------------------------------------------------------------------------------------------
//      Dithering information set (color)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizInfSetCol(                                   // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDIZCOLINF,                                            // Dithering information (each color)
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Threshold (per 1pixel)
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering information set (monochrome)
//---------------------------------------------------------------------------------------------------
static VOID DizInfSetMon(                                   // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDIZCOLINF,                                            // Dithering information (each color)
    LPDRWINF,                                               // Drawing information
    DWORD                                                   // Threshold (per 1pixel)
);

//---------------------------------------------------------------------------------------------------
//      Dithering information renewal (color)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizInfChgCol(                                   // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDIZCOLINF                                             // Dithering information (each color)
);
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering information renewal (monochrome)
//---------------------------------------------------------------------------------------------------
static VOID DizInfChgMon(                                   // Return value no
    LPDIZINF,                                               // Fixation dithering information
    LPDIZCOLINF                                             // Dithering information (each color)
);


//***************************************************************************************************
//      Functions
//***************************************************************************************************
//===================================================================================================
//      Drawing information make
//===================================================================================================
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColDrwInfSet(                              // In a bundle development possibility line number
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Dithering information
    DWORD       linBufSiz                                   // Line buffer size (1color)
)
{
    DWORD       lvl;

    /*----- variable power offset calculation ------------------------------*/
    drwInf->XaxOfs = (drwInf->StrXax * drwInf->XaxDnt + drwInf->XaxNrt / 2) / drwInf->XaxNrt;
    drwInf->YaxOfs = (drwInf->StrYax * drwInf->YaxDnt + drwInf->YaxNrt / 2) / drwInf->YaxNrt;
    /*----- One line dot number calculation --------------------------------*/
    drwInf->LinDot = 
        (drwInf->XaxOfs + drwInf->XaxSiz) * drwInf->XaxNrt / drwInf->XaxDnt - 
         drwInf->XaxOfs                   * drwInf->XaxNrt / drwInf->XaxDnt;
    /*----- One line byte calculation --------------------------------------*/
    switch (dizInf->PrnMod) {
        case PRM316: case PRM616: lvl = 4; break;
        case PRM604:              lvl = 2; break;
        default:                  lvl = 1; break;
    }
    drwInf->LinByt = (drwInf->LinDot * lvl + 7) / 8;
    /*----- In a bundle development possibility line number ----------------*/
    return (linBufSiz / drwInf->LinByt) * drwInf->YaxDnt / drwInf->YaxNrt;
}
#endif

//===================================================================================================
//      Dithering procedure (For DRIVER)
//===================================================================================================
VOID WINAPI N501ColDizPrc(                                  // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf                                      // Drawing information
)
{
    ColDizPrcNln(dizInf, drwInf, 1);
    return;
}


//===================================================================================================
//      Static functions
//===================================================================================================
//---------------------------------------------------------------------------------------------------
//      Dithering procedure (For DRIVER)
//---------------------------------------------------------------------------------------------------
static VOID ColDizPrcNln(                                   // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    DWORD       lvl;

    switch (dizInf->PrnMod) {
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
        case PRM316: case PRM616: lvl = 4; break;
        case PRM604:              lvl = 2; break;
#endif
        default:                  lvl = 1; break;
    }

#if !defined(CP80W9X)                                       // CP-E8000 is invalid
    if (dizInf->ColMon == CMMCOL) {
        /*===== Color ======================================================*/
        switch (lvl) {
            case 1: DizPrcC02(dizInf, drwInf, linNum); return;
            case 2: DizPrcC04(dizInf, drwInf, linNum); return;
            case 4: DizPrcC16(dizInf, drwInf, linNum); return;
        }
    }
#endif

    /*===== Monochrome =====================================================*/
    switch (lvl) {
        case 1: DizPrcM02(dizInf, drwInf, linNum); return;
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
        case 2: DizPrcM04(dizInf, drwInf, linNum); return;
        case 4: DizPrcM16(dizInf, drwInf, linNum); return;
#endif
    }
}


//---------------------------------------------------------------------------------------------------
//      Dithering (color 2value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcC02(                                      // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    LPCMYK      src;
    BYTE        wrtPix;
    BYTE        bytCyn, bytMgt, bytYel, bytBla;
    CMYK        cmy;
    LPBYTE      dizCyn, dizMgt, dizYel, dizBla;
    LPBYTE      linC00, linM00, linY00, linK00;
    DWORD       xax, yax;
    LPCMYK      srcPtr;
    LONG        xaxNrt, xaxDnt, yaxNrt, yaxDnt;
    LONG        amrXax, amrYax, amrXax000;
    DWORD       elmSiz, linByt;

    DIZCOLINF   dizColInf;

    elmSiz = 1;

//  DizInfSetCol(dizInf, drwInf, elmSiz);
    DizInfSetCol(dizInf, &dizColInf, drwInf, elmSiz);

    dizCyn = dizInf->TblCyn;
    dizMgt = dizInf->TblMgt;
    dizYel = dizInf->TblYel;
    dizBla = dizInf->TblBla;

    linC00 = drwInf->LinBufCyn + drwInf->LinByt * drwInf->AllLinNum;
    linM00 = drwInf->LinBufMgt + drwInf->LinByt * drwInf->AllLinNum;
    linY00 = drwInf->LinBufYel + drwInf->LinByt * drwInf->AllLinNum;
    linK00 = drwInf->LinBufBla + drwInf->LinByt * drwInf->AllLinNum;

    xaxNrt = drwInf->XaxNrt; xaxDnt = drwInf->XaxDnt;
    yaxNrt = drwInf->YaxNrt; yaxDnt = drwInf->YaxDnt;

    src = drwInf->CmyBuf;

    /****** Dithering main **************************************************/
    if ((xaxNrt == xaxDnt) && (yaxNrt == yaxDnt)) {

        /*===== Same size(Expansion/reduction no) ==========================*/
        for (yax = 0; yax < linNum; yax++) {
            /*..... Vertical axis movement .................................*/
            wrtPix = (BYTE)0x80;
            bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
//          dizCyn = DizCynCur;
//          dizMgt = DizMgtCur;
//          dizYel = DizYelCur;
//          dizBla = DizBlaCur;
            dizCyn = dizColInf.Cur.Cyn;
            dizMgt = dizColInf.Cur.Mgt;
            dizYel = dizColInf.Cur.Yel;
            dizBla = dizColInf.Cur.Bla;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                /****** Dithering *******************************************/
                cmy = *src++;
                if (cmy.Cyn > *dizCyn++) bytCyn |= wrtPix;  // Cyan
                if (cmy.Mgt > *dizMgt++) bytMgt |= wrtPix;  // Magenta
                if (cmy.Yel > *dizYel++) bytYel |= wrtPix;  // Yellow
                if (cmy.Bla > *dizBla++) bytBla |= wrtPix;  // Black

                if (!(wrtPix >>= 1)) {
                    if (linByt) {
                        *linC00++ = bytCyn;
                        *linM00++ = bytMgt;
                        *linY00++ = bytYel;
                        *linK00++ = bytBla;
                        linByt--;
                    }
                    wrtPix = (BYTE)0x80;
                    bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
                }
//              if (dizCyn == DizCynXep) dizCyn = DizCynXsp;
//              if (dizMgt == DizMgtXep) dizMgt = DizMgtXsp;
//              if (dizYel == DizYelXep) dizYel = DizYelXsp;
//              if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                if (dizCyn == dizColInf.Xep.Cyn) dizCyn = dizColInf.Xsp.Cyn;
                if (dizMgt == dizColInf.Xep.Mgt) dizMgt = dizColInf.Xsp.Mgt;
                if (dizYel == dizColInf.Xep.Yel) dizYel = dizColInf.Xsp.Yel;
                if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
            }
            if (wrtPix != 0x80) {
                if (linByt) {
                    *linC00++ = bytCyn;
                    *linM00++ = bytMgt;
                    *linY00++ = bytYel;
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linC00++ = (BYTE)0x00;
                *linM00++ = (BYTE)0x00;
                *linY00++ = (BYTE)0x00;
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgCol(dizInf);                           // Dithering information renewal(Y)
            DizInfChgCol(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->YaxOfs += 1;
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        return;
    }

    /*===== Expansion/reduction ============================================*/
    amrXax000 = amrXax = (LONG)(drwInf->XaxOfs) * xaxNrt % xaxDnt;
                amrYax = (LONG)(drwInf->YaxOfs) * yaxNrt % yaxDnt;

    for (yax = 0; yax < linNum; yax++) {
        /*..... Vertical axis movement .....................................*/
        srcPtr = src;
        for (amrYax += yaxNrt; ((amrYax >= yaxDnt) || (amrYax < 0));
             amrYax -= yaxDnt) {        // Magnification set for vertical

            amrXax = amrXax000;
            wrtPix = (BYTE)0x80;
            bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
//          dizCyn = DizCynCur;
//          dizMgt = DizMgtCur;
//          dizYel = DizYelCur;
//          dizBla = DizBlaCur;
            dizCyn = dizColInf.Cur.Cyn;
            dizMgt = dizColInf.Cur.Mgt;
            dizYel = dizColInf.Cur.Yel;
            dizBla = dizColInf.Cur.Bla;
            src = srcPtr;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                cmy = *src++;
                for (amrXax += xaxNrt; ((amrXax >= xaxDnt) || (amrXax < 0)); 
                     amrXax -= xaxDnt) {                    // Magnification set for Horizontal

                    /****** Dithering ***************************************/
                    if (cmy.Cyn > *dizCyn++) bytCyn |= wrtPix; // Cyan
                    if (cmy.Mgt > *dizMgt++) bytMgt |= wrtPix; // Magenta
                    if (cmy.Yel > *dizYel++) bytYel |= wrtPix; // Yellow
                    if (cmy.Bla > *dizBla++) bytBla |= wrtPix; // Black

                    if (!(wrtPix >>= 1)) {
                        if (linByt) {
                            *linC00++ = bytCyn;
                            *linM00++ = bytMgt;
                            *linY00++ = bytYel;
                            *linK00++ = bytBla;
                            linByt--;
                        }
                        wrtPix = (BYTE)0x80;
                        bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
                    }
//                  if (dizCyn == DizCynXep) dizCyn = DizCynXsp;
//                  if (dizMgt == DizMgtXep) dizMgt = DizMgtXsp;
//                  if (dizYel == DizYelXep) dizYel = DizYelXsp;
//                  if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                    if (dizCyn == dizColInf.Xep.Cyn) dizCyn = dizColInf.Xsp.Cyn;
                    if (dizMgt == dizColInf.Xep.Mgt) dizMgt = dizColInf.Xsp.Mgt;
                    if (dizYel == dizColInf.Xep.Yel) dizYel = dizColInf.Xsp.Yel;
                    if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
                }
            }
            if (wrtPix != 0x80) {
                if (linByt) {
                    *linC00++ = bytCyn;
                    *linM00++ = bytMgt;
                    *linY00++ = bytYel;
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linC00++ = (BYTE)0x00;
                *linM00++ = (BYTE)0x00;
                *linY00++ = (BYTE)0x00;
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgCol(dizInf);                           // Dithering information renewal(Y)
            DizInfChgCol(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        drwInf->YaxOfs += 1;
    }
    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (color 4value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcC04(                                      // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    LPCMYK      src;
    BYTE        wrtPix004, wrtPix008, wrtPix00c;
    BYTE        bytCyn, bytMgt, bytYel, bytBla;
    CMYK        cmy;
    LPBYTE      dizCyn, dizMgt, dizYel, dizBla;
    LPBYTE      linC00, linM00, linY00, linK00;
    DWORD       xax, yax;
    LPCMYK      srcPtr;
    LONG        xaxNrt, xaxDnt, yaxNrt, yaxDnt;
    LONG        amrXax, amrYax, amrXax000;
    DWORD       elmSiz, linByt;

    DIZCOLINF   dizColInf;

    elmSiz = 3;

//  DizInfSetCol(dizInf, drwInf, elmSiz);
    DizInfSetCol(dizInf, &dizColInf, drwInf, elmSiz);

    dizCyn = dizInf->TblCyn;
    dizMgt = dizInf->TblMgt;
    dizYel = dizInf->TblYel;
    dizBla = dizInf->TblBla;

    linC00 = drwInf->LinBufCyn + drwInf->LinByt * drwInf->AllLinNum;
    linM00 = drwInf->LinBufMgt + drwInf->LinByt * drwInf->AllLinNum;
    linY00 = drwInf->LinBufYel + drwInf->LinByt * drwInf->AllLinNum;
    linK00 = drwInf->LinBufBla + drwInf->LinByt * drwInf->AllLinNum;

    xaxNrt = drwInf->XaxNrt; xaxDnt = drwInf->XaxDnt;
    yaxNrt = drwInf->YaxNrt; yaxDnt = drwInf->YaxDnt;

    src = drwInf->CmyBuf;

    /****** Dithering main **************************************************/
    if ((xaxNrt == xaxDnt) && (yaxNrt == yaxDnt)) {

        /*===== Same size(Expansion/reduction no) ==========================*/
        for (yax = 0; yax < linNum; yax++) {
            /*..... Vertical axis movement .................................*/
            wrtPix004 = (BYTE)0x40;
            wrtPix008 = (BYTE)0x80;
            wrtPix00c = (BYTE)0xc0;
            bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
//          dizCyn = DizCynCur;
//          dizMgt = DizMgtCur;
//          dizYel = DizYelCur;
//          dizBla = DizBlaCur;
            dizCyn = dizColInf.Cur.Cyn;
            dizMgt = dizColInf.Cur.Mgt;
            dizYel = dizColInf.Cur.Yel;
            dizBla = dizColInf.Cur.Bla;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                /****** Dithering *******************************************/
                cmy = *src++;
                if (cmy.Cyn > *dizCyn) {                    // Cyan
                    if      (cmy.Cyn > *(dizCyn + 2)) bytCyn |= wrtPix00c;
                    else if (cmy.Cyn > *(dizCyn + 1)) bytCyn |= wrtPix008;
                    else                              bytCyn |= wrtPix004;
                }
                if (cmy.Mgt > *dizMgt) {                    // Magenta
                    if      (cmy.Mgt > *(dizMgt + 2)) bytMgt |= wrtPix00c;
                    else if (cmy.Mgt > *(dizMgt + 1)) bytMgt |= wrtPix008;
                    else                              bytMgt |= wrtPix004;
                }
                if (cmy.Yel > *dizYel) {                    // Yellow
                    if      (cmy.Yel > *(dizYel + 2)) bytYel |= wrtPix00c;
                    else if (cmy.Yel > *(dizYel + 1)) bytYel |= wrtPix008;
                    else                              bytYel |= wrtPix004;
                }
                if (cmy.Bla > *dizBla) {                    // Black
                    if      (cmy.Bla > *(dizBla + 2)) bytBla |= wrtPix00c;
                    else if (cmy.Bla > *(dizBla + 1)) bytBla |= wrtPix008;
                    else                              bytBla |= wrtPix004;
                }

                wrtPix00c >>= 2; wrtPix008 >>= 2; wrtPix004 >>= 2;
                if (!wrtPix004) {
                    if (linByt) {
                        *linC00++ = bytCyn;
                        *linM00++ = bytMgt;
                        *linY00++ = bytYel;
                        *linK00++ = bytBla;
                        linByt--;
                    }
                    wrtPix004 = (BYTE)0x40;
                    wrtPix008 = (BYTE)0x80;
                    wrtPix00c = (BYTE)0xc0;
                    bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
                }
                dizCyn += elmSiz;
                dizMgt += elmSiz;
                dizYel += elmSiz;
                dizBla += elmSiz;
//              if (dizCyn == DizCynXep) dizCyn = DizCynXsp;
//              if (dizMgt == DizMgtXep) dizMgt = DizMgtXsp;
//              if (dizYel == DizYelXep) dizYel = DizYelXsp;
//              if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                if (dizCyn == dizColInf.Xep.Cyn) dizCyn = dizColInf.Xsp.Cyn;
                if (dizMgt == dizColInf.Xep.Mgt) dizMgt = dizColInf.Xsp.Mgt;
                if (dizYel == dizColInf.Xep.Yel) dizYel = dizColInf.Xsp.Yel;
                if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
            }
            if (wrtPix004 != 0x40) {
                if (linByt) {
                    *linC00++ = bytCyn;
                    *linM00++ = bytMgt;
                    *linY00++ = bytYel;
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linC00++ = (BYTE)0x00;
                *linM00++ = (BYTE)0x00;
                *linY00++ = (BYTE)0x00;
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgCol(dizInf);                           // Dithering information renewal(Y)
            DizInfChgCol(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->YaxOfs += 1;
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        return;
    }

    /*===== Expansion/reduction ============================================*/
    amrXax000 = amrXax = (LONG)(drwInf->XaxOfs) * xaxNrt % xaxDnt;
                amrYax = (LONG)(drwInf->YaxOfs) * yaxNrt % yaxDnt;

    for (yax = 0; yax < linNum; yax++) {
        /*..... Vertical axis movement .....................................*/
        srcPtr = src;
        for (amrYax += yaxNrt; ((amrYax >= yaxDnt) || (amrYax < 0));
             amrYax -= yaxDnt) {            /* Magnification set for vertical   */

            amrXax = amrXax000;
            wrtPix004 = (BYTE)0x40;
            wrtPix008 = (BYTE)0x80;
            wrtPix00c = (BYTE)0xc0;
            bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
//          dizCyn = DizCynCur;
//          dizMgt = DizMgtCur;
//          dizYel = DizYelCur;
//          dizBla = DizBlaCur;
            dizCyn = dizColInf.Cur.Cyn;
            dizMgt = dizColInf.Cur.Mgt;
            dizYel = dizColInf.Cur.Yel;
            dizBla = dizColInf.Cur.Bla;
            src = srcPtr;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                cmy = *src++;
                for (amrXax += xaxNrt; ((amrXax >= xaxDnt) || (amrXax < 0)); 
                     amrXax -= xaxDnt) {    // Magnification set for Horizontal

                    /****** Dithering ***************************************/
                    if (cmy.Cyn > *dizCyn) {                // Cyan
                        if      (cmy.Cyn > *(dizCyn + 2)) bytCyn |= wrtPix00c;
                        else if (cmy.Cyn > *(dizCyn + 1)) bytCyn |= wrtPix008;
                        else                              bytCyn |= wrtPix004;
                    }
                    if (cmy.Mgt > *dizMgt) {                // Magenta
                        if      (cmy.Mgt > *(dizMgt + 2)) bytMgt |= wrtPix00c;
                        else if (cmy.Mgt > *(dizMgt + 1)) bytMgt |= wrtPix008;
                        else                              bytMgt |= wrtPix004;
                    }
                    if (cmy.Yel > *dizYel) {                // Yellow
                        if      (cmy.Yel > *(dizYel + 2)) bytYel |= wrtPix00c;
                        else if (cmy.Yel > *(dizYel + 1)) bytYel |= wrtPix008;
                        else                              bytYel |= wrtPix004;
                    }
                    if (cmy.Bla > *dizBla) {                // Black
                        if      (cmy.Bla > *(dizBla + 2)) bytBla |= wrtPix00c;
                        else if (cmy.Bla > *(dizBla + 1)) bytBla |= wrtPix008;
                        else                              bytBla |= wrtPix004;
                    }

                    wrtPix00c >>= 2; wrtPix008 >>= 2; wrtPix004 >>= 2;
                    if (!wrtPix004) {
                        if (linByt) {
                            *linC00++ = bytCyn;
                            *linM00++ = bytMgt;
                            *linY00++ = bytYel;
                            *linK00++ = bytBla;
                            linByt--;
                        }
                        wrtPix004 = (BYTE)0x40;
                        wrtPix008 = (BYTE)0x80;
                        wrtPix00c = (BYTE)0xc0;
                        bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
                    }
                    dizCyn += elmSiz;
                    dizMgt += elmSiz;
                    dizYel += elmSiz;
                    dizBla += elmSiz;
//                  if (dizCyn == DizCynXep) dizCyn = DizCynXsp;
//                  if (dizMgt == DizMgtXep) dizMgt = DizMgtXsp;
//                  if (dizYel == DizYelXep) dizYel = DizYelXsp;
//                  if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                    if (dizCyn == dizColInf.Xep.Cyn) dizCyn = dizColInf.Xsp.Cyn;
                    if (dizMgt == dizColInf.Xep.Mgt) dizMgt = dizColInf.Xsp.Mgt;
                    if (dizYel == dizColInf.Xep.Yel) dizYel = dizColInf.Xsp.Yel;
                    if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
                }
            }
            if (wrtPix004 != 0x40) {
                if (linByt) {
                    *linC00++ = bytCyn;
                    *linM00++ = bytMgt;
                    *linY00++ = bytYel;
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linC00++ = (BYTE)0x00;
                *linM00++ = (BYTE)0x00;
                *linY00++ = (BYTE)0x00;
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgCol(dizInf);                           // Dithering information renewal(Y)
            DizInfChgCol(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        drwInf->YaxOfs += 1;
    }
    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (color 16value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcC16(                                      // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    LPCMYK      src;
    DWORD       sft;
    BYTE        min, max, mid;
    BYTE        bytCyn, bytMgt, bytYel, bytBla;
    CMYK        cmy;
    LPBYTE      dizCyn, dizMgt, dizYel, dizBla;
    LPBYTE      linC00, linM00, linY00, linK00;
    DWORD       xax, yax;
    LPCMYK      srcPtr;
    LONG        xaxNrt, xaxDnt, yaxNrt, yaxDnt;
    LONG        amrXax, amrYax, amrXax000;
    DWORD       elmSiz, linByt;

    DIZCOLINF   dizColInf;

    elmSiz = 15;

//  DizInfSetCol(dizInf, drwInf, elmSiz);
    DizInfSetCol(dizInf, &dizColInf, drwInf, elmSiz);

    dizCyn = dizInf->TblCyn;
    dizMgt = dizInf->TblMgt;
    dizYel = dizInf->TblYel;
    dizBla = dizInf->TblBla;

    linC00 = drwInf->LinBufCyn + drwInf->LinByt * drwInf->AllLinNum;
    linM00 = drwInf->LinBufMgt + drwInf->LinByt * drwInf->AllLinNum;
    linY00 = drwInf->LinBufYel + drwInf->LinByt * drwInf->AllLinNum;
    linK00 = drwInf->LinBufBla + drwInf->LinByt * drwInf->AllLinNum;

    xaxNrt = drwInf->XaxNrt; xaxDnt = drwInf->XaxDnt;
    yaxNrt = drwInf->YaxNrt; yaxDnt = drwInf->YaxDnt;

    src = drwInf->CmyBuf;

    /****** Dithering main **************************************************/
    if ((xaxNrt == xaxDnt) && (yaxNrt == yaxDnt)) {

        /*===== Same size(Expansion/reduction no) ==========================*/
        for (yax = 0; yax < linNum; yax++) {
            /*..... Vertical axis movement .................................*/
            sft = 4;
            bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
//          dizCyn = DizCynCur;
//          dizMgt = DizMgtCur;
//          dizYel = DizYelCur;
//          dizBla = DizBlaCur;
            dizCyn = dizColInf.Cur.Cyn;
            dizMgt = dizColInf.Cur.Mgt;
            dizYel = dizColInf.Cur.Yel;
            dizBla = dizColInf.Cur.Bla;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                /****** Dithering *******************************************/
                cmy = *src++;
                if (cmy.Cyn > *dizCyn) {                    // Cyan
                    if (cmy.Cyn > *(dizCyn + 14)) bytCyn |= 0x0f << sft;
                    else {
                        min = 0; max = 13; mid = 7;
                        while (min < max) {
                            if (cmy.Cyn > *(dizCyn + mid)) min = mid;
                            else                           max = mid - 1;
                            mid = (min + max + 1) / 2;
                        }
                        bytCyn |= (mid + 1) << sft;
                    }
                }
                if (cmy.Mgt > *dizMgt) {                    // Magenta
                    if (cmy.Mgt > *(dizMgt + 14)) bytMgt |= 0x0f << sft;
                    else {
                        min = 0; max = 13; mid = 7;
                        while (min < max) {
                            if (cmy.Mgt > *(dizMgt + mid)) min = mid;
                            else                           max = mid - 1;
                            mid = (min + max + 1) / 2;
                        }
                        bytMgt |= (mid + 1) << sft;
                    }
                }
                if (cmy.Yel > *dizYel) {                    // Yellow
                    if (cmy.Yel > *(dizYel + 14)) bytYel |= 0x0f << sft;
                    else {
                        min = 0; max = 13; mid = 7;
                        while (min < max) {
                            if (cmy.Yel > *(dizYel + mid)) min = mid;
                            else                           max = mid - 1;
                            mid = (min + max + 1) / 2;
                        }
                        bytYel |= (mid + 1) << sft;
                    }
                }
                if (cmy.Bla > *dizBla) {                    // Black
                    if (cmy.Bla > *(dizBla + 14)) bytBla |= 0x0f << sft;
                    else {
                        min = 0; max = 13; mid = 7;
                        while (min < max) {
                            if (cmy.Bla > *(dizBla + mid)) min = mid;
                            else                           max = mid - 1;
                            mid = (min + max + 1) / 2;
                        }
                        bytBla |= (mid + 1) << sft;
                    }
                }

                if (sft == 0) {
                    if (linByt) {
                        *linC00++ = bytCyn;
                        *linM00++ = bytMgt;
                        *linY00++ = bytYel;
                        *linK00++ = bytBla;
                        linByt--;
                    }
                    sft = 8;
                    bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
                }
                sft-=4;
                dizCyn += elmSiz;
                dizMgt += elmSiz;
                dizYel += elmSiz;
                dizBla += elmSiz;
//              if (dizCyn == DizCynXep) dizCyn = DizCynXsp;
//              if (dizMgt == DizMgtXep) dizMgt = DizMgtXsp;
//              if (dizYel == DizYelXep) dizYel = DizYelXsp;
//              if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                if (dizCyn == dizColInf.Xep.Cyn) dizCyn = dizColInf.Xsp.Cyn;
                if (dizMgt == dizColInf.Xep.Mgt) dizMgt = dizColInf.Xsp.Mgt;
                if (dizYel == dizColInf.Xep.Yel) dizYel = dizColInf.Xsp.Yel;
                if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
            }
            if (sft != 4) {
                if (linByt) {
                    *linC00++ = bytCyn;
                    *linM00++ = bytMgt;
                    *linY00++ = bytYel;
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linC00++ = (BYTE)0x00;
                *linM00++ = (BYTE)0x00;
                *linY00++ = (BYTE)0x00;
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgCol(dizInf);                           // Dithering information renewal(Y)
            DizInfChgCol(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->YaxOfs += 1;
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        return;
    }

    /*===== Expansion/reduction ============================================*/
    amrXax000 = amrXax = (LONG)(drwInf->XaxOfs) * xaxNrt % xaxDnt;
                amrYax = (LONG)(drwInf->YaxOfs) * yaxNrt % yaxDnt;

    for (yax = 0; yax < linNum; yax++) {
        /*..... Vertical axis movement .....................................*/
        srcPtr = src;
        for (amrYax += yaxNrt; ((amrYax >= yaxDnt) || (amrYax < 0));
             amrYax -= yaxDnt) {        //Magnification set for vertical

            amrXax = amrXax000;
            sft = 4;
            bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
//          dizCyn = DizCynCur;
//          dizMgt = DizMgtCur;
//          dizYel = DizYelCur;
//          dizBla = DizBlaCur;
            dizCyn = dizColInf.Cur.Cyn;
            dizMgt = dizColInf.Cur.Mgt;
            dizYel = dizColInf.Cur.Yel;
            dizBla = dizColInf.Cur.Bla;
            src = srcPtr;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                cmy = *src++;
                for (amrXax += xaxNrt; ((amrXax >= xaxDnt) || (amrXax < 0)); 
                     amrXax -= xaxDnt) {                    // Magnification set for Horizontal

                    /****** Dithering ***************************************/
                    if (cmy.Cyn > *dizCyn) {                // Cyan
                        if (cmy.Cyn > *(dizCyn + 14)) bytCyn |= 0x0f << sft;
                        else {
                            min = 0; max = 13; mid = 7;
                            while (min < max) {
                                if (cmy.Cyn > *(dizCyn + mid)) min = mid;
                                else                           max = mid - 1;
                                mid = (min + max + 1) / 2;
                            }
                            bytCyn |= (mid + 1) << sft;
                        }
                    }
                    if (cmy.Mgt > *dizMgt) {                // Magenta
                        if (cmy.Mgt > *(dizMgt + 14)) bytMgt |= 0x0f << sft;
                        else {
                            min = 0; max = 13; mid = 7;
                            while (min < max) {
                                if (cmy.Mgt > *(dizMgt + mid)) min = mid;
                                else                           max = mid - 1;
                                mid = (min + max + 1) / 2;
                            }
                            bytMgt |= (mid + 1) << sft;
                        }
                    }
                    if (cmy.Yel > *dizYel) {                // Yellow
                        if (cmy.Yel > *(dizYel + 14)) bytYel |= 0x0f << sft;
                        else {
                            min = 0; max = 13; mid = 7;
                            while (min < max) {
                                if (cmy.Yel > *(dizYel + mid)) min = mid;
                                else                           max = mid - 1;
                                mid = (min + max + 1) / 2;
                            }
                            bytYel |= (mid + 1) << sft;
                        }
                    }
                    if (cmy.Bla > *dizBla) {                // Black
                        if (cmy.Bla > *(dizBla + 14)) bytBla |= 0x0f << sft;
                        else {
                            min = 0; max = 13; mid = 7;
                            while (min < max) {
                                if (cmy.Bla > *(dizBla + mid)) min = mid;
                                else                           max = mid - 1;
                                mid = (min + max + 1) / 2;
                            }
                            bytBla |= (mid + 1) << sft;
                        }
                    }

                    if (sft == 0) {
                        if (linByt) {
                            *linC00++ = bytCyn;
                            *linM00++ = bytMgt;
                            *linY00++ = bytYel;
                            *linK00++ = bytBla;
                            linByt--;
                        }
                        sft = 8;
                        bytCyn = bytMgt = bytYel = bytBla = (BYTE)0x00;
                    }
                    sft-=4;
                    dizCyn += elmSiz;
                    dizMgt += elmSiz;
                    dizYel += elmSiz;
                    dizBla += elmSiz;
//                  if (dizCyn == DizCynXep) dizCyn = DizCynXsp;
//                  if (dizMgt == DizMgtXep) dizMgt = DizMgtXsp;
//                  if (dizYel == DizYelXep) dizYel = DizYelXsp;
//                  if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                    if (dizCyn == dizColInf.Xep.Cyn) dizCyn = dizColInf.Xsp.Cyn;
                    if (dizMgt == dizColInf.Xep.Mgt) dizMgt = dizColInf.Xsp.Mgt;
                    if (dizYel == dizColInf.Xep.Yel) dizYel = dizColInf.Xsp.Yel;
                    if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
                }
            }
            if (sft != 4) {
                if (linByt) {
                    *linC00++ = bytCyn;
                    *linM00++ = bytMgt;
                    *linY00++ = bytYel;
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linC00++ = (BYTE)0x00;
                *linM00++ = (BYTE)0x00;
                *linY00++ = (BYTE)0x00;
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgCol(dizInf);                           // Dithering information renewal(Y)
            DizInfChgCol(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        drwInf->YaxOfs += 1;
    }
    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (mono 2value)
//---------------------------------------------------------------------------------------------------
static VOID DizPrcM02(                                      // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    LPCMYK      src;
    BYTE        wrtPix;
    BYTE        bytBla;
    CMYK        cmy;
    LPBYTE      dizBla;
    LPBYTE      linK00;
    DWORD       xax, yax;
    LPCMYK      srcPtr;
    LONG        xaxNrt, xaxDnt, yaxNrt, yaxDnt;
    LONG        amrXax, amrYax, amrXax000;
    DWORD       elmSiz, linByt;

    DIZCOLINF   dizColInf;

    elmSiz = 1;

//  DizInfSetMon(dizInf, drwInf, elmSiz);
    DizInfSetMon(dizInf, &dizColInf, drwInf, elmSiz);

    dizBla = dizInf->TblBla;

    linK00 = drwInf->LinBufBla + drwInf->LinByt * drwInf->AllLinNum;

    xaxNrt = drwInf->XaxNrt; xaxDnt = drwInf->XaxDnt;
    yaxNrt = drwInf->YaxNrt; yaxDnt = drwInf->YaxDnt;

    src = drwInf->CmyBuf;

    /****** Dithering main **************************************************/
    if ((xaxNrt == xaxDnt) && (yaxNrt == yaxDnt)) {

        /*===== Same size(Expansion/reduction no) ==========================*/
        for (yax = 0; yax < linNum; yax++) {
            /*..... Vertical axis movement .................................*/
            wrtPix = (BYTE)0x80;
            bytBla = (BYTE)0x00;
//          dizBla = DizBlaCur;
            dizBla = dizColInf.Cur.Bla;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                /****** Dithering *******************************************/
                cmy = *src++;
                if (cmy.Bla > *dizBla++) bytBla |= wrtPix;  // Black

                if (!(wrtPix >>= 1)) {
                    if (linByt) {
                        *linK00++ = bytBla;
                        linByt--;
                    }
                    wrtPix = (BYTE)0x80;
                    bytBla = (BYTE)0x00;
                }
//              if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
            }
            if (wrtPix != 0x80) {
                if (linByt) {
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgMon(dizInf);                           // Dithering information renewal(Y)
            DizInfChgMon(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->YaxOfs += 1;
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        return;
    }

    /*===== Expansion/reduction ============================================*/
    amrXax000 = amrXax = (LONG)(drwInf->XaxOfs) * xaxNrt % xaxDnt;
                amrYax = (LONG)(drwInf->YaxOfs) * yaxNrt % yaxDnt;

    for (yax = 0; yax < linNum; yax++) {
        /*..... Vertical axis movement .....................................*/
        srcPtr = src;
        for (amrYax += yaxNrt; ((amrYax >= yaxDnt) || (amrYax < 0));
             amrYax -= yaxDnt) {        // Magnification set for vertical

            amrXax = amrXax000;
            wrtPix = (BYTE)0x80;
            bytBla = (BYTE)0x00;
//          dizBla = DizBlaCur;
            dizBla = dizColInf.Cur.Bla;
            src = srcPtr;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                cmy = *src++;
                for (amrXax += xaxNrt; ((amrXax >= xaxDnt) || (amrXax < 0)); 
                     amrXax -= xaxDnt) {                    // Magnification set for Horizontal

                    /****** Dithering ***************************************/
                    if (cmy.Bla > *dizBla++) bytBla |= wrtPix; // Black

                    if (!(wrtPix >>= 1)) {
                        if (linByt) {
                            *linK00++ = bytBla;
                            linByt--;
                        }
                        wrtPix = (BYTE)0x80;
                        bytBla = (BYTE)0x00;
                    }
//                  if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                    if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
                }
            }
            if (wrtPix != 0x80) {
                if (linByt) {
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgMon(dizInf);                           // Dithering information renewal(Y)
            DizInfChgMon(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        drwInf->YaxOfs += 1;
    }
    return;
}


//---------------------------------------------------------------------------------------------------
//      Dithering (mono 4value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcM04(                                      // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    LPCMYK      src;
    BYTE        wrtPix004, wrtPix008, wrtPix00c;
    BYTE        bytBla;
    CMYK        cmy;
    LPBYTE      dizBla;
    LPBYTE      linK00;
    DWORD       xax, yax;
    LPCMYK      srcPtr;
    LONG        xaxNrt, xaxDnt, yaxNrt, yaxDnt;
    LONG        amrXax, amrYax, amrXax000;
    DWORD       elmSiz, linByt;

    DIZCOLINF   dizColInf;

    elmSiz = 3;

//  DizInfSetMon(dizInf, drwInf, elmSiz);
    DizInfSetMon(dizInf, &dizColInf, drwInf, elmSiz);

    dizBla = dizInf->TblBla;

    linK00 = drwInf->LinBufBla + drwInf->LinByt * drwInf->AllLinNum;

    xaxNrt = drwInf->XaxNrt; xaxDnt = drwInf->XaxDnt;
    yaxNrt = drwInf->YaxNrt; yaxDnt = drwInf->YaxDnt;

    src = drwInf->CmyBuf;

    /****** Dithering main **************************************************/
    if ((xaxNrt == xaxDnt) && (yaxNrt == yaxDnt)) {

        /*===== Same size(Expansion/reduction no) ==========================*/
        for (yax = 0; yax < linNum; yax++) {
            /*..... Vertical axis movement .................................*/
            wrtPix004 = (BYTE)0x40;
            wrtPix008 = (BYTE)0x80;
            wrtPix00c = (BYTE)0xc0;
            bytBla = (BYTE)0x00;
//          dizBla = DizBlaCur;
            dizBla = dizColInf.Cur.Bla;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                /****** Dithering *******************************************/
                cmy = *src++;
                if (cmy.Bla > *dizBla) {                    // Black
                    if      (cmy.Bla > *(dizBla + 2)) bytBla |= wrtPix00c;
                    else if (cmy.Bla > *(dizBla + 1)) bytBla |= wrtPix008;
                    else                              bytBla |= wrtPix004;
                }

                wrtPix00c >>= 2; wrtPix008 >>= 2; wrtPix004 >>= 2;
                if (!wrtPix004) {
                    if (linByt) {
                        *linK00++ = bytBla;
                        linByt--;
                    }
                    wrtPix004 = (BYTE)0x40;
                    wrtPix008 = (BYTE)0x80;
                    wrtPix00c = (BYTE)0xc0;
                    bytBla = (BYTE)0x00;
                }
                dizBla += elmSiz;
//              if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
            }
            if (wrtPix004 != 0x40) {
                if (linByt) {
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgMon(dizInf);                           // Dithering information renewal(Y)
            DizInfChgMon(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->YaxOfs += 1;
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        return;
    }

    /*===== Expansion/reduction ============================================*/
    amrXax000 = amrXax = (LONG)(drwInf->XaxOfs) * xaxNrt % xaxDnt;
                amrYax = (LONG)(drwInf->YaxOfs) * yaxNrt % yaxDnt;

    for (yax = 0; yax < linNum; yax++) {
        /*..... Vertical axis movement .....................................*/
        srcPtr = src;
        for (amrYax += yaxNrt; ((amrYax >= yaxDnt) || (amrYax < 0));
             amrYax -= yaxDnt) {                            // Magnification set for vertical

            amrXax = amrXax000;
            wrtPix004 = (BYTE)0x40;
            wrtPix008 = (BYTE)0x80;
            wrtPix00c = (BYTE)0xc0;
            bytBla = (BYTE)0x00;
//          dizBla = DizBlaCur;
            dizBla = dizColInf.Cur.Bla;
            src = srcPtr;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                cmy = *src++;
                for (amrXax += xaxNrt; ((amrXax >= xaxDnt) || (amrXax < 0)); 
                     amrXax -= xaxDnt) {                    // Magnification set for Horizontal

                    /****** Dithering ***************************************/
                    if (cmy.Bla > *dizBla) { /* Black                       */
                        if      (cmy.Bla > *(dizBla + 2)) bytBla |= wrtPix00c;
                        else if (cmy.Bla > *(dizBla + 1)) bytBla |= wrtPix008;
                        else                              bytBla |= wrtPix004;
                    }

                    wrtPix00c >>= 2; wrtPix008 >>= 2; wrtPix004 >>= 2;
                    if (!wrtPix004) {
                        if (linByt) {
                            *linK00++ = bytBla;
                            linByt--;
                        }
                        wrtPix004 = (BYTE)0x40;
                        wrtPix008 = (BYTE)0x80;
                        wrtPix00c = (BYTE)0xc0;
                        bytBla = (BYTE)0x00;
                    }
                    dizBla += elmSiz;
//                  if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                    if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
                }
            }
            if (wrtPix004 != 0x40) {
                if (linByt) {
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgMon(dizInf);                           // Dithering information renewal(Y)
            DizInfChgMon(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        drwInf->YaxOfs += 1;
    }
    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering (mono 16value)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizPrcM16(                                      // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       linNum                                      // Source data line number
)
{
    LPCMYK      src;
    DWORD       sft;
    BYTE        min, max, mid;
    BYTE        bytBla;
    CMYK        cmy;
    LPBYTE      dizBla;
    LPBYTE      linK00;
    DWORD       xax, yax;
    LPCMYK      srcPtr;
    LONG        xaxNrt, xaxDnt, yaxNrt, yaxDnt;
    LONG        amrXax, amrYax, amrXax000;
    DWORD       elmSiz, linByt;

    DIZCOLINF   dizColInf;

    elmSiz = 15;

//  DizInfSetMon(dizInf, drwInf, elmSiz);
    DizInfSetMon(dizInf, &dizColInf, drwInf, elmSiz);

    dizBla = dizInf->TblBla;

    linK00 = drwInf->LinBufBla + drwInf->LinByt * drwInf->AllLinNum;

    xaxNrt = drwInf->XaxNrt; xaxDnt = drwInf->XaxDnt;
    yaxNrt = drwInf->YaxNrt; yaxDnt = drwInf->YaxDnt;

    src = drwInf->CmyBuf;

    /****** Dithering main **************************************************/
    if ((xaxNrt == xaxDnt) && (yaxNrt == yaxDnt)) {

        /*===== Same size(Expansion/reduction no) ==========================*/
        for (yax = 0; yax < linNum; yax++) {
            /*..... Vertical axis movement .................................*/
            sft = 4;
            bytBla = (BYTE)0x00;
//          dizBla = DizBlaCur;
            dizBla = dizColInf.Cur.Bla;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                /****** Dithering *******************************************/
                cmy = *src++;
                if (cmy.Bla > *dizBla) {                    // Black
                    if (cmy.Bla > *(dizBla + 14)) bytBla |= 0x0f << sft;
                    else {
                        min = 0; max = 13; mid = 7;
                        while (min < max) {
                            if (cmy.Bla > *(dizBla + mid)) min = mid;
                            else                           max = mid - 1;
                            mid = (min + max + 1) / 2;
                        }
                        bytBla |= (mid + 1) << sft;
                    }
                }

                if (sft == 0) {
                    if (linByt) {
                        *linK00++ = bytBla;
                        linByt--;
                    }
                    sft = 8;
                    bytBla = (BYTE)0x00;
                }
                sft-=4;
                dizBla += elmSiz;
//              if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
            }
            if (sft != 4) {
                if (linByt) {
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgMon(dizInf);                           // Dithering information renewal(Y)
            DizInfChgMon(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        return;
    }

    /*===== Expansion/reduction ============================================*/
    amrXax000 = amrXax = (LONG)(drwInf->XaxOfs) * xaxNrt % xaxDnt;
                amrYax = (LONG)(drwInf->YaxOfs) * yaxNrt % yaxDnt;

    for (yax = 0; yax < linNum; yax++) {
        /*..... Vertical axis movement .....................................*/
        srcPtr = src;
        for (amrYax += yaxNrt; ((amrYax >= yaxDnt) || (amrYax < 0));
             amrYax -= yaxDnt) {                            // Magnification set for vertical

            amrXax = amrXax000;
            sft = 4;
            bytBla = (BYTE)0x00;
//          dizBla = DizBlaCur;
            dizBla = dizColInf.Cur.Bla;
            src = srcPtr;
            linByt = drwInf->LinByt;

            for (xax = 0; xax < drwInf->XaxSiz; xax++) {
                /*..... Horizontal axis movement ...........................*/
                cmy = *src++;
                for (amrXax += xaxNrt; ((amrXax >= xaxDnt) || (amrXax < 0)); 
                     amrXax -= xaxDnt) {                    // Magnification set for Horizontal

                    /****** Dithering ***************************************/
                    if (cmy.Bla > *dizBla) {                // Black
                        if (cmy.Bla > *(dizBla + 14)) bytBla |= 0x0f << sft;
                        else {
                            min = 0; max = 13; mid = 7;
                            while (min < max) {
                                if (cmy.Bla > *(dizBla + mid)) min = mid;
                                else                           max = mid - 1;
                                mid = (min + max + 1) / 2;
                            }
                            bytBla |= (mid + 1) << sft;
                        }
                    }

                    if (sft == 0) {
                        if (linByt) {
                            *linK00++ = bytBla;
                            linByt--;
                        }
                        sft = 8;
                        bytBla = (BYTE)0x00;
                    }
                    sft-=4;
                    dizBla += elmSiz;
//                  if (dizBla == DizBlaXep) dizBla = DizBlaXsp;
                    if (dizBla == dizColInf.Xep.Bla) dizBla = dizColInf.Xsp.Bla;
                }
            }
            if (sft != 4) {
                if (linByt) {
                    *linK00++ = bytBla;
                    linByt--;
                }
            }
            while (linByt) {
                *linK00++ = (BYTE)0x00;
                linByt--;
            }
//          DizInfChgMon(dizInf);                           // Dithering information renewal(Y)
            DizInfChgMon(dizInf, &dizColInf);               // Dithering information renewal(Y)
            drwInf->StrYax += 1;
            drwInf->AllLinNum += 1;
        }
        drwInf->YaxOfs += 1;
    }
    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering information set (color)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizInfSetCol(                                   // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDIZCOLINF dizColInf,                                  // Dithering information (each color)
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       elmSiz                                      // Threshold (per 1pixel)
)
{
    DWORD       dizSiz, dzx, dzy;
    LPBYTE      diz;

//  dizSiz = dizInf->SizCyn; DizCynDYY = dizSiz * elmSiz;
    dizSiz = dizInf->SizCyn; dizColInf->DYY.Cyn = dizSiz * elmSiz;
    dzx = ((drwInf->StrXax) % dizSiz) * elmSiz;
//  dzy = ((drwInf->StrYax) % dizSiz) * DizCynDYY;
    dzy = ((drwInf->StrYax) % dizSiz) * dizColInf->DYY.Cyn;
    diz = dizInf->TblCyn;
//  DizCynCur = diz + dzy + dzx;
//  DizCynXsp = diz + dzy; DizCynXep = DizCynXsp + DizCynDYY;
//  DizCynYsp = diz + dzx; DizCynYep = DizCynYsp + dizSiz * DizCynDYY;
    dizColInf->Cur.Cyn = diz + dzy + dzx;
    dizColInf->Xsp.Cyn = diz + dzy; dizColInf->Xep.Cyn = dizColInf->Xsp.Cyn + dizColInf->DYY.Cyn;
    dizColInf->Ysp.Cyn = diz + dzx; dizColInf->Yep.Cyn = dizColInf->Ysp.Cyn + dizSiz * dizColInf->DYY.Cyn;

//  dizSiz = dizInf->SizMgt; DizMgtDYY = dizSiz * elmSiz;
    dizSiz = dizInf->SizMgt; dizColInf->DYY.Mgt = dizSiz * elmSiz;
    dzx = ((drwInf->StrXax) % dizSiz) * elmSiz;
//  dzy = ((drwInf->StrYax) % dizSiz) * DizMgtDYY;
    dzy = ((drwInf->StrYax) % dizSiz) * dizColInf->DYY.Mgt;
    diz = dizInf->TblMgt;
//  DizMgtCur = diz + dzy + dzx;
//  DizMgtXsp = diz + dzy; DizMgtXep = DizMgtXsp + DizMgtDYY;
//  DizMgtYsp = diz + dzx; DizMgtYep = DizMgtYsp + dizSiz * DizMgtDYY;
    dizColInf->Cur.Mgt = diz + dzy + dzx;
    dizColInf->Xsp.Mgt = diz + dzy; dizColInf->Xep.Mgt = dizColInf->Xsp.Mgt + dizColInf->DYY.Mgt;
    dizColInf->Ysp.Mgt = diz + dzx; dizColInf->Yep.Mgt = dizColInf->Ysp.Mgt + dizSiz * dizColInf->DYY.Mgt;

//  dizSiz = dizInf->SizYel; DizYelDYY = dizSiz * elmSiz;
    dizSiz = dizInf->SizYel; dizColInf->DYY.Yel = dizSiz * elmSiz;
    dzx = ((drwInf->StrXax) % dizSiz) * elmSiz;
//  dzy = ((drwInf->StrYax) % dizSiz) * DizYelDYY;
    dzy = ((drwInf->StrYax) % dizSiz) * dizColInf->DYY.Yel;
    diz = dizInf->TblYel;
//  DizYelCur = diz + dzy + dzx;
//  DizYelXsp = diz + dzy; DizYelXep = DizYelXsp + DizYelDYY;
//  DizYelYsp = diz + dzx; DizYelYep = DizYelYsp + dizSiz * DizYelDYY;
    dizColInf->Cur.Yel = diz + dzy + dzx;
    dizColInf->Xsp.Yel = diz + dzy; dizColInf->Xep.Yel = dizColInf->Xsp.Yel + dizColInf->DYY.Yel;
    dizColInf->Ysp.Yel = diz + dzx; dizColInf->Yep.Yel = dizColInf->Ysp.Yel + dizSiz * dizColInf->DYY.Yel;

//  dizSiz = dizInf->SizBla; DizBlaDYY = dizSiz * elmSiz;
    dizSiz = dizInf->SizBla; dizColInf->DYY.Bla = dizSiz * elmSiz;
    dzx = ((drwInf->StrXax) % dizSiz) * elmSiz;
//  dzy = ((drwInf->StrYax) % dizSiz) * DizBlaDYY;
    dzy = ((drwInf->StrYax) % dizSiz) * dizColInf->DYY.Bla;
    diz = dizInf->TblBla;
//  DizBlaCur = diz + dzy + dzx;
//  DizBlaXsp = diz + dzy; DizBlaXep = DizBlaXsp + DizBlaDYY;
//  DizBlaYsp = diz + dzx; DizBlaYep = DizBlaYsp + dizSiz * DizBlaDYY;
    dizColInf->Cur.Bla = diz + dzy + dzx;
    dizColInf->Xsp.Bla = diz + dzy; dizColInf->Xep.Bla = dizColInf->Xsp.Bla + dizColInf->DYY.Bla;
    dizColInf->Ysp.Bla = diz + dzx; dizColInf->Yep.Bla = dizColInf->Ysp.Bla + dizSiz * dizColInf->DYY.Bla;

    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering information set (monochrome)
//---------------------------------------------------------------------------------------------------
static VOID DizInfSetMon(                                   // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDIZCOLINF dizColInf,                                  // Dithering information (each color)
    LPDRWINF    drwInf,                                     // Drawing information
    DWORD       elmSiz                                      // Threshold (per 1pixel)
)
{
    DWORD       dizSiz, dzx, dzy;
    LPBYTE      diz;

//  dizSiz = dizInf->SizBla; DizBlaDYY = dizSiz * elmSiz;
    dizSiz = dizInf->SizBla; dizColInf->DYY.Bla = dizSiz * elmSiz;
    dzx = ((drwInf->StrXax) % dizSiz) * elmSiz;
//  dzy = ((drwInf->StrYax) % dizSiz) * DizBlaDYY;
    dzy = ((drwInf->StrYax) % dizSiz) * dizColInf->DYY.Bla;
    diz = dizInf->TblBla;
//  DizBlaCur = diz + dzy + dzx;
//  DizBlaXsp = diz + dzy; DizBlaXep = DizBlaXsp + DizBlaDYY;
//  DizBlaYsp = diz + dzx; DizBlaYep = DizBlaYsp + dizSiz * DizBlaDYY;
    dizColInf->Cur.Bla = diz + dzy + dzx;
    dizColInf->Xsp.Bla = diz + dzy; dizColInf->Xep.Bla = dizColInf->Xsp.Bla + dizColInf->DYY.Bla;
    dizColInf->Ysp.Bla = diz + dzx; dizColInf->Yep.Bla = dizColInf->Ysp.Bla + dizSiz * dizColInf->DYY.Bla;

    return;
}


//---------------------------------------------------------------------------------------------------
//      Dithering information renewal (color)
//---------------------------------------------------------------------------------------------------
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
static VOID DizInfChgCol(                                   // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDIZCOLINF dizColInf                                   // Dithering information (each color)
)
{
//  DizCynCur += DizCynDYY; DizCynXsp += DizCynDYY; DizCynXep += DizCynDYY;
    dizColInf->Cur.Cyn += dizColInf->DYY.Cyn;
    dizColInf->Xsp.Cyn += dizColInf->DYY.Cyn;
    dizColInf->Xep.Cyn += dizColInf->DYY.Cyn;
//  DizMgtCur += DizMgtDYY; DizMgtXsp += DizMgtDYY; DizMgtXep += DizMgtDYY;
    dizColInf->Cur.Mgt += dizColInf->DYY.Mgt;
    dizColInf->Xsp.Mgt += dizColInf->DYY.Mgt;
    dizColInf->Xep.Mgt += dizColInf->DYY.Mgt;
//  DizYelCur += DizYelDYY; DizYelXsp += DizYelDYY; DizYelXep += DizYelDYY;
    dizColInf->Cur.Yel += dizColInf->DYY.Yel;
    dizColInf->Xsp.Yel += dizColInf->DYY.Yel;
    dizColInf->Xep.Yel += dizColInf->DYY.Yel;
//  DizBlaCur += DizBlaDYY; DizBlaXsp += DizBlaDYY; DizBlaXep += DizBlaDYY;
    dizColInf->Cur.Bla += dizColInf->DYY.Bla;
    dizColInf->Xsp.Bla += dizColInf->DYY.Bla;
    dizColInf->Xep.Bla += dizColInf->DYY.Bla;

//  if (DizCynCur == DizCynYep) {
//      DizCynXsp = dizInf->TblCyn;
//      DizCynXep = DizCynXsp + DizCynDYY;
//      DizCynCur = DizCynYsp;
//  }
    if (dizColInf->Cur.Cyn == dizColInf->Yep.Cyn) {
        dizColInf->Xsp.Cyn = dizInf->TblCyn;
        dizColInf->Xep.Cyn = dizColInf->Xsp.Cyn + dizColInf->DYY.Cyn;
        dizColInf->Cur.Cyn = dizColInf->Ysp.Cyn;
    }
//  if (DizMgtCur == DizMgtYep) {
//      DizMgtXsp = dizInf->TblMgt;
//      DizMgtXep = DizMgtXsp + DizMgtDYY;
//      DizMgtCur = DizMgtYsp;
//  }
    if (dizColInf->Cur.Mgt == dizColInf->Yep.Mgt) {
        dizColInf->Xsp.Mgt = dizInf->TblMgt;
        dizColInf->Xep.Mgt = dizColInf->Xsp.Mgt + dizColInf->DYY.Mgt;
        dizColInf->Cur.Mgt = dizColInf->Ysp.Mgt;
    }
//  if (DizYelCur == DizYelYep) {
//      DizYelXsp = dizInf->TblYel;
//      DizYelXep = DizYelXsp + DizYelDYY;
//      DizYelCur = DizYelYsp;
//  }
    if (dizColInf->Cur.Yel == dizColInf->Yep.Yel) {
        dizColInf->Xsp.Yel = dizInf->TblYel;
        dizColInf->Xep.Yel = dizColInf->Xsp.Yel + dizColInf->DYY.Yel;
        dizColInf->Cur.Yel = dizColInf->Ysp.Yel;
    }
//  if (DizBlaCur == DizBlaYep) {
//      DizBlaXsp = dizInf->TblBla;
//      DizBlaXep = DizBlaXsp + DizBlaDYY;
//      DizBlaCur = DizBlaYsp;
//  }
    if (dizColInf->Cur.Bla == dizColInf->Yep.Bla) {
        dizColInf->Xsp.Bla = dizInf->TblBla;
        dizColInf->Xep.Bla = dizColInf->Xsp.Bla + dizColInf->DYY.Bla;
        dizColInf->Cur.Bla = dizColInf->Ysp.Bla;
    }

    return;
}
#endif

//---------------------------------------------------------------------------------------------------
//      Dithering information renewal (monochrome)
//---------------------------------------------------------------------------------------------------
static VOID DizInfChgMon(                                   // Return value no
    LPDIZINF    dizInf,                                     // Fixation dithering information
    LPDIZCOLINF dizColInf                                   // Dithering information (each color)
)
{
//  DizBlaCur += DizBlaDYY; DizBlaXsp += DizBlaDYY; DizBlaXep += DizBlaDYY;
    dizColInf->Cur.Bla += dizColInf->DYY.Bla;
    dizColInf->Xsp.Bla += dizColInf->DYY.Bla;
    dizColInf->Xep.Bla += dizColInf->DYY.Bla;

//  if (DizBlaCur == DizBlaYep) {
//      DizBlaXsp = dizInf->TblBla;
//      DizBlaXep = DizBlaXsp + DizBlaDYY;
//      DizBlaCur = DizBlaYsp;
//  }
    if (dizColInf->Cur.Bla == dizColInf->Yep.Bla) {
        dizColInf->Xsp.Bla = dizInf->TblBla;
        dizColInf->Xep.Bla = dizColInf->Xsp.Bla + dizColInf->DYY.Bla;
        dizColInf->Cur.Bla = dizColInf->Ysp.Bla;
    }

    return;
}


// End of N5DIZPC.C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\n5dizpc.h ===
//***************************************************************************************************
//    N5DIZPC.H
//
//    C Header (Functions of dither and color matching (For N5 printer))
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
//***************************************************************************************************
//    Functions
//***************************************************************************************************
#if !defined(CP80W9X)                                       // CP-E8000 is invalid
DWORD WINAPI N501ColDrwInfSet(LPDIZINF, LPDRWINF, DWORD);
#endif
VOID  WINAPI N501ColDizPrc(LPDIZINF, LPDRWINF);

//  End of N5DIZPC.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>

#include <prcomoem.h>
#include "COLMATCH.H"
#include "DEBUG2.H"

//
// For debugging.
//

#ifndef DEBUG2_FILE
//#define MY_VERBOSE(x) DBGPRINT(DBG_WARNING, x)
#define MY_VERBOSE VERBOSE
//#define DL_VERBOSE MY_VERBOSE
#define DL_VERBOSE VERBOSE
//#define SC_VERBOSE MY_VERBOSE
#define SC_VERBOSE VERBOSE
//#define CM_VERBOSE MY_VERBOSE
#define CM_VERBOSE VERBOSE

#else   // DEBUG2_FILE
#define DUMP_VERBOSE(p1,p2) DbgFDump(p1,p2);
#define SB_VERBOSE(no, msg) { DbgFPrint msg; }
#define MY_VERBOSE(msg) SB_VERBOSE(1, msg)
#define DL_VERBOSE(msg) SB_VERBOSE(1, msg)
#define SC_VERBOSE(msg) SB_VERBOSE(1, msg)
#define CM_VERBOSE(msg) SB_VERBOSE(1, msg)
#endif  // DEBUG2_FILE

//
// Misc definitions follows.
//

#define DOWNLOADFONT 1
//#define DOWNLOADFONT 0

#define DRVGETDRIVERSETTING(p, t, o, s, n, r) \
    ((p)->pDrvProcs->DrvGetDriverSetting(p, t, o, s, n, r))

#define DRVGETGPDDATA(p, t, i, b, s, n) \
  ((p)->pDrvProcs->DrvGetGPDData(p, t, i, b, s, n))

#define MINIPDEV_DATA(p) ((p)->pdevOEM)

#define MASTER_UNIT 1200

#define DEFAULT_PALETTE_INDEX   0

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " s

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////
//VOID DbgPrint(IN LPCTSTR pstrFormat,  ...);

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CSN4'      // EPSON ESC/Page printers
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

typedef struct {
    DWORD    fGeneral;
    int    iEscapement;
    short    sHeightDiv;
    short    iDevCharOffset;
    BYTE    iPaperSource;
    BYTE    iDuplex;
    BYTE    iTonerSave;
    BYTE    iOrientation;
    BYTE    iResolution; 
    BYTE    iColor;
    BYTE    iSmoothing;
    BYTE    iJamRecovery;
    BYTE    iMediaType;
    BYTE    iOutBin;             //+N5
    BYTE    iIcmMode;            //+N5
    BYTE    iUnitFactor;         // factor of master unit
    BYTE    iDithering;
    BYTE    iColorMatching;
    BYTE    iBitFont;
    BYTE    iCmyBlack;
    BYTE    iTone;
    BYTE    iPaperSize;
    BYTE    iCompress;
    WORD    Printer;
    DEVCOL  Col;
    WORD    wRectWidth, wRectHeight;

#define UNKNOWN_DLFONT_ID (~0)

    DWORD dwDLFontID;         // device's current font ID
    DWORD dwDLSelectFontID;   // "SelectFont" font ID 
    DWORD dwDLSetFontID;      // "SetFont" font ID
    WORD wCharCode;


#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    DWORD dwSelectedColor;     // Latest selected color descirbe as COLOR_SELECT_xxx
    BYTE iColorMayChange;    // 1 means called block data callback that may change color
    /* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

} MYPDEV, *PMYPDEV;

// Flags for fGeneral
#define FG_DBCS        0x00000001
#define FG_VERT        0x00000002
#define FG_PROP        0x00000004
#define FG_DOUBLE      0x00000008
#define FG_NULL_PEN    0x00000010
#define FG_BOLD        0x00000020
#define FG_ITALIC      0x00000040

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif    // _PDEV_H


// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
    "DrvGetGPDData",
    "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
    "ImageProcessing",
    "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};


// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\casio\$(ALT_PROJECT)
SRCDIR=..
N5SRCDIR=..\..\casn5res

TARGETNAME=csn5res
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),csn5res
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\csn5res.rc \
    $(SRCDIR)\csn5res.c \
    $(SRCDIR)\prnctl.c \
    $(SRCDIR)\common.c \
    $(SRCDIR)\colmatch.c \
    $(SRCDIR)\N5colmh.c \
    $(SRCDIR)\N5colsb.c \
    $(SRCDIR)\N5dizmk.c \
    $(SRCDIR)\N5dizpc.c \
    $(SRCDIR)\debug2.c

MISCFILES=\
    $(SRCDIR)\csn5res.ini \
    $(SRCDIR)\lut\cpn5nml.diz \
    $(SRCDIR)\lut\cpn5rgb.lt3 \
    $(SRCDIR)\lut\cpn5rn10.icm \
    $(GPDDIR)\csn5j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\prnctl.c ===
//***************************************************************************************************
//    PRNCTL.C
//
//    Functions of controlling printer
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************
#include    "PDEV.H"
#include    <stdio.h>
#include    "PRNCTL.H"

#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

//***************************************************************************************************
//    Data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Type of pressing raster image
//---------------------------------------------------------------------------------------------------
#define   RASTER_COMP     0                         // Press
#define   RASTER_NONCOMP  1                         // Not press
#define   RASTER_EMPTY    2                         // Empty

//---------------------------------------------------------------------------------------------------
//    Buffer for setting command
//---------------------------------------------------------------------------------------------------
static BYTE        CmdBuf[1 * 1024];                // 1KB

//---------------------------------------------------------------------------------------------------
//    Structure for setting command
//---------------------------------------------------------------------------------------------------
typedef const struct {
    WORD        Size;                               // Command size
    LPBYTE      Cmd;                                // Command buffer
} CMDDEF, FAR *LPCMDDEF;

//===================================================================================================
//    Command define
//===================================================================================================
//---------------------------------------------------------------------------------------------------
//    Change mode
//---------------------------------------------------------------------------------------------------
static CMDDEF ModOrgIn =    { 4, "\x1b""z""\xd0\x01"};      // ESC/Page -> original
static CMDDEF ModOrgOut =   { 4, "\x1b""z""\x00\x01"};      // original -> ESC/Page
//---------------------------------------------------------------------------------------------------
//    Setting overwrite
//---------------------------------------------------------------------------------------------------
static CMDDEF CfgWrtMod =    { 6, "\x1d""%uowE"};           // Setting overwrite
//---------------------------------------------------------------------------------------------------
//    Setting spool positon
//---------------------------------------------------------------------------------------------------
static CMDDEF PosAbsHrz =    { 4, "\x1d""%dX"};             // Horizontal
static CMDDEF PosAbsVtc =    { 4, "\x1d""%dY"};             // Vertical
//---------------------------------------------------------------------------------------------------
//    Spool bitmap data
//---------------------------------------------------------------------------------------------------
static CMDDEF ImgDrw =       {16, "\x1d""%u;%u;%u;%dbi{I"}; // Spool bit image
static CMDDEF ImgRasStr =    {15, "\x1d""%u;%u;%u;%dbrI"};  // Start spool raster image
static CMDDEF ImgRasEnd =    { 4, "\x1d""erI"};             // End spool raster image
static CMDDEF ImgRasDrw =    { 6, "\x1d""%ur{I"};           // Spool raster image
static CMDDEF ImgRasNon =    { 6, "\x1d""%uu{I"};           // Spool raster image(Not press)
static CMDDEF ImgRasEpy =    { 5, "\x1d""%ueI"};            // Spool empty raster image
//---------------------------------------------------------------------------------------------------
//    CASIO original
//---------------------------------------------------------------------------------------------------
static CMDDEF OrgColCmy =    {15, "Cc,%u,%u,%u,%u*"};       // CMYK
static CMDDEF OrgDrwPln =    {15, "Da,%u,%u,%u,%u*"};       // Setting plane
static CMDDEF OrgImgCmy =    {26, "Cj%w,%u,%u,%u,%l,%l,%u,%u*"};   // CMYK bitimage

static BYTE OVERWRITE[] = 
    "\x1D" "1owE"                      //MOV1
    "\x1D" "0tsE";

//***************************************************************************************************
//    Prototype declaration
//***************************************************************************************************
static WORD        PlaneCmdStore(PDEVOBJ, LPBYTE, WORD);
static void        BitImgImgCmd(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, LPBYTE);
static BOOL        RasterImgCmd(PDEVOBJ, WORD, WORD, WORD, WORD, WORD, WORD, WORD, LPBYTE, LPBYTE);
static WORD        RasterSize(WORD, WORD, WORD, WORD, LPBYTE);
static WORD        RasterComp(LPBYTE, WORD, LPBYTE, LPBYTE, LPWORD);
static void        CMYKImgCmd(PDEVOBJ, WORD, LONG, LONG, WORD, WORD, WORD, WORD, WORD, DWORD, DWORD, LPBYTE, LPBYTE, LONG, LONG);
static WORD        CmdCopy(LPBYTE, LPCMDDEF);
static WORD        CmdStore(LPBYTE, LPCMDDEF, LPINT);
static WORD        INTtoASC(LPBYTE, int);
static WORD        USINTtoASC(LPBYTE, WORD);
static WORD        LONGtoASC(LPBYTE, LONG);
static WORD        USLONGtoASC(LPBYTE, DWORD);

//***************************************************************************************************
//    Functions
//***************************************************************************************************
//===================================================================================================
//    Spool bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmap(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    LPDRWBMP       lpBmp                                    // Pointer to DRWBMP structure
)
{
    WORD           siz,size;
    WORD           comp;
    WORD           width;                                   // dot
    WORD           height;                                  // dot
    WORD           widthByte;                               // byte
    LPBYTE         lpTmpBuf;
    LPBYTE         lpSchBit;
    LPBYTE         lpBit;                                   // Pointer to Bitmap data
    POINT          drwPos;
    WORD           higSiz;                                  // dot
    WORD           higCnt;
    WORD           strHigCnt;
    WORD           widLCnt;                                 // Width from the left edge
    WORD           widRCnt;                                 // Width from the right edge
    WORD           invLft;                                  // Invalid size from the left edge
    WORD           invRgt;                                  // Invalid size from the right edge
    WORD           img1st;                                  // Spool first image data?
    int            pam[4];
    int            palm[1];

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    lpTmpBuf = NULL;
    width = lpBmp->Width;
    height = lpBmp->Height;
    widthByte = lpBmp->WidthByte;
    comp = No;

    MY_VERBOSE((" PB "));

    img1st = Yes;
    lpSchBit = lpBmp->lpBit;
    for (higCnt = 0; higCnt < height; higCnt++) {
        higSiz = 0;
        invLft = 0;
        invRgt = 0;
        for (; higCnt < height; higCnt++) {               // 1 Spool bitmap data
                                                          // Search NULL data from the left edge
            for (widLCnt = 0; widLCnt < widthByte; widLCnt++) {
                if (lpSchBit[widLCnt] != 0x00) {
                    if (higSiz == 0) {                    // first line?
                        strHigCnt = higCnt;
                        invLft = widLCnt;                 // Invalid size from the left edge
                    } else {
                        if (invLft > widLCnt) {
                            invLft = widLCnt;             // Renew invalid size from the left edge
                        }
                    }
                                                          // Search NULL data from the right edge
                    for (widRCnt = 0; widRCnt < widthByte; widRCnt++) {
                        if (lpSchBit[widthByte - widRCnt - 1] != 0x00) {
                            if (higSiz == 0) {            // first line?
                                invRgt = widRCnt;         // Invalid size from the right edge
                            } else {
                                if (invRgt > widRCnt) {
                                    invRgt = widRCnt;     // Renew invalid size from the right edge
                                }
                            }
                            break;
                        }
                    }
                    higSiz++;                             // Renew height size
                    break;
                }
            }
            lpSchBit += widthByte;                        // Next line bitmap data
            if (widLCnt == widthByte && higSiz != 0) {    // 1line all NULL data & There were data except NULL data in previous line
                break;                                    // Go to spool bitmap data
            }
        }
        if (higSiz != 0) {                                // There are data for spool?
            if (img1st == Yes) {                          // Spool for the first time
                                                          // Compress?
                if (pOEM->iCompress != XX_COMPRESS_OFF) {
                    if ((lpTmpBuf = MemAllocZ(widthByte * height)) != NULL) {
                        comp = Yes;
                    }
                }
                // Original mode in
                siz = CmdCopy(CmdBuf, &ModOrgIn);
                // Color?
                if (pOEM->iColor == XX_COLOR_SINGLE 
                || pOEM->iColor == XX_COLOR_MANY
                || pOEM->iColor == XX_COLOR_MANY2) {
                    pam[0] = lpBmp->Color.Cyn;
                    pam[1] = lpBmp->Color.Mgt;
                    pam[2] = lpBmp->Color.Yel;
                    pam[3] = lpBmp->Color.Bla;
                    siz += CmdStore(CmdBuf + siz, &OrgColCmy, pam);

                    siz += PlaneCmdStore(pdevobj, CmdBuf + siz, lpBmp->Plane);
                }
                // Original mode out
                siz += CmdCopy(CmdBuf + siz, &ModOrgOut);
                if (siz != 0) {                         // There are data for spool?
                    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
                }
                img1st = No;                            // Not first time
            }

            drwPos.x = lpBmp->DrawPos.x + invLft * 8;   // x coordinates
            drwPos.y = lpBmp->DrawPos.y + strHigCnt;    // y coordinates
            palm[0] = drwPos.x;
            siz = CmdStore(CmdBuf, &PosAbsHrz, palm);
            palm[0] = drwPos.y;
            siz += CmdStore(CmdBuf + siz, &PosAbsVtc, palm);
            if (siz != 0) {                             // There are data for spool?
                WRITESPOOLBUF(pdevobj, CmdBuf, siz);
            }

            lpBit = lpBmp->lpBit + widthByte * strHigCnt;
            if (comp == Yes) {                          // Compress?

                if (RasterImgCmd(pdevobj, pOEM->iCompress, width, higSiz,
                                 widthByte, 0, invLft, invRgt, lpBit, lpTmpBuf) == No) {
                    comp = No;                          // But compress rate is poor, no compress
                }
            }
            if (comp == No) {                           // Not compress

                BitImgImgCmd(pdevobj, width, higSiz, widthByte, 0, invLft, invRgt, lpBit);
            }
        }
    }
    if (lpTmpBuf) {
        MemFree(lpTmpBuf);
    }
    return;
}


//===================================================================================================
//    Spool CMYK bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmapCMYK(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    LPDRWBMPCMYK   lpBmp                                    // Pointer to DRWBMPCMYK structure
)
{
    WORD           siz;
    WORD           comp;
    WORD           width;                                   // dot
    WORD           height;                                  // dot
    WORD           widthByte;
    LPBYTE         lpSchBit;                                // Pointer to bitmap data
    LPBYTE         lpBit;                                   // Pointer to bitmap data
    LONG           xPos;
    LONG           yPos;
    WORD           posClpLft;                               // Clipping dot size
    DWORD          posAdj;                                  // 1/7200inch
    WORD           higSiz;                                  // dot
    WORD           higCnt;
    WORD           strHigCnt;
    WORD           widLCnt;
    WORD           widRCnt;
    WORD           invLft;                                  // Invalid size from the left edge
    WORD           invRgt;                                  // Invalid size from the right edge
    DWORD          invLftBit;                               // Invalid bit size from the left edge
    DWORD          invRgtBit;                               // Invalid bit size from the right edge
    WORD           rgtBit;                                  // Valid bit size from the right edge
    WORD           img1st;                                  // Spool for the first time
    DWORD          dstSiz;
    LPBYTE         lpDst;
    LPBYTE         lpTmp;
    int            pam[1];
    WORD           img1st_2;                                // Spool for the first time

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    MY_VERBOSE((" CM \n"));


    lpTmp = NULL;
    posAdj = 7200 / pOEM->Col.wReso;                        // 1/7200inch
    width = lpBmp->Width;
    height = lpBmp->Height;
    widthByte = lpBmp->WidthByte;
    comp = No;
    if (pOEM->iCompress != XX_COMPRESS_OFF) {
        if ((lpTmp = MemAllocZ(widthByte * height)) != NULL) {
            comp = Yes;
        }
    }
    img1st = Yes;
    img1st_2 = Yes;
    lpSchBit = lpBmp->lpBit;

    for (higCnt = 0; higCnt < height; higCnt++) {
        higSiz = 0;
        invLft = 0;
        invRgt = 0;
        for (; higCnt < height; higCnt++) {                // 1 Spool bitmap data
                                                           // Search NULL data from the left edge
            for (widLCnt = 0; widLCnt < widthByte; widLCnt++) {

                if (lpSchBit[widLCnt] != 0x00) {
                    if (higSiz == 0) {
                        strHigCnt = higCnt;                // first line
                        invLft = widLCnt;                  // Invalid size from the left edge
                    } else {
                        if (invLft > widLCnt) {
                            invLft = widLCnt;              // Renew invalid size from the left edge
                        }
                    }
                                                           // Search NULL data from the right edge
                    for (widRCnt = 0; widRCnt < widthByte; widRCnt++) {
                        if (lpSchBit[widthByte - widRCnt - 1] != 0x00) {
                            if (higSiz == 0) {             // first line
                                invRgt = widRCnt;          // Invalid size from the right edge
                            } else {
                                if (invRgt > widRCnt) {
                                    invRgt = widRCnt;      // Renew size from the right edge
                                }
                            }
                            break;
                        }
                    }
                    higSiz++;                              // Renew height size
                    break;
                }
            }
            lpSchBit += widthByte;                         // Next line bitmap data
            if (widLCnt == widthByte && higSiz != 0) {     // 1line all NULL data & There were data except NULL data in previous line
                break;                                     // goto spool
            }
        }
        if (higSiz != 0) {                                 // There are data for spool
            if (img1st_2 == Yes) {
                WRITESPOOLBUF(pdevobj, OVERWRITE, BYTE_LENGTH(OVERWRITE));
                img1st_2 = No;
            }
            // When Colormode is XX_COLOR_MANY or XX_COLOR_MANY2 ,not compress
            if (comp == Yes) {
                if (pOEM->iColor == XX_COLOR_MANY || pOEM->iColor == XX_COLOR_MANY2) {
                    comp = No;
                }
            }
            if (comp == No && img1st == Yes) {
                // Original mode in
                siz = CmdCopy(CmdBuf, &ModOrgIn);
                                                            // Plane
                siz += PlaneCmdStore(pdevobj, CmdBuf + siz, lpBmp->Plane);
                if (siz != 0) {                             // There are data for spool
                    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
                }
                img1st = No;                                // not first
            }

            invLftBit = (DWORD)invLft * 8;
            if (invRgt != 0) {

                if ((rgtBit = (WORD)((DWORD)width * lpBmp->DataBit % 8)) == 0) {
                    rgtBit = 8;
                }
                if (rgtBit == 8) {
                    invRgtBit = (DWORD)invRgt * 8;
                } else {
                    invRgtBit = ((DWORD)invRgt - 1) * 8 + rgtBit;
                }
            } else {
                invRgtBit = 0;
            }
            posClpLft = (WORD)(invLftBit / lpBmp->DataBit);
                                                             // Start position of spooling
            xPos = ((LONG)lpBmp->DrawPos.x + posClpLft) * posAdj;
            yPos = ((LONG)lpBmp->DrawPos.y + strHigCnt) * posAdj;

            lpBit = lpBmp->lpBit + widthByte * strHigCnt;
                                                             // Spool CMYK bit image
            CMYKImgCmd(pdevobj, comp, xPos, yPos, lpBmp->Frame, lpBmp->DataBit, width, higSiz, widthByte,
                       invLftBit, invRgtBit, lpBit, lpTmp, (LONG)lpBmp->DrawPos.x + posClpLft, (LONG)lpBmp->DrawPos.y + strHigCnt);
        }
    }

    if (img1st == No) {                                      // Already spool 
        // Original mode out
        siz = CmdCopy(CmdBuf, &ModOrgOut);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
    }
    if (lpTmp) {
        MemFree(lpTmp);
    }
    return;
}


//===================================================================================================
//    Spool plane command
//===================================================================================================
WORD PlaneCmdStore(                                         // Size of command
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    LPBYTE         lpDst,
    WORD           Plane
)
{
    int            pam[4];
    WORD           siz;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    if (Plane & PLN_CYAN) {
        pam[0] = 0;                                         // Spool
    } else {
        pam[0] = 1;                                         // Not spool
    }
    if (Plane & PLN_MGENTA) {
        pam[1] = 0;                                         // Spool
    } else {
        pam[1] = 1;                                         // Not spool
    }
    if (Plane & PLN_YELLOW) {
        pam[2] = 0;                                         // Spool
    } else {
        pam[2] = 1;                                         // Not spool
    }
    if (Plane & PLN_BLACK) {
        pam[3] = 0;                                         // Spool
    } else {
        pam[3] = 1;                                         // Not spool
    }
    siz = CmdStore(lpDst, &OrgDrwPln, pam);
    return siz;
}


//===================================================================================================
//    Spool bitimage command data
//===================================================================================================
void BitImgImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           Rotation,                                // rotare(0fixed)
    WORD           InvLeft,                                 // Invalid size from the left edge
    WORD           InvRight,                                // Invalid size from the right edge
    LPBYTE         lpBit                                    // Bitmap data
)
{
    int            pam[10];
    WORD           siz;
    WORD           widByt;
    WORD           linCnt;

    if (InvLeft == 0 && InvRight == 0) {                    // There are no invalid size
        pam[0] = WidthByte * Height;                        // Number of Data byte
        pam[1] = Width;
        pam[2] = Height;
        pam[3] = Rotation;
        siz = CmdStore(CmdBuf, &ImgDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        WRITESPOOLBUF(pdevobj, lpBit, pam[0]);
    } else {                                                // There are invalid size
        widByt = WidthByte - InvLeft - InvRight;            // Width byte
        pam[0] = widByt * Height;
        if (InvRight == 0) {                                // There are no invalid size from the right edge
            pam[1] = Width - InvLeft * 8;                   // Width bit image
        } else {
            pam[1] = widByt * 8;                            // Width bit image
        }
        pam[2] = Height;                                    // Height bit image
        pam[3] = Rotation;
        siz = CmdStore(CmdBuf, &ImgDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        for (linCnt = 0; linCnt < Height; linCnt++) {       // Spool bitmap data by 1 line
            lpBit += InvLeft;
            WRITESPOOLBUF(pdevobj, lpBit, widByt);
            lpBit += widByt;
            lpBit += InvRight;
        }
    }
    return;
}


//===================================================================================================
//    Spool raster image command data
//===================================================================================================
BOOL RasterImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Comp,
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           Rotation,                                // rotate(0:fixed)
    WORD           InvLeft,                                 // Invalid size from the left edge
    WORD           InvRight,                                // Invalid size from the left edge
    LPBYTE         lpBit,                                   // Pointer to bitmap data
    LPBYTE         lpBuf                                    // Pointer to raster image data buffer
)
{
    int            pam[4];
    WORD           siz;
    WORD           widByt;
    WORD           setCnt;
    WORD           ras;                                     // Type of raster image
    WORD           befRas;                                  // Type of raster image(Privious line)
    LPBYTE         lpLas;                                   // Privious raster data
    WORD           dstSiz;                                  // byte size
    WORD           rasSiz;                                  // Raster image data byte size
    WORD           rasEpy;

    MY_VERBOSE((" RAS "));

    widByt = WidthByte - InvLeft - InvRight;                // Width byte (Not include invalid size)
    if (Comp == XX_COMPRESS_AUTO) {
                                                            // Get raster image size
        rasSiz = RasterSize(Height, widByt, InvLeft, InvRight, lpBit);
        if (rasSiz > (widByt * Height / 5 * 4)) {           // Raster rate is more than 80%
            return No;                                      // Error
        }
    }
    pam[0] = 4;
    if (InvRight == 0) {                                    // No invalid size from the right edge
        pam[1] = Width - InvLeft * 8;                       // Width
    } else {
        pam[1] = widByt * 8;                                // Width
    }
    pam[2] = Height;                                        // Height
    pam[3] = Rotation;
    siz = CmdStore(CmdBuf, &ImgRasStr, pam);
    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
    lpLas = NULL;
    rasSiz = 0;
    rasEpy = 0;
    for (setCnt = 0; setCnt < Height; setCnt++) {
        lpBit += InvLeft;
                                                            // Compress
        ras = RasterComp(lpBuf + rasSiz, widByt, lpBit, lpLas, &dstSiz);
        if (setCnt != 0 && befRas != ras) {                 // Not same as raster state of previous line
            if (befRas == RASTER_COMP) {
                pam[0] = rasSiz;
                siz = CmdStore(CmdBuf, &ImgRasDrw, pam);
                WRITESPOOLBUF(pdevobj, CmdBuf, siz);        // Spool command
                WRITESPOOLBUF(pdevobj, lpBuf, rasSiz);      // Spool data
                rasSiz = 0;
            } else if (befRas == RASTER_EMPTY) {
                pam[0] = rasEpy;
                siz = CmdStore(CmdBuf, &ImgRasEpy, pam);
                WRITESPOOLBUF(pdevobj, CmdBuf, siz);
                rasEpy = 0;
            }
        }                                                   // Spool state of current line
        if (ras == RASTER_COMP) {
            rasSiz += dstSiz;
        } else if (ras == RASTER_EMPTY) {
            rasEpy++;
        } else {
            pam[0] = dstSiz;
            siz = CmdStore(CmdBuf, &ImgRasNon, pam);
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);            // Spool command
            WRITESPOOLBUF(pdevobj, lpBit, dstSiz);          // Spool data
        }
        befRas = ras;                                       // Renew
        lpLas = lpBit;                                      // Renew
        lpBit += widByt;                                    // Renew
        lpBit += InvRight;
    }
    if (rasSiz != 0) {                                      // There are raster data without spooling
        pam[0] = rasSiz;
        siz = CmdStore(CmdBuf, &ImgRasDrw, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);                // Spool command
        WRITESPOOLBUF(pdevobj, lpBuf, rasSiz);              // Spool data
    } else if (rasEpy != 0) {                               // There are empty raster data without spooling
        pam[0] = rasEpy;
        siz = CmdStore(CmdBuf, &ImgRasEpy, pam);
        WRITESPOOLBUF(pdevobj, CmdBuf, siz);                // Spool command
    }
    siz = CmdCopy(CmdBuf, &ImgRasEnd);
    WRITESPOOLBUF(pdevobj, CmdBuf, siz);
    return Yes;
}


//===================================================================================================
//    Get size of raster image
//===================================================================================================
WORD RasterSize(
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    WORD           InvLeft,
    WORD           InvRight,
    LPBYTE         lpBit
)
{
    WORD           rasSiz;
    WORD           chkCnt;
    WORD           rasEpy;
    LPBYTE         lpLas;
    WORD           dstCnt;
    WORD           srcCnt;
    WORD           empSiz;
    BYTE           cmpDat;
    WORD           equCnt;

    rasSiz = 0;
    rasEpy = 0;
    lpLas = NULL;
    for (chkCnt = 0; chkCnt < Height; chkCnt++) {           // Check size of raster image
        lpBit += InvLeft;
        srcCnt = WidthByte;
        for (; srcCnt != 0; srcCnt--) {
            if (lpBit[srcCnt - 1] != 0x00) {
                break;
            }
        }
        if (srcCnt == 0) {                                  // 1 line All white data?
            rasEpy++;
            lpLas = lpBit;
            lpBit += WidthByte;
            lpBit += InvRight;
            continue;
        }
        if (rasEpy != 0) {
            rasSiz += 8;
            rasEpy = 0;
        }
        empSiz = WidthByte - srcCnt;
        for (dstCnt = 0, srcCnt = 0; srcCnt < WidthByte; ) {
            if (lpLas != NULL) {
                if (lpLas[srcCnt] == lpBit[srcCnt]) {
                    equCnt = 1;
                    srcCnt++;
                    for (; srcCnt < WidthByte; srcCnt++) {

                        if (lpLas[srcCnt] != lpBit[srcCnt]) {
                            break;
                        }
                        equCnt++;
                    }
                    if (srcCnt == WidthByte) {
                        rasSiz++;
                        break;
                    }
                }
                rasSiz++;
                if (equCnt >= 63) {
                    rasSiz += ((equCnt / 255) + 1);
                }
            }

            if (srcCnt < (WidthByte - 1) && lpBit[srcCnt] == lpBit[srcCnt + 1]) {
                cmpDat = lpBit[srcCnt];
                equCnt = 2;

                for (srcCnt += 2; srcCnt < WidthByte; srcCnt++) {
                    if (cmpDat != lpBit[srcCnt]) {
                        break;
                    }
                    equCnt++;
                }
                rasSiz += 2;
                if (equCnt >= 63) {
                    rasSiz += equCnt / 255 + 1;
                }
            } else {
                if (WidthByte < (dstCnt + 9)) {
                    rasSiz += WidthByte - empSiz + 9;
                    break;
                }
                if ((WidthByte - srcCnt) < 8) {
                    rasSiz += WidthByte - srcCnt + 1;
                    srcCnt += WidthByte - srcCnt;
                } else {
                    rasSiz += 9;
                    srcCnt += 8;
                }
            }
        }
        lpLas = lpBit;
        lpBit += WidthByte;
        lpBit += InvRight;
    }
    return rasSiz;
}


//===================================================================================================
//    Compress raster image
//===================================================================================================
WORD RasterComp(
    LPBYTE         lpDst,
    WORD           Siz,
    LPBYTE         lpSrc,
    LPBYTE         lpLas,
    LPWORD         lpDstSiz
)
{
    WORD           dstCnt;
    WORD           srcCnt;
    WORD           empSiz;
    BYTE           cmpDat;
    WORD           equCnt;
    WORD           setCnt;
    BYTE           flgByt;
    WORD           flgPnt;

    static const BYTE flgTbl[8] = {0x00, 0x01, 0x02, 0x04,
                                   0x08, 0x10, 0x20, 0x40};

    srcCnt = Siz;
    for (; srcCnt != 0; srcCnt--) {
        if (lpSrc[srcCnt - 1] != 0x00) {
            break;
        }
    }
    if (srcCnt == 0) {
        *lpDstSiz = 0;
        return RASTER_EMPTY;
    }
    empSiz = Siz - srcCnt;
    for (dstCnt = 0, srcCnt = 0; srcCnt < Siz; ) {
        if (lpLas != NULL) {
            if (lpLas[srcCnt] == lpSrc[srcCnt]) {
                equCnt = 1;
                srcCnt++;
                for (; srcCnt < Siz; srcCnt++) {
                    if (lpLas[srcCnt] != lpSrc[srcCnt]) {
                        break;
                    }
                    equCnt++;
                }
                if (srcCnt == Siz) {
                    break;
                }
                if (Siz < (dstCnt + equCnt / 255 + 1)) {
                    *lpDstSiz = Siz - empSiz;
                    return RASTER_NONCOMP;
                }
                if (equCnt < 63) {
                    lpDst[dstCnt++] = 0x80 | (BYTE)equCnt;
                } else {
                    lpDst[dstCnt++] = 0x80 | 0x3f;
                    for (equCnt -= 63; equCnt >= 255; equCnt -= 255) {
                        lpDst[dstCnt++] = 0xff;
                    }
                    lpDst[dstCnt++] = (BYTE)equCnt;
                }
            }
        }

        if (srcCnt < (Siz - 1) && lpSrc[srcCnt] == lpSrc[srcCnt + 1]) {
            cmpDat = lpSrc[srcCnt];
            equCnt = 2;
            for (srcCnt += 2; srcCnt < Siz; srcCnt++) {
                if (cmpDat != lpSrc[srcCnt]) {
                    break;
                }
                equCnt++;
            }
            if (Siz < (dstCnt + equCnt / 255 + 2)) {
                *lpDstSiz = Siz - empSiz;
                return RASTER_NONCOMP;
            }
            if (equCnt < 63) {
                lpDst[dstCnt++] = 0xc0 | (BYTE)equCnt;
            } else {
                lpDst[dstCnt++] = 0xc0 | 0x3f;
                for (equCnt -= 63; equCnt >= 255; equCnt -= 255) {
                    lpDst[dstCnt++] = 0xff;
                }
                lpDst[dstCnt++] = (BYTE)equCnt;
            }
            lpDst[dstCnt++] = cmpDat;
        } else {
            if (Siz < (dstCnt + 9)) {
                *lpDstSiz = Siz - empSiz;
                return RASTER_NONCOMP;
            }
            flgPnt = dstCnt;
            dstCnt++;
            flgByt = 0x00;
            if (lpLas != NULL) {
                for (setCnt = 0; srcCnt < Siz && setCnt < 8; srcCnt++, setCnt++) {
                    if (lpLas[srcCnt] != lpSrc[srcCnt]) {
                        lpDst[dstCnt++] = lpSrc[srcCnt];
                        flgByt |= flgTbl[setCnt];
                    }
                }
            } else {

                for (setCnt = 0; srcCnt < Siz && setCnt < 8; srcCnt++, setCnt++) {
                    lpDst[dstCnt++] = lpSrc[srcCnt];
                    flgByt |= flgTbl[setCnt];
                }
            }
            lpDst[flgPnt] = flgByt;
        }
    }
    if (Siz == dstCnt) {
        *lpDstSiz = Siz - empSiz;
        return RASTER_NONCOMP;
    }
    lpDst[dstCnt++] = 0x80;
    *lpDstSiz = dstCnt;
    return RASTER_COMP;
}


//===================================================================================================
//    Spool CMYK Bit image command
//===================================================================================================
void CMYKImgCmd(
    PDEVOBJ        pdevobj,                                 // Pointer to PDEVOBJ structure
    WORD           Comp,
    LONG           XPos,
    LONG           YPos,
    WORD           Frame,
    WORD           DataBit,                                 // (1:2value 2:4value 4:16value)
    WORD           Width,                                   // dot
    WORD           Height,                                  // dot
    WORD           WidthByte,                               // byte
    DWORD          InvLeft,                                 // Invalid size from the left edge
    DWORD          InvRight,                                // Invalid size from the right edge
    LPBYTE         lpBit,
    LPBYTE         lpTmp,
    LONG           XPos_P,
    LONG           YPos_P
)
{
    int            pam[11];
    WORD           siz;
    WORD           widByt;                                  // Width byte(Not include invalid size)
    WORD           Plane;
    LPBYTE         lpDst;                                   // Memory copy
    LPBYTE         lpSrc;                                   // Memory copy
    WORD           linCnt;
    DWORD          widBit;                                  // Width bit(Not include invalid size)
    DWORD          dstSiz;
    DWORD          rasSiz;

    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    widBit = (DWORD)Width * DataBit - InvLeft - InvRight;

    if (Comp == Yes) {                                       // Compress
        siz = CmdCopy(CmdBuf, &ModOrgIn);                    // Original mode in

        if (pOEM->iColor == XX_COLOR_SINGLE 
        || pOEM->iColor == XX_COLOR_MANY
        || pOEM->iColor == XX_COLOR_MANY2) {
            pam[0] = 0;
            pam[1] = 0;
            pam[2] = 0;
            pam[3] = 0;
            if (Frame == 1) {
                pam[0] = 255;
                Plane = PLN_CYAN;
            }
            if (Frame == 2) {
                pam[1] = 255;
                Plane = PLN_MGENTA;
            }
            if (Frame == 3) {
                pam[2] = 255;
                Plane = PLN_YELLOW;
            }
            if (Frame == 0) {
                pam[3] = 255;
                Plane = PLN_BLACK;
            }
            siz += CmdStore(CmdBuf + siz, &OrgColCmy, pam);

            siz += PlaneCmdStore(pdevobj, CmdBuf + siz, Plane);
        }
        siz += CmdCopy(CmdBuf + siz, &ModOrgOut);           // Original mode out
        if (siz != 0) {                                     // There are data for spool?

            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        }
        pam[0] = XPos_P;
        siz = CmdStore(CmdBuf, &PosAbsHrz, pam);
        pam[0] = YPos_P;
        siz += CmdStore(CmdBuf + siz, &PosAbsVtc, pam);
        if (siz != 0) {                                     // There are data for spool
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
        }

        if (RasterImgCmd(pdevobj, pOEM->iCompress, Width, Height,
                         WidthByte, 0, (WORD)((InvLeft + 7) / 8), (WORD)((InvRight + 7) / 8), lpBit, lpTmp) == No) {
            // Not compress because compress rate is poor
            BitImgImgCmd(pdevobj, Width, Height, WidthByte, 0, (WORD)((InvLeft + 7) / 8), (WORD)((InvRight + 7) / 8), lpBit);
        }
    }

    if (Comp == No) {                                        // Not compress
        pam[2] = 0;
        pam[3] = Frame;
        pam[4] = DataBit;
        pam[5] = HIWORD(XPos);
        pam[6] = LOWORD(XPos);
        pam[7] = HIWORD(YPos);
        pam[8] = LOWORD(YPos);
        pam[10] = Height;
        if (InvLeft == 0 && InvRight == 0) {                 // Not include invalid size
            pam[0] = 0;                                      // Data byte size (high byte)
            pam[1] = WidthByte * Height;                     // Data byte size (low byte)
            pam[9] = Width;
            siz = CmdStore(CmdBuf, &OrgImgCmy, pam);
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
            WRITESPOOLBUF(pdevobj, lpBit, pam[1]);
        } else {                                             // Include invalid size
            widByt = (WORD)((widBit + 7) / 8);
            pam[0] = 0;                                      // Data byte size (high byte)
            pam[1] = widByt * Height;                        // Data byte size (low byte)
            pam[9] = (WORD)(widBit / DataBit);
            siz = CmdStore(CmdBuf, &OrgImgCmy, pam);
            WRITESPOOLBUF(pdevobj, CmdBuf, siz);
            for (linCnt = 0; linCnt < Height; linCnt++) {    // Spool bitmap data by 1 line
                WRITESPOOLBUF(pdevobj, lpBit + (WORD)(InvLeft / 8), widByt);
                lpBit += WidthByte;
            }
        }
    }
    return;
}


//===================================================================================================
//    Copy command buffer
//===================================================================================================
WORD CmdCopy(
    LPBYTE         lpDst,
    LPCMDDEF       lpCmdInf
)
{
    WORD           siz;
    LPBYTE         lpCmd;

    lpCmd = lpCmdInf->Cmd;
    for (siz = 0; siz < lpCmdInf->Size; siz++) {
        lpDst[siz] = lpCmd[siz];
    }
    return siz;
}


//===================================================================================================
//    Copy command data
//===================================================================================================
WORD CmdStore(
    LPBYTE         lpDst,
    LPCMDDEF       CmdInf,
    LPINT          lpPam
)
{
    LPBYTE         lpCmd;
    BYTE           cmdDat;
    WORD           cmdCnt;
    WORD           setCnt;
    WORD           pamCnt;
    WORD           upmDat;
    int            pamDat;
    DWORD          dDat;
    LONG           lDat;

    setCnt = 0;
    pamCnt = 0;
    lpCmd = CmdInf->Cmd;
    for (cmdCnt = 0; cmdCnt < CmdInf->Size; cmdCnt++) {     // Copy
        cmdDat = *lpCmd++;
        if (cmdDat != '%') {
            lpDst[setCnt++] = cmdDat;
        } else {
            cmdCnt++;
            switch (cmdDat = *lpCmd++) {                    // Type
                case 'u':
                    setCnt += USINTtoASC(&lpDst[setCnt], (WORD)lpPam[pamCnt++]);
                    break;
                case 'd':
                    setCnt += INTtoASC(&lpDst[setCnt], lpPam[pamCnt++]);
                    break;
#if 0   /* 441435: Currently Not used */
                case 'y':
                    upmDat = (WORD)lpPam[pamCnt++];

                    if (upmDat == 0 || (upmDat / 100) != 0) {

                        setCnt += USINTtoASC(&lpDst[setCnt], (WORD)(upmDat / 100));
                    }
                    if ((upmDat % 100) != 0) {
                        lpDst[setCnt++] = '.';

                        setCnt += USINTtoASC(&lpDst[setCnt], (WORD)(upmDat % 100));
                    }
                    break;
                case 'z':
                    pamDat = lpPam[pamCnt++];

                    if (upmDat == 0 || (upmDat / 100) != 0) {

                        setCnt += INTtoASC(&lpDst[setCnt], (pamDat / 100));
                    }
                    if ((pamDat % 100) != 0) {
                        lpDst[setCnt++] = '.';
                        if (pamDat < 0) {
                            pamDat = 0 - pamDat;
                        }

                        setCnt += USINTtoASC(&lpDst[setCnt], (WORD)(pamDat % 100));
                    }
                    break;
#endif   /* 441435: Currently Not used */
                case 'w':
                    dDat = MAKELONG(lpPam[pamCnt + 1], lpPam[pamCnt]);
                    setCnt += USLONGtoASC(&lpDst[setCnt], dDat);
                    pamCnt += 2;
                    break;
                case 'l':
                    lDat = MAKELONG(lpPam[pamCnt + 1], lpPam[pamCnt]);
                    setCnt += LONGtoASC(&lpDst[setCnt], lDat);
                    pamCnt += 2;
                    break;
#if 0   /* 441435: Currently Not used */
                case 'b':
                    lpDst[setCnt++] = (BYTE)lpPam[pamCnt++];
                    break;
#endif   /* 441435: Currently Not used */
                case '%':
                    lpDst[setCnt++] = cmdDat;
                    break;
            }
        }
    }
    return setCnt;
}


//===================================================================================================
//    int -> ascii
//===================================================================================================
WORD INTtoASC(
    LPBYTE         lpDst,
    int            Dat                                      // Conversion data
)
{
    WORD           setCnt;
    WORD           divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    if (Dat < 0) {
        lpDst[setCnt++] = '-';
        Dat = 0 - Dat;
    }
    setVal = No;
    for (divDat = 10000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= (int)divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}


//===================================================================================================
//    usint -> ascii
//===================================================================================================
WORD USINTtoASC(
    LPBYTE         lpDst,
    WORD           Dat
)
{
    WORD           setCnt;
    WORD           divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    setVal = No;
    for (divDat = 10000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}


//===================================================================================================
//    long -> ascii
//===================================================================================================
WORD LONGtoASC(
    LPBYTE         lpDst,
    LONG           Dat
)
{
    WORD           setCnt;
    DWORD          divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    if (Dat < 0) {
        lpDst[setCnt++] = '-';
        Dat = 0 - Dat;
    }
    setVal = No;
    for (divDat = 1000000000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= (LONG)divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}


//===================================================================================================
//    uslong -> ascii
//===================================================================================================
WORD USLONGtoASC(
    LPBYTE         lpDst,
    DWORD          Dat
)
{
    WORD           setCnt;
    DWORD          divDat;
    WORD           setVal;

    setCnt = 0;
    if (Dat == 0) {
        lpDst[setCnt++] = '0';
        return setCnt;
    }
    setVal = No;
    for (divDat = 1000000000; divDat != 1; divDat /= 10) {
        if (setVal == Yes) {
            lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
        } else {
            if (Dat >= divDat) {

                lpDst[setCnt++] = (BYTE)(Dat / divDat + '0');
                setVal = Yes;
            }
        }
        Dat %= divDat;
    }
    lpDst[setCnt++] = (BYTE)(Dat + '0');
    return setCnt;
}



// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\csn5res\prnctl.h ===
//***************************************************************************************************
//    PRNCTL.H
//
//    C Header(Functions of controlling printer)
//---------------------------------------------------------------------------------------------------
//    copyright(C) 1997-2000 CASIO COMPUTER CO.,LTD. / CASIO ELECTRONICS MANUFACTURING CO.,LTD.
//***************************************************************************************************

//***************************************************************************************************
//    Data define
//***************************************************************************************************
//---------------------------------------------------------------------------------------------------
//    Plane
//---------------------------------------------------------------------------------------------------
#define    PLN_CYAN        0x8000
#define    PLN_MGENTA      0x4000
#define    PLN_YELLOW      0x2000
#define    PLN_BLACK       0x1000

#define    PLN_ALL            (PLN_CYAN | PLN_MGENTA | PLN_YELLOW | PLN_BLACK)

//---------------------------------------------------------------------------------------------------
//    Structure of spooling bitmap data
//---------------------------------------------------------------------------------------------------
typedef struct {
    WORD        Style;                                      // Type of spool
    WORD        Plane;                                      // Plane
    CMYK        Color;                                      // CMYK
    WORD        Diz;                                        // Type of dithering
    POINT       DrawPos;                                    // Start position of spooling
    WORD        Width;                                      // dot
    WORD        Height;                                     // dot
    WORD        WidthByte;                                  // byte
    LPBYTE      lpBit;                                      // bitamp data
} DRWBMP, FAR *LPDRWBMP;

//---------------------------------------------------------------------------------------------------
//    Structure of spooling CMYK bitmap data
//---------------------------------------------------------------------------------------------------
typedef struct {
    WORD        Style;                                      // Type of spool
    WORD        Plane;                                      // Plane
    WORD        Frame;                                      // Frame
    WORD        DataBit;                                    // Databit
    POINT       DrawPos;                                    // Start position of spool
    WORD        Width;                                      // dot
    WORD        Height;                                     // dot
    WORD        WidthByte;                                  // byte
    LPBYTE      lpBit;                                      // Bitmap data
} DRWBMPCMYK, FAR *LPDRWBMPCMYK;


//***************************************************************************************************
//     Functions
//***************************************************************************************************
//===================================================================================================
//    Spool bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmap(PDEVOBJ, LPDRWBMP);

//===================================================================================================
//    Spool CMYK bitmap data
//===================================================================================================
void FAR PASCAL PrnBitmapCMYK(PDEVOBJ, LPDRWBMPCMYK);

// End of File
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cswinres\debug.c ===
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cswinres\cswinid.h ===
#ifndef _CSWINID_H
#define _CSWINID_H

// Callback ID's
#define RES_SENDBLOCK           12

#define RES_SELECTRES_240       14
#define RES_SELECTRES_400       15

#define CM_XM_ABS               20
#define CM_YM_ABS               22

#define CM_REL_LEFT             24
#define CM_REL_RIGHT            25
#define CM_REL_UP               26
#define CM_REL_DOWN             27

#define CM_FE_RLE               30
#define CM_DISABLECOMP          31

#define CSWM_CR                 40
#define CSWM_COPY               45
#define CSWM_FF                 47
#define CSWM_LF                 48

#define AUTOFEED                49

#define PS_SEGMENT              60
#define PS_A3                   60
#define PS_B4                   61
#define PS_A4                   62
#define PS_B5                   63
#define PS_LETTER               64
#define PS_POSTCARD             65
#define PS_A5                   66
#define PS_FREE                 67

#define PRN_3250GTWM           109
#define PRN_3500GTWM           110
#define PRN_3800WM             111

#define SBYTE                  120
#define DBYTE                  121
#define CM_BOLD_ON             122
#define CM_BOLD_OFF            123
#define CM_ITALIC_ON           124
#define CM_ITALIC_OFF          125
#define CM_WHITE_ON            126
#define CM_WHITE_OFF           127

#define START_DOC              130
#define END_DOC                131

#define DRW_WHITE_RECT         140
#define DRW_BLACK_RECT         141
#define DRW_GRAY_RECT          142
#define DRW_RECT_WIDTH         143
#define DRW_RECT_HEIGHT        144


#endif //_CSWINID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cswinres\cswinres.c ===
// =========================================================================
//
//        CASIO PAGEPRESTO Universal Printer Driver for MS-Windows NT 5.0
//
// =========================================================================

//// CSWINRES.C file for Winmode Common DLL


#include "pdev.h"
#include "cswinres.h"
#include "cswinid.h"

#if DBG
#  include "mydbg.h"
#endif

#include <stdio.h>
#undef wsprintf
#define wsprintf sprintf

#define CCHMAXCMDLEN 256
#define MAX_STRLEN 255

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define DRVGETDRIVERSETTING(p, t, o, s, n, r) \
    ((p)->pDrvProcs->DrvGetDriverSetting(p, t, o, s, n, r))

#define PARAM(p,n) \
    (*((p)+(n)))


BOOL
BInitOEMExtraData(
        POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.

    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    return TRUE;
}


BOOL
BMergeOEMExtraData(
        POEMUD_EXTRADATA pdmIn,
        POEMUD_EXTRADATA pdmOut)
{
    return TRUE;
}

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PMYPDEV pOEM;

    VERBOSE(("OEMEnablePDEV - %08x\n", pdevobj));

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(MYPDEV))))
        {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));
            return NULL;
        }
    }

    // misc initializations

    pOEM = (PMYPDEV)pdevobj->pdevOEM;
    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    VERBOSE(("OEMDisablePDEV - %08x\n", pdevobj));

    if(pdevobj->pdevOEM)
    {
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}

BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PMYPDEV pOld, pNew;

    VERBOSE(("OEMResetPDEV - %08x, %08x\n", pdevobjOld, pdevobjNew));

    if (NULL == (pOld = (PMYPDEV)pdevobjOld->pdevOEM) ||
        NULL == (pNew = (PMYPDEV)pdevobjNew->pdevOEM)) {
        ERR(("Invalid PDEV\n"));
        return FALSE;
    }

    *pNew = *pOld;
    return TRUE;
}

static
VOID
LoadJobSetupCmd(
    PDEVOBJ pdevobj,
    PMYPDEV pOEM)
{
    BYTE ajOutput[64];
    DWORD dwNeeded;
    DWORD dwOptionsReturned;

    if (pOEM->dwGeneral & FG_HAS_TSAVE) {

        if(!DRVGETDRIVERSETTING(pdevobj, "TonerSave", ajOutput, 
                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
            WARNING(("DrvGetDriverSetting(1) Failed\n"));
            pOEM->jTonerSave = VAL_TS_NOTSELECT;
        } else {
            VERBOSE(("TonerSave:%s\n", ajOutput));
            if (!strcmp(ajOutput, OPT_TS_NORMAL)) {
                pOEM->jTonerSave = VAL_TS_NORMAL;
                VERBOSE(("VAL_TS_NORMAL\n"));
            } else if (!strcmp(ajOutput, OPT_TS_LV1)) {
                pOEM->jTonerSave = VAL_TS_LV1;
                VERBOSE(("VAL_TS_LV1\n"));
            } else if (!strcmp(ajOutput, OPT_TS_LV2)) {
                pOEM->jTonerSave = VAL_TS_LV2;
                VERBOSE(("VAL_TS_LV2\n"));
            } else if (!strcmp(ajOutput, OPT_TS_LV3)) {
                pOEM->jTonerSave = VAL_TS_LV3;
                VERBOSE(("VAL_TS_LV3\n"));
            } else {
                pOEM->jTonerSave = VAL_TS_NOTSELECT;
                VERBOSE(("VAL_TS_NOTSELECT\n"));
            }
        }
        VERBOSE(("jTonerSave:%x\n", pOEM->jTonerSave));
    }

    if (pOEM->dwGeneral & FG_HAS_SMOTH) {

        if (!DRVGETDRIVERSETTING(pdevobj, "Smoothing", ajOutput,
                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
            WARNING(("DrvGetDriverSetting(1) Failed\n"));
            pOEM->jSmoothing = VAL_SMOOTH_NOTSELECT;
        } else {
            VERBOSE(("Smoothing:%s\n", ajOutput));
            if (!strcmp(ajOutput, OPT_SMOOTH_OFF)) {
                pOEM->jSmoothing = VAL_SMOOTH_OFF;
                VERBOSE(("VAL_SMOOTH_OFF\n"));
            } else if (!strcmp(ajOutput, OPT_SMOOTH_ON)) {
                pOEM->jSmoothing = VAL_SMOOTH_ON;
                VERBOSE(("VAL_SMOOTH_ON\n"));
            } else {
                pOEM->jSmoothing = VAL_SMOOTH_NOTSELECT;
                VERBOSE(("VAL_SMOOTH_NOTSELECT\n"));
            }
        }
        VERBOSE(("jSmoothing:%x\n", pOEM->jSmoothing));
    }

    if (!DRVGETDRIVERSETTING(pdevobj, "MPFSetting", ajOutput,
                                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        WARNING(("DrvGetDriverSetting(1) Failed\n"));
        pOEM->jMPFSetting = MPF_NOSET;
    } else {
        VERBOSE(("MPFSetting:%s\n", ajOutput));
        if (!strcmp(ajOutput, OPT_A3)) {
            pOEM->jMPFSetting = MPF_A3;
            VERBOSE(("MPF_A3\n"));
        } else if (!strcmp(ajOutput, OPT_B4)) {
            pOEM->jMPFSetting = MPF_B4;
            VERBOSE(("MPF_B4\n"));
        } else if (!strcmp(ajOutput, OPT_A4)) {
            pOEM->jMPFSetting = MPF_A4;
            VERBOSE(("MPF_A4\n"));
        } else if (!strcmp(ajOutput, OPT_B5)) {
            pOEM->jMPFSetting = MPF_B5;
            VERBOSE(("MPF_B5\n"));
        } else if (!strcmp(ajOutput, OPT_A5)) {
            pOEM->jMPFSetting = MPF_A5;
            VERBOSE(("MPF_A5\n"));
        } else if (!strcmp(ajOutput, OPT_LETTER)) {
            pOEM->jMPFSetting = MPF_LETTER;
            VERBOSE(("MPF_LETTER\n"));
        } else if (!strcmp(ajOutput, OPT_POSTCARD)) {
            pOEM->jMPFSetting = MPF_POSTCARD;
            VERBOSE(("MPF_POSTCARD\n"));
        } else {
            pOEM->jMPFSetting = MPF_NOSET;
            VERBOSE(("MPF_NOSET\n"));
        }
    }
    VERBOSE(("jMPFSetting:%x\n", pOEM->jMPFSetting));

}

static
VOID
LoadPaperSelectCmd(
    PDEVOBJ pdevobj,
    PMYPDEV pOEM,
    INT iPaperID,
    WORD wPapSizeX,
    WORD wPapSizeY)
{
    BYTE cmdbuf[CCHMAXCMDLEN];
    WORD wlen = 0;
    DWORD dwTemp;
    WORD wPapLenX;
    WORD wPapLenY;
    BYTE ajOutput[64];
    DWORD dwNeeded;
    DWORD dwOptionsReturned;
    BYTE bOrientation;
    
    switch (iPaperID) {
    case PS_LETTER:

        if (pOEM->jMPFSetting == MPF_LETTER) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     Not Support Free
        // MS(MPF paper Size)    28h: Letter -

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x28;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_A3:

        if (pOEM->jMPFSetting == MPF_A3) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     Not Support Free
        // MS(MPF paper Size)    1Fh: A3 |

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x1F;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_A4:

        if (pOEM->jMPFSetting == MPF_A4) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     Not Support Free
        // MS(MPF paper Size)    2Ah: A4 -

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x2A;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_B4:

        if (pOEM->jMPFSetting == MPF_B4) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)    Not Support Free
        // MS(MPF paper Size)    25h: B4 |

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x25;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_B5:

        if (pOEM->jMPFSetting == MPF_B5) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     Not Support Free
        // MS(MPF paper Size)    2Ch: B5 -

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x2C;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_A5:

        if (pOEM->jMPFSetting == MPF_A5) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     Not Support Free
        // MS(MPF paper Size)    2Eh: A5 -

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x2E;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_POSTCARD:

        if (pOEM->jMPFSetting == MPF_POSTCARD) {
            pOEM->jAutoSelect = 0x11;    // MPF
        } else if (pOEM->jModel == MD_CP3800WM) {
            pOEM->jAutoSelect = AutoFeed_3800[iPaperID - PS_SEGMENT];
        } else {
            pOEM->jAutoSelect = AutoFeed[iPaperID - PS_SEGMENT];
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     Not Support Free
        // MS(MPF paper Size)    31h: PostCard |

        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x00;
        cmdbuf[wlen++] = 0x31;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case PS_FREE:
        pOEM->jAutoSelect = 0x11;    // MPF

        if(!DRVGETDRIVERSETTING(pdevobj, "Orientation", ajOutput, 
                sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
            WARNING(("LoadPaperSelectCmd(1) Failed\n"));
            bOrientation = 1;
        } else {
            VERBOSE(("Orientation:%s\n", ajOutput));
            if (!strcmp(ajOutput, "PORTRAIT")) {
                bOrientation = 1;
            } else {
                bOrientation = 2;
            }
        }

        // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
        //                         ~~ ~~
        // MF(MPF Free size)     XSize,YSize mm (X[hi],X[lo],Y[hi],Y[lo])
        // MS(MPF paper Size)    FFh: FreePaper |

// 2001/02/27 ->
//      dwTemp = (wPapSizeX * 254) / MASTER_UNIT;                               // 0.1mm a unit
//      wPapLenX = (WORD)((dwTemp + 5) /10);                                    //   1mm a unit, round
        dwTemp = (wPapSizeX * 2540) / MASTER_UNIT;                              // 0.01mm a unit
        wPapLenX = (WORD)((dwTemp + 99) /100);                                  //    1mm a unit, roundup
//      dwTemp = (wPapSizeY * 254) / MASTER_UNIT;                               // 0.1mm a unit
//      wPapLenY = (WORD)((dwTemp + 5) /10);                                    //   1mm a unit, round
        dwTemp = (wPapSizeY * 2540) / MASTER_UNIT;                              // 0.01mm a unit
        wPapLenY = (WORD)((dwTemp + 99) /100);                                  //    1mm a unit, roundup
// 2001/02/27 <-
        if (bOrientation == 1) {
            cmdbuf[wlen++] = HIBYTE(wPapLenX);
            cmdbuf[wlen++] = LOBYTE(wPapLenX);
            cmdbuf[wlen++] = HIBYTE(wPapLenY);
            cmdbuf[wlen++] = LOBYTE(wPapLenY);
        } else {
            cmdbuf[wlen++] = HIBYTE(wPapLenY);
            cmdbuf[wlen++] = LOBYTE(wPapLenY);
            cmdbuf[wlen++] = HIBYTE(wPapLenX);
            cmdbuf[wlen++] = LOBYTE(wPapLenX);
        }
        cmdbuf[wlen++] = 0xFF;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;
    }
}

INT APIENTRY
OEMCommandCallback(
        PDEVOBJ pdevobj,
        DWORD   dwCmdCbID,
        DWORD   dwCount,
        PDWORD  pdwParams)
{
    PMYPDEV pOEM;

    BYTE            cmdbuf[CCHMAXCMDLEN];
    WORD            wlen, i, wRectCmdLen;
    WORD            wDestX, wDestY;
    BYTE            bGrayScale ;
    INT             iRet = 0;
    union _temp {
        DWORD   dwTemp;
        WORD    wTemp;
        BYTE    jTemp;
    } Temp;

    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

#if 0
#if DBG
{
    int i, max;
    for (i = 0; i < (max = sizeof(MyCallbackID) / sizeof(MyCallbackID[0])); i++) {
        if (MyCallbackID[i].dwID == dwCmdCbID){
            VERBOSE(("%s PARAMS: %d\n", MyCallbackID[i].S, dwCount));
            break;
        }
    }
    if (i == max)
        WARNING(("%d is Invalid ID\n", dwCmdCbID));
}
#endif

#endif

    ASSERT(VALID_PDEVOBJ(pdevobj));

    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    wlen = 0;

    //
    // fill in printer commands
    //

    switch (dwCmdCbID) {
        case RES_SENDBLOCK:

            if (pOEM->dwGeneral & FG_COMP){
                Temp.dwTemp = PARAM(pdwParams, 0) + 8;    // 8: Parameter Lengeth (except ImageData)

                // 'c' LN X Y IW IH D
                // ~~~ ~~

                cmdbuf[wlen++] = 'c';
                cmdbuf[wlen++] = (BYTE)(Temp.dwTemp >> 24);
                cmdbuf[wlen++] = (BYTE)(Temp.dwTemp >> 16);
                cmdbuf[wlen++] = (BYTE)(Temp.dwTemp >> 8);
                cmdbuf[wlen++] = (BYTE)(Temp.dwTemp);
            } else {

                // 'b' X Y IW IH D
                // ~~~
                cmdbuf[wlen++] = 'b';
            }

            // 'c' LN X Y IW IH D
            //        ~ ~ ~~ ~~
            // 'b' X Y IW IH D
            //     ~ ~ ~~ ~~

            cmdbuf[wlen++] = (BYTE)(pOEM->sWMXPosi >> 8);
            cmdbuf[wlen++] = (BYTE)(pOEM->sWMXPosi);
            cmdbuf[wlen++] = (BYTE)(pOEM->sWMYPosi >> 8);
            cmdbuf[wlen++] = (BYTE)(pOEM->sWMYPosi);

            cmdbuf[wlen++] = (BYTE)(PARAM(pdwParams, 1) >> 8);
            cmdbuf[wlen++] = (BYTE)PARAM(pdwParams, 1);
            cmdbuf[wlen++] = (BYTE)(PARAM(pdwParams, 2) >> 8);
            cmdbuf[wlen++] = (BYTE)PARAM(pdwParams, 2);

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            break;

        case RES_SELECTRES_240:

            pOEM->sRes = RATIO_240;

            // ESC i | RT PF AJ PM MF MS PS PO CP OS
            //            ~~ ~~ ~~

            cmdbuf[wlen++] = 0x18;    // 18h -> 24d    Page Format
            cmdbuf[wlen++] = 0x10;    // Not Adjust
            cmdbuf[wlen++] = 0x10;    // cancell Page Marge

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

            break;

        case RES_SELECTRES_400:

            pOEM->sRes = RATIO_400;

            // ESC i | RT PF AJ PM MF MS PS PO CP OS
            //            ~~ ~~ ~~

            cmdbuf[wlen++] = 0x28;    // 28h -> 40d    Page Format
            cmdbuf[wlen++] = 0x10;    // Not Adjust
            cmdbuf[wlen++] = 0x10;    // cancell Page Marge

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

            break;

        case CM_XM_ABS:

            // Set return value accordingly.  Unidrv expects
            // the values to be retuned in device's unit here.

            iRet = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("XMOVEABS:X=%d, Y=%d\n", iRet,
                                      (SHORT)(PARAM(pdwParams, 1) / pOEM->sRes)));

            pOEM->sWMXPosi = (SHORT)(PARAM(pdwParams, 0) / pOEM->sRes);

            break;

        case CM_YM_ABS:

            // Set return value accordingly.  Unidrv expects
            // the values to be retuned in device's unit here.
            iRet = (WORD)(PARAM(pdwParams, 1) / pOEM->sRes);
            VERBOSE(("YMOVEABS:X=%d, Y=%d\n",
                            (SHORT)(PARAM(pdwParams, 0) / pOEM->sRes), iRet));

            pOEM->sWMYPosi = (SHORT)(PARAM(pdwParams, 1) / pOEM->sRes);
            break;

        case CM_REL_LEFT:

            // Set return value accordingly.  Unidrv expects
            // the values to be retuned in device's unit here.
            iRet = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CM_REL_LEFT:%d\n", iRet));
            VERBOSE(("DestXRel:%d\n", PARAM(pdwParams, 0)));

            pOEM->sWMXPosi -= (SHORT)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CurosorPosition X:%d Y:%d\n",
                                        pOEM->sWMXPosi, pOEM->sWMYPosi));
            break;

        case CM_REL_RIGHT:

            // Set return value accordingly.  Unidrv expects
            // the values to be retuned in device's unit here.
            iRet = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CM_REL_RIGHT:%d\n", iRet));
            VERBOSE(("DestXRel:%d\n", PARAM(pdwParams, 0)));

            pOEM->sWMXPosi += (SHORT)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CurosorPosition X:%d Y:%d\n",
                                        pOEM->sWMXPosi, pOEM->sWMYPosi));
            break;

        case CM_REL_UP:

            // Set return value accordingly.  Unidrv expects
            // the values to be retuned in device's unit here.
            iRet = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CM_REL_UP:%d\n", iRet));
            VERBOSE(("DestYRel:%d\n", PARAM(pdwParams, 0)));

            pOEM->sWMYPosi -= (SHORT)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CurosorPosition X:%d Y:%d\n",
                                        pOEM->sWMXPosi, pOEM->sWMYPosi));
            break;

        case CM_REL_DOWN:

            // Set return value accordingly.  Unidrv expects
            // the values to be retuned in device's unit here.
            iRet = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CM_REL_DOWN:%d\n", iRet));
            VERBOSE(("DestYRel:%d\n", PARAM(pdwParams, 0)));

            pOEM->sWMYPosi += (SHORT)(PARAM(pdwParams, 0) / pOEM->sRes);
            VERBOSE(("CurosorPosition X:%d Y:%d\n",
                                        pOEM->sWMXPosi, pOEM->sWMYPosi));
            break;

        case CM_FE_RLE:
            pOEM->dwGeneral |= FG_COMP;
            break;

        case CM_DISABLECOMP:
            pOEM->dwGeneral &= ~FG_COMP;
            break;

        case CSWM_CR:

            pOEM->sWMXPosi = 0;
            break;

        case CSWM_FF:

            pOEM->sWMXPosi = 0;
            pOEM->sWMYPosi = 0;

            cmdbuf[wlen++] = '3';

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            break;

        case CSWM_LF:

            pOEM->sWMXPosi = 0;
            break;

        case CSWM_COPY:

            Temp.dwTemp = PARAM(pdwParams, 0);
            if (Temp.dwTemp > 255) Temp.dwTemp = 255;    // max
            if (Temp.dwTemp < 1) Temp.dwTemp = 1;        // min

            // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
            //                                     ~~ ~~

            cmdbuf[wlen++] = (BYTE)Temp.dwTemp;    // Copy
            cmdbuf[wlen++] = 0x80;            // character Offset All 0 

            if (pOEM->jModel == MD_CP3800WM) {
                // ESC 'i' 7Eh LG TS SM VS HS

                cmdbuf[wlen++] = 0x1B;
                cmdbuf[wlen++] = 'i';
                cmdbuf[wlen++] = 0x7E;
                cmdbuf[wlen++] = 0x04;                      // LG(command LenGth)
                cmdbuf[wlen++] = pOEM->jTonerSave;    // TS(Toner Save)
                cmdbuf[wlen++] = pOEM->jSmoothing;    // SM(SMoothing) 01h: ON
                cmdbuf[wlen++] = 0xFF;                      // VS(Vertical Shift)
                cmdbuf[wlen++] = 0xFF;                      // HS(Horizontal Shift)
            }

            // Winmode IN
            // ESC 'i' 'z'

            VERBOSE(("Enterning Win-mode\n"));

            pOEM->bWinmode = TRUE;

            cmdbuf[wlen++] = 0x1b;
            cmdbuf[wlen++] = 'i';
            cmdbuf[wlen++] = 'z';

            //Enginge Resolution Setting
            // '1' E

            cmdbuf[wlen++] = '1';
            if (pOEM->sRes == RATIO_400) {
                // 0190h->400d
                cmdbuf[wlen++] = 0x01;
                cmdbuf[wlen++] = 0x90;
            } else {
                // 00F0h->240d
                cmdbuf[wlen++] = 0x00;
                cmdbuf[wlen++] = 0xF0;
            }

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            break;

        case AUTOFEED:

            // ESC 'i' '|' RT PF AJ PM MF MS PS PO CP OS
            //                               ~~
            // PS(Paper feed Select)

            cmdbuf[wlen++] = pOEM->jAutoSelect;

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            break;

        case PS_LETTER:
        case PS_A3:
        case PS_A4:
        case PS_B4:
        case PS_B5:
        case PS_A5:
        case PS_POSTCARD:
//            LoadPaperSelectCmd(pdevobj, pOEM, dwCmdCbID);
            LoadPaperSelectCmd(pdevobj, pOEM, dwCmdCbID, 0, 0);
            break;

        case PS_FREE:
            LoadPaperSelectCmd(pdevobj, pOEM, dwCmdCbID, 
                               (WORD)PARAM(pdwParams, 0), (WORD)PARAM(pdwParams, 1));
            break;

        case PRN_3250GTWM:

            VERBOSE(("CmdStartJob - CP3250GT\n"));

            pOEM->jModel = MD_CP3250GTWM;
            pOEM->dwGeneral &= ~FG_HAS_TSAVE;
            pOEM->dwGeneral &= ~FG_HAS_SMOTH;
            LoadJobSetupCmd(pdevobj, pOEM);
            break;

        case PRN_3500GTWM:

            VERBOSE(("CmdStartJob - CP-3500GT\n"));

            pOEM->jModel = MD_CP3500GTWM;
            pOEM->dwGeneral &= ~FG_HAS_TSAVE;
            pOEM->dwGeneral &= ~FG_HAS_SMOTH;
            LoadJobSetupCmd(pdevobj, pOEM);
            break;

        case PRN_3800WM:

            VERBOSE(("CmdStartJob - CP-3800\n"));

            pOEM->jModel = MD_CP3800WM;
            pOEM->dwGeneral |= FG_HAS_TSAVE;
            pOEM->dwGeneral |= FG_HAS_SMOTH;
            LoadJobSetupCmd(pdevobj, pOEM);
            break;

        case SBYTE:
            pOEM->dwGeneral &= ~FG_DOUBLE;
            break;

        case DBYTE:
            pOEM->dwGeneral |= FG_DOUBLE;
            break;

//+++ For character attribute switch

        case CM_BOLD_ON:
            pOEM->dwGeneral |= FG_BOLD;
            goto SET_ATTRIB;

        case CM_BOLD_OFF:
            pOEM->dwGeneral &= ~FG_BOLD;
            goto SET_ATTRIB;

        case CM_ITALIC_ON:
            pOEM->dwGeneral |= FG_ITALIC;
            goto SET_ATTRIB;

        case CM_ITALIC_OFF:
            pOEM->dwGeneral &= ~FG_ITALIC;
            goto SET_ATTRIB;

        case CM_WHITE_ON:
            // B CL
            cmdbuf[wlen++] = 'B';
            cmdbuf[wlen++] = 0x01;

            // G OL LW LV FP
            cmdbuf[wlen++] = 'G';
            cmdbuf[wlen++] = 0x00;
            cmdbuf[wlen++] = 0x00;
            cmdbuf[wlen++] = 0x01;
            cmdbuf[wlen++] = 0x01;
            cmdbuf[wlen++] = 0x00;

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

            pOEM->dwGeneral |= FG_WHITE;
            goto SET_ATTRIB;

        case CM_WHITE_OFF:
            // B CL
            cmdbuf[wlen++] = 'B';
            cmdbuf[wlen++] = 0x00;

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

            pOEM->dwGeneral &= ~FG_WHITE;
            goto SET_ATTRIB;

SET_ATTRIB: // 'C' As(Attribute Switch)
            if ((  Temp.jTemp = ((BYTE)(pOEM->dwGeneral & (FG_BOLD | FG_ITALIC | FG_WHITE)) ))
                                                                    != pOEM->jPreAttrib) {
                cmdbuf[wlen++] = 'C';
                cmdbuf[wlen++] = Temp.jTemp;

                WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

                pOEM->jPreAttrib = Temp.jTemp;
            }
            break;
//---

        case START_DOC:

            VERBOSE(("CmdStartDoc\n"));

        // For Debug
        //*Cmd: "<1B>i|<04>"

            // If status is WINMODE IN, then output WINMODE OUT command
            if (pOEM->bWinmode) {

                VERBOSE(("Leave Win-mode to issue init comands.\n"));
                cmdbuf[wlen++] = '0';    // WINMODE OUT
                pOEM->bWinmode = FALSE;
            }

        /*
         *    The following command(Initialize) is invalid when it is WINMODE.
         *    WINMODE OUT command must be outputed in END_DOC before Initialize.
         *    Initialize(START DOC procsee) command must not be ouputed without END DOC process.
         *    Printer Rom of some version can use 07h command instead of WINMODE OUT.
         *                   ~~~~~~~~~~~~~
         *
         *    07h        WINMODE OUT command when it is Winmode
         *               NOP commnad in except when it is Winmode
         */
//          cmdbuf[wlen++] = 0x07;
            cmdbuf[wlen++] = 0x1B;
            cmdbuf[wlen++] = 'i';
            cmdbuf[wlen++] = '|';
            cmdbuf[wlen++] = 0x04;

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

            break;

        case END_DOC:

            VERBOSE(("CmdEndDoc\n"));

            VERBOSE(("Exit Win-mode.\n"));

            pOEM->bWinmode = FALSE;
            cmdbuf[wlen++] = '0';    // WINMODE OUT

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            break;

        case DRW_WHITE_RECT:
            wDestX = (WORD)PARAM(pdwParams, 0) / pOEM->sRes;
            wDestY = (WORD)PARAM(pdwParams, 1) / pOEM->sRes;

            cmdbuf[wlen++] = 0x65; //PaintMode
            cmdbuf[wlen++] = 0x00; //Pattern

            cmdbuf[wlen++] = 0x70; //Draw Box command
            cmdbuf[wlen++] = 0x00; //No line
            cmdbuf[wlen++] = 0x00; //Line Width(H)
            cmdbuf[wlen++] = 0x01; //Line Width(L) : 1dot
            cmdbuf[wlen++] = 0x01; //Line Color : white
            cmdbuf[wlen++] = 0x00; //OR Line
            cmdbuf[wlen++] = 0x00; //Pattern //White
            cmdbuf[wlen++] = 0x00; //OR Pattern
            cmdbuf[wlen++] = 0x00; //GrayScale
            cmdbuf[wlen++] = (BYTE)((wDestX >> 8) & 0xff); //X1 (H)
            cmdbuf[wlen++] = (BYTE)((wDestX >> 0) & 0xff); //X1 (L)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 8) & 0xff); //Y1 (H)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 0) & 0xff); //Y1 (L)

            wDestX += (pOEM->wRectWidth - 1);
            wDestY += (pOEM->wRectHeight - 1);

            cmdbuf[wlen++] = (BYTE)((wDestX >> 8) & 0xff); //X2 (H)
            cmdbuf[wlen++] = (BYTE)((wDestX >> 0) & 0xff); //X2 (L)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 8) & 0xff); //Y2 (H)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 0) & 0xff); //Y2 (L)
            cmdbuf[wlen++] = 0x00; //Corner(H) : 
            cmdbuf[wlen++] = 0x00; //Corner(L) : 90

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            break;

        case DRW_BLACK_RECT:
            wDestX = (WORD)PARAM(pdwParams, 0) / pOEM->sRes;
            wDestY = (WORD)PARAM(pdwParams, 1) / pOEM->sRes;

            cmdbuf[wlen++] = 0x65; //PaintMode
            cmdbuf[wlen++] = 0x00; //Pattern

            cmdbuf[wlen++] = 0x70; //Draw Box command
            cmdbuf[wlen++] = 0x00; //No line
            cmdbuf[wlen++] = 0x00; //Line Width(H)
            cmdbuf[wlen++] = 0x01; //Line Width(L) : 1dot
            cmdbuf[wlen++] = 0x01; //Line Color : white
            cmdbuf[wlen++] = 0x00; //OR Line
            cmdbuf[wlen++] = 0x01; //Pattern : black
            cmdbuf[wlen++] = 0x00; //OR Pattern
            cmdbuf[wlen++] = 0x00; //GrayScale
            cmdbuf[wlen++] = (BYTE)((wDestX >> 8) & 0xff); //X1 (H)
            cmdbuf[wlen++] = (BYTE)((wDestX >> 0) & 0xff); //X1 (L)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 8) & 0xff); //Y1 (H)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 0) & 0xff); //Y1 (L)

            wDestX += (pOEM->wRectWidth - 1);
            wDestY += (pOEM->wRectHeight - 1);

            cmdbuf[wlen++] = (BYTE)((wDestX >> 8) & 0xff); //X2 (H)
            cmdbuf[wlen++] = (BYTE)((wDestX >> 0) & 0xff); //X2 (L)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 8) & 0xff); //Y2 (H)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 0) & 0xff); //Y2 (L)
            cmdbuf[wlen++] = 0x00; //Corner(H) : 
            cmdbuf[wlen++] = 0x00; //Corner(L) : 90

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

            break;

        case DRW_GRAY_RECT:

            wDestX = (WORD)PARAM(pdwParams, 0) / pOEM->sRes;
            wDestY = (WORD)PARAM(pdwParams, 1) / pOEM->sRes;
            bGrayScale = (BYTE)((WORD)PARAM(pdwParams, 2) * 255 / 100);

            cmdbuf[wlen++] = 0x65; //PaintMode
            cmdbuf[wlen++] = 0x02; //GrayScale

            cmdbuf[wlen++] = 0x70; //Draw Box command
            cmdbuf[wlen++] = 0x00; //No line
            cmdbuf[wlen++] = 0x00; //Line Width(H)
            cmdbuf[wlen++] = 0x01; //Line Width(L) : 1dot
            cmdbuf[wlen++] = 0x01; //Line Color : white
            cmdbuf[wlen++] = 0x00; //OR Line
            cmdbuf[wlen++] = bGrayScale; //Pattern
            cmdbuf[wlen++] = 0x00; //OR Pattern
            cmdbuf[wlen++] = bGrayScale; //GrayScale
            cmdbuf[wlen++] = (BYTE)((wDestX >> 8) & 0xff); //X1 (H)
            cmdbuf[wlen++] = (BYTE)((wDestX >> 0) & 0xff); //X1 (L)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 8) & 0xff); //Y1 (H)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 0) & 0xff); //Y1 (L)

            wDestX += (pOEM->wRectWidth - 1);
            wDestY += (pOEM->wRectHeight - 1);

            cmdbuf[wlen++] = (BYTE)((wDestX >> 8) & 0xff); //X2 (H)
            cmdbuf[wlen++] = (BYTE)((wDestX >> 0) & 0xff); //X2 (L)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 8) & 0xff); //Y2 (H)
            cmdbuf[wlen++] = (BYTE)((wDestY >> 0) & 0xff); //Y2 (L)
            cmdbuf[wlen++] = 0x00; //Corner(H) : 
            cmdbuf[wlen++] = 0x00; //Corner(L) : 90

            WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

           break;
        case DRW_RECT_WIDTH :
            pOEM->wRectWidth = (WORD)PARAM(pdwParams, 0) / pOEM->sRes;
            break;

        case DRW_RECT_HEIGHT:
            pOEM->wRectHeight = (WORD)PARAM(pdwParams, 0) / pOEM->sRes;
            break;

    }

    return iRet;
}


/*
 *
 * OEMSendFontCmd
 *
 */
VOID APIENTRY
OEMSendFontCmd(
    PDEVOBJ        pdevobj,
    PUNIFONTOBJ    pUFObj,
    PFINVOCATION   pFInv)
{
    PGETINFO_STDVAR    pSV;
    DWORD              adwStdVariable[2+2*4];
    DWORD              dwIn, dwOut;
    PBYTE              pubCmd;
    BYTE               aubCmd[128];
    PIFIMETRICS        pIFI;
    DWORD              dwHeight, dwWidth;
    PMYPDEV pOEM;
    BYTE               Cmd[128];
    WORD               wlen;
    DWORD              dwNeeded;

    VERBOSE(("OEMSendFontCmd() entry.\n"));

    pubCmd = pFInv->pubCommand;
    pIFI =   pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + (sizeof(DWORD) + sizeof(LONG)) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;

    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    // Initialize pOEM
    if (pIFI->jWinCharSet == 0x80)
        pOEM->dwGeneral |= FG_DOUBLE;
    else
        pOEM->dwGeneral &= ~FG_DOUBLE;

    pOEM->dwGeneral &=  ~FG_BOLD;
    pOEM->dwGeneral &=  ~FG_ITALIC;

    dwOut = 0;
    // 'L' CT
    // CT(Character Table)
    aubCmd[dwOut++] = 'L';

    if('@' == *((LPSTR)pIFI+pIFI->dpwszFaceName)) {
        pOEM->dwGeneral |= FG_VERT;
        aubCmd[dwOut++] = 0x01;
        aubCmd[dwOut++] = 'A';
        aubCmd[dwOut++] = 0x00;
        aubCmd[dwOut++] = 0x5A;
        pOEM->dwGeneral |= FG_VERT_ROT;
    } else {
        pOEM->dwGeneral &= ~FG_VERT;
        aubCmd[dwOut++] = 0x00;
        aubCmd[dwOut++] = 'A';
        aubCmd[dwOut++] = 0x00;
        aubCmd[dwOut++] = 0x00;
        pOEM->dwGeneral &= ~FG_VERT_ROT;
    }
//  if (pIFI->jWinPitchAndFamily & 0x01)
    if (pIFI->jWinPitchAndFamily & FIXED_PITCH)
        pOEM->dwGeneral |= FG_PROP;
    else
        pOEM->dwGeneral &= ~FG_PROP;

//  pOEM->dwGeneral &= ~FG_DBCS;

    for ( dwIn = 0; dwIn < pFInv->dwCount;) {
        if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'H') {

            dwHeight = pSV->StdVar[0].lStdVariable / pOEM->sRes;

            if (dwHeight < 16) dwHeight = 8;
            if (dwHeight > 2560) dwHeight = 2560;

            aubCmd[dwOut++] = (BYTE)(dwHeight >> 8);
            aubCmd[dwOut++] = (BYTE)dwHeight;
            VERBOSE(("Height=%d\n", dwHeight));
            dwIn += 2;
        } else if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'W') {
            if (pubCmd[dwIn+2] == 'S') {

                dwWidth = pSV->StdVar[1].lStdVariable / pOEM->sRes;

                if (dwWidth < 8) dwWidth = 8;
                if (dwWidth > 1280) dwWidth = 1280;

                aubCmd[dwOut++] = (BYTE)(dwWidth >> 8);
                aubCmd[dwOut++] = (BYTE)dwWidth;
                dwIn += 3;
            } else if (pubCmd[dwIn+2] == 'D') {

                dwWidth = (pSV->StdVar[1].lStdVariable / pOEM->sRes) * 2;

                if (dwWidth < 8) dwWidth = 8;
                if (dwWidth > 1280) dwWidth = 1280;

                aubCmd[dwOut++] = (BYTE)(dwWidth >> 8);
                aubCmd[dwOut++] = (BYTE)dwWidth;
                dwIn += 3;
            }
            VERBOSE(("Width=%d\n", dwWidth));
        } else {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }

    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

}



/*
 *
 * OEMOutputCharStr
 *
 */

#if 0 // >>> Change UFM File(JIS->SJIS) >>>
void jis2sjis(BYTE jJisCode[], BYTE jSjisCode[])
{
    BYTE jTmpM, jTmpL;

    jTmpM = jJisCode[0];
    jTmpL = jJisCode[1];

    if (jTmpM % 2)
        jTmpM++;
    else
        jTmpL += 0x5E;

    jTmpM = jTmpM/2 + 0x70;
    jTmpL += 0x1F;

    if (jTmpM > 0x9F) jTmpM += 0x40;
    if (jTmpL > 0x7E) jTmpL++;

    jSjisCode[0] = jTmpM;
    jSjisCode[1] = jTmpL;
}
#endif // <<< Change UFM File(JIS->SJIS) <<<

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING  GStr;
// #333653: Change I/F for GETINFO_GLYPHSTRING
    // BYTE                 aubBuff[1024];
    PBYTE                aubBuff;
    PTRANSDATA           pTrans;
    PDWORD               pdwGlyphID;
    PWORD                pwUnicode;
    DWORD                dwI;
    DWORD                dwNeeded;
    PMYPDEV pOEM;
    PIFIMETRICS          pIFI;

    BYTE                 Cmd[256];

    WORD                 wlen;
#if 0 // >>> Change UFM File(JIS->SJIS) >>>
    BYTE                 ajConvertOut[2];
#endif // <<< Change UFM File(JIS->SJIS) <<<
    PGETINFO_STDVAR      pSV;
    DWORD                adwStdVariable[2+2*2];
    SHORT                sCP, sCP_Double, sCP_Vert;

    BYTE                 jTmp;
    LONG                 lFontHeight, lFontWidth;

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    VERBOSE(("OEMOutputCharStr() entry.\n"));

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + (sizeof(DWORD) + sizeof(LONG)) * (2 - 1);
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    lFontHeight = pSV->StdVar[0].lStdVariable / pOEM->sRes;
    lFontWidth  = pSV->StdVar[1].lStdVariable / pOEM->sRes;

// ---

    sCP = (SHORT)lFontWidth;
    sCP_Double = sCP * 2;
    sCP_Vert = (SHORT)lFontHeight;

    switch (dwType){
        case TYPE_GLYPHHANDLE:

            //
            // Call the Unidriver service routine to convert
            // glyph-handles into the character code data.
            //

// #333653: Change I/F for GETINFO_GLYPHSTRING
                GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
                GStr.dwCount   = dwCount;
                GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
                GStr.pGlyphIn  = pGlyph;
                GStr.dwTypeOut = TYPE_TRANSDATA;
                GStr.pGlyphOut = NULL;
                GStr.dwGlyphOutSize = 0;

                // pGlyph = (PVOID)((HGLYPH *)pGlyph + GStr.dwCount);

                VERBOSE(("Character Count = %d\n", GStr.dwCount));

                if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, GStr.dwSize, &dwNeeded) || !GStr.dwGlyphOutSize) {
                    ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
                    return;
                }

                if ((aubBuff = (PBYTE)MemAlloc(GStr.dwGlyphOutSize)) == NULL) {
                    ERR(("UNIFONTOBJ_GetInfo:MemAlloc failed.\n"));
                    return;
                }

                GStr.pGlyphOut = aubBuff;

                if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, GStr.dwSize, &dwNeeded)){
                    ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
                    MemFree(aubBuff);
                    return;
                }

                pTrans = (PTRANSDATA)aubBuff;

            while (dwCount) {
                if (dwCount > MAX_STRLEN) {
                    GStr.dwCount = MAX_STRLEN;
                    dwCount -= MAX_STRLEN;
                } else {
                    GStr.dwCount = dwCount;
                    dwCount = 0;
                }

                wlen = 0;
                for (dwI = 0; dwI < GStr.dwCount; dwI++, pTrans++){
//                  VERBOSE(("TYPE_TRANSDATA:ubCodePageID:0x%x\n", pTrans->ubCodePageID));
//                  VERBOSE(("TYPE_TRANSDATA:ubType:0x%x\n", pTrans->ubType));

                    switch (pTrans->ubType & MTYPE_FORMAT_MASK){
                        case MTYPE_DIRECT: 
//                          VERBOSE(("TYPE_TRANSDATA:ubCode:0x%x\n", pTrans->uCode.ubCode));

                            if (dwI == 0){

                                if('O' == *((LPSTR)pIFI+pIFI->dpwszFaceName)) {
                                    // OCR
                                    VERBOSE(("OCR\n"));
                                    if (GStr.dwCount > 1)
                                        Cmd[wlen++] = 'W';
                                    else
                                        Cmd[wlen++] = 'U';
                                } else {
                                    VERBOSE(("PICA\n"));
                                    if (GStr.dwCount > 1)
                                        Cmd[wlen++] = 'O';
                                    else
                                        Cmd[wlen++] = 'M';
                                }

                                Cmd[wlen++] = (BYTE)(pOEM->sWMXPosi >> 8);
                                Cmd[wlen++] = (BYTE)pOEM->sWMXPosi;
                                Cmd[wlen++] = (BYTE)(pOEM->sWMYPosi >> 8);
                                Cmd[wlen++] = (BYTE)pOEM->sWMYPosi;

                                if (GStr.dwCount > 1) {
                                    Cmd[wlen++] = 0x00;              // Draw Vector
                                    Cmd[wlen++] = (BYTE)(sCP >> 8);  // Character Pitch
                                    Cmd[wlen++] = (BYTE)sCP;
                                    Cmd[wlen++] = (BYTE)GStr.dwCount;
                                }
                            }

                            Cmd[wlen++] = pTrans->uCode.ubCode;

                            pOEM->sWMXPosi += sCP;
                            break;    // MTYPE_DIRECT

                        case MTYPE_PAIRED: 
//                          VERBOSE(("TYPE_TRANSDATA:ubPairs:0x%x\n", *(PWORD)(pTrans->uCode.ubPairs)));

                            switch (pTrans->ubType & MTYPE_DOUBLEBYTECHAR_MASK){

#if 0 // >>> Change UFM File(JIS->SJIS) >>>
      // When JIS CODE
      //   In Case of 1byte character, passed MYTYPE_SINGLE
      //
      // When Shift-JIS CODE
      //   In Case of 1byte character, passed MTYPE_DIRECT

                                case MTYPE_SINGLE: 
                                    if ( (pOEM->dwGeneral & (FG_VERT | FG_VERT_ROT))
                                                                     == (FG_VERT | FG_VERT_ROT) ) {
                                        Cmd[wlen++] = 'A';
                                        Cmd[wlen++] = 0x00;
                                        Cmd[wlen++] = 0x00;
                                        pOEM->dwGeneral &= ~FG_VERT_ROT;
                                    }

                                    if (dwI == 0){
                                        if (GStr.dwCount > 1)
                                            Cmd[wlen++] = 'O';
                                        else
                                            Cmd[wlen++] = 'M';

                                        Cmd[wlen++] = (BYTE)(pOEM->sWMXPosi >> 8);
                                        Cmd[wlen++] = (BYTE)pOEM->sWMXPosi;
                                        Cmd[wlen++] = (BYTE)(pOEM->sWMYPosi >> 8);
                                        Cmd[wlen++] = (BYTE)pOEM->sWMYPosi;

                                        if (GStr.dwCount > 1) {
                                            Cmd[wlen++] = 0x00;              // Draw Vector
                                            Cmd[wlen++] = (BYTE)(sCP >> 8);  // Character Pitch
                                            Cmd[wlen++] = (BYTE)sCP;
                                            Cmd[wlen++] = (BYTE)GStr.dwCount;
                                        }
                                    }

                                    // JIS -> ASCII
                                    switch (pTrans->uCode.ubPairs[0]) {
                                        case 0x21:
                                            if (Cmd[wlen] = jJis2Ascii[0][pTrans->uCode.ubPairs[1] - 0x20])
                                                wlen++;
                                            else    // If 0 (no entry), space
                                                Cmd[wlen++] = 0x20;
                                            break;

                                        case 0x23:
                                            Cmd[wlen++] = pTrans->uCode.ubPairs[1];
                                            break;

                                        case 0x25:
                                            if (Cmd[wlen] = jJis2Ascii[1][pTrans->uCode.ubPairs[1] - 0x20])
                                                wlen++;
                                            else    // If 0 (no entry), space
                                                Cmd[wlen++] = 0x20;
                                            break;

                                        default:    // If 0 (no entry), space
                                            Cmd[wlen++] = 0x20;
                                            break;
                                    }

                                    pOEM->sWMXPosi += sCP;
                                    break;    // MTYPE_SINGLE
#endif // <<< Change UFM File(JIS->SJIS) <<<

                                case MTYPE_DOUBLE:
                                    if( (pOEM->dwGeneral & (FG_VERT | FG_VERT_ROT)) == FG_VERT ) {
                                        Cmd[wlen++] = 'A';
                                        Cmd[wlen++] = 0x00;
                                        Cmd[wlen++] = 0x5A;
                                        pOEM->dwGeneral |= FG_VERT_ROT;
                                    }

                                    if (dwI == 0){
                                        if (GStr.dwCount > 1)
                                            Cmd[wlen++] = 'S';
                                        else
                                            Cmd[wlen++] = 'Q';

                                        Cmd[wlen++] = (BYTE)(pOEM->sWMXPosi >> 8);
                                        Cmd[wlen++] = (BYTE)pOEM->sWMXPosi;
                                        if (pOEM->dwGeneral & FG_VERT) {
                                            Cmd[wlen++] = (BYTE)(
                                                            (pOEM->sWMYPosi + (SHORT)lFontWidth * 2) >> 8);
                                            Cmd[wlen++] = (BYTE)(pOEM->sWMYPosi + (SHORT)lFontWidth * 2);
                                        } else {
                                            Cmd[wlen++] = (BYTE)(pOEM->sWMYPosi >> 8);
                                            Cmd[wlen++] = (BYTE)pOEM->sWMYPosi;
                                        }

                                        if (GStr.dwCount > 1) {
                                            Cmd[wlen++] = 0x00;                     // Draw Vector
                                            
                                            if (pOEM->dwGeneral & FG_VERT){  // Character Pitch
                                                Cmd[wlen++] = (BYTE)(sCP_Double >> 8);
                                                Cmd[wlen++] = (BYTE)sCP_Double;
                                            } else {
                                                Cmd[wlen++] = (BYTE)(sCP_Vert >> 8);
                                                Cmd[wlen++] = (BYTE)sCP_Vert;
                                            }

                                            Cmd[wlen++] = (BYTE)GStr.dwCount;
                                        }
                                    }

#if 0 // Change UFM File(JIS->SJIS)
                                    jis2sjis(pTrans->uCode.ubPairs, ajConvertOut);
                                    Cmd[wlen++] = ajConvertOut[0];
                                    Cmd[wlen++] = ajConvertOut[1];
#else
                                    Cmd[wlen++] = pTrans->uCode.ubPairs[0];
                                    Cmd[wlen++] = pTrans->uCode.ubPairs[1];
#endif
//                                  VERBOSE(("AfterConvert: %x%x\n",
//                                                                 ajConvertOut[0], ajConvertOut[1]));
                                    if (pOEM->dwGeneral & FG_VERT)
                                        pOEM->sWMXPosi += sCP_Double;
                                    else
                                        pOEM->sWMXPosi += sCP_Vert;

                                    break;    // MTYPE_DOUBLE
                            }

                            break;    // MTYPE_PAIRED
                    }
                    WRITESPOOLBUF(pdevobj, Cmd, wlen);
                    wlen = 0;

                }     // for
            }         // while
// #333653: Change I/F for GETINFO_GLYPHSTRING
            MemFree(aubBuff);
            break;    // TYPE_GLYPHHANDLE

#if 0
        case TYPE_GLYPHID:

            for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++){
                ERR(("TYEP_GLYPHID:0x%x\n", *(PDWORD)pGlyph));
            }
            break;
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cswinres\cswinres.h ===
#ifndef _CSWINRES_H
#define _CSWINRES_H

// ===== Printer Model =====
#define MD_CP3250GTWM           0x01
#define MD_CP3500GTWM           0x02
#define MD_CP3800WM             0x03

// MPF Setting
#define OPT_NOSET               "Option1"
#define OPT_A3                  "Option2"
#define OPT_B4                  "Option3"
#define OPT_A4                  "Option4"
#define OPT_B5                  "Option5"
#define OPT_LETTER              "Option6"
#define OPT_POSTCARD            "Option7"
#define OPT_A5                  "Option8"

// Toner Save
#define OPT_TS_NORMAL           "Option1"
#define OPT_TS_LV1              "Option2"
#define OPT_TS_LV2              "Option3"
#define OPT_TS_LV3              "Option4"
#define OPT_TS_NOTSELECT        "Option5"

// Smoothing
#define OPT_SMOOTH_OFF          "Option1"
#define OPT_SMOOTH_ON           "Option2"
#define OPT_SMOOTH_NOTSELECT    "Option3"

// ===== AutoFeed =====
const
static BYTE AutoFeed[] = {        /* Auto Select */
                                  0x26,    /* A3 */
                                  0x29,    /* B4 */
                                  0x2b,    /* A4 */
                                  0x2c,    /* B5 */
                                  0x11,    /* Letter */
                                  0x2f,    /* PostCard */
                                  0x2d     /* A5 */
};

const
static BYTE AutoFeed_3800[] = {   /* For 3800 */
                                  0x26,    /* A3 */
                                  0x29,    /* B4 */
                                  0x2b,    /* A4 */
                                  0x2c,    /* B5 */
                                  0x11,    /* Letter */
                                  0x11,    /* PostCard */
                                  0x2d     /* A5 */
};

#define MASTER_UNIT 1200

// ===== JIS->ASCII Table =====
#if 0 // >>> Change UFM File(JIS->SJIS) >>>
const
static BYTE jJis2Ascii[][96] = {

/*++            0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
2120 --*/    {   0,  32, 164, 161,  44,  46, 165,  58,  59,  63,  33, 222, 223,   0,  96,   0,
/*++                SP   A   B   C   D   E   F   G   H   I   J   K   L   M   N
                    SP            ,    .        :    ;    ?    !                 `

2130 --*/       94, 126,  95,   0,   0,   0,   0,   0,   0,   0,   0,   0, 176,  45,   0,  47,
/*++           O   P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^
                ^    ~    _                                                     -         /

2140 --*/        0,   0,   0, 124,   0,   0,   0,  39,   0,  34,  40,  41,  91,  93,  91,  93,
/*++           _   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n
                               |                   '         "     (   )    [    ]    [    ]

2150 --*/      123, 125,  60,  62,   0,   0, 162, 163,   0,   0,   0,   0,  43,  45,   0,   0,
/*++           o   p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~
                {    }    <    >                                          +    -

2160 --*/        0,  61,   0,  60,  62,   0,   0,   0,   0,   0,   0, 223,  39,  34,   0,  92,
/*++                                                        
                     =         <    >                                      '    "         \

2170 --*/       36,   0,   0,  37,  35,  38,  42,  64,   0,   0,   0,   0,   0,   0,   0,   0 },
/*++                                                      
                $              %    #    &    *    @


2520 --*/    {   0, 167, 177, 168, 178, 169, 179, 170, 180, 171, 181, 182,   0, 183,   0, 184,
/*++                @   A   B   C   D   E   F   G   H   I   J   K   L   M   N
                                                                               

2530 --*/        0, 185,   0, 186,   0, 187,   0, 188,   0, 189,   0, 190,   0, 191,   0, 192,
/*++           O   P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^
                                                                                    

2540 --*/        0, 193,   0, 175, 194,   0, 195,   0, 196,   0, 197, 198, 199, 200, 201, 202,
/*++           _   `   a   b   c   d   e   f   g   h   i   j   k   l   m   n
                                                                                 

2550 --*/        0,   0, 203,   0,   0, 204,   0,   0, 205,   0,   0, 206,   0,   0, 207, 208,
/*++           o   p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~
                                                                                      

2560 --*/      209, 210, 211, 172, 212, 173, 213, 174, 214, 215, 216, 217, 218, 219,   0, 220,
/*++                                                        
                                                                             

2570 --*/        0,   0, 166, 221,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 }
/*++                             
                              
      --*/
};
#endif // <<< Change UFM File(JIS->SJIS) <<<


#endif //--- _CSWINRES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cswinres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
}


#if 0
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}

#endif

//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));
        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cswinres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        //VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            //VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            //VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
            }
            else
            {
                *ppv = NULL ;
            //VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        //VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        //VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        //VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        //VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        //VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        //VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {

        //VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

        *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName,
            cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo,
            cjDevInfo, pDevInfo, pded);

        if (*pDevOem)
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        //VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        //VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));

        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        //VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        //VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        //VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        //VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        //VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        //VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        //VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        //VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        //VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        //VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        //VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        //VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        //VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        //VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        //VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        //VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        //VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cswinres\mydbg.h ===
#if DBG
#ifndef MYDBG_H_INCLUDED
#define MYDBG_H_INCLUDED


typedef struct _tblCallbackID {
    char*   S;
    DWORD   dwID;
} tblCallbackID;

static tblCallbackID MyCallbackID[] = {
    {"RES_SENDBLOCK",           12},
    {"RES_SELECTRES_240",       14},
    {"RES_SELECTRES_400",       15},
    {"CM_XM_ABS",               20},
    {"CM_YM_ABS",               22},
    {"CM_REL_LEFT",             24},
    {"CM_REL_RIGHT",            25},
    {"CM_REL_UP",               26},
    {"CM_REL_DOWN",             27},
    {"CM_FE_RLE",               30},
    {"CM_DISABLECOMP",          31},
    {"CSWM_CR",                 40},
    {"CSWM_COPY",               45},
    {"CSWM_FF",                 47},
    {"CSWM_LF",                 48},
    {"AUTOFEED",                49},
    {"PS_A3",                   60},
    {"PS_B4",                   61},
    {"PS_A4",                   62},
    {"PS_B5",                   63},
    {"PS_LETTER",               64},
    {"PS_POSTCARD",             65},
    {"PS_A5",                   66},
    {"PRN_3250GTWM",           109},
    {"PRN_3500GTWM",           110},
    {"PRN_3800WM",             111},
    {"SBYTE",                  120},
    {"DBYTE",                  121},
    {"CM_BOLD_ON",             122},
    {"CM_BOLD_OFF",            123},
    {"CM_ITALIC_ON",           124},
    {"CM_ITALIC_OFF",          125},
    {"CM_WHITE_ON",            126},
    {"CM_WHITE_OFF",           127},
    {"START_DOC",              130},
    {"END_DOC",                131}
};


#endif  // MYDBG_H_INCLUDED
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cswinres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// OEM Signature and version.
//

#define OEM_SIGNATURE   'CPWN'      // CASIO Winmode
#define DLLTEXT(s)      "CSWN: " s
#define OEM_VERSION      0x00010000L


#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
//#define ERRORTEXT(s)    "ERROR " s

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_CPPL_EXTRADATA {
    OEM_DMEXTRAHEADER    dmExtraHdr;
} CPPL_EXTRADATA, *PCPPL_EXTRADATA;
#define POEMUD_EXTRADATA PCPPL_EXTRADATA
#define OEMUD_EXTRADATA CPPL_EXTRADATA
	    
typedef struct {
    BYTE    jModel;
    DWORD   dwGeneral;
    BYTE    jPreAttrib;
    SHORT   sRes;
    SHORT   sWMXPosi;
    SHORT   sWMYPosi;
    BYTE    jAutoSelect;
    BYTE    jTonerSave;
    BYTE    jSmoothing;
    BYTE    jMPFSetting;
    WORD    wRectWidth;
    WORD    wRectHeight;
    BOOL    bWinmode;
    BOOL bHasTonerSave;
    BOOL bHasSmooth;
} MYPDEV, *PMYPDEV;

#define MINIPDEV_DATA(p) ((p)->pdevOEM)

// Value for sRes
// The ratio MasterUnit to DeviceUnit
#define MASTERUNIT	1200
#define RATIO_240	(MASTERUNIT / 240)
#define RATIO_400	(MASTERUNIT / 400)

// Flags for dwGeneral
//+++ 0x000000xx(1byte) For character attribute switch
#define FG_BOLD         0x00000001
#define FG_ITALIC       0x00000002
#define FG_WHITE        0x00000008
// ---
#define FG_VERT	        0x00000100
#define FG_PROP	        0x00000200
#define FG_DOUBLE       0x00000400
#define FG_UNDERLINE	0x00000800
#define FG_STRIKETHRU	0x00001000
#define FG_COMP	        0x00010000
#define FG_VERT_ROT     0x00020000

#define FG_HAS_TSAVE    0x01000000
#define FG_HAS_SMOTH    0x02000000

// Value for byTonerSave
#define VAL_TS_NORMAL			0x00
#define VAL_TS_LV1				0x01
#define VAL_TS_LV2				0x02
#define VAL_TS_LV3				0x03
#define VAL_TS_NOTSELECT		0xFF

// Value for bySmoothing
#define VAL_SMOOTH_OFF			0x00
#define VAL_SMOOTH_ON			0x01
#define VAL_SMOOTH_NOTSELECT	0xFF

// Value for byMPFSetting
#define MPF_NOSET		0x00
#define MPF_A3			0x01
#define MPF_B4			0x02
#define MPF_A4			0x03
#define MPF_B5			0x04
#define MPF_LETTER		0x05
#define MPF_POSTCARD	0x06
#define MPF_A5			0x07



extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cswinres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\casio\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=cswinres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),cswinres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\cswinres.rc \
    $(SRCDIR)\common.c \
    $(SRCDIR)\cswinres.c

MISCFILES=\
    $(SRCDIR)\cswinres.ini \
    $(GPDDIR)\cscp32wj.gpd \
    $(GPDDIR)\cscp35wj.gpd \
    $(GPDDIR)\cscp38wj.gpd \
    $(GPDDIR)\cscp39wj.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\dclsres\code.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

char *rgchModuleName = "DCLSRES";

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    dclsres.c

Abstract:

    Implementation of OEMFilterGraphics callback
        

Environment:

    Windows NT Unidrv driver

Revision History:

    22/10/97 -patryan-
        Port code to NT5.0
--*/

#include	<pdev.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cswinres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
    "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
    "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\dclsres\name.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    name.h

Abstract:

    Interface Function name strings for PublishInterface

--*/
CONST CHAR pstrGetInfo[]                = "GetInfo";
CONST CHAR pstrFilterGraphics[]         = "FilterGraphics";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\dclsres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

//    DbgPrint(DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]);

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
//        DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
//        DbgPrint(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


//
// Functions for outputting debug messages
//

// VOID DbgPrint(IN LPCTSTR pstrFormat,  ...)
// {
//    va_list ap;
//
//    va_start(ap, pstrFormat);
//    EngDebugPrint("", (PCHAR) pstrFormat, ap);
//    va_end(ap);
// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\dclsres\pdev.h ===
/*++

Copyright (C) 1997 - 1999 Microsoft Corporation

--*/


#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>

//
// Debug text.
//
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)
#define TESTSTRING      "Callback for Declasers."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'DCLS'      // Declaser series dll
#define DLLTEXT(s)      __TEXT("DCLSRES:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L

//
// Memory allocation
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }

#ifdef DBG
#define DebugMsg
#else
#define DebugMsg
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\dclsres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() ;

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

// Prototype
BOOL CompressIt(PDEVOBJ, PBYTE, int, IPrintOemDriverUni* );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\dclsres\oemud.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       OEMUD.H
//
//
//  PURPOSE:    Define common data types, and external function prototypes
//                              for OEMUD Test Module.
//
//  PLATFORMS:
//    Windows NT 5.0
//
//
#ifndef _OEMUD_H
#define _OEMUD_H


#include <lib.h>

#include <PRINTOEM.H>



////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


#if 0
////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

#define TESTSTRING      "This is a Unidrv KM test."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

#endif // 0

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////
// VOID DbgPrint(IN LPCTSTR pstrFormat,  ...);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\dclsres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    comoem.cpp

Abstract:

    Windows NT Universal Printer Driver OEM Plug-in Sample

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


#include "pdev.h"
#include "name.h"
#include "code.c"
#include <initguid.h>
#include <prcomoem.h>
#include <assert.h>
#include "comoem.h"



///////////////////////////////////////////////////////////
//
// Globals
//

static HANDLE ghInstance = NULL ;
static long g_cComponents = 0 ;
static long g_cServerLocks = 0 ;

///////////////////////////////////////////////////////////
//
// Export functions
//

BOOL APIENTRY
DllMain(
    HANDLE hInst,
    DWORD dwReason,
    void* lpReserved)
/*++

Routine Description:

    Dll entry point for initializatoin.

Arguments:

    hInst      - Dll instance handle
    wReason    - The reason DllMain was called.
                 Initialization or termination, for a process or a thread.
    lpreserved - Reserved for the system's use

Return Value:

    TRUE if successful, FALSE if there is an error

Note:


--*/
{

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DebugMsg(DLLTEXT("DLLMain: Process attach.\r\n"));

            //
            // Save DLL instance for use later.
            //
            ghInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            DebugMsg(DLLTEXT("DLLMain: Thread attach.\r\n"));
            break;

        case DLL_PROCESS_DETACH:
            DebugMsg(DLLTEXT("DLLMain: Process detach.\r\n"));
            break;

        case DLL_THREAD_DETACH:
            DebugMsg(DLLTEXT("DLLMain: Thread detach.\r\n"));
            break;
    }

    return TRUE;
}


STDAPI
DllCanUnloadNow()
/*++

Routine Description:

    Function to return the status that this dll can be unloaded.

Arguments:


Return Value:

    S_OK if it's ok to unload it, S_FALSE if it is used.

Note:


--*/
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

STDAPI
DllGetClassObject(
    const CLSID& clsid,
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    Function to return class factory object

Arguments:

    clsid - CLSID for the class object
    iid   - Reference to the identifier of the interface that communic
    ppv   - Indirect pointer to the communicating interface

Note:

--*/
{
    DebugMsg(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    //
    // Can we create this component?
    //
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    //
    // Create class factory.
    //
    IOemCF* pClassFactory = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pClassFactory == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    //
    // Get requested interface.
    //
    HRESULT hr = pClassFactory->QueryInterface(iid, ppv) ;
    pClassFactory->Release() ;

    return hr ;
}


////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack (IPrintOemUNI) body
//

STDMETHODIMP
IOemCB::QueryInterface(
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    IUnknow QueryInterface

Arguments:

    iid   - Reference to the identifier of the interface that communic
    ppv   - Indirect pointer to the communicating interface

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB: QueryInterface entry\n"));

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ;
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ;
    }
    else
    {
        *ppv = NULL ;
        DebugMsg(DLLTEXT("IOemCB:Return NULL.\n")) ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
IOemCB::AddRef()
/*++

Routine Description:

    IUnknow AddRef interface

Arguments:

    Increment a reference count

Return Value:

    Reference count

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG)
IOemCB::Release()
/*++

Routine Description:

    IUnknown Release interface

Arguments:

    Decrement a reference count

Return Value:

    Reference count

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

STDMETHODIMP
IOemCB::EnableDriver(
    DWORD          dwDriverVersion,
    DWORD          cbSize,
    PDRVENABLEDATA pded)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DisableDriver(VOID)
/*++

Routine Description:

    IPrintOemUni DisableDriver interface
    Free all resources, and get prepared to be unloaded.

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
/*++

Routine Description:

    IPrintOemUni PublishDriverInterface interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));

// Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
    return S_OK;
}

STDMETHODIMP
IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
/*++

Routine Description:

    IPrintOemUni EnablePDEV interface
    Construct its own PDEV. At this time, the driver also passes a function
    table which contains its own implementation of DDI entrypoints

Arguments:

    pdevobj        - pointer to a DEVOBJ structure. pdevobj->pdevOEM is undefined.
    pPrinterName   - name of the current printer.
    Cpatterns      -
    phsurfPatterns -
    cjGdiInfo      - size of GDIINFO
    pGdiInfo       - a pointer to GDIINFO
    cjDevInfo      - size of DEVINFO
    pDevInfo       - These parameters are identical to what39s passed into DrvEnablePDEV.
    pded: points to a function table which contains the system driver39s
    implementation of DDI entrypoints.


Return Value:


--*/
{


    DebugMsg(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
/*++

Routine Description:

    IPrintOemUni ResetPDEV interface
    OEMResetPDEV transfers the state of the driver from the old PDEVOBJ to the
    new PDEVOBJ when an application calls ResetDC.

Arguments:

pdevobjOld - pdevobj containing Old PDEV
pdevobjNew - pdevobj containing New PDEV

Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::ResetPDEV entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
/*++

Routine Description:

    IPrintOemUni DisablePDEV interface
    Free resources allocated for the PDEV.

Arguments:

    pdevobj -

Return Value:


Note:


--*/
{

    DebugMsg(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    return E_NOTIMPL;
};

STDMETHODIMP
IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni GetInfo interface

Arguments:


Return Value:


Note:


--*/
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    DebugMsg(DLLTEXT("IOemCB::GetInfo(%s) entry.\r\n"), OEM_INFO[dwMode]);

    //
    // Validate parameters.
    //
    if( ( (OEMGI_GETSIGNATURE != dwMode) &&
          (OEMGI_GETINTERFACEVERSION != dwMode) &&
          (OEMGI_GETVERSION != dwMode) ) ||
        (NULL == pcbNeeded)
      )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        //
        // Did not write any bytes.
        //
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return S_FALSE;
    }

    //
    // Need/wrote 4 bytes.
    //
    *pcbNeeded = 4;

    //
    // Validate buffer size.  Minimum size is four bytes.
    //
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return S_FALSE;
    }

    //
    // Write information to buffer.
    //
    switch(dwMode)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return S_OK;
}


STDMETHODIMP
IOemCB::GetImplementedMethod(
    PSTR pMethodName)
/*++

Routine Description:

    IPrintOemUni GetImplementedMethod interface

Arguments:


Return Value:


Note:


--*/
{

    LONG lReturn;
    DebugMsg(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    DebugMsg(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName != NULL)
    {
        switch (*pMethodName)
        {
            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        DebugMsg(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        DebugMsg(__TEXT("NOT supported\r\n"));
        return S_FALSE;
    }
}

STDMETHODIMP
IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam)
/*++

Routine Description:

    IPrintOemUni DevMode interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
/*++

Routine Description:

    IPrintOemUni CommandCallback interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    DebugMsg(DLLTEXT("        dwCallbackID = %d\r\n"), dwCallbackID);
    DebugMsg(DLLTEXT("        dwCount      = %d\r\n"), dwCount);

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
/*++

Routine Description:

    IPrintOemUni ImageProcessing interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
/*++

Routine Description:

    IPrintOemUni FilterGraphics interface

Arguments:


Return Value:


Note:


--*/
{
    DWORD dwResult;
    DebugMsg(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));

    BYTE  *lpSrc, *lpTgt;
    static BYTE  localBuf[1300];
    int  i,j, bytesRem,  nBytes;
    static  BYTE  Blk1[256] = {0};
    static  BYTE  Blk4[256] = {0};
    static  BYTE  Blk2Byt1[256] = {0};
    static  BYTE  Blk2Byt2[256] = {0};
    static  BYTE  Blk3Byt1[256] = {0};
    static  BYTE  Blk3Byt2[256] = {0};
    static  BYTE  BindBlk2[4][16] = {0};
    static  BYTE  BindBlk3[16][4] = {0};

    if (!Blk1[1])      //  need to initialize tables
       {
	   for(i = 0 ; i < 256 ; i++)
	   {
	       BYTE  rot;

	       //First Block , one byte only 123456XX to  00654321
	       rot = (BYTE)i;
	       Blk1[i]     = 0x10 & (rot <<=1);
	       Blk1[i]    |= 0x20 & (rot <<=2);
	       rot = (BYTE)i;
	       Blk1[i]    |= 0x08 & (rot >>=1);
	       Blk1[i]    |= 0x04 & (rot >>=2);
	       Blk1[i]    |= 0x02 & (rot >>=2);
	       Blk1[i]    |= 0x01 & (rot >>=2);
	       Blk1[i]     = Blk1[i]  + 0x3F;
	
	       //Second Block first byte  XXXXXX12 to 00000021
	       Blk2Byt1[i]  = 0x01 & (i >>1);
	       Blk2Byt1[i] |= 0x02 & (i <<1);   // i byte
	
	       //Second Block second byte  3456XXXX to 00006543
	       rot = (BYTE)i;
	       Blk2Byt2[i]  = 0x08 & (rot >>=1);
	       Blk2Byt2[i] |= 0x04 & (rot >>=2);
	       Blk2Byt2[i] |= 0x02 & (rot >>=2);
	       Blk2Byt2[i] |= 0x01 & (rot >>=2);   // j byte

	       //Third Block First byte  XXXX1234 to 00004321
	       rot =(BYTE)i;
	       Blk3Byt1[i]  = 0x02 & (rot >>=1);
	       Blk3Byt1[i] |= 0x01 & (rot >>=2);
	       rot = (BYTE)i;
	       Blk3Byt1[i] |= 0x04 & (rot <<=1);
	       Blk3Byt1[i] |= 0x08 & (rot <<=2);   //j byte

	       //Third Block Second byte  56XXXXXX to 00000065
	       rot = (BYTE)i;
	       Blk3Byt2[i]  = 0x02 & (rot >>=5);
	       Blk3Byt2[i] |= 0x01 & (rot >>=2);   //i byte
	
	       //Fourth Block, only byte  XX123456 to 00654321
	       rot = (BYTE)i;
	       Blk4[i]   = 0x08 & (rot <<=1);
	       Blk4[i]  |= 0x10 & (rot <<=2);
	       Blk4[i]  |= 0x20 & (rot <<=2);
	       rot = (BYTE)i;
	       Blk4[i]  |= 0x04 & (rot >>=1);
	       Blk4[i]  |= 0x02 & (rot >>=2);
	       Blk4[i]  |= 0x01 & (rot >>=2);
	       Blk4[i]   = Blk4[i]  + 0x3F;


	   }
	   for(i = 0 ; i < 4 ; i++)
	       for(j = 0 ; j < 16 ; j++)
	       {
		   // Bind 00000021 & 00006543  & add 3F
		   BindBlk2[i][j] = ( (j<< 2 ) | i) + 0x3F;
		   // Bind 00004321 & 00000065  & add 3F
		   BindBlk3[j][i] = ( (i<< 4 ) | j) + 0x3F;
	       }
       }

    bytesRem = dwLen;		
    lpSrc = (PBYTE)pBuf;
    while(bytesRem > 0)
    {
	nBytes = (bytesRem > 3072) ? 3072 : bytesRem;
	bytesRem -= nBytes;
	lpTgt = localBuf;
	for(i = 0 ; i < nBytes / 3 ; i++)
	{
	    *lpTgt++ = Blk1[*lpSrc];
	    lpSrc +=3;
	}
	CompressIt(pdevobj, (PBYTE)localBuf, (int)(lpTgt - localBuf), pOEMHelp);
    }
    // End of block send graphics line feed & carriage return
    pOEMHelp->DrvWriteSpoolBuf(pdevobj, "\x2D\x24", 2, &dwResult);

    bytesRem = dwLen;
    lpSrc = (PBYTE)pBuf;
    while(bytesRem > 0)
    {
	nBytes = (bytesRem > 3072) ? 3072 : bytesRem;
	bytesRem -= nBytes;
	lpTgt = localBuf;
	for(i = 0 ; i < nBytes / 3 ; i++)
	{
	    *lpTgt++ = BindBlk2[ Blk2Byt1[ *lpSrc] ][ Blk2Byt2[ *(lpSrc +1)] ];
	    lpSrc +=3;
	}
	CompressIt(pdevobj, (PBYTE)localBuf, (int)(lpTgt - localBuf), pOEMHelp);
    }
    // End of block send graphics line feed & carriage return

    pOEMHelp->DrvWriteSpoolBuf(pdevobj, "\x2D\x24", 2, &dwResult);
    bytesRem = dwLen;
    lpSrc = (PBYTE)pBuf;
    while(bytesRem > 0)
    {
	nBytes = (bytesRem > 3072) ? 3072 : bytesRem;
	bytesRem -= nBytes;
	lpTgt = localBuf;
	for(i = 0 ; i < nBytes / 3 ; i++)
	{
	    *lpTgt++ = BindBlk3[ Blk3Byt1[ *(lpSrc+1) ] ][ Blk3Byt2[ *(lpSrc +2)] ];
	    lpSrc +=3;
       }
	CompressIt(pdevobj, (PBYTE)localBuf, (int)(lpTgt - localBuf), pOEMHelp);
    }
    // End of block send graphics line feed & carriage return
    pOEMHelp->DrvWriteSpoolBuf(pdevobj, "\x2D\x24", 2, &dwResult);

    bytesRem = dwLen;
    lpSrc = (PBYTE)pBuf;
    while(bytesRem > 0)
    {
	nBytes = (bytesRem > 3072) ? 3072 : bytesRem;
	bytesRem -= nBytes;
	lpTgt = localBuf;
	for(i = 0 ; i < nBytes / 3 ; i++)
	{
	    *lpTgt++ = Blk4[ *(lpSrc+2) ];
	    lpSrc += 3;
	}
	CompressIt(pdevobj, (PBYTE)localBuf, (int)(lpTgt - localBuf), pOEMHelp);
    }

    // End of final block send line feed  & End Block command
    pOEMHelp->DrvWriteSpoolBuf(pdevobj, "\x2D\x9C", 2, &dwResult);

    return  100;                /* Value not used AT PRESENT! */


    if (SUCCEEDED(FilterGraphics( pdevobj,  pBuf,  dwLen)))
        return S_OK;
    else
        return E_FAIL;
}

BOOL
CompressIt(
PDEVOBJ  pdevobj,
PBYTE  ExpBuf,
int   ExpLen,
IPrintOemDriverUni* pOEMHelp)
{
	static BYTE  CompBuf[1200]; //Max size before Compression is 1024
	BYTE  *lpSrc, *lpTgt;
	int InCompMode =0, count=0,i,FormatLen;
	BYTE FormatBuf[10];
	BYTE *pFormat;
	lpSrc = ExpBuf;
	lpTgt = CompBuf;
	DWORD dwResult;

	for (i=0; i < ExpLen; i++,lpSrc++)
	{
	    if ( *lpSrc != *(lpSrc +1))
	    {
            if (!InCompMode)
                *lpTgt++ = *lpSrc;
            else
            {
                InCompMode = 0;
                //Send the repeat char sequence - !#X
                pFormat = FormatBuf;
		FormatLen = sprintf((char *)pFormat,"!%d%c",count,*lpSrc);
                pOEMHelp->DrvWriteSpoolBuf(pdevobj, FormatBuf,FormatLen,&dwResult);
            }
	    }
	    else
	    {
            if (!InCompMode)
            {
                 InCompMode =1;
                 count =2;
                 pOEMHelp->DrvWriteSpoolBuf(pdevobj, CompBuf, (DWORD)(lpTgt - CompBuf), &dwResult);
                 lpTgt = CompBuf;
            }
            else
                 count++;
	     }
	}
	if (!InCompMode)
	     pOEMHelp->DrvWriteSpoolBuf(pdevobj, CompBuf, (DWORD)(lpTgt - CompBuf), &dwResult);
	else
	{
	     //Send the repeat char sequence - !#X
	     pFormat = FormatBuf;
	     FormatLen  = sprintf((char *)pFormat,"!%d%c",count-1,*lpSrc); 	
	     pOEMHelp->DrvWriteSpoolBuf(pdevobj, FormatBuf,FormatLen, &dwResult);
	}
 	return TRUE;

}

IOemCB::~IOemCB()
{
    // Make sure that driver's helper function interface is released.
    if(NULL != pOEMHelp)
    {
        pOEMHelp->Release();
        pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference
    // count should be zero.
    assert(0 == m_cRef);
}

STDMETHODIMP
IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
/*++

Routine Description:

    IPrintOemUni Compression interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
/*++

Routine Description:

    IPrintOemUni HalftonePattern interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,
    POEMMEMORYUSAGE pMemoryUsage)
/*++

Routine Description:

    IPrintOemUni MemoryUsage interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadFontHeader interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadCharGlyph interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni TTDownloadMethod interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
/*++

Routine Description:

    IPrintOemUni OutputCharStr interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv)
/*++

Routine Description:

    IPrintOemUni SendFontCmd interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni DriverDMS interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
/*++

Routine Description:

    IPrintOemUni TextOutAsBitmap interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
/*++

Routine Description:

    IPrintOemUni TTYGetInfo interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Interface Oem Class factory body
//
STDMETHODIMP
IOemCF::QueryInterface(
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    Class Factory QueryInterface interface

Arguments:


Return Value:


Note:


--*/
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
    IOemCF::AddRef()
/*++

Routine Description:

    IPrintOemUni AddRef interface

Arguments:


Return Value:


Note:


--*/
{
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG)
IOemCF::Release()
/*++

Routine Description:

    IPrintOemUni Release interface

Arguments:


Return Value:


Note:


--*/
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

STDMETHODIMP
IOemCF::CreateInstance(
    IUnknown* pUnknownOuter,
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    IPrintOemUni CreateInstance interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("Class factory:\t\tCreate component.")) ;

    //
    // Cannot aggregate.
    //
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    //
    // Create component.
    //
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    //
    // Get the requested interface.
    //
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    //
    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    //
    pOemCB->Release() ;
    return hr ;
}

STDMETHODIMP
IOemCF::LockServer(
    BOOL bLock)
/*++

Routine Description:

    Class Factory LockServer interface

Arguments:


Return Value:


Note:


--*/
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epagcres\debug.c ===
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epagcres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epagcres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

		98/7/16 v-yutah:
		Added Compression entry support

		98/9/3 v-yutah:
		Because of suggestion from ganeshp,
			Modified PublishDriverInterface(), and related to it,
			Modified EnableDriver(), DisableDriver()

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"


// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
#if	1	// Suggested by ganeshp
		// Need to return S_OK so that DisableDriver() will be called, which Releases
		// the reference to the Printer Driver's interface.
		return S_OK;
#else	// Suggested by ganeshp
        return E_NOTIMPL;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
#if	1	// Suggested by ganeshp
		// Release reference to Printer Driver's interface.
		if (this->pOEMHelp)
		{
			this->pOEMHelp->Release();
			this->pOEMHelp = NULL;
		}
		return S_OK;
#else	// Suggested by ganeshp
        return E_NOTIMPL;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        PDEVOEM pTemp;

        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

        if ((pTemp = OEMEnablePDEV(pdevobj, pPrinterName,
                cPatterns, phsurfPatterns, cjGdiInfo,
                pGdiInfo, cjDevInfo, pDevInfo, pded))) {
            *pDevOem = pTemp;
            return S_OK;
        }
        return E_FAIL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
//      VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
#if	1	// Suggested by ganeshp
		// Need to store pointer to Driver Helper functions, if we already haven't.
		if (this->pOEMHelp == NULL)
		{
			HRESULT hResult;
			// Get Interface to Helper Functions.
			hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));
			if(!SUCCEEDED(hResult))
			{
				// Make sure that interface pointer reflects interface query failure.
				this->pOEMHelp = NULL;
				return E_FAIL;
			}
		}
		return S_OK;
#else	// Suggested by ganeshp
        if (this->pOEMHelp == NULL)
            pIUnknown->AddRef();
        this->pOEMHelp = reinterpret_cast<IPrintOemDriverUni*>(pIUnknown);
        return S_OK;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
#if	1
        return E_NOTIMPL;
#else
        *ppbResult = OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader,
										pColorTable, dwCallbackID, pIPParams);

        return S_OK;
#endif
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
#if	0
        return E_NOTIMPL;
#else
        *piResult = OEMCompression(pdevobj, pInBuf, pOutBuf, dwInLen, dwOutLen);

        return S_OK;
#endif
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epagcres\comp.c ===
//
//	Compress20
//

#ifndef MAX_WORD
#define MAX_WORD					0xFFFF
#endif
#define BAND_PIXEL					4
#define SIZE_HEADER20				10

// DCR:
// #define	ADJUST3			// adjust raster data
// DCR:

#if	0	// for BGR888 (not used)
#define MakeCompress20Mode(q)		((WORD) (0x20 + (q)))
#define MakeUncompress20Mode(q)		((WORD) (0x00 + (q)))
#else	// for RGB888 (Unidrv uses this format)
#define MakeCompress20Mode(q)		((WORD) (0x20 + 2 - (q)))
#define MakeUncompress20Mode(q)		((WORD) (0x00 + 2 - (q)))
#endif

typedef struct tagCODINGDATA {
	PBYTE	pCurPtr ;
	DWORD	leftCount ;
	DWORD	code ;
	WORD	codeBits ;
} CODINGDATA ;

static BOOL HufTblInitd = FALSE;
static WORD HufCode[256] ;
static BYTE HufCodeLen[256] ;

/****************************** Internal Functions ****************************/
void WriteDataToBuffer(CODINGDATA * const pCD) ;
void CodeHufmanData(const BYTE d, CODINGDATA * const pCD) ;
void WriteHeader(BYTE *pBuf, DWORD size, WORD width, WORD height, WORD mode) ;
void MakeHufmanTable20(void) ;
BOOL WriteBand(WORD width, WORD height, LONG lDelta, BYTE *pSrc, CODINGDATA *pCD) ;
/******************************************************************************/


__inline void WriteDataToBuffer(CODINGDATA * const pCD)
{
	if (pCD->leftCount) {
		*(pCD->pCurPtr)++ = (BYTE) pCD->code ;
		pCD->leftCount-- ;
		pCD->code >>= 8 ;
	}
	pCD->codeBits -= 8 ;
}


__inline void CodeHufmanData(const BYTE d, CODINGDATA * const pCD)
{
	pCD->code |= ((DWORD) HufCode[d]) << pCD->codeBits ;
	pCD->codeBits += HufCodeLen[d] ;
	
	while (pCD->codeBits >= 8) WriteDataToBuffer(pCD) ;
}


void MakeHufmanTable20(void) 
{
	WORD huf, rhuf, temp, i ;
	int len, num, j ;
	WORD cdn[] = {0, 0, 1, 2, 2, 4, 4, 7, 9, 14, 17, 24, 172} ;

	huf = 0 ;
	num = 0 ;
	
	for(len = 1 ; len <= 12; len++) {
		huf <<= 1;

		for(i = 0; i < cdn[len] ; i++) {
			rhuf = 0 ;
			temp = huf ;

			for (j = 0 ; j < len ; j++) {
				rhuf = (rhuf << 1) | (temp & 1) ;
				temp >>= 1 ;
			}
			
			if (num) {
				j = (num+1) >> 1 ;
				if ((num & 0x1) == 0) j = 256 - j ;
			}
			else {
				j = 0 ;
			}

			HufCode[j] = rhuf ;
			HufCodeLen[j] = (BYTE) len ;

			huf ++ ;
			num ++ ;
		}
	}
}


void WriteHeader(BYTE *pBuf, DWORD size, WORD width, WORD height, WORD mode)
{
	//	Write Size
	*pBuf++ = (BYTE) (size >> 24) ;
	*pBuf++ = (BYTE) (size >> 16) ;
	*pBuf++ = (BYTE) (size >> 8) ;
	*pBuf++ = (BYTE) size ;
	
	//	Write width
	*pBuf++ = (BYTE) (width >> 8) ;
	*pBuf++ = (BYTE) width ;
	
	//	Write height
	*pBuf++ = (BYTE) (height >> 8) ;
	*pBuf++ = (BYTE) height ;
	
	//	Write mode
	*pBuf++ = (BYTE) (mode >> 8) ;
	*pBuf++ = (BYTE) mode ;
}


DWORD Compress20(
		PBYTE pInBuff,
		DWORD dwInBuffLen,
		DWORD dwWidthBytes,
		PBYTE pOutBuff,
		DWORD dwOutBuffLen)
{
	PBYTE pSrc ;
	LONG lDelta ;
	LONG nextBand ;
	CODINGDATA cd ;
	DWORD dwHeight ;
	DWORD y, dwBlock ;
	WORD width, ymod ;
	
	if (dwWidthBytes / 3 > MAX_WORD) {
		return 0 ;
	}
	
	width = (WORD) (dwWidthBytes / 3) ;
	dwHeight = dwInBuffLen / dwWidthBytes ;
	lDelta = (LONG) dwWidthBytes ;
	pSrc = pInBuff ;
	
	if (!HufTblInitd)
	{
		MakeHufmanTable20() ;
		HufTblInitd = TRUE;
	}
	
	// Initialize
	cd.pCurPtr = pOutBuff ;
	cd.leftCount = dwOutBuffLen ;
	
	dwBlock = dwHeight / BAND_PIXEL ;
	ymod = (WORD) (dwHeight % BAND_PIXEL) ;
	nextBand = lDelta * BAND_PIXEL ;
	
	for (y = 0 ; y < dwBlock ; y++) {
		if (WriteBand(width, BAND_PIXEL, lDelta, pSrc, &cd)) return 0 ;
		pSrc += nextBand ;
	}
	if (ymod) {
		if (WriteBand(width, ymod, lDelta, pSrc, &cd)) return 0 ;
	}
	
	if (cd.leftCount == 0) return 0 ;
	return (dwOutBuffLen - cd.leftCount) ;
}


BOOL WriteBand(WORD width, WORD height, LONG lDelta, PBYTE pSrc, CODINGDATA *pCD)
{
	DWORD bandLimit ;
	PBYTE pBandStart ;
	DWORD cntBandStart ;
	
	PBYTE pBand, pPt, pPrePt ;
	WORD x, y, i ;
	BYTE left ;
#ifdef	ADJUST3
	WORD cmod3;
#endif
	
#ifdef	ADJUST3
	// DCR: begin
	// Unidrv might send invalid RasterDataWidthInBytes, so
	// lDelta (was RasterDataWidthInBytes) can be non-multiple of 3.
	// Minidriver must complement the raster data supplemented with the
	// neighbouring pixel.
	// Although Unidrv may omit not only at the starting point of the raster
	// but at the ending point, mini driver can't know which point is omitted,
	// so mini driver always assumes the starting point is omitted.
	// When ending point is omitted, the print out result can't help being
	// color-shifted.
	// DCR: end
	// cmod3 is set to non-zero if lDelta is not a multiple of 3.
	if (cmod3 = (WORD)(lDelta % 3))
	{
		cmod3 = 3 - cmod3;	// set complementary to reduce calculation
	}
	// define BYTEADJ3 macro to get a byte data from PBYTE p, adjusted by
	// cmod3 and complemented by pseudo raster data;
	// where, x is pixel offset in the raster to check starting point condition.
#define	BYTEADJ3(p, x)	((!cmod3) ? *(PBYTE)(p) : ((x) ? *((PBYTE)(p) - cmod3) : *((PBYTE)(p) + 3 - cmod3)))
#endif	// ADJUST3

	bandLimit = (DWORD)width * height + SIZE_HEADER20 ;
	
	for (i = 0 ; i <= 2 ; i++) {
		if (pCD->leftCount <= SIZE_HEADER20) return TRUE ;

		pBandStart = pCD->pCurPtr ;
		cntBandStart = pCD->leftCount ;

		pCD->pCurPtr += SIZE_HEADER20 ;
		pCD->leftCount -= SIZE_HEADER20 ;
		pCD->code = 0 ;
		pCD->codeBits = 0 ;
		
		pBand = pSrc + i ;
		pPt = pBand ;
		left = 0 ;
		
		for (x = 0 ; x < width ; x++) {
#ifndef	ADJUST3
			CodeHufmanData((BYTE) (*pPt-left), pCD) ;
			left = *pPt ;
#else
			CodeHufmanData((BYTE) (BYTEADJ3(pPt, x)-left), pCD) ;
			left = BYTEADJ3(pPt, x) ;
#endif
			pPt += 3 ;
		}
		
		for (y = 1 ; y < height ; y++) {
			pPrePt = pBand ;
			pBand += lDelta ;
			pPt = pBand ;
			left = 0 ;
			
			for (x = 0 ; x < width ; x++) {
#ifndef	ADJUST3
				CodeHufmanData((BYTE) (*pPt-((left+*pPrePt)>>1)), pCD) ;
				left = *pPt ;
#else
				CodeHufmanData((BYTE) (BYTEADJ3(pPt, x)-((left+BYTEADJ3(pPrePt, x))>>1)), pCD) ;
				left = BYTEADJ3(pPt, x) ;
#endif
				pPt += 3 ;
				pPrePt += 3 ;
			}
		}
		
		if (pCD->codeBits) WriteDataToBuffer(pCD) ;
		
		if (cntBandStart <= pCD->leftCount + bandLimit) {
			// Write Block Header
			WriteHeader(pBandStart, cntBandStart - pCD->leftCount, width, height, MakeCompress20Mode(i)) ;
		}
		else {
			// Output Un-Compress Data
			if (cntBandStart <= bandLimit) return TRUE ;

			WriteHeader(pBandStart, bandLimit, width, height, MakeUncompress20Mode(i)) ;
			pBandStart += SIZE_HEADER20 ;
			
			pBand = pSrc + i ;
			
			for (y = 0 ; y < height ; y++) {
				pPt = pBand ;
				pBand += lDelta ;
				for (x = 0 ; x < width ; x++) {
#ifndef	ADJUST3
					*pBandStart++ = *pPt ;
#else
					*pBandStart++ = BYTEADJ3(pPt, x) ;
#endif
					pPt += 3 ;
				}
			}
			
			pCD->pCurPtr = pBandStart ;
			pCD->leftCount = cntBandStart - bandLimit ;
		}
	}
	
	return FALSE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epagcres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs && \
         (pdevobj)->pdevOEM )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'EPGC'      // EPSPN ESC/Page-Color series dll
// #define DLLTEXT(s)      __TEXT("EPGC:  ") __TEXT(s)
#define DLLTEXT(s)      "EPGC:  " s
#define OEM_VERSION      0x00010000L

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epagcres\eprcid.h ===
// Font Resource (UFM)
#define	RC_FONT_ROMAN		1
#define	RC_FONT_SANSRF		2
#define	RC_FONT_COURIER		3
#define	RC_FONT_COURIERI	4
#define	RC_FONT_COURIERB	5
#define	RC_FONT_COURIERZ	6
#define	RC_FONT_SYMBOL		7
#define	RC_FONT_SYMBOLIC	8
#define	RC_FONT_DUTCH		33
#define	RC_FONT_DUTCHI		34
#define	RC_FONT_DUTCHB		35
#define	RC_FONT_DUTCHZ		36
#define	RC_FONT_SWISS		37
#define	RC_FONT_SWISSI		38
#define	RC_FONT_SWISSB		39
#define	RC_FONT_SWISSZ		40
#define	RC_FONT_MOREWB		43

//	Font Resource (UFM):Japanese
#define	RC_FONT_MINCHO		52
#define	RC_FONT_MINCHOV		53
#define	RC_FONT_KGOTHIC		54
#define	RC_FONT_KGOTHICV	55
#define	RC_FONT_MGOTHIC		56
#define	RC_FONT_MGOTHICV	57
#define	RC_FONT_KYOUKA		58
#define	RC_FONT_KYOUKAV		59
#define	RC_FONT_SHOUKAI		60
#define	RC_FONT_SHOUKAIV	61
#define	RC_FONT_MOUHITSU	62
#define	RC_FONT_MOUHITSV	63
#define	RC_FONT_FMINB		64
#define	RC_FONT_FMINBV		65
#define	RC_FONT_FGOB		66
#define	RC_FONT_FGOBV		67
#define	RC_FONT_FMGOT		68
#define	RC_FONT_FMGOTV		69

//	TTFS:Latin; valid only when optional fonts(Swiss721, etc.) provided
#define	RC_TTF_ARIAL		131
#define	RC_DF_SWISS721		132
#define	RC_TTF_COURIERNEW	133
#define	RC_DF_COURIER		134
#define	RC_TTF_SYMBOL		135
#define	RC_DF_SYMBOLIC		136
#define	RC_TTF_TIMESNR		137
#define	RC_DF_DUTCH801		138
#define	RC_TTF_WINGDINGS	139
#define	RC_DF_MOREWINGBATS	140

//	TTFS:Japanese
#define	RC_TTF_MSMINCHO		141
#define	RC_DF_MINCHO		142
#define	RC_TTF_MSMINCHOV	143
#define	RC_DF_MINCHOV		144
#define	RC_TTF_MSGOTHIC		145
#define	RC_DF_GOTHIC		146
#define	RC_TTF_MSGOTHICV	147
#define	RC_DF_GOTHICV		148

#define RC_TTF_MSMINCHO_E   150
#define RC_TTF_MSMINCHOV_E  151
#define RC_TTF_MSGOTHIC_E   152
#define RC_TTF_MSGOTHICV_E  153

//	PaperSize
#define	RC_STR_HLT			257
#define	RC_STR_GLG			258
#define	RC_STR_GLT			259
#define	RC_STR_F4			260
#define	RC_STR_C10			261
#define	RC_STR_A3P			262

// PaperSize:Japanese
//#define	RC_STR_A3N			265
#define	RC_STR_A3W			266
#define	RC_STR_IB5			268

// FontCartridgeName:Japanese
#define	RC_STR_MARUGOT		270
#define	RC_STR_KYOKASHO		271
#define	RC_STR_KAISHO		272
#define	RC_STR_GYOSHO		273
#define	RC_STR_FMINFKGOT	274
#define	RC_STR_FMARUGOT		275

//	PaperSource:US
#define	RC_STR_CST			276
#define	RC_STR_CST1			277
#define	RC_STR_CST2			278
#define	RC_STR_CST3			279
#define	RC_STR_CST4			280
#define	RC_STR_TRAY			281
#define	RC_STR_MPTRAY		282
#define	RC_STR_LCST			283
#define	RC_STR_FTRAY		284
#define	RC_STR_AUTOSEL		285
#define	RC_STR_MMFDR		290
#define	RC_STR_AUTOCHG		291

// Custom Features
#define	RC_STR_FACEDOWN		321
#define	RC_STR_FACEUP		322
#define	RC_STR_THICK		323
#define	RC_STR_THICK_N		324
#define	RC_STR_PRNTRMODE	325
#define	RC_STR_QUALITY		326
#define	RC_STR_SPEED		327
#define	RC_STR_CLRADJUST	328
#define	RC_STR_NONE			329
#define	RC_STR_NATURAL		330
#define	RC_STR_VIVID		331

#define	RC_STR_BRGHTNSS		358
#define	RC_STR_DRVDEF		359
#define	RC_STR_DARK2		360
#define	RC_STR_DARK1		361
#define	RC_STR_NORMAL		362
#define	RC_STR_LGHT1		363
#define	RC_STR_LGHT2		364
#define	RC_STR_LGHT3		365
#define	RC_STR_LGHT4		366
#define	RC_STR_HUE			367
#define	RC_STR_YLW			368
#define	RC_STR_YLWGRN		369
#define	RC_STR_GRN			370
#define	RC_STR_BLUGRN		371
#define	RC_STR_GRNBLU		372
#define	RC_STR_BLU			373
#define	RC_STR_BLUPPL		374
#define	RC_STR_PPL			375
#define	RC_STR_REDPPL		376
#define	RC_STR_RED			377
#define	RC_STR_ORG			378
#define	RC_STR_YLWORG		379
#define	RC_STR_CHROMA		380
#define	RC_STR_FLAT			381
#define	RC_STR_LOW			382
#define	RC_STR_MED			383
#define	RC_STR_HIGH			384
#define	RC_STR_RECTFILL		385
#define	RC_STR_ENABLED		386
#define	RC_STR_DISABLED		387

#define RC_STR_OPTION_ON	390
#define RC_STR_OPTION_OFF	391


//	Custom Features:Japanese
#define	RC_STR_VPADJUST		400
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epagcres\epagcres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1998  Microsoft Corporation
COPYRIGHT (C) 1997-1998  SEIKO EPSON CORP.

Module Name:

    epagcres.c

Abstract:

    ESC/Page specific font metrics resource
    This file contains code for downloading bitmap TrueType fonts
    on Epson ESC/Page printers.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.
    07/../97 Epson
        Modofied to support ESC/Page
    .....
    02/26/98 Epson
        Font downloading memory usage legal calculation implemented
        TTF download range reduced
        Some cleanups

    07/17/98    v-yutah
        Modification for ESC/Page-Color

--*/

#include "pdev.h"

#include "stdio.h"
// DEBUG
//#define    DBGMSGBOX    1    // UNDEF:No MsgBox, 1:level=1, 2:level=2
//#define    DUMPRASTER    1

#ifdef    DBGMSGBOX
#include "stdarg.h"
#endif
// DEBUG

//
// ---- M A C R O  D E F I N E ----
//
#define CCHMAXCMDLEN                    128
#define    MAX_GLYPHSTRLEN                    256        // maximum glyph string length can be passed from Unidrv
#define FONT_HEADER_SIZE                0x86    // format type 2

#define    DOWNLOAD_HEADER_MEMUSG            (56 + 256)
#define    DOWNLOAD_HDRTBL_MEMUSG            134
#define    DOWNLOAD_FNTHDR_MEMUSG            32
#define    DOWNLOAD_FONT_MEMUSG(w,h)        (((((DWORD)(w) + 31)/32)*4)*(DWORD)(h))
#define DOWNLOAD_MIN_FONT_ID            512
#define DOWNLOAD_NO_DBCS_OFFSET            1024
#define DOWNLOAD_MIN_FONT_ID_NO_DBCS    (DOWNLOAD_MIN_FONT_ID + DOWNLOAD_NO_DBCS_OFFSET)
#define DOWNLOAD_MIN_GLYPH_ID            32
#define DOWNLOAD_MAX_GLYPH_ID_J            (DOWNLOAD_MIN_GLYPH_ID + 512 - 1)
#define DOWNLOAD_MAX_GLYPH_ID_C            (DOWNLOAD_MIN_GLYPH_ID + 512 - 1)
#define DOWNLOAD_MAX_GLYPH_ID_K            (DOWNLOAD_MIN_GLYPH_ID + 512 - 1)
#define DOWNLOAD_MAX_GLYPH_ID_H            (DOWNLOAD_MIN_GLYPH_ID + 256 - 1)
#define DOWNLOAD_MAX_FONTS                24
#define    DOWNLOAD_MAX_HEIGHT                600        // in 600 dpi

#define    MAX_PALETTE_SIZE                16        // maximum of programmable palettes

#define MASTER_X_UNIT                    1200
#define MASTER_Y_UNIT                    1200
#define MIN_X_UNIT_DIV                    2        // 600 dpi
#define MIN_Y_UNIT_DIV                    2        // 600 dpi

#define VERT_PRINT_REL_X                125
#define VERT_PRINT_REL_Y                125

// Make acess to the 2 byte character in a RISC portable manner.
// Note we treat the 2 byte data as BIG-endian short ingeger for
// convenience.

#define SWAPW(x) \
    ((WORD)(((WORD)(x) << 8) | ((WORD)(x) >> 8)))
#define GETWORD(p) \
    ((WORD)(((WORD)(*((PBYTE)(p))) << 8) + *((PBYTE)(p) + 1)))
#define PUTWORD(p,w) \
    (*((PBYTE)(p)) = HIBYTE(w), *((PBYTE)(p) + 1) = LOBYTE(w))
#define PUTWORDINDIRECT(p,pw) \
    (*((PBYTE)(p)) = *((PBYTE)(pw) + 1), *((PBYTE)(p) + 1) = *((PBYTE)(pw)))

#define WRITESPOOLBUF(p,s,n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf((p),(s),(n)))

// Internal Locale ID
#define LCID_JPN            0x00000000    // Japan; default
#define LCID_CHT            0x00010000    // Taiwan (ChineseTraditional)
#define LCID_CHS            0x00020000    // PRC (ChineseSimplified)
#define LCID_KOR            0x00030000    // Korea
#define LCID_USA            0x01000000    // US

// OEMCommandCallback callback function ordinal
#define    SET_LCID                    10                // ()
#define    SET_LCID_J                    (10 + LCID_JPN)    // ()
#define    SET_LCID_C                    (10 + LCID_CHT)    // ()
#define    SET_LCID_K                    (10 + LCID_CHS)    // ()
#define    SET_LCID_H                    (10 + LCID_KOR)    // ()
#define    SET_LCID_U                    (10 + LCID_USA)    // ()

#ifdef    DUMPRASTER
#define XMOVE_ABS                    11                // (DestX)
#define XMOVE_REL_RT                12                // (DestXRel)
#define XMOVE_REL_LF                13                // (DestXRel)
#define YMOVE_ABS                    14                // (DestY)
#define YMOVE_REL_DN                15                // (DestYRel)
#define YMOVE_REL_UP                16                // (DestYRel)
#endif

#define TEXT_PRN_DIRECTION            20                // (PrintDirInCCDegrees)
#define TEXT_SINGLE_BYTE            21                // (FontBold,FontItalic)
#define TEXT_DOUBLE_BYTE            22                // (FontBold,FontItalic)
#define TEXT_BOLD                    23                // (FontBold)
#define TEXT_ITALIC                    24                // (FontItalic)
#define TEXT_HORIZONTAL                25                // ()
#define TEXT_VERTICAL                26                // ()
#define TEXT_NO_VPADJUST            27                // ()

#define DOWNLOAD_SELECT_FONT_ID        30                // (CurrentFontID)
#define DOWNLOAD_DELETE_FONT        31                // (CurrentFontID)
#define DOWNLOAD_DELETE_ALLFONT        32                // ()
#define DOWNLOAD_SET_FONT_ID        33                // (CurrentFontID)
#define DOWNLOAD_SET_CHAR_CODE        34                // (NextGlyph)

#define SEND_BLOCK_DATA                40                // (NumOfDataBytes,RasterDataWidthInBytes,RasterDataHeightInPixels)
#define SET_SRC_BMP_WIDTH            41                // (RasterDataWidthInBytes)
#define SET_SRC_BMP_HEIGHT            42                // (RasterDataHeightInPixels)
#define    DEFINE_PALETTE_ENTRY        43                // (PaletteIndexToProgram,RedValue,GreenValue,BlueValue)
#define    SELECT_PALETTE_ENTRY        44                // (CurrentPaletteIndex)
#define    SET_RECT_WIDTH                45                // (RectXSize)
#define    SET_RECT_HEIGHT                46                // (RectYSize)

#define COMPRESS_OFF                50                // ()
#define COMPRESS_ON                    51                // ()

//
// ---- S T R U C T U R E  D E F I N E ----
//
typedef struct tagHEIGHTLIST {
    short   id;            // DWORD aligned for access optimization
    WORD    Height;
    WORD    fGeneral;    // DWORD aligned for access optimization
    WORD    Width;
} HEIGHTLIST, *LPHEIGHTLIST;

typedef    struct _PALETTE {
    BYTE    Red;
    BYTE    Green;
    BYTE    Blue;
    BYTE    Reserved;
} PALETTE, *LPPALETTE;

typedef struct tagEPAGEMDV {
    WORD    fGeneral;
    WORD    wListNum;
    HEIGHTLIST HeightL[DOWNLOAD_MAX_FONTS];
    DWORD    dwTextYRes;
    DWORD    dwTextXRes;
    DWORD    dwLCID;
    DWORD    dwMemAvailable;
    DWORD    dwMaxGlyph;
    DWORD    dwNextGlyph;
    int        iParamForFSweF;
    int        iCurrentDLFontID;
    int        iDevCharOffset;
    int        iSBCSX;
    int        iDBCSX;
    int        iSBCSXMove;
    int        iSBCSYMove;
    int        iDBCSXMove;
    int        iDBCSYMove;
    int        iEscapement;
    // for ESC/Page-Color
    DWORD   dwWidthBytes;
    DWORD   dwHeightPixels;
    PALETTE    Palette[MAX_PALETTE_SIZE];
#ifdef    DUMPRASTER
    // for DEBUG
    HANDLE  hDump;
    DWORD   xCurPos;
    DWORD   yCurPos;
#endif    // DUMPRASTER
} EPAGEMDV, *LPEPAGEMDV;

// fGeneral flags
#define FLAG_DBCS        0x0001
#define FLAG_VERT        0x0002
#define FLAG_PROP        0x0004
#define FLAG_DOUBLE      0x0008
#define FLAG_VERTPRN     0x0010
#define FLAG_NOVPADJ     0x0020
//
#define FLAG_COMPRESS    0x0100
// DEBUG
#ifdef    DBGMSGBOX
#define    FLAG_SKIPMSG     0x8000
#endif
// DEBUG

typedef struct {
    BYTE bFormat;
    BYTE bDataDir;
    WORD wCharCode;
    WORD wBitmapWidth;
    WORD wBitmapHeight;
    WORD wLeftOffset;
    WORD wAscent;
    DWORD CharWidth;
} ESCPAGECHAR;

typedef struct {
   WORD Integer;
   WORD Fraction;
} FRAC;

typedef struct {
   WORD wFormatType;
   WORD wDataSize;
   WORD wSymbolSet;
   WORD wCharSpace;
   FRAC CharWidth;
   FRAC CharHeight;
   WORD wFontID;
   WORD wWeight;  // Line Width
   WORD wEscapement;  // Rotation
   WORD wItalic;  // Slant
   WORD wLast;
   WORD wFirst;
   WORD wUnderline;
   WORD wUnderlineWidth;
   WORD wOverline;
   WORD wOverlineWidth;
   WORD wStrikeOut;
   WORD wStrikeOutWidth;
   WORD wCellWidth;
   WORD wCellHeight;
   WORD wCellLeftOffset;
   WORD wCellAscender;
   FRAC FixPitchWidth;
} ESCPAGEHEADER, *LPESCPAGEHEADER;

//
// ----- S T A T I C  D A T A ---
//
const int ESin[4] = { 0, 1, 0, -1 };
const int ECos[4] = { 1, 0, -1, 0 };

const char DLI_DNLD_HDR[]        = "\x1D%d;%ddh{F";
const char DLI_SELECT_FONT_ID[]    = "\x1D%ddcF\x1D" "0;0coP";
const char DLI_DELETE_FONT[]    = "\x1D%dddcF";
const char DLI_FONTNAME[]        = "________________________EPSON_ESC_PAGE_DOWNLOAD_FONT%02d";
const char DLI_SYMBOLSET[]        = "ESC_PAGE_DOWNLOAD_FONT_INDEX";
#define SYMBOLSET_LEN (sizeof(DLI_SYMBOLSET) - 1)    // adjust for terminating NULL
const char DLI_DNLD1CHAR_H[]    = "\x1D%d;";
const char DLI_DNLD1CHAR_P[]    = "%d;";
const char DLI_DNLD1CHAR_F[]    = "%dsc{F";

const char SET_SINGLE_BYTE[]    = "\x1D" "1;0mcF\x1D%d;%dpP";
const char SET_DOUBLE_BYTE[]    = "\x1D" "1;1mcF\x1D%d;%dpP";
const char CHAR_PITCH[]            = "\x1D" "0spF\x1D%d;%dpP";
const char PRNDIR_POSMOV[]        = "\x1D%dpmP";
const char PRN_DIRECTION[]        = "\x1D%droF";
const char SET_CHAR_OFFSET[]    = "\x1D" "0;%dcoP";
const char SET_CHAR_OFFSET_S[]    = "\x1D" "0;%scoP";
const char SET_CHAR_OFFSET_XY[]    = "\x1D%d;%dcoP";
const char SET_VERT_PRINT[]        = "\x1D%dvpC";

const char SET_BOLD[]            = "\x1D%dweF";
const char SET_ITALIC[]            = "\x1D%dslF";

const char SET_REL_X[]            = "\x1D%dH";
const char SET_REL_Y[]            = "\x1D%dV";
#ifdef    DUMPRASTER
const char SET_ABS_X[]            = "\x1D%dX";
const char SET_ABS_Y[]            = "\x1D%dY";
#endif    // DUMPRASTER

const char START_COLOR_IMAGE[]    = "\x1D" "2;102;0;%d;%d;%d;%d;%d;0scrI";
const char DRAW_COLOR_IMAGE[]    = "\x1D%d;%dcr{I";
const char DRAW_COLOR_IMAGE_NOCOMP[]    = "\x1D%d;%dcu{I";

const char SELECT_PALETTE[]        = "\x1D" "1;2;3;%d;%d;%dfpE" "\x1D" "1;2;1cpE";

//
// ---- C O M P R E S S I O N   L I B R A R Y ----
//
#include "comp.c"

//
// ---- I N T E R N A L  F U N C T I O N  P R O T O T Y P E ----
//
BOOL PASCAL BInsertHeightList(LPEPAGEMDV lpEpage, int id, WORD wHeight, WORD wWidth, BYTE fProp, BYTE fDBCS);
int PASCAL IGetHLIndex(LPEPAGEMDV lpEpage, int id);
//BYTE PASCAL BTGetProp(LPEPAGEMDV lpEpage, int id);
//BYTE PASCAL BTGetDBCS(LPEPAGEMDV lpEpage, int id);
//WORD PASCAL WGetWidth(LPEPAGEMDV lpEpage, int id);
//WORD PASCAL WGetHeight(LPEPAGEMDV lpEpage, int id);
LONG LConvertFontSizeToStr(LONG  size, PSTR  pStr);
WORD WConvDBCSCharCode(WORD cc, DWORD LCID);
BOOL BConvPrint(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph);
DWORD CheckAvailableMem(LPEPAGEMDV lpEpage, PUNIFONTOBJ pUFObj);
// DEBUG
#ifdef    DBGMSGBOX
int DbgMsg(LPEPAGEMDV lpEpage, UINT mbicon, LPCTSTR msgfmt, ...);
int MsgBox(LPEPAGEMDV lpEpage, LPCTSTR msg, UINT mbicon);
#endif
// DEBUG

//
// ---- F U N C T I O N S ----
//
//////////////////////////////////////////////////////////////////////////
//  Function:   OEMEnablePDEV
//
//  Description:  OEM callback for DrvEnablePDEV;
//                  allocate OEM specific memory block
//
//  Parameters:
//
//        pdevobj            Pointer to the DEVOBJ. pdevobj->pdevOEM is undefined.
//        pPrinterName    name of the current printer.
//        cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo:
//                        These parameters are identical to what's passed
//                        into DrvEnablePDEV.
//        pded            points to a function table which contains the
//                        system driver's implementation of DDI entrypoints.
//
//  Returns:
//        Pointer to the PDEVOEM
//
//  Comments:
//
//
//  History:
//          07/15/97        Created. Epson
//
//////////////////////////////////////////////////////////////////////////

PDEVOEM APIENTRY OEMEnablePDEV(PDEVOBJ pdevobj, PWSTR pPrinterName, ULONG cPatterns, HSURF* phsurfPatterns, ULONG cjGdiInfo, GDIINFO* pGdiInfo, ULONG cjDevInfo, DEVINFO* pDevInfo, DRVENABLEDATA * pded)
{
    // allocate private data structure
    LPEPAGEMDV lpEpage = MemAllocZ(sizeof(EPAGEMDV));
    if (lpEpage)
    {
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMEnablePDEV() entry. PDEVOEM = %x, ulAspectX = %d, ulAspectY = %d\r\n"),
//            lpEpage, pGdiInfo->ulAspectX, pGdiInfo->ulAspectX));
// DEBUG
#ifdef    DBGMSGBOX
#if    DBGMSGBOX == 2
DbgMsg(lpEpage, MB_OK, L"OEMEnablePDEV() entry. PDEVOEM = %x, ulAspectX = %d, ulAspectY = %d\r\n",
        lpEpage, pGdiInfo->ulAspectX, pGdiInfo->ulAspectX);
#endif
#endif
#ifdef    DUMPRASTER
lpEpage->hDump =
#ifdef    DBGMSGBOX
(DbgMsg(lpEpage, MB_ICONQUESTION, L"Creating RasterView data file c:\\epagcres.dmp...\r\n")
                    == IDOK) ?
#endif
                    CreateFile(L"c:\\epagcres.dmp", GENERIC_WRITE, 0, NULL,
                                CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)
#ifdef    DBGMSGBOX
                    : INVALID_HANDLE_VALUE
#endif
                    ;
if (lpEpage->hDump != INVALID_HANDLE_VALUE)
{
    DWORD cb;
    WriteFile(lpEpage->hDump, &cjGdiInfo, 4, &cb, NULL);
    WriteFile(lpEpage->hDump, pGdiInfo, cjGdiInfo, &cb, NULL);
}
#endif    // #ifdef    DUMPRASTER
// DEBUG
        // save text resolution
        lpEpage->dwTextYRes = pGdiInfo->ulAspectY;
        lpEpage->dwTextXRes = pGdiInfo->ulAspectX;
        // save pointer to the data structure
        pdevobj->pdevOEM = (PDEVOEM)lpEpage;
    }
    return (PDEVOEM)lpEpage;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDisablePDEV
//
//  Description:  OEM callback for DrvDisablePDEV;
//                  free all allocated OEM specific memory block(s)
//
//  Parameters:
//
//        pdevobj            Pointer to the DEVOBJ.
//
//  Returns:
//        None
//
//  Comments:
//
//
//  History:
//          07/15/97        Created. Epson
//
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY OEMDisablePDEV(PDEVOBJ pdevobj)
{
    LPEPAGEMDV lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMDisablePDEV() entry. PDEVOEM = %x\r\n"), lpEpage));
    if (lpEpage)
    {
// DEBUG
#ifdef    DUMPRASTER
if (lpEpage->hDump != INVALID_HANDLE_VALUE)
    CloseHandle(lpEpage->hDump);
#endif
// DEBUG
        // free private data structure
        MemFree(lpEpage);
        pdevobj->pdevOEM = NULL;
    }
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    LPEPAGEMDV lpEpageOld, lpEpageNew;

    lpEpageOld = (LPEPAGEMDV)pdevobjOld->pdevOEM;
    lpEpageNew = (LPEPAGEMDV)pdevobjNew->pdevOEM;

    if (lpEpageOld != NULL && lpEpageNew != NULL)
        *lpEpageNew = *lpEpageOld;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMCommandCallback
//
//  Description:  process Command Callback specified by GPD file
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//        dwCmdCbID    CallbackID specified in GPD file
//        dwCount        Parameter count
//        pdwParams    Pointer to the parameters
//
//
//  Returns:
//
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

INT APIENTRY OEMCommandCallback(PDEVOBJ pdevobj, DWORD dwCmdCbID, DWORD dwCount, PDWORD pdwParams)
{
    LPEPAGEMDV    lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    INT            i, cbCmd;
    int            id;
    int            hlx;
    BYTE        Cmd[256];

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,%d,%d,) entry.\r\n"), dwCmdCbID, dwCount));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    cbCmd = 0;
    switch (dwCmdCbID & 0xFFFF)
    {
    case  SET_LCID: // 10:()
        // set LCID for this job
        lpEpage->dwLCID = dwCmdCbID & 0xFFFF0000;
        break;

#ifdef    DUMPRASTER
    case XMOVE_ABS:    // 11:(DestX)
        if (dwCount >= 1)
        {
            lpEpage->xCurPos = pdwParams[0] / 2;
            cbCmd = sprintf(Cmd, SET_ABS_X, lpEpage->xCurPos);
        }
        break;
    case XMOVE_REL_RT:    // 12:(DestXRel)
        if (dwCount >= 1)
        {
            lpEpage->xCurPos += pdwParams[0] / 2;
            cbCmd = sprintf(Cmd, SET_REL_X, pdwParams[0] / 2);
        }
        break;
    case XMOVE_REL_LF:    // 13:(DestXRel)
        if (dwCount >= 1)
        {
            lpEpage->xCurPos -= pdwParams[0] / 2;
            cbCmd = sprintf(Cmd, SET_REL_X, -(LONG)(pdwParams[0] / 2));
        }
        break;
    case YMOVE_ABS:    // 14:(DestY)
        if (dwCount >= 1)
        {
            lpEpage->yCurPos = pdwParams[0] / 2;
            cbCmd = sprintf(Cmd, SET_ABS_Y, lpEpage->yCurPos);
        }
        break;
    case YMOVE_REL_DN:    // 15:(DestYRel)
        if (dwCount >= 1)
        {
            lpEpage->yCurPos += pdwParams[0] / 2;
            cbCmd = sprintf(Cmd, SET_REL_Y, pdwParams[0] / 2);
        }
        break;
    case YMOVE_REL_UP:    // 16:(DestYRel)
        if (dwCount >= 1)
        {
            lpEpage->yCurPos -= pdwParams[0] / 2;
            cbCmd = sprintf(Cmd, SET_REL_Y, -(LONG)(pdwParams[0] / 2));
        }
        break;
#endif

    case  TEXT_PRN_DIRECTION: // 20:(PrintDirInCCDegrees)
        if (dwCount >= 1)
        {
            int   iEsc90;

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_PRN_DIRECTION,%d,[%d]) entry.\r\n"), dwCount, *pdwParams));

            lpEpage->iEscapement = (int)*pdwParams;
            iEsc90 = lpEpage->iEscapement/90;

            cbCmd = sprintf(Cmd, PRNDIR_POSMOV, iEsc90 ? 1 : 0);

            lpEpage->iSBCSXMove =  lpEpage->iSBCSX * ECos[iEsc90];
            lpEpage->iSBCSYMove = -lpEpage->iSBCSX * ESin[iEsc90];
            if (lpEpage->fGeneral & FLAG_DBCS)
            {
                lpEpage->iDBCSXMove = lpEpage->iDBCSX * ECos[iEsc90];
                lpEpage->iDBCSYMove = -lpEpage->iDBCSX * ESin[iEsc90];
                cbCmd += sprintf(&Cmd[cbCmd], SET_CHAR_OFFSET_XY,
                                 lpEpage->iDevCharOffset * ESin[iEsc90],
                                 lpEpage->iDevCharOffset * ECos[iEsc90]);
            }
            else if (lpEpage->iCurrentDLFontID > 0 && lpEpage->iEscapement)
            {
                WORD wHeight;
                short sXMove, sYMove;
                hlx = IGetHLIndex(lpEpage, lpEpage->iCurrentDLFontID);
                wHeight = (hlx >= 0) ? lpEpage->HeightL[hlx].Height : 0;
                sXMove = -(short)wHeight * ESin[iEsc90];
                sYMove = -(short)wHeight * ECos[iEsc90];
                cbCmd += sprintf(&Cmd[cbCmd], SET_CHAR_OFFSET_XY, sXMove, sYMove);

            }
            else
            {
                cbCmd += sprintf(&Cmd[cbCmd], SET_CHAR_OFFSET, 0);
            }

            if (!(lpEpage->fGeneral & (FLAG_DBCS | FLAG_PROP)) ||
                ((lpEpage->fGeneral & FLAG_DBCS) &&
                 !(lpEpage->fGeneral & FLAG_DOUBLE)))
            {
                cbCmd += sprintf(&Cmd[cbCmd], CHAR_PITCH,
                                 lpEpage->iSBCSXMove, lpEpage->iSBCSYMove);
            }
            else if ((FLAG_DBCS | FLAG_DOUBLE) ==
                     (lpEpage->fGeneral & (FLAG_DBCS | FLAG_DOUBLE)))
            {
                cbCmd += sprintf(&Cmd[cbCmd], CHAR_PITCH,
                                 lpEpage->iDBCSXMove, lpEpage->iDBCSYMove);
            }
            cbCmd += sprintf(&Cmd[cbCmd], PRN_DIRECTION, lpEpage->iEscapement);
        }
        break;

    case TEXT_SINGLE_BYTE: // 21:(FontBold,FontItalic)
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_SINGLE_BYTE,%d,) entry.\r\n"), dwCount));
        cbCmd = sprintf(Cmd, SET_SINGLE_BYTE,
                        lpEpage->iSBCSXMove, lpEpage->iSBCSYMove);
        cbCmd += sprintf(&Cmd[cbCmd], PRN_DIRECTION, lpEpage->iEscapement);
        if (lpEpage->fGeneral & FLAG_VERT)
        {
            cbCmd += sprintf(&Cmd[cbCmd], SET_VERT_PRINT, 0);
        }
        lpEpage->fGeneral &= ~FLAG_DOUBLE;
        goto SetBoldItalic;

    case TEXT_DOUBLE_BYTE: // 22:(FontBold,FontItalic)
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_DOUBLE_BYTE,%d,) entry.\r\n"), dwCount));
        cbCmd = sprintf(Cmd, SET_DOUBLE_BYTE,
                        lpEpage->iDBCSXMove, lpEpage->iDBCSYMove);
        cbCmd += sprintf(&Cmd[cbCmd], PRN_DIRECTION, lpEpage->iEscapement);
        if (lpEpage->fGeneral & FLAG_VERT)
        {
            cbCmd += sprintf(&Cmd[cbCmd], SET_VERT_PRINT, 1);
        }
        lpEpage->fGeneral |= FLAG_DOUBLE;
SetBoldItalic:
        if (dwCount >= 2)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("  Bold = %d, Italic = %d\r\n"), pdwParams[0], pdwParams[1]));
            cbCmd += sprintf(&Cmd[cbCmd], SET_BOLD,
                             pdwParams[0] ? lpEpage->iParamForFSweF + 3 :
                                            lpEpage->iParamForFSweF);
            cbCmd += sprintf(&Cmd[cbCmd], SET_ITALIC,
                             pdwParams[1] ? 346 : 0);
        }
        break;

    case TEXT_BOLD: // 23:(FontBold)
        if (dwCount >= 1)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_BOLD,%d,%d) entry.\r\n"), dwCount, *pdwParams));
            cbCmd += sprintf(&Cmd[cbCmd], SET_BOLD,
                             (*pdwParams) ? lpEpage->iParamForFSweF + 3 :
                                            lpEpage->iParamForFSweF);
        }
        break;

    case TEXT_ITALIC: // 24:(FontItalic)
        if (dwCount >= 1)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_ITALIC,%d,%d) entry.\r\n"), dwCount, *pdwParams));
            cbCmd += sprintf(&Cmd[cbCmd], SET_ITALIC, (*pdwParams) ? 346 : 0);
        }
        break;

    case TEXT_HORIZONTAL: // 25:()
// DEBUG
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_OK, L"VertPrn = Off");
#endif
// DEBUG
        cbCmd = sprintf(Cmd, SET_VERT_PRINT, 0);
        lpEpage->fGeneral &= ~FLAG_VERTPRN;
        break;

    case TEXT_VERTICAL: // 26:()
// DEBUG
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_OK, L"VertPrn = On");
#endif
// DEBUG
        cbCmd = sprintf(Cmd, SET_VERT_PRINT, 1);
        lpEpage->fGeneral |= FLAG_VERTPRN;
        break;

    case TEXT_NO_VPADJUST:    // 27:()
        lpEpage->fGeneral |= FLAG_NOVPADJ;
        break;

    case DOWNLOAD_SELECT_FONT_ID: // 30:(CurrentFontID)
        if (dwCount >= 1)
        {
            id = (int)*pdwParams;
            // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET if needed
            if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
            {
                id -= DOWNLOAD_NO_DBCS_OFFSET;
            }
            hlx = IGetHLIndex(lpEpage, id);
            if (hlx >= 0)
            {    // FontID registered
// DBGPRINT(DBG_WARNING, (DLLTEXT("DOWNLOAD_SELECT_FONT_ID:FontID=%d\r\n"), id));
                lpEpage->iCurrentDLFontID = id;
                lpEpage->fGeneral &= ~(FLAG_DBCS | FLAG_VERT | FLAG_DOUBLE);
                if (lpEpage->HeightL[hlx].fGeneral & FLAG_PROP)
                    lpEpage->fGeneral |= FLAG_PROP;
                else
                    lpEpage->fGeneral &= ~FLAG_PROP;
                lpEpage->iParamForFSweF = 0;
                lpEpage->iSBCSX = lpEpage->HeightL[hlx].Width;
                lpEpage->iDBCSX = 0;
                cbCmd = sprintf(Cmd, DLI_SELECT_FONT_ID, id - DOWNLOAD_MIN_FONT_ID);
            }
        }
        break;

    case DOWNLOAD_DELETE_FONT:    // 31:(CurrentFontID)
        if (dwCount >= 1)
        {
            id = (int)*pdwParams;
            // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET if needed
            if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
            {
                id -= DOWNLOAD_NO_DBCS_OFFSET;
            }
            hlx = IGetHLIndex(lpEpage, id);
            if (hlx >= 0)
            {    // FontID registered
                // set up font delete command
                cbCmd = sprintf(Cmd, DLI_DELETE_FONT, id - DOWNLOAD_MIN_FONT_ID);
                // move HeightList table contents
                for (i = hlx; i + 1 < lpEpage->wListNum; i++)
                {
                    lpEpage->HeightL[i].id = lpEpage->HeightL[i + 1].id;
                    lpEpage->HeightL[i].fGeneral = lpEpage->HeightL[i + 1].fGeneral;
                    lpEpage->HeightL[i].Height = lpEpage->HeightL[i + 1].Height;
                    lpEpage->HeightL[i].Width = lpEpage->HeightL[i + 1].Width;
                }
                // decrease the total number
                lpEpage->wListNum--;
            }
        }
        break;

    case DOWNLOAD_DELETE_ALLFONT: // 32:()
        for (i = 0; i < (int)lpEpage->wListNum ; i++)
        {
            cbCmd += sprintf(&Cmd[cbCmd], DLI_DELETE_FONT,
                               (WORD)lpEpage->HeightL[i].id - DOWNLOAD_MIN_FONT_ID);
            lpEpage->HeightL[i].id = 0;
        }
        lpEpage->wListNum = 0;
        break;

    case DOWNLOAD_SET_FONT_ID:        // 33:(CurrentFontID)
        if (dwCount >= 1)
        {
            id = (int)*pdwParams;
            // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET if needed
            if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
            {
                id -= DOWNLOAD_NO_DBCS_OFFSET;
            }
            hlx = IGetHLIndex(lpEpage, id);
            if (hlx >= 0 && lpEpage->iCurrentDLFontID != id)
            {    // FontID registered && not active
// DBGPRINT(DBG_WARNING, (DLLTEXT("DOWNLOAD_SET_FONT_ID:FontID=%d\r\n"), id));
                cbCmd = sprintf(Cmd, DLI_SELECT_FONT_ID, id - DOWNLOAD_MIN_FONT_ID);
                lpEpage->iParamForFSweF = 0;
                lpEpage->iCurrentDLFontID = id;
            }
        }
        break;

    case DOWNLOAD_SET_CHAR_CODE:    // 34:(NextGlyph)
        if (dwCount >= 1)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("DOWNLOAD_SET_CHAR_CODE:NextGlyph=%Xh\r\n"), pdwParams[0]));
            // save next glyph
            lpEpage->dwNextGlyph = pdwParams[0];
        }
        break;

    case SEND_BLOCK_DATA:    // 40:(NumOfDataBytes,RasterDataWidthInBytes,RasterDataHeightInPixels)
        if (dwCount >= 1)
        {
            DWORD srcWidth, srcHeight, dstWidth, dstHeight;
            // get image size
            srcWidth = dstWidth = lpEpage->dwWidthBytes / 3;
            srcHeight = dstHeight = lpEpage->dwHeightPixels;
// DBGPRINT(DBG_WARNING, (DLLTEXT("SEND_BLOCK_DATA(%ld), srcWidth=%ld, srcHeight=%ld\r\n"), pdwParams[0], srcWidth, srcHeight));
#ifdef    DBGMSGBOX
#if    DBGMSGBOX == 2
DbgMsg(lpEpage, MB_OK, L"SEND_BLOCK_DATA(%ld,%ld,%ld), srcWidth=%ld, srcHeight=%ld\r\n",
        pdwParams[0], pdwParams[1], pdwParams[2], srcWidth, srcHeight);
#endif
#endif
            if (lpEpage->dwTextXRes == 300)
                dstWidth *= 2;
            if (lpEpage->dwTextYRes == 300)
                dstHeight *= 2;
            cbCmd = sprintf(Cmd, START_COLOR_IMAGE,
                            (lpEpage->fGeneral & FLAG_COMPRESS) ? 20 : 0,
                            srcWidth, srcHeight,
                            dstWidth, dstHeight);
            cbCmd += sprintf(&Cmd[cbCmd],
                             (lpEpage->fGeneral & FLAG_COMPRESS) ?
                              DRAW_COLOR_IMAGE : DRAW_COLOR_IMAGE_NOCOMP,
                             pdwParams[0], srcHeight);
        }
        break;

    case SET_SRC_BMP_WIDTH:    // 41:(RasterDataWidthInBytes)
        if (dwCount >= 1)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("SET_SRC_BMP_WIDTH(%ld)\r\n"), pdwParams[0]));
#ifdef    DBGMSGBOX
if (pdwParams[0] % 3)
DbgMsg(lpEpage, MB_ICONEXCLAMATION, L"Invalid RasterDataWidthInBytes for SET_SRC_BMP_WIDTH(%ld)", pdwParams[0]);
#if    DBGMSGBOX == 2
else
DbgMsg(lpEpage, MB_OK, L"SET_SRC_BMP_WIDTH(%ld)", pdwParams[0]);
#endif
#endif
            // save raster data width in bytes
            lpEpage->dwWidthBytes = pdwParams[0];
        }
        break;

    case SET_SRC_BMP_HEIGHT:    // 42:(RasterDataHeightInPixels)
        if (dwCount >= 1)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("SET_SRC_BMP_HEIGHT(%ld)\r\n"), pdwParams[0]));
#ifdef    DBGMSGBOX
#if    DBGMSGBOX == 2
DbgMsg(lpEpage, MB_OK, L"SET_SRC_BMP_HEIGHT(%ld)", pdwParams[0]);
#endif
#endif
            // save raster data height in pixels
            lpEpage->dwHeightPixels = pdwParams[0];
        }
        break;


    case DEFINE_PALETTE_ENTRY:    // 43:(PaletteIndexToProgram,RedValue,GreenValue,BlueValue)
        if (dwCount >= 4)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("DEFINE_PALETTE_ENTRY(%ld,%ld,%ld,%ld)\r\n"),
//                        pdwParams[0], pdwParams[1], pdwParams[2], pdwParams[3]));
            // save palette definition for later use
            if (pdwParams[0] < MAX_PALETTE_SIZE)
            {
                lpEpage->Palette[pdwParams[0]].Red = (BYTE)pdwParams[1];
                lpEpage->Palette[pdwParams[0]].Green = (BYTE)pdwParams[2];
                lpEpage->Palette[pdwParams[0]].Blue = (BYTE)pdwParams[3];
            }
            else
            {
                ERR(("Too large palette index(%ld,%ld,%ld,%ld)\r\n", pdwParams[0], pdwParams[1], pdwParams[2], pdwParams[3]));
            }
        }
        break;

    case SELECT_PALETTE_ENTRY:    // 44:(CurrentPaletteIndex)
        if (dwCount >= 1)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("SELECT_PALETTE_ENTRY(%ld)\r\n"), pdwParams[0]));
#ifdef    DBGMSGBOX
#if    DBGMSGBOX == 2
DbgMsg(lpEpage, MB_OK, L"SELECT_PALETTE_ENTRY(%ld)", pdwParams[0]);
#endif
#endif
            // select palette
            cbCmd = sprintf(Cmd, SELECT_PALETTE,
                            lpEpage->Palette[pdwParams[0]].Red,
                            lpEpage->Palette[pdwParams[0]].Green,
                            lpEpage->Palette[pdwParams[0]].Blue);
        }
        break;

    case COMPRESS_OFF:    // 50:()
// DBGPRINT(DBG_WARNING, (DLLTEXT("COMPRESS_OFF\r\n")));
#ifdef    DBGMSGBOX
#if    DBGMSGBOX == 2
DbgMsg(lpEpage, MB_OK, L"COMPRESS_OFF");
#endif
#endif
        lpEpage->fGeneral &= ~FLAG_COMPRESS;
        break;

    case COMPRESS_ON:    // 51:()
// DBGPRINT(DBG_WARNING, (DLLTEXT("COMPRESS_ON\r\n")));
#ifdef    DBGMSGBOX
#if    DBGMSGBOX == 2
DbgMsg(lpEpage, MB_OK, L"COMPRESS_ON");
#endif
#endif
        lpEpage->fGeneral |= FLAG_COMPRESS;
        break;

    default:
        ERR(("Unexpected OEMCommandCallback(,%d,%d,%.8lX)\r\n", dwCmdCbID, dwCount, pdwParams));
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_ICONEXCLAMATION, L"Unexpected OEMCommandCallback(,%d,%d,%.8lX)", dwCmdCbID, dwCount, pdwParams);
#endif
        break;
    }
    if (cbCmd)
    {
        WRITESPOOLBUF(pdevobj, Cmd, cbCmd);
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////
//    Function:   OEMCompression
//
//    Description:  Compress the data stream
//
//    Parameters:
//        pdevobj        Pointer to the DEVOBJ.
//        pInBuf         Pointer to raster data to compress
//        pOutBuf        Pointer to output buffer for compressed data
//        dwInLen        size of input data to compress
//        dwOutLen    size of output buffer in bytes
//
//    Returns:
//        the number of compressed bytes created if successful
//        otherwise -1 if unable to compress the data within the specified buffer.
//
//    Remarks:
//        If the Compression callback is provided by the OEM DLL and the
//        CmdEnableOEMComp command is defined in the GPD, the callback will
//        be used to compress the next block of data.
//        The relative size of the newly compressed data will be compared to
//        any other enabled unidrv compression modes to determine the most
//        efficient compression algorithm for this block of data.
//        If it results in the smallest size, unidrv will send the
//        CmdEnableOEMComp command followed by the data.
//        The OEM function only compresses and returns the data and is not
//        responsible for any output.
//        Unidrv will provide a buffer in which to compress the data.
//        The size of this buffer will be specified and may represent the size
//        of best compression algorithm checked so far.
//        In this way an early out algorithm can be used to stop compressing
//        if it isn't going to result in smaller output.
//        The Compression callback can be used to implement a special compression
//        method that may or may not be more efficient than existing unidrv
//        compression modes thus allowing the best method to be utilized.
//        Since there is some overhead involved with compressing the data the OEM
//        should only enable those compression methods most likely to yield the
//        best results.
//        To utilize this callback the device must be able to switch compression
//        modes and support disabled compression on a per scan line basis.
//
INT APIENTRY OEMCompression(PDEVOBJ pdevobj, PBYTE pInBuf, PBYTE pOutBuf, DWORD dwInLen, DWORD dwOutLen)
{
    INT Result = dwOutLen;
    LPEPAGEMDV lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    if (lpEpage->dwWidthBytes == 0 ||
        (Result = Compress20(pInBuf, dwInLen, lpEpage->dwWidthBytes, pOutBuf, dwOutLen))
        == 0)
    {
        Result = -1;
    }
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCompression(,,,%ld,%ld)=%ld\r\n"), dwInLen, dwOutLen, Result));
// DEBUG
#ifdef    DBGMSGBOX
#if    DBGMSGBOX == 2
DbgMsg(lpEpage, (Result != -1) ? MB_OK : MB_ICONEXCLAMATION,
       L"OEMCompression(..)[%ld/%ld,%ld]->%ld", dwInLen, lpEpage->dwWidthBytes, dwOutLen, Result);
#endif
#endif
#ifdef    DUMPRASTER
if (lpEpage->hDump != INVALID_HANDLE_VALUE)
{
    DWORD cb, len;
    len = sizeof (DWORD) * 3;
    WriteFile(lpEpage->hDump, &len, 4, &cb, NULL);
    WriteFile(lpEpage->hDump, &lpEpage->xCurPos, 4, &cb, NULL);
    WriteFile(lpEpage->hDump, &lpEpage->yCurPos, 4, &cb, NULL);
    WriteFile(lpEpage->hDump, &lpEpage->dwWidthBytes, 4, &cb, NULL);
    WriteFile(lpEpage->hDump, &dwInLen, 4, &cb, NULL);
    WriteFile(lpEpage->hDump, pInBuf, dwInLen, &cb, NULL);
}
#endif    // #ifdef    DUMPRASTER
// DEBUG
    return Result;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadFontHeader
//
//  Description:  download font header of ESC/Page
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//
//        pUFObj        Pointer to the UNIFONTOBJ.
//
//
//  Returns:
//        required amount of memory
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY OEMDownloadFontHeader(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj)
{
    ESCPAGEHEADER FontHeader;
    BYTE Buff[56];
    int  iSizeOfBuf;
    LPEPAGEMDV lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    PIFIMETRICS pIFI = pUFObj->pIFIMetrics;
    int id = (int)(pUFObj->ulFontID);
    int idx = id - DOWNLOAD_MIN_FONT_ID;
    BYTE bPS = (BYTE)((pIFI->jWinPitchAndFamily & 0x03) == VARIABLE_PITCH);
    BYTE bDBCS = (BYTE)IS_DBCSCHARSET(pIFI->jWinCharSet);
    DWORD adwStdVariable[2 + 2 * 2];
    PGETINFO_STDVAR    pSV = (PGETINFO_STDVAR)adwStdVariable;
    DWORD height, width, dwTemp;
    DWORD MemAvailable;

    // check FontID
    if (idx < 0)
        return 0;    // error for invalid FontID
    // special check for avoiding DBCS TTF downloading
    if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
    {
        if (bDBCS)
            return 0;    // treat as error for DBCS
        // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET for SBCS
        id -= DOWNLOAD_NO_DBCS_OFFSET;
        idx -= DOWNLOAD_NO_DBCS_OFFSET;
    }

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMDownloadFontHeader(%S) entry. ulFontID=%d, bPS=%d, bDBCS=%d\r\n"),
//         ((pIFI->dpwszFaceName) ? (LPWSTR)((LPBYTE)pIFI + pIFI->dpwszFaceName) : L"?"), id, bPS, bDBCS));

    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return 0;    // error
    }
// LConvertFontSizeToStr((pSV->StdVar[0].lStdVariable * 2540L) / MASTER_Y_UNIT, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  FontHeight: %d (%s mm)\r\n"), pSV->StdVar[0].lStdVariable, Buff));
// LConvertFontSizeToStr((pSV->StdVar[1].lStdVariable * 2540L) / MASTER_X_UNIT, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  FontWidth: %d (%s mm)\r\n"), pSV->StdVar[1].lStdVariable, Buff));
    // preset character size
    // FontHeight, FontWidth set in Minimum Unit for ESC/Page
    height = pSV->StdVar[0].lStdVariable / MIN_Y_UNIT_DIV;
    width = pSV->StdVar[1].lStdVariable / MIN_X_UNIT_DIV;

    // get memory information
    MemAvailable = CheckAvailableMem(lpEpage, pUFObj);
// DBGPRINT(DBG_WARNING, (DLLTEXT("Available memory = %d bytes\r\n"), MemAvailable));
    if (MemAvailable < DOWNLOAD_HEADER_MEMUSG)
    {
        ERR(("Insufficient memory for TTF download.\r\n"));
        return 0;    // error
    }
    // set dwMaxGlyph according to the dwRemainingMemory
    if (bDBCS &&
        ((long)MemAvailable >= 256 * (long)(DOWNLOAD_FNTHDR_MEMUSG +
                                            DOWNLOAD_FONT_MEMUSG(width, height))))
    {
        switch (lpEpage->dwLCID)
        {
        case LCID_JPN:
            lpEpage->dwMaxGlyph = DOWNLOAD_MAX_GLYPH_ID_J;
            break;
        case LCID_CHS:
            lpEpage->dwMaxGlyph = DOWNLOAD_MAX_GLYPH_ID_K;
            break;
        case LCID_CHT:
            lpEpage->dwMaxGlyph = DOWNLOAD_MAX_GLYPH_ID_C;
            break;
        case LCID_KOR:
            lpEpage->dwMaxGlyph = DOWNLOAD_MAX_GLYPH_ID_H;
            break;
        }
    }
    else
        lpEpage->dwMaxGlyph = 255;

    // fill FontHeader w/ 0 to optimize setting 0s
    ZeroMemory(&FontHeader, sizeof(ESCPAGEHEADER));

    if (bPS)    // VARIABLE_PITCH
        lpEpage->fGeneral |= FLAG_PROP;
    else
        lpEpage->fGeneral &= ~FLAG_PROP;
    if (!BInsertHeightList(lpEpage, id, (WORD)height, (WORD)width, bPS, bDBCS))
    {
        ERR(("Can't register download font.\r\n"));
        return 0;    // error
    }
    lpEpage->iParamForFSweF = 0;
    lpEpage->iSBCSX = width;
    lpEpage->iDBCSX = 0;

    FontHeader.wFormatType     = SWAPW(0x0002);
    FontHeader.wDataSize       = SWAPW(FONT_HEADER_SIZE);
//
// ALWAYS PROPORTINAL SPACING REQUIRED
//
// This resolves the following problems:
//    o    The width of Half-width DBCS fonts are doubled
//    o    Fixed picth fonts are shifted gradually
//
    // proportional spacing
    FontHeader.wCharSpace         = SWAPW(1);
    FontHeader.CharWidth.Integer  = (WORD)SWAPW(0x100);
//OK    FontHeader.CharWidth.Fraction = 0;

    FontHeader.CharHeight.Integer = SWAPW(height);
//OK    FontHeader.CharHeight.Fraction = 0;
    // in the range 128 - 255
    FontHeader.wFontID         = SWAPW(idx + (idx < 0x80 ? 0x80 : 0x00));
//OK    FontHeader.wWeight         = 0;
//OK    FontHeader.wEscapement     = 0;
//OK    FontHeader.wItalic         = 0;
    if (bDBCS)
    {
        FontHeader.wSymbolSet   = SWAPW(idx + 0xC000);    // idx + C000h for DBCS
        if (lpEpage->dwLCID == LCID_KOR)
        {
            FontHeader.wFirst        = SWAPW(0xA1A1);
            FontHeader.wLast        = SWAPW(0xA3FE);    // less than or equal to 282 chars
        }
        else
        {
            FontHeader.wFirst        = SWAPW(0x2121);
            FontHeader.wLast        = SWAPW((lpEpage->dwMaxGlyph > 255) ? 0x267E : 0x237E);
        }
    }
    else
    {
        FontHeader.wSymbolSet   = SWAPW(idx + 0x4000);    // idx + 4000h for SBCS
        FontHeader.wFirst        = SWAPW(32);
        FontHeader.wLast        = SWAPW(255);
    }
//OK    FontHeader.wUnderline      = 0;
    FontHeader.wUnderlineWidth = SWAPW(10);
//OK    FontHeader.wOverline       = 0;
//OK    FontHeader.wOverlineWidth  = 0;
//OK    FontHeader.wStrikeOut      = 0;
//OK    FontHeader.wStrikeOutWidth = 0;
    FontHeader.wCellWidth      = SWAPW(width);
    FontHeader.wCellHeight     = SWAPW(height);
//OK    FontHeader.wCellLeftOffset = 0;
    dwTemp = height * pIFI->fwdWinAscender / (pIFI->fwdWinAscender + pIFI->fwdWinDescender);
    FontHeader.wCellAscender   = SWAPW(dwTemp);
    FontHeader.FixPitchWidth.Integer  = SWAPW(width);
//OK    FontHeader.FixPitchWidth.Fraction = 0;

    iSizeOfBuf = sprintf(Buff, DLI_DNLD_HDR, FONT_HEADER_SIZE, idx);
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, &FontHeader, sizeof(ESCPAGEHEADER));
    iSizeOfBuf = sprintf(Buff, DLI_FONTNAME, idx);
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, (LPBYTE)DLI_SYMBOLSET, SYMBOLSET_LEN);
    iSizeOfBuf = sprintf(Buff, DLI_SELECT_FONT_ID, idx);
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    lpEpage->iCurrentDLFontID = id;
    dwTemp = DOWNLOAD_HEADER_MEMUSG;
    // management area required for every 32 header registration
    if ((lpEpage->wListNum & 0x1F) == 0x01)
        dwTemp += DOWNLOAD_HDRTBL_MEMUSG;
    return dwTemp;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadCharGlyph
//
//  Description:  download character glyph
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//        pUFObj        Pointer to the UNIFONTOBJ.
//        hGlyph        Glyph handle to download
//        pdwWidth    Pointer to DWORD width buffer.
//                    Minidirer has to set the width of downloaded glyph data.
//
//  Returns:
//        Necessary amount of memory to download this character glyph in the printer.
//        If returning 0, UNIDRV assumes that this function failed.
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY OEMDownloadCharGlyph(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, HGLYPH hGlyph, PDWORD pdwWidth)
{
    GETINFO_GLYPHBITMAP GBmp;
    GLYPHBITS          *pgb;

    ESCPAGECHAR        ESCPageChar;
    int                iSizeOfBuf;
    int                hlx;
    DWORD            dwSize;
    LPEPAGEMDV        lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    BYTE            Buff[32];
    int                id = (int)(pUFObj->ulFontID);
    WORD            cp;
    DWORD            CharIncX;
    DWORD            dwMemUsg;
    BYTE            bDBCS;

    // check FontID
    if (id < DOWNLOAD_MIN_FONT_ID)
        return 0;    // error for invalid FontID
    // validate Download FontID
    hlx = IGetHLIndex(lpEpage, id);
    if (hlx < 0)
    {
        ERR(("Invalid Download FontID(%d).\r\n", id));
        return 0;    // error
    }
    // cache DBCS flag
    bDBCS = lpEpage->HeightL[hlx].fGeneral & FLAG_DBCS;
    // special check for avoiding DBCS TTF downloading
    if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
    {
        if (bDBCS)
            return 0;    // treat as error for DBCS
        // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET for SBCS
        id -= DOWNLOAD_NO_DBCS_OFFSET;
    }
    // check GlyphID range
    if (lpEpage->dwNextGlyph > lpEpage->dwMaxGlyph)
    {
        ERR(("No more TTF downloading allowed (GlyphID=%d).\r\n", lpEpage->dwNextGlyph));
        return 0;    // error
    }

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMDownloadCharGlyph() entry. ulFontID = %d, hGlyph = %d\r\n"), id, hGlyph));

    //
    // Get the character information.
    //
    // Get Glyph Bitmap
    GBmp.dwSize     = sizeof(GETINFO_GLYPHBITMAP);
    GBmp.hGlyph     = hGlyph;
    GBmp.pGlyphData = NULL;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp, 0, NULL))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\r\n"));
        return 0;
    }
    pgb = GBmp.pGlyphData->gdf.pgb;
    // Note that ptqD.{x|y}.HighPart is 28.4 format;
    // i.e. device coord. multiplied by 16.
    CharIncX = (GBmp.pGlyphData->ptqD.x.HighPart + 15) >> 4;
// DBGPRINT(DBG_WARNING, (DLLTEXT("Origin.x  = %d\n"), pgb->ptlOrigin.x));
// DBGPRINT(DBG_WARNING, (DLLTEXT("Origin.y  = %d\n"), pgb->ptlOrigin.y));
// DBGPRINT(DBG_WARNING, (DLLTEXT("Extent.cx = %d\n"), pgb->sizlBitmap.cx));
// DBGPRINT(DBG_WARNING, (DLLTEXT("Extent.cy = %d\n"), pgb->sizlBitmap.cy));
// DBGPRINT(DBG_WARNING, (DLLTEXT("CharInc.x = %d\n"), CharIncX));
// DBGPRINT(DBG_WARNING, (DLLTEXT("CharInc.y = %d\n"), (GBmp.pGlyphData->ptqD.y.HighPart + 15) >> 4));

    dwMemUsg = DOWNLOAD_FNTHDR_MEMUSG + DOWNLOAD_FONT_MEMUSG(CharIncX, (GBmp.pGlyphData->ptqD.y.HighPart + 15) >> 4);
    if (CheckAvailableMem(lpEpage, pUFObj) < dwMemUsg)
    {
        ERR(("Insufficient memory for OEMDownloadCharGlyph.\r\n"));
        return 0;    // error
    }

    // retrieve NextGlyph
    cp = (WORD)lpEpage->dwNextGlyph;
    // for DBCS, modify cp to printable char code
    if (bDBCS)
    {
        cp = WConvDBCSCharCode(cp, lpEpage->dwLCID);
    }

    //
    // Fill character header.
    //
    ZeroMemory(&ESCPageChar, sizeof(ESCPAGECHAR));    // Safe initial values

    // fill in the charcter header information.
    ESCPageChar.bFormat       = 0x01;
    ESCPageChar.bDataDir      = 0x10;
    ESCPageChar.wCharCode     = (bDBCS) ? SWAPW(cp) : LOBYTE(cp);
    ESCPageChar.wBitmapWidth  = SWAPW(pgb->sizlBitmap.cx);
    ESCPageChar.wBitmapHeight = SWAPW(pgb->sizlBitmap.cy);
    ESCPageChar.wLeftOffset   = SWAPW(pgb->ptlOrigin.x);
    ESCPageChar.wAscent       = SWAPW(-pgb->ptlOrigin.y);    // negate (to be positive)
    ESCPageChar.CharWidth     = MAKELONG(SWAPW(CharIncX), 0);

    dwSize = pgb->sizlBitmap.cy * ((pgb->sizlBitmap.cx + 7) >> 3);
    iSizeOfBuf = sprintf(Buff, DLI_DNLD1CHAR_H, dwSize + sizeof(ESCPAGECHAR));
    if (bDBCS)    // for DBCS, set additional high byte
        iSizeOfBuf += sprintf(&Buff[iSizeOfBuf], DLI_DNLD1CHAR_P, HIBYTE(cp));
    iSizeOfBuf += sprintf(&Buff[iSizeOfBuf], DLI_DNLD1CHAR_F, LOBYTE(cp));
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, &ESCPageChar, sizeof(ESCPAGECHAR));
    WRITESPOOLBUF(pdevobj, pgb->aj, dwSize);

    if (pdwWidth)
        *pdwWidth = CharIncX;

    return dwMemUsg;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMTTDownloadMethod
//
//  Description:  determines TT font downloading method
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//
//        pFontObj    Pointer to the FONTOBJ.
//
//
//  Returns:  TTDOWNLOAD_???? flag: one of these
//        TTDOWNLOAD_DONTCARE        Minidriver doesn't care how this font is handled.
//        TTDOWNLOAD_GRAPHICS        Minidriver prefers printing this TT font as graphics.
//        TTDOWNLOAD_BITMAP        Minidriver prefers download this TT font as bitmap soft font.
//        TTDOWNLOAD_TTOUTLINE    Minidriver prefers downloading this TT fonta as TT outline soft font. This printer must have TT rasterizer support. UNIDRV will provide pointer to the memory mapped TT file, through callback. The minidriver has to parser the TT file by itself.
//
//
//  Comments:
//        The judgement is very unreliable !!!
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY OEMTTDownloadMethod(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj)
{
    DWORD ttdlf = TTDOWNLOAD_GRAPHICS;
    LPEPAGEMDV lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    DWORD adwStdVariable[2 + 2 * 1];
    PGETINFO_STDVAR    pSV = (PGETINFO_STDVAR)adwStdVariable;

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMTTDownloadMethod entry. jWinCharSet = %d\r\n"), pUFObj->pIFIMetrics->jWinCharSet));

    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (1 - 1);
    pSV->dwNumOfVariable = 1;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL) &&
        pSV->StdVar[0].lStdVariable < DOWNLOAD_MAX_HEIGHT * MIN_Y_UNIT_DIV)
    {    // not so big font size
        ttdlf = TTDOWNLOAD_BITMAP;    // download bitmap font
    }
    else
    {
        WARNING(("OEMTTDownloadMethod returns TTDOWNLOAD_GRAPHICS. width = %d\n",
                 pSV->StdVar[0].lStdVariable));
    }
    return ttdlf;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMOutputCharStr
//
//  Description:  convert character code
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//
//        pUFObj        Pointer to the UNIFONTOBJ.
//
//        dwType        Type of pglyph string. One of following is specified by UNIDRV.
//                    TYPE_GLYPHHANDLE TYPE_GLYPHID
//
//        dwCount        Number of the glyph store in pGlyph
//
//        pGlyph        Pointer to glyph string to HGLYPH* (TYPE_GLYPHHANDLE)
//                    Glyph handle that GDI passes.
//                    DWORD* (TYPE_GLYPHID). Glyph ID that UNIDRV creates from
//                    Glyph Handle. In case of TrueType font, string type is HGLYPH*.
//                    For Device font, string type is DWORD*
//
//
//  Returns:
//        None
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY OEMOutputCharStr(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph)
{

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMOutputCharStr(,,%s,%d,) entry.\r\n")),
//         (dwType == TYPE_GLYPHHANDLE) ? "TYPE_GLYPHHANDLE" : "TYPE_GLYPHID", dwCount);

// DEBUG
// CheckAvailableMem((LPEPAGEMDV)(pdevobj->pdevOEM), pUFObj);
// DEBUG

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:
// DBGPRINT(DBG_WARNING, (DLLTEXT("dwType = TYPE_GLYPHHANDLE\n")));
// pdwGlyphID = (PDWORD)pGlyph;
// for (dwI = 0; dwI < dwCount; dwI++)
//  DBGPRINT(DBG_WARNING, (DLLTEXT("hGlyph[%d] = %x\r\n"), dwI, pdwGlyphID[dwI]));
        BConvPrint(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        break;

    case TYPE_GLYPHID:
// DBGPRINT(DBG_WARNING, (DLLTEXT("dwType = TYPE_GLYPHID\n")));
        {
            LPEPAGEMDV    lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
            int hlx = IGetHLIndex(lpEpage, lpEpage->iCurrentDLFontID);
            if (hlx >= 0)
            {    // TTF downloaded
                BYTE bDBCS = lpEpage->HeightL[hlx].fGeneral & FLAG_DBCS;
                PDWORD pdwGlyphID;
                DWORD dwI;
                for (dwI = 0, pdwGlyphID = pGlyph; dwI < dwCount; dwI++, pdwGlyphID++)
                {
                    if (bDBCS)
                    {
                        // for DBCS, modify cp to printable char code
                        WORD cc = WConvDBCSCharCode((WORD)*pdwGlyphID, lpEpage->dwLCID);
                        WORD cp = SWAPW(cc);
// DBGPRINT(DBG_WARNING, (DLLTEXT("pGlyph[%d] = 0x%X, 0x%X (%.4X)\n"), dwI, LOBYTE(cp), HIBYTE(cp), (WORD)*pdwGlyphID));
                        WRITESPOOLBUF(pdevobj, (PBYTE)&cp, 2);
                    }
                    else
                    {
// DBGPRINT(DBG_WARNING, (DLLTEXT("pGlyph[%d] = 0x%.4lX\n"), dwI, (WORD)*pdwGlyphID));
                        WRITESPOOLBUF(pdevobj, (PBYTE)pdwGlyphID, 1);
                    }
                }
            }
            else
            {    // download font not active
                if (!BConvPrint(pdevobj, pUFObj, dwType, dwCount, pGlyph))
                    ERR(("TYPE_GLYPHID specified for device font.\r\n"));
            }
        }
        break;
    }
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMSendFontCmd
//
//  Description:  Send scalable font download command
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//
//        pUFObj        Pointer to the UNIFONTOBJ.
//
//        pFInv        Pointer to the FINVOCATION
//                    Command string template has been extracted from UFM file,
//                    which may contain "#V" and/or "#H[S|D]"
//
//  Returns:
//        None
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY OEMSendFontCmd(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, PFINVOCATION pFInv)
{
    DWORD        adwStdVariable[2 + 2 * 2];
    PGETINFO_STDVAR pSV = (PGETINFO_STDVAR)adwStdVariable;
    DWORD        dwIn, dwOut;
    PBYTE        pubCmd;
    BYTE        aubCmd[CCHMAXCMDLEN];
//    GETINFO_FONTOBJ    FO;
    PIFIMETRICS    pIFI = pUFObj->pIFIMetrics;
    DWORD         height100, width, charoff;

    LPEPAGEMDV    lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    BYTE        Buff[16];

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMSendFontCmd() entry. Font = %S\r\n"), (LPWSTR)((BYTE*)pIFI + pIFI->dpwszFaceName)));

    pubCmd = pFInv->pubCommand;

//    //
//    // GETINFO_FONTOBJ
//    //
//    FO.dwSize = sizeof(GETINFO_FONTOBJ);
//    FO.pFontObj = NULL;
//
//    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_FONTOBJ, &FO, 0, NULL))
//    {
//        ERR(("UFO_GETINFO_FONTOBJ failed.\r\n"));
//        return;
//    }

    //
    // Get standard variables.
    //
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return;
    }
// LConvertFontSizeToStr((pSV->StdVar[0].lStdVariable * 2540L) / MASTER_Y_UNIT, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  FontHeight: %d (%s mm)\r\n"), pSV->StdVar[0].lStdVariable, Buff));
// LConvertFontSizeToStr((pSV->StdVar[1].lStdVariable * 2540L) / MASTER_X_UNIT, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  FontWidth: %d (%s mm)\r\n"), pSV->StdVar[1].lStdVariable, Buff));

    // Initialize lpEpage
// DBGPRINT(DBG_WARNING, (DLLTEXT("  fGeneral = ")));
    if (IS_DBCSCHARSET(pIFI->jWinCharSet))
    {
        lpEpage->fGeneral |= FLAG_DOUBLE;
// DBGPRINT(DBG_WARNING, ("FLAG_DOUBLE "));
    }
    else
        lpEpage->fGeneral &= ~FLAG_DOUBLE;

    if (L'@' == *((LPWSTR)((BYTE*)pIFI + pIFI->dpwszFaceName)))
    {
        lpEpage->fGeneral |= FLAG_VERT;
// DBGPRINT(DBG_WARNING, ("FLAG_VERT "));
    }
    else
        lpEpage->fGeneral &= ~FLAG_VERT;

    if ((pIFI->jWinPitchAndFamily & 0x03) == VARIABLE_PITCH)
    {
        lpEpage->fGeneral |= FLAG_PROP;
// DBGPRINT(DBG_WARNING, ("FLAG_PROP"));
    }
    else
        lpEpage->fGeneral &= ~FLAG_PROP;
// DBGPRINT(DBG_WARNING, ("\r\n"));

    dwOut = 0;
    lpEpage->fGeneral &= ~FLAG_DBCS;

    // preset character height in Minimum Unit for ESC/Page
    height100 = (pSV->StdVar[0].lStdVariable * 100L) / MIN_Y_UNIT_DIV;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  Height = %d\r\n"), height100));

    for (dwIn = 0; dwIn < pFInv->dwCount && dwOut < CCHMAXCMDLEN; )
    {
        // check for FS_n1_weF command
        if (pubCmd[dwIn] == '\x1D' &&
            (!strncmp(&pubCmd[dwIn + 2], "weF", 3) ||
             !strncmp(&pubCmd[dwIn + 3], "weF", 3)))
        {
            // save n1 for the FS_n1_weF command
            sscanf(&pubCmd[dwIn + 1], "%d", &lpEpage->iParamForFSweF);
        }
        if (pubCmd[dwIn] == '#' && pubCmd[dwIn + 1] == 'V')
        {
            dwOut += LConvertFontSizeToStr(height100, &aubCmd[dwOut]);
            dwIn += 2;
        }
        else if (pubCmd[dwIn] == '#' && pubCmd[dwIn + 1] == 'H')
        {
            // get width in MASTER_X_UNIT; no adjustment needed
            width = pSV->StdVar[1].lStdVariable;
            if (pubCmd[dwIn + 2] == 'S')
            {
                dwIn += 3;
                lpEpage->fGeneral |= FLAG_DBCS;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  WidthS = ")));
            }
            else if (pubCmd[dwIn + 2] == 'D')
            {
                width *= 2;
                dwIn += 3;
                lpEpage->fGeneral |= FLAG_DBCS;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  WidthD = ")));
            }
            else if (pubCmd[dwIn + 2] == 'K')
            {    // PAGE-C/K/H
                width *= 2;
                dwIn += 3;
                lpEpage->fGeneral |= FLAG_DBCS;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  WidthK = ")));
            }
            else
            {
                dwIn += 2;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  Width = ")));
            }
// DBGPRINT(DBG_WARNING, ("%d\r\n", width));
#if    1    // <FS> n1 wmF
            // use width in minimum unit
            width = (width * 100L) / MIN_Y_UNIT_DIV;
#else    // <FS> n1 wcF
            // get CPI (Char# per Inch)
            width = (MASTER_X_UNIT * 100L) / width;
#endif
// DBGPRINT(DBG_WARNING, (DLLTEXT("Width=%d\r\n"), width));
            dwOut += LConvertFontSizeToStr(width, &aubCmd[dwOut]);
        }
        else
        {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }
// DBGPRINT(DBG_WARNING, (DLLTEXT("  iParamForFSweF = %d\r\n"), lpEpage->iParamForFSweF));

    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

    lpEpage->iDevCharOffset = (height100 * pIFI->fwdWinDescender /
                               (pIFI->fwdWinAscender + pIFI->fwdWinDescender));
    LConvertFontSizeToStr((lpEpage->fGeneral & FLAG_DBCS) ? lpEpage->iDevCharOffset : 0,
                          Buff);
    dwOut = sprintf(aubCmd, SET_CHAR_OFFSET_S, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  iDevCharOffset = %s\r\n"), Buff));

    if (lpEpage->fGeneral & FLAG_VERT)
    {
        int dx = (lpEpage->fGeneral & FLAG_DOUBLE) ? 1 : 0;
        dwOut += sprintf(&aubCmd[dwOut], SET_VERT_PRINT, dx);
    }
    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

    lpEpage->iCurrentDLFontID = -1;        // mark device font

    // save for SET_SINGLE_BYTE and SET_DOUBLE_BYTE
    // get width in Minimum Unit for ESC/Page
    width = pSV->StdVar[1].lStdVariable / MIN_X_UNIT_DIV;
    if (lpEpage->fGeneral & FLAG_DBCS)
    {
        lpEpage->iSBCSX = lpEpage->iSBCSXMove = width;
        lpEpage->iDBCSX = lpEpage->iDBCSXMove = width * 2;
    }
    else
    {
        lpEpage->iSBCSX = lpEpage->iSBCSXMove = width;
        lpEpage->iDBCSX = lpEpage->iDBCSXMove = 0;
    }
    lpEpage->iSBCSYMove = lpEpage->iDBCSYMove = 0;
}


//
// LConvertFontSizeToStr : converts font size to string
//    params
//        size    :    font size (magnified by 100 times)
//        pStr    :    points string buffer
//    return
//        converted string length
//    spec
//        converting format = "xx.yy"
//
LONG LConvertFontSizeToStr(LONG  size, PSTR  pStr)
{
    return (LONG)sprintf(pStr, "%d.%02d", size / 100, size % 100);
}


//
// BInsertHeightList : inserts HeightList data for id (FontID) in *lpEpage
//    params
//        lpEpage    :    points EPAGEMDV
//        id        :    target font ID
//        wHeight    :    font height
//        wWidth    :    font width
//        fProp    :    proportional spacing font flag
//        fDBCS    :    DBCS font flag
//    return
//        TRUE when succeeded, FALSE if failed (no more space)
//
BOOL PASCAL BInsertHeightList(LPEPAGEMDV lpEpage, int id, WORD wHeight, WORD wWidth, BYTE fProp, BYTE fDBCS)
{
// DBGPRINT(DBG_WARNING, (DLLTEXT("Registering download font (%d):\r\n"), id));
// DBGPRINT(DBG_WARNING, (DLLTEXT("  wHeight = %d\r\n"), (int)wHeight));
// DBGPRINT(DBG_WARNING, (DLLTEXT("  wWidth  = %d\r\n"), (int)wWidth));
// DBGPRINT(DBG_WARNING, (DLLTEXT("  fProp   = %d\r\n"), (int)fProp));
// DBGPRINT(DBG_WARNING, (DLLTEXT("  fDBCS   = %d\r\n"), (int)fDBCS));
    if (lpEpage->wListNum < DOWNLOAD_MAX_FONTS)
    {
        LPHEIGHTLIST lpHeightList = lpEpage->HeightL;

        lpHeightList          += lpEpage->wListNum;
        lpHeightList->id       = (short)id;
        lpHeightList->Height   = wHeight;
        lpHeightList->Width    = wWidth;
        lpHeightList->fGeneral = ((fProp) ? FLAG_PROP : 0) | ((fDBCS) ? FLAG_DBCS : 0);
        lpEpage->wListNum++;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//
// IGetHLIndex : gets HeightList index for id (FontID) in *lpEpage
//    params
//        lpEpage    :    points EPAGEMDV
//        id        :    target font ID
//    return
//        the HeghtList index if found, else -1 will be returned
//
int PASCAL IGetHLIndex(LPEPAGEMDV lpEpage, int id)
{
    int iRet;
    for (iRet = lpEpage->wListNum - 1;
         iRet >= 0 && (int)lpEpage->HeightL[iRet].id != id;
         iRet--)
        ;
    return iRet;
}


//BYTE PASCAL BTGetProp(LPEPAGEMDV lpEpage, int id)
//{
//    int i = IGetHLIndex(lpEpage, id);
//    return (i >= 0) ? (lpEpage->HeightL[i].fGeneral & FLAG_PROP) : 0;
//}


//BYTE PASCAL BTGetDBCS(LPEPAGEMDV lpEpage, int id)
//{
//    int i = IGetHLIndex(lpEpage, id);
//    return (i >= 0) ? (lpEpage->HeightL[i].fGeneral & FLAG_DBCS) : 0;
//}


//WORD PASCAL WGetWidth(LPEPAGEMDV lpEpage, int id)
//{
//    int i = IGetHLIndex(lpEpage, id);
//    return (i >= 0) ? lpEpage->HeightL[i].Width : 0;
//}


//WORD PASCAL WGetHeight(LPEPAGEMDV lpEpage, int id)
//{
//    int i = IGetHLIndex(lpEpage, id);
//    return (i >= 0) ? lpEpage->HeightL[i].Height : 0;
//}


//
// WConvDBCSCharCode : converts linear character code to printable range
//    params
//        cc        :    linear character code started at DOWNLOAD_MIN_GLYPH_ID
//        LCID    :    locale ID
//    return
//        WORD character code in printable range
//
//    Conversion spec:
//        cc                return
//    LCID = LCID_KOR:
//        0x20..0x7D    ->    0xA1A1..0xA1FE    (char count = 0xA1FE - 0xA1A1 + 1 = 0x5E)
//        0x7E..0xDB    ->    0xA2A1..0xA2FE    (char count = 0x5E)
//        0xDC..0x139    ->    0xA3A1..0xA3FE    (char count = 0x5E)
//        ...                ...
//    LCID != LCID_KOR:
//        0x20..0x7D    ->    0x2121..0x207E    (char count = 0x217E - 0x2121 + 1 = 0x5E)
//        0x7E..0xDB    ->    0x2221..0x227E    (char count = 0x5E)
//        0xDC..0x139    ->    0x2321..0x237E    (char count = 0x5E)
//        ...                ...
//
WORD WConvDBCSCharCode(WORD cc, DWORD LCID)
{
    WORD nPad, cc2;
    cc2 = cc - DOWNLOAD_MIN_GLYPH_ID;    // adjust to base 0
    nPad = cc2 / 0x5E;                    // get gap count
    cc2 += nPad * (0x100 - 0x5E);        // adjust for padding gaps
    // set the base code for the LCID
    switch (LCID)
    {
    case LCID_KOR:
        cc2 += (WORD)0xA1A1;
        break;
    default:
        cc2 += (WORD)0x2121;
        break;
    }
// DBGPRINT(DBG_WARNING, (DLLTEXT("WConvDBCSCharCode(%.4x,%d) = %.4x\r\n"), cc, LCID, cc2));
    return cc2;
}


//
// BConvPrint : converts glyph string and prints it
//    params
//        pdevobj    :    Pointer to the DEVOBJ.
//        pUFObj    :    Pointer to the UNIFONTOBJ.
//        dwType    :    Type of pglyph string. One of following is specified by UNIDRV.
//                    TYPE_GLYPHHANDLE TYPE_GLYPHID
//        dwCount    :    Number of the glyph store in pGlyph
//        pGlyph    :    Pointer to glyph string to HGLYPH* (TYPE_GLYPHHANDLE)
//                    Glyph handle that GDI passes.
//                    DWORD* (TYPE_GLYPHID). Glyph ID that UNIDRV creates from
//                    Glyph Handle. In case of TrueType font, string type is HGLYPH*.
//                    For Device font, string type is DWORD*
//    return
//        TRUE when succeeded, FALSE if failed
//
BOOL BConvPrint(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph)
{
    TRANSDATA *aTrans;
    GETINFO_GLYPHSTRING GStr;
    LPEPAGEMDV lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);

    DWORD    dwI;
    DWORD    adwStdVariable[2 + 2 * 2];
    PGETINFO_STDVAR    pSV;
    BOOL    bGotStdVar;
    DWORD    dwFontSim[2];

    BYTE jType, *pTemp;
    WORD wLen;
    BOOL bRet;

    // setup GETINFO_GLYPHSTRING
    GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
    GStr.dwCount   = dwCount;
    GStr.dwTypeIn  = dwType;
    GStr.pGlyphIn  = pGlyph;
    GStr.pGlyphOut = NULL;
    GStr.dwTypeOut = TYPE_TRANSDATA;
    GStr.dwGlyphOutSize = 0;

    if ((FALSE != (bRet = pUFObj->pfnGetInfo(pUFObj,
            UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)))
        || 0 == GStr.dwGlyphOutSize)
    {
        ERR(("UFO_GETINFO_GRYPHSTRING faild - %d, %d.\n",
            bRet, GStr.dwGlyphOutSize));
        return FALSE;
    }

    aTrans = (TRANSDATA *)MemAlloc(GStr.dwGlyphOutSize);
    if (NULL == aTrans)
    {
        ERR(("MemAlloc faild.\n"));
        return FALSE;
    }

    GStr.pGlyphOut = aTrans;

    // convert glyph string to TRANSDATA
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        return FALSE;
    }

// Only LCID_JPN == 0, other LCIDs are not 0
//            if (lpEpage->dwLCID == LCID_CHT ||
//                lpEpage->dwLCID == LCID_CHS ||
//                lpEpage->dwLCID == LCID_KOR)
//            if (lpEpage->dwLCID && lpEpage->dwLCID != LCID_USA)
    if (lpEpage->dwLCID != LCID_USA)    //99/02/04
    {
        // prepare GETINFO_STDVAR
        pSV = (PGETINFO_STDVAR)adwStdVariable;
        pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
        pSV->dwNumOfVariable = 2;
        pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTBOLD;
        pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTITALIC;
        bGotStdVar = FALSE;
        // preset 0 to dwFontSim[]
        dwFontSim[0] = dwFontSim[1] = 0;
    }
// #441438: PREFIX: "bGotStdVar" does not initialized if dwLCID == LCID_USA
// #441439: PREFIX: "pSV" does not initialized if dwLCID == LCID_USA
    else {
        pSV = (PGETINFO_STDVAR)adwStdVariable;
        bGotStdVar = TRUE;
    }

    for (dwI = 0; dwI < dwCount; dwI++)
    {
// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubCodePageID:0x%x\n"),aTrans[dwI].ubCodePageID));
// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubType:0x%x\n"),aTrans[dwI].ubType));
        jType = (aTrans[dwI].ubType & MTYPE_FORMAT_MASK);

        switch (jType)
        {
        case MTYPE_DIRECT:
        case MTYPE_COMPOSE:

// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubCode:0x%.2X\n"),aTrans[dwI].uCode.ubCode));
// Only LCID_JPN == 0, other LCIDs are not 0
//                    if (lpEpage->dwLCID == LCID_CHT ||
//                        lpEpage->dwLCID == LCID_CHS ||
//                        lpEpage->dwLCID == LCID_KOR)
            if (lpEpage->dwLCID)
            {
// #441438: PREFIX: "bGotStdVar" does not initialized if dwLCID == LCID_USA
                // if (lpEpage->fGeneral & FLAG_DOUBLE)
                if ((lpEpage->fGeneral & FLAG_DOUBLE) &&
                    lpEpage->dwLCID != LCID_USA)
                {
                    if (!bGotStdVar)
                    {    // dwFontSim[] not initialized
                        // get FontBold/FontItalic
                        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
                        {
                            bGotStdVar = TRUE;
                            // update FontBold/FontItalic
                            dwFontSim[0] = pSV->StdVar[0].lStdVariable;
                            dwFontSim[1] = pSV->StdVar[1].lStdVariable;
                        }
                        else
                        {
                            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
                        }
                    }
                    // invoke CmdSelectSingleByteMode
                    OEMCommandCallback(pdevobj, TEXT_SINGLE_BYTE, 2, dwFontSim);
                }
            }
            switch(jType)
            {
            case MTYPE_DIRECT:
                WRITESPOOLBUF(pdevobj, &aTrans[dwI].uCode.ubCode, 1);
                break;
            case MTYPE_COMPOSE:
                pTemp = (BYTE *)(aTrans) + aTrans[dwI].uCode.sCode;

                // first two bytes are the length of the string
                wLen = *pTemp + (*(pTemp + 1) << 8);
                pTemp += 2;

                WRITESPOOLBUF(pdevobj, pTemp, wLen);
                break;
            }
            break;
        case MTYPE_PAIRED:
// Only LCID_JPN == 0, other LCIDs are not 0
//                    if (lpEpage->dwLCID == LCID_CHT ||
//                        lpEpage->dwLCID == LCID_CHS ||
//                        lpEpage->dwLCID == LCID_KOR)
            if (lpEpage->dwLCID)
            {
                if (!(lpEpage->fGeneral & FLAG_DOUBLE) &&
                    lpEpage->dwLCID != LCID_USA)
                {
                    if (!bGotStdVar)
                    {    // dwFontSim[] not initialized
                        // get FontBold/FontItalic
                        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
                        {
                            bGotStdVar = TRUE;
                            // update FontBold/FontItalic
                            dwFontSim[0] = pSV->StdVar[0].lStdVariable;
                            dwFontSim[1] = pSV->StdVar[1].lStdVariable;
                        }
                        else
                        {
                            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
                        }
                    }
                    // invoke CmdSelectDoubleByteMode
                    OEMCommandCallback(pdevobj, TEXT_DOUBLE_BYTE, 2, dwFontSim);
                }
// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubPairs:(0x%.2X,0x%.2X)\n"), aTrans[dwI].uCode.ubPairs[0], aTrans[dwI].uCode.ubPairs[1]));
                WRITESPOOLBUF(pdevobj, aTrans[dwI].uCode.ubPairs, 2);
            }
            else
            {    // Jpn
// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubPairs:(0x%.2X,0x%.2X)\n"), aTrans[dwI].uCode.ubPairs[0], aTrans[dwI].uCode.ubPairs[1]));
                // EPSON specific
                // vertical period and comma must be shifted to upper right.
                BOOL AdjPos;
                int adjx, adjy;
                BYTE buf[32];
                DWORD cb;
// DEBUG
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_OK, L"Code = %.4x, Vertical = %d.\r\n",
       *((PWORD)aTrans[dwI].uCode.ubPairs), !!(lpEpage->fGeneral & (FLAG_VERT|FLAG_VERTPRN)));
#endif
// DEBUG
// #441438: PREFIX: "bGotStdVar" does not initialized if dwLCID == LCID_USA
                // 99/02/04
                // if ((lpEpage->fGeneral & FLAG_DOUBLE) && (aTrans[dwI].ubType & MTYPE_SINGLE))
                if (lpEpage->dwLCID != LCID_USA && (lpEpage->fGeneral & FLAG_DOUBLE) && (aTrans[dwI].ubType & MTYPE_SINGLE))
                {
                    if (!bGotStdVar)
                    {    // dwFontSim[] not initialized
                        // get FontBold/FontItalic
                        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
                        {
                            bGotStdVar = TRUE;
                            // update FontBold/FontItalic
                            dwFontSim[0] = pSV->StdVar[0].lStdVariable;
                            dwFontSim[1] = pSV->StdVar[1].lStdVariable;
                        }
                        else
                        {
                            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
                        }
                    }
                    // invoke CmdSelectSingleByteMode
                    OEMCommandCallback(pdevobj, TEXT_SINGLE_BYTE, 2, dwFontSim);
                }

                AdjPos = (*((PWORD)aTrans[dwI].uCode.ubPairs) == 0x2421 ||    // comma
                          *((PWORD)aTrans[dwI].uCode.ubPairs) == 0x2521) &&    // period
                         (lpEpage->fGeneral & (FLAG_VERT|FLAG_VERTPRN)) &&
                         !(lpEpage->fGeneral & FLAG_NOVPADJ);
                if (AdjPos)
                {
                    adjx = lpEpage->iSBCSX * VERT_PRINT_REL_X / 100;
                    adjy = lpEpage->iSBCSX * VERT_PRINT_REL_Y / 100;
// DEBUG
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_ICONINFORMATION, L"adjx = %d, adjy = %d.\r\n", adjx, adjy);
#endif
// DEBUG
                    cb = sprintf(buf, SET_REL_X, -adjx);
                    cb += sprintf(buf + cb, SET_REL_Y, -adjy);
                    WRITESPOOLBUF(pdevobj, buf, cb);
                }
                WRITESPOOLBUF(pdevobj, aTrans[dwI].uCode.ubPairs, 2);
                if (AdjPos)
                {
                    cb = sprintf(buf, SET_REL_X, adjx);
                    cb += sprintf(buf + cb, SET_REL_Y, adjy);
                    WRITESPOOLBUF(pdevobj, buf, cb);
                }
            }
            break;
        default:
            WARNING(("Unsupported TRANSDATA data type passed.\n"));
            WARNING(("jType=%02x, sCode=%x\n", aTrans[dwI].uCode.sCode, jType));
        }
    }

    if (NULL != aTrans)
    {
        MemFree(aTrans);
    }

    return TRUE;
}

//
// CheckAvailableMem : check available memory size
//    params
//        lpEpage    :    Pointer to the EPAGEMDV.
//        pUFObj    :    Pointer to the UNIFONTOBJ.
//    return
//        available memory size in bytes
//
DWORD CheckAvailableMem(LPEPAGEMDV lpEpage, PUNIFONTOBJ pUFObj)
{
    GETINFO_MEMORY meminfo;
    // get memory information
    meminfo.dwSize = sizeof(GETINFO_MEMORY);
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_MEMORY, &meminfo, 0, NULL))
    {
        ERR(("UFO_GETINFO_MEMORY failed.\r\n"));
        return 0;    // error
    }
    // DCR: Unidrv might return NEGATIVE value
    if ((long)meminfo.dwRemainingMemory < 0)
        meminfo.dwRemainingMemory = 0;
    if (lpEpage->dwMemAvailable != meminfo.dwRemainingMemory)
    {
        lpEpage->dwMemAvailable = meminfo.dwRemainingMemory;
//        DBGPRINT(DBG_WARNING, (DLLTEXT("Available memory = %d bytes\r\n"), meminfo.dwRemainingMemory));
    }
    return meminfo.dwRemainingMemory;
}

// DEBUG
#ifdef    DBGMSGBOX
#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
int DbgMsg(LPEPAGEMDV lpEpage, UINT mbicon, LPCTSTR msgfmt, ...)
{
    // can't do anything against GUI
    return 0;
}
int MsgBox(LPEPAGEMDV lpEpage, LPCTSTR msg, UINT mbicon)
{
    // can't do anything against GUI
    return 0;
}
#else    // Usermode
int DbgMsg(LPEPAGEMDV lpEpage, UINT mbicon, LPCTSTR msgfmt, ...)
{
    TCHAR buf[256];
    va_list va;
    va_start(va, msgfmt);
    wvsprintf((LPTSTR)buf, msgfmt, va);
    va_end(va);
    return MsgBox(lpEpage, buf, mbicon);
}

int MsgBox(LPEPAGEMDV lpEpage, LPCTSTR msg, UINT mbicon)
{
    int rc = IDOK;
    if (mbicon != MB_OK)
        lpEpage->fGeneral &= ~FLAG_SKIPMSG;
    if (!(lpEpage->fGeneral & FLAG_SKIPMSG))
    {
        if (IDCANCEL ==
            (rc = MessageBox(GetDesktopWindow(), msg, L"EPAGCRES", mbicon|MB_OKCANCEL)))
        {
            lpEpage->fGeneral |= FLAG_SKIPMSG;
        }
    }
    return rc;
}
#endif
#endif    // #ifdef    DBGMSGBOX
// DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epagcres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
    "Compression",
//     "DeviceCapabilities",
//     "DevMode",
//     "DevQueryPrintEx",
    "DisableDriver",	// Suggested by ganeshp
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
    "EnableDriver",		// Suggested by ganeshp
    "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epagcres\sources.inc ===
!ifndef PRNROOT
! ifndef DDKBUILDENV
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
! else
PRNROOT=$(BASEDIR)\src\print
! endif
!endif

!include $(PRNROOT)\print.inc

!ifndef GPDLANG
GPDLANG=$(ALT_PROJECT)
!endif

!ifndef DDKBUILDENV

GPDDIR=$(PRNROOT)\gpd\epson\$(GPDLANG)
GPDDIR_RI=$(PRNROOT)\gpd\ricoh\$(GPDLANG)
GPDDIR_TG=$(PRNROOT)\gpd\trg\$(GPDLANG)

!else

GPDDIR=$(PRNROOT)\mini\gpd\epson\$(GPDLANG)
GPDDIR_RI=$(PRNROOT)\mini\gpd\ricoh\$(GPDLANG)
GPDDIR_TG=$(PRNROOT)\mini\gpd\trg\$(GPDLANG)

!endif

ICMDIR=..\icm

INCLUDES=$(PRNROOT)\inc

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),epagcres
!else
DLLBASE=0x8000000
!endif

UMTYPE=windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epagcres\nt4\dllentry.cpp ===
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//		DllInitialize
//
//  PLATFORMS:	Windows NT
//
//

#include "pdev.h"

// Need to export these functions as c declarations.
extern "C" {

///////////////////////////////////////////////////////////
//
// DLL entry point
//

#ifndef WINNT_40

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#else // WINNT_40

// DllInitialize isn't called/used for user mode version.
BOOL WINAPI DllInitialize(ULONG ulReason)
{
	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));

            // In kernel mode version, initializes semaphore.
            DrvCreateInterlock();
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));

            // In kernel mode version, deletes semaphore.
            DrvDeleteInterlock();
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#endif // WINNT_40

}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epageres\debug.c ===
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epageres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epagcres\nt4\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

		98/7/16 v-yutah:
		Added Compression entry support

		98/9/3 v-yutah:
		Because of suggestion from ganeshp,
			Modified PublishDriverInterface(), and related to it,
			Modified EnableDriver(), DisableDriver()

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
#if	1	// Suggested by ganeshp
		// Need to return S_OK so that DisableDriver() will be called, which Releases
		// the reference to the Printer Driver's interface.
		return S_OK;
#else	// Suggested by ganeshp
        return E_NOTIMPL;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
#if	1	// Suggested by ganeshp
		// Release reference to Printer Driver's interface.
		if (this->pOEMHelp)
		{
			this->pOEMHelp->Release();
			this->pOEMHelp = NULL;
		}
		return S_OK;
#else	// Suggested by ganeshp
        return E_NOTIMPL;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        PDEVOEM pTemp;

        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

        if ((pTemp = OEMEnablePDEV(pdevobj, pPrinterName,
                cPatterns, phsurfPatterns, cjGdiInfo,
                pGdiInfo, cjDevInfo, pDevInfo, pded))) {
            *pDevOem = pTemp;
            return S_OK;
        }
        return E_FAIL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
//      VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
#if	1	// Suggested by ganeshp
		// Need to store pointer to Driver Helper functions, if we already haven't.
		if (this->pOEMHelp == NULL)
		{
			HRESULT hResult;
			// Get Interface to Helper Functions.
			hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));
			if(!SUCCEEDED(hResult))
			{
				// Make sure that interface pointer reflects interface query failure.
				this->pOEMHelp = NULL;
				return E_FAIL;
			}
		}
		return S_OK;
#else	// Suggested by ganeshp
        if (this->pOEMHelp == NULL)
            pIUnknown->AddRef();
        this->pOEMHelp = reinterpret_cast<IPrintOemDriverUni*>(pIUnknown);
        return S_OK;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
#if	1
        return E_NOTIMPL;
#else
        *ppbResult = OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader,
										pColorTable, dwCallbackID, pIPParams);

        return S_OK;
#endif
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
#if	0
        return E_NOTIMPL;
#else
        *piResult = OEMCompression(pdevobj, pInBuf, pOutBuf, dwInLen, dwOutLen);

        return S_OK;
#endif
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epageres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs && \
         (pdevobj)->pdevOEM )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'EPAG'      // EPSPN ESC/Page series dll
// #define DLLTEXT(s)      __TEXT("EPAG:  ") __TEXT(s)
#define DLLTEXT(s)      "EPAG:  " s
#define OEM_VERSION      0x00010000L

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epageres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
//     "DevMode",
//     "DevQueryPrintEx",
    "DisableDriver",	// Suggested by ganeshp
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
    "EnableDriver",		// Suggested by ganeshp
    "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epageres\eprcid.h ===
// please keep consistency between GPDCMN.GPD with this file

// Font Resource (UFM)
#define	RC_FONT_ROMAN		1
#define RC_FONT_SANSRF		2
#define RC_FONT_COURIER		3
#define RC_FONT_COURIERI	4
#define RC_FONT_COURIERB	5
#define RC_FONT_COURIERZ	6
#define RC_FONT_SYMBOL		7
#define RC_FONT_SYMBOLIC	8
#define RC_FONT_DUTCH		33
#define RC_FONT_DUTCHI		34
#define RC_FONT_DUTCHB		35
#define RC_FONT_DUTCHZ		36
#define RC_FONT_SWISS		37
#define RC_FONT_SWISSI		38
#define RC_FONT_SWISSB		39
#define RC_FONT_SWISSZ		40
#define RC_FONT_MOREWB		43

// Font Resource (UFM):Japanese
#define RC_FONT_MINCHO		52
#define RC_FONT_MINCHOV		53
#define RC_FONT_KGOTHIC		54
#define RC_FONT_KGOTHICV	55
#define RC_FONT_MGOTHIC		56
#define RC_FONT_MGOTHICV	57
#define RC_FONT_KYOUKA		58
#define RC_FONT_KYOUKAV		59
#define RC_FONT_SHOUKAI		60
#define RC_FONT_SHOUKAIV	61
#define RC_FONT_MOUHITSU	62
#define RC_FONT_MOUHITSV	63
#define RC_FONT_FMINB		64
#define RC_FONT_FMINBV		65
#define RC_FONT_FGOB		66
#define RC_FONT_FGOBV		67
#define RC_FONT_FMGOT		68
#define RC_FONT_FMGOTV		69

// Font Resource (UFM):ChineseT
#define RC_FONT_SUNGC		70
#define RC_FONT_SUNGCV		71
#define RC_FONT_SUNGCL		72
#define RC_FONT_SUNGCLV		73
#define RC_FONT_SUNGCB		74
#define RC_FONT_SUNGCBV		75
#define RC_FONT_KAIC		76
#define RC_FONT_KAICV		77
#define RC_FONT_KAICL		78
#define RC_FONT_KAICLV		79
#define RC_FONT_KAICB		80
#define RC_FONT_KAICBV		81
#define RC_FONT_YUANGC		82
#define RC_FONT_YUANGCV		83
#define RC_FONT_YUANGCL		84
#define RC_FONT_YUANGCLV	85
#define RC_FONT_YUANGCB		86
#define RC_FONT_YUANGCBV	87
#define RC_FONT_HEIC		88
#define RC_FONT_HEICV		89
#define RC_FONT_HEICL		90
#define RC_FONT_HEICLV		91
#define RC_FONT_HEICB		92
#define RC_FONT_HEICBV		93
#define RC_FONT_LIC			94
#define RC_FONT_LICV		95
#define RC_FONT_FSUNGC		96
#define RC_FONT_FSUNGCV		97
#define RC_FONT_FSUNGCL		98
#define RC_FONT_FSUNGCLV	99
#define RC_FONT_FSUNGCB		100
#define RC_FONT_FSUNGCBV	101
#define RC_FONT_SHINGC		102
#define RC_FONT_SHINGCV		103
#define RC_FONT_SHINYIC		104
#define RC_FONT_SHINYICV	105

// Font Resource (UFM):ChineseS
#define RC_FONT_SONGK		106
#define RC_FONT_SONGKV		107
#define RC_FONT_HEIK		108
#define RC_FONT_HEIKV		109
#define RC_FONT_KAIK		110
#define RC_FONT_KAIKV		111
#define RC_FONT_FSONGK		112
#define RC_FONT_FSONGKV		113

// Font Resource (UFM):Korean
#define RC_FONT_MYUNGH		114
#define RC_FONT_MYUNGHV		115
#define RC_FONT_MYUNGHB		116
#define RC_FONT_MYUNGHBV	117
#define RC_FONT_GOTHIH		118
#define RC_FONT_GOTHIHV		119
#define RC_FONT_GOTHIHB		120
#define RC_FONT_GOTHIHBV	121
#define RC_FONT_DINARH		122
#define RC_FONT_DINARHV		123
#define RC_FONT_DINARHB		124
#define RC_FONT_DINARHBV	125
#define RC_FONT_GUNGH		126
#define RC_FONT_GUNGHV		127
#define RC_FONT_GUNGHB		128
#define RC_FONT_GUNGHBV		129
#define RC_FONT_SAMMUH		130
#define RC_FONT_SAMMUHV		131
#define RC_FONT_SAMMUHB		132
#define RC_FONT_SAMMUHBV	133
#define RC_FONT_PILGIH		134
#define RC_FONT_PILGIHV		135
#define RC_FONT_PILGIHB		136
#define RC_FONT_PILGIHBV	137
#define RC_FONT_YETCHH		138
#define RC_FONT_YETCHHV		139
#define RC_FONT_YETCHHB		140
#define RC_FONT_YETCHHBV	141

// TTFS:Latin; valid only when optional fonts(Swiss721, etc.) provided
#define RC_TTF_ARIAL		150
#define RC_DF_SWISS721		151
#define RC_TTF_COURIERNEW	152
#define RC_DF_COURIER		153
#define RC_TTF_SYMBOL		154
#define RC_DF_SYMBOLIC		156
#define RC_TTF_TIMESNR		157
#define RC_DF_DUTCH801		158
#define RC_TTF_WINGDINGS	159
#define RC_DF_MOREWINGBATS	160

// TTFS:Japanese
#define RC_TTF_MSMINCHO		180
#define RC_DF_MINCHO		181
#define RC_TTF_MSMINCHOV	182
#define RC_DF_MINCHOV		183
#define RC_TTF_MSGOTHIC		184
#define RC_DF_GOTHIC		185
#define RC_TTF_MSGOTHICV	186
#define RC_DF_GOTHICV		187

// TTFS:Japanese in English
#define RC_TTF_MSMINCHO_E   190
#define RC_TTF_MSMINCHOV_E  191
#define RC_TTF_MSGOTHIC_E   192
#define RC_TTF_MSGOTHICV_E  193

//@TTFS:ChineseT
#define RC_TTF_LMING		200
#define RC_DF_SUNGCL		201
#define RC_TTF_LMINGV		202
#define RC_DF_SUNGCLV		203

//@TTFS:ChineseT in English
#define RC_TTF_LMING_E		204
#define RC_TTF_LMINGV_E		205

// TTFS:Chinese
#define RC_TTF_SIMSUN		210
#define RC_DF_SONGK			211
#define RC_TTF_SIMSUNV		212
#define RC_DF_SONGKV		213
#define RC_TTF_SIMHEI		214
#define RC_DF_HEIK			215
#define RC_TTF_SIMHEIV		216
#define RC_DF_HEIKV			217

// TTFS:Chinese in English
#define RC_TTF_SIMSUN_E		218
#define RC_TTF_SIMSUNV_E	219
#define RC_TTF_SIMHEI_E		220
#define RC_TTF_SIMHEIV_E	221

// PaperSize
#define RC_STR_HLT			257
#define RC_STR_GLG			258
#define RC_STR_GLT			259
#define RC_STR_F4			260
#define RC_STR_C10			261
#define RC_STR_A3P			262

#define RC_STR_A3W			263
#define RC_STR_IB5			264

// PaperSize:ChineseT
#define RC_STR_8VO			265
#define RC_STR_16MO			266

// PaperSource:Japanese
#define RC_STR_CST			270
#define RC_STR_CST1			271
#define RC_STR_CST2			272
#define RC_STR_CST3			273
#define RC_STR_CST4			274
#define RC_STR_TRAY			275
#define RC_STR_MMFDR		276
#define RC_STR_LCST			277
#define RC_STR_AUTOCHG		278
#define RC_STR_FTRAY		279
#define RC_STR_AUTOSEL		280

#define RC_STR_MPTRAY		281

// FontCartridgeName:Japanese
#define RC_STR_MARUGOT		290
#define RC_STR_KYOKASHO		291
#define RC_STR_KAISHO		292
#define RC_STR_GYOSHO		293
#define RC_STR_FMINFKGOT	294
#define RC_STR_FMARUGOT		295

// FontCartridgeName:ChineseT
#define RC_STR_FSSSY		296
#define RC_STR_LI			297
#define RC_STR_FANSUNG		298
#define RC_STR_SHING		299

// FontCartridgeName:Korean
#define RC_STR_PLYTCH		300

// Custom Features
#define RC_STR_THICK		323
#define RC_STR_THICK_N		324
#define RC_STR_THIN			325
#define RC_STR_RECTFILL		385
#define RC_STR_ENABLED		386
#define RC_STR_DISABLED		387
#define RC_STR_OPTION_ON	388
#define RC_STR_OPTION_OFF	389

// Custom Features:Japanese
#define RC_STR_VPADJUST		391

// Custom Feature Duplex
#define RC_STR_DUPLEXUNIT	395
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epageres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

		98/9/3 v-yutah:
		Because of suggestion from ganeshp,
			Modified PublishDriverInterface(), and related to it,
			Modified EnableDriver(), DisableDriver()

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
#if	1	// Suggested by ganeshp
		// Need to return S_OK so that DisableDriver() will be called, which Releases
		// the reference to the Printer Driver's interface.
		return S_OK;
#else	// Suggested by ganeshp
        return E_NOTIMPL;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
#if	1	// Suggested by ganeshp
		// Release reference to Printer Driver's interface.
		if (this->pOEMHelp)
		{
			this->pOEMHelp->Release();
			this->pOEMHelp = NULL;
		}
		return S_OK;
#else	// Suggested by ganeshp
        return E_NOTIMPL;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        PDEVOEM pTemp;

        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

        if ((pTemp = OEMEnablePDEV(pdevobj, pPrinterName,
                cPatterns, phsurfPatterns, cjGdiInfo,
                pGdiInfo, cjDevInfo, pDevInfo, pded))) {
            *pDevOem = pTemp;
            return S_OK;
        }
        return E_FAIL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
//      VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
#if	1	// Suggested by ganeshp
		// Need to store pointer to Driver Helper functions, if we already haven't.
		if (this->pOEMHelp == NULL)
		{
			HRESULT hResult;
			// Get Interface to Helper Functions.
			hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));
			if(!SUCCEEDED(hResult))
			{
				// Make sure that interface pointer reflects interface query failure.
				this->pOEMHelp = NULL;
				return E_FAIL;
			}
		}
		return S_OK;
#else	// Suggested by ganeshp
        if (this->pOEMHelp == NULL)
            pIUnknown->AddRef();
        this->pOEMHelp = reinterpret_cast<IPrintOemDriverUni*>(pIUnknown);
        return S_OK;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epageres\epageres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1998  Microsoft Corporation
COPYRIGHT (C) 1997-1998  SEIKO EPSON CORP.

Module Name:

    epageres.c

Abstract:

    ESC/Page specific font metrics resource
    This file contains code for downloading bitmap TrueType fonts
    on Epson ESC/Page printers.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.
    07/../97 Epson
        Modofied to support ESC/Page
    .....
    02/26/98 Epson
        Font downloading memory usage legal calculation implemented
        TTF download range reduced
        Some cleanups

--*/

#include "pdev.h"

// DEBUG
// #define    DBGMSGBOX    1    // UNDEF:No MsgBox, 1:level=1, 2:level=2
#ifdef    DBGMSGBOX
#include "stdarg.h"
#endif
// DEBUG

//
// ---- M A C R O  D E F I N E ----
//
#define CCHMAXCMDLEN                    128
#define    MAX_GLYPHSTRLEN                    256        // maximum glyph string length can be passed from Unidrv
#define FONT_HEADER_SIZE                0x86    // format type 2

#define    DOWNLOAD_HEADER_MEMUSG            (56 + 256)
#define    DOWNLOAD_HDRTBL_MEMUSG            134
#define    DOWNLOAD_FNTHDR_MEMUSG            32
#define    DOWNLOAD_FONT_MEMUSG(w,h)        (((((DWORD)(w) + 31)/32)*4)*(DWORD)(h))
#define DOWNLOAD_MIN_FONT_ID            512
#define DOWNLOAD_NO_DBCS_OFFSET            1024
#define DOWNLOAD_MIN_FONT_ID_NO_DBCS    (DOWNLOAD_MIN_FONT_ID + DOWNLOAD_NO_DBCS_OFFSET)
#define DOWNLOAD_MIN_GLYPH_ID            32
#define DOWNLOAD_MAX_GLYPH_ID_J            (DOWNLOAD_MIN_GLYPH_ID + 512 - 1)
#define DOWNLOAD_MAX_GLYPH_ID_C            (DOWNLOAD_MIN_GLYPH_ID + 512 - 1)
#define DOWNLOAD_MAX_GLYPH_ID_K            (DOWNLOAD_MIN_GLYPH_ID + 512 - 1)
#define DOWNLOAD_MAX_GLYPH_ID_H            (DOWNLOAD_MIN_GLYPH_ID + 256 - 1)
#define DOWNLOAD_MAX_FONTS                24
#define    DOWNLOAD_MAX_HEIGHT                600        // in 600 dpi

#define MASTER_X_UNIT                    1200
#define MASTER_Y_UNIT                    1200
#define MIN_X_UNIT_DIV                    2        // 600 dpi
#define MIN_Y_UNIT_DIV                    2        // 600 dpi

#define VERT_PRINT_REL_X                125
#define VERT_PRINT_REL_Y                125

// Make acess to the 2 byte character in a RISC portable manner.
// Note we treat the 2 byte data as BIG-endian short ingeger for
// convenience.

#define SWAPW(x) \
    ((WORD)(((WORD)(x) << 8) | ((WORD)(x) >> 8)))
#define GETWORD(p) \
    ((WORD)(((WORD)(*((PBYTE)(p))) << 8) + *((PBYTE)(p) + 1)))
#define PUTWORD(p,w) \
    (*((PBYTE)(p)) = HIBYTE(w), *((PBYTE)(p) + 1) = LOBYTE(w))
#define PUTWORDINDIRECT(p,pw) \
    (*((PBYTE)(p)) = *((PBYTE)(pw) + 1), *((PBYTE)(p) + 1) = *((PBYTE)(pw)))

#define WRITESPOOLBUF(p,s,n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf((p), (s), (n)))

// Internal Locale ID
#define LCID_JPN            0x00000000    // Japan; default
#define LCID_CHT            0x00010000    // Taiwan (ChineseTraditional)
#define LCID_CHS            0x00020000    // PRC (ChineseSimplified)
#define LCID_KOR            0x00030000    // Korea
#define LCID_USA            0x01000000    // US

// OEMCommandCallback callback function ordinal
#define    SET_LCID                    10                // ()
#define    SET_LCID_J                    (10 + LCID_JPN)    // ()
#define    SET_LCID_C                    (10 + LCID_CHT)    // ()
#define    SET_LCID_K                    (10 + LCID_CHS)    // ()
#define    SET_LCID_H                    (10 + LCID_KOR)    // ()
#define    SET_LCID_U                    (10 + LCID_USA)    // ()

#define TEXT_PRN_DIRECTION            20                // (PrintDirInCCDegrees)
#define TEXT_SINGLE_BYTE            21                // (FontBold,FontItalic)
#define TEXT_DOUBLE_BYTE            22                // (FontBold,FontItalic)
#define TEXT_BOLD                    23                // (FontBold)
#define TEXT_ITALIC                    24                // (FontItalic)
#define TEXT_HORIZONTAL                25                // ()
#define TEXT_VERTICAL                26                // ()
#define TEXT_NO_VPADJUST            27                // ()

#define DOWNLOAD_SELECT_FONT_ID        30                // (CurrentFontID)
#define DOWNLOAD_DELETE_FONT        31                // (CurrentFontID)
#define DOWNLOAD_DELETE_ALLFONT        32                // ()
#define DOWNLOAD_SET_FONT_ID        33                // (CurrentFontID)
#define DOWNLOAD_SET_CHAR_CODE        34                // (NextGlyph)

#define EP_FONT_EXPLICITE_ITALIC_FONT   (1 << 0)

//
// ---- S T R U C T U R E  D E F I N E ----
//
typedef struct tagHEIGHTLIST {
    short   id;            // DWORD aligned for access optimization
    WORD    Height;
    WORD    fGeneral;    // DWORD aligned for access optimization
    WORD    Width;
} HEIGHTLIST, *LPHEIGHTLIST;

typedef struct tagEPAGEMDV {
    WORD    fGeneral;
    WORD    wListNum;
    HEIGHTLIST HeightL[DOWNLOAD_MAX_FONTS];
    DWORD    dwTextYRes;
    DWORD    dwTextXRes;
    DWORD    dwLCID;
    DWORD    dwMemAvailable;
    DWORD    dwMaxGlyph;
    DWORD    dwNextGlyph;
    DWORD    flAttribute;           // 2001/3/1     sid. To save italic attribute of some device font.
    int        iParamForFSweF;
    int        iCurrentDLFontID;
    int        iDevCharOffset;
    int        iSBCSX;
    int        iDBCSX;
    int        iSBCSXMove;
    int        iSBCSYMove;
    int        iDBCSXMove;
    int        iDBCSYMove;
    int        iEscapement;
} EPAGEMDV, *LPEPAGEMDV;

// fGeneral flags
#define FLAG_DBCS        0x0001
#define FLAG_VERT        0x0002
#define FLAG_PROP        0x0004
#define FLAG_DOUBLE      0x0008
#define FLAG_VERTPRN     0x0010
#define FLAG_NOVPADJ     0x0020
// DEBUG
#ifdef    DBGMSGBOX
#define    FLAG_SKIPMSG     0x8000
#endif
// DEBUG

typedef struct {
    BYTE bFormat;
    BYTE bDataDir;
    WORD wCharCode;
    WORD wBitmapWidth;
    WORD wBitmapHeight;
    WORD wLeftOffset;
    WORD wAscent;
    DWORD CharWidth;
} ESCPAGECHAR;

typedef struct {
   WORD Integer;
   WORD Fraction;
} FRAC;

typedef struct {
   WORD wFormatType;
   WORD wDataSize;
   WORD wSymbolSet;
   WORD wCharSpace;
   FRAC CharWidth;
   FRAC CharHeight;
   WORD wFontID;
   WORD wWeight;  // Line Width
   WORD wEscapement;  // Rotation
   WORD wItalic;  // Slant
   WORD wLast;
   WORD wFirst;
   WORD wUnderline;
   WORD wUnderlineWidth;
   WORD wOverline;
   WORD wOverlineWidth;
   WORD wStrikeOut;
   WORD wStrikeOutWidth;
   WORD wCellWidth;
   WORD wCellHeight;
   WORD wCellLeftOffset;
   WORD wCellAscender;
   FRAC FixPitchWidth;
} ESCPAGEHEADER, *LPESCPAGEHEADER;

//
// ----- S T A T I C  D A T A ---
//
const int ESin[4] = { 0, 1, 0, -1 };
const int ECos[4] = { 1, 0, -1, 0 };

const char DLI_DNLD_HDR[]        = "\x1D%d;%ddh{F";
const char DLI_SELECT_FONT_ID[]    = "\x1D%ddcF\x1D" "0;0coP";
const char DLI_DELETE_FONT[]    = "\x1D%dddcF";
const char DLI_FONTNAME[]        = "________________________EPSON_ESC_PAGE_DOWNLOAD_FONT%02d";
const char DLI_SYMBOLSET[]        = "ESC_PAGE_DOWNLOAD_FONT_INDEX";
#define SYMBOLSET_LEN (sizeof(DLI_SYMBOLSET) - 1)    // adjust for terminating NULL
const char DLI_DNLD1CHAR_H[]    = "\x1D%d;";
const char DLI_DNLD1CHAR_P[]    = "%d;";
const char DLI_DNLD1CHAR_F[]    = "%dsc{F";

const char SET_SINGLE_BYTE[]    = "\x1D" "1;0mcF\x1D%d;%dpP";
const char SET_DOUBLE_BYTE[]    = "\x1D" "1;1mcF\x1D%d;%dpP";
const char CHAR_PITCH[]            = "\x1D" "0spF\x1D%d;%dpP";
const char PRNDIR_POSMOV[]        = "\x1D%dpmP";
const char PRN_DIRECTION[]        = "\x1D%droF";
const char SET_CHAR_OFFSET[]    = "\x1D" "0;%dcoP";
const char SET_CHAR_OFFSET_S[]    = "\x1D" "0;%scoP";
const char SET_CHAR_OFFSET_XY[]    = "\x1D%d;%dcoP";
const char SET_VERT_PRINT[]        = "\x1D%dvpC";

const char SET_BOLD[]              = "\x1D%dweF";
const char SET_ITALIC[]            = "\x1D%dslF";
const char SET_ITALIC_SINGLEBYTE[] = "\x1D%dstF";

const char SET_REL_X[]            = "\x1D%dH";
const char SET_REL_Y[]            = "\x1D%dV";

//
// ---- I N T E R N A L  F U N C T I O N  P R O T O T Y P E ----
//
BOOL PASCAL BInsertHeightList(LPEPAGEMDV lpEpage, int id, WORD wHeight, WORD wWidth, BYTE fProp, BYTE fDBCS);
int PASCAL IGetHLIndex(LPEPAGEMDV lpEpage, int id);
//BYTE PASCAL BTGetProp(LPEPAGEMDV lpEpage, int id);
//BYTE PASCAL BTGetDBCS(LPEPAGEMDV lpEpage, int id);
//WORD PASCAL WGetWidth(LPEPAGEMDV lpEpage, int id);
//WORD PASCAL WGetHeight(LPEPAGEMDV lpEpage, int id);
LONG LConvertFontSizeToStr(LONG  size, PSTR  pStr);
WORD WConvDBCSCharCode(WORD cc, DWORD LCID);
BOOL BConvPrint(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph);
DWORD CheckAvailableMem(LPEPAGEMDV lpEpage, PUNIFONTOBJ pUFObj);
// DEBUG
#ifdef    DBGMSGBOX
int DbgMsg(LPEPAGEMDV lpEpage, UINT mbicon, LPCTSTR msgfmt, ...);
int MsgBox(LPEPAGEMDV lpEpage, LPCTSTR msg, UINT mbicon);
#endif
// DEBUG

//
// ---- F U N C T I O N S ----
//
//////////////////////////////////////////////////////////////////////////
//  Function:   OEMEnablePDEV
//
//  Description:  OEM callback for DrvEnablePDEV;
//                  allocate OEM specific memory block
//
//  Parameters:
//
//        pdevobj            Pointer to the DEVOBJ. pdevobj->pdevOEM is undefined.
//        pPrinterName    name of the current printer.
//        cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo:
//                        These parameters are identical to what's passed
//                        into DrvEnablePDEV.
//        pded            points to a function table which contains the
//                        system driver's implementation of DDI entrypoints.
//
//  Returns:
//        Pointer to the PDEVOEM
//
//  Comments:
//
//
//  History:
//          07/15/97        Created. Epson
//
//////////////////////////////////////////////////////////////////////////

PDEVOEM APIENTRY OEMEnablePDEV(PDEVOBJ pdevobj, PWSTR pPrinterName, ULONG cPatterns, HSURF* phsurfPatterns, ULONG cjGdiInfo, GDIINFO* pGdiInfo, ULONG cjDevInfo, DEVINFO* pDevInfo, DRVENABLEDATA * pded)
{
    // allocate private data structure
    LPEPAGEMDV lpEpage = MemAllocZ(sizeof(EPAGEMDV));
    if (lpEpage)
    {
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMEnablePDEV() entry. PDEVOEM = %x, ulAspectX = %d, ulAspectY = %d\r\n"),
//            lpEpage, pGdiInfo->ulAspectX, pGdiInfo->ulAspectX));
        // save text resolution
        lpEpage->dwTextYRes = pGdiInfo->ulAspectY;
        lpEpage->dwTextXRes = pGdiInfo->ulAspectX;
        // save pointer to the data structure
        lpEpage->flAttribute = 0;
        pdevobj->pdevOEM = (PDEVOEM)lpEpage;
    }
    return (PDEVOEM)lpEpage;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDisablePDEV
//
//  Description:  OEM callback for DrvDisablePDEV;
//                  free all allocated OEM specific memory block(s)
//
//  Parameters:
//
//        pdevobj            Pointer to the DEVOBJ.
//
//  Returns:
//        None
//
//  Comments:
//
//
//  History:
//          07/15/97        Created. Epson
//
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY OEMDisablePDEV(PDEVOBJ pdevobj)
{
    LPEPAGEMDV lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMDisablePDEV() entry. PDEVOEM = %x\r\n"), lpEpage));
    if (lpEpage)
    {
        // free private data structure
        MemFree(lpEpage);
        pdevobj->pdevOEM = NULL;
    }
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    LPEPAGEMDV lpEpageOld, lpEpageNew;

    lpEpageOld = (LPEPAGEMDV)pdevobjOld->pdevOEM;
    lpEpageNew = (LPEPAGEMDV)pdevobjNew->pdevOEM;

    if (lpEpageOld != NULL && lpEpageNew != NULL)
        *lpEpageNew = *lpEpageOld;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMCommandCallback
//
//  Description:  process Command Callback specified by GPD file
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//        dwCmdCbID    CallbackID specified in GPD file
//        dwCount        Parameter count
//        pdwParams    Pointer to the parameters
//
//
//  Returns:
//
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

INT APIENTRY OEMCommandCallback(PDEVOBJ pdevobj, DWORD dwCmdCbID, DWORD dwCount, PDWORD pdwParams)
{
    LPEPAGEMDV    lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    INT            i, cbCmd;
    int            id;
    int            hlx;
    BYTE        Cmd[256];

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,%d,%d,) entry.\r\n"), dwCmdCbID, dwCount));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    cbCmd = 0;
    switch (dwCmdCbID & 0xFFFF)
    {
    case  SET_LCID: // 10:()
        // set LCID for this job
        lpEpage->dwLCID = dwCmdCbID & 0xFFFF0000;
        break;

    case  TEXT_PRN_DIRECTION: // 20:(PrintDirInCCDegrees)
        if (dwCount >= 1)
        {
            int   iEsc90;

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_PRN_DIRECTION,%d,[%d]) entry.\r\n"), dwCount, *pdwParams));

            lpEpage->iEscapement = (int)*pdwParams;
            iEsc90 = lpEpage->iEscapement/90;

            cbCmd = sprintf(Cmd, PRNDIR_POSMOV, iEsc90 ? 1 : 0);

            lpEpage->iSBCSXMove =  lpEpage->iSBCSX * ECos[iEsc90];
            lpEpage->iSBCSYMove = -lpEpage->iSBCSX * ESin[iEsc90];
            if (lpEpage->fGeneral & FLAG_DBCS)
            {
                lpEpage->iDBCSXMove = lpEpage->iDBCSX * ECos[iEsc90];
                lpEpage->iDBCSYMove = -lpEpage->iDBCSX * ESin[iEsc90];
                cbCmd += sprintf(&Cmd[cbCmd], SET_CHAR_OFFSET_XY,
                                 lpEpage->iDevCharOffset * ESin[iEsc90],
                                 lpEpage->iDevCharOffset * ECos[iEsc90]);
            }
            else if (lpEpage->iCurrentDLFontID > 0 && lpEpage->iEscapement)
            {
                WORD wHeight;
                short sXMove, sYMove;
                hlx = IGetHLIndex(lpEpage, lpEpage->iCurrentDLFontID);
                wHeight = (hlx >= 0) ? lpEpage->HeightL[hlx].Height : 0;
                sXMove = -(short)wHeight * ESin[iEsc90];
                sYMove = -(short)wHeight * ECos[iEsc90];
                cbCmd += sprintf(&Cmd[cbCmd], SET_CHAR_OFFSET_XY, sXMove, sYMove);

            }
            else
            {
                cbCmd += sprintf(&Cmd[cbCmd], SET_CHAR_OFFSET, 0);
            }

            if (!(lpEpage->fGeneral & (FLAG_DBCS | FLAG_PROP)) ||
                ((lpEpage->fGeneral & FLAG_DBCS) &&
                 !(lpEpage->fGeneral & FLAG_DOUBLE)))
            {
                cbCmd += sprintf(&Cmd[cbCmd], CHAR_PITCH,
                                 lpEpage->iSBCSXMove, lpEpage->iSBCSYMove);
            }
            else if ((FLAG_DBCS | FLAG_DOUBLE) ==
                     (lpEpage->fGeneral & (FLAG_DBCS | FLAG_DOUBLE)))
            {
                cbCmd += sprintf(&Cmd[cbCmd], CHAR_PITCH,
                                 lpEpage->iDBCSXMove, lpEpage->iDBCSYMove);
            }
            cbCmd += sprintf(&Cmd[cbCmd], PRN_DIRECTION, lpEpage->iEscapement);
        }
        break;

    case TEXT_SINGLE_BYTE: // 21:(FontBold,FontItalic)
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_SINGLE_BYTE,%d,) entry.\r\n"), dwCount));
        cbCmd = sprintf(Cmd, SET_SINGLE_BYTE,
                        lpEpage->iSBCSXMove, lpEpage->iSBCSYMove);
        cbCmd += sprintf(&Cmd[cbCmd], PRN_DIRECTION, lpEpage->iEscapement);
        if (lpEpage->fGeneral & FLAG_VERT)
        {
            cbCmd += sprintf(&Cmd[cbCmd], SET_VERT_PRINT, 0);
        }
        lpEpage->fGeneral &= ~FLAG_DOUBLE;
        goto SetBoldItalic;

    case TEXT_DOUBLE_BYTE: // 22:(FontBold,FontItalic)
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_DOUBLE_BYTE,%d,) entry.\r\n"), dwCount));
        cbCmd = sprintf(Cmd, SET_DOUBLE_BYTE,
                        lpEpage->iDBCSXMove, lpEpage->iDBCSYMove);
        cbCmd += sprintf(&Cmd[cbCmd], PRN_DIRECTION, lpEpage->iEscapement);
        if (lpEpage->fGeneral & FLAG_VERT)
        {
            cbCmd += sprintf(&Cmd[cbCmd], SET_VERT_PRINT, 1);
        }
        else
        {
            cbCmd += sprintf(&Cmd[cbCmd], SET_VERT_PRINT, 0);
        }
        lpEpage->fGeneral |= FLAG_DOUBLE;
SetBoldItalic:
        if (dwCount >= 2)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("  Bold = %d, Italic = %d\r\n"), pdwParams[0], pdwParams[1]));
            cbCmd += sprintf(&Cmd[cbCmd], SET_BOLD,
                             pdwParams[0] ? lpEpage->iParamForFSweF + 3 :
                                            lpEpage->iParamForFSweF);
            if ((!lpEpage->flAttribute & EP_FONT_EXPLICITE_ITALIC_FONT)) 
            {
                cbCmd += sprintf(&Cmd[cbCmd], SET_ITALIC,
                                 pdwParams[1] ? 346 : 0);
                cbCmd += sprintf(&Cmd[cbCmd], SET_ITALIC_SINGLEBYTE,
                                 pdwParams[1] ? 1 : 0);
            }
        }
        break;

    case TEXT_BOLD: // 23:(FontBold)
        if (dwCount >= 1)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_BOLD,%d,%d) entry.\r\n"), dwCount, *pdwParams));
            cbCmd += sprintf(&Cmd[cbCmd], SET_BOLD,
                             (*pdwParams) ? lpEpage->iParamForFSweF + 3 :
                                            lpEpage->iParamForFSweF);
        }
        break;

    case TEXT_ITALIC: // 24:(FontItalic)
        if (dwCount >= 1)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMCommandCallback(,TEXT_ITALIC,%d,%d) entry.\r\n"), dwCount, *pdwParams));
            if (!(lpEpage->flAttribute & EP_FONT_EXPLICITE_ITALIC_FONT)) 
            {
                cbCmd += sprintf(&Cmd[cbCmd], SET_ITALIC, (*pdwParams) ? 346 : 0);
                cbCmd += sprintf(&Cmd[cbCmd], SET_ITALIC_SINGLEBYTE, (*pdwParams) ? 1 : 0);
            }
        }
        break;

    case TEXT_HORIZONTAL: // 25:()
// DEBUG
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_OK, L"VertPrn = Off");
#endif
// DEBUG
        cbCmd = sprintf(Cmd, SET_VERT_PRINT, 0);
        lpEpage->fGeneral &= ~FLAG_VERTPRN;
        break;

    case TEXT_VERTICAL: // 26:()
// DEBUG
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_OK, L"VertPrn = On");
#endif
// DEBUG
        cbCmd = sprintf(Cmd, SET_VERT_PRINT, 1);
        lpEpage->fGeneral |= FLAG_VERTPRN;
        break;

    case TEXT_NO_VPADJUST:    // 27:()
        lpEpage->fGeneral |= FLAG_NOVPADJ;
        break;

    case DOWNLOAD_SELECT_FONT_ID: // 30:(CurrentFontID)
        if (dwCount >= 1)
        {
            id = (int)*pdwParams;
            // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET if needed
            if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
            {
                id -= DOWNLOAD_NO_DBCS_OFFSET;
            }
            hlx = IGetHLIndex(lpEpage, id);
            if (hlx >= 0)
            {    // FontID registered
// DBGPRINT(DBG_WARNING, (DLLTEXT("DOWNLOAD_SELECT_FONT_ID:FontID=%d\r\n"), id));
                lpEpage->iCurrentDLFontID = id;
                lpEpage->fGeneral &= ~(FLAG_DBCS | FLAG_VERT | FLAG_DOUBLE);
                if (lpEpage->HeightL[hlx].fGeneral & FLAG_PROP)
                    lpEpage->fGeneral |= FLAG_PROP;
                else
                    lpEpage->fGeneral &= ~FLAG_PROP;
                lpEpage->iParamForFSweF = 0;
                lpEpage->iSBCSX = lpEpage->HeightL[hlx].Width;
                lpEpage->iDBCSX = 0;
                cbCmd = sprintf(Cmd, DLI_SELECT_FONT_ID, id - DOWNLOAD_MIN_FONT_ID);
            }
        }
        break;

    case DOWNLOAD_DELETE_FONT:    // 31:(CurrentFontID)
        if (dwCount >= 1)
        {
            id = (int)*pdwParams;
            // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET if needed
            if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
            {
                id -= DOWNLOAD_NO_DBCS_OFFSET;
            }
            hlx = IGetHLIndex(lpEpage, id);
            if (hlx >= 0)
            {    // FontID registered
                // set up font delete command
                cbCmd = sprintf(Cmd, DLI_DELETE_FONT, id - DOWNLOAD_MIN_FONT_ID);
                // move HeightList table contents
                for (i = hlx; i + 1 < lpEpage->wListNum; i++)
                {
                    lpEpage->HeightL[i].id = lpEpage->HeightL[i + 1].id;
                    lpEpage->HeightL[i].fGeneral = lpEpage->HeightL[i + 1].fGeneral;
                    lpEpage->HeightL[i].Height = lpEpage->HeightL[i + 1].Height;
                    lpEpage->HeightL[i].Width = lpEpage->HeightL[i + 1].Width;
                }
                // decrease the total number
                lpEpage->wListNum--;
            }
        }
        break;

    case DOWNLOAD_DELETE_ALLFONT: // 32:()
        for (i = 0; i < (int)lpEpage->wListNum ; i++)
        {
            cbCmd += sprintf(&Cmd[cbCmd], DLI_DELETE_FONT,
                               (WORD)lpEpage->HeightL[i].id - DOWNLOAD_MIN_FONT_ID);
            lpEpage->HeightL[i].id = 0;
        }
        lpEpage->wListNum = 0;
        break;

    case DOWNLOAD_SET_FONT_ID:        // 33:(CurrentFontID)
        if (dwCount >= 1)
        {
            id = (int)*pdwParams;
            // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET if needed
            if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
            {
                id -= DOWNLOAD_NO_DBCS_OFFSET;
            }
            hlx = IGetHLIndex(lpEpage, id);
            if (hlx >= 0 && lpEpage->iCurrentDLFontID != id)
            {    // FontID registered && not active
// DBGPRINT(DBG_WARNING, (DLLTEXT("DOWNLOAD_SET_FONT_ID:FontID=%d\r\n"), id));
                cbCmd = sprintf(Cmd, DLI_SELECT_FONT_ID, id - DOWNLOAD_MIN_FONT_ID);
                lpEpage->iParamForFSweF = 0;
                lpEpage->iCurrentDLFontID = id;
            }
        }
        break;

    case DOWNLOAD_SET_CHAR_CODE:    // 34:(NextGlyph)
        if (dwCount >= 1)
        {
// DBGPRINT(DBG_WARNING, (DLLTEXT("DOWNLOAD_SET_CHAR_CODE:NextGlyph=%Xh\r\n"), pdwParams[0]));
            // save next glyph
            lpEpage->dwNextGlyph = pdwParams[0];
        }
        break;

    default:
        ERR(("Unexpected OEMCommandCallback(,%d,%d,%.8lX)\r\n", dwCmdCbID, dwCount, pdwParams));
        break;
    }
    if (cbCmd)
    {
        WRITESPOOLBUF(pdevobj, Cmd, cbCmd);
    }
    return 0;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadFontHeader
//
//  Description:  download font header of ESC/Page
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//
//        pUFObj        Pointer to the UNIFONTOBJ.
//
//
//  Returns:
//        required amount of memory
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY OEMDownloadFontHeader(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj)
{
    ESCPAGEHEADER FontHeader;
    BYTE Buff[56];
    int  iSizeOfBuf;
    LPEPAGEMDV lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    PIFIMETRICS pIFI = pUFObj->pIFIMetrics;
    int id = (int)(pUFObj->ulFontID);
    int idx = id - DOWNLOAD_MIN_FONT_ID;
    BYTE bPS = (BYTE)((pIFI->jWinPitchAndFamily & 0x03) == VARIABLE_PITCH);
    BYTE bDBCS = (BYTE)IS_DBCSCHARSET(pIFI->jWinCharSet);
    DWORD adwStdVariable[2 + 2 * 2];
    PGETINFO_STDVAR    pSV = (PGETINFO_STDVAR)adwStdVariable;
    DWORD height, width, dwTemp;
    DWORD MemAvailable;

    // check FontID
    if (idx < 0)
        return 0;    // error for invalid FontID
    // special check for avoiding DBCS TTF downloading
    if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
    {
        if (bDBCS)
            return 0;    // treat as error for DBCS
        // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET for SBCS
        id -= DOWNLOAD_NO_DBCS_OFFSET;
        idx -= DOWNLOAD_NO_DBCS_OFFSET;
    }

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMDownloadFontHeader(%S) entry. ulFontID=%d, bPS=%d, bDBCS=%d\r\n"),
//         ((pIFI->dpwszFaceName) ? (LPWSTR)((LPBYTE)pIFI + pIFI->dpwszFaceName) : L"?"), id, bPS, bDBCS));

    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return 0;    // error
    }
// LConvertFontSizeToStr((pSV->StdVar[0].lStdVariable * 2540L) / MASTER_Y_UNIT, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  FontHeight: %d (%s mm)\r\n"), pSV->StdVar[0].lStdVariable, Buff));
// LConvertFontSizeToStr((pSV->StdVar[1].lStdVariable * 2540L) / MASTER_X_UNIT, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  FontWidth: %d (%s mm)\r\n"), pSV->StdVar[1].lStdVariable, Buff));
    // preset character size
    // FontHeight, FontWidth set in Minimum Unit for ESC/Page
    height = pSV->StdVar[0].lStdVariable / MIN_Y_UNIT_DIV;
    width = pSV->StdVar[1].lStdVariable / MIN_X_UNIT_DIV;

    // get memory information
    MemAvailable = CheckAvailableMem(lpEpage, pUFObj);
// DBGPRINT(DBG_WARNING, (DLLTEXT("Available memory = %d bytes\r\n"), MemAvailable));
    if (MemAvailable < DOWNLOAD_HEADER_MEMUSG)
    {
        ERR(("Insufficient memory for TTF download.\r\n"));
        return 0;    // error
    }
    // set dwMaxGlyph according to the dwRemainingMemory
    if (bDBCS &&
        ((long)MemAvailable >= 256 * (long)(DOWNLOAD_FNTHDR_MEMUSG +
                                            DOWNLOAD_FONT_MEMUSG(width, height))))
    {
        switch (lpEpage->dwLCID)
        {
        case LCID_JPN:
            lpEpage->dwMaxGlyph = DOWNLOAD_MAX_GLYPH_ID_J;
            break;
        case LCID_CHS:
            lpEpage->dwMaxGlyph = DOWNLOAD_MAX_GLYPH_ID_K;
            break;
        case LCID_CHT:
            lpEpage->dwMaxGlyph = DOWNLOAD_MAX_GLYPH_ID_C;
            break;
        case LCID_KOR:
            lpEpage->dwMaxGlyph = DOWNLOAD_MAX_GLYPH_ID_H;
            break;
        }
    }
    else
        lpEpage->dwMaxGlyph = 255;

    // fill FontHeader w/ 0 to optimize setting 0s
    ZeroMemory(&FontHeader, sizeof(ESCPAGEHEADER));

    if (bPS)    // VARIABLE_PITCH
        lpEpage->fGeneral |= FLAG_PROP;
    else
        lpEpage->fGeneral &= ~FLAG_PROP;
    if (!BInsertHeightList(lpEpage, id, (WORD)height, (WORD)width, bPS, bDBCS))
    {
        ERR(("Can't register download font.\r\n"));
        return 0;    // error
    }
    lpEpage->iParamForFSweF = 0;
    lpEpage->iSBCSX = width;
    lpEpage->iDBCSX = 0;

    FontHeader.wFormatType     = SWAPW(0x0002);
    FontHeader.wDataSize       = SWAPW(FONT_HEADER_SIZE);
//
// ALWAYS PROPORTINAL SPACING REQUIRED
//
// This resolves the following problems:
//    o    The width of Half-width DBCS fonts are doubled
//    o    Fixed picth fonts are shifted gradually
//
    // proportional spacing
    FontHeader.wCharSpace         = SWAPW(1);
    FontHeader.CharWidth.Integer  = (WORD)SWAPW(0x100);
//OK    FontHeader.CharWidth.Fraction = 0;

    FontHeader.CharHeight.Integer = SWAPW(height);
//OK    FontHeader.CharHeight.Fraction = 0;
    // in the range 128 - 255
    FontHeader.wFontID         = SWAPW(idx + (idx < 0x80 ? 0x80 : 0x00));
//OK    FontHeader.wWeight         = 0;
//OK    FontHeader.wEscapement     = 0;
//OK    FontHeader.wItalic         = 0;
    if (bDBCS)
    {
        FontHeader.wSymbolSet   = SWAPW(idx + 0xC000);    // idx + C000h for DBCS
        if (lpEpage->dwLCID == LCID_KOR)
        {
            FontHeader.wFirst        = SWAPW(0xA1A1);
            FontHeader.wLast        = SWAPW(0xA3FE);    // less than or equal to 282 chars
        }
        else
        {
            FontHeader.wFirst        = SWAPW(0x2121);
            FontHeader.wLast        = SWAPW((lpEpage->dwMaxGlyph > 255) ? 0x267E : 0x237E);
        }
    }
    else
    {
        FontHeader.wSymbolSet   = SWAPW(idx + 0x4000);    // idx + 4000h for SBCS
        FontHeader.wFirst        = SWAPW(32);
        FontHeader.wLast        = SWAPW(255);
    }
//OK    FontHeader.wUnderline      = 0;
    FontHeader.wUnderlineWidth = SWAPW(10);
//OK    FontHeader.wOverline       = 0;
//OK    FontHeader.wOverlineWidth  = 0;
//OK    FontHeader.wStrikeOut      = 0;
//OK    FontHeader.wStrikeOutWidth = 0;
    FontHeader.wCellWidth      = SWAPW(width);
    FontHeader.wCellHeight     = SWAPW(height);
//OK    FontHeader.wCellLeftOffset = 0;
    dwTemp = height * pIFI->fwdWinAscender / (pIFI->fwdWinAscender + pIFI->fwdWinDescender);
    FontHeader.wCellAscender   = SWAPW(dwTemp);
    FontHeader.FixPitchWidth.Integer  = SWAPW(width);
//OK    FontHeader.FixPitchWidth.Fraction = 0;

    iSizeOfBuf = sprintf(Buff, DLI_DNLD_HDR, FONT_HEADER_SIZE, idx);
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, &FontHeader, sizeof(ESCPAGEHEADER));
    iSizeOfBuf = sprintf(Buff, DLI_FONTNAME, idx);
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, (LPBYTE)DLI_SYMBOLSET, SYMBOLSET_LEN);
    iSizeOfBuf = sprintf(Buff, DLI_SELECT_FONT_ID, idx);
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    lpEpage->iCurrentDLFontID = id;
    dwTemp = DOWNLOAD_HEADER_MEMUSG;
    // management area required for every 32 header registration
    if ((lpEpage->wListNum & 0x1F) == 0x01)
        dwTemp += DOWNLOAD_HDRTBL_MEMUSG;
    return dwTemp;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadCharGlyph
//
//  Description:  download character glyph
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//        pUFObj        Pointer to the UNIFONTOBJ.
//        hGlyph        Glyph handle to download
//        pdwWidth    Pointer to DWORD width buffer.
//                    Minidirer has to set the width of downloaded glyph data.
//
//  Returns:
//        Necessary amount of memory to download this character glyph in the printer.
//        If returning 0, UNIDRV assumes that this function failed.
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY OEMDownloadCharGlyph(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, HGLYPH hGlyph, PDWORD pdwWidth)
{
    GETINFO_GLYPHBITMAP GBmp;
    GLYPHBITS          *pgb;

    ESCPAGECHAR        ESCPageChar;
    int                iSizeOfBuf;
    int                hlx;
    DWORD            dwSize;
    LPEPAGEMDV        lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    BYTE            Buff[32];
    int                id = (int)(pUFObj->ulFontID);
    WORD            cp;
    DWORD            CharIncX;
    DWORD            dwMemUsg;
    BYTE            bDBCS;

    // check FontID
    if (id < DOWNLOAD_MIN_FONT_ID)
        return 0;    // error for invalid FontID
    // validate Download FontID
    hlx = IGetHLIndex(lpEpage, id);
    if (hlx < 0)
    {
        ERR(("Invalid Download FontID(%d).\r\n", id));
        return 0;    // error
    }
    // cache DBCS flag
    bDBCS = lpEpage->HeightL[hlx].fGeneral & FLAG_DBCS;
    // special check for avoiding DBCS TTF downloading
    if (id >= DOWNLOAD_MIN_FONT_ID_NO_DBCS)
    {
        if (bDBCS)
            return 0;    // treat as error for DBCS
        // adjust FontID by DOWNLOAD_NO_DBCS_OFFSET for SBCS
        id -= DOWNLOAD_NO_DBCS_OFFSET;
    }
    // check GlyphID range
    if (lpEpage->dwNextGlyph > lpEpage->dwMaxGlyph)
    {
        ERR(("No more TTF downloading allowed (GlyphID=%d).\r\n", lpEpage->dwNextGlyph));
        return 0;    // error
    }

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMDownloadCharGlyph() entry. ulFontID = %d, hGlyph = %d\r\n"), id, hGlyph));

    //
    // Get the character information.
    //
    // Get Glyph Bitmap
    GBmp.dwSize     = sizeof(GETINFO_GLYPHBITMAP);
    GBmp.hGlyph     = hGlyph;
    GBmp.pGlyphData = NULL;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp, 0, NULL))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\r\n"));
        return 0;
    }
    pgb = GBmp.pGlyphData->gdf.pgb;
    // Note that ptqD.{x|y}.HighPart is 28.4 format;
    // i.e. device coord. multiplied by 16.
    CharIncX = (GBmp.pGlyphData->ptqD.x.HighPart + 15) >> 4;
// DBGPRINT(DBG_WARNING, (DLLTEXT("Origin.x  = %d\n"), pgb->ptlOrigin.x));
// DBGPRINT(DBG_WARNING, (DLLTEXT("Origin.y  = %d\n"), pgb->ptlOrigin.y));
// DBGPRINT(DBG_WARNING, (DLLTEXT("Extent.cx = %d\n"), pgb->sizlBitmap.cx));
// DBGPRINT(DBG_WARNING, (DLLTEXT("Extent.cy = %d\n"), pgb->sizlBitmap.cy));
// DBGPRINT(DBG_WARNING, (DLLTEXT("CharInc.x = %d\n"), CharIncX));
// DBGPRINT(DBG_WARNING, (DLLTEXT("CharInc.y = %d\n"), (GBmp.pGlyphData->ptqD.y.HighPart + 15) >> 4));

    dwMemUsg = DOWNLOAD_FNTHDR_MEMUSG + DOWNLOAD_FONT_MEMUSG(CharIncX, (GBmp.pGlyphData->ptqD.y.HighPart + 15) >> 4);
    if (CheckAvailableMem(lpEpage, pUFObj) < dwMemUsg)
    {
        ERR(("Insufficient memory for OEMDownloadCharGlyph.\r\n"));
        return 0;    // error
    }

    // retrieve NextGlyph
    cp = (WORD)lpEpage->dwNextGlyph;
    // for DBCS, modify cp to printable char code
    if (bDBCS)
    {
        cp = WConvDBCSCharCode(cp, lpEpage->dwLCID);
    }

    //
    // Fill character header.
    //
    ZeroMemory(&ESCPageChar, sizeof(ESCPAGECHAR));    // Safe initial values

    // fill in the charcter header information.
    ESCPageChar.bFormat       = 0x01;
    ESCPageChar.bDataDir      = 0x10;
    ESCPageChar.wCharCode     = (bDBCS) ? SWAPW(cp) : LOBYTE(cp);
    ESCPageChar.wBitmapWidth  = SWAPW(pgb->sizlBitmap.cx);
    ESCPageChar.wBitmapHeight = SWAPW(pgb->sizlBitmap.cy);
    ESCPageChar.wLeftOffset   = SWAPW(pgb->ptlOrigin.x);
    ESCPageChar.wAscent       = SWAPW(-pgb->ptlOrigin.y);    // negate (to be positive)
    ESCPageChar.CharWidth     = MAKELONG(SWAPW(CharIncX), 0);

    dwSize = pgb->sizlBitmap.cy * ((pgb->sizlBitmap.cx + 7) >> 3);
    iSizeOfBuf = sprintf(Buff, DLI_DNLD1CHAR_H, dwSize + sizeof(ESCPAGECHAR));
    if (bDBCS)    // for DBCS, set additional high byte
        iSizeOfBuf += sprintf(&Buff[iSizeOfBuf], DLI_DNLD1CHAR_P, HIBYTE(cp));
    iSizeOfBuf += sprintf(&Buff[iSizeOfBuf], DLI_DNLD1CHAR_F, LOBYTE(cp));
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, &ESCPageChar, sizeof(ESCPAGECHAR));
    WRITESPOOLBUF(pdevobj, pgb->aj, dwSize);

    if (pdwWidth)
        *pdwWidth = CharIncX;

    return dwMemUsg;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMTTDownloadMethod
//
//  Description:  determines TT font downloading method
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//
//        pFontObj    Pointer to the FONTOBJ.
//
//
//  Returns:  TTDOWNLOAD_???? flag: one of these
//        TTDOWNLOAD_DONTCARE        Minidriver doesn't care how this font is handled.
//        TTDOWNLOAD_GRAPHICS        Minidriver prefers printing this TT font as graphics.
//        TTDOWNLOAD_BITMAP        Minidriver prefers download this TT font as bitmap soft font.
//        TTDOWNLOAD_TTOUTLINE    Minidriver prefers downloading this TT fonta as TT outline soft font. This printer must have TT rasterizer support. UNIDRV will provide pointer to the memory mapped TT file, through callback. The minidriver has to parser the TT file by itself.
//
//
//  Comments:
//        The judgement is very unreliable !!!
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY OEMTTDownloadMethod(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj)
{
    DWORD ttdlf = TTDOWNLOAD_GRAPHICS;
    LPEPAGEMDV lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    DWORD adwStdVariable[2 + 2 * 1];
    PGETINFO_STDVAR    pSV = (PGETINFO_STDVAR)adwStdVariable;

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMTTDownloadMethod entry. jWinCharSet = %d\r\n"), pUFObj->pIFIMetrics->jWinCharSet));

    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (1 - 1);
    pSV->dwNumOfVariable = 1;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL) &&
        pSV->StdVar[0].lStdVariable < DOWNLOAD_MAX_HEIGHT * MIN_Y_UNIT_DIV)
    {    // not so big font size
        ttdlf = TTDOWNLOAD_BITMAP;    // download bitmap font
    }
    else
    {
        WARNING(("OEMTTDownloadMethod returns TTDOWNLOAD_GRAPHICS. width = %d\n",
                 pSV->StdVar[0].lStdVariable));
    }
    return ttdlf;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMOutputCharStr
//
//  Description:  convert character code
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//
//        pUFObj        Pointer to the UNIFONTOBJ.
//
//        dwType        Type of pglyph string. One of following is specified by UNIDRV.
//                    TYPE_GLYPHHANDLE TYPE_GLYPHID
//
//        dwCount        Number of the glyph store in pGlyph
//
//        pGlyph        Pointer to glyph string to HGLYPH* (TYPE_GLYPHHANDLE)
//                    Glyph handle that GDI passes.
//                    DWORD* (TYPE_GLYPHID). Glyph ID that UNIDRV creates from
//                    Glyph Handle. In case of TrueType font, string type is HGLYPH*.
//                    For Device font, string type is DWORD*
//
//
//  Returns:
//        None
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY OEMOutputCharStr(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph)
{

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMOutputCharStr(,,%s,%d,) entry.\r\n")),
//         (dwType == TYPE_GLYPHHANDLE) ? "TYPE_GLYPHHANDLE" : "TYPE_GLYPHID", dwCount);

// DEBUG
// CheckAvailableMem((LPEPAGEMDV)(pdevobj->pdevOEM), pUFObj);
// DEBUG

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:
// DBGPRINT(DBG_WARNING, (DLLTEXT("dwType = TYPE_GLYPHHANDLE\n")));
// pdwGlyphID = (PDWORD)pGlyph;
// for (dwI = 0; dwI < dwCount; dwI++)
//  DBGPRINT(DBG_WARNING, (DLLTEXT("hGlyph[%d] = %x\r\n"), dwI, pdwGlyphID[dwI]));
        BConvPrint(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        break;

    case TYPE_GLYPHID:
// DBGPRINT(DBG_WARNING, (DLLTEXT("dwType = TYPE_GLYPHID\n")));
        {
            LPEPAGEMDV    lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
            int hlx = IGetHLIndex(lpEpage, lpEpage->iCurrentDLFontID);
            if (hlx >= 0)
            {    // TTF downloaded
                BYTE bDBCS = lpEpage->HeightL[hlx].fGeneral & FLAG_DBCS;
                PDWORD pdwGlyphID;
                DWORD dwI;
                for (dwI = 0, pdwGlyphID = pGlyph; dwI < dwCount; dwI++, pdwGlyphID++)
                {
                    if (bDBCS)
                    {
                        // for DBCS, modify cp to printable char code
                        WORD cc = WConvDBCSCharCode((WORD)*pdwGlyphID, lpEpage->dwLCID);
                        WORD cp = SWAPW(cc);
// DBGPRINT(DBG_WARNING, (DLLTEXT("pGlyph[%d] = 0x%X, 0x%X (%.4X)\n"), dwI, LOBYTE(cp), HIBYTE(cp), (WORD)*pdwGlyphID));
                        WRITESPOOLBUF(pdevobj, (PBYTE)&cp, 2);
                    }
                    else
                    {
// DBGPRINT(DBG_WARNING, (DLLTEXT("pGlyph[%d] = 0x%.4lX\n"), dwI, (WORD)*pdwGlyphID));
                        WRITESPOOLBUF(pdevobj, (PBYTE)pdwGlyphID, 1);
                    }
                }
            }
            else
            {    // download font not active
                if (!BConvPrint(pdevobj, pUFObj, dwType, dwCount, pGlyph))
                    ERR(("TYPE_GLYPHID specified for device font.\r\n"));
            }
        }
        break;
    }
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMSendFontCmd
//
//  Description:  Send scalable font download command
//
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ.
//
//        pUFObj        Pointer to the UNIFONTOBJ.
//
//        pFInv        Pointer to the FINVOCATION
//                    Command string template has been extracted from UFM file,
//                    which may contain "#V" and/or "#H[S|D]"
//
//  Returns:
//        None
//
//  Comments:
//
//
//  History:
//          07/../97        Created. -Epson-
//
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY OEMSendFontCmd(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, PFINVOCATION pFInv)
{
    DWORD        adwStdVariable[2 + 2 * 2];
    PGETINFO_STDVAR pSV = (PGETINFO_STDVAR)adwStdVariable;
    DWORD        dwIn, dwOut;
    PBYTE        pubCmd;
    BYTE        aubCmd[CCHMAXCMDLEN];
//    GETINFO_FONTOBJ    FO;
    PIFIMETRICS    pIFI = pUFObj->pIFIMetrics;
    DWORD         height100, width, charoff;

    LPEPAGEMDV    lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);
    BYTE        Buff[16];

// DBGPRINT(DBG_WARNING, (DLLTEXT("OEMSendFontCmd() entry. Font = %S\r\n"), (LPWSTR)((BYTE*)pIFI + pIFI->dpwszFaceName)));

    pubCmd = pFInv->pubCommand;

//    //
//    // GETINFO_FONTOBJ
//    //
//    FO.dwSize = sizeof(GETINFO_FONTOBJ);
//    FO.pFontObj = NULL;
//
//    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_FONTOBJ, &FO, 0, NULL))
//    {
//        ERR(("UFO_GETINFO_FONTOBJ failed.\r\n"));
//        return;
//    }

    //
    // Get standard variables.
    //
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
        return;
    }
// LConvertFontSizeToStr((pSV->StdVar[0].lStdVariable * 2540L) / MASTER_Y_UNIT, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  FontHeight: %d (%s mm)\r\n"), pSV->StdVar[0].lStdVariable, Buff));
// LConvertFontSizeToStr((pSV->StdVar[1].lStdVariable * 2540L) / MASTER_X_UNIT, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  FontWidth: %d (%s mm)\r\n"), pSV->StdVar[1].lStdVariable, Buff));

    // Initialize lpEpage
// DBGPRINT(DBG_WARNING, (DLLTEXT("  fGeneral = ")));
    if (IS_DBCSCHARSET(pIFI->jWinCharSet))
    {
        lpEpage->fGeneral |= FLAG_DOUBLE;
// DBGPRINT(DBG_WARNING, ("FLAG_DOUBLE "));
    }
    else
        lpEpage->fGeneral &= ~FLAG_DOUBLE;

    if (L'@' == *((LPWSTR)((BYTE*)pIFI + pIFI->dpwszFaceName)))
    {
        lpEpage->fGeneral |= FLAG_VERT;
// DBGPRINT(DBG_WARNING, ("FLAG_VERT "));
    }
    else
        lpEpage->fGeneral &= ~FLAG_VERT;

    if ((pIFI->jWinPitchAndFamily & 0x03) == VARIABLE_PITCH)
    {
        lpEpage->fGeneral |= FLAG_PROP;
// DBGPRINT(DBG_WARNING, ("FLAG_PROP"));
    }
    else
        lpEpage->fGeneral &= ~FLAG_PROP;
// DBGPRINT(DBG_WARNING, ("\r\n"));

    dwOut = 0;
    lpEpage->fGeneral &= ~FLAG_DBCS;

    // preset character height in Minimum Unit for ESC/Page
    height100 = (pSV->StdVar[0].lStdVariable * 100L) / MIN_Y_UNIT_DIV;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  Height = %d\r\n"), height100));

    for (dwIn = 0; dwIn < pFInv->dwCount && dwOut < CCHMAXCMDLEN; )
    {
        // check for FS_n1_weF command
        if (pubCmd[dwIn] == '\x1D' &&
            (!strncmp(&pubCmd[dwIn + 2], "weF", 3) ||
             !strncmp(&pubCmd[dwIn + 3], "weF", 3)))
        {
            // save n1 for the FS_n1_weF command
            sscanf(&pubCmd[dwIn + 1], "%d", &lpEpage->iParamForFSweF);
        }
        else if ((pubCmd[dwIn] == '\x1D') && ((dwIn + 5) <= pFInv->dwCount)
            && (pubCmd[dwIn+2] == 's') && (pubCmd[dwIn+3] == 't') && (pubCmd[dwIn+4] == 'F'))
        {
            if (pubCmd[dwIn+1] == '1') // This font is italic font like "Arial Italic"
            {
                lpEpage->flAttribute |= EP_FONT_EXPLICITE_ITALIC_FONT;
            }
            else { // Normal font
                lpEpage->flAttribute &= ~EP_FONT_EXPLICITE_ITALIC_FONT;
            }
        }
        if (pubCmd[dwIn] == '#' && pubCmd[dwIn + 1] == 'V')
        {
            dwOut += LConvertFontSizeToStr(height100, &aubCmd[dwOut]);
            dwIn += 2;
        }
        else if (pubCmd[dwIn] == '#' && pubCmd[dwIn + 1] == 'H')
        {
            // get width in MASTER_X_UNIT; no adjustment needed
            width = pSV->StdVar[1].lStdVariable;
            if (pubCmd[dwIn + 2] == 'S')
            {
                dwIn += 3;
                lpEpage->fGeneral |= FLAG_DBCS;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  WidthS = ")));
            }
            else if (pubCmd[dwIn + 2] == 'D')
            {
                width *= 2;
                dwIn += 3;
                lpEpage->fGeneral |= FLAG_DBCS;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  WidthD = ")));
            }
            else if (pubCmd[dwIn + 2] == 'K')
            {    // PAGE-C/K/H
                width *= 2;
                dwIn += 3;
                lpEpage->fGeneral |= FLAG_DBCS;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  WidthK = ")));
            }
            else
            {
                dwIn += 2;
// DBGPRINT(DBG_WARNING, (DLLTEXT("  Width = ")));
            }
// DBGPRINT(DBG_WARNING, ("%d\r\n", width));
#if    1    // <FS> n1 wmF
            // use width in minimum unit
            width = (width * 100L) / MIN_Y_UNIT_DIV;
#else    // <FS> n1 wcF
            // get CPI (Char# per Inch)
            width = (MASTER_X_UNIT * 100L) / width;
#endif
// DBGPRINT(DBG_WARNING, (DLLTEXT("Width=%d\r\n"), width));
            dwOut += LConvertFontSizeToStr(width, &aubCmd[dwOut]);
        }
        else
        {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }
// DBGPRINT(DBG_WARNING, (DLLTEXT("  iParamForFSweF = %d\r\n"), lpEpage->iParamForFSweF));

    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

    lpEpage->iDevCharOffset = (height100 * pIFI->fwdWinDescender /
                               (pIFI->fwdWinAscender + pIFI->fwdWinDescender));
    LConvertFontSizeToStr((lpEpage->fGeneral & FLAG_DBCS) ? lpEpage->iDevCharOffset : 0,
                          Buff);
    dwOut = sprintf(aubCmd, SET_CHAR_OFFSET_S, Buff);
// DBGPRINT(DBG_WARNING, (DLLTEXT("  iDevCharOffset = %s\r\n"), Buff));

    if (lpEpage->fGeneral & FLAG_VERT)
    {
        int dx = (lpEpage->fGeneral & FLAG_DOUBLE) ? 1 : 0;
        dwOut += sprintf(&aubCmd[dwOut], SET_VERT_PRINT, dx);
    }
    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

    lpEpage->iCurrentDLFontID = -1;        // mark device font

    // save for SET_SINGLE_BYTE and SET_DOUBLE_BYTE
    // get width in Minimum Unit for ESC/Page
    width = pSV->StdVar[1].lStdVariable / MIN_X_UNIT_DIV;
    if (lpEpage->fGeneral & FLAG_DBCS)
    {
        lpEpage->iSBCSX = lpEpage->iSBCSXMove = width;
        lpEpage->iDBCSX = lpEpage->iDBCSXMove = width * 2;
    }
    else
    {
        lpEpage->iSBCSX = lpEpage->iSBCSXMove = width;
        lpEpage->iDBCSX = lpEpage->iDBCSXMove = 0;
    }
    lpEpage->iSBCSYMove = lpEpage->iDBCSYMove = 0;
}


//
// LConvertFontSizeToStr : converts font size to string
//    params
//        size    :    font size (magnified by 100 times)
//        pStr    :    points string buffer
//    return
//        converted string length
//    spec
//        converting format = "xx.yy"
//
LONG LConvertFontSizeToStr(LONG  size, PSTR  pStr)
{
    return (LONG)sprintf(pStr, "%d.%02d", size / 100, size % 100);
}


//
// BInsertHeightList : inserts HeightList data for id (FontID) in *lpEpage
//    params
//        lpEpage    :    points EPAGEMDV
//        id        :    target font ID
//        wHeight    :    font height
//        wWidth    :    font width
//        fProp    :    proportional spacing font flag
//        fDBCS    :    DBCS font flag
//    return
//        TRUE when succeeded, FALSE if failed (no more space)
//
BOOL PASCAL BInsertHeightList(LPEPAGEMDV lpEpage, int id, WORD wHeight, WORD wWidth, BYTE fProp, BYTE fDBCS)
{
// DBGPRINT(DBG_WARNING, (DLLTEXT("Registering download font (%d):\r\n"), id));
// DBGPRINT(DBG_WARNING, (DLLTEXT("  wHeight = %d\r\n"), (int)wHeight));
// DBGPRINT(DBG_WARNING, (DLLTEXT("  wWidth  = %d\r\n"), (int)wWidth));
// DBGPRINT(DBG_WARNING, (DLLTEXT("  fProp   = %d\r\n"), (int)fProp));
// DBGPRINT(DBG_WARNING, (DLLTEXT("  fDBCS   = %d\r\n"), (int)fDBCS));
    if (lpEpage->wListNum < DOWNLOAD_MAX_FONTS)
    {
        LPHEIGHTLIST lpHeightList = lpEpage->HeightL;

        lpHeightList          += lpEpage->wListNum;
        lpHeightList->id       = (short)id;
        lpHeightList->Height   = wHeight;
        lpHeightList->Width    = wWidth;
        lpHeightList->fGeneral = ((fProp) ? FLAG_PROP : 0) | ((fDBCS) ? FLAG_DBCS : 0);
        lpEpage->wListNum++;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//
// IGetHLIndex : gets HeightList index for id (FontID) in *lpEpage
//    params
//        lpEpage    :    points EPAGEMDV
//        id        :    target font ID
//    return
//        the HeghtList index if found, else -1 will be returned
//
int PASCAL IGetHLIndex(LPEPAGEMDV lpEpage, int id)
{
    int iRet;
    for (iRet = lpEpage->wListNum - 1;
         iRet >= 0 && (int)lpEpage->HeightL[iRet].id != id;
         iRet--)
        ;
    return iRet;
}


//BYTE PASCAL BTGetProp(LPEPAGEMDV lpEpage, int id)
//{
//    int i = IGetHLIndex(lpEpage, id);
//    return (i >= 0) ? (lpEpage->HeightL[i].fGeneral & FLAG_PROP) : 0;
//}


//BYTE PASCAL BTGetDBCS(LPEPAGEMDV lpEpage, int id)
//{
//    int i = IGetHLIndex(lpEpage, id);
//    return (i >= 0) ? (lpEpage->HeightL[i].fGeneral & FLAG_DBCS) : 0;
//}


//WORD PASCAL WGetWidth(LPEPAGEMDV lpEpage, int id)
//{
//    int i = IGetHLIndex(lpEpage, id);
//    return (i >= 0) ? lpEpage->HeightL[i].Width : 0;
//}


//WORD PASCAL WGetHeight(LPEPAGEMDV lpEpage, int id)
//{
//    int i = IGetHLIndex(lpEpage, id);
//    return (i >= 0) ? lpEpage->HeightL[i].Height : 0;
//}


//
// WConvDBCSCharCode : converts linear character code to printable range
//    params
//        cc        :    linear character code started at DOWNLOAD_MIN_GLYPH_ID
//        LCID    :    locale ID
//    return
//        WORD character code in printable range
//
//    Conversion spec:
//        cc                return
//    LCID = LCID_KOR:
//        0x20..0x7D    ->    0xA1A1..0xA1FE    (char count = 0xA1FE - 0xA1A1 + 1 = 0x5E)
//        0x7E..0xDB    ->    0xA2A1..0xA2FE    (char count = 0x5E)
//        0xDC..0x139    ->    0xA3A1..0xA3FE    (char count = 0x5E)
//        ...                ...
//    LCID != LCID_KOR:
//        0x20..0x7D    ->    0x2121..0x207E    (char count = 0x217E - 0x2121 + 1 = 0x5E)
//        0x7E..0xDB    ->    0x2221..0x227E    (char count = 0x5E)
//        0xDC..0x139    ->    0x2321..0x237E    (char count = 0x5E)
//        ...                ...
//
WORD WConvDBCSCharCode(WORD cc, DWORD LCID)
{
    WORD nPad, cc2;
    cc2 = cc - DOWNLOAD_MIN_GLYPH_ID;    // adjust to base 0
    nPad = cc2 / 0x5E;                    // get gap count
    cc2 += nPad * (0x100 - 0x5E);        // adjust for padding gaps
    // set the base code for the LCID
    switch (LCID)
    {
    case LCID_KOR:
        cc2 += (WORD)0xA1A1;
        break;
    default:
        cc2 += (WORD)0x2121;
        break;
    }
// DBGPRINT(DBG_WARNING, (DLLTEXT("WConvDBCSCharCode(%.4x,%d) = %.4x\r\n"), cc, LCID, cc2));
    return cc2;
}


//
// BConvPrint : converts glyph string and prints it
//    params
//        pdevobj    :    Pointer to the DEVOBJ.
//        pUFObj    :    Pointer to the UNIFONTOBJ.
//        dwType    :    Type of pglyph string. One of following is specified by UNIDRV.
//                    TYPE_GLYPHHANDLE TYPE_GLYPHID
//        dwCount    :    Number of the glyph store in pGlyph
//        pGlyph    :    Pointer to glyph string to HGLYPH* (TYPE_GLYPHHANDLE)
//                    Glyph handle that GDI passes.
//                    DWORD* (TYPE_GLYPHID). Glyph ID that UNIDRV creates from
//                    Glyph Handle. In case of TrueType font, string type is HGLYPH*.
//                    For Device font, string type is DWORD*
//    return
//        TRUE when succeeded, FALSE if failed
//
BOOL BConvPrint(PDEVOBJ pdevobj, PUNIFONTOBJ pUFObj, DWORD dwType, DWORD dwCount, PVOID pGlyph)
{
    TRANSDATA *aTrans;
    GETINFO_GLYPHSTRING GStr;
    LPEPAGEMDV lpEpage = (LPEPAGEMDV)(pdevobj->pdevOEM);

    DWORD    dwI;
    DWORD    adwStdVariable[2 + 2 * 2];
    PGETINFO_STDVAR    pSV;
    BOOL    bGotStdVar;
    DWORD    dwFontSim[2];

    BYTE jType, *pTemp;
    WORD wLen;
    BOOL bRet;

    // setup GETINFO_GLYPHSTRING
    GStr.dwSize    = sizeof(GETINFO_GLYPHSTRING);
    GStr.dwCount   = dwCount;
    GStr.dwTypeIn  = dwType;
    GStr.pGlyphIn  = pGlyph;
    GStr.pGlyphOut = NULL;
    GStr.dwTypeOut = TYPE_TRANSDATA;

    GStr.dwGlyphOutSize = 0;
    GStr.pGlyphOut = NULL;

    if ((FALSE != (bRet = pUFObj->pfnGetInfo(pUFObj,
            UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)))
        || 0 == GStr.dwGlyphOutSize)
    {
        ERR(("UFO_GETINFO_GRYPHSTRING faild - %d, %d.\n",
            bRet, GStr.dwGlyphOutSize));
        return FALSE;
    }

    aTrans = (TRANSDATA *)MemAlloc(GStr.dwGlyphOutSize);
    if (NULL == aTrans)
    {
        ERR(("MemAlloc faild.\n"));
        return FALSE;
    }

    GStr.pGlyphOut = aTrans;

    // convert glyph string to TRANSDATA
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
        return FALSE;
    }

// Only LCID_JPN == 0, other LCIDs are not 0
//            if (lpEpage->dwLCID == LCID_CHT ||
//                lpEpage->dwLCID == LCID_CHS ||
//                lpEpage->dwLCID == LCID_KOR)
//            if (lpEpage->dwLCID && lpEpage->dwLCID != LCID_USA)
    if (lpEpage->dwLCID != LCID_USA)    //99/02/04
    {
        // prepare GETINFO_STDVAR
        pSV = (PGETINFO_STDVAR)adwStdVariable;
        pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
        pSV->dwNumOfVariable = 2;
        pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTBOLD;
        pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTITALIC;
        bGotStdVar = FALSE;
        // preset 0 to dwFontSim[]
        dwFontSim[0] = dwFontSim[1] = 0;
    }
// #441440: PREFIX: "bGotStdVar" does not initialized if dwLCID == LCID_USA
// #441441: PREFIX: "pSV" does not initialized if dwLCID == LCID_USA
    else {
        pSV = (PGETINFO_STDVAR)adwStdVariable;
        bGotStdVar = TRUE;
    }

    for (dwI = 0; dwI < dwCount; dwI++)
    {
// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubCodePageID:0x%x\n"),aTrans[dwI].ubCodePageID));
// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubType:0x%x\n"),aTrans[dwI].ubType));
        jType = (aTrans[dwI].ubType & MTYPE_FORMAT_MASK);

        switch (jType)
        {
        case MTYPE_DIRECT:
        case MTYPE_COMPOSE:

// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubCode:0x%.2X\n"),aTrans[dwI].uCode.ubCode));
// Only LCID_JPN == 0, other LCIDs are not 0
//                    if (lpEpage->dwLCID == LCID_CHT ||
//                        lpEpage->dwLCID == LCID_CHS ||
//                        lpEpage->dwLCID == LCID_KOR)
            if (lpEpage->dwLCID)
            {
// #441440: PREFIX: "bGotStdVar" does not initialized if dwLCID == LCID_USA
                // if (lpEpage->fGeneral & FLAG_DOUBLE)
                if ((lpEpage->fGeneral & FLAG_DOUBLE) &&
                    lpEpage->dwLCID != LCID_USA)
                {
                    if (!bGotStdVar)
                    {    // dwFontSim[] not initialized
                        // get FontBold/FontItalic
                        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
                        {
                            bGotStdVar = TRUE;
                            // update FontBold/FontItalic
                            dwFontSim[0] = pSV->StdVar[0].lStdVariable;
                            dwFontSim[1] = pSV->StdVar[1].lStdVariable;
                        }
                        else
                        {
                            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
                        }
                    }
                    // invoke CmdSelectSingleByteMode
                    OEMCommandCallback(pdevobj, TEXT_SINGLE_BYTE, 2, dwFontSim);
                }
            }

            switch(jType)
            {
            case MTYPE_DIRECT:
                WRITESPOOLBUF(pdevobj, &aTrans[dwI].uCode.ubCode, 1);
                break;
            case MTYPE_COMPOSE:
                pTemp = (BYTE *)(aTrans) + aTrans[dwI].uCode.sCode;

                // first two bytes are the length of the string
                wLen = *pTemp + (*(pTemp + 1) << 8);
                pTemp += 2;

                WRITESPOOLBUF(pdevobj, pTemp, wLen);
                break;
            }
            break;
        case MTYPE_PAIRED:
// Only LCID_JPN == 0, other LCIDs are not 0
//                    if (lpEpage->dwLCID == LCID_CHT ||
//                        lpEpage->dwLCID == LCID_CHS ||
//                        lpEpage->dwLCID == LCID_KOR)
            if (lpEpage->dwLCID)
            {
                if (!(lpEpage->fGeneral & FLAG_DOUBLE) &&
                    lpEpage->dwLCID != LCID_USA)
                {
                    if (!bGotStdVar)
                    {    // dwFontSim[] not initialized
                        // get FontBold/FontItalic
                        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
                        {
                            bGotStdVar = TRUE;
                            // update FontBold/FontItalic
                            dwFontSim[0] = pSV->StdVar[0].lStdVariable;
                            dwFontSim[1] = pSV->StdVar[1].lStdVariable;
                        }
                        else
                        {
                            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
                        }
                    }
                    // invoke CmdSelectDoubleByteMode
                    OEMCommandCallback(pdevobj, TEXT_DOUBLE_BYTE, 2, dwFontSim);
                }
// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubPairs:(0x%.2X,0x%.2X)\n"), aTrans[dwI].uCode.ubPairs[0], aTrans[dwI].uCode.ubPairs[1]));
                WRITESPOOLBUF(pdevobj, aTrans[dwI].uCode.ubPairs, 2);
            }
            else
            {    // Jpn
// DBGPRINT(DBG_WARNING, (DLLTEXT("TYPE_TRANSDATA:ubPairs:(0x%.2X,0x%.2X)\n"), aTrans[dwI].uCode.ubPairs[0], aTrans[dwI].uCode.ubPairs[1]));
                // EPSON specific
                // vertical period and comma must be shifted to upper right.
                BOOL AdjPos;
                int adjx, adjy;
                BYTE buf[32];
                DWORD cb;
// DEBUG
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_OK, L"Code = %.4x, Vertical = %d.\r\n",
       *((PWORD)aTrans[dwI].uCode.ubPairs), !!(lpEpage->fGeneral & (FLAG_VERT|FLAG_VERTPRN)));
#endif
// DEBUG
// #441440: PREFIX: "bGotStdVar" does not initialized if dwLCID == LCID_USA
                // 99/02/04
                // if ((lpEpage->fGeneral & FLAG_DOUBLE) && (aTrans[dwI].ubType & MTYPE_SINGLE))
                if (lpEpage->dwLCID != LCID_USA && (lpEpage->fGeneral & FLAG_DOUBLE) && (aTrans[dwI].ubType & MTYPE_SINGLE))
                {
                    if (!bGotStdVar)
                    {    // dwFontSim[] not initialized
                        // get FontBold/FontItalic
                        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 0, NULL))
                        {
                            bGotStdVar = TRUE;
                            // update FontBold/FontItalic
                            dwFontSim[0] = pSV->StdVar[0].lStdVariable;
                            dwFontSim[1] = pSV->StdVar[1].lStdVariable;
                        }
                        else
                        {
                            ERR(("UFO_GETINFO_STDVARIABLE failed.\r\n"));
                        }
                    }
                    // invoke CmdSelectSingleByteMode
                    OEMCommandCallback(pdevobj, TEXT_SINGLE_BYTE, 2, dwFontSim);
                }

                AdjPos = (*((PWORD)aTrans[dwI].uCode.ubPairs) == 0x2421 ||    // comma
                          *((PWORD)aTrans[dwI].uCode.ubPairs) == 0x2521) &&    // period
                         (lpEpage->fGeneral & (FLAG_VERT|FLAG_VERTPRN)) &&
                         !(lpEpage->fGeneral & FLAG_NOVPADJ);
                if (AdjPos)
                {
                    adjx = lpEpage->iSBCSX * VERT_PRINT_REL_X / 100;
                    adjy = lpEpage->iSBCSX * VERT_PRINT_REL_Y / 100;
// DEBUG
#ifdef    DBGMSGBOX
DbgMsg(lpEpage, MB_ICONINFORMATION, L"adjx = %d, adjy = %d.\r\n", adjx, adjy);
#endif
// DEBUG
                    cb = sprintf(buf, SET_REL_X, -adjx);
                    cb += sprintf(buf + cb, SET_REL_Y, -adjy);
                    WRITESPOOLBUF(pdevobj, buf, cb);
                }
                WRITESPOOLBUF(pdevobj, aTrans[dwI].uCode.ubPairs, 2);
                if (AdjPos)
                {
                    cb = sprintf(buf, SET_REL_X, adjx);
                    cb += sprintf(buf + cb, SET_REL_Y, adjy);
                    WRITESPOOLBUF(pdevobj, buf, cb);
                }
            }
            break;
        default:
            WARNING(("Unsupported TRANSDATA data type passed.\n"));
            WARNING(("jType=%02x, sCode=%x\n", aTrans[dwI].uCode.sCode, jType));
        }
    }

    if (NULL != aTrans)
    {
        MemFree(aTrans);
    }

    return TRUE;
}


//
// CheckAvailableMem : check available memory size
//    params
//        lpEpage    :    Pointer to the EPAGEMDV.
//        pUFObj    :    Pointer to the UNIFONTOBJ.
//    return
//        available memory size in bytes
//
DWORD CheckAvailableMem(LPEPAGEMDV lpEpage, PUNIFONTOBJ pUFObj)
{
    GETINFO_MEMORY meminfo;
    // get memory information
    meminfo.dwSize = sizeof(GETINFO_MEMORY);
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_MEMORY, &meminfo, 0, NULL))
    {
        ERR(("UFO_GETINFO_MEMORY failed.\r\n"));
        return 0;    // error
    }
    // DCR: Unidrv might return NEGATIVE value
    if ((long)meminfo.dwRemainingMemory < 0)
        meminfo.dwRemainingMemory = 0;
    if (lpEpage->dwMemAvailable != meminfo.dwRemainingMemory)
    {
        lpEpage->dwMemAvailable = meminfo.dwRemainingMemory;
//        DBGPRINT(DBG_WARNING, (DLLTEXT("Available memory = %d bytes\r\n"), meminfo.dwRemainingMemory));
    }
    return meminfo.dwRemainingMemory;
}

// DEBUG
#ifdef    DBGMSGBOX
#if defined(KERNEL_MODE) && !defined(USERMODE_DRIVER)
int DbgMsg(LPEPAGEMDV lpEpage, UINT mbicon, LPCTSTR msgfmt, ...)
{
    // can't do anything against GUI
    return 0;
}
int MsgBox(LPEPAGEMDV lpEpage, LPCTSTR msg, UINT mbicon)
{
    // can't do anything against GUI
    return 0;
}
#else    // Usermode
int DbgMsg(LPEPAGEMDV lpEpage, UINT mbicon, LPCTSTR msgfmt, ...)
{
    TCHAR buf[256];
    va_list va;
    va_start(va, msgfmt);
    wvsprintf((LPTSTR)buf, msgfmt, va);
    va_end(va);
    return MsgBox(lpEpage, buf, mbicon);
}

int MsgBox(LPEPAGEMDV lpEpage, LPCTSTR msg, UINT mbicon)
{
    int rc = IDOK;
    if (mbicon != MB_OK)
        lpEpage->fGeneral &= ~FLAG_SKIPMSG;
    if (!(lpEpage->fGeneral & FLAG_SKIPMSG))
    {
        if (IDCANCEL ==
            (rc = MessageBox(GetDesktopWindow(), msg, L"EPAGCRES", mbicon|MB_OKCANCEL)))
        {
            lpEpage->fGeneral |= FLAG_SKIPMSG;
        }
    }
    return rc;
}
#endif
#endif    // #ifdef    DBGMSGBOX
// DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epageres\sources.inc ===
#
# Common part of SOURCES file
#

MAJORCOMP=windows
MINORCOMP=md_epageres

#
# We assume PRNROOT is propery defined
#

!include $(PRNROOT)\print.inc

GPDLANG=$(ALT_PROJECT)

!ifndef DDKBUILDENV

GPDDIR=$(PRNROOT)\gpd\epson\$(GPDLANG)
GPDDIR_RI=$(PRNROOT)\gpd\ricoh\$(GPDLANG)
GPDDIR_TG=$(PRNROOT)\gpd\trg\$(GPDLANG)

!else

GPDDIR=$(PRNROOT)\mini\gpd\epson\$(GPDLANG)
GPDDIR_RI=$(PRNROOT)\mini\gpd\ricoh\$(GPDLANG)
GPDDIR_TG=$(PRNROOT)\mini\gpd\trg\$(GPDLANG)

!endif

INCLUDES=$(PRNROOT)\inc

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),epageres
!else
DLLBASE=0x8000000
!endif

UMTYPE=windows
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epageres\nt4\dllentry.cpp ===
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//		DllInitialize
//
//  PLATFORMS:	Windows NT
//
//

#include "pdev.h"

// Need to export these functions as c declarations.
extern "C" {

///////////////////////////////////////////////////////////
//
// DLL entry point
//

#ifndef WINNT_40

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#else // WINNT_40

// DllInitialize isn't called/used for user mode version.
BOOL WINAPI DllInitialize(ULONG ulReason)
{
	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));

            // In kernel mode version, initializes semaphore.
            DrvCreateInterlock();
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));

            // In kernel mode version, deletes semaphore.
            DrvDeleteInterlock();
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#endif // WINNT_40

}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\epageres\nt4\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

		98/9/3 v-yutah:
		Because of suggestion from ganeshp,
			Modified PublishDriverInterface(), and related to it,
			Modified EnableDriver(), DisableDriver()

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:

    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
#if	1	// Suggested by ganeshp
		// Need to return S_OK so that DisableDriver() will be called, which Releases
		// the reference to the Printer Driver's interface.
		return S_OK;
#else	// Suggested by ganeshp
        return E_NOTIMPL;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
#if	1	// Suggested by ganeshp
		// Release reference to Printer Driver's interface.
		if (this->pOEMHelp)
		{
			this->pOEMHelp->Release();
			this->pOEMHelp = NULL;
		}
		return S_OK;
#else	// Suggested by ganeshp
        return E_NOTIMPL;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        PDEVOEM pTemp;

        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

        if ((pTemp = OEMEnablePDEV(pdevobj, pPrinterName,
                cPatterns, phsurfPatterns, cjGdiInfo,
                pGdiInfo, cjDevInfo, pDevInfo, pded))) {
            *pDevOem = pTemp;
            return S_OK;
        }
        return E_FAIL;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
//      VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
#if	1	// Suggested by ganeshp
		// Need to store pointer to Driver Helper functions, if we already haven't.
		if (this->pOEMHelp == NULL)
		{
			HRESULT hResult;
			// Get Interface to Helper Functions.
			hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));
			if(!SUCCEEDED(hResult))
			{
				// Make sure that interface pointer reflects interface query failure.
				this->pOEMHelp = NULL;
				return E_FAIL;
			}
		}
		return S_OK;
#else	// Suggested by ganeshp
        if (this->pOEMHelp == NULL)
            pIUnknown->AddRef();
        this->pOEMHelp = reinterpret_cast<IPrintOemDriverUni*>(pIUnknown);
        return S_OK;
#endif	// Suggested by ganeshp
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    #ifdef DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    #ifdef DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
    #else // DOWNLOADFONT
        return E_NOTIMPL;
    #endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\eprstres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

!if "$(ALT_PROJECT)"=="CHP"
GPDLANG=CHS
!else
GPDLANG=$(ALT_PROJECT)
!endif

GPDDIR_EP=$(PRNROOT)\gpd\epson\$(GPDLANG)
GPDDIR_TG=$(PRNROOT)\gpd\trg\$(GPDLANG)

INCLUDES=$(PRNROOT)\inc

UMTYPE=windows

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),eprstres
!else
DLLBASE=0x8000000
!endif

RESOURCE_ONLY_DLL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\fmdebug.c ===
///////////////////////////////////////////////////
// fmdebug.c
//
// September.4,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#if DBG

#include <minidrv.h>

void dbgPrintf(LPSTR pszMsg, ...)
{
	va_list arg;
	va_start(arg, pszMsg);
	// DbgPrint("[fmblpres]", pszMsg, arg);
	va_end(arg);
}


#endif // DBG

// end of fmdebug.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\fmdebug.h ===
////////////////////////////////////////////////
// fudebug.h
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#ifndef fudebug_h
#define	fudebug_h

// 
// #if DBG && defined(TRACE_DDI)
// #define	TRACEDDI(a)	dbgPrintf a;
// #else
// #define	TRACEDDI(a)
// #endif
// 
// 
// #if DBG && defined(TRACE_OUT)
// #define	TRACEOUT(a)	dbgPrintf a;
// #else
// #define	TRACEOUT(a)
// #endif
// 
// #if DBG
// void dbgPrintf(LPSTR pszMsg, ...);
// #endif
// 

#define DDI_VERBOSE VERBOSE

#endif // !fudebug_h

// end of fudebug.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#ifdef USERMODE_DRIVER

#define INITGUID // for GUID one-time initialization

#include "fmlbp.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    // DbgPrint(DLLTEXT("IOemCB: QueryInterface entry\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ; 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ; 
    }
    else
    {
        *ppv = NULL ;
        // DbgPrint(DLLTEXT("IOemCB:Return NULL.\n")) ; 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    // DbgPrint(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release() 
{
    // DbgPrint(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    // DbgPrint(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    // DbgPrint(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    // DbgPrint(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    // DbgPrint(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    // DbgPrint(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    OEMDisablePDEV(pdevobj);
    return S_OK;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::GetInfo() entry.\r\n"));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    // DbgPrint(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    // DbgPrint(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'D':
#if 0
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;
#endif
                else if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'E':
#if 0
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
#if 0
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
#if 0
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'I':
#if 0
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'M':
#if 0
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
#if 0
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
#endif
                break;
        }
    }

    if (lReturn)
    {
        // DbgPrint(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        // DbgPrint(__TEXT("NOT supported\r\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    // DbgPrint(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    // DbgPrint(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    // if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
    //                     dwCallbackID, pIPParams))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    // DbgPrint(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));
    // pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuf, dwLen, &dwResult);
    
    // if (dwResult == dwLen)
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    // DbgPrint(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    // DbgPrint(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));
    //*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));
    //*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));
    //*pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    // DbgPrint(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));
    OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    return S_OK;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    // DbgPrint(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    return S_OK;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    // DbgPrint(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //// DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //// DbgPrint(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID) ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID) ;
}
#endif

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif // USERMODE_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\comoem.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\fmlbp.h ===
///////////////////////////////////////////////////////////////
// fmlbp.h
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997


#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define	FUFM_OEM_SIGNATURE	'FUFM'
#define	FUFM_OEM_VERSION	0x00010000L


typedef	const BYTE FAR*	LPCBYTE;


typedef struct tag_FUFM_OEM_EXTRADATA {
	OEM_DMEXTRAHEADER	dmExtraHdr;
} FUFM_OEM_EXTRADATA, *PFUFM_OEM_EXTRADATA;




#define WRITESPOOLBUF(pdevobj, s, n) \
	((pdevobj)->pDrvProcs->DrvWriteSpoolBuf((pdevobj), s, n))

#define	IS_VALID_FUFMPDEV(p) \
	((p) != NULL && (p)->dwSignature == FUFM_OEM_SIGNATURE)


#define	FUFM_MASTER_TO_DEVICE(p,d) \
	((p)->devData.dwResolution * (d) / FUFM_RESOLUTION_MASTER_UNIT)


// FUFMDATA.dwSizeReduction
#define	FUFM_SIZE_REDUCTION_100			0
#define	FUFM_SIZE_REDUCTION_75			1
#define	FUFM_SIZE_REDUCTION_70			2
#define	FUFM_SIZE_REDUCTION_UNKNOWN		((DWORD)-1)


// FUFMDATA.dwResolution
#define	FUFM_RESOLUTION_MASTER_UNIT		1200
#define	FUFM_RESOLUTION_240				240
#define	FUFM_RESOLUTION_400				400
#define	FUFM_RESOLUTION_UNKNOWN			((DWORD)-1)


// FUFMDATA.dwPaperSize
#define	FUFM_PAPERSIZE_A3					0x00000003
#define	FUFM_PAPERSIZE_A4					0x00000004
#define	FUFM_PAPERSIZE_A5					0x00000005
#define	FUFM_PAPERSIZE_B4					0x00010004
#define	FUFM_PAPERSIZE_B5					0x00010005
#define	FUFM_PAPERSIZE_LETTER				0x00030000
#define	FUFM_PAPERSIZE_LEGAL				0x00020000
#define	FUFM_PAPERSIZE_JAPANESE_POSTCARD	0x00040000
#define	FUFM_PAPERSIZE_CUSTOM_SIZE			0x00090000
#define	FUFM_PAPERSIZE_UNKNOWN				((DWORD)-1)


// FUFMDATA.dwPaperSource
#define	FUFM_PAPERSOURCE_AUTO				0x00010000
#define	FUFM_PAPERSOURCE_MANUAL				0x00000002
#define	FUFM_PAPERSOURCE_BIN1				0x00000000
#define	FUFM_PAPERSOURCE_BIN2				0x00000001
#define	FUFM_PAPERSOURCE_BIN3				0x00000003
#define	FUFM_PAPERSOURCE_UNKNOWN			((DWORD)-1)


// FUFMDATA.dwPaperOrientation
#define	FUFM_PAPERORIENTATION_PORTRAIT		0
#define	FUFM_PAPERORIENTATION_LANDSCAPE		1
#define	FUFM_PAPERORIENTATION_UNKNOWN		((DWORD)-1)


// FUFMDATA.dwFontAttributes
#define	FUFM_FONTATTR_BOLD					0x00000001
#define	FUFM_FONTATTR_ITALIC				0x00000002
#define	FUFM_FONTATTR_UNDERLINE				0x00000004
#define	FUFM_FONTATTR_STRIKEOUT				0x00000008


typedef struct tag_FUFMDATA {
	DWORD	dwSizeReduction;
	DWORD	dwResolution;
	DWORD	dwPaperSize;
	DWORD	dwPaperSource;
	DWORD	dwPaperOrientation;
	DWORD	dwCopies;
	DWORD	dwFontAttributes;
} FUFMDATA;


typedef	FUFMDATA*		PFUFMDATA;
typedef const FUFMDATA*	PCFUFMDATA;




// FUFMPDEV.dwEmMode
enum tag_FUFM_EMMODE {
	FUFM_EMMODE_FM,
	FUFM_EMMODE_ESCP
};

typedef	enum tag_FUFM_EMMODE	FUFM_EMMODE;


// FUFMPDEV.dwFlags
#define	FUFM_FLAG_SCALABLEFONT		0x0001
#define	FUFM_FLAG_QUICKRESET		0x0002
#define	FUFM_FLAG_PAPER3			0x0004

#define	FUFM_FLAG_START_JOB_0		0
#define	FUFM_FLAG_START_JOB_1		FUFM_FLAG_SCALABLEFONT
#define	FUFM_FLAG_START_JOB_2		(FUFM_FLAG_SCALABLEFONT | FUFM_FLAG_QUICKRESET)
#define	FUFM_FLAG_START_JOB_3		(FUFM_FLAG_SCALABLEFONT | FUFM_FLAG_QUICKRESET | FUFM_FLAG_PAPER3)
#define	FUFM_FLAG_START_JOB_4		FUFM_FLAG_PAPER3
// #251047: overlaps SBCS on vert mode
#define	FUFM_FLAG_VERTICALFONT		0x0008
// #284409: SBCS rotated on vert mode
#define	FUFM_FLAG_FONTROTATED 		0x0010



// FUFMPDEV.dwPosChanged
#define	FUFM_X_POSCHANGED			0x0001
#define	FUFM_Y_POSCHANGED			0x0002


typedef struct tag_FUFMPDEV {
	DWORD		dwSignature;
	FUFM_EMMODE	emMode;
	DWORD		dwFlags;

	DWORD		dwPosChanged;
	int			x;
	int			y;
	int			iLinefeedSpacing;
	int			cxfont;		//#144637

	DWORD		dwPaperWidth;
	DWORD		dwPaperLength;
	int			cyPage;

	FUFMDATA	devData;
	FUFMDATA	reqData;
} FUFMPDEV, *PFUFMPDEV;


// @Aug/31/98 ->
#define	MAX_COPIES_VALUE		999
// @Aug/31/98 <-

// Device font height and font width values calculated
// form the IFIMETRICS field values.  Must be the same way
// what Unidrv is doing to calculate stdandard variables.
// (Please check.)

#define FH_IFI(p) ((p)->fwdUnitsPerEm)
#define FW_IFI(p) ((p)->fwdAveCharWidth)

// end of fmlbp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\fmlbpres.c ===
/////////////////////////////////////////
// fmlbpres.c
//
// September.4,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#include "fmlbp.h"
#include "fmdebug.h"

// for lib.h debug
DWORD gdwDrvMemPoolTag = 'meoD';

enum FUFM_CEX_FLAGS {
    FUFM_CEX_CONTINUE    = 0x20,
    FUFM_CEX_SEPARATE    = 0x60,
    FUFM_CEX_TERMINATE    = 0x70
};


#define    CMDID_START_JOB_0                0
#define    CMDID_START_JOB_1                1
#define    CMDID_START_JOB_2                2
#define    CMDID_START_JOB_3                3
#define    CMDID_START_JOB_4                4

#define    CMDID_END_JOB                    9

#define    CMDID_EMMODE_FM                    10
#define    CMDID_EMMODE_ESCP                11

#define    CMDID_SIZE_REDUCTION_100        20
#define    CMDID_SIZE_REDUCTION_75            21
#define    CMDID_SIZE_REDUCITON_70            22

#define    CMDID_RESOLUTION_240            30
#define    CMDID_RESOLUTION_400            31

#define    CMDID_ORIENTATION_PORTRAIT        40
#define    CMDID_ORIENTATION_LANDSCAPE        41

#define    CMDID_PAPERSOURCE_AUTO            50
#define    CMDID_PAPERSOURCE_MANUAL        51
#define    CMDID_PAPERSOURCE_BIN1            52
#define    CMDID_PAPERSOURCE_BIN2            53
#define    CMDID_PAPERSOURCE_BIN3            54

#define    CMDID_FORM_A3                    60
#define    CMDID_FORM_A4                    61
#define    CMDID_FORM_A5                    62
#define    CMDID_FORM_B4                    63
#define    CMDID_FORM_B5                    64
#define    CMDID_FORM_LETTER                65
#define    CMDID_FORM_LEGAL                66
#define    CMDID_FORM_JAPANESE_POSTCARD    67
#define    CMDID_FORM_CUSTOM_SIZE            68

#define    CMDID_COPIES                    70

#define    CMDID_START_DOC                    80

#define    CMDID_START_PAGE                90

#define    CMDID_SET_LINEFEEDSPACING        100
#define    CMDID_FF                        101
#define    CMDID_CR                        102
#define    CMDID_LF                        103

#define    CMDID_X_MOVE                    110
#define    CMDID_Y_MOVE                    111

#define    CMDID_SEND_BLOCK                120


#define    CMDID_FONTATTR_BOLD_OFF            130
#define    CMDID_FONTATTR_BOLD_ON            131
#define    CMDID_FONTATTR_ITALIC_OFF        132
#define    CMDID_FONTATTR_ITALIC_ON        133
#define    CMDID_FONTATTR_UNDERLINE_OFF    134
#define    CMDID_FONTATTR_UNDERLINE_ON        135
#define    CMDID_FONTATTR_STRIKEOUT_OFF    136
#define    CMDID_FONTATTR_STRIKEOUT_ON        137

// #251047: overlaps SBCS on vert mode
#define    CMDID_SELECTSINGLE              140
#define    CMDID_SELECTDOUBLE              141



/////////////////////////////////////////////////

struct tag_FUFM_COMMAND{
    UINT    cbCommand;
    PBYTE    pbCommand;
};

typedef struct tag_FUFM_COMMAND            FUFM_COMMAND;
typedef    struct tag_FUFM_COMMAND*        PFUFM_COMMAND;
typedef    const struct tag_FUFM_COMMAND*    PCFUFM_COMMAND;

// KGS
const FUFM_COMMAND    g_cmd7Point            = { 6, "\x1C\x26\x27\x60\x27\x70" };
const FUFM_COMMAND    g_cmd9Point            = { 6, "\x1C\x26\x29\x60\x29\x70" };
const FUFM_COMMAND    g_cmd10halfPoint    = { 8, "\x1C\x26\x21\x20\x65\x21\x20\x75" };
const FUFM_COMMAND    g_cmd12Point        = { 8, "\x1C\x26\x21\x22\x60\x21\x22\x70" };

// TF + HSS2
const FUFM_COMMAND    g_cmdMinchou        = { 9, "\x1C\x28\x61\x70\x1BQ1 |" };
const FUFM_COMMAND    g_cmdGothic            = { 9, "\x1C\x28\x61\x71\x1BQ1 |" };

// HWF
const FUFM_COMMAND    g_cmdHWF            = { 2, "\x1CK" };

// VWF
const FUFM_COMMAND    g_cmdVWF            = { 7, "\x1CJ\x1BQ1 q" };

// #251047: overlaps SBCS on vert mode
const FUFM_COMMAND    g_cmdSingleMode     = { 3, "\x1B(H" };
const FUFM_COMMAND    g_cmdDoubleMode     = { 3, "\x1B$B" };


/////////////////////////////////////////////////


PBYTE fufmPutULONG(PBYTE pb, ULONG ulData)
{
    if(9 < ulData){
        pb = fufmPutULONG(pb, ulData / 10);
    }

    *pb++ = (BYTE)('0' + ulData % 10);
    return pb;
}


PBYTE fufmPutLONG(PBYTE pb, LONG lData)
{
    if(0 > lData){
        *pb++ = '-';
        lData = -lData;
    }
    return fufmPutULONG(pb, (ULONG)lData);
}



BYTE fufmGetHEX(int hi, int low)
{
    DWORD dwData = 0;

    if('0' <= hi && hi <= '9')
        dwData += (hi - '0');
    else if('a' <= hi && hi <= 'f')
        dwData += (hi - 'a') + 10;
    else if('A' <= hi && hi <= 'F')
        dwData += (hi - 'A') + 10;

    dwData *= 10;

    if('0' <= low && low <= '9')
        dwData += (low - '0');
    else if('a' <= low && low <= 'f')
        dwData += (low - 'a') + 10;
    else if('A' <= low && low <= 'F')
        dwData += (low - 'A') + 10;

    return (BYTE)dwData;
}


PBYTE    fufmPutCexParam(PBYTE pb, int iParam, int iFlag)
{
    if(iParam > 9){
        pb = fufmPutCexParam(pb, iParam / 10, FUFM_CEX_CONTINUE);
    }
    *pb++ = (BYTE)((iParam % 10) | iFlag);
    return pb;
}



PBYTE _cdecl fufmFormatCommand(PBYTE pbCmd, LPCSTR pszFmt, ...)
{
    LPCSTR    pch;
    LPBYTE    pb;
    
    va_list arg;
    va_start(arg, pszFmt);
    pb = pbCmd;
    for(pch = pszFmt; *pch != '\0'; ++pch){
        if(*pch == '%'){
            ++pch;
            switch(*pch){
              case 'd':        pb = fufmPutLONG(pb, va_arg(arg, LONG));            break;
              case 'u':          pb = fufmPutULONG(pb, va_arg(arg, ULONG));              break;
              case '%':        *pb++ = '%';                                        break;
              default:
                  VERBOSE(("[fufmFormatCommand]invalid seq. %%%c\r\n", *pch))
                  break;
            }
        }
#if 0
        else if(*pch == '\\'){
            ++pch;
            switch(*pch){
              case 'r':        *pb++ = '\x0d';        break;
              case 'n':        *pb++ = '\x0a';        break;
              case 'f':        *pb++ = '\x0c';        break;
              case '0':        *pb++ = '\x00';        break;
              case '\\':    *pb++ = '\\';        break;
              case 'x':          *pb++ = fufmGetHEX(pch[1], pch[2]);    pch += 2;      break;
              default:
                  VERBOSE(("[fufmFormatCommand]invalid seq. \\%c\r\n", *pch))
                  break;
            }
        }
#endif
        else{
            *pb++ = *pch;
        }
    }
    va_end(arg);

    return pb;
}



PBYTE    fufmPutCP(PBYTE pb, int iPitch)
{
    // CP
    *pb++ = 0x1c;
    *pb++ = 0x24;
    pb = fufmPutCexParam(pb, iPitch, FUFM_CEX_TERMINATE);
    return pb;
}


PBYTE    fufmPutCommand(PBYTE pb, const FUFM_COMMAND* pCmd)
{
    memcpy(pb, pCmd->pbCommand, pCmd->cbCommand);
    return pb + pCmd->cbCommand;
}



PBYTE fufmUpdatePosition(PBYTE pb, PFUFMPDEV pFufmPDEV)
{
    int        x;
    int        y;

    if(pFufmPDEV->dwPosChanged != 0){
        x = pFufmPDEV->x + 1;
        y = pFufmPDEV->y + 1;
        switch(pFufmPDEV->dwPosChanged){
          case FUFM_X_POSCHANGED:    // HPA command
            VERBOSE(("[fufmUpdatePosition]HPA %d\r\n", x))
            *pb++ = 0x1b;
            *pb++ = 0x5b;
            pb = fufmPutULONG(pb, x);
            *pb++ = 0x60;
            break;
          default:    // SAP command
            VERBOSE(("[fufmUpdatePosition]SAP %d %d\r\n", x, y))
            *pb++ = 0x1c;
            *pb++ = 0x22;
            pb = fufmPutCexParam(pb, x, FUFM_CEX_SEPARATE);
            pb = fufmPutCexParam(pb, y, FUFM_CEX_TERMINATE);
            break;
        }
        pFufmPDEV->dwPosChanged = 0;
    }
    return pb;
}



PBYTE fufmUpdateFontAttributes(PBYTE pb, PFUFMPDEV pFufmPDEV)
{
    DWORD dwAttributes;
    DWORD dwParam;

    if((pFufmPDEV->dwFlags & FUFM_FLAG_SCALABLEFONT) != 0){
        if(pFufmPDEV->devData.dwFontAttributes != pFufmPDEV->reqData.dwFontAttributes){
            pFufmPDEV->devData.dwFontAttributes = pFufmPDEV->reqData.dwFontAttributes;
            dwAttributes = pFufmPDEV->devData.dwFontAttributes;
            dwParam = 0;
            *pb++ = 0x1c;
            *pb++ = '*';
            if((dwAttributes & FUFM_FONTATTR_BOLD) != 0){
                *pb++ = (BYTE)(FUFM_CEX_SEPARATE + dwParam);
                dwParam = 1;
            }
            if((dwAttributes & FUFM_FONTATTR_ITALIC) != 0){
                *pb++ = (BYTE)(FUFM_CEX_SEPARATE + dwParam);
                dwParam = 3;
            }
            if((dwAttributes & FUFM_FONTATTR_UNDERLINE) != 0){
                *pb++ = (BYTE)(FUFM_CEX_SEPARATE + dwParam);
                dwParam = 4;
            }
            if((dwAttributes & FUFM_FONTATTR_STRIKEOUT) != 0){
                *pb++ = (BYTE)(FUFM_CEX_SEPARATE + dwParam);
                dwParam = 9;
            }
            *pb++ = (BYTE)(FUFM_CEX_TERMINATE + dwParam);
        }
    }

    return pb;
}



void fufmCmdStartDoc(PDEVOBJ pdevobj)
{
    PFUFMPDEV         pFufmPDEV;
    PCFUFMDATA        pReq;
    PFUFMDATA        pDev;
    PBYTE            pbCmd;
    BYTE            abCmd[256];
    BOOL            bResolutionCommandNeed;
    BOOL            bPaperCommandNeed;
    BOOL            bCopyCommandNeed;
    DWORD            dwPaperSize;
    DWORD            dwPaperWidth;
    DWORD            dwPaperLength;

    VERBOSE(("[fufmCmdStartDoc]\r\n"))

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pReq = &pFufmPDEV->reqData;
    pDev = &pFufmPDEV->devData;
    pbCmd = abCmd;

    bResolutionCommandNeed = TRUE;
    bPaperCommandNeed = FALSE;
    bCopyCommandNeed = TRUE;

    if(pDev->dwSizeReduction != pReq->dwSizeReduction){
        pDev->dwSizeReduction = pReq->dwSizeReduction;
        pbCmd = fufmFormatCommand(pbCmd, "\x1bQ%u!I", pDev->dwSizeReduction);
        bResolutionCommandNeed = TRUE;
        bPaperCommandNeed = TRUE;
    }

    if(bResolutionCommandNeed != FALSE || pDev->dwResolution != pReq->dwResolution){
        pDev->dwResolution = pReq->dwResolution;
        pbCmd = fufmFormatCommand(pbCmd, "\x1bQ%u!A", pDev->dwResolution);
        bPaperCommandNeed = TRUE;
        bCopyCommandNeed = TRUE;
        pDev->dwFontAttributes   = 0;
    }
 
     if(pDev->dwPaperSize != pReq->dwPaperSize){
         pDev->dwPaperSize = pReq->dwPaperSize;
         bPaperCommandNeed = TRUE;
     }
     if(pDev->dwPaperSource != pReq->dwPaperSource){
         pDev->dwPaperSource = pReq->dwPaperSource;
         bPaperCommandNeed = TRUE;
     }
     if(pDev->dwPaperOrientation != pReq->dwPaperOrientation){
         pDev->dwPaperOrientation = pReq->dwPaperOrientation;
         bPaperCommandNeed = TRUE;
     }
     if(bPaperCommandNeed != FALSE){
        dwPaperSize = pDev->dwPaperSize;
        if(dwPaperSize == FUFM_PAPERSIZE_CUSTOM_SIZE)
            dwPaperSize = FUFM_PAPERSIZE_A4;
        if(pDev->dwPaperSource != FUFM_PAPERSOURCE_AUTO){
            // PAPER command
            pbCmd = fufmFormatCommand(pbCmd,
                                    "\x1bQ%u;%u;%u;%u!@",
                                    HIWORD(dwPaperSize),
                                    LOWORD(dwPaperSize),
                                    LOWORD(pDev->dwPaperSource),
                                     pDev->dwPaperOrientation);
        }
        else{
             // PAPER2 command
             pbCmd = fufmFormatCommand(pbCmd,
                                     "\x1bQ%u;%u;%u!F",
                                     HIWORD(dwPaperSize),
                                     LOWORD(dwPaperSize),
                                     pDev->dwPaperOrientation);
         }
         if((pFufmPDEV->dwFlags & FUFM_FLAG_PAPER3) != 0 &&
                             pDev->dwPaperSize == FUFM_PAPERSIZE_CUSTOM_SIZE &&
                             pDev->dwPaperSource == FUFM_PAPERSOURCE_MANUAL){
             // PAPER3 command
             pbCmd = fufmFormatCommand(pbCmd,
                                    "\x1bQ9;%u;%u;%u!\\",
                                    pFufmPDEV->dwPaperWidth,
                                    pFufmPDEV->dwPaperLength,
                                    pDev->dwPaperOrientation);
         }
     }
 
    if(bCopyCommandNeed != FALSE || pDev->dwCopies != pReq->dwCopies){
        pDev->dwCopies = pReq->dwCopies;
        pbCmd = fufmFormatCommand(pbCmd, "\x1bQ%u!D", pDev->dwCopies);
    }

    if((pFufmPDEV->dwFlags & FUFM_FLAG_SCALABLEFONT) != 0){
        pbCmd = fufmFormatCommand(pbCmd, "\x1bQ1;0;1;1;0!Q\x1c*\x70");
    }

    if(pbCmd > abCmd){
        WRITESPOOLBUF(pdevobj, abCmd, (DWORD)(pbCmd - abCmd));
    }
}



void fufmCmdEmMode(PDEVOBJ pdevobj, FUFM_EMMODE emMode)
{
    PFUFMPDEV    pFufmPDEV;

    VERBOSE(("[fufmCmdChangeEM]%d\r\n", emMode))

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pFufmPDEV->emMode = emMode;
    if(pFufmPDEV->emMode == FUFM_EMMODE_ESCP){
        WRITESPOOLBUF(pdevobj, "\x1b/\xb2@\x7f", 5);
    }
}


void fufmCmdEndJob(PDEVOBJ pdevobj)
{
    PFUFMPDEV    pFufmPDEV;

    VERBOSE(("[fufmCmdEndJob]\r\n"))

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    if(pFufmPDEV->emMode == FUFM_EMMODE_ESCP){
        WRITESPOOLBUF(pdevobj, "\x1b\x7f\x00\x00\x01\x05", 6);
    }
    else if((pFufmPDEV->dwFlags & FUFM_FLAG_QUICKRESET) == 0){
        WRITESPOOLBUF(pdevobj, "\x1bQ0!d", 5);
    }
    else{
        WRITESPOOLBUF(pdevobj, "\x1b\x63", 2);
    }
}



void fufmCmdStartPage(PDEVOBJ pdevobj)
{
    PFUFMPDEV pFufmPDEV;

    VERBOSE(("[fufmCmdStartPage]\r\n"))

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pFufmPDEV->x = 0;
    pFufmPDEV->y = 0;
    pFufmPDEV->dwPosChanged = FUFM_X_POSCHANGED | FUFM_Y_POSCHANGED;
}


void fufmCmdEndPage(PDEVOBJ pdevobj)
{
    VERBOSE(("[fufmCmdEndPage]\r\n"))
}



void fufmCmdFormFeed(PDEVOBJ pdevobj)
{
    PFUFMPDEV pFufmPDEV;

    VERBOSE(("[fufmCmdFormFeed]\r\n"))
    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pFufmPDEV->x = 0;
    pFufmPDEV->y = 0;
    pFufmPDEV->dwPosChanged = FUFM_X_POSCHANGED | FUFM_Y_POSCHANGED;
    WRITESPOOLBUF(pdevobj, "\x0c", 1);
}



void fufmCmdCR(PDEVOBJ pdevobj)
{
    PFUFMPDEV pFufmPDEV;

    VERBOSE(("[fufmCmdCR]\r\n"))
    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pFufmPDEV->x = 0;
    pFufmPDEV->dwPosChanged |= FUFM_X_POSCHANGED;
}


void fufmCmdSetLinefeedSpacing(PDEVOBJ pdevobj, int iLinefeedSpacing)
{
    PFUFMPDEV pFufmPDEV;

    VERBOSE(("[fufmSetLinefeedSpacing]\r\n"))
    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pFufmPDEV->iLinefeedSpacing = iLinefeedSpacing;
}



void fufmCmdLF(PDEVOBJ pdevobj)
{
    PFUFMPDEV pFufmPDEV;

    VERBOSE(("[fufmCmdLF]\r\n"))
    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    pFufmPDEV->y += pFufmPDEV->iLinefeedSpacing;
    pFufmPDEV->dwPosChanged |= FUFM_Y_POSCHANGED;
}



INT fufmCmdXMove(PFUFMPDEV pFufmPDEV, PDWORD pdwParams)
{
    INT    x;

    VERBOSE(("[fufmCmdXMove] %d\r\n", pdwParams[0]))

      x = FUFM_MASTER_TO_DEVICE(pFufmPDEV, pdwParams[0]);
      if(x < 0)
          x = 0;
      if(x != pFufmPDEV->x){
          pFufmPDEV->x = x;
          pFufmPDEV->dwPosChanged |= FUFM_X_POSCHANGED;
      }
      return (INT)x;
}



INT fufmCmdYMove(PFUFMPDEV pFufmPDEV, PDWORD pdwParams)
{
    INT    y;

      VERBOSE(("[fufmCmdYMove] %d\n", pdwParams[0]))

      y = FUFM_MASTER_TO_DEVICE(pFufmPDEV, pdwParams[0]);
      if(y < 0)
          y = 0;
      if(y != pFufmPDEV->y){
          pFufmPDEV->y = y;
          pFufmPDEV->dwPosChanged |= FUFM_Y_POSCHANGED;
      }
      return (INT)y;
}



void fufmCmdSendBlock(PDEVOBJ pdevobj, PDWORD pdwParams)
{
    enum { FUFM_ZERO_DATA_SIZE = 512 };
    enum { FUFM_CY_BORDER = 180 };
    static BYTE abZeroData[FUFM_ZERO_DATA_SIZE];
    PFUFMPDEV    pFufmPDEV;
    DWORD        cbBlockData;
    DWORD        cBlockByteWidth;
    int            x;
    int            y;
    int            cyBorder;
    int            yBorder;
    int            cPadLine;
    int            cPadSize;
    PBYTE        pbCmd;
    BYTE        abCmd[64];

    DDI_VERBOSE(("[fufmCmdSendBlock]\r\n"))

    pFufmPDEV = pdevobj->pdevOEM;
    cbBlockData = pdwParams[0];
    cBlockByteWidth = pdwParams[1];

    x = pFufmPDEV->x + 1;
    y = pFufmPDEV->y + 1;
    cyBorder = FUFM_MASTER_TO_DEVICE(pFufmPDEV, FUFM_CY_BORDER);
    yBorder = pFufmPDEV->cyPage - cyBorder;
    cPadLine = y - yBorder;
    if(cPadLine < 0)
        cPadLine = 0;
    VERBOSE(("y %d yBorder %d cPadLine %d\r\n", y, yBorder, cPadLine))
    cPadSize = cPadLine * cBlockByteWidth;

    pbCmd = abCmd;
    if(pFufmPDEV->dwPosChanged != 0 || cPadLine > 0){
        // SAP command
        *pbCmd++ = 0x1c;
        *pbCmd++ = 0x22;
        pbCmd = fufmPutCexParam(pbCmd, x, FUFM_CEX_SEPARATE);
        pbCmd = fufmPutCexParam(pbCmd, y - cPadLine, FUFM_CEX_TERMINATE);
        pFufmPDEV->dwPosChanged = 0;
    }
    // RTGIMG command
    pbCmd = fufmFormatCommand(pbCmd,
                            "\x1bQ%u;%u;0!a",
                            cbBlockData + cPadSize,
                            cBlockByteWidth * 8);
    WRITESPOOLBUF(pdevobj, abCmd, (DWORD)(pbCmd - abCmd));

    if(cPadSize > 0){
        VERBOSE(("pad image %d lines\r\n", cPadLine))
        for(; cPadSize > FUFM_ZERO_DATA_SIZE; cPadSize -= FUFM_ZERO_DATA_SIZE)
            WRITESPOOLBUF(pdevobj, abZeroData, FUFM_ZERO_DATA_SIZE);
        WRITESPOOLBUF(pdevobj, abZeroData, cPadSize);
    }
}

// MINI5 Export func.
INT APIENTRY OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD     dwCmdCbID,
    DWORD     dwCount,
    PDWORD     pdwParams)
{
    PFUFMPDEV pFufmPDEV;

    DDI_VERBOSE(("[OEMCommandCallback]dwCmdCbID %d\r\n", dwCmdCbID))

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    if(IS_VALID_FUFMPDEV(pFufmPDEV) == FALSE)
        return 0;

    switch(dwCmdCbID){
      case CMDID_FF:                        fufmCmdFormFeed(pdevobj);                                                    break;
      case CMDID_CR:                        fufmCmdCR(pdevobj);                                                            break;
      case CMDID_SET_LINEFEEDSPACING:        fufmCmdSetLinefeedSpacing(pdevobj, (int)pdwParams[0]);                        break;
      case CMDID_LF:                        fufmCmdLF(pdevobj);                                                            break;

      case CMDID_X_MOVE:                    return fufmCmdXMove(pFufmPDEV, pdwParams);                                    // no break
      case CMDID_Y_MOVE:                    return fufmCmdYMove(pFufmPDEV, pdwParams);                                    // no break

      case CMDID_SEND_BLOCK:                fufmCmdSendBlock(pdevobj, pdwParams);                                        break;

      case CMDID_FONTATTR_BOLD_OFF:            pFufmPDEV->reqData.dwFontAttributes &= ~FUFM_FONTATTR_BOLD;                    break;
      case CMDID_FONTATTR_BOLD_ON:            pFufmPDEV->reqData.dwFontAttributes |= FUFM_FONTATTR_BOLD;                    break;
      case CMDID_FONTATTR_ITALIC_OFF:        pFufmPDEV->reqData.dwFontAttributes &= ~FUFM_FONTATTR_ITALIC;                break;
      case CMDID_FONTATTR_ITALIC_ON:        pFufmPDEV->reqData.dwFontAttributes |= FUFM_FONTATTR_ITALIC;                break;
      case CMDID_FONTATTR_UNDERLINE_OFF:    pFufmPDEV->reqData.dwFontAttributes &= ~FUFM_FONTATTR_UNDERLINE;            break;
      case CMDID_FONTATTR_UNDERLINE_ON:        pFufmPDEV->reqData.dwFontAttributes |= FUFM_FONTATTR_UNDERLINE;                break;
      case CMDID_FONTATTR_STRIKEOUT_OFF:    pFufmPDEV->reqData.dwFontAttributes &= ~FUFM_FONTATTR_STRIKEOUT;            break;
      case CMDID_FONTATTR_STRIKEOUT_ON:        pFufmPDEV->reqData.dwFontAttributes |= FUFM_FONTATTR_STRIKEOUT;                break;

// #251047: overlaps SBCS on vert mode
      case CMDID_SELECTSINGLE: {
        PBYTE   pb;
        BYTE    ab[256];

        pb = ab;
        pb = fufmPutCommand(pb, &g_cmdSingleMode);
// #284409: SBCS rotated on vert mode
//      if (pFufmPDEV->dwFlags & FUFM_FLAG_VERTICALFONT)
//          pb = fufmPutCommand(pb, &g_cmdHWF);
        if (pb > ab)
            WRITESPOOLBUF(pdevobj, ab, (DWORD)(pb - ab));
        break;
      }
      case CMDID_SELECTDOUBLE: {
        PBYTE   pb;
        BYTE    ab[256];

        pb = ab;
        pb = fufmPutCommand(pb, &g_cmdDoubleMode);
// #284409: SBCS rotated on vert mode
//      if (pFufmPDEV->dwFlags & FUFM_FLAG_VERTICALFONT)
//          pb = fufmPutCommand(pb, &g_cmdVWF);
        if (pb > ab)
            WRITESPOOLBUF(pdevobj, ab, (DWORD)(pb - ab));
        break;
      }

// PAGE_SETUP.1
      case CMDID_START_PAGE:                fufmCmdStartPage(pdevobj);                                                    break;

// DOC_SETUP.1
      case CMDID_SIZE_REDUCTION_100:        pFufmPDEV->reqData.dwSizeReduction = FUFM_SIZE_REDUCTION_100;                break;
      case CMDID_SIZE_REDUCTION_75:            pFufmPDEV->reqData.dwSizeReduction = FUFM_SIZE_REDUCTION_75;                break;
      case CMDID_SIZE_REDUCITON_70:            pFufmPDEV->reqData.dwSizeReduction = FUFM_SIZE_REDUCTION_70;                break;

// DOC_SETUP.2
      case CMDID_RESOLUTION_240:            pFufmPDEV->reqData.dwResolution = FUFM_RESOLUTION_240;                        break;
      case CMDID_RESOLUTION_400:            pFufmPDEV->reqData.dwResolution = FUFM_RESOLUTION_400;                        break;

// DOC_SETUP.3
      case CMDID_ORIENTATION_PORTRAIT:        pFufmPDEV->reqData.dwPaperOrientation = FUFM_PAPERORIENTATION_PORTRAIT;        break;
      case CMDID_ORIENTATION_LANDSCAPE:        pFufmPDEV->reqData.dwPaperOrientation = FUFM_PAPERORIENTATION_LANDSCAPE;    break;

// DOC_SETUP.4
      case CMDID_PAPERSOURCE_AUTO:            pFufmPDEV->reqData.dwPaperSource = FUFM_PAPERSOURCE_AUTO;                    break;
      case CMDID_PAPERSOURCE_MANUAL:        pFufmPDEV->reqData.dwPaperSource = FUFM_PAPERSOURCE_MANUAL;                    break;
      case CMDID_PAPERSOURCE_BIN1:            pFufmPDEV->reqData.dwPaperSource = FUFM_PAPERSOURCE_BIN1;                    break;
      case CMDID_PAPERSOURCE_BIN2:            pFufmPDEV->reqData.dwPaperSource = FUFM_PAPERSOURCE_BIN2;                    break;
      case CMDID_PAPERSOURCE_BIN3:            pFufmPDEV->reqData.dwPaperSource = FUFM_PAPERSOURCE_BIN3;                    break;
 
// DOC_SETUP.5
      case CMDID_FORM_A3:                    pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_A3;                            break;
      case CMDID_FORM_A4:                    pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_A4;                            break;
      case CMDID_FORM_A5:                    pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_A5;                            break;
      case CMDID_FORM_B4:                    pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_B4;                            break;
      case CMDID_FORM_B5:                    pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_B5;                            break;
      case CMDID_FORM_LETTER:                pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_LETTER;                        break;
      case CMDID_FORM_LEGAL:                pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_LEGAL;                        break;
      case CMDID_FORM_JAPANESE_POSTCARD:        pFufmPDEV->reqData.dwPaperSize = FUFM_PAPERSIZE_JAPANESE_POSTCARD;            break;

// DOC_SETUP.6
// @Aug/31/98 ->
    case CMDID_COPIES:
        if (MAX_COPIES_VALUE < pdwParams[0]) {
            pFufmPDEV->reqData.dwCopies = MAX_COPIES_VALUE;
        }
        else if (1 > pdwParams[0]) {
            pFufmPDEV->reqData.dwCopies = 1;
        }
        else {
            pFufmPDEV->reqData.dwCopies = pdwParams[0];
        }
// @Aug/31/98 <-
break;

// DOC_SETUP.7
      case CMDID_START_DOC:                    fufmCmdStartDoc(pdevobj);                                                    break;

// JOB_SETUP.1
      case CMDID_START_JOB_0:                pFufmPDEV->dwFlags = 0;                                                        break;
      case CMDID_START_JOB_1:                pFufmPDEV->dwFlags = FUFM_FLAG_START_JOB_1;                                    break;
      case CMDID_START_JOB_2:                pFufmPDEV->dwFlags = FUFM_FLAG_START_JOB_2;                                    break;
      case CMDID_START_JOB_3:                pFufmPDEV->dwFlags = FUFM_FLAG_START_JOB_3;                                    break;
      case CMDID_START_JOB_4:                pFufmPDEV->dwFlags = FUFM_FLAG_START_JOB_4;                                    break;

// JOB_SETUP.2
      case CMDID_EMMODE_FM:                    fufmCmdEmMode(pdevobj, FUFM_EMMODE_FM);                                        break;
      case CMDID_EMMODE_ESCP:                fufmCmdEmMode(pdevobj, FUFM_EMMODE_ESCP);                                    break;

// JOB_FINISH.1
      case CMDID_END_JOB:                    fufmCmdEndJob(pdevobj);                                                        break;
    }
    return 0;
}



void fufmGetPaperSize(PFUFMPDEV pFufmPDEV, const GDIINFO* pGdiInfo)
{
    pFufmPDEV->dwPaperWidth = pGdiInfo->ulHorzSize;
    if((LONG)pFufmPDEV->dwPaperWidth < 0)
        pFufmPDEV->dwPaperWidth = (-(LONG)pFufmPDEV->dwPaperWidth + 500) / 1000;

    pFufmPDEV->dwPaperLength = pGdiInfo->ulVertSize;
    if((LONG)pFufmPDEV->dwPaperLength < 0)
        pFufmPDEV->dwPaperLength = (-(LONG)pFufmPDEV->dwPaperLength + 500) / 1000;

    VERBOSE(("paper size %u %u\r\n", pFufmPDEV->dwPaperWidth, pFufmPDEV->dwPaperLength))
    VERBOSE(("printable area %u %u\r\n", pGdiInfo->ulHorzRes, pGdiInfo->ulVertRes))

    pFufmPDEV->cyPage = (int)pGdiInfo->ulVertRes;
}



void fufmInitData(PFUFMDATA pDev)
{
    pDev->dwSizeReduction        = FUFM_SIZE_REDUCTION_UNKNOWN;
    pDev->dwResolution            = FUFM_RESOLUTION_UNKNOWN;
    pDev->dwPaperSize            = FUFM_PAPERSIZE_UNKNOWN;
    pDev->dwPaperSource            = FUFM_PAPERSOURCE_UNKNOWN;
    pDev->dwPaperOrientation    = FUFM_PAPERORIENTATION_UNKNOWN;
    pDev->dwCopies                = (DWORD)-1;        // UNKNOWN
    pDev->dwFontAttributes        = 0;
}




// MINI5 Export func.
PDEVOEM APIENTRY OEMEnablePDEV(
    PDEVOBJ            pdevobj,
    PWSTR            pPrinterName,
    ULONG            cPatterns,
    HSURF*            phsurfPatterns,
    ULONG            cjGdiInfo,
    GDIINFO*        pGdiInfo,
    ULONG            cjDevInfo,
    DEVINFO*        pDevInfo,
    DRVENABLEDATA*    pded
    )
{
    PFUFMPDEV pFufmPDEV;

    DDI_VERBOSE(("[OEMEnablePDEV]" __DATE__ " " __TIME__ "\r\n"));

    pFufmPDEV = (PFUFMPDEV)MemAlloc(sizeof(FUFMPDEV));
    if(pFufmPDEV != NULL){
        pFufmPDEV->dwSignature = FUFM_OEM_SIGNATURE;
        pFufmPDEV->emMode = FUFM_EMMODE_FM;
        pFufmPDEV->dwFlags = 0;

        pFufmPDEV->dwPosChanged = FUFM_X_POSCHANGED | FUFM_Y_POSCHANGED;
        pFufmPDEV->x = 0;
        pFufmPDEV->y = 0;
        pFufmPDEV->iLinefeedSpacing = 0;

VERBOSE(("paper size %u %u\r\n", pGdiInfo->szlPhysSize.cx, pGdiInfo->szlPhysSize.cy))
        fufmGetPaperSize(pFufmPDEV, pGdiInfo);
        fufmInitData(&pFufmPDEV->devData);
        fufmInitData(&pFufmPDEV->reqData);
    }
    return pFufmPDEV;
}



// MINI5 Export func.
VOID APIENTRY OEMDisablePDEV(PDEVOBJ pdevobj)
{
    PFUFMPDEV pFufmPDEV;
    DDI_VERBOSE(("[OEMDisablePDEV]\r\n"));

    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    if(IS_VALID_FUFMPDEV(pFufmPDEV) == FALSE)
        return;

    MemFree(pdevobj->pdevOEM);
    pdevobj->pdevOEM = NULL;
}



// MINI5 Export func.
BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
    PFUFMPDEV pFufmPDEVOld;
    PFUFMPDEV pFufmPDEVNew;

    DDI_VERBOSE(("[OEMResetPDEV]\r\n"))

    pFufmPDEVOld = (PFUFMPDEV)pdevobjOld->pdevOEM;
    if(IS_VALID_FUFMPDEV(pFufmPDEVOld) == FALSE)
        return FALSE;

    pFufmPDEVNew = (PFUFMPDEV)pdevobjNew->pdevOEM;
    if(IS_VALID_FUFMPDEV(pFufmPDEVNew) == FALSE)
        return FALSE;

    pFufmPDEVNew->devData = pFufmPDEVOld->devData;

    return TRUE;
}


// MINI5 Export func.
VOID APIENTRY OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ    pUFObj,
    DWORD        dwType,
    DWORD        dwCount,
    PVOID        pGlyph
    )
{
    PFUFMPDEV        pFufmPDEV;
    GETINFO_GLYPHSTRING glyphStr;
    PBYTE        pb;
    BYTE        abBuff[256];
// #333653: Change I/F for GETINFO_GLYPHSTRING
    PTRANSDATA    pTrans, aTrans;
    DWORD        i;
    DWORD        cbNeeded;
    PDWORD        pdwGlyphID;
    INT        cxfont;        //#144637
// #284409: SBCS rotated on vert mode
    BYTE        ab[16];

    DDI_VERBOSE(("[OEMOutputCharStr]\r\n"))
    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    if(IS_VALID_FUFMPDEV(pFufmPDEV) == FALSE)
        return;

    pb = abBuff;
    pb = fufmUpdatePosition(pb, pFufmPDEV);
    pb = fufmUpdateFontAttributes(pb, pFufmPDEV);
    if(pb > abBuff){
        WRITESPOOLBUF(pdevobj, abBuff, (DWORD)(pb - abBuff));
    }

    switch(dwType){
      case TYPE_GLYPHHANDLE:
          VERBOSE(("TYPE_GLYPHHANDLE\r\n"))
          glyphStr.dwSize = sizeof(glyphStr);
          glyphStr.dwCount = dwCount;
          glyphStr.dwTypeIn = TYPE_GLYPHHANDLE;
          glyphStr.pGlyphIn = pGlyph;
          glyphStr.dwTypeOut = TYPE_TRANSDATA;
// #333653: Change I/F for GETINFO_GLYPHSTRING
          glyphStr.pGlyphOut = NULL;
          glyphStr.dwGlyphOutSize = 0;
          if(pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &glyphStr, sizeof(glyphStr), &cbNeeded) || !glyphStr.dwGlyphOutSize){
              VERBOSE(("UFO_GETINFO_GLYPHSTRING error\r\n"))
              return;
          }
          if((aTrans = (PTRANSDATA)MemAlloc(glyphStr.dwGlyphOutSize)) == NULL) {
              VERBOSE(("MemAlloc fail\r\n"))
              return;
          }
          glyphStr.pGlyphOut = aTrans;
          if(FALSE == pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &glyphStr, sizeof(glyphStr), &cbNeeded)){
              VERBOSE(("UFO_GETINFO_GLYPHSTRING error\r\n"))
              goto out;
          }
        pTrans = aTrans;
        cxfont = pFufmPDEV->cxfont;    //#144637
        for(i = dwCount; i > 0; --i){
            VERBOSE(("TYPE_TRANSDATA:ubCodePageID:0x%x ubType:0x%x\r\n", pTrans->ubCodePageID, pTrans->ubType))
            switch(pTrans->ubType & (MTYPE_FORMAT_MASK | MTYPE_DOUBLEBYTECHAR_MASK)){
              case MTYPE_DIRECT:
              case MTYPE_DIRECT | MTYPE_SINGLE:
              case MTYPE_DIRECT | MTYPE_DOUBLE:
// #284409: SBCS rotated on vert mode
                  if (pFufmPDEV->dwFlags & FUFM_FLAG_VERTICALFONT) {
                      if (pFufmPDEV->dwFlags & FUFM_FLAG_FONTROTATED) {
                          pb = fufmPutCommand(ab, &g_cmdHWF);
                          if (pb > ab)
                              WRITESPOOLBUF(pdevobj, ab, (DWORD)(pb - ab));
                          pFufmPDEV->dwFlags &= ~FUFM_FLAG_FONTROTATED;
                      }
                  }
                  WRITESPOOLBUF(pdevobj, &pTrans->uCode.ubCode, 1);
                pFufmPDEV->x += (cxfont / 2);    //#144637
                  break;
              case MTYPE_PAIRED:
              case MTYPE_PAIRED | MTYPE_DOUBLE:
// #284409: SBCS rotated on vert mode
                  if (pFufmPDEV->dwFlags & FUFM_FLAG_VERTICALFONT) {
                      if (!(pFufmPDEV->dwFlags & FUFM_FLAG_FONTROTATED)) {
                          pb = fufmPutCommand(ab, &g_cmdVWF);
                          if (pb > ab)
                              WRITESPOOLBUF(pdevobj, ab, (DWORD)(pb - ab));
                          pFufmPDEV->dwFlags |= FUFM_FLAG_FONTROTATED;
                      }
                  }
                  WRITESPOOLBUF(pdevobj, pTrans->uCode.ubPairs, 2);
                pFufmPDEV->x += cxfont;    //#144637
                  break;
              case MTYPE_PAIRED | MTYPE_SINGLE:
// #284409: SBCS rotated on vert mode
                  if (pFufmPDEV->dwFlags & FUFM_FLAG_VERTICALFONT) {
                      if (pFufmPDEV->dwFlags & FUFM_FLAG_FONTROTATED) {
                          pb = fufmPutCommand(ab, &g_cmdHWF);
                          if (pb > ab)
                              WRITESPOOLBUF(pdevobj, ab, (DWORD)(pb - ab));
                          pFufmPDEV->dwFlags &= ~FUFM_FLAG_FONTROTATED;
                      }
                  }
                  WRITESPOOLBUF(pdevobj, &pTrans->uCode.ubPairs[1], 1);
                pFufmPDEV->x += (cxfont / 2);    //#144637
                  break;
            }
            ++pTrans;
        }
out:
          MemFree(aTrans);
          break;
      case TYPE_GLYPHID:
          VERBOSE(("TYPE_GLYPHID\r\n"))
          pdwGlyphID = (PDWORD)pGlyph;
        for(i = dwCount; i > 0; --i){
            VERBOSE(("TYPE_GLYPHID:0x%x\r\n", *pdwGlyphID))
            WRITESPOOLBUF(pdevobj, (PBYTE)pGlyph, 1);
            ++pdwGlyphID;
        }
        break;
      case TYPE_TRANSDATA:
          VERBOSE(("TYPE_TRANSDATA\r\n"))
          break;
      case TYPE_UNICODE:
          VERBOSE(("TYPE_UNICODE\r\n"))
          break;
    }
}



VOID APIENTRY OEMSendFontCmd(
    PDEVOBJ            pdevobj,
    PUNIFONTOBJ        pUFObj,
    PFINVOCATION    pFInv
    )
{
    PFUFMPDEV        pFufmPDEV;
    enum { CB_STDVAR_2 = sizeof(GETINFO_STDVAR) + sizeof(DWORD) * 2 * (2 - 1) };
    PGETINFO_STDVAR pSV;
    DWORD            adwStdVarBuff[(CB_STDVAR_2 + sizeof(DWORD) - 1) / sizeof(DWORD)];
    DWORD            cbNeeded;
    DWORD            i;
    LONG            cxFont;
    LONG            cyFont;
    DWORD            dwResolution;
    PBYTE            pbCmd;
    BYTE            abCmd[256];

    PIFIMETRICS pIFI = pUFObj->pIFIMetrics;

#define SV_HEIGHT (pSV->StdVar[0].lStdVariable)
#define SV_WIDTH (pSV->StdVar[1].lStdVariable)

    DDI_VERBOSE(("[OEMSendFontCmd]FontID:%d dwFlags:%x\r\n", pUFObj->ulFontID, pUFObj->dwFlags))
    pFufmPDEV = (PFUFMPDEV)pdevobj->pdevOEM;
    if(IS_VALID_FUFMPDEV(pFufmPDEV) == FALSE)
        return;

    pSV = (PGETINFO_STDVAR)adwStdVarBuff;
    pSV->dwSize = CB_STDVAR_2;
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, &cbNeeded)) {
        VERBOSE(("UFO_GETINFO_STDVARIABLE failed.\r\n"))
        return;
    }

    VERBOSE(("FNT_INFO_FONTHEIGHT %d\r\n", pSV->StdVar[0].lStdVariable))
    VERBOSE(("FNT_INFO_FONTWIDTH  %d\r\n", pSV->StdVar[1].lStdVariable))

    // this printer requires DBCS cell (square, if not stretched)
    // X/Y sizes as X/Y values for scalable font command.

    cyFont = FUFM_MASTER_TO_DEVICE(pFufmPDEV, pSV->StdVar[0].lStdVariable);
    cxFont = cyFont
        * SV_WIDTH * FH_IFI(pIFI) / SV_HEIGHT / FW_IFI(pIFI);

    pFufmPDEV->cxfont = cxFont;    //#144637

    dwResolution = pFufmPDEV->devData.dwResolution;

    VERBOSE(("dwResolution %u cxFont %u cyFont %u\r\n", dwResolution, cxFont, cyFont))

    pbCmd = abCmd;
    for(i = 0; i < pFInv->dwCount; ++i){
        switch(pFInv->pubCommand[i]){
          case 'a': // 7point non scalable font
              pbCmd = fufmPutCommand(pbCmd, &g_cmd7Point);
            pbCmd = fufmPutCP(pbCmd, (dwResolution != 400)? 24: 40);
              break;
          case 'b': // 9point non scalable font
              pbCmd = fufmPutCommand(pbCmd, &g_cmd9Point);
              pbCmd = fufmPutCP(pbCmd, (dwResolution != 400)? 30: 50);
              break;
          case 'c': // 10.5point non scalable font
              pbCmd = fufmPutCommand(pbCmd, &g_cmd10halfPoint);
              pbCmd = fufmPutCP(pbCmd, (dwResolution != 400)? 36: 60);
              break;
          case 'd':    // 12point non scalable font
              pbCmd = fufmPutCommand(pbCmd, &g_cmd12Point);
              pbCmd = fufmPutCP(pbCmd, (dwResolution != 400)? 40: 66);
              break;

          case 's':    // scalable font
              if (cyFont == cxFont) {
                  pbCmd = fufmFormatCommand(pbCmd,
                      "\x1BQ%u!R", cyFont);
              }
              else {
                  pbCmd = fufmFormatCommand(pbCmd,
                      "\x1BQ%u;%u!R", cyFont, cxFont);
              }
              pbCmd = fufmPutCP(pbCmd, cxFont);
              break;

          case 'H':    // HWF
              pFufmPDEV->dwFlags &= ~FUFM_FLAG_VERTICALFONT;
              pbCmd = fufmPutCommand(pbCmd, &g_cmdHWF);
// #284409: SBCS rotated on vert mode
              pFufmPDEV->dwFlags &= ~FUFM_FLAG_FONTROTATED;
              break;
          case 'V':    // VWF
              pFufmPDEV->dwFlags |= FUFM_FLAG_VERTICALFONT;
// #284409: SBCS rotated on vert mode
              // pbCmd = fufmPutCommand(pbCmd, &g_cmdVWF);
              break;

          case 'M':    // Minchou
              pbCmd = fufmPutCommand(pbCmd, &g_cmdMinchou);
              break;
          case 'G':    // Gothic
              pbCmd = fufmPutCommand(pbCmd, &g_cmdGothic);
              break;
        }
    }
    if(pbCmd > abCmd)
        WRITESPOOLBUF(pdevobj, abCmd, (DWORD)(pbCmd - abCmd));
}


// end of fmlbpres.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\fmlbpdm.c ===
///////////////////////////////////////////////////
// fmlbpdm.c
//
// September.4,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#include "fmlbp.h"
#include "fmdebug.h"

#ifdef KERNEL_MODE

#define	SETLASTERROR(e)	EngSetLastError(e)

#else // !KERNEL_MODE

#define	SETLASTERROR(e)	SetLastError(e)

#endif // !KERNEL_MODE


// MINI5 Export func.
BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
	VERBOSE(("[OEMGetInfo]\r\n"))

	if(pcbNeeded == NULL){
  		SETLASTERROR(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

  	*pcbNeeded = sizeof(DWORD);
  	if(NULL == pBuffer || sizeof(DWORD) > cbSize){
  		SETLASTERROR(ERROR_INSUFFICIENT_BUFFER);
  		return FALSE;
  	}

	switch(dwInfo){
	  case OEMGI_GETSIGNATURE:
		VERBOSE(("OEMGI_GETSIGNATURE\r\n"))
	  	*(LPDWORD)pBuffer = FUFM_OEM_SIGNATURE;
	  	break;
	  case OEMGI_GETINTERFACEVERSION:
		VERBOSE(("OEMGI_GETINTERFACEVERSION\r\n"))
	  	*(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
	  	break;
	  case OEMGI_GETVERSION:
		VERBOSE(("OEMGI_GETVERSION\r\n"))
	  	*(LPDWORD)pBuffer = FUFM_OEM_VERSION;
	  	break;
	  default:
		VERBOSE(("invalid dwInfo\r\n"))
	  	SETLASTERROR(ERROR_INVALID_PARAMETER);
		return FALSE;
	}
	return TRUE;
}



static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
    if(NULL == pOEMDevModeParam){
    	VERBOSE(("pOEMDevModeParam is NULL\r\n"))
    	return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize){
    	VERBOSE(("pOEMDevModeParam->cbSize (%d) is less than sizeof(OEMDMPARAM)\r\n", pOEMDevModeParam->cbSize))
        return FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter){
		VERBOSE(("pOEMDevModeParam->hPrinter is NULL\r\n"))
		return FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule){
		VERBOSE(("pOEMDevModeParam->hModule is NULL\r\n"))
        return FALSE;
    }

    if((0 != pOEMDevModeParam->cbBufSize) && (NULL == pOEMDevModeParam->pOEMDMOut)){
		VERBOSE(("pOEMDevModeParam->cbBufSize is not 0, and, pOEMDMOut is NULL\r\n"))
		return FALSE;
    }

    if((OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn)){
		VERBOSE(("dwMode is OEMDM_MERGE && pOEMDMIn is NULL\r\n"))
		return FALSE;
    }

    return TRUE;
}



static void fufmInitOEMExtraData(PFUFM_OEM_EXTRADATA pFufmOEMExtra)
{
	pFufmOEMExtra->dmExtraHdr.dwSize = sizeof(FUFM_OEM_EXTRADATA);
	pFufmOEMExtra->dmExtraHdr.dwSignature = FUFM_OEM_SIGNATURE;
	pFufmOEMExtra->dmExtraHdr.dwVersion = FUFM_OEM_VERSION;
}



static void fufmMergeOEMExtraData(
	PFUFM_OEM_EXTRADATA pFufmOEMExtraIn,
	PFUFM_OEM_EXTRADATA pFufmOEMExtraOut)
{
}



// MINI5 Export func.
BOOL APIENTRY OEMDevMode(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
	VERBOSE(("[OEMDevMode]\r\n"))

	if(BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam) == FALSE){
		VERBOSE(("invalid OEMDevModeParam\r\n"))
		SETLASTERROR(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	if(dwMode == OEMDM_SIZE){
		pOEMDevModeParam->cbBufSize = sizeof(FUFM_OEM_EXTRADATA);
		VERBOSE(("OEMDM_SIZE %d\r\n", pOEMDevModeParam->cbBufSize))
		return TRUE;
	}

	if(sizeof(FUFM_OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize){
		VERBOSE(("cbBufSize %d\r\n", pOEMDevModeParam->cbBufSize))
  		SETLASTERROR(ERROR_INSUFFICIENT_BUFFER);
		return FALSE;
	}

	switch(dwMode){
	  case OEMDM_DEFAULT:
		VERBOSE(("OEMDM_DEFAULT\r\n"));
	  	fufmInitOEMExtraData((PFUFM_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
		break;
	  case OEMDM_CONVERT:
		VERBOSE(("OEMDM_CONVERT\r\n"));
	  	fufmInitOEMExtraData((PFUFM_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
		break;
	  case OEMDM_MERGE:
		VERBOSE(("OEMDM_MERGE\r\n"));
		fufmMergeOEMExtraData((PFUFM_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
							(PFUFM_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
		break;
	  default:
		VERBOSE(("invalid dwMode\r\n"));
	  	SETLASTERROR(ERROR_INVALID_PARAMETER);
	  	return FALSE;
	  	break;
	}
	return TRUE;
}



// end of fmlbpdm.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sources.

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\fuj\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=fmlbpres
TARGETPATH=obj
TARGETTYPE=DYNLINK

INCLUDES=$(PRNROOT)\inc

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),fmlbpres
!else
DLLBASE=0x8000000
!endif

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\fmlbpres.rc \
    $(SRCDIR)\fmlbpres.c \
    $(SRCDIR)\fmlbpdm.c \
    $(SRCDIR)\fmdebug.c

MISCFILES=\
    $(SRCDIR)\fmlbpres.ini \
    $(GPDDIR)\fufm101j.gpd \
    $(GPDDIR)\fufm102j.gpd \
    $(GPDDIR)\fufm111j.gpd \
    $(GPDDIR)\fufm112j.gpd \
    $(GPDDIR)\fufm114j.gpd \
    $(GPDDIR)\fufm115j.gpd \
    $(GPDDIR)\fufm121j.gpd \
    $(GPDDIR)\fufm12aj.gpd \
    $(GPDDIR)\fufm14aj.gpd \
    $(GPDDIR)\fufm15aj.gpd \
    $(GPDDIR)\fufm212j.gpd \
    $(GPDDIR)\fufm21pj.gpd \
    $(GPDDIR)\fufm222j.gpd \
    $(GPDDIR)\fufm224j.gpd \
    $(GPDDIR)\fufm226j.gpd \
    $(GPDDIR)\fufm227j.gpd \
    $(GPDDIR)\fufm22aj.gpd \
    $(GPDDIR)\fufm23dj.gpd \
    $(GPDDIR)\fufm3d2j.gpd \
    $(GPDDIR)\fufmlbpj.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\name.h ===
CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\nt4\dllentry.cpp ===
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//		DllInitialize
//
//  PLATFORMS:	Windows NT
//
//

#include "pdev.h"

// Need to export these functions as c declarations.
extern "C" {

///////////////////////////////////////////////////////////
//
// DLL entry point
//

#ifndef WINNT_40

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#else // WINNT_40

// DllInitialize isn't called/used for user mode version.
BOOL WINAPI DllInitialize(ULONG ulReason)
{
	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));

            // In kernel mode version, initializes semaphore.
            DrvCreateInterlock();
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));

            // In kernel mode version, deletes semaphore.
            DrvDeleteInterlock();
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#endif // WINNT_40

}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\nt4\pdev.h ===
#include "fmlbp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fmlbpres\nt4\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


#define INITGUID // for GUID one-time initialization

#include "fmlbp.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    // DbgPrint(DLLTEXT("IOemCB: QueryInterface entry\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ; 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ; 
    }
    else
    {
        *ppv = NULL ;
        // DbgPrint(DLLTEXT("IOemCB:Return NULL.\n")) ; 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    // DbgPrint(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release() 
{
    // DbgPrint(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    // DbgPrint(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    // DbgPrint(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    // DbgPrint(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    // DbgPrint(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    // DbgPrint(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    OEMDisablePDEV(pdevobj);
    return S_OK;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::GetInfo() entry.\r\n"));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    // DbgPrint(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    // DbgPrint(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'D':
#if 0
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;
#endif
                else if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'E':
#if 0
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
#if 0
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
#if 0
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'I':
#if 0
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'M':
#if 0
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
#if 0
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
#endif
                break;
        }
    }

    if (lReturn)
    {
        // DbgPrint(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        // DbgPrint(__TEXT("NOT supported\r\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    // DbgPrint(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    // DbgPrint(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    // if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
    //                     dwCallbackID, pIPParams))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    // DbgPrint(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));
    // pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuf, dwLen, &dwResult);
    
    // if (dwResult == dwLen)
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    // DbgPrint(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    // DbgPrint(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));
    //*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));
    //*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));
    //*pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    // DbgPrint(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));
    OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    return S_OK;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    // DbgPrint(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    return S_OK;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    // DbgPrint(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //// DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //// DbgPrint(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID) ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID) ;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuprjres\debug.c ===
#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuprjres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//

class IOemCB : public IPrintOemUni
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        REFIID riid,
        PVOID *ppv)
    {
        if (riid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown *>(this); 
        }
        else if (riid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni *>(this);
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }

        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (0 == InterlockedDecrement(&m_cRef))
        {
            delete this ;
            return 0;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\r\n")));
        if (OEMDevMode(dwMode, pOemDMParam))
            return S_OK;
        else
            return S_FALSE;
    }

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\r\n")));
        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // IPrintOemEngine methods
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\r\n")));

        return S_OK;
    }

    STDMETHODIMP
    DisableDriver()
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\r\n")));

        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
    }

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ pdevobj,
        PWSTR pPrinterName,
        ULONG cPatterns,
        HSURF *phsurfPatterns,
        ULONG cjGdiInfo,
        GDIINFO *pGdiInfo,
        ULONG cjDevInfo,
        DEVINFO *pDevInfo,
        DRVENABLEDATA *pded,
        PDEVOEM *pDevOem)
    {
        PDEVOEM pTemp;

        pTemp = OEMEnablePDEV(pdevobj,
            pPrinterName, cPatterns, phsurfPatterns,
            cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

        if (NULL == pTemp) {
            return E_FAIL;
        }

        //
        // Save necessary helpder function addresses.
        //

        ((MINIDEV *)pTemp)->pIntf = this->pOEMHelp;
        *pDevOem = pTemp;

        return S_OK;
    }

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        VERBOSE(((DLLTEXT("IOemCB::DisablePDEV() entry.\n"))));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // IPrintOemUni methods
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n")));

        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(
                IID_IPrintOemDriverUni,
                (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                this->pOEMHelp = NULL;
                return E_FAIL;
            }
        }

        return S_OK;
    }

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_FAIL;

        if (NULL != pMethodName) {

            PSTR pTemp;

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE(("GetImplementedMethod: %s - %d\n",
            pMethodName, lRet));

        return lRet;
    }

    STDMETHODIMP
    DriverDMS(
        PVOID pDevObj,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ     pdevobj,
        DWORD       dwCallbackID,
        DWORD       dwCount,
        PDWORD      pdwParams,
        OUT INT     *piResult)
    {
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\r\n")));
        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ pdevobj,
        PBYTE pSrcBitmap,
        PBITMAPINFOHEADER pBitmapInfoHeader,
        PBYTE pColorTable,
        DWORD dwCallbackID,
        PIPPARAMS pIPParams,
        PBYTE *ppbResult)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    Compression(
        PDEVOBJ pdevobj,
        PBYTE pInBuf,
        PBYTE pOutBuf,
        DWORD dwInLen,
        DWORD dwOutLen,
        INT *piResult)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ pdevobj,
        PBYTE pHTPattern,
        DWORD dwHTPatternX,
        DWORD dwHTPatternY,
        DWORD dwHTNumPatterns,
        DWORD dwCallbackID,
        PBYTE pResource,
        DWORD dwResourceSize)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ pdevobj,
        POEMMEMORYUSAGE pMemoryUsage)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ pdevobj,
        DWORD dwInfoIndex,
        PVOID pOutputBuf,
        DWORD dwSize,
        DWORD *pcbcNeeded)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD *pdwResult)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH hGlyph,
        PDWORD pdwWidth,
        DWORD *pdwResult)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD *pdwResult)
    {
        return E_NOTIMPL;
    }

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD dwType,
        DWORD dwCount,
        PVOID pGlyph)
    {
        VERBOSE(("OutputCharStr\n"));
        OEMOutputCharStr(pdevobj,
                pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ pdevobj,
        PUNIFONTOBJ pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\r\n")));
        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    STDMETHODIMP
    TextOutAsBitmap(
       SURFOBJ *pso,
       STROBJ *pstro,
       FONTOBJ *pfo,
       CLIPOBJ *pco,
       RECTL *prclExtra,
       RECTL *prclOpaque,
       BRUSHOBJ *pboFore,
       BRUSHOBJ *pboOpaque,
       POINTL *pptlOrg,
       MIX mix)
    {
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};


//
// Make the Unidrv helper functions (defined in C++)
// accesible to C.
//

extern "C" {

    //
    // DrvWriteSpoolBuf()
    //
    HRESULT
    XXXDrvWriteSpoolBuf(
        VOID *pIntf,
        PDEVOBJ pdevobj,
        PVOID pBuffer,
        DWORD cbSize,
        DWORD *pdwResult) {

            return ((IPrintOemDriverUni *)pIntf)->DrvWriteSpoolBuf(
                pdevobj,
                pBuffer,
                cbSize,
                pdwResult);
        }

}

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        REFIID riid,
        PVOID *ppv)
    {
        if ((riid == IID_IUnknown) || (riid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }

        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (0 == InterlockedDecrement(&m_cRef))
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

    STDMETHODIMP
    CreateInstance(
        LPUNKNOWN pUnknownOuter,
        const IID& iid,
        void **ppv)
    {

        // Cannot aggregate.
        if (pUnknownOuter != NULL)
        {
            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (pOemCB == NULL)
        {
            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr;
    }

    STDMETHODIMP
    LockServer(
        BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructors
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};


///////////////////////////////////////////////////////////
//
// Export functions
//

STDAPI
DllCanUnloadNow(
    VOID)
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

STDAPI
DllGetClassObject(
    const CLSID& clsid,
    const IID& iid,
    void** ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory."))) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuprjres\common.c ===
#include "pdev.h" 

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING,("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DBGPRINT(DBG_WARNING,("\tcbSize = %d.\r\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING,("\thPrinter = %#lx.\r\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING,("\thModule = %#lx.\r\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING,("\tpPublicDMIn = %#lx.\r\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING,("\tpPublicDMOut = %#lx.\r\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING,("\tpOEMDMIn = %#lx.\r\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING,("\tpOEMDMOut = %#lx.\r\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING,("\tcbBufSize = %d.\r\n", pOEMDevModeParam->cbBufSize));
    }
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        //DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        //DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        //DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        //DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        //DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        //DBGPRINT(DBG_WARNING,("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////
BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
	// Initialize OEM Extra data.
	pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
	pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
	pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

	return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////
BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
	if(pdmIn) {
		//
		// copy over the private fields, if they are valid
		//
	}
	return TRUE;
}
/***************************************************************************
    Function Name : OEMGetInfo

    Note          : Make this.                               09/26/97
***************************************************************************/
BOOL APIENTRY OEMGetInfo(
DWORD dwInfo,
PVOID pBuffer,
DWORD cbSize,
PDWORD pcbNeeded
){
    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
	// wPaperSource + bFirstPage
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }
    return TRUE;
}
/***************************************************************************
    Function Name : OEMDevMode

    Note          : Make this.                               09/26/97
***************************************************************************/
BOOL APIENTRY OEMDevMode(
DWORD 			dwMode,
POEMDMPARAM 	pOEMDevModeParam
){
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        //DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n")));
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        //DBGPRINT(DBG_WARNING,(ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            //DBGPRINT(DBG_WARNING,("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuprjres\fuprjres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------
// 08/08/94 Wrote it. by Hayakawa, Task.
//

#define _FUPRJRES_C
#include "pdev.h"

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

/***************************************************************************
    Function Name : SheetFeed

    Parameters    : LPDV	lpdv		Private Device Structure

    Note          : Make this.                               09/13/94 Task
***************************************************************************/
void SheetFeed(
PDEVOBJ pdevobj
){
	USHORT 				bFirstPage;
	DEVICE_DATA *pOEM;
    DWORD dwResult;

	//
	// verify pdevobj okay
	//
	ASSERT(VALID_PDEVOBJ(pdevobj));

	pOEM = (DEVICE_DATA *)MINIDEV_DATA(pdevobj);

	bFirstPage = (USHORT)pOEM->bFirstPage;

	if ((pOEM->wPaperSource == DMBIN_180BIN1) ||
		(pOEM->wPaperSource == DMBIN_180BIN2) ||
		(pOEM->wPaperSource == DMBIN_360BIN1) ||
		(pOEM->wPaperSource == DMBIN_360BIN2) ||
		(pOEM->wPaperSource == DMBIN_SUIHEI_BIN1) ||
		(pOEM->wPaperSource == DMBIN_TAMOKUTEKI_BIN1) ||
		(pOEM->wPaperSource == DMBIN_FI_FRONT)) {

		WRITESPOOLBUF(pdevobj, ecCSFBPAGE.pEscStr, ecCSFBPAGE.cbSize, &dwResult);

	} else if ((pOEM->wPaperSource == DMBIN_TRACTOR) ||
			(pOEM->wPaperSource == DMBIN_FI_TRACTOR)) {

		WRITESPOOLBUF(pdevobj, ecTRCTBPAGE.pEscStr, ecTRCTBPAGE.cbSize, &dwResult);

	} else if ((pOEM->wPaperSource == DMBIN_MANUAL) &&
						(!bFirstPage)) {

		WRITESPOOLBUF(pdevobj, ecManual2P.pEscStr, ecManual2P.cbSize, &dwResult);
		pOEM->bFirstPage = FALSE;

	}

	WRITESPOOLBUF(pdevobj,"\x0D", 1, &dwResult);
	if (bFirstPage) pOEM->bFirstPage = FALSE;
}
/***************************************************************************
    Function Name : OEMSendFontCmd

    Note          : Make this.                               09/26/97
***************************************************************************/
VOID APIENTRY OEMSendFontCmd(
PDEVOBJ			pdevobj,
PUNIFONTOBJ		pUFObj,
PFINVOCATION	pFInv)
{
    DWORD dwResult;

	WRITESPOOLBUF(pdevobj,pFInv->pubCommand, pFInv->dwCount, &dwResult);
}
/***************************************************************************
    Function Name : OEMCommandCallback

    Note          : Make this.                               09/26/97
***************************************************************************/
INT APIENTRY OEMCommandCallback(
PDEVOBJ pdevobj,
DWORD   dwCmdCbID,
DWORD   dwCount,
PDWORD  pdwParams
){
	USHORT 				bFirstPage;
	DEVICE_DATA *pOEM;
    DWORD dwResult;

	//
	// verify pdevobj okay
	//
	ASSERT(VALID_PDEVOBJ(pdevobj));

	pOEM = (DEVICE_DATA *)MINIDEV_DATA(pdevobj);

	bFirstPage = (USHORT)pOEM->bFirstPage;

	switch (dwCmdCbID) {

	case CMDID_ENDDOC :
		WRITESPOOLBUF(pdevobj,ecFMEnddoc.pEscStr,ecFMEnddoc.cbSize, &dwResult);
		break;

	case CMDID_BEGINDOC :
		pOEM->bFirstPage   = 1;
		pOEM->wPaperSource = 0;
		break;

	case CMDID_MAN180 :
	case CMDID_MAN360 :
		pOEM->wPaperSource = DMBIN_MANUAL;
		SheetFeed(pdevobj);
		break;

	case CMDID_TRA180 :
		pOEM->wPaperSource = DMBIN_TRACTOR;
		SheetFeed(pdevobj);
		break;

	case CMDID_180BIN1 :
		if (pOEM->wPaperSource != DMBIN_180BIN1) {
			pOEM->wPaperSource = DMBIN_180BIN1;
			WRITESPOOLBUF(pdevobj, ecSelectBIN1.pEscStr, ecSelectBIN1.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_180BIN2 :
		if (pOEM->wPaperSource != DMBIN_180BIN2) {
			pOEM->wPaperSource = DMBIN_180BIN2;
			WRITESPOOLBUF(pdevobj, ecSelectBIN2.pEscStr, ecSelectBIN2.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_360BIN1 :
		if (pOEM->wPaperSource != DMBIN_360BIN1) {
			pOEM->wPaperSource = DMBIN_360BIN1;
			WRITESPOOLBUF(pdevobj, ecSelectBIN1.pEscStr, ecSelectBIN1.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_360BIN2 :
		if (pOEM->wPaperSource != DMBIN_360BIN2) {
			pOEM->wPaperSource = DMBIN_360BIN2;
			WRITESPOOLBUF(pdevobj, ecSelectBIN2.pEscStr, ecSelectBIN2.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_FI_TRACTOR :
		if (pOEM->wPaperSource != DMBIN_FI_TRACTOR) {
			pOEM->wPaperSource = DMBIN_FI_TRACTOR;
			WRITESPOOLBUF(pdevobj, ecSelectFTRCT.pEscStr, ecSelectFTRCT.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_FI_FRONT :
		if (pOEM->wPaperSource != DMBIN_FI_FRONT) {
			pOEM->wPaperSource = DMBIN_FI_FRONT;
			WRITESPOOLBUF(pdevobj, ecSelectFFRNT.pEscStr, ecSelectFFRNT.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_SUIHEI_BIN1 :
		if (pOEM->wPaperSource != DMBIN_SUIHEI_BIN1) {
			pOEM->wPaperSource = DMBIN_SUIHEI_BIN1;
			WRITESPOOLBUF(pdevobj, ecSelectBIN1.pEscStr, ecSelectBIN1.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_TAMOKUTEKI_BIN1 :
		if (pOEM->wPaperSource != DMBIN_TAMOKUTEKI_BIN1) {
			pOEM->wPaperSource = DMBIN_TAMOKUTEKI_BIN1;
			WRITESPOOLBUF(pdevobj, ecSelectBIN1.pEscStr, ecSelectBIN1.cbSize, &dwResult);
		}
		SheetFeed(pdevobj);
		break;

	case CMDID_BEGINPAGE :
                // Assume it is not safe to think color settings
                // are carried over pages.
                SetRibbonColor(pdevobj, TEXT_COLOR_UNKNOWN);
#if 0
		if ((pOEM->wPaperSource == DMBIN_180BIN1) ||
			(pOEM->wPaperSource == DMBIN_180BIN2) ||
			(pOEM->wPaperSource == DMBIN_360BIN1) ||
			(pOEM->wPaperSource == DMBIN_360BIN2) ||
			(pOEM->wPaperSource == DMBIN_SUIHEI_BIN1) ||
			(pOEM->wPaperSource == DMBIN_TAMOKUTEKI_BIN1) ||
			(pOEM->wPaperSource == DMBIN_FI_FRONT)) {

			WRITESPOOLBUF(pdevobj, ecCSFBPAGE.pEscStr, ecCSFBPAGE.cbSize, &dwResult);

		} else if ((pOEM->wPaperSource == DMBIN_TRACTOR) ||
				(pOEM->wPaperSource == DMBIN_FI_TRACTOR)) {
			WRITESPOOLBUF(pdevobj, ecTRCTBPAGE.pEscStr, ecTRCTBPAGE.cbSize, &dwResult);

		} else if ((pOEM->wPaperSource == DMBIN_MANUAL) &&
						(!bFirstPage)) {
		WRITESPOOLBUF(pdevobj, ecManual2P.pEscStr, ecManual2P.cbSize, &dwResult);
		pOEM->bFirstPage = FALSE;
		}

		WRITESPOOLBUF(pdevobj, "\x0D", 1, &dwResult);

		if (bFirstPage) pOEM->bFirstPage = FALSE;
#endif
		break;


	case CMDID_ENDPAGE :

		if ((pOEM->wPaperSource == DMBIN_180BIN1) ||
			(pOEM->wPaperSource == DMBIN_180BIN2) ||
			(pOEM->wPaperSource == DMBIN_360BIN1) ||
			(pOEM->wPaperSource == DMBIN_360BIN2) ||
			(pOEM->wPaperSource == DMBIN_SUIHEI_BIN1) ||
			(pOEM->wPaperSource == DMBIN_TAMOKUTEKI_BIN1) ||
			(pOEM->wPaperSource == DMBIN_FI_FRONT)) {
			WRITESPOOLBUF(pdevobj, ecCSFEPAGE.pEscStr, ecCSFEPAGE.cbSize, &dwResult);
		}
		break;
        case CMDID_SELECT_BLACK_COLOR:
            pOEM->jColor = 8;
            break;
        case CMDID_SELECT_BLUE_COLOR:
            pOEM->jColor = 6;
            break;
        case CMDID_SELECT_CYAN_COLOR:
            pOEM->jColor = 4;
            break;
        case CMDID_SELECT_GREEN_COLOR:
            pOEM->jColor = 5;
            break;
        case CMDID_SELECT_MAGENTA_COLOR:
            pOEM->jColor = 2;
            break;
        case CMDID_SELECT_RED_COLOR:
            pOEM->jColor = 3;
            break;
        case CMDID_SELECT_WHITE_COLOR:
            // Should not happen
            pOEM->jColor = 0;
            break;
        case CMDID_SELECT_YELLOW_COLOR:
            pOEM->jColor = 1;
            break;
        case CMDID_SEND_BLACK_COLOR:
            SetRibbonColor(pdevobj, TEXT_COLOR_BLACK);
            break;
        case CMDID_SEND_CYAN_COLOR:
            SetRibbonColor(pdevobj, TEXT_COLOR_CYAN);
            break;
        case CMDID_SEND_MAGENTA_COLOR:
            SetRibbonColor(pdevobj, TEXT_COLOR_MAGENTA);
            break;
        case CMDID_SEND_YELLOW_COLOR:
            SetRibbonColor(pdevobj, TEXT_COLOR_YELLOW);
            break;
	} /* end switch */

    // MSKK 11/05
    return 0;
}

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ pdevobj,
    PWSTR pPrinterName,
    ULONG cPatterns,
    HSURF *phsurfPatterns,
    ULONG cjGdiInfo,
    GDIINFO* pGdiInfo,
    ULONG cjDevInfo,
    DEVINFO* pDevInfo,
    DRVENABLEDATA *pded)
{
    DEVICE_DATA *pTemp;

    VERBOSE((DLLTEXT("OEMEnablePDEV() entry.\n")));

    // Set minidriver PDEV address.

    pTemp = (DEVICE_DATA *)MemAllocZ(sizeof(DEVICE_DATA));
    if (NULL == pTemp) {
        ERR(("Memory allocation failure.\n"));
        return NULL;
    }
    pTemp->bFirstPage = TRUE;

    pdevobj->pdevOEM = (MINIDEV *)MemAllocZ(sizeof(MINIDEV));
    if (NULL == pdevobj->pdevOEM) {
        ERR(("Memory allocation failure.\n"));
        return NULL;
    }
    MINIDEV_DATA(pdevobj) = (PDEVOEM)pTemp;

    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    VERBOSE((DLLTEXT("OEMDisablePDEV() entry.\n")));

    if ( NULL != pdevobj->pdevOEM ) {

        if (MINIDEV_DATA(pdevobj)) {
            MemFree(MINIDEV_DATA(pdevobj));
        }
        MemFree( pdevobj->pdevOEM );
        pdevobj->pdevOEM = NULL;
    }
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    DEVICE_DATA *pOEMOld, *pOEMNew;

    pOEMOld = (DEVICE_DATA *)MINIDEV_DATA(pdevobjOld);
    pOEMNew = (DEVICE_DATA *)MINIDEV_DATA(pdevobjNew);

    if (pOEMOld != NULL && pOEMNew != NULL)
        *pOEMNew = *pOEMOld;

    return TRUE;
}

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD dwType,
    DWORD dwCount,
    PVOID pGlyph )
{
    GETINFO_GLYPHSTRING GStr;
    PBYTE               aubBuff;
    PTRANSDATA          pTrans;
    DWORD               dwI;
    DEVICE_DATA *pOEM;
    DWORD dwResult;
    INT i;
    BYTE jColor;
    BOOL bBackTab;

    VERBOSE(("OEMOutputCharStr() entry.\n"));
    ASSERT(VALID_PDEVOBJ(pdevobj));

    if(!pdevobj || !pUFObj || !pGlyph)
    {
        ERR(("OEMOutputCharStr: Invalid parameter.\n"));
        return;
    }

//    if(dwType == TYPE_GLYPHHANDLE &&
//        (pUFObj->ulFontID < 1 || pUFObj->ulFontID > 21))
    if(dwType == TYPE_GLYPHHANDLE)
    {
//        ERR(("OEMOutputCharStr: Invalid font ID %d.\n",
//            pUFObj->ulFontID));
//        return;
//        VERBOSE(("OEMOutputCharStr: Font ID %d.\n",
//            pUFObj->ulFontID));
    }

    pOEM = (DEVICE_DATA *)MINIDEV_DATA(pdevobj);

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:
        // if(!(aubBuff = (PBYTE)MemAllocZ(dwCount * sizeof(TRANSDATA))) )
        // {
        //     ERR(("MemAlloc failed.\n"));
        //     return;
        // }

        GStr.dwSize = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount = dwCount;
        GStr.dwTypeIn = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
// #333653: Change I/F for GETINFO_GLYPHSTRING
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;
        if (pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL) || !GStr.dwGlyphOutSize)
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            return;
        }
        if(!(aubBuff = (PBYTE)MemAllocZ(GStr.dwGlyphOutSize)) )
        {
            ERR(("MemAlloc failed.\n"));
            return;
        }
        GStr.pGlyphOut = aubBuff;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            goto out;
        }

        jColor = pOEM->jColor;

        VERBOSE(("jColor=%d\n", jColor));

        // If old color can be used as it is,
        // use it first.

        jColor <<= 1;
        if (0 != (pOEM->jColor & pOEM->jOldColor)) {
            jColor &= ~(pOEM->jOldColor << 1);
            jColor |= 1;
        }

        for (i = 0; i < 5 && jColor > 0;
            i++, (jColor >>= 1)) {

            pTrans = (PTRANSDATA)aubBuff;

            // Check if we need to print this plane.
            if (!(jColor & 1))
                continue;

            // Check if we need to do back-tab
            bBackTab = (jColor > 1);
            if (bBackTab)
            {
                WRITESPOOLBUF(pdevobj,
                    "\x1BH", 2, &dwResult);
            }

            // Send out color select command
            switch (i)
            {
            case 0:
                // Same as before
                break;
            case 1:
                // Y
                SetRibbonColor(pdevobj, TEXT_COLOR_YELLOW);
                break;
            case 2:
                // M
                SetRibbonColor(pdevobj, TEXT_COLOR_MAGENTA);
                break;
            case 3:
                // C
                SetRibbonColor(pdevobj, TEXT_COLOR_CYAN);
                break;
            case 4:
                // K
                SetRibbonColor(pdevobj, TEXT_COLOR_BLACK);
                break;
            }

            // Send out text
            for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
            {
                switch (pTrans->ubType & MTYPE_FORMAT_MASK)
                {
                case MTYPE_DIRECT:
                    WRITESPOOLBUF(pdevobj,
                        &pTrans->uCode.ubCode, 1,
                        &dwResult);
                    break;

                case MTYPE_PAIRED:
                    WRITESPOOLBUF(pdevobj,
                        &pTrans->uCode.ubPairs[0], 1,
                        &dwResult);
                    WRITESPOOLBUF(pdevobj,
                        &pTrans->uCode.ubPairs[1], 1,
                        &dwResult);
                    break;
                }
            }

            // Do back-tab for next plane
            if (bBackTab)
            {
                WRITESPOOLBUF(pdevobj,
                    "\x1C" "D\x1B[3g", 6,
                    &dwResult);
            }
        }
out:
        MemFree(aubBuff);
        break;
    }
    return;
}

VOID
SetRibbonColor(
    PDEVOBJ pdevobj,
    BYTE jColor)
{
    DEVICE_DATA *pOEM;
    DWORD dwResult;

    pOEM = (DEVICE_DATA *)MINIDEV_DATA(pdevobj);

    switch (jColor)
    {
    case TEXT_COLOR_YELLOW:
        if (TEXT_COLOR_YELLOW != pOEM->jOldColor)
        {
            WRITESPOOLBUF(pdevobj,
                "\x1C*!s", 4, &dwResult);
                pOEM->jOldColor = TEXT_COLOR_YELLOW;
        }
        break;
    case TEXT_COLOR_MAGENTA:
        if (TEXT_COLOR_MAGENTA != pOEM->jOldColor)
        {
            WRITESPOOLBUF(pdevobj,
                 "\x1C*!u", 4, &dwResult);
                pOEM->jOldColor = TEXT_COLOR_MAGENTA;
        }
        break;
    case TEXT_COLOR_CYAN:
        if (TEXT_COLOR_CYAN != pOEM->jOldColor)
        {
            WRITESPOOLBUF(pdevobj,
                "\x1C*!v", 4, &dwResult);
                pOEM->jOldColor = TEXT_COLOR_CYAN;
        }
        break;
    case TEXT_COLOR_BLACK:
        if (TEXT_COLOR_BLACK != pOEM->jOldColor)
        {
             WRITESPOOLBUF(pdevobj,
                 "\x1C*!p", 4, &dwResult);
                 pOEM->jOldColor = TEXT_COLOR_BLACK;
        }
        break;
    case TEXT_COLOR_UNKNOWN:
        pOEM->jOldColor = TEXT_COLOR_UNKNOWN;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuprjres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define OEM_DRIVER_VERSION 0x0500

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'FMPR'      // FMPR printers
#define DLLTEXT(s)      "FMPR: " s
#define OEM_VERSION      0x00010000L

//------------------------------------------------------ FMPR private devmode

typedef struct tag_OEMUD_EXTRADATA {
	OEM_DMEXTRAHEADER	dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

typedef struct {
    WORD wPaperSource;	// The current paper source
    BOOL bFirstPage;	// This is TRUE when First Page is Printing.
    BYTE jColor; // Current text color
    BYTE jOldColor; // Last ribbon color
} DEVICE_DATA;

//--------------------------------------------------------- command structure
typedef struct esccmd{
	WORD	cbSize;
	PBYTE	pEscStr;
} ESCCMD, FAR * PESCCMD;


#define LOCENTRY near pascal

//------------------------- Command callback id#s. for fmlbp GPC and PFM data
//------------------------- 1-255
#define CMDID_BEGINPAGE	1   // Entered in PAGECONTROL.PC_OCD_BEGINDOC as %1
#define CMDID_ENDPAGE	2
#define CMDID_BEGINDOC	3
#define CMDID_ENDDOC	4

#define CMDID_MIN24L	10
#define CMDID_MIN48H	11
#define CMDID_GOT48H	12
#define CMDID_MIN24LV	13
#define CMDID_U_MIN24LV	14
#define CMDID_MIN48HV	15
#define CMDID_U_MIN48HV	16
#define CMDID_GOT48HV	17
#define CMDID_U_GOT48HV	18

#define CMDID_MAN180	20
#define CMDID_TRA180	21
#define CMDID_180BIN1	22
#define CMDID_180BIN2	23
#define CMDID_MAN360	24
#define CMDID_360BIN1	25
#define CMDID_360BIN2	26
#define CMDID_FI_TRACTOR	27
#define CMDID_FI_FRONT		28
#define CMDID_SUIHEI_BIN1	29
#define CMDID_TAMOKUTEKI_BIN1	30

#define CMDID_SELECT_BLACK_COLOR 40
#define CMDID_SELECT_BLUE_COLOR 41
#define CMDID_SELECT_CYAN_COLOR 42
#define CMDID_SELECT_GREEN_COLOR 43
#define CMDID_SELECT_MAGENTA_COLOR 44
#define CMDID_SELECT_RED_COLOR 45
#define CMDID_SELECT_WHITE_COLOR 46
#define CMDID_SELECT_YELLOW_COLOR 47

#define CMDID_SEND_BLACK_COLOR 50
#define CMDID_SEND_CYAN_COLOR 51
#define CMDID_SEND_MAGENTA_COLOR 52
#define CMDID_SEND_YELLOW_COLOR 53

typedef unsigned short USHORT;
typedef WCHAR * PWSZ;     // pwsz, 0x0000 terminated UNICODE strings only

#ifdef _FUPRJRES_C
#define ESCCMDDEF(n,s) ESCCMD n = {sizeof(s)-1, s};
#else // _FUPRJRES_C
#define ESCCMDDEF(n,s) extern ESCCMD n;
#endif // _FUPRJRES_C

//------------------------------------------------- Paper Feed & Output Command
ESCCMDDEF(ecCSFBPAGE, "\x1BQ0 [")
ESCCMDDEF(ecCSFEPAGE, "\x1BQ1 [")
ESCCMDDEF(ecTRCTBPAGE, "\x1BQ22 B")
ESCCMDDEF(ecManual2P, "\x0C")

//--------------------------------------------------------- Char Select Command
ESCCMDDEF(ecDBCS, "\x1B$B")
ESCCMDDEF(ecSBCS, "\x1B(H")
ESCCMDDEF(ecVWF, "\x1CJ\x1BQ1 q")
ESCCMDDEF(ecHWF, "\x1CK")

//--------------------------------------------------------- mode change command
ESCCMDDEF(ecESCP2FM, "\x1B/\xB2@\x7F")
ESCCMDDEF(ecFM2ESCP, "\x1B\x7F\x00\x00\x01\x05")
ESCCMDDEF(ecFMEnddoc, "\x0D\x1B\x63")

//---------------------------------------------- font select & unselect command
ESCCMDDEF(ec24Min, "\x1C(a")
ESCCMDDEF(ec48Min, "\x1C(ap")
ESCCMDDEF(ec48Got, "\x1C(aq")
ESCCMDDEF(ec26Pitch, "\x1C$\x22v")
ESCCMDDEF(ec52Pitch, "\x1C$%r")
ESCCMDDEF(ecHankaku, "\x1BQ1\x20|")
ESCCMDDEF(ecTate1, "\x1CJ")
ESCCMDDEF(ecTate2, "\x1BQ1\x20q")
ESCCMDDEF(ecYoko, "\x1CK")

//---------------------------------------------- Paper Source Selection Command
ESCCMDDEF(ecSelectBIN1, "\x1BQ20\x20[")
ESCCMDDEF(ecSelectBIN2, "\x1BQ21\x20[")
ESCCMDDEF(ecSelectFTRCT, "\x1BQ10\x20\\")
ESCCMDDEF(ecSelectFFRNT, "\x1BQ11\x20\\")

//------ This NUMBER have to be changed when GPC file (or FMPR.RC) is modified.
#define DMBIN_180BIN1			269
#define DMBIN_180BIN2			270
#define DMBIN_360BIN1			271
#define DMBIN_360BIN2			272
#define DMBIN_FI_TRACTOR		273      // Tractor (FI2 FMPR-359F1)
#define DMBIN_FI_FRONT			274      // Front inserter (FI2 FMPR-359F1)
#define DMBIN_SUIHEI_BIN1		275      // Suihei printer BIN1 (FMPR601)
#define DMBIN_TAMOKUTEKI_BIN1	276      // Tamokuteki printer BIN1 (FMPR671, 654)

#define TEXT_COLOR_UNKNOWN 0
#define TEXT_COLOR_YELLOW  1
#define TEXT_COLOR_MAGENTA 2
#define TEXT_COLOR_CYAN    4
#define TEXT_COLOR_BLACK   8

VOID
SetRibbonColor(
    PDEVOBJ pdevobj,
    BYTE jColor);

//
// Minidriver device data block which we maintain.
// Its address is saved in the DEVOBJ.pdevOEM of
// OEM customiztion I/F.
//

typedef struct {
    VOID *pData; // Minidriver private data.
    VOID *pIntf; // a.k.a. pOEMHelp
} MINIDEV;

//
// Easy access to the OEM data and the printer
// driver helper functions.
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

    extern
    HRESULT
    XXXDrvWriteSpoolBuf(
        VOID *pIntf,
        PDEVOBJ pDevobj,
        PVOID pBuffer,
        DWORD cbSize,
        DWORD *pdwResult);

#ifdef __cplusplus
}
#endif // __cplusplus

#define MINIDEV_DATA(p) \
    (((MINIDEV *)(p)->pdevOEM)->pData)

#define MINIDEV_INTF(p) \
    (((MINIDEV *)(p)->pdevOEM)->pIntf)

#define WRITESPOOLBUF(p, b, n, r) \
    XXXDrvWriteSpoolBuf(MINIDEV_INTF(p), (p), (b), (n), (r))

#endif	// _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuprjres\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sources.

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

MAJORCOMP=windows
MINORCOMP=md_fuprjres

GPDDIR=$(PRNROOT)\gpd\fuj\$(ALT_PROJECT)
UNIDIR=$(PRNROOT)\unidrv2
SRCDIR=..

RCCODEPAGE=932

TARGETNAME=fuprjres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),fuprjres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc;$(UNIDIR)\inc

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\fuprjres.rc \
    $(SRCDIR)\fuprjres.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\fuprjres.ini \
    $(GPDDIR)\fuf180mj.gpd \
    $(GPDDIR)\fuf180cj.gpd \
    $(GPDDIR)\fuf372fj.gpd \
    $(GPDDIR)\fuf671fj.gpd \
    $(GPDDIR)\fuf371aj.gpd \
    $(GPDDIR)\fuf374fj.gpd \
    $(GPDDIR)\fuf672fj.gpd \
    $(GPDDIR)\fuf373mj.gpd \
    $(GPDDIR)\fuf373cj.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuprjres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
    "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
    "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
//     "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuband.h ===
//
// fuband.h
//
// August.26,1997 H.Ishida(FPL)
// fjxlres.dll (NT5.0 MiniDriver)
// 
// July.31,1996 H.Ishida (FPL)
// FUXL.DLL (NT4.0 MiniDriver)
//
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997


#ifndef fuband_h
#define	fuband_h

#define	OUTPUT_MH		0x0001
#define	OUTPUT_RTGIMG2	0x0002
#define	OUTPUT_MH2		0x0004
#define	OUTPUT_RTGIMG4	0x0008


void fuxlInitBand(PFUXLPDEV pFjxlPDEV);
void fuxlDisableBand(PFUXLPDEV pFjxlPDEV);

void fuxlRefreshBand(PDEVOBJ pdevobj);


#endif // !fuband_h
// end of fuband.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fudebug.c ===
///////////////////////////////////////////////////
// fudebug.c
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#if DBG

#include <minidrv.h>

void dbgPrintf(LPSTR pszMsg, ...)
{
	va_list arg;
	va_start(arg, pszMsg);
	DbgPrint("[fuxlres]", pszMsg, arg);
	va_end(arg);
}


#endif // DBG

// end of fudebug.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "fuxl.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    // DbgPrint(DLLTEXT("IOemCB: QueryInterface entry\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ; 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ; 
    }
    else
    {
        *ppv = NULL ;
        // DbgPrint(DLLTEXT("IOemCB:Return NULL.\n")) ; 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    // DbgPrint(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release() 
{
    // DbgPrint(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    // DbgPrint(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    // DbgPrint(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    // DbgPrint(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    // DbgPrint(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    // DbgPrint(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    OEMDisablePDEV(pdevobj);
    return S_OK;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::GetInfo() entry.\r\n"));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    // DbgPrint(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    // DbgPrint(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'D':
#if 0
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;
#endif
                else if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'E':
#if 0
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
#if 0
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'I':
#if 0
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'M':
#if 0
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'O':
#if 0
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
#if 0
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'T':
#if 0
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
#endif
                break;
        }
    }

    if (lReturn)
    {
        // DbgPrint(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        // DbgPrint(__TEXT("NOT supported\r\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    // DbgPrint(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    // DbgPrint(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    // if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
    //                     dwCallbackID, pIPParams))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    // DbgPrint(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));
    // pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuf, dwLen, &dwResult);
    
    if (OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    // DbgPrint(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    // DbgPrint(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));
    //*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));
    //*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));
    //*pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    // DbgPrint(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));
    // OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    // return S_OK;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    // DbgPrint(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    // OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    // return S_OK;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    // DbgPrint(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //// DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //// DbgPrint(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID) ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID) ;
}
#endif

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\comoem.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fudebug.h ===
////////////////////////////////////////////////
// fudebug.h
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#ifndef fudebug_h
#define	fudebug_h

#include <minidrv.h>

#if DBG && defined(TRACE_DDI)
#define	TRACEDDI(a)	dbgPrintf a;
#else
#define	TRACEDDI(a)
#endif


#if DBG && defined(TRACE_OUT)
#define	TRACEOUT(a)	dbgPrintf a;
#else
#define	TRACEOUT(a)
#endif

#if DBG
void dbgPrintf(LPSTR pszMsg, ...);
#endif


#endif // !fudebug_h

// end of fudebug.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuband.c ===
//
// fuband.c
//
// August.26,1997 H.Ishida(FPL)
//  fuxlres.dll (NT5.0 MiniDriver)
//
// July.31,1996 H.Ishida (FPL)
// FUXL.DLL (NT4.0 MiniDriver)
//

#include "fuxl.h"
#include "fumh.h"
#include "fumh2.h"
#include "fuband.h"
#include "fuimg2.h"
#include "fuimg4.h"
#include "fudebug.h"



//
// FjBAND:
//     In Win-F image command(RTGIMG2 and RTGIMG4), image coordinate must
// be a multiple of 32. But I can't create such a GPC file for RasDD.
// Some image data, not on 32x32 grid, must be buffered in FjBAND,
// width:papser width, height:32, x-coordinate:0, y-coordinate:a multiple
// of 32.
// 
//  Image to be output
//     (0, y)
//          A----------------------------------+
//          |  partA                           |
//          B----------------------------------+
//          |  partB                           |
//          |                                  |
//          |                                  |
//          C----------------------------------+
//          |  partC                           |
//          D----------------------------------+
//
//  I split source image to 3 part.
//     A: top of image, is not a multiple of 32.
//     B: top of image, is a multiple of 32.
//     C: bottom of image, is a multilpe of 32.
//     D: bottom of image, is not a multile of 32.
//
//     partA: A to B. this part is buffered in FjBAND, ORed on 
//            previousely written image.
//     partB: B to C. this part is not bufferd, output immediately.
//     partC: C to D. this part is buffered in FjBAND, may be ORed
//            partA of next image.
//


#define	FUXL_BANDHEIGHT	32



//
// void fuxlInitBand(PFUXLPDEV pFuxlPDEV)      // fuxlres private PDEV
//
// This function initializes FjBAND, but not allocate memory for band.
//
void fuxlInitBand(PFUXLPDEV pFuxlPDEV)
{
	int			i;

	pFuxlPDEV->cBandByteWidth = (pFuxlPDEV->cxPage + 7) / 8;
	i = 0x10000L / pFuxlPDEV->cBandByteWidth;
	pFuxlPDEV->cyBandSegment = i - (i % FUXL_BANDHEIGHT);
	pFuxlPDEV->pbBand = NULL;
	pFuxlPDEV->cbBand = FUXL_BANDHEIGHT * pFuxlPDEV->cBandByteWidth;
	pFuxlPDEV->yBandTop = 0;
	pFuxlPDEV->bBandDirty = FALSE;
	pFuxlPDEV->bBandError = FALSE;
}



//
// BOOL fuxlEnableBand(
//      PFUXLPDEV pFuxlPDEV      // fuxlres private PDEV
// );
//
// This function allocates memory for FjBAND.
//
// Return Values
//    TRUE:  band memory is allocated.
//    FALSE: band memory is not allocated.
//
BOOL fuxlEnableBand(PFUXLPDEV pFuxlPDEV)
{
	DWORD		cbBand;

	pFuxlPDEV->pbBand = (LPBYTE)MemAllocZ(pFuxlPDEV->cbBand);
	if(pFuxlPDEV->pbBand == NULL){
		pFuxlPDEV->bBandError = TRUE;
		return FALSE;
	}
	memset(pFuxlPDEV->pbBand, 0, pFuxlPDEV->cbBand);
	pFuxlPDEV->bBandDirty = FALSE;
	return TRUE;
}


//
// void fuxlDisableBand(
//      PFUXLPDEV pFuxlPDEV   // fuxlres private PDEV
// );
//
// This function frees memory for FjBAND.
//
void fuxlDisableBand(PFUXLPDEV pFuxlPDEV)
{
	if(pFuxlPDEV->pbBand != NULL){
		MemFree(pFuxlPDEV->pbBand);
		pFuxlPDEV->pbBand = NULL;
	}
	pFuxlPDEV->bBandError = FALSE;
}



//
// void fuxlCopyBand(
//      PDEVOBJ pdevobj,   // MINI5 data
//      LPBYTE  pBuff,     // address of source image data.
//      LONG    lDelta,    // width of source image data(in bytes)
//      int     y,         // y-coordinate of source image.
//      int     cy         // height of source image data(scanline)
// );
//
// This function copies source image data to FjBAND.
//
//
void fuxlCopyBand(PDEVOBJ pdevobj, LPCBYTE pbSrc, int cSrcBandWidth, int y, int cy)
{
	PFUXLPDEV	pFuxlPDEV;
	LPCBYTE		pbSrcTmp;
	LPBYTE		pbDst;
	LPBYTE		pbDstTmp;
	int			i;
	int			j;
	UINT		uTmp;

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;

	if(pFuxlPDEV->yBandTop <= y && y + cy <= pFuxlPDEV->yBandTop + FUXL_BANDHEIGHT){
		pbDst = pFuxlPDEV->pbBand + (y - pFuxlPDEV->yBandTop) * pFuxlPDEV->cBandByteWidth;
		uTmp = 0;
		for(i = cy; i > 0; --i){
			pbDstTmp = pbDst;
			for(j = cSrcBandWidth; j > 0; --j){
				uTmp |= *pbSrc;
				*pbDstTmp++ |= *pbSrc++;
			}
			pbDst += pFuxlPDEV->cBandByteWidth;
		}
		if(uTmp != 0)
			pFuxlPDEV->bBandDirty = TRUE;
	}
}



//
// BOOL fuxlOutputMH(
//      PDEVOBJ	pdevobj   // MINI5 data
//      LPCBYTE pbSrc,    // address of source image data.
//      LONG    lDelta,   // width of source image data(in byte).
//      int     y,        // y-coordinate of source image data.
//      int     cy        // height of source image data(scanline).
// );
//
// This function outputs image, uses FM-MH(old type).
//
// Return Values
//    TRUE: output succeeded.
//    FALSE: output failed. 
//           memory allocate error, or
//           MH compression is not effecive for this image data.
//
BOOL fuxlOutputMH(PDEVOBJ pdevobj, LPCBYTE pbSrc, int cSrcBandWidth, int y, int cy)
{
	BOOL		bResult;
	LPBYTE		pDest;
	LONG		cb;
	LONG		cDestN;
	DWORD		cbMHData;
	BYTE		abTmp[10];

	bResult = FALSE;
	cb = cSrcBandWidth * cy;
	cDestN = (cb + 1) / 2;
	pDest = (LPBYTE)MemAllocZ(cDestN);
	if(pDest != NULL){
		cbMHData = (WORD)MhCompress(pDest, cDestN, (LPBYTE)pbSrc, cSrcBandWidth * cy, cSrcBandWidth, cy);
		if(cbMHData > 0){
			memcpy(abTmp, "\x1d\x30\x20\x62\x00\x00", 6);
	        abTmp[6] = HIBYTE((WORD)y);
	        abTmp[7] = LOBYTE((WORD)y);
	        abTmp[8] = HIBYTE(cbMHData);
	        abTmp[9] = LOBYTE(cbMHData);
	        WRITESPOOLBUF(pdevobj, abTmp, 10);
	        WRITESPOOLBUF(pdevobj, pDest, cbMHData);
	        WRITESPOOLBUF(pdevobj, "\x00\x00", 2 );
			bResult = TRUE;
		}
		MemFree(pDest);
	}

	return bResult;
}




//
// BOOL fuxlOutputMH2(
//      PDEVOBJ pdevobj,    // MINI5 data
//      LPCBYTE pbSrc,      // address of source image data.
//      LONG    lDelta,     // width of source image data(in byte).
//      int     y,          // y-coordinate of source image data.
//      int     cy          // height of source image data(scanline).
// );
//
// This function outputs image, uses FM-MH2(for XL-65K and after).
//
// Return Value
//    TRUE:  output succeeded.
//    FALSE: output failed. 
//           memory allocate error, or
//           MH compression is not effective for this iamge data.
//
BOOL fuxlOutputMH2(PDEVOBJ pdevobj, LPCBYTE pbSrc, int cSrcByteWidth, int y, int cy)
{
	BOOL		bResult;
	LPBYTE		pDest;
	LONG		cb;
	LONG		cDestN;
	DWORD		cbMHData;
	BYTE		abTmp[10];

	bResult = FALSE;
	cb = cSrcByteWidth * cy;
	cDestN = (cb + 1) / 2;
	pDest = (LPBYTE)MemAllocZ(cDestN);
	if(pDest != NULL){
		cbMHData = Mh2Compress(pDest, cDestN, (LPBYTE)pbSrc, cSrcByteWidth * cy, cSrcByteWidth, cy);
		if(cbMHData > 0){
			memcpy(abTmp, "\x1d\x30\x20\x62\x00\x00", 6);
	        abTmp[6] = HIBYTE((WORD)y);
	        abTmp[7] = LOBYTE((WORD)y);
	        abTmp[8] = HIBYTE(cbMHData);
	        abTmp[9] = LOBYTE(cbMHData);
	        WRITESPOOLBUF(pdevobj, abTmp, 10);
	        WRITESPOOLBUF(pdevobj, pDest, cbMHData);
	        WRITESPOOLBUF(pdevobj, "\x00\x00", 2 );
			bResult = TRUE;
		}
		MemFree(pDest);
	}

	return bResult;
}



//
// void fuxlOutputGraphics(
//      PDEVOBJ pdevobj, // MINI5
//      LPCBYTE pbSrc,   // address of source image data.
//      UINT    bx,      // width of source iamge data(in byte).
//      UINT    y,       // y-coordinate of source iamge data.
//      UINT    cy       // height of source iamge data(scanline).
// );
//
// This function outputs source iamge data.
//
void fuxlOutputGraphics(PDEVOBJ pdevobj, LPCBYTE pbSrc, int cSrcByteWidth, UINT y, UINT cy)
{
	PFUXLPDEV	pFuxlPDEV;
	DWORD		dwOutputCmd;

	TRACEOUT(("[fuxlOutputGraphics]y %d cy %d\r\n", y, cy))

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	dwOutputCmd = pFuxlPDEV->dwOutputCmd;

	if((dwOutputCmd & OUTPUT_MH2) != 0){
		TRACEOUT(("[fuxlOutputGraphics]Try MH2\r\n"))
		if(fuxlOutputMH2(pdevobj, pbSrc, cSrcByteWidth, y, cy) != FALSE)
			return;
	}
	if((dwOutputCmd & OUTPUT_RTGIMG4) != 0){
		TRACEOUT(("[fuxlOutputGraphics]Send RTGIMG4\r\n"))
		fuxlOutputRTGIMG4(pdevobj, pbSrc, cSrcByteWidth, y, cy);
		return;
	}
	if((dwOutputCmd & OUTPUT_MH) != 0){
		TRACEOUT(("[fuxlOutputGraphics]Try MH\r\n"))
		if(fuxlOutputMH(pdevobj, pbSrc, cSrcByteWidth, y, cy) != FALSE)
			return;
	}
	TRACEOUT(("[fuxlOutputGraphics]Send RTGIMG2\r\n"))
	fuxlOutputRTGIMG2(pdevobj, pbSrc, cSrcByteWidth, y, cy);
}



//
// BOOL fuxlSetBandPos(
//      PDEVOBJ pdevobj,     // MINI5 data
//      int     yPos         // y-coordinate
// );
//
// This function sets y-coordinate of FjBAND.
//
// Return Value.
//    TRUE:  secceeded
//    FALSE: failed(FjBAND can't move upward)
//
// Remarks
//    Internally, y-coordinate is adjust to a multiple of 32.
//    Then check new y-coordinate, if it is equal to previous y-coordinate,
//    the contents of FjBAND remain. Otherwise, flushes FjBAND.
//     
BOOL fuxlSetBandPos(PDEVOBJ pdevobj, int yPos)
{
	PFUXLPDEV pFuxlPDEV;
	
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	if(yPos < pFuxlPDEV->yBandTop)
		return FALSE;

	yPos -= yPos % FUXL_BANDHEIGHT;
	if(yPos != pFuxlPDEV->yBandTop){
		if(pFuxlPDEV->bBandDirty != FALSE){
			fuxlOutputGraphics(pdevobj, pFuxlPDEV->pbBand, pFuxlPDEV->cBandByteWidth, pFuxlPDEV->yBandTop, FUXL_BANDHEIGHT);
			memset(pFuxlPDEV->pbBand, 0, pFuxlPDEV->cbBand);
			pFuxlPDEV->bBandDirty = FALSE;
		}
		pFuxlPDEV->yBandTop = yPos;
	}
	return TRUE;
}



//
// void fuxlRefreshBand(
//      PDEVOBJ pdevobj        // MINI5 data
// );
//
// This function flushes FjBAND, send FormFeed command, and sets
// y-coordinate to top(0).
//
void fuxlRefreshBand(PDEVOBJ pdevobj)
{
	PFUXLPDEV pFuxlPDEV;
	
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	if(pFuxlPDEV->bBandDirty != FALSE){
		fuxlOutputGraphics(pdevobj, pFuxlPDEV->pbBand, pFuxlPDEV->cBandByteWidth, pFuxlPDEV->yBandTop, FUXL_BANDHEIGHT);
		memset(pFuxlPDEV->pbBand, 0, pFuxlPDEV->cbBand);
		pFuxlPDEV->bBandDirty = FALSE;
	}
	WRITESPOOLBUF(pdevobj, "\x0c", 1);			// FF command
	pFuxlPDEV->yBandTop = 0;
}



//
// WORD OEMFilterGraphics(
//      LPDV   lpdv,     // address of private data, used by RasDD.
//      LPBYTE lpBuf,    // address of source iamge data.
//      WORD wLen        // size of source image data.
// );
//
// This function convert image format to Printer command sequence,
// and spool it.
//
// Return Value
//   the number of bytes of processed raster data.
//   the number of bytes may be the same as wLen, but not necessarily.
//
// Remarks
//
//       | <--------------- pFuxlPDEV->cBlockWidth-----------> |
// lpBuf *--------+--------+--------+--------+--------+--------+---
//       |        |        |        |        |        |        | ^
//       +--------+--------+--------+--------+--------+--------+ |
//       |        |        |        |        |        |        | pFuxlPDEV->
//       +--------+--------+--------+--------+--------+--------+ cBlockHeight
//       |        |        |        |        |        |        | |
//       +--------+--------+--------+--------+--------+--------+ |
//       |        |        |        |        |        |        | v
//       +--------+--------+--------+--------+--------+--------+---
//
//        white dot:0
//        black dot:1
//
//        coordinate of '*' (left-top of image):
//          pFuxlPDEV->x
//          pFuxlPDEV->y
//
//

// MINI5 export
BOOL APIENTRY OEMFilterGraphics(PDEVOBJ pdevobj, LPBYTE pbBuf, DWORD dwLen)
{
	PFUXLPDEV	pFuxlPDEV;
	LPCBYTE		pbSrc;
	int			y;
	int			yAlignTop;
	int			yBottom;
	int			yAlignBottom;
	int			cSrcByteWidth;
	int			cLine;

	TRACEOUT(("[OEMFilterGraphics]\r\n"))
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	if(pFuxlPDEV->pbBand == NULL){
		if(pFuxlPDEV->bBandError != FALSE)
			return FALSE;
		if(fuxlEnableBand(pFuxlPDEV) == FALSE)
			return FALSE;
	}

	pbSrc = pbBuf;
	y = pFuxlPDEV->y;
	yAlignTop = y - (y % FUXL_BANDHEIGHT);
	yBottom = y + pFuxlPDEV->cBlockHeight;
	yAlignBottom = yBottom - (yBottom % FUXL_BANDHEIGHT);
	cSrcByteWidth = pFuxlPDEV->cBlockByteWidth;

	if(yAlignTop < y){
		// partA
		if(fuxlSetBandPos(pdevobj, y) == FALSE)		// FUXL band pos can't move up
			return TRUE;
		cLine = FUXL_BANDHEIGHT - (y - yAlignTop);
		if(y + cLine >= yBottom){
			fuxlCopyBand(pdevobj, pbSrc, cSrcByteWidth, y, yBottom - y);
			return TRUE;
		}
		fuxlCopyBand(pdevobj, pbSrc, cSrcByteWidth, y, cLine);
		pbSrc += cSrcByteWidth * cLine;
		y += cLine;
	}
	if(y < yAlignBottom){
		// partB
		if(fuxlSetBandPos(pdevobj, yAlignBottom) == FALSE)		// FUXL band pos can't move up
			return TRUE;
		for(cLine = yAlignBottom - y; cLine >= pFuxlPDEV->cyBandSegment; cLine -= pFuxlPDEV->cyBandSegment){
			fuxlOutputGraphics(pdevobj, pbSrc, cSrcByteWidth, y, pFuxlPDEV->cyBandSegment);
			pbSrc += cSrcByteWidth * pFuxlPDEV->cyBandSegment;
			y += pFuxlPDEV->cyBandSegment;
		}
		if(cLine > 0){
			fuxlOutputGraphics(pdevobj, pbSrc, cSrcByteWidth, y, cLine);
			pbSrc += cSrcByteWidth * cLine;
			y += cLine;
		}
	}
	if(y < yBottom){
		// partC
		if(fuxlSetBandPos(pdevobj, y) == FALSE)		// FUXL band pos can't move up
			return TRUE;
		fuxlCopyBand(pdevobj, pbSrc, cSrcByteWidth, y, yBottom - y);
	}
	return TRUE;
}


// end of fuband.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuimg4.h ===
///////////////////////////////////////////////
// fuimg4.h
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#ifndef fuimg4_h
#define	fuimg4_h

void fuxlOutputRTGIMG4(PDEVOBJ pdevobj, LPCBYTE pbSrc, int iByteWidth, int y, int cy);

#endif // !fuimg4_h
// end of fuimg4.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuimg2.c ===
//
// fuimg2.c
//
// September.3,1997 H.Ishida (FPL)
// fuxlers.dll (NT5.0 MiniDriver)
//
// Aug.2,1996 H.Ishida(FPL)
// FJXL.DLL (NT4.0 MiniDriver)
//
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997

#include "fuxl.h"
#include "fuimg2.h"

//
// Win-F RTGIMG2 output routine
// RTGIMG2:
//   GS<\x1D> + P1<\x30> + Space<\x20> + a<\x61>
//       + Pc + Pxh + Pxl + Pyh + Pyl + Pyh + D1 + ... + D64
//       { + D1 + ... + D64 } + Pc
//
//   P1 must be 30(hex)
//
//   Pc:  number of the following block.
//        if Pc is 0, terminate RTGIMG2.
//
//   Pxl, Pxh, Pyl, Pyh:  coordinate of the following block.
//                        it must be a multiple of 32.
//
//            X->
//         <-- 16dot -->
//       1      8 9      16
//      +--------+--------+
//      |  D1    |   D2   |
//      +--------+--------+    ^
//  |   |  D3    |   D4   |    |
//  v   +--------+--------+    |
//  Y   .        .        .  16dot
//      .        .        .    |
//      .        .        .    |
//      +--------+--------+    v
//      |  D63   |   D64  |
//      +--------+--------+
//      White dot:0  Black dot:1
//




const UINT	MAX_BLOCK			= 255;
const UINT	CB_RTGIMG2HEADER	= 5;
const UINT	CB_RTGIMG2BLOCK		= 64;
const UINT	IDX_BLOCK_COUNTER	= 0;


//
// LPBYTE fuxlRtgimg2OutputData(
//     PDEVOJB pdevobj    // MINI5 data
//     LPBYTE lpbDst,     // address of data to be output(spool).
//     UINT   x,          // x-coordinate
//     UINT   y,          // y-coordinate
//     UINT   uTmp        // 00h: entire block is white. otherwise block is not white.
// );
//
//     Output RTGIMG2 block to spool.
//
// Return value:
//      address of next block to be stored.
//
static LPBYTE fuxlRtgimg2OutputData(PDEVOBJ pdevobj, LPBYTE lpbDst, UINT x, UINT y, UINT uTmp)
{
	if(uTmp == 0){
		// entire block is white.
		// igonre this block. flush blocks in buffer.
		if(lpbDst[IDX_BLOCK_COUNTER] > 0){
			WRITESPOOLBUF(pdevobj,
						lpbDst,
						lpbDst[IDX_BLOCK_COUNTER] * CB_RTGIMG2BLOCK + CB_RTGIMG2HEADER);
			lpbDst[IDX_BLOCK_COUNTER] = 0;
		}
	}
	else {
		if(lpbDst[IDX_BLOCK_COUNTER] == 0){
			// first block, in buffer, needs its coordinate.
			lpbDst[1] = HIBYTE((WORD)x);		// Pxh
			lpbDst[2] = LOBYTE((WORD)x);		// Pxl
			lpbDst[3] = HIBYTE((WORD)y);		// Pyh
			lpbDst[4] = LOBYTE((WORD)y);		// Pyl
		}
		lpbDst[IDX_BLOCK_COUNTER]++;
		if(lpbDst[IDX_BLOCK_COUNTER] >= MAX_BLOCK){
			WRITESPOOLBUF(pdevobj,
						lpbDst,
						lpbDst[IDX_BLOCK_COUNTER] * CB_RTGIMG2BLOCK + CB_RTGIMG2HEADER);
			lpbDst[IDX_BLOCK_COUNTER] = 0;
		}
	}
	// return pointer for the address, next block will be stored.
	return lpbDst + lpbDst[IDX_BLOCK_COUNTER] * CB_RTGIMG2BLOCK + CB_RTGIMG2HEADER;
}



//
// void FuxlOutputRTGIMG2(
//     PDEVOBJ pdevobj,      // MINI5 data
//     LPCBYTE lpBuf,        // address of image
//     UINT    bxSrc,        // width of image (in byte)
//     UINT    y,            // y-coordinate
//     UINT    cy            // height of image (scanline)
// );
//
//    Convert image to RTGIMG2 command sequence, and spool.
//
//
//    Souce image data:
//
//            | <-------------------- bxSrc ----------------------> |
//    lpBuf ->*--------+--------+--------+--------+--------+--------+---
//            |        |        |        |        |        |        | ^
//            +--------+--------+--------+--------+--------+--------+ |
//            |        |        |        |        |        |        | cy
//            +--------+--------+--------+--------+--------+--------+ |
//            |        |        |        |        |        |        | |
//            +--------+--------+--------+--------+--------+--------+ |
//            |        |        |        |        |        |        | v
//            +--------+--------+--------+--------+--------+--------+---
//
//        coordinate of '*' (left-top of image) is (0, y)
//        white dot:0
//        black dot:1
//
//
void fuxlOutputRTGIMG2(PDEVOBJ pdevobj, LPCBYTE lpBuf, UINT bxSrc, UINT y, UINT cy)
{
	LPCBYTE	lpbSrc;
	LPBYTE	lpbDst;
	LPCBYTE	lpbTmpSrc;
	LPBYTE	lpbTmpDst;
	UINT	uTmp;
	UINT	x;
	UINT	i, j, ii;

	lpbDst = (LPBYTE)MemAllocZ(CB_RTGIMG2HEADER + MAX_BLOCK * CB_RTGIMG2BLOCK);
	if(lpbDst == NULL)
		return;

	WRITESPOOLBUF(pdevobj, "\x1D\x30\x20\x61", 4);		// RTGIMG2 start

	lpbSrc = lpBuf;
	lpbDst[0] = 0;			// Pc
	lpbDst[1] = 0;			// Pxl
	lpbDst[2] = 0;			// Pxh
	lpbDst[3] = 0;			// Pyl
	lpbDst[4] = 0;			// Pyh
	lpbTmpDst = &lpbDst[CB_RTGIMG2HEADER];

	for(i = cy; i >= 32; i -= 32){
		x = 0;
		for(j = bxSrc; j >= 2; j -= 2){
			lpbTmpSrc = lpbSrc;
			uTmp = 0;
			for(ii = 32; ii > 0; --ii){
				uTmp |= lpbTmpSrc[0];
				*lpbTmpDst++ = lpbTmpSrc[0];
				uTmp |= lpbTmpSrc[1];
				*lpbTmpDst++ = lpbTmpSrc[1];
				lpbTmpSrc += bxSrc;
			}
			lpbTmpDst = fuxlRtgimg2OutputData(pdevobj, lpbDst, x, y, uTmp);
			x += 16;
			lpbSrc += 2;
		}
		if(j > 0){
			// right edge of image
			// j must be 1.
			lpbTmpSrc = lpbSrc;
			uTmp = 0;
			for(ii = 32; ii > 0; --ii){
				uTmp |= lpbTmpSrc[0];
				*lpbTmpDst++ =lpbTmpSrc[0];
				*lpbTmpDst++ = 0;				// padding for right side
				lpbTmpSrc += bxSrc;
			}
			lpbTmpDst = fuxlRtgimg2OutputData(pdevobj, lpbDst, x, y, uTmp);
			lpbSrc++;
		}
		// flush buffer
		lpbTmpDst = fuxlRtgimg2OutputData(pdevobj, lpbDst, x, y, 0);
		lpbSrc += bxSrc * 31;
		y += 32;
	}
	if(i > 0){
		// bottom edge of image
		x = 0;
		for(j = bxSrc; j >= 2; j -= 2){
			lpbTmpSrc = lpbSrc;
			uTmp = 0;
			for(ii = i; ii > 0; --ii){
				uTmp |= lpbTmpSrc[0];
				*lpbTmpDst++ = lpbTmpSrc[0];
				uTmp |= lpbTmpSrc[1];
				*lpbTmpDst++ = lpbTmpSrc[1];
				lpbTmpSrc += bxSrc;
			}
			for(ii = 32 - i; ii > 0; --ii){
				*lpbTmpDst++ = 0;				// padding for bottom lines
				*lpbTmpDst++ = 0;				// padding for bottom lines
			}
			lpbTmpDst = fuxlRtgimg2OutputData(pdevobj, lpbDst, x, y, uTmp);
			x += 16;
			lpbSrc += 2;
		}
		if(j > 0){
			// right-bottom corner of image
			// j must be 1.
			lpbTmpSrc = lpbSrc;
			uTmp = 0;
			for(ii = i; ii > 0; --ii){
				uTmp |= lpbTmpSrc[0];
				*lpbTmpDst++ = lpbTmpSrc[0];
				*lpbTmpDst++ = 0;				// padding for right side
				lpbTmpSrc += bxSrc;
			}
			for(ii = 32 - i ; ii > 0; --ii){
				*lpbTmpDst++ = 0;				// padding for bottom lines
				*lpbTmpDst++ = 0;				// padding for bottom lines
			}
			lpbTmpDst = fuxlRtgimg2OutputData(pdevobj, lpbDst, x, y, uTmp);
		}
		// flush buffer
		lpbTmpDst = fuxlRtgimg2OutputData(pdevobj, lpbDst, x, y, 0);
	}
	WRITESPOOLBUF(pdevobj, "\x00", 1);			// RTGIMG2 terminate
	MemFree(lpbDst);
}


// end of fuimg2.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuimg4.c ===
////////////////////////////////////////////////////
// fuimg4.cpp
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#include "fuxl.h"
#include "fuimg4.h"
#include "fudebug.h"

#define	C_BLOCK_BYTE_WIDTH	4
#define	CY_BLOCK			32



static LPBYTE setImg4Block(LPBYTE pbDest, LPCBYTE pbSrc, int cSrcByteWidth, int cBlockByteWidth, int cyBlock)
{
	LPCBYTE	pbTmp;
	DWORD	dwMask;
	DWORD	dwData;
	int		i;
	int		j;

	dwData = 0xffffffff;
	for(i = 0; i < cyBlock; ++i){
		pbTmp = pbSrc;
		for(j = 0; j < cBlockByteWidth; ++j){
			dwData = (dwData << 8) | (*pbTmp++ & 0xff);
			if((dwData & 0x00ffffff) == 0){
				pbDest[-1] += 1;
			}
			else if((dwData & 0x0000ffff) == 0){
				*pbDest++ = 0;
				*pbDest++ = 2;
			}
			else{
				*pbDest++ = (BYTE)dwData;
			}
		}
		for(; j < 4; ++j){
			dwData <<= 8;
			if((dwData & 0x00ffffff) == 0){
				pbDest[-1] += 1;
			}
			else if((dwData & 0x0000ffff) == 0){
				*pbDest++ = 0;
				*pbDest++ = 2;
			}
			else{
				*pbDest++ = (BYTE)dwData;
			}
		}
		pbSrc += cSrcByteWidth;
	}
	for( ; i < CY_BLOCK; ++i){
		for(j = 0; j < C_BLOCK_BYTE_WIDTH; ++j){
			dwData <<= 8;
			if((dwData & 0x00ffffff) == 0){
				pbDest[-1] += 1;
			}
			else if((dwData & 0x0000ffff) == 0){
				*pbDest++ = 0;
				*pbDest++ = 2;
			}
			else{
				*pbDest++ = (BYTE)dwData;
			}
		}
	}

	return pbDest;
}




void fuxlOutputRTGIMG4(PDEVOBJ pdevobj, LPCBYTE pbSrc, int cSrcByteWidth, int y, int cy)
{
	PFUXLPDEV	pFuxlPDEV;
	LPCBYTE		pbSrcTmp;
	LPBYTE		pbDest;
	UINT		uFlags;
	UINT		uSerialCode;
	BOOL		bCmdHeader;
	int			iy;
	int			ix;
	int			cx;
	int			xPos;
	int			yPos;
	int			cBlockByteWidth;
	int			cyBlock;
	BYTE		abBuff[256];

	TRACEOUT(("[fjxlRTGIMG4]\r\n"))

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	cx = pFuxlPDEV->cxPage;

	bCmdHeader = FALSE;
	uFlags = 0xd0;
	uSerialCode = 0;

	cyBlock = 32;
	for(iy = 0; iy < cy; iy += cyBlock){
		if(iy + cyBlock > cy)
			cyBlock = cy - iy;
		pbSrcTmp = pbSrc;

		cBlockByteWidth = 4;
		for(ix = 0; ix < cSrcByteWidth; ix += cBlockByteWidth){
			if(ix + cBlockByteWidth > cSrcByteWidth)
				cBlockByteWidth = cSrcByteWidth - ix;

			pbDest = abBuff;
			*pbDest++ = (BYTE)(uSerialCode | uFlags);
			if(uFlags == 0xd0){
				xPos = ix * 8;
				yPos = iy + y;
				*pbDest++ = (xPos >> 8) & 0xff;
				*pbDest++ = (xPos & 0xe0) | 0x01;
				*pbDest++ = (yPos >> 8) & 0xff;
				*pbDest++ = (yPos & 0xe0) | 0x01;
			}
			pbDest = setImg4Block(pbDest, pbSrcTmp, cSrcByteWidth, cBlockByteWidth, cyBlock);
			uFlags = 0xd0;
			if(pbDest[-3] != 0 || pbDest[-2] != 0 || pbDest[-1] != 128){
				if(bCmdHeader == FALSE){
					bCmdHeader = TRUE;
					WRITESPOOLBUF(pdevobj, "\x1d\x32\x20\x61", 4);
				}
				WRITESPOOLBUF(pdevobj, abBuff, (DWORD)(pbDest - abBuff));
				uSerialCode = (uSerialCode + 1) & 0x0f;
				uFlags = 0xe0;
			}
			pbSrcTmp += cBlockByteWidth;
		}
		pbSrc += cSrcByteWidth * cyBlock;
		uFlags = 0xd0;
	}

	if(bCmdHeader != FALSE){
		abBuff[0] = uSerialCode | 0xf0;
		WRITESPOOLBUF(pdevobj, abBuff, 1);
	}
}




// end of fuimg4.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fumh.h ===
//----------------------------------------------------------------------
//	FILE NAME	: FUMH.h
//	FUNCTION	: MH Compress
//	AUTHER		: 1996.08.08 FPL)Y.YUTANI
//	NOTE		: for Windows NT V4.0
//----------------------------------------------------------------------
#ifndef fumh_h
#define	fumh_h

DWORD	MhCompress(
	BYTE *pDest,
	DWORD cDestN,
	BYTE *pSrc, 
	DWORD cSrcN,
	DWORD cSrcX,
	DWORD cSrcY
);

#endif // !fumh_h

// end of FUMH.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuimg2.h ===
//
// fuimg2.h
//
// September.3,1997 H.Ishida (FPL)
// fjxlres.dll (NT5.0 MiniDriver)
//
// Aug.2,1996 H.Ishida(FPL)
// FJXL.DLL (NT4.0 MiniDriver)
//
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997
#ifndef fuimg2_h
#define	fuimg2_h


void fuxlOutputRTGIMG2(PDEVOBJ pdevobj, LPCBYTE lpBuf, UINT bxBuf, UINT y, UINT cy);


#endif // fuimg2_h
// end of fuimg2.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fumh.c ===
//-----------------------------------------------------------------------------
//	FILE NAME	: FUMH.C
//	FUNCTION	: MH Compress and MH2 Compress
//	AUTHER		: 1996.08.08 FPL)Y.YUTANI
//	NOTE		: for Windows NT V4.0
//  MODIFY      : Reduce data size Oct.31,1996 H.Ishida
//  MODIFY      : for NT.50 MiniDriver Sep.3,1997 H.Ishida(FPL)
//-----------------------------------------------------------------------------
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997

#include <minidrv.h>
#include "fumhdef.h"

const
CODETABLE
WhiteMakeUpTable[] = 
{
    { 0xd800, 5 },
    { 0x9000, 5 },
    { 0x5c00, 6 },
    { 0x6e00, 7 },
    { 0x3600, 8 },
    { 0x3700, 8 },
    { 0x6400, 8 },
    { 0x6500, 8 },
    { 0x6800, 8 },
    { 0x6700, 8 },
    { 0x6600, 9 },
    { 0x6680, 9 },
    { 0x6900, 9 },
    { 0x6980, 9 },
    { 0x6a00, 9 },
    { 0x6a80, 9 },
    { 0x6b00, 9 },
    { 0x6b80, 9 },
    { 0x6c00, 9 },
    { 0x6c80, 9 },
    { 0x6d00, 9 },
    { 0x6d80, 9 },
    { 0x4c00, 9 },
    { 0x4c80, 9 },
    { 0x4d00, 9 },
    { 0x6000, 6 },
    { 0x4d80, 9 },
    { 0x0100, 11 },
    { 0x0180, 11 },
    { 0x01a0, 11 },
    { 0x0120, 12 },
    { 0x0130, 12 },
    { 0x0140, 12 },
    { 0x0150, 12 },
    { 0x0160, 12 },
    { 0x0170, 12 },
    { 0x01c0, 12 },
    { 0x01d0, 12 },
    { 0x01e0, 12 },
    { 0x01f0, 12 },
    { 0x3500, 8 },
    { 0x1c00, 6 },
    { 0x7000, 4 },
    { 0x8000, 4 },
    { 0xb000, 4 },
    { 0xc000, 4 },
    { 0xe000, 4 },
    { 0xf000, 4 },
    { 0x9800, 5 },
    { 0xa000, 5 },
    { 0x3800, 5 },
    { 0x4000, 5 },
    { 0x2000, 6 },
    { 0x0c00, 6 },
    { 0xd000, 6 },
    { 0xd400, 6 },
    { 0xa800, 6 },
    { 0xac00, 6 },
    { 0x4e00, 7 },
    { 0x1800, 7 },
    { 0x1000, 7 },
    { 0x2e00, 7 },
    { 0x0600, 7 },
    { 0x0800, 7 },
};

const
CODETABLE
WhiteTerminateTable[] =
{
    { 0x3500, 8 },
    { 0x1c00, 6 },
    { 0x7000, 4 },
    { 0x8000, 4 },
    { 0xb000, 4 },
    { 0xc000, 4 },
    { 0xe000, 4 },
    { 0xf000, 4 },
    { 0x9800, 5 },
    { 0xa000, 5 },
    { 0x3800, 5 },
    { 0x4000, 5 },
    { 0x2000, 6 },
    { 0x0c00, 6 },
    { 0xd000, 6 },
    { 0xd400, 6 },
    { 0xa800, 6 },
    { 0xac00, 6 },
    { 0x4e00, 7 },
    { 0x1800, 7 },
    { 0x1000, 7 },
    { 0x2e00, 7 },
    { 0x0600, 7 },
    { 0x0800, 7 },
    { 0x5000, 7 },
    { 0x5600, 7 },
    { 0x2600, 7 },
    { 0x4800, 7 },
    { 0x3000, 7 },
    { 0x0200, 8 },
    { 0x0300, 8 },
    { 0x1a00, 8 },
    { 0x1b00, 8 },
    { 0x1200, 8 },
    { 0x1300, 8 },
    { 0x1400, 8 },
    { 0x1500, 8 },
    { 0x1600, 8 },
    { 0x1700, 8 },
    { 0x2800, 8 },
    { 0x2900, 8 },
    { 0x2a00, 8 },
    { 0x2b00, 8 },
    { 0x2c00, 8 },
    { 0x2d00, 8 },
    { 0x0400, 8 },
    { 0x0500, 8 },
    { 0x0a00, 8 },
    { 0x0b00, 8 },
    { 0x5200, 8 },
    { 0x5300, 8 },
    { 0x5400, 8 },
    { 0x5500, 8 },
    { 0x2400, 8 },
    { 0x2500, 8 },
    { 0x5800, 8 },
    { 0x5900, 8 },
    { 0x5a00, 8 },
    { 0x5b00, 8 },
    { 0x4a00, 8 },
    { 0x4b00, 8 },
    { 0x3200, 8 },
    { 0x3300, 8 },
    { 0x3400, 8 },
};

const
CODETABLE
BlackMakeUpTable[] = 
{
    { 0x03c0, 10 },
    { 0x0c80, 12 },
    { 0x0c90, 12 },
    { 0x05b0, 12 },
    { 0x0330, 12 },
    { 0x0340, 12 },
    { 0x0350, 12 },
    { 0x0360, 13 },
    { 0x0368, 13 },
    { 0x0250, 13 },
    { 0x0258, 13 },
    { 0x0260, 13 },
    { 0x0268, 13 },
    { 0x0390, 13 },
    { 0x0398, 13 },
    { 0x03a0, 13 },
    { 0x03a8, 13 },
    { 0x03b0, 13 },
    { 0x03b8, 13 },
    { 0x0290, 13 },
    { 0x0298, 13 },
    { 0x02a0, 13 },
    { 0x02a8, 13 },
    { 0x02d0, 13 },
    { 0x02d8, 13 },
    { 0x0320, 13 },
    { 0x0328, 13 },
    { 0x0100, 11 },
    { 0x0180, 11 },
    { 0x01a0, 11 },
    { 0x0120, 12 },
    { 0x0130, 12 },
    { 0x0140, 12 },
    { 0x0150, 12 },
    { 0x0160, 12 },
    { 0x0170, 12 },
    { 0x01c0, 12 },
    { 0x01d0, 12 },
    { 0x01e0, 12 },
    { 0x01f0, 12 },
    { 0x0dc0, 10 },
    { 0x4000, 3 },
    { 0xc000, 2 },
    { 0x8000, 2 },
    { 0x6000, 3 },
    { 0x3000, 4 },
    { 0x2000, 4 },
    { 0x1800, 5 },
    { 0x1400, 6 },
    { 0x1000, 6 },
    { 0x0800, 7 },
    { 0x0a00, 7 },
    { 0x0e00, 7 },
    { 0x0400, 8 },
    { 0x0700, 8 },
    { 0x0c00, 9 },
    { 0x05c0, 10 },
    { 0x0600, 10 },
    { 0x0200, 10 },
    { 0x0ce0, 11 },
    { 0x0d00, 11 },
    { 0x0d80, 11 },
    { 0x06e0, 11 },
    { 0x0500, 11 },
};

const
CODETABLE
BlackTerminateTable[] =
{
    { 0x0dc0, 10 },
    { 0x4000, 3 },
    { 0xc000, 2 },
    { 0x8000, 2 },
    { 0x6000, 3 },
    { 0x3000, 4 },
    { 0x2000, 4 },
    { 0x1800, 5 },
    { 0x1400, 6 },
    { 0x1000, 6 },
    { 0x0800, 7 },
    { 0x0a00, 7 },
    { 0x0e00, 7 },
    { 0x0400, 8 },
    { 0x0700, 8 },
    { 0x0c00, 9 },
    { 0x05c0, 10 },
    { 0x0600, 10 },
    { 0x0200, 10 },
    { 0x0ce0, 11 },
    { 0x0d00, 11 },
    { 0x0d80, 11 },
    { 0x06e0, 11 },
    { 0x0500, 11 },
    { 0x02e0, 11 },
    { 0x0300, 11 },
    { 0x0ca0, 12 },
    { 0x0cb0, 12 },
    { 0x0cc0, 12 },
    { 0x0cd0, 12 },
    { 0x0680, 12 },
    { 0x0690, 12 },
    { 0x06a0, 12 },
    { 0x06b0, 12 },
    { 0x0d20, 12 },
    { 0x0d30, 12 },
    { 0x0d40, 12 },
    { 0x0d50, 12 },
    { 0x0d60, 12 },
    { 0x0d70, 12 },
    { 0x06c0, 12 },
    { 0x06d0, 12 },
    { 0x0da0, 12 },
    { 0x0db0, 12 },
    { 0x0540, 12 },
    { 0x0550, 12 },
    { 0x0560, 12 },
    { 0x0570, 12 },
    { 0x0640, 12 },
    { 0x0650, 12 },
    { 0x0520, 12 },
    { 0x0530, 12 },
    { 0x0240, 12 },
    { 0x0370, 12 },
    { 0x0380, 12 },
    { 0x0270, 12 },
    { 0x0280, 12 },
    { 0x0580, 12 },
    { 0x0590, 12 },
    { 0x02b0, 12 },
    { 0x02c0, 12 },
    { 0x05a0, 12 },
    { 0x0660, 12 },
    { 0x0670, 12 },
};

//-----------------------------------------------------------------------------
//	DWORD	FjCountBits
//		BYTE	*pTmp		Pointer of sources area
//		DWORD	cBitstmp	Now bit number from top of sources area
//		DWORD	cBitsMax	Last bits number in this line
//		BOOL	hWhite		color flag
//							TRUE	: counting white bits
//							FALSE	: counting black bits
//		Return code	:	Join same color bits number
//-----------------------------------------------------------------------------
DWORD FjCountBits( BYTE *pTmp, DWORD cBitsTmp, DWORD cBitsMax, BOOL bWhite )
{
    DWORD cBits, k;

    pTmp += (cBitsTmp / 8);
    k = cBitsTmp % 8;
    
    for (cBits = 0; cBits < cBitsMax; cBits++) {
        
        if (((*pTmp & (1 << (7 - k))) == 0) != bWhite)
            break;

        k++;
        if (k == 8) {
            k = 0;
            pTmp++;
        }
    } 

    return cBits;
}

//-----------------------------------------------------------------------------
//	VOID	FjBitsCopy
//		BYTE	*pTmp		Pointer of destinaition area
//		DWORD	cBitsTmp	Bit number from top of destination area
//		DWORD	dwCode		Copy code
//		INT		cCopyBits	Copy size(bit)
//-----------------------------------------------------------------------------
VOID FjBitsCopy( BYTE *pTmp, DWORD cBitsTmp, DWORD dwCode, INT cCopyBits )
{
	INT k, cBits;
	DWORD dwMask, dwTmp;

	pTmp += (cBitsTmp / 8);
	k = cBitsTmp % 8;

	cBits = cCopyBits + k;

	dwTmp = (DWORD)*pTmp << 16;
	dwTmp &= 0xff000000L >> k;
	dwTmp |= dwCode << (8 - k);

	if( cBits <= 8 ) {
		*pTmp = (BYTE)(dwTmp >> 16);
	} else if( cBits <= 16 ) {
		*pTmp = (BYTE)(dwTmp >> 16);
		*(pTmp + 1) = (BYTE)(dwTmp >> 8);
	} else {
		*pTmp = (BYTE)(dwTmp >> 16);
		*(pTmp + 1) = (BYTE)(dwTmp >> 8);
		*(pTmp + 2) = (BYTE)dwTmp;
	}
}
//-----------------------------------------------------------------------------
//	DWORD	MhCompress
//		BYTE	*pDest	Pointer of destinaition area
//		DWORD	cDestN	Size of destination area(byte)
//		BYTE	*pSrc	Pointer of sources area
//		DWORD	cSrcN	Size of sources area(byte)
//		DWORD	cSrcX	Sources image x width
//		DWORD	cSrcY	Sources image y height
//		Return code	:	Writing size to destination area
//-----------------------------------------------------------------------------
DWORD MhCompress( BYTE *pDest, DWORD cDestN, BYTE *pSrc, DWORD cSrcN, DWORD cSrcX, DWORD cSrcY )
{
	DWORD		cBitsSrc, cBitsSrcMax;
	DWORD		cBitsDest, cBitsDestMax, cBitsDestMark;
	DWORD		cBitsRun;
	DWORD		dwCode, cBits;
	DWORD		i;
	PATNINFO	ptnInfo;

	cBitsDest = 0;
	cBitsSrc = 0;

	cBitsDestMax = cDestN * 8;
	
	for (i = 0; i < cSrcY; i++) {

		// Set initial color
		ptnInfo.dwNextColor = NEXT_COLOR_WHITE;

		// Top EOL
		if (cBitsDest + CBITS_EOL_CODE > cBitsDestMax)
 			return 0;
		FjBitsCopy(pDest, cBitsDest, EOL_CODE, CBITS_EOL_CODE);
 		cBitsDest += CBITS_EOL_CODE;
// vvv Oct.31,1996 H.Ishida
		cBitsDestMark = cBitsDest;
// ^^^ Oct.31,1996 H.Ishida

		// Encode
		cBitsSrcMax = cBitsSrc + (cSrcX * 8);
		
		// Compress one line image
		while ( cBitsSrc < cBitsSrcMax ) {

			// Next run is white
 			if( ptnInfo.dwNextColor == NEXT_COLOR_WHITE ) {
			
				// Count white bits
				cBitsRun = FjCountBits(pSrc, cBitsSrc, (cBitsSrcMax - cBitsSrc), TRUE);
				cBitsSrc += cBitsRun;
// vvv Oct.31,1996 H.Ishida
				// reduce data size
				if(cBitsSrc >= cBitsSrcMax){
					if(cBitsDest > cBitsDestMark)
						break;
					cBitsRun = 2;			// Whole white line is convert to white 2 dots:Minimun MH data.
				}
// ^^^ Oct.31,1996 H.Ishida
				// Careful, white run length over maximam
				while( cBitsRun > RUNLENGTH_MAX ) {
					dwCode = WhiteMakeUpTable[MAKEUP_TABLE_MAX - 1].wCode;
					cBits = WhiteMakeUpTable[MAKEUP_TABLE_MAX - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
					cBitsRun -= RUNLENGTH_MAX;
				}
				if (cBitsRun >= 64) {
					dwCode = WhiteMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].wCode;
					cBits = WhiteMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
				}
				dwCode = WhiteTerminateTable[cBitsRun % TERMINATE_MAX].wCode;
				cBits = WhiteTerminateTable[cBitsRun % TERMINATE_MAX].cBits;
				if (cBitsDest + cBits > cBitsDestMax)
					return 0;
				FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
				cBitsDest += cBits;
				ptnInfo.dwNextColor = NEXT_COLOR_BLACK;
			} else {

				// Black bits
				cBitsRun = FjCountBits(pSrc, cBitsSrc, (cBitsSrcMax - cBitsSrc), FALSE);
				cBitsSrc += cBitsRun;

				// Careful, black run length over maximam
				while( cBitsRun > RUNLENGTH_MAX ) {
					dwCode = BlackMakeUpTable[MAKEUP_TABLE_MAX - 1].wCode;
					cBits = BlackMakeUpTable[MAKEUP_TABLE_MAX - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
					cBitsRun -= RUNLENGTH_MAX;
				}
				if (cBitsRun >= 64) {
					dwCode = BlackMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].wCode;
					cBits = BlackMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
				}
				dwCode = BlackTerminateTable[cBitsRun % TERMINATE_MAX].wCode;
				cBits = BlackTerminateTable[cBitsRun % TERMINATE_MAX].cBits;
				if (cBitsDest + cBits > cBitsDestMax)
					return 0;
				FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
				cBitsDest += cBits;
				ptnInfo.dwNextColor = NEXT_COLOR_WHITE;
			}
        }
		// End of one raster
	}

	// Last EOL.
	if (cBitsDest + CBITS_EOL_CODE > cBitsDestMax)
		return 0;
	FjBitsCopy(pDest, cBitsDest, EOL_CODE, CBITS_EOL_CODE);
	cBitsDest += CBITS_EOL_CODE;

	// Pad with 0 until byte boundary
	if ((cBits = (8 - (cBitsDest % 8)) % 8) != 0) {
		if (cBitsDest + cBits > cBitsDestMax)
			return 0;
		FjBitsCopy(pDest, cBitsDest, FILL_CODE, cBits);
		cBitsDest += cBits;
	}

	return cBitsDest / 8;
}
// end of FUMH.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fumh2.c ===
//-----------------------------------------------------------------------------
//	FILE NAME	: FUMH2.c
//	FUNCTION	: MH Compress and MH2 Compress
//	AUTHER		: 1996.08.08 FPL)Y.YUTANI
//	NOTE		: for Windows NT V4.0
//  MODIFY      : Reduce data size Oct.31,1996 H.Ishida
//  MODIFY      : for NT5.0 Minidriver Sep.3,1997 H.Ishida(FPL)
//-----------------------------------------------------------------------------
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997

#include <minidrv.h>
#include "fumhdef.h"

//-----------------------------------------------------------------------------
//	BOOL SameLineCheck
//		PBYTE	pSrc	Pointer of sources bits image
//		DWORD	cSrcX	Width size of sources image(byte)
//		Return code	:	TRUE	Same image line
//						FALSE	Not same image line
//-----------------------------------------------------------------------------
BOOL SameLineCheck( PBYTE pSrc, DWORD cSrcX )
{
	DWORD	i;
	PBYTE	pLine1, pLine2;
	
	pLine1 = pSrc;
	pLine2 = pSrc + cSrcX;
	for( i = 0; i < cSrcX; i++ ) {
		if( *pLine1 != *pLine2 ) return FALSE;
		pLine1++;
		pLine2++;
	}
	
	return TRUE;
}
//-----------------------------------------------------------------------------
//	DWORD	SamePatternCheck
//		BYTE		*pTmp		Pointer of sources bits image
//		DWORD		cBitsTmp	Bit number from top of sources bits image
//		DWORD		cBitsMax	Maximam bit of sources bits image
//		PATNINFO	*pInfo		Pointer of Same pattern finormation struction
//		Rerutn code	:	Sources bit number
//-----------------------------------------------------------------------------
DWORD SamePatternCheck( BYTE *pTmp, DWORD cBitsTmp, DWORD cBitsMax, PATNINFO *pInfo )
{
	DWORD	cBits, k;
	BYTE	ptn1, ptn2;
	DWORD	dwPtn;

	// Initial same pattern number
	pInfo->dwPatnNum = 1;
	
	// Nothing remain bits
	if( cBitsTmp >= cBitsMax ) return cBitsTmp;
	
	// Caluclation sources bytes and bits
	pTmp += (cBitsTmp / 8);
	k = cBitsTmp % 8;
	
	// If remain bits bolow 16bits, return function
	if( ( cBitsTmp + 16 ) > cBitsMax ) return cBitsTmp;
	
	// Get Top 8bits(bit number is byte baundary?)
#if 1
	if( k != 0 ) {
		ptn1 = *pTmp << k;
		ptn1 |= *(pTmp+1) >> ( 8 - k );
	} else {
		ptn1 = *pTmp;
	}
#else
	dwPtn = *pTmp;
	dwPtn <<= 8;
	dwPtn |= *(pTmp+1);
	dwPtn <<= k;
	ptn1 = (BYTE)((dwPtn >> 8) & 0x00ff);
#endif
	// If 8bits image is all white or black, return function
	if( ptn1 == ALL_BLACK || ptn1 == ALL_WHITE ) return cBitsTmp;
	
	// Compare top 8bits image and next 8bits image
	// (Careful same pattern number maximam)
	for (cBits = cBitsTmp + 8;
		(cBits + 7 < cBitsMax) && (pInfo->dwPatnNum < SAMEPATN_MAX); cBits += 8 ) {
		pTmp++;
#if 1
		if( k != 0 ) {
			ptn2 = *pTmp << k;
			ptn2 |= *(pTmp+1) >> ( 8 - k );
		} else {
			ptn2 = *pTmp;
		}
#else
		dwPtn = *pTmp;
		dwPtn <<= 8;
		dwPtn |= *(pTmp+1);
		dwPtn <<= k;
		ptn2 = (BYTE)((dwPtn >> 8) & 0x00ff);
#endif
		// If top image not iqual next image, stop counting same pattern
		if( ptn1 != ptn2 ) break;

		// Same pattern number addition
		pInfo->dwPatnNum++;
		
	}
	
	// Nothing same pattern
	if( pInfo->dwPatnNum == 1 ) return cBitsTmp;
	
	// Set pattern
	pInfo->dwPatn = (DWORD)ptn1;
	
	// If bits remain, check joint bit's color and set
	if( cBits < cBitsMax ) {
		if ( (*pTmp & (1 << (7 - k)) ) == 0 ) {
			pInfo->dwNextColor = NEXT_COLOR_WHITE;
		} else {
			pInfo->dwNextColor = NEXT_COLOR_BLACK;
		}
	} else {
		pInfo->dwNextColor = NEXT_COLOR_WHITE;
	}
	return cBits;
}
//-----------------------------------------------------------------------------
//	DWORD	Mh2Compress
//		BYTE	*pDest	Pointer of destinaition area
//		DWORD	cDestN	Size of destination area(byte)
//		BYTE	*pSrc	Pointer of sources area
//		DWORD	cSrcN	Size of sources area(byte)
//		DWORD	cSrcX	Sources image x width
//		DWORD	cSrcY	Sources image y height
//		Return code	:	Writing size to destination area
//-----------------------------------------------------------------------------
DWORD Mh2Compress( BYTE *pDest, DWORD cDestN, BYTE *pSrc, DWORD cSrcN, DWORD cSrcX, DWORD cSrcY )
{
	DWORD		cBitsSrc, cBitsSrcMax;
	DWORD		cBitsDest, cBitsDestMax, cBitsDestMark;
	DWORD		cBitsRun;
	DWORD		dwCode, cBits;
	DWORD		i;
	DWORD		dwSameLine;
	PBYTE		pSrcLine;
	PATNINFO	ptnInfo;

	cBitsDest = 0;
	cBitsSrc = 0;
	dwSameLine = 1;

	cBitsDestMax = cDestN * 8;
	
	for (i = 0; i < cSrcY; i++) {

		// Set initial color
		ptnInfo.dwNextColor = NEXT_COLOR_WHITE;

		// Top pointer of now line
		pSrcLine = pSrc + ( i * cSrcX );

		// Now line equal next line image?(No check last line)
		if( i != ( cSrcY - 1 ) ) {
			if( SameLineCheck( pSrcLine, cSrcX ) ) {
				dwSameLine++;
				cBitsSrc += ( cSrcX * 8 );
				if( dwSameLine < SAMELINE_MAX ) continue;
			}
		}
		// Top EOL
		if (cBitsDest + CBITS_EOL_CODE > cBitsDestMax)
 			return 0;
		FjBitsCopy(pDest, cBitsDest, EOL_CODE, CBITS_EOL_CODE);
 		cBitsDest += CBITS_EOL_CODE;
		
		// There are same lines
		if( dwSameLine > 1 ) {
			if (cBitsDest + CBITS_SAMELINE > cBitsDestMax)
				return 0;
			// Set same line code
			FjBitsCopy( pDest, cBitsDest, SAMELINE_CODE, CBITS_SAMELINE_CODE );
			cBitsDest += CBITS_SAMELINE_CODE;
			// Set same line number
			FjBitsCopy( pDest, cBitsDest, dwSameLine << 8, CBITS_SAMELINE_NUM );
			cBitsDest += CBITS_SAMELINE_NUM;
			// Initial same line number
			dwSameLine = 1;
		}
// vvv Oct.31,1996 H.Ishida
		cBitsDestMark = cBitsDest;
// ^^^ Oct.31,1996 H.Ishida

		// Encode
		cBitsSrcMax = cBitsSrc + (cSrcX * 8);
		
		// Compress one line image
		while ( cBitsSrc < cBitsSrcMax ) {

			// Check same pattern
			cBitsSrc = SamePatternCheck( pSrc, cBitsSrc, cBitsSrcMax, &ptnInfo );
			// there are same patterns
			if( ptnInfo.dwPatnNum > 1 ) {
				if ( ( cBitsDest + CBITS_SAMEPATN ) > cBitsDestMax)
					return 0;
				// Set same pattern code
				FjBitsCopy(pDest, cBitsDest, SAMEPATN_CODE, CBITS_SAMEPATN_CODE );
				cBitsDest += CBITS_SAMEPATN_CODE;
				// Set same pattern image
				FjBitsCopy(pDest, cBitsDest, ptnInfo.dwPatn << 8, CBITS_SAMEPATN_BYTE );
				cBitsDest += CBITS_SAMEPATN_BYTE;
				ptnInfo.dwPatnNum <<= 5;
				ptnInfo.dwPatnNum |= ptnInfo.dwNextColor;
				// Set same pattern number & next run color
				FjBitsCopy(pDest, cBitsDest, ptnInfo.dwPatnNum, CBITS_SAMEPATN_NUM );
				cBitsDest += CBITS_SAMEPATN_NUM;
				// Unknown same pattern on after here
				continue;
			}
			
			// Next run is white
 			if( ptnInfo.dwNextColor == NEXT_COLOR_WHITE ) {

				// Count white bits
				cBitsRun = FjCountBits(pSrc, cBitsSrc, (cBitsSrcMax - cBitsSrc), TRUE);
				cBitsSrc += cBitsRun;
// vvv Oct.31,1996 H.Ishida
				// reduce data size
				if(cBitsSrc >= cBitsSrcMax){
					if(cBitsDest > cBitsDestMark)
						break;
					cBitsRun = 2;			// Whole white line is convert to white 2 dots:Minimun MH data.
				}
// ^^^ Oct.31,1996 H.Ishida

				// Careful, white run length over maximam
				while( cBitsRun > RUNLENGTH_MAX ) {
					dwCode = WhiteMakeUpTable[MAKEUP_TABLE_MAX - 1].wCode;
					cBits = WhiteMakeUpTable[MAKEUP_TABLE_MAX - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
					cBitsRun -= RUNLENGTH_MAX;
				}
				if (cBitsRun >= 64) {
					dwCode = WhiteMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].wCode;
					cBits = WhiteMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
				}
				dwCode = WhiteTerminateTable[cBitsRun % TERMINATE_MAX].wCode;
				cBits = WhiteTerminateTable[cBitsRun % TERMINATE_MAX].cBits;
				if (cBitsDest + cBits > cBitsDestMax)
					return 0;
				FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
				cBitsDest += cBits;
				ptnInfo.dwNextColor = NEXT_COLOR_BLACK;
			} else {

				// Black bits
				cBitsRun = FjCountBits(pSrc, cBitsSrc, (cBitsSrcMax - cBitsSrc), FALSE);
				cBitsSrc += cBitsRun;

				// Careful, black run length over maximam
				while( cBitsRun > RUNLENGTH_MAX ) {
					dwCode = BlackMakeUpTable[MAKEUP_TABLE_MAX - 1].wCode;
					cBits = BlackMakeUpTable[MAKEUP_TABLE_MAX - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
					cBitsRun -= RUNLENGTH_MAX;
				}
				if (cBitsRun >= 64) {
					dwCode = BlackMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].wCode;
					cBits = BlackMakeUpTable[(cBitsRun / TERMINATE_MAX) - 1].cBits;
					if (cBitsDest + cBits > cBitsDestMax)
						return 0;
					FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
					cBitsDest += cBits;
				}
				dwCode = BlackTerminateTable[cBitsRun % TERMINATE_MAX].wCode;
				cBits = BlackTerminateTable[cBitsRun % TERMINATE_MAX].cBits;
				if (cBitsDest + cBits > cBitsDestMax)
					return 0;
				FjBitsCopy(pDest, cBitsDest, dwCode, cBits);
				cBitsDest += cBits;
				ptnInfo.dwNextColor = NEXT_COLOR_WHITE;
			}
		}
        // End of one raster
	}

	// Last EOL.
	if (cBitsDest + CBITS_EOL_CODE > cBitsDestMax)
		return 0;
	FjBitsCopy(pDest, cBitsDest, EOL_CODE, CBITS_EOL_CODE);
	cBitsDest += CBITS_EOL_CODE;

	// Pad with 0 until byte boundary
	if ((cBits = (8 - (cBitsDest % 8)) % 8) != 0) {
		if (cBitsDest + cBits > cBitsDestMax)
			return 0;
		FjBitsCopy(pDest, cBitsDest, FILL_CODE, cBits);
		cBitsDest += cBits;
	}

	return cBitsDest / 8;
}
// end of FUMH2.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\name.h ===
CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fumh2.h ===
//----------------------------------------------------------------------
//	FILE NAME	: fumh2.h
//	FUNCTION	: MH2 Compress
//	AUTHER		: 1996.08.01 FPL)Y.YUTANI
//	NOTE		: for Windows NT V4.0
//  MODIFY      : for NT4.0 Minidriver H.Ishida(FPL)
//----------------------------------------------------------------------
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997
#ifndef fumh2_h
#define	fumh2_h

DWORD	Mh2Compress(
	BYTE *pDest,
	DWORD cDestN,
	BYTE *pSrc, 
	DWORD cSrcN,
	DWORD cSrcX,
	DWORD cSrcY
);

#endif // !fumh2_h

// end of fumh2.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fumhdef.h ===
//-----------------------------------------------------------------------------
//	FILE NAME	: FUMHDEF.H
//	AUTHER		: 1996.08.08 FPL)Y.YUTANI
//	NOTE		: MH,MH2 Compress Heder File for FJXL.DLL
//			:               (for Windows NT V4.0)
//  MODIFY      : for NT5.0 Minidriver Sep.3,1997 H.Ishida (FPL)
//-----------------------------------------------------------------------------
// COPYRIGHT(C) FUJITSU LIMITED 1996-1997
#define	RAMDOM_BIT				1

#define	NEXT_COLOR_WHITE		0x0000
#define	NEXT_COLOR_BLACK		0x0010
#define	ALL_WHITE				0x00
#define	ALL_BLACK				0xFF
#define	EOL_CODE				0x0010
#define	FILL_CODE				0x0000
#define	SAMELINE_CODE			0x0080
#define	SAMEPATN_CODE			0x0090
#define	CBITS_EOL_CODE			12
#define	CBITS_SAMELINE_CODE		12
#define	CBITS_SAMELINE_NUM		8
#define	CBITS_SAMELINE			( CBITS_SAMELINE_CODE + CBITS_SAMELINE_NUM )
#define	CBITS_SAMEPATN_CODE		12
#define	CBITS_SAMEPATN_BYTE		8
#define	CBITS_SAMEPATN_NUM		12
#define	CBITS_SAMEPATN			( CBITS_SAMEPATN_CODE + CBITS_SAMEPATN_BYTE + CBITS_SAMEPATN_NUM )

#define	SAMELINE_MAX			255
#define	SAMEPATN_MAX			2047
#define	RUNLENGTH_MAX			2560
#define	TERMINATE_MAX			64
#define	MAKEUP_TABLE_MAX		40

// MH code table struction
typedef struct {
    WORD	wCode;			//	Run code
    WORD	cBits;			//	Run length
} CODETABLE;

// Same pattern informaiton sturction
typedef struct {
	DWORD	dwPatn;			//	Same pattern image(8bits)
	DWORD	dwPatnNum;		//	Same pattern number
	DWORD	dwNextColor;	//	Color of next bit
} PATNINFO;

extern	const CODETABLE WhiteMakeUpTable[];
extern	const CODETABLE WhiteTerminateTable[];
extern	const CODETABLE BlackMakeUpTable[];
extern	const CODETABLE BlackTerminateTable[];

DWORD	FjCountBits( BYTE *pTmp, DWORD cBitsTmp, DWORD cBitsMax, BOOL bWhite );
VOID	FjBitsCopy( BYTE *pTmp, DWORD cBitsTmp, DWORD dwCode, INT cCopyBits );

// end of FUMHDEF.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuxldm.c ===
///////////////////////////////////////////////////
// fuxldm.c
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#include "fuxl.h"
#include "fudebug.h"

// MINI5 Export func.
BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
	TRACEOUT(("[OEMGetInfo]\r\n"))

	if(pcbNeeded == NULL){
  		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

  	*pcbNeeded = sizeof(DWORD);
  	if(NULL == pBuffer || sizeof(DWORD) > cbSize){
  		SetLastError(ERROR_INSUFFICIENT_BUFFER);
  		return FALSE;
  	}

	switch(dwInfo){
	  case OEMGI_GETSIGNATURE:
		TRACEOUT(("OEMGI_GETSIGNATURE\r\n"))
	  	*(LPDWORD)pBuffer = FUXL_OEM_SIGNATURE;
	  	break;
	  case OEMGI_GETINTERFACEVERSION:
		TRACEOUT(("OEMGI_GETINTERFACEVERSION\r\n"))
	  	*(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
	  	break;
	  case OEMGI_GETVERSION:
		TRACEOUT(("OEMGI_GETVERSION\r\n"))
	  	*(LPDWORD)pBuffer = FUXL_OEM_VERSION;
	  	break;
	  default:
		TRACEOUT(("invalid dwInfo\r\n"))
	  	SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}
	return TRUE;
}



static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
    if(NULL == pOEMDevModeParam){
    	TRACEOUT(("pOEMDevModeParam is NULL\r\n"))
    	return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize){
    	TRACEOUT(("pOEMDevModeParam->cbSize (%d) is less than sizeof(OEMDMPARAM)\r\n", pOEMDevModeParam->cbSize))
        return FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter){
		TRACEOUT(("pOEMDevModeParam->hPrinter is NULL\r\n"))
		return FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule){
		TRACEOUT(("pOEMDevModeParam->hModule is NULL\r\n"))
        return FALSE;
    }

    if((0 != pOEMDevModeParam->cbBufSize) && (NULL == pOEMDevModeParam->pOEMDMOut)){
		TRACEOUT(("pOEMDevModeParam->cbBufSize is not 0, and, pOEMDMOut is NULL\r\n"))
		return FALSE;
    }

    if((OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn)){
		TRACEOUT(("dwMode is OEMDM_MERGE && pOEMDMIn is NULL\r\n"))
		return FALSE;
    }

    return TRUE;
}



static void fuxlInitOEMExtraData(PFUXL_OEM_EXTRADATA pFuxlOEMExtra)
{
	pFuxlOEMExtra->dmExtraHdr.dwSize = sizeof(FUXL_OEM_EXTRADATA);
	pFuxlOEMExtra->dmExtraHdr.dwSignature = FUXL_OEM_SIGNATURE;
	pFuxlOEMExtra->dmExtraHdr.dwVersion = FUXL_OEM_VERSION;
}



static void fuxlMergeOEMExtraData(
	PFUXL_OEM_EXTRADATA pFuxlOEMExtraIn,
	PFUXL_OEM_EXTRADATA pFuxlOEMExtraOut)
{
}



// MINI5 Export func.
BOOL APIENTRY OEMDevMode(DWORD dwMode, POEMDMPARAM pOEMDevModeParam)
{
	TRACEOUT(("[OEMDevMode]\r\n"))

	if(BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam) == FALSE){
		TRACEOUT(("invalid OEMDevModeParam\r\n"))
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	if(dwMode == OEMDM_SIZE){
		pOEMDevModeParam->cbBufSize = sizeof(FUXL_OEM_EXTRADATA);
		TRACEOUT(("OEMDM_SIZE %d\r\n", pOEMDevModeParam->cbBufSize))
		return TRUE;
	}

	if(sizeof(FUXL_OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize){
		TRACEOUT(("cbBufSize %d\r\n", pOEMDevModeParam->cbBufSize))
  		SetLastError(ERROR_INSUFFICIENT_BUFFER);
		return FALSE;
	}

	switch(dwMode){
	  case OEMDM_DEFAULT:
		TRACEOUT(("OEMDM_DEFAULT\r\n"));
	  	fuxlInitOEMExtraData((PFUXL_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
		break;
	  case OEMDM_CONVERT:
		TRACEOUT(("OEMDM_CONVERT\r\n"));
	  	fuxlInitOEMExtraData((PFUXL_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
		break;
	  case OEMDM_MERGE:
		TRACEOUT(("OEMDM_MERGE\r\n"));
		fuxlMergeOEMExtraData((PFUXL_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
							(PFUXL_OEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);
		break;
	  default:
		TRACEOUT(("invalid dwMode\r\n"));
	  	SetLastError(ERROR_INVALID_PARAMETER);
	  	return FALSE;
	  	break;
	}
	return TRUE;
}



// end of fuxldm.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuxlres.c ===
/////////////////////////////////////////
// fuxlres.c
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997


#include "fuxl.h"
#include "fuband.h"
#include "fudebug.h"

// for lib.h debug
DWORD gdwDrvMemPoolTag = 'meoD';

#define	MIN_FREE_WIDTH_300		1063
#define	MAX_FREE_WIDTH_300		3390
#define	MIN_FREE_LENGTH_300		1630
#define	MAX_FREE_LENGTH_300		4843

#define	MIN_FREE_WIDTH_600		2126
#define	MAX_FREE_WIDTH_600		6780
#define	MIN_FREE_LENGTH_600		3260
#define	MAX_FREE_LENGTH_600		9686


#define	FUXL_UNKNOWN			(DWORD)-1


#define	CMDID_ORIENTATION_PORTRAIT			20
#define	CMDID_ORIENTATION_LANDSCAPE			21

#define	CMDID_INPUTBIN_AUTO				30
#define	CMDID_INPUTBIN_MANUAL			31
#define	CMDID_INPUTBIN_BIN1				32
#define	CMDID_INPUTBIN_BIN2				33
#define	CMDID_INPUTBIN_BIN3				34
#define	CMDID_INPUTBIN_BIN4				35

#define	CMDID_RESOLUTION_300				40
#define	CMDID_RESOLUTION_600				41

#define	CMDID_FORM_A3						50
#define	CMDID_FORM_A4						51
#define	CMDID_FORM_A5						52
#define	CMDID_FORM_B4						53
#define	CMDID_FORM_B5						54
#define	CMDID_FORM_LETTER					55
#define	CMDID_FORM_LEGAL					56
#define	CMDID_FORM_JAPANESE_POSTCARD		57
#define	CMDID_FORM_CUSTOM_SIZE				58

#define	CMDID_START_JOB						60
#define	CMDID_END_JOB						61

#define	CMDID_START_DOC						70
#define	CMDID_END_DOC						71


#define	CMDID_START_PAGE					80
#define	CMDID_END_PAGE						81

#define	CMDID_COPIES						90

#define	CMDID_FF							100
#define	CMDID_CR							101
#define	CMDID_LF							102
#define	CMDID_SET_LINE_SPACING				103

#define	CMDID_X_MOVE						110
#define	CMDID_Y_MOVE						111
#define	CMDID_SEND_BLOCK_0					120
#define	CMDID_SEND_BLOCK_1					121

#define	CMDID_SIZEREDUCTION_100				130
#define	CMDID_SIZEREDUCTION_80				131
#define	CMDID_SIZEREDUCTION_70				132

#define	CMDID_SMOOTHING_OFF					140
#define	CMDID_SMOOTHING_ON					141

#define	CMDID_TONERSAVE_OFF					150
#define	CMDID_TONERSAVE_ON					151

#define	CMDID_DUPLEX_NONE					200
#define	CMDID_DUPLEX_VERTICAL				201
#define	CMDID_DUPLEX_HORIZONTAL				202

#define	CMDID_DUPLEX_POSITION_LEFTTOP		210
#define	CMDID_DUPLEX_POSITION_RIGHTBOTTOM	211

#define	CMDID_DUPLEX_WHITEPAGE_OFF			220
#define	CMDID_DUPLEX_WHITEPAGE_ON			221

#define	CMDID_DUPLEX_FRONTPAGE_MERGIN_0		300
#define	CMDID_DUPLEX_FRONTPAGE_MERGIN_30	330

#define	CMDID_DUPLEX_BACKPAGE_MERGIN_0		400
#define	CMDID_DUPLEX_BACKPAGE_MERGIN_30		430




PBYTE fuxlPutULONG(PBYTE pb, ULONG ulData)
{
	if(9 < ulData){
		pb = fuxlPutULONG(pb, ulData / 10);
	}

	*pb++ = (BYTE)('0' + ulData % 10);
	return pb;
}


PBYTE fuxlPutLONG(PBYTE pb, LONG lData)
{
	if(0 > lData){
		*pb++ = '-';
		lData = -lData;
	}
	return fuxlPutULONG(pb, (ULONG)lData);
}



BYTE fuxlGetHEX(int hi, int low)
{
	DWORD dwData = 0;

	if('0' <= hi && hi <= '9')
		dwData += (hi - '0');
	else if('a' <= hi && hi <= 'f')
		dwData += (hi - 'a') + 10;
	else if('A' <= hi && hi <= 'F')
		dwData += (hi - 'A') + 10;

	dwData *= 10;

	if('0' <= low && low <= '9')
		dwData += (low - '0');
	else if('a' <= low && low <= 'f')
		dwData += (low - 'a') + 10;
	else if('A' <= low && low <= 'F')
		dwData += (low - 'A') + 10;

	return (BYTE)dwData;
}



LPBYTE _cdecl fuxlFormatCommand(LPBYTE pbCmd, LPCSTR pszFmt, ...)
{
	LPCSTR	pch;
	LPBYTE	pb;
	
	va_list arg;
	va_start(arg, pszFmt);
	pb = pbCmd;
	for(pch = pszFmt; *pch != '\0'; ++pch){
		if(*pch == '%'){
			++pch;
			switch(*pch){
			  case 'd':		pb = fuxlPutLONG(pb, va_arg(arg, LONG));		break;
			  case 'u':	  	pb = fuxlPutULONG(pb, va_arg(arg, ULONG));	  	break;
			  case '%':		*pb++ = '%';								break;
			}
		}
		else if(*pch == '\\'){
			++pch;
			switch(*pch){
			  case 'r':		*pb++ = '\x0d';		break;
			  case 'n':		*pb++ = '\x0a';		break;
			  case 'f':		*pb++ = '\x0c';		break;
			  case '0':		*pb++ = '\0';		break;
			  case '\\':	*pb++ = '\\';		break;
			  case 'x':	  	*pb++ = fuxlGetHEX(pch[1], pch[2]);	pch += 2;  	break;
			}
		}
		else{
			*pb++ = *pch;
		}
	}
	va_end(arg);

	return pb;
}


void fuxlInitDevData(PFUXLDATA pData)
{
	pData->dwResolution = FUXL_UNKNOWN;
	pData->dwCopies = FUXL_UNKNOWN;
	pData->dwSizeReduction = FUXL_UNKNOWN;
	pData->dwSmoothing = FUXL_UNKNOWN;
	pData->dwTonerSave = FUXL_UNKNOWN;

	pData->dwForm = FUXL_UNKNOWN;
	pData->dwPaperWidth = FUXL_UNKNOWN;
	pData->dwPaperLength = FUXL_UNKNOWN;
	pData->dwPaperOrientation = FUXL_UNKNOWN;
	pData->dwInputBin = FUXL_UNKNOWN;

	pData->dwDuplex = FUXL_UNKNOWN;
	pData->dwDuplexPosition = FUXL_UNKNOWN;
	pData->dwDuplexFrontPageMergin = FUXL_UNKNOWN;
	pData->dwDuplexBackPageMergin = FUXL_UNKNOWN;
	pData->dwDuplexWhitePage = FUXL_UNKNOWN;
}




void fuxlCmdStartJob(PDEVOBJ pdevobj)
{
	TRACEOUT(("[fuxlCmdStartjob]\r\n"))
	WRITESPOOLBUF(pdevobj, "\x1b\x2f\xb2\x40\x7f\x1b\x7f\x00\x00\x01\x07", 11);
}


void fuxlCmdEndJob(PDEVOBJ pdevobj)
{
	TRACEOUT(("[fuxlCmdEndJob]\r\n"))
	WRITESPOOLBUF(pdevobj, "\x1d\x30\x20\x41", 4);
}



static DWORD	getFreeWidth(DWORD dwResolution, DWORD dwPaperWidth)
{
	switch(dwResolution){
	  case 300:
	  	if(dwPaperWidth < MIN_FREE_WIDTH_300)
	  		dwPaperWidth = MIN_FREE_WIDTH_300;
	  	else if(dwPaperWidth > MAX_FREE_WIDTH_300)
	  		dwPaperWidth = MAX_FREE_WIDTH_300;
		break;
	  case 600:
	  	if(dwPaperWidth < MIN_FREE_WIDTH_600)
	  		dwPaperWidth = MIN_FREE_WIDTH_600;
	  	else if(dwPaperWidth > MAX_FREE_WIDTH_600)
	  		dwPaperWidth = MAX_FREE_WIDTH_600;
	  	break;
	  default:
		TRACEOUT(("[getFreeLength]invalid resolution\r\n"))
		break;
	}
	return dwPaperWidth;
}



static DWORD	getFreeLength(DWORD dwResolution, DWORD dwPaperLength)
{
	switch(dwResolution){
	  case 300:
	  	if(dwPaperLength < MIN_FREE_LENGTH_300)
	  		dwPaperLength = MIN_FREE_LENGTH_300;
	  	else if(dwPaperLength > MAX_FREE_LENGTH_300)
	  		dwPaperLength = MAX_FREE_LENGTH_300;
		break;
	  case 600:
	  	if(dwPaperLength < MIN_FREE_LENGTH_600)
	  		dwPaperLength = MIN_FREE_LENGTH_600;
	  	else if(dwPaperLength > MAX_FREE_LENGTH_600)
	  		dwPaperLength = MAX_FREE_LENGTH_600;
	  	break;
	  default:
		TRACEOUT(("[getFreeLength]invalid resolution\r\n"))
		break;
	}
	return dwPaperLength;
}



void fuxlCmdStartDoc(PDEVOBJ pdevobj)
{
	PFUXLPDEV 		pFuxlPDEV;
	PCFUXLDATA		pReq;
	PFUXLDATA		pDev;
	PBYTE			pbCmd;
	BYTE			abCmd[256];
	BOOL			bPaperCommandNeed;
	BOOL			bDuplexChanged;
	DWORD			dwSizeReduction;
	DWORD			dwPaperWidth;
	DWORD			dwPaperLength;

	TRACEOUT(("[fuxlCmdStartDoc]\r\n"))

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pReq = &pFuxlPDEV->reqData;
	pDev = &pFuxlPDEV->devData;
	pbCmd = abCmd;

	bPaperCommandNeed = FALSE;
	bDuplexChanged = FALSE;

	if(pDev->dwResolution != pReq->dwResolution ||
		pDev->dwPaperOrientation != pReq->dwPaperOrientation){
		// #156604: Should be perform Res command when orientation
		//	    was changed.
		pDev->dwResolution = pReq->dwResolution;
		pbCmd = fuxlFormatCommand(pbCmd, "\x1d%d C", pDev->dwResolution);
	}
	if(pDev->dwSmoothing != pReq->dwSmoothing){
		pDev->dwSmoothing = pReq->dwSmoothing;
		pbCmd = fuxlFormatCommand(pbCmd, "\x1d%d D", pDev->dwSmoothing);
	}
	if(pDev->dwTonerSave != pReq->dwTonerSave){
		pDev->dwTonerSave = pReq->dwTonerSave;
		pbCmd = fuxlFormatCommand(pbCmd, "\x1d%d E", pDev->dwTonerSave);
	}

	dwSizeReduction = pReq->dwSizeReduction;
	switch(pReq->dwForm){
	  case FUXL_FORM_A5:
	  case FUXL_FORM_LETTER:
	  case FUXL_FORM_LEGAL:
	  case FUXL_FORM_JAPANESE_POSTCARD:
	  case FUXL_FORM_CUSTOM_SIZE:
	 	dwSizeReduction = 0;
	 	break;
	  case FUXL_FORM_B5:
	  	if(dwSizeReduction != 0 && dwSizeReduction != 1)
	 		dwSizeReduction = 0;
	  	break;
	}
	if(pDev->dwSizeReduction != dwSizeReduction){
		pDev->dwSizeReduction = dwSizeReduction;
		pbCmd = fuxlFormatCommand(pbCmd, "\x1d%d F", pDev->dwSizeReduction);
		bPaperCommandNeed = TRUE;
	}
 
 	if(pDev->dwForm != pReq->dwForm){
 		pDev->dwForm = pReq->dwForm;
 		bPaperCommandNeed = TRUE;
 	}
 	if(pDev->dwPaperOrientation != pReq->dwPaperOrientation){
 		pDev->dwPaperOrientation = pReq->dwPaperOrientation;
 		bPaperCommandNeed = TRUE;
 	}
 	if(pDev->dwForm != FUXL_FORM_CUSTOM_SIZE){
	 	if(pDev->dwInputBin != pReq->dwInputBin){
	 		pDev->dwInputBin = pReq->dwInputBin;
	 		bPaperCommandNeed = TRUE;
	 	}
	 	if(bPaperCommandNeed != FALSE){
	 		pbCmd = fuxlFormatCommand(pbCmd,
	 								"\x1d%d;%d;%d;%d Q",
	 								HIWORD(pDev->dwForm),
	 								LOWORD(pDev->dwForm),
	 								pDev->dwInputBin,
	 								pDev->dwPaperOrientation);
	 	}
 	}
 	else{
		if(pDev->dwPaperOrientation == 0){
	 		dwPaperWidth = getFreeWidth(pDev->dwResolution, pReq->dwPaperWidth);
 			dwPaperLength = getFreeLength(pDev->dwResolution, pReq->dwPaperLength);
 		}
 		else{
	 		dwPaperLength = getFreeWidth(pDev->dwResolution, pReq->dwPaperWidth);
 			dwPaperWidth = getFreeLength(pDev->dwResolution, pReq->dwPaperLength);
 		}
 		if(pDev->dwPaperWidth != dwPaperWidth){
 			pDev->dwPaperWidth = dwPaperWidth;
 			bPaperCommandNeed = TRUE;
 		}
 		if(pDev->dwPaperLength != dwPaperLength){
 			pDev->dwPaperLength = dwPaperLength;
 			bPaperCommandNeed = TRUE;
 		}
 		if(pDev->dwInputBin != 9){
 			pDev->dwInputBin = 9;
 			bPaperCommandNeed = TRUE;
 		}
 		if(bPaperCommandNeed != FALSE){
 			pbCmd = fuxlFormatCommand(pbCmd,
 									"\x1d%d;%d;%d;%d;%d Q",
 									HIWORD(pDev->dwForm),
 									pDev->dwPaperWidth,
 									pDev->dwPaperLength,
 									pDev->dwInputBin,
 									pDev->dwPaperOrientation);
 		}
 	}
	if(pDev->dwCopies != pReq->dwCopies){
		pDev->dwCopies = pReq->dwCopies;
		pbCmd = fuxlFormatCommand(pbCmd, "\x1d%d R", pDev->dwCopies);
	}

	if(pDev->dwDuplex != pReq->dwDuplex){
		bDuplexChanged = TRUE;
		pDev->dwDuplex = pReq->dwDuplex;
	}
	if(pDev->dwDuplex == 0){
		if(bDuplexChanged != FALSE){
			pbCmd = fuxlFormatCommand(pbCmd, "\x1d\x30 G");
		}
	}
	else{
		if(pDev->dwDuplexPosition != pReq->dwDuplexPosition){
			bDuplexChanged = TRUE;
			pDev->dwDuplexPosition = pReq->dwDuplexPosition;
		}
		if(pDev->dwDuplexFrontPageMergin != pReq->dwDuplexFrontPageMergin){
			bDuplexChanged = TRUE;
			pDev->dwDuplexFrontPageMergin = pReq->dwDuplexFrontPageMergin;
		}
		if(pDev->dwDuplexBackPageMergin != pReq->dwDuplexBackPageMergin){
			bDuplexChanged = TRUE;
			pDev->dwDuplexBackPageMergin = pReq->dwDuplexBackPageMergin;
		}
		if(pDev->dwDuplexWhitePage != pReq->dwDuplexWhitePage){
			bDuplexChanged = TRUE;
			pDev->dwDuplexWhitePage = pReq->dwDuplexWhitePage;
		}
		if(bDuplexChanged != FALSE){
			pbCmd = fuxlFormatCommand(pbCmd,
									"\x1d%u;%u;%u;%u;%u G",
									pDev->dwDuplex,
									pDev->dwDuplexPosition,
									pDev->dwDuplexFrontPageMergin,
									pDev->dwDuplexBackPageMergin,
									pDev->dwDuplexWhitePage);
			// #199308: Duplex not work
			// #198813: Duplex margins not work
			{
				DWORD	dwDuplexCmd;
				DWORD	dwFrontMargin, dwBackMargin;

				dwDuplexCmd = (pDev->dwDuplex - 1) * 2 +
					pDev->dwDuplexPosition;
				dwFrontMargin = (pDev->dwDuplexFrontPageMergin
					* pDev->dwResolution * 10) / 254;
				dwBackMargin = (pDev->dwDuplexBackPageMergin
					* pDev->dwResolution * 10) / 254;
				pbCmd = fuxlFormatCommand(pbCmd,
					"\x1BQ2;%u;%u;%u!W",
					dwDuplexCmd,
					dwFrontMargin,
					dwBackMargin);
			}
		}
	}

	if(pbCmd > abCmd)
		WRITESPOOLBUF(pdevobj, abCmd, (DWORD)(pbCmd - abCmd));
}



void fuxlCmdEndDoc(PDEVOBJ pdevobj)
{
	TRACEOUT(("[fuxlCmdEndJob]\r\n"))
}



void fuxlCmdStartPage(PDEVOBJ pdevobj)
{
	PFUXLPDEV pFuxlPDEV;

	TRACEOUT(("[fuxlCmdStartPage]\r\n"))

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pFuxlPDEV->x = 0;
	pFuxlPDEV->y = 0;
}


void fuxlCmdEndPage(PDEVOBJ pdevobj)
{
	TRACEOUT(("[fuxlCmdEndPage]\r\n"))
}



void fuxlCmdFF(PDEVOBJ pdevobj)
{
	TRACEOUT(("[fuxlCmdFF]\r\n"))
	fuxlRefreshBand(pdevobj);
}



void fuxlCmdCR(PDEVOBJ pdevobj)
{
	PFUXLPDEV pFuxlPDEV;

	TRACEOUT(("[fuxlCmdCR]\r\n"))
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pFuxlPDEV->x = 0;
}


void fuxlCmdLF(PDEVOBJ pdevobj)
{
	PFUXLPDEV pFuxlPDEV;

	TRACEOUT(("[fuxlCmdLF]\r\n"))
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pFuxlPDEV->y += pFuxlPDEV->iLinefeedSpacing;
}



void fuxlCmdSetLinefeedSpacing(PDEVOBJ pdevobj, int iLinefeedSpacing)
{
	PFUXLPDEV pFuxlPDEV;

	TRACEOUT(("[fuxlCmdSetLinefeedSpacing]%d\r\n", iLinefeedSpacing))
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pFuxlPDEV->iLinefeedSpacing = FUXL_MASTER_TO_DEVICE(pFuxlPDEV, iLinefeedSpacing);
}



INT fuxlCmdXMove(PDEVOBJ pdevobj, int x)
{
	PFUXLPDEV	pFuxlPDEV;

	TRACEOUT(("[fuxlCmdXMove] %d\r\n", x))
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pFuxlPDEV->x = FUXL_MASTER_TO_DEVICE(pFuxlPDEV, (int)x);
  	if(pFuxlPDEV->x < 0)
  		pFuxlPDEV->x = 0;
  	return pFuxlPDEV->x;
}



INT fuxlCmdYMove(PDEVOBJ pdevobj, int y)
{
	PFUXLPDEV	pFuxlPDEV;

	TRACEOUT(("[fuxlCmdYMove] %d\r\n", y))
	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	pFuxlPDEV->y = FUXL_MASTER_TO_DEVICE(pFuxlPDEV, (int)y);
  	if(pFuxlPDEV->y < 0)
  		pFuxlPDEV->y = 0;
  	return pFuxlPDEV->y;
}



void fuxlCmdSendBlock(PDEVOBJ pdevobj, DWORD dwCount, LPDWORD pdwParams, DWORD dwOutputCmd)
{
	PFUXLPDEV pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;

	TRACEOUT(("[fuxlCmdSendBlock]\r\n"))

	if(3 > dwCount){
		TRACEOUT(("Too less parameter %d\r\n", dwCount))
		return;
	}
	TRACEOUT(("cx %d cy %d\r\n", pdwParams[1] * 8, pdwParams[2]))

	pFuxlPDEV->dwOutputCmd = dwOutputCmd;
	pFuxlPDEV->cbBlockData = pdwParams[0];
	pFuxlPDEV->cBlockByteWidth = (int)pdwParams[1];
	pFuxlPDEV->cBlockHeight = (int)pdwParams[2];
}




// MINI5 Export func.
INT APIENTRY OEMCommandCallback(
	PDEVOBJ pdevobj,
	DWORD 	dwCmdCbID,
	DWORD 	dwCount,
	PDWORD 	pdwParams)
{
	PFUXLPDEV pFuxlPDEV;

	TRACEDDI(("[OEMCommandCallback]dwCmdCbID %d\r\n", dwCmdCbID))

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	if(IS_VALID_FUXLPDEV(pFuxlPDEV) == FALSE)
		return 0;

	switch(dwCmdCbID){
	  case CMDID_START_JOB:					fuxlCmdStartJob(pdevobj);		break;
	  case CMDID_END_JOB:					fuxlCmdEndJob(pdevobj);			break;

	  case CMDID_START_DOC:					fuxlCmdStartDoc(pdevobj);		break;
	  case CMDID_END_DOC:					fuxlCmdEndDoc(pdevobj);			break;

	  case CMDID_START_PAGE:				fuxlCmdStartPage(pdevobj);		break;
	  case CMDID_END_PAGE:					fuxlCmdEndPage(pdevobj);		break;
	
	  case CMDID_FF:						fuxlCmdFF(pdevobj);				break;
	  case CMDID_CR:						fuxlCmdCR(pdevobj);				break;
	  case CMDID_LF:						fuxlCmdLF(pdevobj);				break;
	  case CMDID_SET_LINE_SPACING:			fuxlCmdSetLinefeedSpacing(pdevobj, (int)pdwParams[0]);		break;
	  case CMDID_X_MOVE:					return fuxlCmdXMove(pdevobj, (int)pdwParams[0]);			// no break
	  case CMDID_Y_MOVE:					return fuxlCmdYMove(pdevobj, (int)pdwParams[0]);			// no break

	  case CMDID_SEND_BLOCK_0:				fuxlCmdSendBlock(pdevobj, dwCount, pdwParams, OUTPUT_MH | OUTPUT_RTGIMG2);	break;
	  case CMDID_SEND_BLOCK_1:				fuxlCmdSendBlock(pdevobj, dwCount, pdwParams, OUTPUT_MH2 | OUTPUT_RTGIMG4);	break;

	  case CMDID_RESOLUTION_300:			pFuxlPDEV->reqData.dwResolution = 300;						break;
	  case CMDID_RESOLUTION_600:			pFuxlPDEV->reqData.dwResolution = 600;						break;

	  case CMDID_ORIENTATION_PORTRAIT:		pFuxlPDEV->reqData.dwPaperOrientation = 0;					break;
	  case CMDID_ORIENTATION_LANDSCAPE:		pFuxlPDEV->reqData.dwPaperOrientation = 1;					break;

	  case CMDID_INPUTBIN_AUTO:				pFuxlPDEV->reqData.dwInputBin = FUXL_INPUTBIN_AUTO;			break;
	  case CMDID_INPUTBIN_MANUAL:			pFuxlPDEV->reqData.dwInputBin = FUXL_INPUTBIN_MANUAL;		break;
	  case CMDID_INPUTBIN_BIN1:				pFuxlPDEV->reqData.dwInputBin = FUXL_INPUTBIN_BIN1;			break;
	  case CMDID_INPUTBIN_BIN2:				pFuxlPDEV->reqData.dwInputBin = FUXL_INPUTBIN_BIN2;			break;
	  case CMDID_INPUTBIN_BIN3:				pFuxlPDEV->reqData.dwInputBin = FUXL_INPUTBIN_BIN3;			break;
	  case CMDID_INPUTBIN_BIN4:				pFuxlPDEV->reqData.dwInputBin = FUXL_INPUTBIN_BIN4;			break;
 
	  case CMDID_FORM_A3:					pFuxlPDEV->reqData.dwForm = FUXL_FORM_A3;					break;
	  case CMDID_FORM_A4:					pFuxlPDEV->reqData.dwForm = FUXL_FORM_A4;					break;
	  case CMDID_FORM_A5:					pFuxlPDEV->reqData.dwForm = FUXL_FORM_A5;					break;
	  case CMDID_FORM_B4:					pFuxlPDEV->reqData.dwForm = FUXL_FORM_B4;					break;
	  case CMDID_FORM_B5:					pFuxlPDEV->reqData.dwForm = FUXL_FORM_B5;					break;
	  case CMDID_FORM_LETTER:				pFuxlPDEV->reqData.dwForm = FUXL_FORM_LETTER;				break;
	  case CMDID_FORM_LEGAL:				pFuxlPDEV->reqData.dwForm = FUXL_FORM_LEGAL;				break;
	  case CMDID_FORM_JAPANESE_POSTCARD:	pFuxlPDEV->reqData.dwForm = FUXL_FORM_JAPANESE_POSTCARD;	break;
	  case CMDID_FORM_CUSTOM_SIZE:			pFuxlPDEV->reqData.dwForm = FUXL_FORM_CUSTOM_SIZE;			break;

	  case CMDID_SIZEREDUCTION_100:			pFuxlPDEV->reqData.dwSizeReduction = 0;						break;
	  case CMDID_SIZEREDUCTION_80:			pFuxlPDEV->reqData.dwSizeReduction = 1;						break;
	  case CMDID_SIZEREDUCTION_70:			pFuxlPDEV->reqData.dwSizeReduction = 2;						break;

	  case CMDID_SMOOTHING_OFF:				pFuxlPDEV->reqData.dwSmoothing = 0;							break;
	  case CMDID_SMOOTHING_ON:				pFuxlPDEV->reqData.dwSmoothing = 1;							break;

	  case CMDID_TONERSAVE_OFF:				pFuxlPDEV->reqData.dwTonerSave = 0;							break;
	  case CMDID_TONERSAVE_ON:				pFuxlPDEV->reqData.dwTonerSave = 1;							break;

	  case CMDID_DUPLEX_NONE:				pFuxlPDEV->reqData.dwDuplex = 0;							break;
	  case CMDID_DUPLEX_VERTICAL:			pFuxlPDEV->reqData.dwDuplex = 1;							break;
	  case CMDID_DUPLEX_HORIZONTAL:			pFuxlPDEV->reqData.dwDuplex = 2;							break;

	  case CMDID_DUPLEX_POSITION_LEFTTOP:		pFuxlPDEV->reqData.dwDuplexPosition = 0;				break;
	  case CMDID_DUPLEX_POSITION_RIGHTBOTTOM:	pFuxlPDEV->reqData.dwDuplexPosition = 1;				break;

	  case CMDID_DUPLEX_WHITEPAGE_OFF:		pFuxlPDEV->reqData.dwDuplexWhitePage = 0;					break;
	  case CMDID_DUPLEX_WHITEPAGE_ON:		pFuxlPDEV->reqData.dwDuplexWhitePage = 1;					break;

// @Aug/31/98 ->
    case CMDID_COPIES:
        if (MAX_COPIES_VALUE < pdwParams[0]) {
            pFuxlPDEV->reqData.dwCopies = MAX_COPIES_VALUE;
        }
        else if(1 > pdwParams[0]) {
            pFuxlPDEV->reqData.dwCopies = 1;
        }
        else {
            pFuxlPDEV->reqData.dwCopies = pdwParams[0];
        }
        break;
// @Aug/31/98 <-
	}

	if(CMDID_DUPLEX_FRONTPAGE_MERGIN_0 <= dwCmdCbID && dwCmdCbID <= CMDID_DUPLEX_FRONTPAGE_MERGIN_30){
		pFuxlPDEV->reqData.dwDuplexFrontPageMergin = dwCmdCbID - CMDID_DUPLEX_FRONTPAGE_MERGIN_0;
	}
	else if(CMDID_DUPLEX_BACKPAGE_MERGIN_0 <= dwCmdCbID && dwCmdCbID <= CMDID_DUPLEX_BACKPAGE_MERGIN_30){
		pFuxlPDEV->reqData.dwDuplexBackPageMergin = dwCmdCbID - CMDID_DUPLEX_BACKPAGE_MERGIN_0;
	}

	return 0;
}




// MINI5 Export func.
PDEVOEM APIENTRY OEMEnablePDEV(
	PDEVOBJ			pdevobj,
	PWSTR			pPrinterName,
	ULONG			cPatterns,
	HSURF*			phsurfPatterns,
	ULONG			cjGdiInfo,
	GDIINFO*		pGdiInfo,
	ULONG			cjDevInfo,
	DEVINFO*		pDevInfo,
	DRVENABLEDATA*	pded
	)
{
	PFUXLPDEV pFuxlPDEV;

	TRACEDDI(("[OEMEnablePDEV]\r\n"));

	pFuxlPDEV = (PFUXLPDEV)MemAllocZ(sizeof(FUXLPDEV));
	if(pFuxlPDEV != NULL){
		pFuxlPDEV->dwSignature = FUXL_OEM_SIGNATURE;

		pFuxlPDEV->cbBlockData = 0;
		pFuxlPDEV->cBlockByteWidth = 0;
		pFuxlPDEV->cBlockHeight = 0;
		pFuxlPDEV->iLinefeedSpacing = 0;
		pFuxlPDEV->x = 0;
		pFuxlPDEV->y = 0;

		pFuxlPDEV->cxPage = pGdiInfo->ulHorzRes;
		pFuxlPDEV->cyPage = pGdiInfo->ulVertRes;
		TRACEOUT(("szlPhysSize %d, %d\r\n", pGdiInfo->szlPhysSize.cx, pGdiInfo->szlPhysSize.cy))
		TRACEOUT(("cxPage %d cyPage %d\r\n", pFuxlPDEV->cxPage, pFuxlPDEV->cyPage))

		fuxlInitDevData(&pFuxlPDEV->devData);
		fuxlInitDevData(&pFuxlPDEV->reqData);
		fuxlInitBand(pFuxlPDEV);
	}
	TRACEOUT(("[OEMEnablePDEV]exit\r\n"))
	return pFuxlPDEV;
}


// MINI5 Export func.
VOID APIENTRY OEMDisablePDEV(PDEVOBJ pdevobj)
{
	PFUXLPDEV pFuxlPDEV;
	TRACEDDI(("[OEMDisablePDEV]\r\n"));

	pFuxlPDEV = (PFUXLPDEV)pdevobj->pdevOEM;
	if(IS_VALID_FUXLPDEV(pFuxlPDEV) == FALSE)
		return;

	fuxlDisableBand(pFuxlPDEV);
	MemFree(pdevobj->pdevOEM);
	pdevobj->pdevOEM = NULL;
}



// MINI5 Export func.
BOOL APIENTRY OEMResetPDEV(
	PDEVOBJ pdevobjOld,
	PDEVOBJ pdevobjNew
	)
{
	PFUXLPDEV pFuxlPDEVOld;
	PFUXLPDEV pFuxlPDEVNew;

	TRACEDDI(("[OemResetPDEV]\r\n"))

	pFuxlPDEVOld = (PFUXLPDEV)pdevobjOld->pdevOEM;
	if(IS_VALID_FUXLPDEV(pFuxlPDEVOld) == FALSE)
		return FALSE;

	pFuxlPDEVNew = (PFUXLPDEV)pdevobjNew->pdevOEM;
	if(IS_VALID_FUXLPDEV(pFuxlPDEVNew) == FALSE)
		return FALSE;

	pFuxlPDEVNew->devData = pFuxlPDEVOld->devData;

	return TRUE;
}



// end of fuxlres.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\fuxl.h ===
///////////////////////////////////////////////////////////////
// fuxl.h
//
// September.3,1997 H.Ishida (FPL)
//
// COPYRIGHT(C) FUJITSU LIMITED 1997

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define	FUXL_OEM_SIGNATURE	'FUXL'
#define	FUXL_OEM_VERSION	0x00010000L


typedef	const BYTE FAR*	LPCBYTE;


typedef struct tag_FUXL_OEM_EXTRADATA {
	OEM_DMEXTRAHEADER	dmExtraHdr;
} FUXL_OEM_EXTRADATA, *PFUXL_OEM_EXTRADATA;




#define WRITESPOOLBUF(p, s, n) \
	((p)->pDrvProcs->DrvWriteSpoolBuf((p), (s), (n)))

#define	IS_VALID_FUXLPDEV(p) \
	((p) != NULL && (p)->dwSignature == FUXL_OEM_SIGNATURE)

#define	FUXL_MASTER_UNIT	600
#define	FUXL_MASTER_TO_DEVICE(p,d) \
	((p)->devData.dwResolution * (d) / FUXL_MASTER_UNIT)



typedef struct tag_FUXLDATA {
	DWORD	dwResolution;
	DWORD	dwCopies;
	DWORD	dwSizeReduction;
	DWORD	dwSmoothing;
	DWORD	dwTonerSave;

	DWORD	dwForm;
	DWORD	dwPaperWidth;
	DWORD	dwPaperLength;
	DWORD	dwPaperOrientation;
	DWORD	dwInputBin;
	
	DWORD	dwDuplex;
	DWORD	dwDuplexPosition;
	DWORD	dwDuplexFrontPageMergin;
	DWORD	dwDuplexBackPageMergin;
	DWORD	dwDuplexWhitePage;
} FUXLDATA;

typedef struct tag_FUXLDATA*			PFUXLDATA;
typedef	const struct tag_FUXLDATA*		PCFUXLDATA;


// FUXLDATA.dwForm
#define	FUXL_FORM_A3					0x00000003
#define	FUXL_FORM_A4					0x00000004
#define	FUXL_FORM_A5					0x00000005
#define	FUXL_FORM_B4					0x00010004
#define	FUXL_FORM_B5					0x00010005
#define	FUXL_FORM_LEGAL					0x00020000
#define	FUXL_FORM_LETTER				0x00030000
#define	FUXL_FORM_JAPANESE_POSTCARD		0x00040000
#define	FUXL_FORM_CUSTOM_SIZE			0x00090000

// FUXLDATA.dwInputBin
#define	FUXL_INPUTBIN_AUTO				0
#define	FUXL_INPUTBIN_BIN1				1
#define	FUXL_INPUTBIN_BIN2				2
#define	FUXL_INPUTBIN_BIN3				3
#define	FUXL_INPUTBIN_BIN4				4
#define	FUXL_INPUTBIN_MANUAL			9


typedef struct tag_FUXLPDEV {
	DWORD	dwSignature;

	FUXLDATA	reqData;
	FUXLDATA	devData;

	int			iLinefeedSpacing;	// linefeed spacing[device corrdinate]
	int			x;					// cursor position[device coordinate]
	int			y;

	DWORD		cxPage;				// printable area[dot]
	DWORD		cyPage;

	DWORD		cbBlockData;		// send block data
	DWORD		cBlockByteWidth;
	DWORD		cBlockHeight;

	LPBYTE		pbBand;				// Band memory
	DWORD		cbBand;
	int			yBandTop;			// Top coordinate of Band memory.
	int			cBandByteWidth;		// Byte width of Band memory
	int			cyBandSegment;		// Split Graphics data within 64K
	BOOL		bBandDirty;			// TRUE: Band memory is Dirty(Not all white).
	BOOL		bBandError;			// TRUE: I can't alloc memory for lpbBand
	DWORD		dwOutputCmd;		// Output data format. One of OUTPUT_xxxx macro.

} FUXLPDEV, *PFUXLPDEV;


// @Aug/31/98 ->
#define	MAX_COPIES_VALUE    999
// @Aug/31/98 <-

// end of fuxl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sources.

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\fuj\$(ALT_PROJECT)
UNIDIR=$(PRNROOT)\unidrv2
SRCDIR=..

TARGETNAME=fuxlres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),fuxlres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc;$(UNIDIR)\inc

RCCODEPAGE=932

UMTYPE=windows

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=\
    $(SRCDIR)\fuxlres.rc \
    $(SRCDIR)\fuxlres.c \
    $(SRCDIR)\fuxldm.c \
    $(SRCDIR)\fudebug.c \
    $(SRCDIR)\fuband.c \
    $(SRCDIR)\fumh2.c \
    $(SRCDIR)\fumh.c \
    $(SRCDIR)\fuimg4.c \
    $(SRCDIR)\fuimg2.c

MISCFILES=\
    $(SRCDIR)\fuxlres.ini \
    $(GPDDIR)\fugl340j.gpd \
    $(GPDDIR)\fugl34ej.gpd \
    $(GPDDIR)\fugl360j.gpd \
    $(GPDDIR)\fugl36ej.gpd \
    $(GPDDIR)\fugl740j.gpd \
    $(GPDDIR)\fugl74ej.gpd \
    $(GPDDIR)\fugl760j.gpd \
    $(GPDDIR)\fugl76ej.gpd \
    $(GPDDIR)\fuxl25j.gpd \
    $(GPDDIR)\fuxl50j.gpd \
    $(GPDDIR)\fuxl50mj.gpd \
    $(GPDDIR)\fuxl51j.gpd \
    $(GPDDIR)\fuxl52j.gpd \
    $(GPDDIR)\fuxl53j.gpd \
    $(GPDDIR)\fuxl532j.gpd \
    $(GPDDIR)\fuxl551j.gpd \
    $(GPDDIR)\fuxl56j.gpd \
    $(GPDDIR)\fuxl56mj.gpd \
    $(GPDDIR)\fuxl57j.gpd \
    $(GPDDIR)\fuxl572j.gpd \
    $(GPDDIR)\fuxl58j.gpd \
    $(GPDDIR)\fuxl581j.gpd \
    $(GPDDIR)\fuxl60j.gpd \
    $(GPDDIR)\fuxl601j.gpd \
    $(GPDDIR)\fuxl60mj.gpd \
    $(GPDDIR)\fuxl610j.gpd \
    $(GPDDIR)\fuxl65j.gpd \
    $(GPDDIR)\fuxl65mj.gpd \
    $(GPDDIR)\fuxl66j.gpd

# end of SOURCES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\nt4\dllentry.cpp ===
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//		DllInitialize
//
//  PLATFORMS:	Windows NT
//
//

#include "pdev.h"

// Need to export these functions as c declarations.
extern "C" {

///////////////////////////////////////////////////////////
//
// DLL entry point
//

#ifndef WINNT_40

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#else // WINNT_40

// DllInitialize isn't called/used for user mode version.
BOOL WINAPI DllInitialize(ULONG ulReason)
{
	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(("Process attach.\r\n"));

            // In kernel mode version, initializes semaphore.
            DrvCreateInterlock();
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(("Process detach.\r\n"));

            // In kernel mode version, deletes semaphore.
            DrvDeleteInterlock();
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}

#endif // WINNT_40

}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\nt4\pdev.h ===
#include "fuxl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fuxlres\nt4\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "fuxl.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    // DbgPrint(DLLTEXT("IOemCB: QueryInterface entry\n"));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ; 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        // DbgPrint(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ; 
    }
    else
    {
        *ppv = NULL ;
        // DbgPrint(DLLTEXT("IOemCB:Return NULL.\n")) ; 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    // DbgPrint(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCB::Release() 
{
    // DbgPrint(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    // DbgPrint(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    // DbgPrint(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    // DbgPrint(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    // DbgPrint(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    // DbgPrint(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    OEMDisablePDEV(pdevobj);
    return S_OK;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::GetInfo() entry.\r\n"));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    // DbgPrint(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    // DbgPrint(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'D':
#if 0
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;
#endif
                else if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
#if 0
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'E':
#if 0
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
#endif
                if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
#if 0
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'I':
#if 0
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'M':
#if 0
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'O':
#if 0
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
#if 0
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
#endif
                break;

            case (WCHAR)'T':
#if 0
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
#endif
                break;
        }
    }

    if (lReturn)
    {
        // DbgPrint(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        // DbgPrint(__TEXT("NOT supported\r\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    // DbgPrint(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    // DbgPrint(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    // if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
    //                     dwCallbackID, pIPParams))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    // DbgPrint(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));
    // pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuf, dwLen, &dwResult);
    
    if (OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    // DbgPrint(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    // DbgPrint(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    // DbgPrint(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));
    //*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));
    //*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    // DbgPrint(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));
    //*pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);

    return E_NOTIMPL;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    // DbgPrint(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));
    // OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    // return S_OK;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    // DbgPrint(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    // OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    // return S_OK;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    // DbgPrint(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    // DbgPrint(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //// DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //// DbgPrint(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID) ;
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID) ;
}
#endif

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxartres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

#if 0
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    // if (OEMResetPDEV(pdevobjOld, pdevobjNew))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

#if 0
    OEMDisablePDEV(pdevobj);
    return S_OK;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));
    VERBOSE((DLLTEXT("        Function:%s:"),pMethodName));

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;

                if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'I':
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'M':
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        VERBOSE(("Supported\n"));
        return S_OK;
    }
    else
    {
        VERBOSE(("NOT supported\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    // if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
    //                     dwCallbackID, pIPParams))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if(OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

#if 0
    *pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);
    if(*pdwResult)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

#if 0
    *pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);
    if(*pdwResult)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));

#if 0
    *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
    if(*pdwResult <= TTDOWNLOAD_TTOUTLINE)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    return S_OK;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    return S_OK;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //VERBOSE((DLLTEXT("Class factory:\t\tCreate component.")));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}
#endif

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxartres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxartres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

#if 0
static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
#else // 0
extern BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
extern BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
#endif // 0
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEM_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            VERBOSE(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


#if 0
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
#if 0
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));
#endif

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
#if 0
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }
#endif

    return TRUE;
}
#endif // 0


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxartres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxartres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'FXAT'      // LG GDI x00 series dll
#define DLLTEXT(s)      "FXAT: " s
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////
#define STRBUFSIZE  1024
typedef struct tag_OEM_EXTRADATA {
    OEM_DMEXTRAHEADER   dmExtraHdr;
    // Private extention
    POINTL  ptlOrg;
    POINTL  ptlCur;
    SIZEL   sizlRes;
    WORD    iCopies;
    CHAR    *chOrient;
    CHAR    *chSize;
    BOOL    bString;
    WORD    cFontId;
    WORD    iFontId;
    WORD    iFontHeight;
    WORD    iFontWidth;
    WORD    iFontWidth2;
    LONG    aFontId[20];
    POINTL ptlTextCur;
    WORD    iTextFontId;
    WORD    iTextFontHeight;
    WORD    iTextFontWidth;
    WORD    iTextFontWidth2;
    WORD    cTextBuf;
    BYTE    ajTextBuf[STRBUFSIZE];
    WORD    fFontSim;
    BOOL    fSort;
    BOOL    fCallback;  //Is OEMFilterGraphics called?
    BOOL    fPositionReset;
    WORD    iCurFontId; // id of font currently selected
// #365649: Invalid font size
    WORD    iCurFontHeight;
    WORD    iCurFontWidth;
// For internal calculation of X-pos.
    LONG widBuf[STRBUFSIZE];
    LONG    lInternalXAdd;
    WORD    wSBCSFontWidth;
// For TIFF compression in fxartres
    DWORD   dwTiffCompressBufSize;
    PBYTE   pTiffCompressBuf;
// ntbug9#208433: Output images are broken on ART2/3 models.
    BOOL    bART3;	// ART2/3 models can't support the TIFF compression.
} OEM_EXTRADATA, *POEM_EXTRADATA;

// For TIFF compression in fxartres
#define TIFFCOMPRESSBUFSIZE 2048        // It may be resize if needed more buffer dynamically.
#define TIFF_MIN_RUN        4           // Minimum repeats before use RLE
#define TIFF_MAX_RUN        128         // Maximum repeats
#define TIFF_MAX_LITERAL    128         // Maximum consecutive literal data
#define NEEDSIZE4TIFF(s)    ((s)+(((s)+127) >> 7))          // Buffer for TIFF compression requires a byte 
                                                            // per 128 bytes in the worst case.

// Device font height and font width values calculated
// form the IFIMETRICS field values.  Must be the same way
// what Unidrv is doing to calculate stdandard variables.
// (Please check.)

#define FH_IFI(p) ((p)->fwdUnitsPerEm)
#define FW_IFI(p) ((p)->fwdAveCharWidth)

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxartres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\fx\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=fxartres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),fxartres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\fxartres.rc \
    $(SRCDIR)\common.c \
    $(SRCDIR)\fxartres.c

MISCFILES=\
    $(SRCDIR)\fxartres.ini \
    $(GPDDIR)\fx4105j.gpd \
    $(GPDDIR)\fx41082j.gpd \
    $(GPDDIR)\fx4108j.gpd \
    $(GPDDIR)\fx4108vj.gpd \
    $(GPDDIR)\fx41502j.gpd \
    $(GPDDIR)\fx4150j.gpd \
    $(GPDDIR)\fx41602j.gpd \
    $(GPDDIR)\fx4160j.gpd \
    $(GPDDIR)\fx4200j.gpd \
    $(GPDDIR)\fx4300j.gpd \
    $(GPDDIR)\fxablp2j.gpd \
    $(GPDDIR)\fxablprj.gpd \
    $(GPDDIR)\fx4210j.gpd \
    $(GPDDIR)\fx4410j.gpd \
    $(GPDDIR)\fxdc250j.gpd \
    $(GPDDIR)\fxdc450j.gpd \
    $(GPDDIR)\fxdc600j.gpd \
    $(GPDDIR)\fxdc605j.gpd \
    $(GPDDIR)\fxdp250j.gpd \
    $(GPDDIR)\fxdp280j.gpd \
    $(GPDDIR)\fxdp400j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxartres\fxartres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//#define FX_VERBOSE WARNING
#define FX_VERBOSE VERBOSE

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    // Initialize private data
    pOEMExtra->ptlOrg.x = 0;
    pOEMExtra->ptlOrg.y = 0;
    pOEMExtra->sizlRes.cx = 0;
    pOEMExtra->sizlRes.cy = 0;
    pOEMExtra->iCopies = 0;
    pOEMExtra->bString = FALSE;
    pOEMExtra->cFontId = 0;
    pOEMExtra->iFontId = 0;
    pOEMExtra->iFontHeight = 0;
    pOEMExtra->iFontWidth = 0;
    pOEMExtra->iFontWidth2 = 0;
    pOEMExtra->ptlTextCur.x = 0;
    pOEMExtra->ptlTextCur.y = 0;
    pOEMExtra->iTextFontId = 0;
    pOEMExtra->iTextFontHeight = 0;
    pOEMExtra->iTextFontWidth = 0;
    pOEMExtra->iTextFontWidth2 = 0;
    pOEMExtra->cTextBuf = 0;
    pOEMExtra->fFontSim = 0;
    pOEMExtra->fCallback = FALSE;
    pOEMExtra->fPositionReset = TRUE;
    pOEMExtra->fSort = FALSE;

    pOEMExtra->iCurFontId = 0;
// #365649: Invalid font size
    pOEMExtra->iCurFontHeight = 0;
    pOEMExtra->iCurFontWidth = 0;

    // For internal calculation of X-pos.
    pOEMExtra->lInternalXAdd = 0;

    // For TIFF compression in fxartres
    if( !(pOEMExtra->pTiffCompressBuf =(PBYTE)MemAllocZ(TIFFCOMPRESSBUFSIZE)) )
    {
        ERR(("MemAlloc failed.\n"));
        return FALSE;
    }
    pOEMExtra->dwTiffCompressBufSize = TIFFCOMPRESSBUFSIZE;

    // Intialize another private buffers
    ZeroMemory(pOEMExtra->widBuf, sizeof(LONG) * STRBUFSIZE);
    ZeroMemory(pOEMExtra->ajTextBuf, STRBUFSIZE);
    ZeroMemory(pOEMExtra->aFontId, sizeof(LONG) * 20);

// ntbug9#208433: Output images are broken on ART2/3 models.
    pOEMExtra->bART3 = FALSE;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //

        // Copy private data
        pdmOut->ptlOrg.x = pdmIn->ptlOrg.x;
        pdmOut->ptlOrg.y = pdmIn->ptlOrg.y;
        pdmOut->sizlRes.cx = pdmIn->sizlRes.cx;
        pdmOut->sizlRes.cy = pdmIn->sizlRes.cy;
        pdmOut->iCopies = pdmIn->iCopies;
        pdmOut->bString = pdmIn->bString;
        pdmOut->cFontId = pdmIn->cFontId;
        pdmOut->iFontId = pdmIn->iFontId;
        pdmOut->iFontHeight = pdmIn->iFontHeight;
        pdmOut->iFontWidth = pdmIn->iFontWidth;
        pdmOut->iFontWidth2 = pdmIn->iFontWidth2;
        pdmOut->ptlTextCur.x = pdmIn->ptlTextCur.x;
        pdmOut->ptlTextCur.y = pdmIn->ptlTextCur.y;
        pdmOut->iTextFontId = pdmIn->iTextFontId;
        pdmOut->iTextFontHeight = pdmIn->iTextFontHeight;
        pdmOut->iTextFontWidth = pdmIn->iTextFontWidth;
        pdmOut->iTextFontWidth2 = pdmIn->iTextFontWidth2;
        pdmOut->cTextBuf = pdmIn->cTextBuf;
        pdmOut->fFontSim = pdmIn->fFontSim;
        pdmOut->fCallback = pdmIn->fCallback;
        pdmOut->fPositionReset = pdmIn->fPositionReset;
        pdmOut->fSort = pdmIn->fSort;
        pdmOut->iCurFontId = pdmIn->iCurFontId;
// #365649: Invalid font size
        pdmOut->iCurFontHeight = pdmIn->iCurFontHeight;
        pdmOut->iCurFontWidth = pdmIn->iCurFontWidth;

        // For internal calculation of X-pos.
        pdmOut->lInternalXAdd = pdmIn->lInternalXAdd;
        memcpy((PBYTE)pdmOut->widBuf, (PBYTE)pdmIn->widBuf, sizeof(LONG) * STRBUFSIZE );

        // For TIFF compression in fxartres
        pdmOut->dwTiffCompressBufSize = pdmIn->dwTiffCompressBufSize;
        pdmOut->pTiffCompressBuf = pdmIn->pTiffCompressBuf;     // This buffer is used only in OEMFilterGraphics.
                                                                // So no need to copy contents of the buffer.

        // Copy private buffer
        pdmOut->chOrient = pdmIn->chOrient;
        pdmOut->chSize = pdmIn->chSize;
        memcpy((PBYTE)pdmOut->aFontId,(PBYTE)pdmIn->aFontId,sizeof(LONG) * 20);
        memcpy((PBYTE)pdmOut->ajTextBuf, (PBYTE)pdmIn->ajTextBuf, STRBUFSIZE);
    }
    return TRUE;
}

// #######

#include <stdio.h>
#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

#define DEVICE_MASTER_UNIT 7200
#define DRIVER_MASTER_UNIT 1200

// @Aug/31/98 ->
#define MAX_COPIES_VALUE 99
// @Aug/31/98 <-

#define MAX_COPIES_VALUE_450 999

#define FONT_SIM_ITALIC 1
#define FONT_SIM_BOLD 2
#define FONT_SIM_WHITE 4

// to get physical paper sizes.

typedef struct tagMYFORMS {
    CHAR *id;
    LONG x;
    LONG y;
} MYFORMS, *LPMYFORMS;

// font name to font id mappnig

typedef struct tagMYFONTS {
    LONG id;
    BYTE *fid1;
    BYTE *fid2;
} MYFONTS, *LPMYFONTS;

//
// Load necessary information for specified paper size.
// Make sure PC_OCD_LANDSCAPE and PC_OCD_PORTRAIT are
// called.
//

MYFORMS gForms[] = {
    "a3", 13608, 19422,
    "a4", 9498, 13608,
    "a5", 6570, 9498,
    "a6", 4515, 6570,
    "b4", 11718, 16776,
    "b5", 8178, 11718,
    "b6", 5648, 8178,
    "pc", 4302, 6570, // Postcard
    "o0", 12780, 19980, // Tabloid
    "o1", 9780, 12780, // Letter
    "o2", 9780, 15180, // German Legal Fanfold
    "o3", 9780, 16380, // Legal
    "s1", 4530, 10962, // (Env) Comm 10
    "s2", 4224, 8580, // (Env) Monarch
    "s3", 4776, 9972, // (Env) DL
    "s4", 7230, 10398, // (Env) C5
    "hl", 6390, 9780, // Statement
    NULL, 0, 0
};

MYFONTS gFonts[] = {

    150, "fid 150 1 0 0 960 480\n", "fid 151 2 4 0 960 960\n", // Mincho
    156, "fid 156 1 0 0 960 480\n", "fid 157 2 5 0 960 960\n", // @Mincho

    152, "fid 152 1 0 1 960 480\n", "fid 153 2 4 1 960 960\n", // Gothic
    158, "fid 158 1 0 1 960 480\n", "fid 159 2 5 1 960 960\n", // @Gothic

    154, "fid 154 1 0 8 960 480\n", "fid 155 2 4 2 960 960\n", // Maru-Gothic
    160, "fid 160 1 0 8 960 480\n", "fid 161 2 5 2 960 960\n", // @Maru-Gothic

    162, "fid 162 1 130 108 0 0\n", "fid 163 1 128 108 0 0\n", // CS Courier
    164, "fid 164 1 130 109 0 0\n", "fid 165 1 128 109 0 0\n", // CS Courier Italic
    166, "fid 166 1 130 110 0 0\n", "fid 167 1 128 110 0 0\n", // CS Courier Bold
    168, "fid 168 1 130 111 0 0\n", "fid 169 1 128 111 0 0\n", // CS Courier Bold Italic

    172, "fid 172 1 130 100 0 0\n", "fid 173 1 128 100 0 0\n", // CS Times
    174, "fid 174 1 130 102 0 0\n", "fid 175 1 128 102 0 0\n", // CS Times Bold
    176, "fid 176 1 130 101 0 0\n", "fid 177 1 128 101 0 0\n", // CS Times Italic
    178, "fid 178 1 130 103 0 0\n", "fid 179 1 128 103 0 0\n", // CS Times Bold Italic
    180, "fid 180 1 130 104 0 0\n", "fid 181 1 128 104 0 0\n", // CS Triumvirate
    182, "fid 182 1 130 106 0 0\n", "fid 183 1 128 106 0 0\n", // CS Triumvirate Bold
    184, "fid 184 1 130 105 0 0\n", "fid 185 1 128 105 0 0\n", // CS Triumvirate Italic
    186, "fid 186 1 130 107 0 0\n", "fid 187 1 128 107 0 0\n", // CS Triumvirate Bold Italic

    188, "fid 188 1 129 112 0 0\n", NULL, // CS Symbols
    189, "fid 189 1 2 6 0 0\n", NULL, // Enhanced Classic
    190, "fid 190 1 2 7 0 0\n", NULL, // Enhanced Modern

    // Assume there is no device which has both Typebank and Heisei
    // typefaces, we re-use FID #s here.

    150, "fid 150 1 0 0 960 480\n", "fid 151 2 4 0 960 960\n", // (Heisei) Mincho
    156, "fid 156 1 0 0 960 480\n", "fid 157 2 5 0 960 960\n", // (Heisei) @Mincho

    152, "fid 152 1 0 1 960 480\n", "fid 153 2 4 1 960 960\n", // (Heisei) Gothic
    158, "fid 158 1 0 1 960 480\n", "fid 159 2 5 1 960 960\n", // (Heisei) @Gothic

    0, NULL, NULL
};

#define ISDBCSFONT(i) ((i) < 162)
#define ISVERTFONT(i) ((i) >= 156 && (i) < 162)
#define ISPROPFONT(i) ((i) >= 172 && (i) < 190)

#define MARK_ALT_GSET 0x01
#define BISMARKSBCS(i) ((i) >= 0 && (i) < 0x20)

BOOL
LoadPaperInfo(
    POEM_EXTRADATA pOEM,
    CHAR *id ) {

    LPMYFORMS ptmp;

    for ( ptmp = gForms; ptmp->id; ptmp++ ) {
        if ( strcmp( id, ptmp->id) == 0 )
            break;
    }

    if ( ptmp->id == NULL )
        return FALSE;

    FX_VERBOSE(("PI: %s->%s\n", id, ptmp->id ));

    pOEM->chSize = ptmp->id;

    pOEM->ptlOrg.x = 0;
    if ( strcmp( pOEM->chOrient, "l") == 0 ){
        pOEM->ptlOrg.y = ptmp->x;
    }
    else {
        pOEM->ptlOrg.y = ptmp->y;
    }

    pOEM->ptlOrg.x += 210;
    pOEM->ptlOrg.y += 210;

    return TRUE;
}


#define TOHEX(j) ((j) < 10 ? ((j) + '0') : ((j) - 10 + 'a'))

BOOL
HexOutput(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    BYTE Buf[STRBUFSIZE];
    BYTE *pSrc, *pSrcMax;
    LONG iRet, j;

    pSrc = (BYTE *)pBuf;
    pSrcMax = pSrc + dwLen;
    iRet = 0;

    while ( pSrc < pSrcMax ) {

        for ( j = 0; j < sizeof (Buf) && pSrc < pSrcMax; pSrc++ ) {

            BYTE c1, c2;

            c1 = (((*pSrc) >> 4) & 0x0f);
            c2 = (*pSrc & 0x0f);

            Buf[ j++ ] = TOHEX( c1 );
            Buf[ j++ ] = TOHEX( c2 );
        }

        if (WRITESPOOLBUF( pdevobj, Buf, j ) == 0)
            break;

        iRet += j;
    }
    return TRUE;
}


VOID
BeginString(
    PDEVOBJ pdevobj,
    BOOL bReset )
{
    LONG ilen;
    BYTE buf[512];
    POEM_EXTRADATA pOEM;
    BYTE *pbuf;

    pOEM = pdevobj->pOEMDM;

    if (pOEM->bString)
        return;

    pbuf = buf;
    if ( bReset ) {

        FX_VERBOSE(("BS: %d(%d),%d(%d)\n",
            ( pOEM->ptlOrg.x + pOEM->ptlTextCur.x ),
            pOEM->ptlTextCur.x,
            ( pOEM->ptlOrg.y - pOEM->ptlTextCur.y ),
            pOEM->ptlTextCur.y));

        ilen = wsprintf( pbuf,
            "scp %d %d\n",
            ( pOEM->ptlOrg.x + pOEM->ptlTextCur.x ),
            ( pOEM->ptlOrg.y - pOEM->ptlTextCur.y ));
        pbuf += ilen;
    }

    ilen = wsprintf( pbuf,
        "sh <" );
    pbuf += ilen;

    if ( (pbuf - buf) > 0 ) {
        WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
    }
    pOEM->bString = TRUE;

}

VOID
EndString(
    PDEVOBJ pdevobj )
{
    LONG ilen;
    BYTE buf[512];
    POEM_EXTRADATA pOEM;

    pOEM = pdevobj->pOEMDM;

    if (!pOEM->bString)
        return;

    ilen = wsprintf( buf,
        ">\n" );

    if ( ilen > 0 ) {
        WRITESPOOLBUF( pdevobj, buf, ilen );
    }
    pOEM->bString = FALSE;
}

VOID
BeginVertWrite(
    PDEVOBJ pdevobj )
{
    BYTE buf[512];
    POEM_EXTRADATA pOEM;
    INT ilen;
    BYTE *pbuf;

    pOEM = pdevobj->pOEMDM;
    pbuf = buf;

    ilen = wsprintf( pbuf,
        "fo 90\nsrcp %d 0\n", pOEM->iFontHeight );
    pbuf += ilen;
    if (pOEM->fFontSim & FONT_SIM_ITALIC) {
        ilen = wsprintf( pbuf,
            "trf -18 y\n" );
        pbuf += ilen;
    }

    pOEM->ptlTextCur.x += pOEM->iFontHeight;

    if ( pbuf > buf ) {
        WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
    }
}

VOID
EndVertWrite(
    PDEVOBJ pdevobj )
{
    BYTE buf[512];
    POEM_EXTRADATA pOEM;
    INT ilen;
    BYTE *pbuf;

    pOEM = pdevobj->pOEMDM;
    pbuf = buf;

    ilen = wsprintf( pbuf,
        "fo 0\nsrcp %d 0\n", -(pOEM->iFontHeight) );
    pbuf += ilen;
    if (pOEM->fFontSim & FONT_SIM_ITALIC) {
        ilen = wsprintf( pbuf,
            "trf x -18\n" );
        pbuf += ilen;
    }

    if ( pbuf > buf ) {
        WRITESPOOLBUF( pdevobj, buf, (DWORD)(pbuf - buf) );
    }
}

//
// Save the current poistion as the begining position of text output.
// We will cache string output so that we need to remember this.
//

VOID
SaveTextCur(
    PDEVOBJ pdevobj )
{
    POEM_EXTRADATA pOEM;

    pOEM = pdevobj->pOEMDM;

    pOEM->ptlTextCur.x = pOEM->ptlCur.x;
    pOEM->ptlTextCur.y = pOEM->ptlCur.y;
    pOEM->iTextFontId = pOEM->iFontId;
    pOEM->iTextFontHeight = pOEM->iFontHeight;
    pOEM->iTextFontWidth = pOEM->iFontWidth;
    pOEM->iTextFontWidth2 = pOEM->iFontWidth2;

    pOEM->fPositionReset = TRUE;
}

//
// Flush out the cached text.  We switch between single byte font and
// double byte font if necesary.
//

VOID
FlushText(
    PDEVOBJ pdevobj )
{
    INT i;
    INT ilen;
    BYTE *pStr, *pStrSav, *pStrMax, *pStrSav2;
    BYTE buf[512];
    BOOL bReset;
    POEM_EXTRADATA  pOEM;
    INT iMark;
    BOOL bSkipEndString = FALSE;

    pOEM = pdevobj->pOEMDM;
    bReset = pOEM->fPositionReset;

    pStr = pOEM->ajTextBuf;
    pStrMax = pStr + pOEM->cTextBuf;
    pStrSav = pStr;

    if(!pOEM->cTextBuf)
        return;

    while(pStr < pStrMax)
    {
        if(ISDBCSFONT(pOEM->iTextFontId))
        {
            // DBCS font case
            for(pStrSav = pStr; pStr < pStrMax; pStr += 2)
            {
                // Search for next SBCS character
                if ( BISMARKSBCS(*pStr) )
                    break;
            }

            if(pStrSav < pStr)
            {
                FX_VERBOSE(("FT: h,w=%d,%d\n",
                    pOEM->iFontHeight, pOEM->iFontWidth));

                // Send DBCS font select command
// #365649: Invalid font size
                if (pOEM->iCurFontId != (pOEM->iTextFontId + 1) ||
                    pOEM->iCurFontHeight != pOEM->iTextFontHeight ||
                    pOEM->iCurFontWidth != pOEM->iTextFontWidth)
                {
                    ilen = wsprintf( buf, "sfi %d\nfs %d %d\n",
                        (pOEM->iTextFontId + 1),
                        pOEM->iFontHeight, pOEM->iFontWidth2 );
                    WRITESPOOLBUF( pdevobj, buf, ilen );
                    pOEM->iCurFontId = (pOEM->iTextFontId + 1);
                    pOEM->iCurFontHeight = pOEM->iTextFontHeight;
                    pOEM->iCurFontWidth = pOEM->iTextFontWidth;
                }

                // If vertical font, send its command
                if( ISVERTFONT(pOEM->iTextFontId) ) {
                    BeginVertWrite(pdevobj);

                    // Output string: code from BeginString func.
                    if ( bReset ) {
                        ilen = wsprintf( buf, "scp %d %d\n",
                                       ( pOEM->ptlOrg.x + pOEM->ptlTextCur.x ),
                                       ( pOEM->ptlOrg.y - pOEM->ptlTextCur.y ));
                        WRITESPOOLBUF( pdevobj, buf, ilen );
                    }
                    if( 0 == memcmp( pStrSav, "\x21\x25", 2)) {  // 0x2125 = dot character
                        // start with dot character
                        WRITESPOOLBUF( pdevobj, "gs 3\n", 5 );

                        // grset command resets font size, so we have to resend it.
                        ilen = wsprintf( buf, "fs %d %d\n", pOEM->iFontHeight, pOEM->iFontWidth2 );
                        WRITESPOOLBUF( pdevobj, buf, ilen );
                    }
                    WRITESPOOLBUF( pdevobj, "sh <", 4 );
                    pOEM->bString = TRUE;      // no need BeginString

                    for( pStrSav2 = pStrSav ; pStrSav2 < pStr ; pStrSav2 += 2 ) {
                        if( 0 == memcmp( pStrSav2, "\x21\x25", 2)) {  // 0x2125 = dot character
                            // special dot printing mode
                            if( pStrSav2 != pStrSav ) {
                                // change glyph set
                                // If pStrSav2 == pStrSav, gs 3 command has already sent.
                                WRITESPOOLBUF( pdevobj, ">\ngs 3\n", 7 );

                                // grset command resets font size, so we have to resend it.
                                ilen = wsprintf( buf, "fs %d %d\n", pOEM->iFontHeight, pOEM->iFontWidth2 );
                                WRITESPOOLBUF( pdevobj, buf, ilen );

                                WRITESPOOLBUF( pdevobj, "sh <", 4 );
                                pOEM->bString = TRUE;      // no need BeginString
                            }

                            while( 0 == memcmp( pStrSav2, "\x21\x25", 2) ) {
                                // output a dot character directly
                                WRITESPOOLBUF( pdevobj, "2125", 4 );
                                pStrSav2 += 2;
                            }

                            WRITESPOOLBUF( pdevobj, ">\ngs 5\n", 7 );
                            // Next character exist?
                            if( pStrSav2 < pStr ) {
                                // remain string exists

                                // grset command resets font size, so we have to resend it.
                                ilen = wsprintf( buf, "fs %d %d\nsh <", pOEM->iFontHeight, pOEM->iFontWidth2 );
                                WRITESPOOLBUF( pdevobj, buf, ilen );
                                pOEM->bString = TRUE;      // no need BeginString
                                bSkipEndString = FALSE;
                            } else { 
                                // no remain string
                                // grset command resets font size, so we have to resend it.
                                ilen = wsprintf( buf, "fs %d %d\n", pOEM->iFontHeight, pOEM->iFontWidth2 );
                                WRITESPOOLBUF( pdevobj, buf, ilen );
                                pOEM->bString = FALSE;      // need BeginString
                                bSkipEndString = TRUE;
                            }
                        } else {
                            HexOutput(pdevobj, pStrSav2, (WORD)2);
                            bSkipEndString = FALSE;
                        }
                    }

                    if( bSkipEndString == FALSE ) {
                        EndString(pdevobj);
                    }

                    // send revert command
                    EndVertWrite(pdevobj);
                } else { 
                    // Horizontal font or no need to change glyph set

                    // Output string
                    BeginString(pdevobj, bReset);
                    HexOutput(pdevobj, pStrSav, (WORD)(pStr - pStrSav));
                    EndString(pdevobj);
                }
                bReset = FALSE;
            }

            for(pStrSav = pStr; pStr < pStrMax; pStr += 2)
            {
                // Search for DBCS character
                if (!BISMARKSBCS(*pStr))
                    break;
            }

            if(pStrSav < pStr)
            {
                // Send DBCS font select command
// #365649: Invalid font size
                if (pOEM->iCurFontId != pOEM->iTextFontId ||
                    pOEM->iCurFontHeight != pOEM->iTextFontHeight ||
                    pOEM->iCurFontWidth != pOEM->iTextFontWidth)
                {
                    ilen = wsprintf( buf, "sfi %d\nfs %d %d\n",
                        pOEM->iTextFontId,
                        pOEM->iFontHeight, pOEM->iFontWidth );
                    WRITESPOOLBUF( pdevobj, buf, ilen );
                    pOEM->iCurFontId = pOEM->iTextFontId;
                    pOEM->iCurFontHeight = pOEM->iTextFontHeight;
                    pOEM->iCurFontWidth = pOEM->iTextFontWidth;
                }

                // String output
                BeginString(pdevobj, bReset);
                for( ; pStrSav < pStr; pStrSav++)
                {
                    if (BISMARKSBCS(*pStrSav))
                        pStrSav++;
                    HexOutput(pdevobj, pStrSav, (WORD)1);
                }
                EndString(pdevobj);
                bReset = FALSE;
            }
        } else {

            // SBCS font case
            // Send Select Font command

            iMark = *pStr;

// #365649: Invalid font size
            if (pOEM->iCurFontId != (pOEM->iTextFontId + iMark) ||
                    pOEM->iCurFontHeight != pOEM->iTextFontHeight ||
                    pOEM->iCurFontWidth != pOEM->iTextFontWidth)
            {
                ilen = wsprintf( buf, "sfi %d\nfs %d %d\n",
                    (pOEM->iTextFontId + iMark),
                    pOEM->iFontHeight, pOEM->iFontWidth );
                WRITESPOOLBUF( pdevobj, buf, ilen );
                pOEM->iCurFontId = (pOEM->iTextFontId + iMark);
                pOEM->iCurFontHeight = pOEM->iTextFontHeight;
                pOEM->iCurFontWidth = pOEM->iTextFontWidth;
            }

            // String Output
            BeginString(pdevobj, bReset);
            for(i = 0; i < pOEM->cTextBuf; pStr++)
            {
                if (*pStr != iMark)
                    break;

                // Skip marker character
                pStr++;

                HexOutput(pdevobj, pStr, (WORD)1 );
                i += 2;
            }
            EndString(pdevobj);
            bReset = FALSE;
            pOEM->cTextBuf -= (WORD)i;

        }
    }

    pOEM->cTextBuf = 0;
    pOEM->fPositionReset = FALSE;
}

//*************************************************************
int
iCompTIFF(
    BYTE *pbOBuf,
    BYTE *pbIBuf,
    int  iBCnt
    )
/*++

Routine Description:

    This function is called to compress a scan line of data using
    TIFF v4 compression.

Arguments:

    pbOBuf      Pointer to output buffer  PRESUMED LARGE ENOUGH
    pbIBuf      Pointer to data buffer to compress
    iBCnt       Number of bytes to compress

Return Value:

    Number of compressed bytes

Note:
    The output buffer is presumed large enough to hold the output.
    In the worst case (NO REPETITIONS IN DATA) there is an extra
    byte added every 128 bytes of input data.  So, you should make
    the output buffer at least 1% larger than the input buffer.

    This routine is copied form UNIDRV.

--*/
{
    BYTE   *pbOut;        /* Output byte location */
    BYTE   *pbStart;      /* Start of current input stream */
    BYTE   *pb;           /* Miscellaneous usage */
    BYTE   *pbEnd;        /* The last byte of input */
    BYTE    jLast;        /* Last byte,  for match purposes */
    BYTE   bLast;

    int     iSize;        /* Bytes in the current length */
    int     iSend;        /* Number to send in this command */


    pbOut = pbOBuf;
    pbStart = pbIBuf;
    pbEnd = pbIBuf + iBCnt;         /* The last byte */

#if (TIFF_MIN_RUN >= 4)
    // this is a faster algorithm for calculating TIFF compression
    // that assumes a minimum RUN of at least 4 bytes. If the
    // third and fourth byte don't equal then the first/second bytes are
    // irrelevant. This means we can determine non-run data three times
    // as fast since we only check every third byte pair.

   if (iBCnt > TIFF_MIN_RUN)
   {
    // make sure the last two bytes aren't equal so we don't have to check
    // for the buffer end when looking for runs
    bLast = pbEnd[-1];
    pbEnd[-1] = ~pbEnd[-2];
    while( (pbIBuf += 3) < pbEnd )
    {
        if (*pbIBuf == pbIBuf[-1])
        {
            // save the run start pointer, pb, and check whether the first
            // bytes are also part of the run
            //
            pb = pbIBuf-1;
            if (*pbIBuf == pbIBuf[-2])
            {
                pb--;
                if (*pbIBuf == pbIBuf[-3])
                    pb--;
            }

            //  Find out how long this run is
            jLast = *pb;
            do {
                pbIBuf++;
            } while (*pbIBuf == jLast);

            // test whether last byte is also part of the run
            //
            if (jLast == bLast && pbIBuf == (pbEnd-1))
                pbIBuf++;

            // Determine if the run is longer that the required
            // minimum run size.
            //
            if ((iSend = (int)(pbIBuf - pb)) >= (TIFF_MIN_RUN))
            {
                /*
                 *    Worth recording as a run,  so first set the literal
                 *  data which may have already been scanned before recording
                 *  this run.
                 */

                if( (iSize = (int)(pb - pbStart)) > 0 )
                {
                    /*   There is literal data,  so record it now */
                    while (iSize > TIFF_MAX_LITERAL)
                    {
                        iSize -= TIFF_MAX_LITERAL;
                        *pbOut++ = TIFF_MAX_LITERAL-1;
                        CopyMemory(pbOut, pbStart, TIFF_MAX_LITERAL);
                        pbStart += TIFF_MAX_LITERAL;
                        pbOut += TIFF_MAX_LITERAL;
                    }
                    *pbOut++ = iSize - 1;
                    CopyMemory(pbOut, pbStart, iSize);
                    pbOut += iSize;
                }

                /*
                 *   Now for the repeat pattern.  Same logic,  but only
                 * one byte is needed per entry.
                 */
                iSize = iSend;
                while (iSize > TIFF_MAX_RUN)
                {
                    *((char *)pbOut)++ = 1 - TIFF_MAX_RUN;
                    *pbOut++ = jLast;
                    iSize -= TIFF_MAX_RUN;
                }
                *pbOut++ = 1 - iSize;
                *pbOut++ = jLast;

                pbStart = pbIBuf;           /* Ready for the next one! */
            }
        }
    }
    pbEnd[-1] = bLast;
   }
#else
    jLast = *pbIBuf++;

    while( pbIBuf < pbEnd )
    {
        if( jLast == *pbIBuf )
        {
            /*  Find out how long this run is.  Then decide on using it */
            pb = pbIBuf;
            do {
                pbIBuf++;
            } while (pbIBuf < pbEnd && *pbIBuf == jLast);

            /*
             *  Note that pb points at the SECOND byte of the pattern!
             *  AND also that pbIBuf points at the first byte AFTER the run.
             */

            if ((iSend = pbIBuf - pb) >= (TIFF_MIN_RUN - 1))
            {
                /*
                 *    Worth recording as a run,  so first set the literal
                 *  data which may have already been scanned before recording
                 *  this run.
                 */

                if( (iSize = pb - pbStart - 1) > 0 )
                {
                    /*   There is literal data,  so record it now */
                    while (iSize > TIFF_MAX_LITERAL)
                    {
                        iSize -= TIFF_MAX_LITERAL;
                        *pbOut++ = TIFF_MAX_LITERAL-1;
                        CopyMemory(pbOut, pbStart, TIFF_MAX_LITERAL);
                        pbStart += TIFF_MAX_LITERAL;
                        pbOut += TIFF_MAX_LITERAL;
                    }
                    *pbOut++ = iSize - 1;
                    CopyMemory(pbOut, pbStart, iSize);
                    pbOut += iSize;
                }

                /*
                 *   Now for the repeat pattern.  Same logic,  but only
                 * one byte is needed per entry.
                 */

                iSize = iSend + 1;
                while (iSize > TIFF_MAX_RUN)
                {
                    *((char *)pbOut)++ = 1 - TIFF_MAX_RUN;
                    *pbOut++ = jLast;
                    iSize -= TIFF_MAX_RUN;
                }
                *pbOut++ = 1 - iSize;
                *pbOut++ = jLast;

                pbStart = pbIBuf;           /* Ready for the next one! */
            }
            if (pbIBuf == pbEnd)
                break;
        }

        jLast = *pbIBuf++;                   /* Onto the next byte */

    }
#endif

    if ((iSize = (int)(pbEnd - pbStart)) > 0)
    {
        /*  Left some dangling.  This can only be literal data.   */

        while( (iSend = min( iSize, TIFF_MAX_LITERAL )) > 0 )
        {
            *pbOut++ = iSend - 1;
            CopyMemory( pbOut, pbStart, iSend );
            pbOut += iSend;
            pbStart += iSend;
            iSize -= iSend;
        }
    }

    return  (int)(pbOut - pbOBuf);
}

BOOL
APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    POEM_EXTRADATA  pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);
    PBYTE           pNewBufPtr;
    DWORD           dwNewBufSize;
    INT             nCompressedSize;

    if(!pOEM->fCallback)
    {
// ntbug9#208433: Output images are broken on ART2/3 models.
        if (pOEM->bART3) { // ART2/3 can't support TIFF compression
            WRITESPOOLBUF(pdevobj, pBuf, dwLen);
            return TRUE;
        }

        // For TIFF compression in fxartres
        dwNewBufSize = NEEDSIZE4TIFF(dwLen);
        if( dwNewBufSize > pOEM->dwTiffCompressBufSize)
        {
            if(!(pNewBufPtr = (PBYTE)MemAlloc(dwNewBufSize)))
            {
                ERR(("Re-MemAlloc failed.\n"));
                return TRUE;
            }else {
                // Prepare new buffer
                MemFree(pOEM->pTiffCompressBuf);
                pOEM->pTiffCompressBuf = pNewBufPtr;
                pOEM->dwTiffCompressBufSize = dwNewBufSize;
            }
        }
        // Do TIFF compression
        nCompressedSize = iCompTIFF( pOEM->pTiffCompressBuf, pBuf, dwLen );
        WRITESPOOLBUF(pdevobj, pOEM->pTiffCompressBuf, nCompressedSize);
        return TRUE;
    }

    return HexOutput(pdevobj, pBuf, dwLen);
}

//-------------------------------------------------------------------
// OEMOutputCmd
// Action :
//-------------------------------------------------------------------

#define CBID_CM_OCD_XM_ABS              1
#define CBID_CM_OCD_YM_ABS              2
#define CBID_CM_OCD_XM_REL              3
#define CBID_CM_OCD_YM_REL              4
#define CBID_CM_OCD_XM_RELLEFT          5
#define CBID_CM_OCD_YM_RELUP            6
#define CBID_CM_CR                      7
#define CBID_CM_FF                      8
#define CBID_CM_LF                      9

#define CBID_PC_OCD_BEGINDOC_ART        11
#define CBID_PC_OCD_BEGINDOC_ART3       12
#define CBID_PC_OCD_BEGINDOC_ART4       13
#define CBID_PC_OCD_BEGINPAGE           14
#define CBID_PC_OCD_ENDPAGE             15
#define CBID_PC_OCD_MULT_COPIES         16
#define CBID_PC_OCD_PORTRAIT            17
#define CBID_PC_OCD_LANDSCAPE           18
#define CBID_PC_OCD_BEGINDOC_ART4_JCL   19
#define CBID_PC_OCD_MULT_COPIES_450     20

#define CBID_RES_OCD_SELECTRES_240DPI   21
#define CBID_RES_OCD_SELECTRES_300DPI   22
#define CBID_RES_OCD_SELECTRES_400DPI   23
#define CBID_RES_OCD_SELECTRES_600DPI   24
#define CBID_RES_OCD_SENDBLOCK_ASCII    25
#define CBID_RES_OCD_SENDBLOCK          26

#define CBID_RES_OCD_SELECTRES_240DPI_ART3_ART   27
#define CBID_RES_OCD_SELECTRES_300DPI_ART3_ART   28

#define CBID_RES_OCD_SELECTRES_450      29

#define CBID_PSZ_OCD_SELECT_A3          30
#define CBID_PSZ_OCD_SELECT_A4          31
#define CBID_PSZ_OCD_SELECT_A5          32
#define CBID_PSZ_OCD_SELECT_B4          33
#define CBID_PSZ_OCD_SELECT_B5          34
#define CBID_PSZ_OCD_SELECT_PC          35
#define CBID_PSZ_OCD_SELECT_DL          36
#define CBID_PSZ_OCD_SELECT_LT          37
#define CBID_PSZ_OCD_SELECT_GG          38
#define CBID_PSZ_OCD_SELECT_LG          39
#define CBID_PSZ_OCD_SELECT_S1          40
#define CBID_PSZ_OCD_SELECT_S2          41
#define CBID_PSZ_OCD_SELECT_S3          42
#define CBID_PSZ_OCD_SELECT_S4          43
#define CBID_PSZ_OCD_SELECT_A6          44
#define CBID_PSZ_OCD_SELECT_B6          45
#define CBID_PSZ_OCD_SELECT_ST          46

#define CBID_FS_OCD_BOLD_ON             51
#define CBID_FS_OCD_BOLD_OFF            52
#define CBID_FS_OCD_ITALIC_ON           53
#define CBID_FS_OCD_ITALIC_OFF          54
#define CBID_FS_OCD_SINGLE_BYTE         55
#define CBID_FS_OCD_DOUBLE_BYTE         56
#define CBID_FS_OCD_WHITE_TEXT_ON       57
#define CBID_FS_OCD_WHITE_TEXT_OFF      58
#define CBID_SRT_OCD_SORTER_ON          59
#define CBID_SRT_OCD_SORTER_OFF         60

#define CBID_PC_OCD_ENDDOC              70

#define CBID_FONT_SELECT_OUTLINE        101

static
VOID
XYMoveUpdate(
    PDEVOBJ pdevobj)
{
    POEM_EXTRADATA pOEM;

    pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);

    FX_VERBOSE(("XYMoveFlush: %d,%d\n",
        pOEM->ptlCur.x, pOEM->ptlCur.y ));

    if(pOEM->cTextBuf)
        FlushText( pdevobj );

    SaveTextCur( pdevobj );
}

#define XMoveAbs(p, i) \
{   ((POEM_EXTRADATA)((p)->pOEMDM))->ptlCur.x = (i); \
    XYMoveUpdate(p); }

// For internal calculation of X-pos.
#define RATE_FONTWIDTH2XPOS 1000
#define VALUE_FONTWIDTH2XPOS_ROUNDUP5   500
#define YMoveAbs(p, i) \
{   ((POEM_EXTRADATA)((p)->pOEMDM))->ptlCur.y = (i); \
    ((POEM_EXTRADATA)((p)->pOEMDM))->ptlCur.x += ((((POEM_EXTRADATA)((p)->pOEMDM))->lInternalXAdd +VALUE_FONTWIDTH2XPOS_ROUNDUP5 ) \
                                                 / RATE_FONTWIDTH2XPOS ); \
    ((POEM_EXTRADATA)((p)->pOEMDM))->lInternalXAdd = 0;    \
    ZeroMemory(((POEM_EXTRADATA)((p)->pOEMDM))->widBuf, sizeof(LONG) * STRBUFSIZE); \
    XYMoveUpdate(p); }

//
//  FreedBuffersInPDEV
//
VOID
FreeCompressBuffers( PDEVOBJ pdevobj )
{
    POEM_EXTRADATA  pOEM;

    pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);
    if( pOEM->pTiffCompressBuf != NULL )
    {
        MemFree(pOEM->pTiffCompressBuf);
        pOEM->pTiffCompressBuf = NULL;
        pOEM->dwTiffCompressBufSize = 0;
    }

    return;
}

/*****************************************************************************/
/*                                                                           */
/*   INT APIENTRY OEMCommandCallback(                                        */
/*                PDEVOBJ pdevobj                                            */
/*                DWORD   dwCmdCbId                                          */
/*                DWORD   dwCount                                            */
/*                PDWORD  pdwParams                                          */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbID,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams ) // points to values of command params
{
    BYTE            buf[512];
    INT             ilen;
    POEM_EXTRADATA  pOEM;
    LONG            x, y;
    BOOL            bAscii;
    CHAR           *pStr;
    INT             iRet;

    VERBOSE(("OEMCommandCallback entry.\n"));

    ASSERT(VALID_PDEVOBJ(pdevobj));

    pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);

    bAscii = FALSE;
    iRet = 0;
    ilen = 0;

    switch( dwCmdCbID )
    {
        // PAPERSIZE
        case CBID_PSZ_OCD_SELECT_A3:
            LoadPaperInfo( pOEM, "a3" );
            break;

        case CBID_PSZ_OCD_SELECT_A4:
            LoadPaperInfo( pOEM, "a4" );
            break;

        case CBID_PSZ_OCD_SELECT_A5:
            LoadPaperInfo( pOEM, "a5" );
            break;

        case CBID_PSZ_OCD_SELECT_A6:
            LoadPaperInfo( pOEM, "a6" );
            break;

        case CBID_PSZ_OCD_SELECT_B4:
            LoadPaperInfo( pOEM, "b4" );
            break;

        case CBID_PSZ_OCD_SELECT_B5:
            LoadPaperInfo( pOEM, "b5" );
            break;

        case CBID_PSZ_OCD_SELECT_B6:
            LoadPaperInfo( pOEM, "b6" );
            break;

        case CBID_PSZ_OCD_SELECT_PC:
            LoadPaperInfo( pOEM, "pc" );
            break;

        case CBID_PSZ_OCD_SELECT_DL:
            LoadPaperInfo( pOEM, "o0" );
            break;

        case CBID_PSZ_OCD_SELECT_LT:
            LoadPaperInfo( pOEM, "o1" );
            break;

        case CBID_PSZ_OCD_SELECT_GG:
            LoadPaperInfo( pOEM, "o2" );
            break;

        case CBID_PSZ_OCD_SELECT_LG:
            LoadPaperInfo( pOEM, "o3" );
            break;

        case CBID_PSZ_OCD_SELECT_ST:
            LoadPaperInfo( pOEM, "hl" );
            break;

        case CBID_PSZ_OCD_SELECT_S1:
            LoadPaperInfo( pOEM, "s1" );
            break;

        case CBID_PSZ_OCD_SELECT_S2:
            LoadPaperInfo( pOEM, "s2" );
            break;

        case CBID_PSZ_OCD_SELECT_S3:
            LoadPaperInfo( pOEM, "s3" );
            break;

        case CBID_PSZ_OCD_SELECT_S4:
            LoadPaperInfo( pOEM, "s4" );
            break;

        case CBID_PC_OCD_PORTRAIT:
            pOEM->chOrient = "p";
            break;

        case CBID_PC_OCD_LANDSCAPE:
            pOEM->chOrient = "l";
            break;

        // PAGECONTROL
        case CBID_PC_OCD_BEGINDOC_ART:
            ilen = wsprintf( buf, "stj c\n" );
            break;

        case CBID_PC_OCD_BEGINDOC_ART3:
            ilen = wsprintf( buf, "srl %d %d\nstj c\n",
                                        pOEM->sizlRes.cx, pOEM->sizlRes.cy );
            break;

        case CBID_PC_OCD_BEGINDOC_ART4:
            ilen = wsprintf( buf, "\x1b%%-12345X" );
            break;

        case CBID_PC_OCD_BEGINDOC_ART4_JCL:
            ilen = wsprintf( buf,"\x1b%%-12345X\x0d\x0a@JOMO=PRINTER\x0d\x0a");
            break;

        case CBID_PC_OCD_BEGINPAGE:
            // Set resolution value again. The value is often reset to zero in BInitOEMExtraData.
            // It is the time to call ResetDC between pages.
            pOEM->sizlRes.cx = PARAM(pdwParams, 0);
            pOEM->sizlRes.cy = PARAM(pdwParams, 1);

            // bold-simulation width: res / 50
            ilen = wsprintf( buf,
                "stp %s %s\nud i\nscl %d %d\nsb %d\n",
                 pOEM->chOrient,
                 pOEM->chSize,
                 (DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT),
                 (DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT),
                 (pOEM->sizlRes.cy * 2 / 100));

            pOEM->ptlCur.x = 0;
            pOEM->ptlCur.y = 0;
            break;

        case CBID_PC_OCD_ENDPAGE:
            if(pOEM->fSort == FALSE){
                ilen = wsprintf( buf,
                                 "ep %d\n",
                                  pOEM->iCopies );
            }else if(pOEM->fSort == TRUE){
                ilen = wsprintf( buf,
                                 "ep 1\n");
            }

            FlushText( pdevobj );
            pOEM->cFontId = 0;
            pOEM->iCurFontId = 0;
// #365649: Invalid font size
            pOEM->iCurFontHeight = 0;
            pOEM->iCurFontWidth = 0;

            FreeCompressBuffers( pdevobj );   // If the buffer is need after, it will be alloced again.

            break;

        case CBID_PC_OCD_ENDDOC:
            WRITESPOOLBUF( pdevobj, "ej\n", 3 );    // Output endjob command
            FreeCompressBuffers( pdevobj );

            break;

        case CBID_PC_OCD_MULT_COPIES:
// @Aug/31/98 ->
            if(MAX_COPIES_VALUE < PARAM(pdwParams, 0)) {
                pOEM->iCopies = MAX_COPIES_VALUE;
            }
            else if(1 > PARAM(pdwParams, 0)) {
                pOEM->iCopies = 1;
            }
            else {
                pOEM->iCopies = (WORD)PARAM(pdwParams, 0);
            }
// @Aug/31/98 <-
            break;

        case CBID_PC_OCD_MULT_COPIES_450:
            if(MAX_COPIES_VALUE_450 < PARAM(pdwParams, 0)) {
                pOEM->iCopies = MAX_COPIES_VALUE;
            }
            else if(1 > PARAM(pdwParams, 0)) {
                pOEM->iCopies = 1;
            }
            else {
                pOEM->iCopies = (WORD)PARAM(pdwParams, 0);
            }
            break;


        // Cursor Move

        case CBID_CM_OCD_XM_ABS:
        case CBID_CM_OCD_YM_ABS:

            FX_VERBOSE(("CB: XM/YM_ABS %d\n",
                PARAM(pdwParams, 0)));

            iRet = (WORD)PARAM(pdwParams, 0);
            if (CBID_CM_OCD_YM_ABS == dwCmdCbID) {
                YMoveAbs(pdevobj, iRet);
            }
            else {
                XMoveAbs(pdevobj, iRet);
            }
            break;

        // RESOLUTION

        case CBID_RES_OCD_SELECTRES_240DPI:
            pOEM->sizlRes.cx = 240;
            pOEM->sizlRes.cy = 240;
            ilen = wsprintf(buf,
                "@PL > ART\x0D\x0Asrl 240 240\x0D\x0A\nccode j\nstj c\n");
            break;

        case CBID_RES_OCD_SELECTRES_300DPI:
            pOEM->sizlRes.cx = 300;
            pOEM->sizlRes.cy = 300;
            ilen = wsprintf(buf,
                "@PL > ART\x0D\x0Asrl 300 300\x0D\x0A\nccode j\nstj c\n");
            break;

        case CBID_RES_OCD_SELECTRES_400DPI:
            pOEM->sizlRes.cx = 400;
            pOEM->sizlRes.cy = 400;
            ilen = wsprintf(buf,
                "@PL > ART\x0D\x0Asrl 400 400\x0D\x0A\nccode j\nstj c\n");
            break;

        case CBID_RES_OCD_SELECTRES_600DPI:
            pOEM->sizlRes.cx = 600;
            pOEM->sizlRes.cy = 600;
            ilen = wsprintf(buf,
                "@PL > ART\x0D\x0Asrl 600 600\x0D\x0A\nccode j\nstj c\n");
            break;

        case CBID_RES_OCD_SELECTRES_450:
            pOEM->sizlRes.cx = 600;
            pOEM->sizlRes.cy = 600;

            if(pOEM->fSort == FALSE){
                ilen = wsprintf(buf,
                    "@JOOF=OFF\x0D\x0A@PL > ART\x0D\x0Asrl 600 600\x0D\x0A\nccode j\nstj c\n");
            }else{
                ilen = wsprintf(buf,
                    "@JOOF=OFF\x0D\x0A@PL > ART\x0D\x0Asrl 600 600\x0D\x0A\nccode j\nstj c\nstp jog 0\n");
            }
            break;


        case CBID_RES_OCD_SELECTRES_240DPI_ART3_ART:
            pOEM->sizlRes.cx = 240;
            pOEM->sizlRes.cy = 240;
// ntbug9#208433: Output images are broken on ART2/3 models.
            pOEM->bART3 = TRUE;
            break;

        case CBID_RES_OCD_SELECTRES_300DPI_ART3_ART:
            pOEM->sizlRes.cx = 300;
            pOEM->sizlRes.cy = 300;
// ntbug9#208433: Output images are broken on ART2/3 models.
            pOEM->bART3 = TRUE;
            break;


        case CBID_RES_OCD_SENDBLOCK_ASCII:
            bAscii = TRUE;
            pOEM->fCallback = TRUE;
            /* FALLTHROUGH */

        case CBID_RES_OCD_SENDBLOCK:
            //
            // image x y psx psy pcy pcy [string]
            //

            {
                LONG iPsx, iPsy, iPcx, iPcy;

                iPsx = DRIVER_MASTER_UNIT / pOEM->sizlRes.cx;
                iPsy = DRIVER_MASTER_UNIT / pOEM->sizlRes.cy;

                iPcx = PARAM(pdwParams, 2) * 8;
                iPcy = PARAM(pdwParams, 1);

                FX_VERBOSE(("CB: SB %d(%d) %d(%d) %d %d %d %d\n",
                    ( pOEM->ptlOrg.x + pOEM->ptlCur.x ),
                    pOEM->ptlCur.x,
                    ( pOEM->ptlOrg.y - pOEM->ptlCur.y ),
                    pOEM->ptlCur.y,
                    iPsx,
                    iPsy,
                    iPcx,
                    (- iPcy)));

// ntbug9#208433: Output images are broken on ART2/3 models.
                ilen = wsprintf( buf,
                    "%s%d %d %d %d %d %d %s",
                    ((bAscii || pOEM->bART3) ? "im " : "scm 5\nim "),
                    ( pOEM->ptlOrg.x + pOEM->ptlCur.x ),
                    ( pOEM->ptlOrg.y - pOEM->ptlCur.y ),
                    iPsx,
                    iPsy,
                    iPcx,
                    (- iPcy),
                    (bAscii ? "<" : "[")
                );
            }

            break;

        case CBID_FS_OCD_BOLD_ON:
        case CBID_FS_OCD_BOLD_OFF:
        case CBID_FS_OCD_ITALIC_ON:
        case CBID_FS_OCD_ITALIC_OFF:
        case CBID_FS_OCD_SINGLE_BYTE:
        case CBID_FS_OCD_DOUBLE_BYTE:
        case CBID_FS_OCD_WHITE_TEXT_ON:
        case CBID_FS_OCD_WHITE_TEXT_OFF:
            pStr = NULL;

            switch ( dwCmdCbID ) {

            case CBID_FS_OCD_WHITE_TEXT_ON:
                if(!(pOEM->fFontSim & FONT_SIM_WHITE))
                {
                    pStr = "pm i c\n";
                    pOEM->fFontSim |= FONT_SIM_WHITE;
                }
                break;

            case CBID_FS_OCD_WHITE_TEXT_OFF:
                if(pOEM->fFontSim & FONT_SIM_WHITE)
                {
                    pStr = "pm n o\n";
                    pOEM->fFontSim &= ~FONT_SIM_WHITE;
                }
                break;

            case CBID_FS_OCD_BOLD_ON:
                if(!(pOEM->fFontSim & FONT_SIM_BOLD))
                {
                    pStr = "bb\n";
                    pOEM->fFontSim |= FONT_SIM_BOLD;
                }
                break;

            case CBID_FS_OCD_BOLD_OFF:
                if(pOEM->fFontSim & FONT_SIM_BOLD)
                {
                    pStr = "eb\net\n"; // DCR: Do we need "et\n"(Transform off)?
                    pOEM->fFontSim &= ~FONT_SIM_BOLD;
                }
                break;

            case CBID_FS_OCD_ITALIC_ON:
                if(!(pOEM->fFontSim & FONT_SIM_ITALIC))
                {
                    pStr = "trf x -18\nbt\n";
                    pOEM->fFontSim |= FONT_SIM_ITALIC;
                }
                break;

            case CBID_FS_OCD_ITALIC_OFF:
                if(pOEM->fFontSim & FONT_SIM_ITALIC)
                {
                    pStr = "eb\net\n"; // DCR: Do we need "et\n"(Transform off)?
                    pOEM->fFontSim &= ~FONT_SIM_ITALIC;
                }
                break;
            }

            if ( pStr )
            {
                FlushText( pdevobj );
                ilen = strlen( pStr );
                WRITESPOOLBUF( pdevobj, pStr, ilen );
            }
            ilen = 0;
            break;

            case CBID_CM_CR:
                XMoveAbs(pdevobj, 0);
                iRet = 0;
                break;

            case CBID_CM_FF:
            case CBID_CM_LF:
                ilen = 0;
                break;

            case CBID_SRT_OCD_SORTER_OFF:
                pOEM->fSort = FALSE ;
                ilen = wsprintf( buf,
                                 "@CLLT=OFF\x0D\x0A");
                break;

           case CBID_SRT_OCD_SORTER_ON:
                pOEM->fSort = TRUE ;
                ilen = wsprintf( buf,
                                 "@CLLT=ON\x0D\x0A@JOCO=%d\x0D\x0A",
                                 pOEM->iCopies);
                break;


        default:

            break;
    }

    if ( ilen > 0 ) {
        WRITESPOOLBUF( pdevobj, buf, ilen );
    }

    return iRet;
}


//---------------------------*OEMSendFontCmd*----------------------------------
// Action:  send Pages-style font selection command.
//-----------------------------------------------------------------------------
VOID APIENTRY OEMSendFontCmd(pdevobj, pUFObj, pFInv)
PDEVOBJ      pdevobj;
PUNIFONTOBJ  pUFObj;     // offset to the command heap
PFINVOCATION pFInv;
{
    POEM_EXTRADATA  pOEM;
    GETINFO_STDVAR *pSV;
    DWORD           adwSV[2 + 2 * 2];
    INT             iFontId;
    INT             i, j, ilen;
    BYTE            buf[512], *pbuf;
    PIFIMETRICS pIFI = pUFObj->pIFIMetrics;

#define SV_HEIGHT (pSV->StdVar[0].lStdVariable)
#define SV_WIDTH (pSV->StdVar[1].lStdVariable)
#define COEF_FIXPITCH_MUL   8
#define COEF_FIXPITCH_DEV   10
#define COEF_ROUNDUP5_VAL   5

    VERBOSE(("OEMSendFontCmd entry.\n"));

    ASSERT(VALID_PDEVOBJ(pdevobj));

    if(!pUFObj || !pFInv)
    {
        ERR(("OEMSendFontCmd: parameter is invalid."));
        return;
    }

    if(pUFObj->ulFontID < 1 || pUFObj->ulFontID > 21)
    {
        ERR(("OEMSendFontCmd: ulFontID is invalid.\n"));
        return;
    }

    pbuf = buf;
    pOEM = (POEM_EXTRADATA)pdevobj->pOEMDM;

    j = pUFObj->ulFontID - 1;
    iFontId = gFonts[ j ].id;

    if(pOEM->cTextBuf)
        FlushText(pdevobj);

    for ( i = 0; i < pOEM->cFontId; i++ )
    {
        if( iFontId == pOEM->aFontId[ i ] )
            break;
    }
    if ( i >= pOEM->cFontId ) {

        // not declared yet within this page, so let us declare
        // it here.

        pOEM->aFontId[ pOEM->cFontId++ ] = (BYTE)iFontId;
        if ( gFonts[ j ].fid2 ) {
            ilen = wsprintf( pbuf,
                "std\n%s%sed\n",
                gFonts[ j ].fid1,
                gFonts[ j ].fid2 );
            pbuf += ilen;
        }
        else {
            ilen = wsprintf( pbuf,
                "std\n%sed\n",
                gFonts[ j ].fid1 );
            pbuf += ilen;
        }
    }

    pSV = (GETINFO_STDVAR *)&adwSV[0];
    pSV->dwSize               = sizeof(adwSV);
    pSV->dwNumOfVariable      = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, &adwSV, 0, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    FX_VERBOSE(("SendFontCmd: SV_FH,SV_FW=%d,%d\n",
        pSV->StdVar[0].lStdVariable,
        pSV->StdVar[1].lStdVariable));

    pOEM->iFontId = (WORD)iFontId;
    pOEM->iFontHeight = (WORD)SV_HEIGHT;

    // Support non-square scaling only when the
    // font is non-proportional. (The w parameter
    // of "fontsize" ART command only valid with
    // non-proportional fonts)

    if (!ISPROPFONT(iFontId)) {
        if (ISDBCSFONT(iFontId)) {
            pOEM->iFontWidth = (WORD)SV_WIDTH;
            pOEM->iFontWidth2 = (WORD)(SV_WIDTH * 2);
            pOEM->wSBCSFontWidth = (WORD)SV_WIDTH;
        }
        else {
            pOEM->iFontWidth = (WORD)SV_WIDTH;
            // If fixed pitch font, real width of device font is 80% of SV_WIDTH
            pOEM->wSBCSFontWidth = (WORD)((SV_WIDTH * COEF_FIXPITCH_MUL + COEF_ROUNDUP5_VAL ) / COEF_FIXPITCH_DEV);
        }
    }
    else {
        // Default.
        pOEM->iFontWidth = 0;
    }

    if ( pbuf > buf )
        WRITESPOOLBUF( pdevobj, buf, (INT)(pbuf - buf));

    // Need set iFontId to iTextFontId
    pOEM->iTextFontId = pOEM->iFontId;
    pOEM->iTextFontHeight = pOEM->iFontHeight;
    pOEM->iTextFontWidth = pOEM->iFontWidth;
    pOEM->iTextFontWidth2 = pOEM->iFontWidth2;

}


VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD dwType,
    DWORD dwCount,
    PVOID pGlyph )
{
    GETINFO_GLYPHSTRING GStr;
    PBYTE               aubBuff;
    PTRANSDATA          pTrans;
    DWORD               dwI;
    POEM_EXTRADATA      pOEM;

    BYTE *pTemp;
    WORD wLen;
    INT iMark = 0;

    // For internal calculation of X-pos.
    DWORD dwGetInfo;
    GETINFO_GLYPHWIDTH  GWidth;

    VERBOSE(("OEMOutputCharStr() entry.\n"));
    ASSERT(VALID_PDEVOBJ(pdevobj));

    if(!pdevobj || !pUFObj || !pGlyph)
    {
        ERR(("OEMOutputCharStr: Invalid parameter.\n"));
        return;
    }

    if(dwType == TYPE_GLYPHHANDLE &&
                            (pUFObj->ulFontID < 1 || pUFObj->ulFontID > 21) )
    {
        ERR(("OEMOutputCharStr: ulFontID is invalid.\n"));
        return;
    }

    pOEM = (POEM_EXTRADATA)(pdevobj->pOEMDM);

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:

        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;

        /* Get TRANSDATA buffer size */
        if (FALSE != pUFObj->pfnGetInfo(pUFObj,
                UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)
            || 0 == GStr.dwGlyphOutSize)
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\n"));
            return;
        }

        /* Alloc TRANSDATA buffer size */
        if(!(aubBuff = (PBYTE)MemAllocZ(GStr.dwGlyphOutSize)) )
        {
            ERR(("MemAlloc failed.\n"));
            return;
        }

        /* Get actual TRANSDATA */
        GStr.pGlyphOut = (PTRANSDATA)aubBuff;

        if (!pUFObj->pfnGetInfo(pUFObj,
                UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
        {
            ERR(("GetInfo failed.\n"));
            return;
        }

        // For internal calculation of X-pos.
        GWidth.dwSize = sizeof(GETINFO_GLYPHWIDTH);
        GWidth.dwCount = dwCount;
        GWidth.dwType = TYPE_GLYPHHANDLE;
        GWidth.pGlyph = pGlyph;
        GWidth.plWidth = pOEM->widBuf;
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHWIDTH, &GWidth,
            dwGetInfo, &dwGetInfo)) {
            ERR(("UFO_GETINFO_GLYPHWIDTH failed.\n"));
            return;
        }

        pTrans = GStr.pGlyphOut;

        for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
        {
            if ( pOEM->cTextBuf >= sizeof ( pOEM->ajTextBuf ))
                FlushText( pdevobj );

            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            case MTYPE_DIRECT:
                pOEM->ajTextBuf[ pOEM->cTextBuf++ ] = 0;
                pOEM->ajTextBuf[ pOEM->cTextBuf++ ] =
                                                (BYTE)pTrans->uCode.ubCode;
                break;

            case MTYPE_PAIRED:
                pOEM->ajTextBuf[ pOEM->cTextBuf++ ] =
                                            (BYTE)pTrans->uCode.ubPairs[0];
                pOEM->ajTextBuf[ pOEM->cTextBuf++ ] =
                                            (BYTE)pTrans->uCode.ubPairs[1];
                break;
            case MTYPE_COMPOSE:
                pTemp = (BYTE *)(GStr.pGlyphOut) + pTrans->uCode.sCode;

                // first two bytes are the length of the string
                wLen = *pTemp + (*(pTemp + 1) << 8);
                pTemp += 2;

                switch (*pTemp)
                {
                case MARK_ALT_GSET:
                    iMark = MARK_ALT_GSET;
                    pTemp++;
                    wLen--;
                    break;
                }

                while (wLen--)
                {
                    pOEM->ajTextBuf[ pOEM->cTextBuf++ ] = (BYTE)iMark;
                    pOEM->ajTextBuf[ pOEM->cTextBuf++ ] = *pTemp++;
                }
            }
            // For internal calculation of X-pos.
            pOEM->lInternalXAdd += (LONG)((LONG)pOEM->widBuf[dwI] * ((LONG)pOEM->wSBCSFontWidth));
        }
        MemFree(aubBuff);

        break;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxartres\name.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxartres\etc\fxart4.c ===
#define PRINTDRIVER
#include <print.h>
#include "mdevice.h"
#include "gdidefs.inc"
#include "unidrv.h"
#include <memory.h>

#ifndef _INC_WINDOWSX
#include <windowsx.h>
#endif

#ifdef WINNT
#define CODESEG /* not used */
#else // WINNT
#define _CODESEG      "_CODESEG"
#define CODESEG    __based(__segname(_CODESEG))
#endif // WINNT

//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

char *rgchModuleName = "FXART4";

#define DEVICE_MASTER_UNIT 7200
#define DRIVER_MASTER_UNIT 1200

typedef struct
{
    BYTE  fGeneral;       // General purpose bitfield
    BYTE  bCmdCbId;       // Callback ID; 0 iff no callback
    WORD  wCount;         // # of EXTCD structures following
    WORD  wLength;        // length of the command
} CD, *PCD, FAR * LPCD;

typedef struct tagMYMDV {
    POINTL ptlOrg;
    POINTL ptlCur;
    SIZEL sizlRes;
    WORD iCopies;
    CHAR *chOrient;
    CHAR *chSize;
    BOOL bString;
    WORD cFontId;
    WORD iFontId;
    WORD iFontHeight;
    LONG aFontId[20];
    POINTL ptlTextCur;
    WORD iTextFontId;
    WORD iTextFontHeight;
    WORD cTextBuf;
    BYTE ajTextBuf[1024];
    WORD fFontSim;
} MYMDV, *LPMYMDV;

#define FONT_SIM_ITALIC 1
#define FONT_SIM_BOLD 2

// to get physical paper sizes.

typedef struct tagMYFORMS {
    CHAR *id;
    LONG x;
    LONG y;
} MYFORMS, *LPMYFORMS;

// font name to font id mappnig

typedef struct tagMYFONTS {
    LONG id;
    CHAR *fid1;
    CHAR *fid2;
    CHAR *pface;
} MYFONTS, *LPMYFONTS;

//
// Load necessary information for specified paper size.
// Make sure PC_OCD_LANDSCAPE and PC_OCD_PORTRAIT are
// called.
//

MYFORMS gForms[] = {
    "a3", 13608, 19422,
    "a4", 9498, 13608,
    "a5", 6570, 9498,
    "b4", 11718, 16776,
    "b5", 8178, 11718,
    "pc", 4302, 6570, // Postcard
    "dl", 12780, 19980, // Tabloid
    "lt", 9780, 12780, // Letter
    "gg", 9780, 15180, // German Legal Fanfold
    "lg", 9780, 16380, // Legal
    "s1", 4530, 10962, // (Env) Comm 10
    "s2", 4224, 8580, // (Env) Monarch
    "s3", 4776, 9972, // (Env) DL
    "s4", 7230, 10398, // (Env) C5
    NULL, 0, 0
};

MYFONTS gFonts[] = {
    150, "fid 150 1 0 0 960 480\n", "fid 151 2 4 0 960 960\n",
        "\x96\xbe\x92\xa9", // Mincho
    152, "fid 152 1 0 1 960 480\n", "fid 153 2 4 1 960 960\n",
        "\xba\xde\xbc\xaf\xb8", // Gothic
    154, "fid 154 1 0 2 960 480\n", "fid 155 2 4 2 960 960\n",
        "\x8a\xdb\xba\xde\xbc\xaf\xb8", // Maru-Gothic
    156, "fid 156 1 0 0 960 480\n", "fid 157 2 5 0 960 960\n",
        "\x40\x96\xbe\x92\xa9", // @Mincho
    158, "fid 158 1 0 1 960 480\n", "fid 159 2 5 1 960 960\n",
        "\x40\xba\xde\xbc\xaf\xb8", // @Gothic
    160, "fid 160 1 0 2 960 480\n", "fid 161 2 5 2 960 960\n",
        "\x40\x8a\xdb\xba\xde\xbc\xaf\xb8", // @Maru-Gothic
    180, "fid 180 1 130 100 0 0\n", NULL, "CS TIMES",
    181, "fid 181 1 130 101 0 0\n", NULL, "CS TIMES Italic",
    182, "fid 182 1 130 102 0 0\n", NULL, "CS TIMES Bold",
    183, "fid 183 1 130 103 0 0\n", NULL, "CS TIMES Italic Bold",
    184, "fid 184 1 130 104 0 0\n", NULL, "CS Triumvirate",
    185, "fid 185 1 130 105 0 0\n", NULL, "CS Triumvirate Italic",
    186, "fid 186 1 130 106 0 0\n", NULL, "CS Triumvirate Bold",
    187, "fid 187 1 130 107 0 0\n", NULL, "CS Triumvirate Italic Bold",
    188, "fid 188 1 130 108 0 0\n", NULL, "CS Courier",
    189, "fid 189 1 130 109 0 0\n", NULL, "CS Courier Italic",
    190, "fid 190 1 130 110 0 0\n", NULL, "CS Courier Bold",
    191, "fid 191 1 130 111 0 0\n", NULL, "CS Courier Italic Bold",
    192, "fid 192 1 130 112 0 0\n", NULL, "CS Symbol",
    0, NULL, NULL, NULL
};

#define ISDBCSFONT(i) ((i) < 180)
#define ISVERTFONT(i) ((i) >= 156 && (i) < 180)

#ifdef WINNT
#include <stdio.h>
#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

LPWRITESPOOLBUF WriteSpoolBuf;
LPALLOCMEM UniDrvAllocMem;
LPFREEMEM UniDrvFreeMem;

BOOL
MyIsDBCSLeadByte(
BYTE bByte);
#define IsDBCSLeadByte  MyIsDBCSLeadByte

#endif //WINNT







BOOL
LoadPaperInfo(
    LPMYMDV lpMdv,
    CHAR *id ) {

    LPMYFORMS ptmp;


    for ( ptmp = gForms; ptmp->id; ptmp++ ) {
        if ( strcmp( id, ptmp->id) == 0 )
            break;
    }

    if ( ptmp->id == NULL )
        return FALSE;

    lpMdv->chSize = ptmp->id;

    lpMdv->ptlOrg.x = 0;
    if ( strcmp( lpMdv->chOrient, "l") == 0 ){
        lpMdv->ptlOrg.y = ptmp->x;
    }
    else {
        lpMdv->ptlOrg.y = ptmp->y;
    }

    lpMdv->ptlOrg.x += 210;
//v-jiroya (3/19/1997)
//    lpMdv->ptlOrg.y -= 210;
    lpMdv->ptlOrg.y += 210;

    return TRUE;
}

VOID
SjisToJis(
    BYTE *pDst, BYTE *pSrc
    )
{
    INT c1, c2;


    c1 = *pSrc;
    c2 = *(pSrc + 1);

    // Replace code values which cannot be mapped into 0x2121 - 0x7e7e
    // (94 x 94 cahracter plane) with Japanese defult character, which
    // is KATAKANA MIDDLE DOT.

    if (c1 >= 0xf0) {
        c1 = 0x81;
        c2 = 0x45;
    }

    c1 -= ( c1 > 0x9f ) ? 0xb1 : 0x71;
    c1 = c1 * 2 + 1;
    if ( c2 > 0x9e ) {
        c2 = c2 - 0x7e;
        c1++;
    }
    else {
        if ( c2 > 0x7e )
            c2--;
        c2 -= 0x1f;
    }

    *pDst = c1;
    *(pDst + 1) = c2;
}

#define TOHEX(j) ((j) < 10 ? ((j) + '0') : ((j) - 10 + 'a'))

LONG
HexOutput(
    LPDV lpDv,
    BYTE *lpBuf,
    WORD wLen )
{
    BYTE Buf[1024];
    BYTE *pSrc, *pSrcMax;
    LONG iRet, j;

    pSrc = (BYTE *)lpBuf;
    pSrcMax = pSrc + wLen;
    iRet = 0;

    while ( pSrc < pSrcMax ) {

        for ( j = 0; j < sizeof (Buf) && pSrc < pSrcMax; pSrc++ ) {

            BYTE c1, c2;

            c1 = (((*pSrc) >> 4) & 0x0f);
            c2 = (*pSrc & 0x0f);

            Buf[ j++ ] = TOHEX( c1 );
            Buf[ j++ ] = TOHEX( c2 );
        }

        if (WriteSpoolBuf( lpDv, Buf, j ) < 0)
            break;

        iRet += j;
    }
    return (WORD) iRet;
}

VOID
BeginString(
    LPDV lpdv,
    BOOL bReset )
{
    LONG ilen;
    BYTE buf[512];
    LPMYMDV lpMdv;
    BYTE *pbuf;


    lpMdv = lpdv->lpMdv;

    if (lpMdv->bString)
        return;

    pbuf = buf;
    if ( bReset ) {
        ilen = wsprintf( pbuf,
            "scp %d %d\n",
            ( lpMdv->ptlOrg.x + lpMdv->ptlTextCur.x ),
            ( lpMdv->ptlOrg.y - lpMdv->ptlTextCur.y ));
        pbuf += ilen;
    }

    ilen = wsprintf( pbuf,
        "sh <" );
    pbuf += ilen;

    if ( (pbuf - buf) > 0 ) {
        WriteSpoolBuf( lpdv, buf, (pbuf - buf) );
    }
    lpMdv->bString = TRUE;
}

VOID
EndString(
    LPDV lpdv )
{
    LONG ilen;
    BYTE buf[512];
    LPMYMDV lpMdv;

    lpMdv = lpdv->lpMdv;

    if (!lpMdv->bString)
        return;

    ilen = wsprintf( buf,
        ">\n" );

    if ( ilen > 0 ) {
        WriteSpoolBuf( lpdv, buf, ilen );
    }
    lpMdv->bString = FALSE;
}

VOID
BeginVertWrite(
    LPDV lpdv )
{
    BYTE buf[512];
    LPMYMDV lpMdv;
    INT ilen;
    BYTE *pbuf;


    lpMdv = lpdv->lpMdv;
    pbuf = buf;

    ilen = wsprintf( pbuf,
        "fo 90\nsrcp %d 0\n", lpMdv->iFontHeight );
    pbuf += ilen;
    if (lpMdv->fFontSim & FONT_SIM_ITALIC) {
        ilen = wsprintf( pbuf,
            "trf -18 y\n" );
        pbuf += ilen;
    }

    if ( pbuf > buf ) {
        WriteSpoolBuf( lpdv, buf, (pbuf - buf) );
    }
}

VOID
EndVertWrite(
    LPDV lpdv )
{
    BYTE buf[512];
    LPMYMDV lpMdv;
    INT ilen;
    BYTE *pbuf;

    lpMdv = lpdv->lpMdv;
    pbuf = buf;

    ilen = wsprintf( pbuf,
        "fo 0\nsrcp %d 0\n", -(lpMdv->iFontHeight) );
    pbuf += ilen;
    if (lpMdv->fFontSim & FONT_SIM_ITALIC) {
        ilen = wsprintf( pbuf,
            "trf x -18\n" );
        pbuf += ilen;
    }

    if ( pbuf > buf ) {
        WriteSpoolBuf( lpdv, buf, (pbuf - buf) );
    }
}

//
// Save the current poistion as the begining position of text output.
// We will cache string output so that we need to remember this.
//

VOID
SaveTextCur(
    LPDV lpdv )
{
    LPMYMDV lpMdv;
    lpMdv = lpdv->lpMdv;

    lpMdv->ptlTextCur.x = lpMdv->ptlCur.x;
    lpMdv->ptlTextCur.y = lpMdv->ptlCur.y;
    lpMdv->iTextFontId = lpMdv->iFontId;
    lpMdv->iTextFontHeight = lpMdv->iFontHeight;
}

//
// Flush out the cached text.  We switch between single byte font and
// double byte font if necesary.
//

VOID
FlushText(
    LPDV lpdv )
{
    LPMYMDV lpMdv;
    INT i;
    INT ilen;
    BYTE *pStr, *pStrSav, *pStrMax;
    BYTE buf[512];
    BOOL bReset;

    bReset = TRUE;
    lpMdv = lpdv->lpMdv;

    pStr = lpMdv->ajTextBuf;
    pStrMax = pStr + lpMdv->cTextBuf;
    pStrSav = pStr;

    for ( ; pStr < pStrMax; ) {

        if (ISDBCSFONT( lpMdv->iTextFontId )) {

            for ( pStrSav = pStr; pStr < pStrMax; pStr += 2 ) {
                if (!IsDBCSLeadByte(*pStr))
                    break;
                SjisToJis(pStr, pStr);
            }

            if ((pStr - pStrSav) > 0) {

                // switch font to output double byte characters
                // we have assigned fontid + 1 as the font ids for
                // double byte fonts, so just add 1 to get double
                // byte font id.

                ilen = wsprintf( buf,
                    "sfi %d\nfs %d 0\n",
                    (lpMdv->iTextFontId + 1),
                    lpMdv->iFontHeight );
                WriteSpoolBuf( lpdv, buf, ilen );

                if (ISVERTFONT(lpMdv->iTextFontId))
                    BeginVertWrite( lpdv );
                BeginString( lpdv, bReset );
                HexOutput(lpdv, pStrSav, (WORD)(pStr - pStrSav));
                EndString( lpdv );
                if (ISVERTFONT(lpMdv->iTextFontId))
                    EndVertWrite( lpdv );
                bReset = FALSE;
           }

            if ( pStr >= pStrMax )
                break;

            // switch font to output single byte characters

            for ( pStrSav = pStr; pStr < pStrMax; pStr++ ) {
                if (IsDBCSLeadByte(*pStr))
                    break;
            }

        }
        else {
            pStr = pStrMax;
        }

        if ((pStr - pStrSav) > 0) {

            // switch font to output single byte characters

            ilen = wsprintf( buf,
                "sfi %d\nfs %d 0\n",
                (lpMdv->iTextFontId),
                lpMdv->iFontHeight );
            WriteSpoolBuf( lpdv, buf, ilen );

            BeginString( lpdv, bReset );
            HexOutput(lpdv, pStrSav, (WORD)(pStr - pStrSav));
            EndString( lpdv );
            bReset = FALSE;
        }

        if ( pStr >= pStrMax )
            break;

        pStrSav = pStr;
    }

    lpMdv->cTextBuf = 0;
}

//-------------------------------------------------------------------
// CBFilerGraphics
// Action : Convert binary byte stream into ASCII hexadecimal
//      representation.  This is required for ART1, where no binary
//      transmission of image data is allowed.
//-------------------------------------------------------------------

WORD PASCAL CBFilterGraphics(
    LPDV lpdv, LPSTR lpBuf, WORD wLen )
{
    return (WORD)HexOutput(lpdv, lpBuf, wLen );
}

//-------------------------------------------------------------------
// OEMOutputCmd
// Action :
//-------------------------------------------------------------------

// #define CBID_CM_OCD_XM_ABS 1
// #define CBID_CM_OCD_XM_REL 2
// #define CBID_CM_OCD_YM_ABS 3
// #define CBID_CM_OCD_YM_REL 4
#define CBID_CM_OCD_XY_ABS 5
#define CBID_CM_OCD_XY_REL 6

#define CBID_RES_OCD_SELECTRES_240DPI 21
#define CBID_RES_OCD_SELECTRES_300DPI 22
#define CBID_RES_OCD_SELECTRES_400DPI 23
#define CBID_RES_OCD_SELECTRES_600DPI 24
#define CBID_RES_OCD_SENDBLOCK_ASCII 25
#define CBID_RES_OCD_SENDBLOCK 26

#define CBID_PC_OCD_BEGINDOC_ART 11
#define CBID_PC_OCD_BEGINDOC_ART3 12
#define CBID_PC_OCD_BEGINDOC_ART4 13
#define CBID_PC_OCD_BEGINPAGE 14
#define CBID_PC_OCD_ENDPAGE 15
#define CBID_PC_OCD_MULT_COPIES 16
#define CBID_PC_OCD_PORTRAIT 17
#define CBID_PC_OCD_LANDSCAPE 18

#define CBID_PSZ_OCD_SELECT_A3 30
#define CBID_PSZ_OCD_SELECT_A4 31
#define CBID_PSZ_OCD_SELECT_A5 32
#define CBID_PSZ_OCD_SELECT_B4 33
#define CBID_PSZ_OCD_SELECT_B5 34
#define CBID_PSZ_OCD_SELECT_PC 35
#define CBID_PSZ_OCD_SELECT_DL 36
#define CBID_PSZ_OCD_SELECT_LT 37
#define CBID_PSZ_OCD_SELECT_GG 38
#define CBID_PSZ_OCD_SELECT_LG 39
#define CBID_PSZ_OCD_SELECT_S1 40
#define CBID_PSZ_OCD_SELECT_S2 41
#define CBID_PSZ_OCD_SELECT_S3 42
#define CBID_PSZ_OCD_SELECT_S4 43

#define CBID_FS_OCD_BOLD_ON 51
#define CBID_FS_OCD_BOLD_OFF 52
#define CBID_FS_OCD_ITALIC_ON 53
#define CBID_FS_OCD_ITALIC_OFF 54
#define CBID_FS_OCD_SINGLE_BYTE 55
#define CBID_FS_OCD_DOUBLE_BYTE 56
#define CBID_FS_OCD_WHITE_TEXT_ON 57
#define CBID_FS_OCD_WHITE_TEXT_OFF 58

#define CBID_FONT_SELECT_OUTLINE 101

// @Aug/31/98 ->
#define	MAX_COPIES_VALUE		99
// @Aug/31/98 <-
VOID FAR CODESEG PASCAL
OEMOutputCmd(
    LPDV     lpdv,
    WORD     wCmdCbId,
    LPDWORD  lpdwParams )
{
    BYTE buf[512];
    INT ilen;
    LPMYMDV lpMdv;
    LONG x, y;
    BOOL bAscii;
    CHAR *pStr;

    lpMdv = lpdv->lpMdv;
    bAscii = FALSE;

    ilen = 0;

    switch( wCmdCbId ) {

    // PAPERSIZE

    case CBID_PSZ_OCD_SELECT_A3:
        LoadPaperInfo( lpMdv, "a3" );
        break;

    case CBID_PSZ_OCD_SELECT_A4:
        LoadPaperInfo( lpMdv, "a4" );
        break;

    case CBID_PSZ_OCD_SELECT_A5:
        LoadPaperInfo( lpMdv, "a5" );
        break;

    case CBID_PSZ_OCD_SELECT_B4:
        LoadPaperInfo( lpMdv, "b4" );
        break;

    case CBID_PSZ_OCD_SELECT_B5:
        LoadPaperInfo( lpMdv, "b5" );
        break;

    case CBID_PSZ_OCD_SELECT_PC:
        LoadPaperInfo( lpMdv, "pc" );
        break;

    case CBID_PSZ_OCD_SELECT_DL:
        LoadPaperInfo( lpMdv, "dl" );
        break;

    case CBID_PSZ_OCD_SELECT_LT:
        LoadPaperInfo( lpMdv, "lt" );
        break;

    case CBID_PSZ_OCD_SELECT_GG:
        LoadPaperInfo( lpMdv, "gg" );
        break;

    case CBID_PSZ_OCD_SELECT_LG:
        LoadPaperInfo( lpMdv, "lg" );
        break;

    case CBID_PSZ_OCD_SELECT_S1:
        LoadPaperInfo( lpMdv, "s1" );
        break;

    case CBID_PSZ_OCD_SELECT_S2:
        LoadPaperInfo( lpMdv, "s2" );
        break;

    case CBID_PSZ_OCD_SELECT_S3:
        LoadPaperInfo( lpMdv, "s3" );
        break;
    case CBID_PSZ_OCD_SELECT_S4:
        LoadPaperInfo( lpMdv, "s4" );
        break;

    case CBID_PC_OCD_PORTRAIT:
        lpMdv->chOrient = "p";
        break;

    case CBID_PC_OCD_LANDSCAPE:
        lpMdv->chOrient = "l";
        break;

    // PAGECONTROL

    case CBID_PC_OCD_BEGINDOC_ART:
        ilen = wsprintf( buf,
            "stj c\n" );
        break;

    case CBID_PC_OCD_BEGINDOC_ART3:
        ilen = wsprintf( buf,
            "srl %d %d\nstj c\n",
            lpMdv->sizlRes.cx,
            lpMdv->sizlRes.cy );
        break;

    case CBID_PC_OCD_BEGINDOC_ART4:
        ilen = wsprintf( buf,
            "\x1b%%-12345X@PL > ART \x0d\x0asrl %d %d\nccode j\nstj c\n",
            lpMdv->sizlRes.cx,
            lpMdv->sizlRes.cy );
        break;

    case CBID_PC_OCD_BEGINPAGE:

        // bold-simulation width: res / 50

        ilen = wsprintf( buf,
            "stp %s %s\nud i\nscl %d %d\nsb %d\n",
             lpMdv->chOrient,
             lpMdv->chSize,
             (DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT),
             (DEVICE_MASTER_UNIT / DRIVER_MASTER_UNIT),
             (lpMdv->sizlRes.cy * 2 / 100));

        lpMdv->ptlCur.x = 0;
        lpMdv->ptlCur.y = 0;
        break;

    case CBID_PC_OCD_ENDPAGE:

        FlushText( lpdv );
        ilen = wsprintf( buf,
            "ep %d\n",
            lpMdv->iCopies );

        lpMdv->cFontId = 0;

        break;

    case CBID_PC_OCD_MULT_COPIES:
// @Aug/31/98 ->
        if(MAX_COPIES_VALUE < *lpdwParams)
            lpMdv->iCopies = MAX_COPIES_VALUE;
        else if(1 > *lpdwParams)
            lpMdv->iCopies = 1;
        else
            lpMdv->iCopies = (WORD)*lpdwParams;
// @Aug/31/98 <-
        break;\

    case CBID_CM_OCD_XY_ABS:
/////
if (0) {
    char buf[128];
    wsprintf(buf, "\\%% xy_abs %d %d %%\\\n",
        *(LONG *)(lpdwParams),
        *(LONG *)(lpdwParams + 1)
    );
    WriteSpoolBuf( lpdv, buf, strlen(buf));
}
/////
        lpMdv->ptlCur.x = *(LONG *)(lpdwParams);
        lpMdv->ptlCur.y = *(LONG *)(lpdwParams + 1);
        FlushText( lpdv );
        SaveTextCur( lpdv );
        break;

    case CBID_CM_OCD_XY_REL:
/////
if (0) {
    char buf[128];
    wsprintf(buf, "\\%% xy_rel %d %d %%\\\n",
        *(LONG *)(lpdwParams),
        *(LONG *)(lpdwParams + 1)
    );
    WriteSpoolBuf( lpdv, buf, strlen(buf));
}
/////

        lpMdv->ptlCur.x += *(LONG *)(lpdwParams);
        lpMdv->ptlCur.y += *(LONG *)(lpdwParams + 1);
        FlushText( lpdv );
        SaveTextCur( lpdv );
        break;

    // RESOLUTION

    case CBID_RES_OCD_SELECTRES_240DPI:

        lpMdv->sizlRes.cx = 240;
        lpMdv->sizlRes.cy = 240;
        break;

    case CBID_RES_OCD_SELECTRES_300DPI:

        lpMdv->sizlRes.cx = 300;
        lpMdv->sizlRes.cy = 300;
        break;

    case CBID_RES_OCD_SELECTRES_400DPI:

        lpMdv->sizlRes.cx = 400;
        lpMdv->sizlRes.cy = 400;
        break;

    case CBID_RES_OCD_SELECTRES_600DPI:

        lpMdv->sizlRes.cx = 600;
        lpMdv->sizlRes.cy = 600;
        break;

    case CBID_RES_OCD_SENDBLOCK_ASCII:

        bAscii = TRUE;
        /* FALLTHROUGH */

    case CBID_RES_OCD_SENDBLOCK:

        //
        // image x y psx psy pcy pcy [string]
        //

        {
            LONG iPsx, iPsy, iPcx, iPcy;

            iPsx = DRIVER_MASTER_UNIT / lpMdv->sizlRes.cx;
            iPsy = DRIVER_MASTER_UNIT / lpMdv->sizlRes.cy;

            iPcx = lpdwParams[2] * 8;
            iPcy = lpdwParams[1];

            ilen = wsprintf( buf,
                "im %d %d %d %d %d %d %s",
                ( lpMdv->ptlOrg.x + lpMdv->ptlCur.x ),
                ( lpMdv->ptlOrg.y - lpMdv->ptlCur.y ),
                iPsx,
                iPsy,
                iPcx,
                (- iPcy),
                (bAscii ? "<" : "[")
            );
        }

        break;

    case CBID_FS_OCD_BOLD_ON:
    case CBID_FS_OCD_BOLD_OFF:
    case CBID_FS_OCD_ITALIC_ON:
    case CBID_FS_OCD_ITALIC_OFF:
    case CBID_FS_OCD_SINGLE_BYTE:
    case CBID_FS_OCD_DOUBLE_BYTE:
    case CBID_FS_OCD_WHITE_TEXT_ON:
    case CBID_FS_OCD_WHITE_TEXT_OFF:

        FlushText( lpdv );

        pStr = NULL;

        switch ( wCmdCbId ) {

        case CBID_FS_OCD_WHITE_TEXT_ON:
            pStr = "pm i c\n";
            break;

        case CBID_FS_OCD_WHITE_TEXT_OFF:
            pStr = "pm n o\n";
            break;

        case CBID_FS_OCD_BOLD_ON:
            pStr = "bb\n";
            lpMdv->fFontSim |= FONT_SIM_BOLD;
            break;

        case CBID_FS_OCD_BOLD_OFF:
//            pStr = "eb\n";
            pStr = "eb\net\n"; // DCR: Do we need "et\n"(Transform off)?
            lpMdv->fFontSim &= ~FONT_SIM_BOLD;
            lpMdv->fFontSim &= ~FONT_SIM_ITALIC; // DCR: Do we need "et\n"(Transform off)?
            break;

        case CBID_FS_OCD_ITALIC_ON:
            pStr = "trf x -18\nbt\n";
            lpMdv->fFontSim |= FONT_SIM_ITALIC;
            break;

        case CBID_FS_OCD_ITALIC_OFF:
//            pStr = "et\n";
            pStr = "eb\net\n"; // DCR: Do we need "et\n"(Transform off)?
            lpMdv->fFontSim &= ~FONT_SIM_ITALIC;
            lpMdv->fFontSim &= ~FONT_SIM_BOLD; // DCR: Do we need "et\n"(Transform off)?
            break;
        }

        if ( pStr ) {
            ilen = strlen( pStr );
            WriteSpoolBuf( lpdv, pStr, ilen );
        }
        ilen = 0;
        break;

    default:

        break;
    }

    if ( ilen > 0 ) {
        WriteSpoolBuf( lpdv, buf, ilen );
    }
}

BOOL FAR PASCAL
OEMGetFontCmd(
    LPDV lpdv,         // Pointer to PDEVICE structure
    WORD wCmdCbId,     // Command callback id#, defined by minidriver 
    LPFONTINFO lpfont, // Pointer to PFM data
    BOOL fSelect,      // TRUE for selection
    LPBYTE lpBuf,      // Buffer to put command into
    LPWORD lpwSize )   // Ptr to actual size of buffer
{
    INT iFontId;
    CHAR *pface;
    INT j;
    LPMYMDV lpMdv;
    BOOL bRet;

    lpMdv = lpdv->lpMdv;

    if ( !fSelect ) {
        return TRUE;
    }

    iFontId = 0;
    pface = (CHAR *)((BYTE *)lpfont + lpfont->dfFace);
    for ( j = 0; gFonts[ j ].pface; j++ ) {
        if ( !strcmp(pface, gFonts[ j ].pface ) ) {
            iFontId = gFonts[ j ].id;
            break;
        }
    }
    if ( !gFonts[ j ].pface )
        j = 0;

    if ( *lpwSize > 0 ) {
        *lpBuf = j;
        bRet = TRUE;
    }
    else {
        bRet = FALSE;
    }

    *lpwSize = 1;
    return bRet;
}

VOID FAR
OEMSendScalableFontCmd(
    LPDV lpdv,
    LPCD lpcd,
    LPFONTINFO lpFont )
{
    LPMYMDV lpMdv;
    BYTE *lpCmd;
    BYTE buf[512], *pbuf;
    INT ilen;
    LONG iFontHeight;
    LONG i, j;
    LONG iFontId;


    if (!lpcd || !lpFont)
       return;

    lpMdv = lpdv->lpMdv;
    lpCmd = (BYTE *)lpcd + sizeof (CD);
    pbuf = buf;

    j = *lpCmd;
    iFontId = gFonts[ j ].id;
    for ( i = 0; i < lpMdv->cFontId; i++ ) {
        if ( iFontId == lpMdv->aFontId[ i ] )
            break;
    }
    if ( i >= lpMdv->cFontId ) {

        // not declared yet within this page, so let us declare
        // it here.

        lpMdv->aFontId[ lpMdv->cFontId++ ] = (BYTE)iFontId;
        if ( gFonts[ j ].fid2 ) {
            ilen = wsprintf( pbuf,
                "std\n%s%sed\n",
                gFonts[ j ].fid1,
                gFonts[ j ].fid2 );
            pbuf += ilen;
        }
        else {
            ilen = wsprintf( pbuf,
                "std\n%sed\n",
                gFonts[ j ].fid1 );
            pbuf += ilen;
        }
    }

    lpMdv->iFontId = (WORD)iFontId;
    lpMdv->iFontHeight = (WORD)(lpFont->dfPixHeight
        * DRIVER_MASTER_UNIT / lpMdv->sizlRes.cy);

    if ( pbuf > buf ) {
        WriteSpoolBuf( lpdv, buf, (INT)(pbuf - buf) );
    }
    // Need set iFontId to iTextFontId
    SaveTextCur( lpdv );
    
}


/***************************************************************************
    Function Name : OEMOutputChar

    Parameters    : LPDV	lpdv		Private Device Structure
                    LPSTR	lpstr		Print String
                    WORD	len		Length
                    WORD	rcID		Font ID

    Note          : 

***************************************************************************/

VOID FAR
OEMOutputChar(
    LPDV lpdv,
    LPSTR lpStr,
    WORD wLen,
    WORD rcID )
{
    LPMYMDV lpMdv;
    INT i;
    BYTE *pStr;

    lpMdv = lpdv->lpMdv;
    pStr = (BYTE *)lpStr;

    for ( i = 0; i < wLen; i++ ) {
        if ( lpMdv->cTextBuf >= sizeof ( lpMdv->ajTextBuf ))
            FlushText( lpdv );
        lpMdv->ajTextBuf[ lpMdv->cTextBuf++ ] = *pStr++;
    }
}


#ifndef WINNT
//-------------------------------------------------------------------
// Function: Enable()
// Action  : call UniEnable and setup Mdv
//-------------------------------------------------------------------

SHORT CALLBACK Enable(
LPDV lpdv,
WORD style,
PSTR lpModel,
LPSTR lpPort,
LPDM lpStuff )
{
    LPMYMDV lpMdv;
    INT iRet;
    CUSTOMDATA cd;

    cd.cbSize = sizeof(CUSTOMDATA);
    cd.hMd = GetModuleHandle((LPSTR)rgchModuleName);
    cd.fnOEMDump = NULL;
    cd.fnOEMOutputChar = OEMOutputChar;

    iRet = UniEnable( lpdv, style, lpModel, lpPort, lpStuff, &cd );

    if (style == 0x0000 && iRet != 0) {

        if (!(lpMdv = GlobalAllocPtr(GHND, sizeof(MYMDV)))) {

            lpdv->fMdv = FALSE;
            UniDisable( lpdv );
            return FALSE;
        }

        lpdv->lpMdv = lpMdv;

        // default values

        memset( lpMdv, 0, sizeof (MYMDV) );
        lpMdv->iCopies = 1;

        // mark we have initialized it

        lpdv->fMdv = TRUE;
    }

    return iRet;
}

//-------------------------------------------------------------------
// Function: Disable()
// Action  : free Mdv and call Mdv
//-------------------------------------------------------------------
void FAR PASCAL Disable(lpdv)
LPDV lpdv;
{
    if ( lpdv->fMdv ) {
        GlobalFreePtr ( lpdv->lpMdv );
        lpdv->fMdv = FALSE;
    }

    UniDisable( lpdv );
}

#endif // WINNT

#ifdef WINNT
/*************************** Function Header *******************************
 *  MiniDrvEnablePDEV
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *
 ***************************************************************************/
BOOL
MiniDrvEnablePDEV(
LPDV      lpdv,
ULONG    *pdevcaps)
{
    LPMYMDV lpMdv;


    if (!(lpMdv = UniDrvAllocMem(sizeof(MYMDV)))) {

        lpdv->fMdv = FALSE;
        return FALSE;
    }

    lpdv->lpMdv = lpMdv;

    // default values

    memset( lpMdv, 0, sizeof (MYMDV) );
    lpMdv->iCopies = 1;

    // mark we have initialized it

    lpdv->fMdv = TRUE;


    return TRUE;


}
/*************************** Function Header *******************************
 *  MiniDrvDisablePDEV
 *
 * HISTORY:
 *  30 Apl 1996    -by-    Sueya Sugihara    [sueyas]
 *      Created it,  from NT/DDI spec.
 *
 ***************************************************************************/
VOID
MiniDrvDisablePDEV(
LPDV lpdv)
{

    if ( lpdv->fMdv ) {
        UniDrvFreeMem( lpdv->lpMdv );
        lpdv->fMdv = FALSE;
    }


}
BOOL
MyIsDBCSLeadByte(
BYTE bByte)
{
    if(   ((bByte >= 0x81) && (bByte <= 0x9F)) ||
          ((bByte >= 0xE0) && (bByte <= 0xFC)) )
        return TRUE;

    return FALSE;
}


DRVFN
MiniDrvFnTab[] =
{
    {  INDEX_MiniDrvEnablePDEV,       (PFN)MiniDrvEnablePDEV  },
    {  INDEX_MiniDrvDisablePDEV,      (PFN)MiniDrvDisablePDEV  },
    {  INDEX_OEMGetFontCmd,           (PFN)OEMGetFontCmd  },
    {  INDEX_OEMOutputCmd,            (PFN)OEMOutputCmd  },
    {  INDEX_OEMWriteSpoolBuf,        (PFN)CBFilterGraphics  },
    {  INDEX_OEMSendScalableFontCmd,  (PFN)OEMSendScalableFontCmd  },
    {  INDEX_OEMOutputChar,           (PFN)OEMOutputChar  }
};

BOOL
MiniDrvEnableDriver(
    MINIDRVENABLEDATA  *pEnableData
    )
{
    if (pEnableData == NULL)
        return FALSE;

    if (pEnableData->cbSize == 0)
    {
        pEnableData->cbSize = sizeof (MINIDRVENABLEDATA);
        return TRUE;
    }

    if (pEnableData->cbSize < sizeof (MINIDRVENABLEDATA)
            || HIBYTE(pEnableData->DriverVersion)
            < HIBYTE(MDI_DRIVER_VERSION))
    {
        // Wrong size and/or mismatched version
        return FALSE;
    }

    // Load callbacks provided by the Unidriver

    if (!bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvWriteSpoolBuf, (PFN *) &WriteSpoolBuf)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvAllocMem, (PFN *) &UniDrvAllocMem)
        || !bLoadUniDrvCallBack(pEnableData,
            INDEX_UniDrvFreeMem, (PFN *) &UniDrvFreeMem))
    {
        return FALSE;
    }

    pEnableData->cMiniDrvFn
        = sizeof (MiniDrvFnTab) / sizeof(MiniDrvFnTab[0]);
    pEnableData->pMiniDrvFn = MiniDrvFnTab;

    return TRUE;
}

#endif //WINNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxmejres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <minidrv.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxmejres\name.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

CONST CHAR pstrGetInfo[] = "GetInfo";
CONST CHAR pstrDevMode[] = "DevMode";
CONST CHAR pstrPublishDriverInterface[] = "PublishDriverInterface";
CONST CHAR pstrGetImplementedMethod[] = "GetImplementedMethod";
CONST CHAR pstrCommonUIProp[] = "PropCommonUIProp";
CONST CHAR pstrDocumentPropertySheets[] = "DocumentPropertySheets";
CONST CHAR pstrDevicePropertySheets[] = "SheetsDevicePropertySheets";
CONST CHAR pstrDevQueryPrintEx[] = "DevQueryPrintEx";
CONST CHAR pstrDeviceCapabilities[] = "DeviceCapabilities";
CONST CHAR pstrUpgradePrinter[] = "UpgradePrinter";
CONST CHAR pstrPrinterEvent[] = "PrinterEvent";
CONST CHAR pstrDriverEvent[] = "DriverEvent";
CONST CHAR pstrQueryColorProfile[] = "QueryColorProfile";
CONST CHAR pstrUpgradeRegistry[] = "UpgradeRegistry";
CONST CHAR pstrFontInstallerDlgProc[] = "FontInstallerDlgProc";
CONST CHAR pstrGetDriverSetting[] = "GetDriverSetting";
CONST CHAR pstrUpgradeRegistrySetting[] = "UpgradeRegistrySetting";
CONST CHAR pstrUpdateUISetting[] = "UpdateUISetting";
CONST CHAR pstrEnableDriver[] = "EnableDriver";
CONST CHAR pstrDisableDriver[] = "DiableDriver";
CONST CHAR pstrEnablePDEV[] = "EnablePDEV";
CONST CHAR pstrDisablePDEV[] = "DisablePDEV";
CONST CHAR pstrResetPDEV[] = "ResetPDEV";
CONST CHAR pstrCommand[] = "Command";
CONST CHAR pstrDrvGetDriverSetting[] = "DrvGetDriverSetting";
CONST CHAR pstrDrvWriteSpoolBuf[] = "DrvWriteSpoolBuf";
CONST CHAR pstrDriverDMS[] = "DriverDMS";
CONST CHAR pstrCommandCallback[] = "CommandCallback";
CONST CHAR pstrImageProcessing[] = "ImageProcessing";
CONST CHAR pstrFilterGraphics[] = "FilterGraphics";
CONST CHAR pstrCompression[] = "Compression";
CONST CHAR pstrHalftonePattern[] = "HalftonePattern";
CONST CHAR pstrMemoryUsage[] = "MemoryUsage";
CONST CHAR pstrDownloadFontHeader[] = "DownloadFontHeader";
CONST CHAR pstrDownloadCharGlyph[] = "DownloadCharGlyph";
CONST CHAR pstrTTDownloadMethod[] = "TTDownloadMethod";
CONST CHAR pstrOutputCharStr[] = "OutputCharStr";
CONST CHAR pstrSendFontCmd[] = "SendFontCmd";
CONST CHAR pstrTextOutAsBitmap[] = "TextOutAsBitmap";
CONST CHAR pstrGetDDIHooks[] = "GetDDIHooks";
CONST CHAR pstrTTYGetInfo[] = "TTYGetInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxmejres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "name.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

#if 0
    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    // if (OEMResetPDEV(pdevobjOld, pdevobjNew))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

#if 0
    OEMDisablePDEV(pdevobj);
    return S_OK;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    
    LONG lReturn;
    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));
    VERBOSE((DLLTEXT("        Function:%s:"),pMethodName));

    lReturn = FALSE;
    if (pMethodName == NULL)
    {
    }
    else
    {
        switch (*pMethodName)
        {

            case (WCHAR)'C':
                if (!strcmp(pstrCommandCallback, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrCompression, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'D':
                if (!strcmp(pstrDisableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDisablePDEV, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDriverDMS, pMethodName))
                    lReturn = TRUE;

                if (!strcmp(pstrDevMode, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadFontHeader, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrDownloadCharGlyph, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'E':
                if (!strcmp(pstrEnableDriver, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrEnablePDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'H':
                if (!strcmp(pstrHalftonePattern, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'I':
                if (!strcmp(pstrImageProcessing, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'M':
                if (!strcmp(pstrMemoryUsage, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'O':
                if (!strcmp(pstrOutputCharStr, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'R':
                if (!strcmp(pstrResetPDEV, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'S':
                if (!strcmp(pstrSendFontCmd, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'T':
                if (!strcmp(pstrTextOutAsBitmap, pMethodName))
                    lReturn = TRUE;
                else
                if (!strcmp(pstrTTDownloadMethod, pMethodName))
                    lReturn = TRUE;
                else if (!strcmp(pstrTTYGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        VERBOSE(("Supported\n"));
        return S_OK;
    }
    else
    {
        VERBOSE(("NOT supported\n"));
        return S_FALSE;
    }
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

    if (OEMDevMode(dwMode, pOemDMParam))
        return S_OK;
    else
        return S_FALSE;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    // if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
    //                     dwCallbackID, pIPParams))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));

    if(OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

#if 0
    *pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);
    if(*pdwResult)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

#if 0
    *pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);
    if(*pdwResult)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));

#if 0
    *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
    if(*pdwResult <= TTDOWNLOAD_TTOUTLINE)
        return S_OK;
    else
        return S_FALSE;
#else
    return E_NOTIMPL;
#endif
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    return S_OK;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    return S_OK;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //VERBOSE((DLLTEXT("Class factory:\t\tCreate component.")));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}
#endif

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxmejres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

#if 0
static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
#else // 0
extern BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra);
extern BOOL BMergeOEMExtraData(POEM_EXTRADATA pdmIn, POEM_EXTRADATA pdmOut);
#endif // 0
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    DBGPRINT(DBG_WARNING, (DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        DBGPRINT(DBG_WARNING, (ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DBGPRINT(DBG_WARNING, (ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    DBGPRINT(DBG_WARNING, (DLLTEXT("OEMDevMode(%s) entry.\r\n"), OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        DBGPRINT(DBG_WARNING, (ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\r\n")));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEM_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        DBGPRINT(DBG_WARNING, (ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEM_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEM_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEM_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            DBGPRINT(DBG_WARNING, ("OEMUD OEMDevMode():  not valid OEM Extra Data.\r\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


#if 0
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
#if 0
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));
#endif

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
#if 0
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }
#endif

    return TRUE;
}
#endif // 0


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\r\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\r\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\r\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        DBGPRINT(DBG_WARNING, ("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\r\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        DBGPRINT(DBG_WARNING, ("\r\n\tOEM_DEVMODEPARAM dump:\r\n\r\n"));

        DBGPRINT(DBG_WARNING, ("\tcbSize = %d.\r\n", pOEMDevModeParam->cbSize));
        DBGPRINT(DBG_WARNING, ("\thPrinter = %#lx.\r\n", pOEMDevModeParam->hPrinter));
        DBGPRINT(DBG_WARNING, ("\thModule = %#lx.\r\n", pOEMDevModeParam->hModule));
        DBGPRINT(DBG_WARNING, ("\tpPublicDMIn = %#lx.\r\n", pOEMDevModeParam->pPublicDMIn));
        DBGPRINT(DBG_WARNING, ("\tpPublicDMOut = %#lx.\r\n", pOEMDevModeParam->pPublicDMOut));
        DBGPRINT(DBG_WARNING, ("\tpOEMDMIn = %#lx.\r\n", pOEMDevModeParam->pOEMDMIn));
        DBGPRINT(DBG_WARNING, ("\tpOEMDMOut = %#lx.\r\n", pOEMDevModeParam->pOEMDMOut));
        DBGPRINT(DBG_WARNING, ("\tcbBufSize = %d.\r\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxmejres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\fx\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=fxmejres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),fxmejres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\fxmejres.rc \
    $(SRCDIR)\common.c \
    $(SRCDIR)\fxmejres.c

MISCFILES=\
    $(SRCDIR)\fxmejres.ini \
    $(GPDDIR)\fx413mej.gpd \
    $(GPDDIR)\fxab320j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxmejres\fxmejres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEM_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEM_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    // Initialize private data
    pOEMExtra->wCopyCount = 1;
    pOEMExtra->wTray = CMD_ID_TRAY_1;
    pOEMExtra->wPaper = CMD_ID_PAPER_A4;
    pOEMExtra->wRes = 400;
    pOEMExtra->fVert = FALSE;
    pOEMExtra->wFont = 0;
    pOEMExtra->wBlockHeight = 0;
    pOEMExtra->wBlockWidth = 0;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEM_EXTRADATA pdmIn,
    POEM_EXTRADATA pdmOut
    )
{
    if(pdmIn) {
        //
        // copy over the private fields, if they are valid
        //
        // Copy private data
        pdmOut->wCopyCount = pdmIn->wCopyCount;
        pdmOut->wTray = pdmIn->wTray;
        pdmOut->wPaper = pdmIn->wPaper;
        pdmOut->wRes = pdmIn->wRes;
        pdmOut->fVert = pdmIn->fVert;
        pdmOut->wFont = pdmIn->wFont;
        pdmOut->wBlockHeight = pdmIn->wBlockHeight;
        pdmOut->wBlockWidth = pdmIn->wBlockWidth;
    }
    return TRUE;
}

// #######

#include <stdio.h>
#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define PARAM(p,n) \
    (*((p)+(n)))

BYTE    ESC_VERT_ON[]  = "\x1B\x74";
BYTE    ESC_VERT_OFF[] = "\x1B\x4B";
BYTE    ESC_FONT_SELECT_MINCHO[] = "\x1B\x40\x43\x30";
BYTE    ESC_FONT_SELECT_GOTHIC[] = "\x1B\x40\x43\x31";
BYTE    ESC_FONT_PITCH[] = "\x1B\x2D\x00";
BYTE    ESC_FONT_SIZE[] = "\x1B\x75\x33\x00\x00\x00\x00";
BYTE    ESC_SET_COPYCOUNT[] = "\x1B\x3C\x31\x00\x00";
BYTE    ESC_SET_RES240[] = "\x1B\x5B\x31\x00\x06\x3D\x33\x30\x32\x34\x30";
BYTE    ESC_SET_RES400[] = "\x1B\x5B\x31\x00\x06\x3D\x33\x30\x34\x30\x30";
BYTE    ESC_XY_ABS[] = "\x1B\x5C\x39\x00\x00\x00\x00";
BYTE    ESC_XY_REL[] = "\x1B\x5C\x30\x00\x00\x00\x00";
BYTE    ESC_SEND_BLOCK[] = "\x1B\x77\x00\x00\x00\x00";


BOOL APIENTRY OEMFilterGraphics(
PDEVOBJ    pdevobj,  // Points to private data required by the Unidriver.dll
PBYTE      pBuf,     // points to buffer of graphics data
DWORD      dwLen)    // length of buffer in bytes
{
    POEM_EXTRADATA      pOEM;
    WORD                wSent;
    WORD                wlen;

    pOEM = (POEM_EXTRADATA)pdevobj->pOEMDM;
    wSent = (WORD)dwLen;

    while(wSent)
    {
        if(wSent > MAXBUFLEN)
            wlen = MAXBUFLEN;
        else
            wlen = wSent;

        WRITESPOOLBUF(pdevobj, pBuf, wlen);

        wSent -= wlen;
        pBuf += MAXBUFLEN;
    }
    return TRUE;
}

//---------------------------*OEMSendFontCmd*----------------------------------
// Action:  send Pages-style font selection command.
//-----------------------------------------------------------------------------
VOID APIENTRY OEMSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,     // offset to the command heap
    PFINVOCATION pFInv)
{
    POEM_EXTRADATA      pOEM;
    PGETINFO_STDVAR     pSV;
    DWORD               dwStdVariable[2 + 2 * 2];
    BYTE                pbCmd[256];
    WORD                wCmdLen = 0;
    WORD                wFontWidth;
    WORD                wFontHeight;
    WORD                wScale;

    if(!pUFObj || !pFInv)
    {
        ERR(("Parameter is invalid.\n"));
        return;
    }

    pOEM = (POEM_EXTRADATA)pdevobj->pOEMDM;

    // Get font size from STDVARIABLE
    pSV = (PGETINFO_STDVAR)dwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (2 - 1);
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }
    wFontHeight = (WORD)pSV->StdVar[0].lStdVariable;
    wFontWidth = (WORD)(pSV->StdVar[1].lStdVariable * 2);

    // Scaling to current res unit
    wScale = (WORD)(1200 / (pOEM->wRes == CMD_ID_RES240 ? 240 : 400));
    wFontHeight /= wScale;
    wFontWidth  /= wScale;

    // Build Command for Scalable font
    switch(pUFObj->ulFontID)
    {
        case FONT_ID_MIN:
            if(pOEM->fVert)
            {
                wCmdLen = (WORD)wsprintf((PBYTE)&pbCmd, ESC_VERT_OFF);
                pOEM->fVert = FALSE;
            }
            if(pOEM->wFont != FONT_MINCHO)
            {
                wCmdLen += (WORD)wsprintf((PBYTE)&pbCmd[wCmdLen], ESC_FONT_SELECT_MINCHO);
                pOEM->wFont = FONT_MINCHO;
            }
            break;

        case FONT_ID_GOT:       // These fonts are for horizontal
            if(pOEM->fVert)
            {
                wCmdLen = (WORD)wsprintf((PBYTE)&pbCmd, ESC_VERT_OFF);
                pOEM->fVert = FALSE;
            }
            if(pOEM->wFont != FONT_GOTHIC)
            {
                wCmdLen += (WORD)wsprintf((PBYTE)&pbCmd[wCmdLen],
                                                    ESC_FONT_SELECT_MINCHO);
                pOEM->wFont = FONT_GOTHIC;
            }
            break;

        case FONT_ID_MIN_V:
            if(!pOEM->fVert)
            {
                wCmdLen = (WORD)wsprintf((PBYTE)&pbCmd, ESC_VERT_ON);
                pOEM->fVert = TRUE;
            }
            if(pOEM->wFont != FONT_MINCHO)
            {
                wCmdLen += (WORD)wsprintf((PBYTE)&pbCmd[wCmdLen],
                                                    ESC_FONT_SELECT_MINCHO);
                pOEM->wFont = FONT_MINCHO;
            }
            break;

        case FONT_ID_GOT_V:     // These fonts are for vertical
            if(!pOEM->fVert)
            {
                wCmdLen = (WORD)wsprintf((PBYTE)&pbCmd, ESC_VERT_ON);
                pOEM->fVert = TRUE;
            }
            if(pOEM->wFont != FONT_GOTHIC)
            {
                wCmdLen += (WORD)wsprintf((PBYTE)&pbCmd[wCmdLen],
                                                    ESC_FONT_SELECT_MINCHO);
                pOEM->wFont = FONT_GOTHIC;
            }
            break;

        default:
            ERR(("Device Font ID is invalid.\n"));
            return;
    }

    // Font pitch command
    ESC_FONT_PITCH[2] = (BYTE)wFontWidth;
    wCmdLen += (WORD)wsprintf((PBYTE)&pbCmd[wCmdLen], ESC_FONT_PITCH);

    // Font size command
    ESC_FONT_SIZE[3] = HIBYTE(wFontWidth);
    ESC_FONT_SIZE[4] = LOBYTE(wFontWidth);
    ESC_FONT_SIZE[5] = HIBYTE(wFontHeight);
    ESC_FONT_SIZE[6] = LOBYTE(wFontHeight);
    memcpy((PBYTE)&pbCmd[wCmdLen], ESC_FONT_SIZE, 7);
    wCmdLen += 7;

    // Send build command for spooler
    WRITESPOOLBUF(pdevobj, (PBYTE)&pbCmd, wCmdLen);
    return;
}

VOID APIENTRY OEMOutputCharStr(
PDEVOBJ     pdevobj,
PUNIFONTOBJ pUFObj,
DWORD       dwType,
DWORD       dwCount,
PVOID       pGlyph)
{
    POEM_EXTRADATA      pOEM;
    GETINFO_GLYPHSTRING GStr;
    PBYTE               tempBuf;
    PTRANSDATA          pTrans;
    DWORD               i;
    BYTE                pbStr[MAXBUFLEN];
    WORD                wStrLen;

    BYTE *pTemp;
    WORD wLen;

    VERBOSE(("OEMOutputCharStr() entry.\n"));
    ASSERT(VALID_PDEVOBJ(pdevobj));

    if(!pUFObj || !pGlyph)
    {
        ERR(("Parameter is invalid.\n"));
        return ;
    }

    pOEM = (POEM_EXTRADATA)pdevobj->pOEMDM;

    GStr.dwSize     = sizeof(GETINFO_GLYPHSTRING);
    GStr.dwCount    = dwCount;
    GStr.dwTypeIn   = TYPE_GLYPHHANDLE;
    GStr.pGlyphIn   = pGlyph;
    GStr.dwTypeOut  = TYPE_TRANSDATA;
    GStr.pGlyphOut  = NULL;
    GStr.dwGlyphOutSize = 0;

     /* Get TRANSDATA buffer size */
    if (FALSE != pUFObj->pfnGetInfo(pUFObj,
            UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)
        || 0 == GStr.dwGlyphOutSize )
    {
        ERR(("get TRANSDATA buffer size error\n"));
        return ;
    }

    /* Alloc TRANSDATA buffer size */
    if(!(tempBuf = (PBYTE)MemAllocZ(GStr.dwGlyphOutSize)))
    {
        ERR(("Memory alloc failed.\n"));
        return ;
    }

    /* Get actual TRANSDATA */
    GStr.pGlyphOut = tempBuf;
    if (FALSE == pUFObj->pfnGetInfo(pUFObj,
        UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
    {
        ERR(("GetInfo failed.\n"));
        return;
    }

    pTrans = GStr.pGlyphOut;

    for(i = 0, wStrLen = 0; i < dwCount; i++, pTrans++)
    {
        switch(pTrans->ubType & MTYPE_FORMAT_MASK)
        {
            case MTYPE_DIRECT:      // SBCS character
                pbStr[wStrLen++] = pTrans->uCode.ubCode;
                break;

            case MTYPE_PAIRED:      // DBCS character
                pbStr[wStrLen++] = pTrans->uCode.ubPairs[0];
                pbStr[wStrLen++] = pTrans->uCode.ubPairs[1];
                break;
            case MTYPE_COMPOSE:
                pTemp = (BYTE *)(GStr.pGlyphOut) + pTrans->uCode.sCode;

                // first two bytes are the length of the string
                wLen = *pTemp + (*(pTemp + 1) << 8);
                pTemp += 2;

                while (wLen--)
                {
                    pbStr[ wStrLen++ ] = *pTemp++;
                }
        }
    }

    if(wStrLen)
        WRITESPOOLBUF(pdevobj, pbStr, wStrLen);

    MemFree(tempBuf);
    return ;
}

/*****************************************************************************/
/*                                                                           */
/*   INT APIENTRY OEMCommandCallback(                                        */
/*                PDEVOBJ pdevobj                                            */
/*                DWORD   dwCmdCbId                                          */
/*                DWORD   dwCount                                            */
/*                PDWORD  pdwParams                                          */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbId,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams)  // points to values of command params
{
    POEM_EXTRADATA  pOEM;
    WORD            wCmdLen;
    BYTE            pbCmd[MAXBUFLEN];

    VERBOSE(("OEMCommandCallback() entry.\n"));
    ASSERT(VALID_PDEVOBJ(pdevobj));

    pOEM = (POEM_EXTRADATA)pdevobj->pOEMDM;
    wCmdLen = 0;

    switch(dwCmdCbId)
    {
        case CMD_ID_TRAY_1:
        case CMD_ID_TRAY_2:
        case CMD_ID_TRAY_MANUAL:
        case CMD_ID_TRAY_AUTO:
            pOEM->wTray = (WORD)dwCmdCbId;
            break;

        case CMD_ID_PAPER_A3:
        case CMD_ID_PAPER_B4:
        case CMD_ID_PAPER_A4:
        case CMD_ID_PAPER_B5:
        case CMD_ID_PAPER_A5:
        case CMD_ID_PAPER_HAGAKI:
        case CMD_ID_PAPER_LETTER:
        case CMD_ID_PAPER_LEGAL:
            pOEM->wPaper = (WORD)dwCmdCbId;
            SetTrayPaper(pdevobj);
            return 0;

        case CMD_ID_COPYCOUNT:
        {
            WORD    wCopies;

            if(!pdwParams)
                return 0;

            if(*pdwParams < 1)
                wCopies = 1;
            else if(*pdwParams > 99)
                wCopies = 99;
            else
                wCopies = (WORD)*pdwParams;

            ESC_SET_COPYCOUNT[3] = ((BYTE)wCopies / 10) + 0x30;
            ESC_SET_COPYCOUNT[4] = ((BYTE)wCopies % 10) + 0x30;
            memcpy((PBYTE)&pbCmd[wCmdLen], ESC_SET_COPYCOUNT, 5);
            wCmdLen += 5;
            break;
        }

        case CMD_ID_RES240:
        case CMD_ID_RES400:
            pOEM->wRes = (WORD)dwCmdCbId;
            if(pOEM->wRes == CMD_ID_RES240)
            {
                memcpy((PBYTE)&pbCmd[wCmdLen], ESC_SET_RES240, 11);
                wCmdLen += 11;
            } else {
                memcpy((PBYTE)&pbCmd[wCmdLen], ESC_SET_RES400, 11);
                wCmdLen += 11;
            }
            memcpy((PBYTE)&pbCmd[wCmdLen], "\x1B\x5C\x35\x38", 4);
            wCmdLen += 4;
            memcpy((PBYTE)&pbCmd[wCmdLen],
                                        "\x1B\x5B\x31\x00\x03\x46\x34\x00", 8);
            wCmdLen += 8;
            memcpy((PBYTE)&pbCmd[wCmdLen],
                                        "\x1B\x5B\x31\x00\x03\x46\x35\x09", 8);
            wCmdLen += 8;
            memcpy((PBYTE)&pbCmd[wCmdLen],
                                        "\x1B\x5B\x31\x00\x03\x46\x31\x03", 8);
            wCmdLen += 8;
            break;

        case CMD_ID_BEGIN_PAGE:
            pOEM->wFont = 0;

            ESC_XY_ABS[3] = 0x00 | 0x80;
            ESC_XY_ABS[4] = 0x00;
            ESC_XY_ABS[5] = 0x00;
            ESC_XY_ABS[6] = 0x00;

            wCmdLen += (WORD)wsprintf((PBYTE)&pbCmd[wCmdLen], ESC_VERT_OFF);

            memcpy(&pbCmd[wCmdLen], ESC_XY_ABS, 7);
            wCmdLen += 7;
            break;

        case CMD_ID_XM_ABS:
        case CMD_ID_YM_ABS:
        {
            WORD    wX, wY;

            wX = (WORD)PARAM(pdwParams, 0);
            wY = (WORD)PARAM(pdwParams, 1);

            wX /= (pOEM->wRes == CMD_ID_RES240 ? 5 : 3);
            wY /= (pOEM->wRes == CMD_ID_RES240 ? 5 : 3);

            ESC_XY_ABS[3] = HIBYTE(wX) | 0x80;
            ESC_XY_ABS[4] = LOBYTE(wX);
            ESC_XY_ABS[5] = HIBYTE(wY);
            ESC_XY_ABS[6] = LOBYTE(wY);
            WRITESPOOLBUF(pdevobj, ESC_XY_ABS, 7);
            return (INT)(dwCmdCbId == CMD_ID_XM_ABS ? wX : wY);
        }

        case CMD_ID_X_REL_RIGHT:
        case CMD_ID_X_REL_LEFT:
        case CMD_ID_Y_REL_DOWN:
        case CMD_ID_Y_REL_UP:
        {
            WORD    wX, wY;

            wX = (WORD)PARAM(pdwParams, 0);
            wY = (WORD)PARAM(pdwParams, 1);

            wX /= (pOEM->wRes == CMD_ID_RES240 ? 5 : 3);
            wY /= (pOEM->wRes == CMD_ID_RES240 ? 5 : 3);

            ESC_XY_REL[3] = HIBYTE(wX) | 0x80;
            ESC_XY_REL[4] = LOBYTE(wX);
            ESC_XY_REL[5] = HIBYTE(wY);
            ESC_XY_REL[6] = LOBYTE(wY);
            WRITESPOOLBUF(pdevobj, ESC_XY_REL, 7);
            return (INT)((dwCmdCbId == CMD_ID_X_REL_RIGHT
                             || dwCmdCbId == CMD_ID_X_REL_LEFT) ? wX : wY);
        }

        case CMD_ID_SEND_BLOCK240:
        case CMD_ID_SEND_BLOCK400:
            if(pOEM->fVert)
            {
                wCmdLen += (WORD)wsprintf((PBYTE)&pbCmd[wCmdLen], ESC_VERT_OFF);
                pOEM->fVert = FALSE;
            }

            pOEM->wBlockHeight = (WORD)PARAM(pdwParams, 1);
            pOEM->wBlockWidth  = (WORD)(PARAM(pdwParams, 2) * 8);

            ESC_SEND_BLOCK[2] = HIBYTE(pOEM->wBlockWidth);
            ESC_SEND_BLOCK[3] = LOBYTE(pOEM->wBlockWidth);
            ESC_SEND_BLOCK[4] = HIBYTE(pOEM->wBlockHeight);
            ESC_SEND_BLOCK[5] = LOBYTE(pOEM->wBlockHeight);
            memcpy((PBYTE)&pbCmd[wCmdLen], ESC_SEND_BLOCK, 6);
            wCmdLen += 6;
            break;

        case CMD_ID_END_BLOCK:
        {
            WORD    wHeight;

            if(!pOEM->wBlockHeight)
                break;

            wHeight = pOEM->wBlockHeight - 1;
            if(wHeight)
            {
                wHeight *= (pOEM->wRes == CMD_ID_RES240 ? 5 : 3);

                ESC_XY_REL[3] = 0x00 | 0x80;
                ESC_XY_REL[4] = 0x00;
                ESC_XY_REL[5] = HIBYTE(wHeight);
                ESC_XY_REL[6] = LOBYTE(wHeight);
                memcpy(&pbCmd[wCmdLen], ESC_XY_REL, 7);
                wCmdLen += 7;
            }
            break;
        }

        default:
            break;
    }

    if(wCmdLen)
        WRITESPOOLBUF(pdevobj, (PBYTE)&pbCmd, wCmdLen);

    return 0;
}

/*
 *  Set tray and paper
 */
VOID SetTrayPaper(PDEVOBJ pdevobj)
{
    POEM_EXTRADATA  pOEM;
    WORD            wLen;
    BYTE            pbCmdBuf[MAXBUFLEN];

    pOEM = (POEM_EXTRADATA)pdevobj->pOEMDM;
    wLen = 0;

    switch (pOEM->wTray)
    {
        case CMD_ID_TRAY_1:
            memcpy((PBYTE)&pbCmdBuf[wLen], "\x1B\x40\x29\x30", 4);
            wLen += 4;
            break;

        case CMD_ID_TRAY_2:
            memcpy((PBYTE)&pbCmdBuf[wLen], "\x1B\x40\x29\x31", 4);
            wLen += 4;
            break;

        case CMD_ID_TRAY_MANUAL:
            memcpy((PBYTE)&pbCmdBuf[wLen], "\x1B\x40\x29\x32", 4);
            wLen += 4;

            switch (pOEM->wPaper)
            {
                case CMD_ID_PAPER_A3:
                    memcpy((PBYTE)&pbCmdBuf[wLen],
                                        "\x1B\x5B\x31\x00\x03\x40\x31\x30", 8);
                    wLen += 8;
                    break;

                case CMD_ID_PAPER_B4:
                    memcpy((PBYTE)&pbCmdBuf[wLen],
                                        "\x1B\x5B\x31\x00\x03\x40\x31\x31", 8);
                    wLen += 8;
                    break;

                case CMD_ID_PAPER_A4:
                    memcpy((PBYTE)&pbCmdBuf[wLen],
                                        "\x1B\x5B\x31\x00\x03\x40\x31\x33", 8);
                    wLen += 8;
                    break;

                case CMD_ID_PAPER_B5:
                    memcpy((PBYTE)&pbCmdBuf[wLen],
                                        "\x1B\x5B\x31\x00\x03\x40\x31\x34", 8);
                    wLen += 8;
                    break;

                case CMD_ID_PAPER_A5:
                    memcpy((PBYTE)&pbCmdBuf[wLen],
                                        "\x1B\x5B\x31\x00\x03\x40\x31\x36", 8);
                    wLen += 8;
                    break;

                case CMD_ID_PAPER_HAGAKI:
                    memcpy((PBYTE)&pbCmdBuf[wLen],
                                        "\x1B\x5B\x31\x00\x03\x40\x31\x3D", 8);
                    wLen += 8;
                    break;

                case CMD_ID_PAPER_LETTER:
                    memcpy((PBYTE)&pbCmdBuf[wLen],
                                        "\x1B\x5B\x31\x00\x03\x40\x31\x39", 8);
                    wLen += 8;
                    break;

                case CMD_ID_PAPER_LEGAL:
                    memcpy((PBYTE)&pbCmdBuf[wLen],
                                        "\x1B\x5B\x31\x00\x03\x40\x31\x3B", 8);
                    wLen += 8;
                    break;

                default:
                    break;
            }
            break;

        case CMD_ID_TRAY_AUTO:
            switch (pOEM->wPaper)
            {
                case CMD_ID_PAPER_A3:
                    memcpy((PBYTE)&pbCmdBuf[wLen], "\x1B\x40\x29\x38", 4);
                    wLen += 4;
                    break;

                case CMD_ID_PAPER_B4:
                    memcpy((PBYTE)&pbCmdBuf[wLen], "\x1B\x40\x29\x34", 4);
                    wLen += 4;
                    break;

                case CMD_ID_PAPER_A4:
                    memcpy((PBYTE)&pbCmdBuf[wLen], "\x1B\x40\x29\x35", 4);
                    wLen += 4;
                    break;

                case CMD_ID_PAPER_B5:
                    memcpy((PBYTE)&pbCmdBuf[wLen], "\x1B\x40\x29\x36", 4);
                    wLen += 4;
                    break;

                case CMD_ID_PAPER_A5:
                    memcpy((PBYTE)&pbCmdBuf[wLen], "\x1B\x40\x29\x3B", 4);
                    wLen += 4;
                    break;

                case CMD_ID_PAPER_HAGAKI:
                    memcpy((PBYTE)&pbCmdBuf[wLen], "\x1B\x40\x29\x3C", 4);
                    wLen += 4;
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
    }
    if(wLen)
        WRITESPOOLBUF(pdevobj, (PBYTE)pbCmdBuf, wLen);

    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\fxmejres\etc\fx4103me.c ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

char *rgchModuleName = "FX4103ME";

#define PRINTDRIVER
#define BUILDDLL
#include "print.h"
#include "gdidefs.inc"
#include "fx4103me.h"
#include "mdevice.h"
#include "unidrv.h"

VOID myCmd(LPEXTPDEV lpXPDV, LPSTR lpstr, int cch)
{
    int i;
    LPSTR lp;

    lp = &lpXPDV->rgCmd[lpXPDV->wCmdLen];

    for (i = 0; i < cch; i++) *lp++ = *lpstr++;
    lpXPDV->wCmdLen += cch;
}

VOID SetVert(LPEXTPDEV lpXPDV, BOOL fVert, BOOL fMust)
{
    if (fMust) {
        if (fVert) {
            myCmd(lpXPDV, "\x1B\x74", 2);
            lpXPDV->fVert = TRUE;
        } else {
            myCmd(lpXPDV, "\x1B\x4B", 2);
            lpXPDV->fVert = FALSE;
        }
    } else {
        if (fVert) {
            if (lpXPDV->fVert == FALSE) {
                myCmd(lpXPDV, "\x1B\x74", 2);
                lpXPDV->fVert = TRUE;
            }
        } else {
            if (lpXPDV->fVert == TRUE) {
                myCmd(lpXPDV, "\x1B\x4B", 2);
                lpXPDV->fVert = FALSE;
            }
        }
    }
}

#ifndef NOOEMOUTPUTCHAR
/*
 *  Convert from Shift-JIS code to JIS code
 */
VOID SjToJ (LPSTR lpSjis, LPSTR lpJis)
{
    BYTE    bh, bl;

    bh = lpSjis[0];
    bl = lpSjis[1];

    bh -= (BYTE)(bh >= (BYTE)0xa0 ? 0xb0 : 0x70);
    if (bl >= 0x80)
        bl--;
    bh <<= 1;
    if (bl < 0x9e)
        bh--;
    else
        bl -= 0x5e;
    bl -= 0x1f;

    lpJis[0] = bh;
    lpJis[1] = bl;
}
#endif

#ifndef NOCBFILTERGRAPHICS
/********************** Function Header **************************************
 * CBFilterGraphics
 *      Manipulate output data before calling RasDD's buffering function.
 *
 * NOTE: THIS FUNCTION OVERWRITES THE DATA IN THE BUFFER PASSED IN!!!
 *
 * RETURNS:
 *      Value from WriteSpoolBuf
 *
 * HISTORY:
 *
 *
 ****************************************************************************/

WORD FAR PASCAL CBFilterGraphics(lpdv, lpBuf, wLen)
LPBYTE lpdv;
LPSTR lpBuf;
WORD wLen;
{
    LPEXTPDEV lpXPDV;
    WORD cbSent;
    WORD cb;

    if (!(lpXPDV = ((LPEXTPDEV)((LPDV)lpdv)->lpMd)))
        return 0;

    cbSent = wLen;      /* Assume success */

    while (wLen)
    {
        if (wLen > CCHMAXCMDLEN)
            cb = CCHMAXCMDLEN;
        else
            cb = wLen;

        WriteSpoolBuf((LPDV)lpdv, (LPSTR)lpBuf, cb);

        wLen -= cb;
        lpBuf += CCHMAXCMDLEN;
    }

    return cbSent;      /* compatible with WriteSpoolBuf */
}
#endif

#ifndef NOOEMOUTPUTCHAR
/***************************** Function Header *****************************
 * OEMOutputChar
 *      Manipulate output data before calling RasDD's buffering function.
 *      This function is called with the raw bit data that is to be
 *      sent to the printer.
 *
 * NOTE:  THIS FUNCTION OVERWRITES THE DATA IN THE BUFFER PASSED IN!!!
 *
 * RETURNS:
 *      Value from WriteSpoolBuf
 *
 ****************************************************************************/

VOID FAR PASCAL OEMOutputChar(lpdv, lpStr, wLen , rcID)
LPDV lpdv;
LPSTR lpStr;
WORD wLen;
SHORT rcID;
{
    LPEXTPDEV lpXPDV;

    if (!(lpXPDV = ((LPEXTPDEV)lpdv->lpMd)))
        return;

    if ((rcID > FONT_ID_MAX) || (!rcID))
        return;

    if (!wLen)
        return;
}
#endif

// for scalable font (moved from DDK sample for ESCPAGE)
//----------------------------*OEMScaleWidth*--------------------------------
// Action: return the scaled width which is calcualted based on the
//      assumption that ESC\Page assumes 72 points in one 1 inch.
//
// Formulas:
//  <extent> : <font units> = <base Width> : <hRes>
//  <base width> : <etmMasterHeight> = <newWidth> : <newHeight>
//  <etmMasterUnits> : <etmMasterHeight> = <font units> : <vRes>
// therefore,
//   <newWidth> = (<extent> * <hRes> * <newHeight>) / 
//                  (<etmMasterUnits> * <vRes>)
//---------------------------------------------------------------------------
short FAR PASCAL OEMScaleWidth(width, masterUnits, newHeight, vRes, hRes)
short width;        // in units specified by 'masterUnits'.
short masterUnits;
short newHeight;    // in units specified by 'vRes'.
short vRes, hRes;   // height and width device units.
{
    DWORD newWidth10;
    short newWidth;

    // assert that hRes == vRes to avoid overflow problem.
    if (vRes != hRes)
        return 0;

    newWidth10 = (DWORD)width * (DWORD)newHeight * 10;
    newWidth10 /= (DWORD)masterUnits;

    // we multiplied 10 first in order to maintain the precision of
    // the width calcution. Now convert it back and round to the
    // nearest integer.
    newWidth = (short)((newWidth10 + 5) / 10);

    return newWidth;
}

#if 0
// for scalable font (moved from DDK sample for ESCPAGE)
//-----------------------------------------------------------------------------
// Action:  itoa
//-----------------------------------------------------------------------------
short NEAR PASCAL itoa(buf, n)
LPSTR buf;
short n;
{

    BOOL    fNeg;
    short   i, j, k;

    if (fNeg = (n < 0))
        n = -n;

    for (i = 0; n; i++)
    {
        buf[i] = n % 10 + '0';
        n /= 10;
    }

    // n was zero
    if (i == 0)
        buf[i++] = '0';

    if (fNeg)
        buf[i++] = '-';

    for (j = 0, k = i-1 ; j < i / 2 ; j++,k--)
    {
        char tmp;

        tmp = buf[j];
        buf[j] = buf[k];
        buf[k] = tmp;
    }

    buf[i] = 0;

    return i;
}
#endif

// for scalable font (moved from DDK sample for ESCPAGE)
//---------------------------*OEMSendScalableFontCmd*--------------------------
// Action:  send ESC\Page-style font selection command.
//-----------------------------------------------------------------------------
VOID FAR PASCAL OEMSendScalableFontCmd(lpdv, lpcd, lpFont)
LPDV    lpdv;
LPCD    lpcd;     // offset to the command heap
LPFONTINFO lpFont;
{
    LPSTR   lpcmd;
#if 1   // for 4103ME
    LPEXTPDEV lpXPDV;
    WORD    i;

    if (!(lpXPDV = ((LPEXTPDEV)lpdv->lpMd)))
        return;

    if (!lpcd || !lpFont)
        return;

    // be careful about integer overflow.
    lpcmd = (LPSTR)(lpcd+1);

    lpXPDV->wCmdLen = 0;

    for (i = 0; i < lpcd->wLength; )
    {
        BYTE tmp[2];

        if (lpcmd[i] == '#' && lpcmd[i+1] == 'W')
        {
            tmp[0] = HIBYTE(lpFont->dfMaxWidth);
            tmp[1] = LOBYTE(lpFont->dfMaxWidth);
            myCmd(lpXPDV, tmp, 2);
            i += 2;
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'H')
        {
            tmp[0] = HIBYTE(lpFont->dfPixHeight);
            tmp[1] = LOBYTE(lpFont->dfPixHeight);
            myCmd(lpXPDV, tmp, 2);
            i += 2;
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'Y')
        {
            SetVert(lpXPDV, FALSE, FALSE);
            i += 2;
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'T')
        {
            SetVert(lpXPDV, TRUE, TRUE);
            i += 2;
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'M')
        {
            if (lpXPDV->wFont != FONT_MINCHO)
            {
                myCmd(lpXPDV, "\x1B\x40\x43\x30", 4);
                lpXPDV->wFont = FONT_MINCHO;
            }
            i += 2;
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'G')
        {
            if (lpXPDV->wFont != FONT_GOTHIC)
            {
                myCmd(lpXPDV, "\x1B\x40\x43\x31", 4);
                lpXPDV->wFont = FONT_GOTHIC;
            }
            i += 2;
        }
        else
            myCmd(lpXPDV, &lpcmd[i++], 1);
    }

    if (lpXPDV->wCmdLen)
    {
        WriteSpoolBuf(lpdv, (LPSTR)lpXPDV->rgCmd, lpXPDV->wCmdLen);
        lpXPDV->wCmdLen = 0;
    }
#else   // original codes
    short   ocmd;
    WORD    i;
    BYTE    rgcmd[CCHMAXCMDLEN];    // build command here

    if (!lpcd || !lpFont)
        return;

    // be careful about integer overflow.
    lpcmd = (LPSTR)(lpcd+1);
    ocmd = 0;

    for (i = 0; i < lpcd->wLength && ocmd < CCHMAXCMDLEN; )
        if (lpcmd[i] == '#' && lpcmd[i+1] == 'V')      // height
        {
            long    height;

            // use 1/300 inch unit, which should have already been set.
            // convert font height to 1/300 inch units
            height = ((long)(lpFont->dfPixHeight - lpFont->dfInternalLeading)
                      * 300)  / lpFont->dfVertRes ;
            ocmd += wsprintf(&rgcmd[ocmd], "%ld", height);
            i += 2;
        }
        else if (lpcmd[i] == '#' && lpcmd[i+1] == 'H')     // pitch
        {
            if (lpFont->dfPixWidth > 0)
            {
                short tmpWidth;

                if (lpcmd[i+2] == 'S')
                    tmpWidth = lpFont->dfAvgWidth;
                else
                if (lpcmd[i+2] == 'D')
                    tmpWidth = lpFont->dfMaxWidth;
                else
                    {
                    tmpWidth = lpFont->dfPixWidth;
                    i--;
                    }

                ocmd += itoa((LPSTR)&rgcmd[ocmd], 
                         (lpFont->dfHorizRes * 100 / tmpWidth) /100);
                rgcmd[ocmd] = '.';
                ocmd ++;
                ocmd += itoa((LPSTR)&rgcmd[ocmd], 
                         (lpFont->dfHorizRes * 100 / tmpWidth) %100);
            }
            i += 3;
            
        }
        else
            rgcmd[ocmd++] = lpcmd[i++];

    WriteSpoolBuf(lpdv, (LPSTR) rgcmd, ocmd);
#endif
}

/*
 *  Set tray and paper
 */
VOID SetTrayPaper(LPEXTPDEV lpXPDV)
{
    switch (lpXPDV->wTray)
    {
        case CMD_ID_TRAY_1:
            myCmd(lpXPDV, "\x1B\x40\x29\x30", 4);
            break;

        case CMD_ID_TRAY_2:
            myCmd(lpXPDV, "\x1B\x40\x29\x31", 4);
            break;

        case CMD_ID_TRAY_MANUAL:
            myCmd(lpXPDV, "\x1B\x40\x29\x32", 4);

            switch (lpXPDV->wPaper)
            {
                case CMD_ID_PAPER_A3:
                    myCmd(lpXPDV, "\x1B\x5B\x31\x00\x03\x40\x31\x30", 8);
                    break;

                case CMD_ID_PAPER_B4:
                    myCmd(lpXPDV, "\x1B\x5B\x31\x00\x03\x40\x31\x31", 8);
                    break;

                case CMD_ID_PAPER_A4:
                    myCmd(lpXPDV, "\x1B\x5B\x31\x00\x03\x40\x31\x33", 8);
                    break;

                case CMD_ID_PAPER_B5:
                    myCmd(lpXPDV, "\x1B\x5B\x31\x00\x03\x40\x31\x34", 8);
                    break;

                case CMD_ID_PAPER_A5:
                    myCmd(lpXPDV, "\x1B\x5B\x31\x00\x03\x40\x31\x36", 8);
                    break;

                case CMD_ID_PAPER_HAGAKI:
                    myCmd(lpXPDV, "\x1B\x5B\x31\x00\x03\x40\x31\x3D", 8);
                    break;

                case CMD_ID_PAPER_LETTER:
                    myCmd(lpXPDV, "\x1B\x5B\x31\x00\x03\x40\x31\x39", 8);
                    break;

                case CMD_ID_PAPER_LEGAL:
                    myCmd(lpXPDV, "\x1B\x5B\x31\x00\x03\x40\x31\x3B", 8);
                    break;

                default:
                    break;
            }
            break;

        case CMD_ID_TRAY_AUTO:
            switch (lpXPDV->wPaper)
            {
                case CMD_ID_PAPER_A3:
                    myCmd(lpXPDV, "\x1B\x40\x29\x38", 4);
                    break;

                case CMD_ID_PAPER_B4:
                    myCmd(lpXPDV, "\x1B\x40\x29\x34", 4);
                    break;

                case CMD_ID_PAPER_A4:
                    myCmd(lpXPDV, "\x1B\x40\x29\x35", 4);
                    break;

                case CMD_ID_PAPER_B5:
                    myCmd(lpXPDV, "\x1B\x40\x29\x36", 4);
                    break;

                case CMD_ID_PAPER_A5:
                    myCmd(lpXPDV, "\x1B\x40\x29\x3B", 4);
                    break;

                case CMD_ID_PAPER_HAGAKI:
                    myCmd(lpXPDV, "\x1B\x40\x29\x3C", 4);
                    break;

                default:
                    break;
            }
            break;

        default:
            break;
    }
}

/*
 *  Set resolution
 */
VOID SetResolution(LPEXTPDEV lpXPDV)
{
    if (lpXPDV->wRes == CMD_ID_RES240)
        myCmd(lpXPDV, "\x1B\x5B\x31\x00\x06\x3D\x33\x30\x32\x34\x30", 11);
    else
        myCmd(lpXPDV, "\x1B\x5B\x31\x00\x06\x3D\x33\x30\x34\x30\x30", 11);

    myCmd(lpXPDV, "\x1B\x5C\x35\x38", 4);
    myCmd(lpXPDV, "\x1B\x5B\x31\x00\x03\x46\x34\x00", 8);
    myCmd(lpXPDV, "\x1B\x5B\x31\x00\x03\x46\x35\x09", 8);
    myCmd(lpXPDV, "\x1B\x5B\x31\x00\x03\x46\x31\x03", 8);
}

/*
 *  Copy counts
 */
VOID SetCopyCount(LPEXTPDEV lpXPDV)
{
    BYTE tmp[2];

    myCmd(lpXPDV, "\x1B\x3C\x31", 3);
	tmp[0] = (BYTE)(lpXPDV->wCopyCount / 10) + 0x30;
	tmp[1] = (BYTE)(lpXPDV->wCopyCount % 10) + 0x30;
    myCmd(lpXPDV, tmp, 2);
}

/*
 *  Set relative X coordinate
 */
VOID SetRelX(LPEXTPDEV lpXPDV, WORD wX)
{
    BYTE tmp[2];

    myCmd(lpXPDV, "\x1B\x25\x33", 3);

#ifdef USE_MASTERUNIT
    wX = wX / (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
#endif //USE_MASTERUNIT
	tmp[0] = HIBYTE(wX);
	tmp[1] = LOBYTE(wX);
    myCmd(lpXPDV, tmp, 2);
}

/*
 *  Relative left movement
 */
VOID SetRelLeft(LPEXTPDEV lpXPDV, WORD wX)
{
    short sX;
    BYTE tmp[2];

    myCmd(lpXPDV, "\x1B\x25\x33", 3);

#ifdef  USE_MASTERUNIT
    wX = wX / (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
#endif  //USE_MASTERUNIT
    sX = (short)(0 - wX);
	tmp[0] = HIBYTE(sX);
	tmp[1] = LOBYTE(sX);
    myCmd(lpXPDV, tmp, 2);
}

/*
 *  Set relative Y coordinate sub-routine
 */
VOID SetRelYSub(LPEXTPDEV lpXPDV, WORD wY, BOOL bUp)
{
    BYTE tmp[4];
    short sY;

    myCmd(lpXPDV, "\x1B\x5C\x30", 3);

//#ifdef  USE_MASTERUNIT
//    wY = wY / (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
//#endif  //USE_MASTERUNIT
    if (bUp)
        sY = (short)(0 - wY);
    else
        sY = (short)wY;

    tmp[0] = 0x80;
    tmp[1] = 0;
	tmp[2] = HIBYTE(sY);
	tmp[3] = LOBYTE(sY);
    myCmd(lpXPDV, tmp, 4);
}

/*
 *  Set relative Y coordinate
 */
VOID SetRelY(LPEXTPDEV lpXPDV, WORD wY)
{
#if 1
    BYTE tmp[2];

    myCmd(lpXPDV, "\x1B\x5C\x32", 3);

#ifdef  USE_MASTERUNIT
    wY = wY / (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
#endif  //USE_MASTERUNIT
	tmp[0] = HIBYTE(wY);
	tmp[1] = LOBYTE(wY);
    myCmd(lpXPDV, tmp, 2);
#else
    WORD w;

#ifdef  USE_MASTERUNIT
    wY = wY / (lpXPDV->wRes == CMD_ID_RES240 ? 5 : 3);
#endif  //USE_MASTERUNIT
    while (wY > 0)
    {