                   case DSBUFFERFOCUS_INFOCUS:
                                    if(pPrimaryInFocus)
                                    {
                                        RPF(DPFLVL_WARNING, "Multiple primary buffers are in focus!");
                                    }
                                    else
                                    {
                                        pPrimaryInFocus = pObjectNode->m_data->m_pPrimaryBuffer;
                                    }

                                    break;

                                case DSBUFFERFOCUS_OUTOFFOCUS:
                                    pObjectNode->m_data->m_pPrimaryBuffer->Activate(FALSE);
                                    break;

                                case DSBUFFERFOCUS_LOST:
                                    pObjectNode->m_data->m_pPrimaryBuffer->Lose();
                                    break;
                            }
                        }
                    }
                }
            }
        }

        // Activate the primary buffer that's in focus
        if(pPrimaryInFocus)
        {
            pPrimaryInFocus->Activate(TRUE);
        }

        // Activate all in-focus secondary buffers
        for(pBufferNode = lstInFocus.GetListHead(); pBufferNode; pBufferNode = pBufferNode->m_pNext)
        {
            pBufferNode->m_data->Activate(TRUE);
        }

        DPF_LEAVE_VOID();
        LEAVE_DLL_MUTEX();
    }
}


/***************************************************************************
 *
 *  GetSystemFocusState
 *
 *  Description:
 *      Determines the thread that currently has focus, and it's
 *      priority (cooperative level).
 *
 *  Arguments:
 *      LPDSFOCUS [out]: receives current focus state.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::GetSystemFocusState"

void CDirectSoundAdministrator::GetSystemFocusState(LPDSFOCUS pData)
{
    DPF_ENTER();

    // WARNING: GetForegroundWindow is a 16-bit call, and therefore
    // takes the Win16 lock.
    pData->hWnd = GetForegroundApplication();
    pData->uState = GetWindowState(pData->hWnd);
    pData->fApmSuspend = FALSE;

#ifdef SHARED

    DWORD dwWait = WaitObject(0, m_hApmSuspend);

    if(WAIT_OBJECT_0 == dwWait)
    {
        pData->fApmSuspend = TRUE;
    }

#endif // SHARED

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetDsoundFocusState
 *
 *  Description:
 *      Determines the thread that currently has focus, and it's
 *      priority (cooperative level).
 *
 *  Arguments:
 *      LPDSCOOPERATIVELEVEL [out]: receives current focus state.
 *      LPBOOL [out]: receives a flag to force a focus update
 *
 *  Returns:
 *      BOOL: TRUE if the current focus state agrees with the Administrator.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::GetDsoundFocusState"

void CDirectSoundAdministrator::GetDsoundFocusState(LPDSCOOPERATIVELEVEL pData, LPBOOL pfForce)
{
#ifdef SHARED_THREAD_LIST
    CList<DSSHAREDTHREADLISTDATA>       lstThreads;
    CNode<DSSHAREDTHREADLISTDATA> *     pNode;
    CList<DSSHAREDCAPTUREFOCUSDATA>     lstCapture;
    CNode<DSSHAREDCAPTUREFOCUSDATA> *   pCNode;
    HRESULT                             hr;
#else // SHARED_THREAD_LIST
    CNode<CDirectSound *> *             pNode;
#endif // SHARED_THREAD_LIST

    LPDSCOOPERATIVELEVEL            pdsclCheck;

    DPF_ENTER();
    CHECK_WRITE_PTR(pData);
    CHECK_WRITE_PTR(pfForce);    

    // Initialize
    pData->dwThreadId = 0;
    pData->dwPriority = DSSCL_NONE;

    // No thread is in focus if we're suspended, no window is in focus,
    // or the window in focus is minimized.
    if(!m_dsfCurrent.fApmSuspend)
    {
        if(m_dsfCurrent.hWnd && IsWindow(m_dsfCurrent.hWnd))
        {
            if(SW_SHOWMINIMIZED != m_dsfCurrent.uState)
            {
                pData->dwThreadId = GetWindowThreadProcessId(m_dsfCurrent.hWnd, NULL);
            }
        }
    }

    // Walk the list of DirectSound objects looking for the one with the
    // highest priority that has focus set to this thread id.
    if(pData->dwThreadId)
    {

#ifdef SHARED_THREAD_LIST

        hr = ReadSharedThreadList(&lstThreads);

        if(SUCCEEDED(hr))
        {
            for(pNode = lstThreads.GetListHead(); pNode; pNode = pNode->m_pNext)
            {
                pdsclCheck = &pNode->m_data.dsclCooperativeLevel;

#else // SHARED_THREAD_LIST

            for(pNode = m_lstDirectSound.GetListHead(); pNode; pNode = pNode->m_pNext)
            {
                pdsclCheck = &pNode->m_data->m_dsclCooperativeLevel;
                ASSERT(pNode->m_data);  // See Millennium bug 126722
                if (pNode->m_data)

#endif // SHARED_THREAD_LIST

                if(pData->dwThreadId == pdsclCheck->dwThreadId)
                {
                    pData->dwPriority = max(pData->dwPriority, pdsclCheck->dwPriority);
                }
            }

#ifdef SHARED_THREAD_LIST

        }

#endif // SHARED_THREAD_LIST

#ifdef SHARED_THREAD_LIST
    hr = ReadCaptureFocusList(&lstCapture);

    if (SUCCEEDED(hr))
    {
        DWORD dwProcessId = GetCurrentProcessId();

        for (pCNode = lstCapture.GetListHead(); pCNode; pCNode = pCNode->m_pNext)
        {
            // Are we marked as update?
            if ((dwProcessId == pCNode->m_data.dwProcessId) && (pCNode->m_data.fdwFlags & DSCBFLAG_UPDATE))
            {
                *pfForce = TRUE;
                DPF(DPFLVL_INFO, "Focus update requested by another application");
            }
        }
    }
#endif // SHARED_THREAD_LIST

    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetBufferFocusState
 *
 *  Description:
 *      Determines if a buffer should be muted or not based on the current
 *      focus state.
 *
 *  Arguments:
 *      CDirectSoundBuffer * [in]: object for which to update focus state.
 *
 *  Returns:
 *      DSBUFFERFOCUS: buffer focus state.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::GetBufferFocusState"

DSBUFFERFOCUS CDirectSoundAdministrator::GetBufferFocusState(CDirectSoundBuffer *pBuffer)
{
    DSBUFFERFOCUS           bfFocus     = DSBUFFERFOCUS_INFOCUS;
    BOOL                    fFriends;

    DPF_ENTER();

    // If we're in an APM suspension state, all buffers are lost.  If a
    // WRITEPRIMARY app is in focus, all other buffers are lost.  If a
    // WRITEPRIMARY app is out of focus, it's lost.
    if(m_dsfCurrent.fApmSuspend)
    {
        DPF(DPFLVL_INFO, "Buffer at 0x%p is lost because of APM suspension", pBuffer);
        bfFocus = DSBUFFERFOCUS_LOST;
    }
    else
    {
        if(DSSCL_WRITEPRIMARY == m_dsclCurrent.dwPriority)
        {
            if(!(pBuffer->m_dsbd.dwFlags & DSBCAPS_PRIMARYBUFFER) || m_dsclCurrent.dwThreadId != pBuffer->m_pDirectSound->m_dsclCooperativeLevel.dwThreadId)
            {
                DPF(DPFLVL_INFO, "Buffer at 0x%p is lost because a WRITEPRIMARY app is in focus", pBuffer);
                bfFocus = DSBUFFERFOCUS_LOST;
            }
        }
        else if(DSSCL_WRITEPRIMARY == pBuffer->m_pDirectSound->m_dsclCooperativeLevel.dwPriority)
        {
            if(pBuffer->m_dsbd.dwFlags & DSBCAPS_PRIMARYBUFFER)
            {
                if(DSSCL_NONE != m_dsclCurrent.dwPriority || !(pBuffer->m_dsbd.dwFlags & DSBCAPS_STICKYFOCUS))
                {
                    DPF(DPFLVL_INFO, "Buffer at 0x%p is lost because it's WRITEPRIMARY and out of focus", pBuffer);
                    bfFocus = DSBUFFERFOCUS_LOST;
                }
            }
            else
            {
                DPF(DPFLVL_INFO, "Buffer at 0x%p is lost because it's secondary and WRITEPRIMARY", pBuffer);
                bfFocus = DSBUFFERFOCUS_LOST;
            }
        }
    }

    // Determine the relationship of the buffer and the object in focus.  If
    // the buffer's parent and the object in focus are the same, or the
    // buffer's parent's thread and the object's thread are the same, we
    // consider the two to be "friends", i.e. they share focus.
    if(DSBUFFERFOCUS_INFOCUS == bfFocus)
    {
        fFriends = (pBuffer->m_pDirectSound->m_dsclCooperativeLevel.dwThreadId == m_dsclCurrent.dwThreadId);

        // The DSSCL_EXCLUSIVE cooperative level is obsolescent; old apps that request
        // it should be treated as level DSSCL_PRIORITY instead (Millennium bug 102307)
        if(0)  // Was: if(m_dsclCurrent.dwPriority == DSSCL_EXCLUSIVE)
        {
            // If the app in focus is exclusive, all other buffers
            // stop playing, regardless of caps
            bfFocus = fFriends ? DSBUFFERFOCUS_INFOCUS : DSBUFFERFOCUS_OUTOFFOCUS;
        }
        else
        {
            // Assuming <= DSSCL_PRIORITY
            if(pBuffer->m_dsbd.dwFlags & DSBCAPS_GLOBALFOCUS)
            {
                // Global buffers are only muted if an exclusive app
                // comes into focus
            }
            else if(pBuffer->m_dsbd.dwFlags & DSBCAPS_STICKYFOCUS)
            {
                // Sticky buffers are only muted if another DirectSound app
                // comes into focus
                bfFocus = (fFriends || (DSSCL_NONE == m_dsclCurrent.dwPriority && (pBuffer->m_dwStatus & DSBSTATUS_ACTIVE))) ? DSBUFFERFOCUS_INFOCUS : DSBUFFERFOCUS_OUTOFFOCUS;
            }
            else
            {
                // Normal buffers are muted when any other app comes into
                // focus
                bfFocus = fFriends ? DSBUFFERFOCUS_INFOCUS : DSBUFFERFOCUS_OUTOFFOCUS;
            }
        }
    }

    DPF_LEAVE(bfFocus);
    return bfFocus;
}


/***************************************************************************
 *
 *  FreeOrphanedObjects
 *
 *  Description:
 *      Frees objects that are left behind when a process goes away.
 *
 *  Arguments:
 *      DWORD [in]: process id, or 0 for all objects.
 *      BOOL [in]: TRUE to actually free objects.
 *
 *  Returns:
 *      DWORD: count of orphaned objects that were (or must be) freed.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::FreeOrphanedObjects"

DWORD CDirectSoundAdministrator::FreeOrphanedObjects(DWORD dwProcessId, BOOL fFree)
{
    DWORD                           dwCount = 0;
    CNode<CDirectSound*>            *pDsNode,   *pDsNext;
    CNode<CDirectSoundCapture*>     *pDsCNode,  *pDsCNext;
    CNode<CDirectSoundFullDuplex*>  *pDsFdNode, *pDsFdNext;
    CNode<CDirectSoundSink*>        *pSinkNode, *pSinkNext;
    CNode<CDirectSoundBufferConfig*>*pDsBcNode, *pDsBcNext;
    CNode<CClassFactory*>           *pCfNode,   *pCfNext;

    DPF_ENTER();

    // Make sure the process cleaned up after itself.  Search the global
    // object lists for any that were owned by this process and remove them.

    // DirectSoundFullDuplex objects:
    // Must free the DSFD object before the DS or DSC objects since the DSFD
    // will also try to release its DS and DSC objects.  If these are freed
    // first, we hit a fault.
    for(pDsFdNode = m_lstFullDuplex.GetListHead(); pDsFdNode; pDsFdNode = pDsFdNext)
    {
        pDsFdNext = pDsFdNode->m_pNext;
        if(!dwProcessId || pDsFdNode->m_data->GetOwnerProcessId() == dwProcessId)
        {
            dwCount++;
            if(fFree)
            {
                RPF(DPFLVL_WARNING, "Cleaning up orphaned DirectSoundFullDuplex object at 0x%lX...", pDsFdNode->m_data->m_pImpDirectSoundFullDuplex);
                pDsFdNode->m_data->AbsoluteRelease();
            }
        }
    }

    // DirectSound objects:
    for(pDsNode = m_lstDirectSound.GetListHead(); pDsNode; pDsNode = pDsNext)
    {
        pDsNext = pDsNode->m_pNext;
        if(!dwProcessId || pDsNode->m_data->GetOwnerProcessId() == dwProcessId)
        {
            dwCount++;
            if(fFree)
            {
                RPF(DPFLVL_WARNING, "Cleaning up orphaned DirectSound object at 0x%lX...", pDsNode->m_data->m_pImpDirectSound);
                pDsNode->m_data->AbsoluteRelease();
            }
        }
    }

    // DirectSoundCapture objects:
    for(pDsCNode = m_lstCapture.GetListHead(); pDsCNode; pDsCNode = pDsCNext)
    {
        pDsCNext = pDsCNode->m_pNext;
        if(!dwProcessId || pDsCNode->m_data->GetOwnerProcessId() == dwProcessId)
        {
            dwCount++;
            if(fFree)
            {
                RPF(DPFLVL_WARNING, "Cleaning up orphaned DirectSoundCapture object at 0x%lX...", pDsCNode->m_data->m_pImpDirectSoundCapture);
                pDsCNode->m_data->AbsoluteRelease();
            }
        }
    }

    // DirectSoundSink objects:
    for(pSinkNode = m_lstDirectSoundSink.GetListHead(); pSinkNode; pSinkNode = pSinkNext)
    {
        pSinkNext = pSinkNode->m_pNext;
        if(!dwProcessId || pSinkNode->m_data->GetOwnerProcessId() == dwProcessId)
        {
            dwCount++;
            if(fFree)
            {
                RPF(DPFLVL_WARNING, "Cleaning up orphaned DirectSoundSink object at 0x%lX...", pSinkNode->m_data->m_pImpDirectSoundSink);
                pSinkNode->m_data->AbsoluteRelease();
            }
        }
    }

    // CDirectSoundBufferConfig objects:
    for(pDsBcNode = m_lstDSBufferConfig.GetListHead(); pDsBcNode; pDsBcNode = pDsBcNext)
    {
        pDsBcNext = pDsBcNode->m_pNext;
        if(!dwProcessId || pDsBcNode->m_data->GetOwnerProcessId() == dwProcessId)
        {
            dwCount++;
            if(fFree)
            {
                DPF(DPFLVL_WARNING, "Cleaning up orphaned DirectSoundBufferConfig object at 0x%lX...", pDsBcNode->m_data);
                pDsBcNode->m_data->AbsoluteRelease();
            }
        }
    }

    // Class factory objects:
    for(pCfNode = m_lstClassFactory.GetListHead(); pCfNode; pCfNode = pCfNext)
    {
        pCfNext = pCfNode->m_pNext;
        if(!dwProcessId || pCfNode->m_data->GetOwnerProcessId() == dwProcessId)
        {
            dwCount++;
            if(fFree)
            {
                RPF(DPFLVL_WARNING, "Cleaning up orphaned class factory object...");
                pCfNode->m_data->AbsoluteRelease();
            }
        }
    }

    DPF_LEAVE(dwCount);
    return dwCount;
}


/***************************************************************************
 *
 *  IsCaptureSplitterAvailable
 *
 *  Description:
 *      Checks the availability of the capture splitter.
 *      NOTE: this function could be a global helper function.  There's no
 *      reason for it to be a static member of CDirectSoundAdministrator.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE if available, FALSE otherwise.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::IsCaptureSplitterAvailable"

BOOL CDirectSoundAdministrator::IsCaptureSplitterAvailable(void)
{
    static BOOL fChecked = FALSE;
    static BOOL fSplitter;

    DPF_ENTER();

    if (!fChecked)
    {
        // The capture splitter is only present on Windows ME, XP and later
        WINVERSION vers = GetWindowsVersion();
        fSplitter = (vers == WIN_ME || vers >= WIN_XP);
        fChecked = TRUE;
    }

    DPF_LEAVE(fSplitter);
    return fSplitter;
}


/***************************************************************************
 *
 *  UpdateSharedThreadList
 *
 *  Description:
 *      Updates the shared thread list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::UpdateSharedThreadList"

HRESULT CDirectSoundAdministrator::UpdateSharedThreadList(void)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = WriteSharedThreadList();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST



/***************************************************************************
 *
 *  CreateSharedThreadList
 *
 *  Description:
 *      Creates the shared thread list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::CreateSharedThreadList"

HRESULT CDirectSoundAdministrator::CreateSharedThreadList(void)
{
    const LPCTSTR           pszName = TEXT("DirectSound Administrator shared thread array");
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    if(!m_pSharedThreads)
    {
        m_pSharedThreads = NEW(CSharedMemoryBlock);
        hr = HRFROMP(m_pSharedThreads);

        if(SUCCEEDED(hr))
        {
            hr = m_pSharedThreads->Initialize(PAGE_READWRITE, sizeof(DSSHAREDTHREADLISTDATA) * m_dwSharedThreadLimit, pszName);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST


/***************************************************************************
 *
 *  ReadSharedThreadList
 *
 *  Description:
 *      Reads the shared thread list.
 *
 *  Arguments:
 *      CList * [out]: receives shared thread list data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::ReadSharedThreadList"

HRESULT CDirectSoundAdministrator::ReadSharedThreadList(CList<DSSHAREDTHREADLISTDATA> *plst)
{
    LPDSSHAREDTHREADLISTDATA        pData   = NULL;
    DWORD                           cbData  = 0;
    HRESULT                         hr      = DS_OK;
    CNode<DSSHAREDTHREADLISTDATA> * pNode;
    DWORD                           i;

    DPF_ENTER();

    ASSERT(!plst->GetNodeCount());

    // Assert that we've been initialized.  Initialization used to happen here,
    // but it was moved to make shared memory access thread-safe across processes.
    ASSERT(m_pSharedThreads);

    // Lock the list
    m_pSharedThreads->Lock();

    // Read the thread list
    if(SUCCEEDED(hr))
    {
        hr = m_pSharedThreads->Read((LPVOID *)&pData, &cbData);
    }

    // Convert to list format
    if(SUCCEEDED(hr))
    {
        ASSERT(!(cbData % sizeof(*pData)));

        for(i = 0; i < cbData / sizeof(*pData) && SUCCEEDED(hr); i++)
        {
            pNode = plst->AddNodeToList(pData[i]);
            hr = HRFROMP(pNode);
        }
    }

    // Clean up
    MEMFREE(pData);

    // Unlock the list
    m_pSharedThreads->Unlock();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST


/***************************************************************************
 *
 *  WriteSharedThreadList
 *
 *  Description:
 *      Writes the shared thread list.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::WriteSharedThreadList"

HRESULT CDirectSoundAdministrator::WriteSharedThreadList(void)
{
    LPDSSHAREDTHREADLISTDATA        pData       = NULL;
    CList<DSSHAREDTHREADLISTDATA>   lstThreads;
    DSSHAREDTHREADLISTDATA          dsstld;
    CNode<CDirectSound *> *         pDsNode;
    CNode<DSSHAREDTHREADLISTDATA> * pThNode;
    CNode<DSSHAREDTHREADLISTDATA> * pThNext;
    DWORD                           dwCount;
    UINT                            i;
    HRESULT                         hr;

    DPF_ENTER();

    // Save the current process id
    dsstld.dwProcessId = GetCurrentProcessId();

    // Assert that we've been Initialized.
    ASSERT(m_pSharedThreads);

    // Lock the list
    m_pSharedThreads->Lock();

    // Get the shared thread list.  This will also make sure the list is
    // created and initialized.
    hr = ReadSharedThreadList(&lstThreads);

    // Remove our old threads from the list
    if(SUCCEEDED(hr))
    {
        pThNode = lstThreads.GetListHead();

        while(pThNode)
        {
            pThNext = pThNode->m_pNext;

            if(dsstld.dwProcessId == pThNode->m_data.dwProcessId)
            {
                lstThreads.RemoveNodeFromList(pThNode);
            }

            pThNode = pThNext;
        }
    }

    // Add our new threads to the list
    if(SUCCEEDED(hr))
    {
        for(pDsNode = m_lstDirectSound.GetListHead(); pDsNode && SUCCEEDED(hr); pDsNode = pDsNode->m_pNext)
        {
            dsstld.dsclCooperativeLevel.dwThreadId = pDsNode->m_data->m_dsclCooperativeLevel.dwThreadId;
            dsstld.dsclCooperativeLevel.dwPriority = pDsNode->m_data->m_dsclCooperativeLevel.dwPriority;

            hr = HRFROMP(lstThreads.AddNodeToList(dsstld));
            ASSERT(SUCCEEDED(hr));
        }
    }

    // Write the shared thread list
    if(SUCCEEDED(hr) && (dwCount = lstThreads.GetNodeCount()))
    {
        if(dwCount > m_dwSharedThreadLimit)
        {
            DPF(DPFLVL_ERROR, "Reached arbitrary limitation!  %lu threads will not be written to the shared list!", dwCount - m_dwSharedThreadLimit);
            dwCount = m_dwSharedThreadLimit;
        }

        pData = MEMALLOC_A(DSSHAREDTHREADLISTDATA, dwCount);
        hr = HRFROMP(pData);

        if(SUCCEEDED(hr))
        {
            for(i = 0, pThNode = lstThreads.GetListHead(); i < dwCount; i++, pThNode = pThNode->m_pNext)
            {
                ASSERT(pThNode);
                CopyMemory(pData + i, &pThNode->m_data, sizeof(pThNode->m_data));
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = m_pSharedThreads->Write(pData, dwCount * sizeof(*pData));
        }
    }

    // Clean up
    MEMFREE(pData);

    // Unock the list
    m_pSharedThreads->Unlock();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST

#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::UpdateCaptureFocusList"

HRESULT CDirectSoundAdministrator::UpdateCaptureFocusList(void)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = WriteCaptureFocusList();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST


#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::CreateCaptureFocusList"

HRESULT CDirectSoundAdministrator::CreateCaptureFocusList(void)
{
    const LPCTSTR           pszName = TEXT("DirectSound Administrator capture focus array");
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    if(!m_pCaptureFocusData)
    {
        m_pCaptureFocusData = NEW(CSharedMemoryBlock);
        hr = HRFROMP(m_pCaptureFocusData);

        if(SUCCEEDED(hr))
        {
            hr = m_pCaptureFocusData->Initialize(PAGE_READWRITE, sizeof(DSSHAREDCAPTUREFOCUSDATA) * m_dwCaptureDataLimit, pszName);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST


#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::ReadCaptureFocusList"

HRESULT CDirectSoundAdministrator::ReadCaptureFocusList(CList<DSSHAREDCAPTUREFOCUSDATA> *plst)
{
    LPDSSHAREDCAPTUREFOCUSDATA        pData   = NULL;
    DWORD                             cbData  = 0;
    HRESULT                           hr      = DS_OK;
    CNode<DSSHAREDCAPTUREFOCUSDATA> * pNode;
    DWORD                             i;

    DPF_ENTER();

    // Assert that we've been initialized.
    // The initialization used to happen here.
    ASSERT(m_pCaptureFocusData);

    // Lock the list
    m_pCaptureFocusData->Lock();

    // Read the thread list
    if(SUCCEEDED(hr))
    {
        hr = m_pCaptureFocusData->Read((LPVOID *)&pData, &cbData);
    }

    // Convert to list format
    if(SUCCEEDED(hr))
    {
        ASSERT(!(cbData % sizeof(*pData)));

        for(i = 0; i < cbData / sizeof(*pData) && SUCCEEDED(hr); i++)
        {
            pNode = plst->AddNodeToList(pData[i]);
            hr = HRFROMP(pNode);
        }
    }

    // Clean up
    MEMFREE(pData);

    // UnlockTheList
    m_pCaptureFocusData->Unlock();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST


#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::WriteCaptureFocusList"

HRESULT CDirectSoundAdministrator::WriteCaptureFocusList(void)
{
    LPDSSHAREDCAPTUREFOCUSDATA           pData       = NULL;
    CList<DSSHAREDCAPTUREFOCUSDATA>      lstThreads;
    DSSHAREDCAPTUREFOCUSDATA             dsscfd;
    CNode<CDirectSoundCapture *> *       pDscNode;
    CNode<CDirectSoundCaptureBuffer *> * pCBufferNode;
    CNode<DSSHAREDCAPTUREFOCUSDATA> *    pThNode;
    CNode<DSSHAREDCAPTUREFOCUSDATA> *    pThNext;
    DWORD                                dwCount;
    UINT                                 i;
    HRESULT                              hr;
    BOOL                                 fUpdate = FALSE;

    DPF_ENTER();

    // Save the current process id
    dsscfd.dwProcessId = GetCurrentProcessId();

    // Lock the list
    m_pCaptureFocusData->Lock();

    // Get the shared thread list.  This will also make sure the list is
    // created and initialized.
    hr = ReadCaptureFocusList(&lstThreads);

    // Remove our old threads from the list
    if(SUCCEEDED(hr))
    {
        pThNode = lstThreads.GetListHead();

        while(pThNode)
        {
            pThNext = pThNode->m_pNext;

            if(dsscfd.dwProcessId == pThNode->m_data.dwProcessId)
            {
                if (0 != (pThNode->m_data.fdwFlags & DSCBFLAG_UPDATE))
                {
                    fUpdate = TRUE;
                }

                lstThreads.RemoveNodeFromList(pThNode);
            }

            pThNode = pThNext;
        }
    }

    // Add our new buffers to the list
    if(SUCCEEDED(hr))
    {
        for (pDscNode = m_lstCapture.GetListHead(); pDscNode; pDscNode = pDscNode->m_pNext)
        {
            for (pCBufferNode = pDscNode->m_data->m_lstBuffers.GetListHead(); pCBufferNode; pCBufferNode = pCBufferNode->m_pNext)
            {
                dsscfd.hWndFocus = pCBufferNode->m_data->m_hWndFocus;

                // Combine these flags to save space
                hr = pCBufferNode->m_data->GetStatus(&dsscfd.fdwFlags);
                dsscfd.fdwFlags |= (pCBufferNode->m_data->m_pDeviceBuffer->m_fYieldedFocus) ? DSCBFLAG_YIELD : 0;
                dsscfd.fdwFlags |= (pCBufferNode->m_data->m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE) ? DSCBFLAG_FOCUS : 0;
                dsscfd.fdwFlags |= (pCBufferNode->m_data->m_pDeviceBuffer->m_dwFlags & DSCBCAPS_STRICTFOCUS) ? DSCBFLAG_STRICT : 0;
                dsscfd.fdwFlags |= fUpdate ? DSCBFLAG_UPDATE : 0;

                hr = HRFROMP(lstThreads.AddNodeToList(dsscfd));
                ASSERT(SUCCEEDED(hr));
            }
        }
    }

    // Write the shared thread list
    if(SUCCEEDED(hr) && (dwCount = lstThreads.GetNodeCount()))
    {
        if(dwCount > m_dwCaptureDataLimit)
        {
            DPF(DPFLVL_ERROR, "Reached arbitrary limitation!  %lu threads will not be written to the shared list!", dwCount - m_dwCaptureDataLimit);
            dwCount = m_dwCaptureDataLimit;
        }

        pData = MEMALLOC_A(DSSHAREDCAPTUREFOCUSDATA, dwCount);
        hr = HRFROMP(pData);

        if(SUCCEEDED(hr))
        {
            for(i = 0, pThNode = lstThreads.GetListHead(); i < dwCount; i++, pThNode = pThNode->m_pNext)
            {
                ASSERT(pThNode);
                CopyMemory(pData + i, &pThNode->m_data, sizeof(pThNode->m_data));
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = m_pCaptureFocusData->Write(pData, dwCount * sizeof(*pData));
        }
    }

    // Clean up
    MEMFREE(pData);

    // Unlock the list
    m_pCaptureFocusData->Unlock();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST


#ifdef SHARED_THREAD_LIST

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundAdministrator::MarkUpdateCaptureFocusList"

HRESULT CDirectSoundAdministrator::MarkUpdateCaptureFocusList(DWORD dwProcessId, BOOL fUpdate)
{
    LPDSSHAREDCAPTUREFOCUSDATA           pData       = NULL;
    CList<DSSHAREDCAPTUREFOCUSDATA>      lstThreads;
    CNode<DSSHAREDCAPTUREFOCUSDATA> *    pThNode;
    DWORD                                dwCount;
    UINT                                 i;
    HRESULT                              hr;

    DPF_ENTER();

    // Get the shared thread list.  This will also make sure the list is
    // created and initialized.

    // Assert that we've been initialized
    ASSERT(m_pCaptureFocusData);

    // Lock the list
    m_pCaptureFocusData->Lock();

    hr = ReadCaptureFocusList(&lstThreads);

    // Put the list in memory
    if(SUCCEEDED(hr) && (dwCount = lstThreads.GetNodeCount()))
    {
        if (dwCount > m_dwCaptureDataLimit)
        {
            DPF(DPFLVL_ERROR, "Reached arbitrary limitation!  %lu threads will not be written to the shared list!", dwCount - m_dwCaptureDataLimit);
            dwCount = m_dwCaptureDataLimit;
        }

        pData = MEMALLOC_A(DSSHAREDCAPTUREFOCUSDATA, dwCount);
        hr = HRFROMP(pData);

        if(SUCCEEDED(hr))
        {
            for(i = 0, pThNode = lstThreads.GetListHead(); i < dwCount; i++, pThNode = pThNode->m_pNext)
            {
                ASSERT(pThNode);
                CopyMemory(pData + i, &pThNode->m_data, sizeof(pThNode->m_data));

                // Change the update flag on the appropriate buffer
                if(pThNode->m_data.dwProcessId == dwProcessId)
                {
                    if (fUpdate)
                    {
                        pData[i].fdwFlags |= DSCBFLAG_UPDATE;
                    }
                    else
                    {
                        pData[i].fdwFlags &= (~DSCBFLAG_UPDATE);
                    }
                }
            }
        }

        if(SUCCEEDED(hr))
        {
            hr = m_pCaptureFocusData->Write(pData, dwCount * sizeof(*pData));
        }
    }

    // Clean up
    MEMFREE(pData);

    // Unlock the list
    m_pCaptureFocusData->Unlock();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif // SHARED_THREAD_LIST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsbasic.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbasic.h
 *  Content:    Basic class that all DirectSound objects are derived from.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/9/97      dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSBASIC_H__
#define __DSBASIC_H__

#ifdef __cplusplus

// Reference count class
class CRefCount
{
private:
    ULONG               m_ulRefCount;

public:
    CRefCount(ULONG = 0);
    virtual ~CRefCount(void);

public:
    ULONG GetRefCount(void);
    void SetRefCount(ULONG);
    virtual ULONG AddRef(void);
    virtual ULONG Release(void);
};

// Base class that all DirectSound objects are derived from
class CDsBasicRuntime
    : public CRefCount
{
private:
    const DWORD         m_dwOwnerPid;       // Owning process id
    const DWORD         m_dwOwnerTid;       // Owning thread id
    BOOL                m_fAbsoluteRelease; // TRUE to delete the object on release

public:
    CDsBasicRuntime(BOOL = TRUE);
    virtual ~CDsBasicRuntime(void);

public:
    // Object ownership
    DWORD GetOwnerProcessId(void) const;
    DWORD GetOwnerThreadId(void) const;
    
    // Object reference management
    virtual ULONG Release(void);
    void AbsoluteRelease(void);
};

// Runtime extension of the CList template class
template <class type> class CObjectList
{
private:
    CList<type *>           m_lst;

public:
    CObjectList(void);
    virtual ~CObjectList(void);

public:
    // Node creation, removal
    virtual CNode<type *> *AddNodeToList(type *);
    virtual CNode<type *> *InsertNodeIntoList(CNode<type *> *, type *);
    virtual void RemoveNodeFromList(CNode<type *> *);
    virtual void RemoveAllNodesFromList(void);
    
    // Node manipulation by data
    virtual BOOL RemoveDataFromList(type *);
    virtual CNode<type *> *IsDataInList(type *);
    virtual CNode<type *> *GetNodeByIndex(UINT);
    
    // Basic list information
    virtual CNode<type *> *GetListHead(void);
    virtual CNode<type *> *GetListTail(void);
    virtual UINT GetNodeCount(void);
};

// Release/Absolute release helpers
template <class type> type *__AddRef(type *);
template <class type> void __Release(type *);
template <class type> void __AbsoluteRelease(type *);

#define ADDREF(p) \
            __AddRef(p)

#define RELEASE(p) \
            __Release(p), (p) = NULL

#define ABSOLUTE_RELEASE(p) \
            __AbsoluteRelease(p), (p) = NULL

#include "dsbasic.cpp"

#endif // __cplusplus

#endif // __DSBASIC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsapi.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsapi.cpp
 *  Content:    DirectSound APIs
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  DirectSoundCreate
 *
 *  Description:
 *      Creates and initializes a DirectSound object.
 *
 *  Arguments:
 *      REFGUID [in]: driver GUID or NULL to use preferred driver.
 *      LPDIRECTSOUND * [out]: receives IDirectSound interface to the new
 *                             DirectSound object.
 *      IUnknown * [in]: Controlling unknown.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreate"

HRESULT WINAPI DirectSoundCreate
(
    LPCGUID         pGuid,
    LPDIRECTSOUND*  ppIDirectSound,
    LPUNKNOWN       pUnkOuter
)
{
    CDirectSound *          pDirectSound    = NULL;
    LPDIRECTSOUND           pIDirectSound   = NULL;
    HRESULT                 hr              = DS_OK;

    ENTER_DLL_MUTEX();
    DPF_API3(DirectSoundCreate, pGuid, ppIDirectSound, pUnkOuter);
    DPF_ENTER();

    if(pGuid && !IS_VALID_READ_GUID(pGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppIDirectSound))
    {
        RPF(DPFLVL_ERROR, "Invalid interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    // Create a new DirectSound object
    if(SUCCEEDED(hr))
    {
        pDirectSound = NEW(CDirectSound);
        hr = HRFROMP(pDirectSound);
    }

    // Initialize the object
    if(SUCCEEDED(hr))
    {
        hr = pDirectSound->Initialize(pGuid, NULL);
    }

    // Query for an IDirectSound interface
    if(SUCCEEDED(hr))
    {
        hr = pDirectSound->QueryInterface(IID_IDirectSound, TRUE, (LPVOID *)&pIDirectSound);
    }

    if(SUCCEEDED(hr))
    {
        *ppIDirectSound = pIDirectSound;
    }
    else
    {
        RELEASE(pDirectSound);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DirectSoundCreate8
 *
 *  Description:
 *      Creates and initializes a DirectSound 8.0 object.
 *
 *  Arguments:
 *      REFGUID [in]: Driver GUID or NULL to use preferred driver.
 *      LPDIRECTSOUND8 * [out]: Receives IDirectSound8 interface to
 *                              the new DirectSound object.
 *      IUnknown * [in]: Controlling unknown.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCreate8"

HRESULT WINAPI DirectSoundCreate8
(
    LPCGUID         pGuid,
    LPDIRECTSOUND8* ppIDirectSound8,
    LPUNKNOWN       pUnkOuter
)
{
    CDirectSound *          pDirectSound    = NULL;
    LPDIRECTSOUND8          pIDirectSound8  = NULL;
    HRESULT                 hr              = DS_OK;

    ENTER_DLL_MUTEX();
    DPF_API3(DirectSoundCreate8, pGuid, ppIDirectSound8, pUnkOuter);
    DPF_ENTER();

    if(pGuid && !IS_VALID_READ_GUID(pGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppIDirectSound8))
    {
        RPF(DPFLVL_ERROR, "Invalid interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    // Create a new DirectSound object
    if(SUCCEEDED(hr))
    {
        pDirectSound = NEW(CDirectSound);
        hr = HRFROMP(pDirectSound);
    }

    if(SUCCEEDED(hr))
    {
        // Set the DX8 functional level on the object
        pDirectSound->SetDsVersion(DSVERSION_DX8);

        // Initialize the object
        hr = pDirectSound->Initialize(pGuid, NULL);
    }

    // Query for an IDirectSound8 interface
    if(SUCCEEDED(hr))
    {
        hr = pDirectSound->QueryInterface(IID_IDirectSound8, TRUE, (LPVOID *)&pIDirectSound8);
    }

    if(SUCCEEDED(hr))
    {
        *ppIDirectSound8 = pIDirectSound8;
    }
    else
    {
        RELEASE(pDirectSound);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DirectSoundCaptureCreate
 *
 *  Description:
 *      Creates and initializes a DirectSoundCapture object.
 *
 *  Arguments:
 *      LPGUID [in]: driver GUID or NULL/GUID_NULL to use preferred driver.
 *      LPDIRECTSOUNDCAPTURE * [out]: receives IDirectSoundCapture interface
 *                                    to the new DirectSoundCapture object.
 *      IUnknown * [in]: Controlling unknown.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCaptureCreate"

HRESULT WINAPI DirectSoundCaptureCreate
(
    LPCGUID                 pGuid,
    LPDIRECTSOUNDCAPTURE*   ppIDirectSoundCapture,
    LPUNKNOWN               pUnkOuter
)
{
    CDirectSoundCapture *   pDirectSoundCapture     = NULL;
    LPDIRECTSOUNDCAPTURE    pIDirectSoundCapture    = NULL;
    HRESULT                 hr                      = DS_OK;

    ENTER_DLL_MUTEX();
    DPF_API3(DirectSoundCaptureCreate, pGuid, ppIDirectSoundCapture, pUnkOuter);
    DPF_ENTER();

    if(pGuid && !IS_VALID_READ_GUID(pGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppIDirectSoundCapture))
    {
        RPF(DPFLVL_ERROR, "Invalid interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    // Create a new DirectSoundCapture object
    if(SUCCEEDED(hr))
    {
        pDirectSoundCapture = NEW(CDirectSoundCapture);
        hr = HRFROMP(pDirectSoundCapture);
    }

    // Initialize the object
    if(SUCCEEDED(hr))
    {
        hr = pDirectSoundCapture->Initialize(pGuid, NULL);
    }

    // Query for an IDirectSoundCapture interface
    if(SUCCEEDED(hr))
    {
        hr = pDirectSoundCapture->QueryInterface(IID_IDirectSoundCapture, TRUE, (LPVOID *)&pIDirectSoundCapture);
    }

    if(SUCCEEDED(hr))
    {
        *ppIDirectSoundCapture = pIDirectSoundCapture;
    }
    else
    {
        RELEASE(pDirectSoundCapture);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DirectSoundCaptureCreate8
 *
 *  Description:
 *      Creates and initializes a DirectSoundCapture 8.0 object.
 *
 *  Arguments:
 *      LPGUID [in]: driver GUID or NULL/GUID_NULL to use preferred driver.
 *      LPDIRECTSOUNDCAPTURE8 * [out]: receives IDirectSoundCapture8 interface
 *                                     to the new DirectSoundCapture8 object.
 *      IUnknown * [in]: Controlling unknown.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCaptureCreate8"

HRESULT WINAPI DirectSoundCaptureCreate8
(
    LPCGUID                 pGuid,
    LPDIRECTSOUNDCAPTURE8*  ppIDirectSoundCapture8,
    LPUNKNOWN               pUnkOuter
)
{
    CDirectSoundCapture *   pDirectSoundCapture     = NULL;
    LPDIRECTSOUNDCAPTURE    pIDirectSoundCapture8   = NULL;
    HRESULT                 hr                      = DS_OK;

    ENTER_DLL_MUTEX();
    DPF_API3(DirectSoundCaptureCreate8, pGuid, ppIDirectSoundCapture8, pUnkOuter);
    DPF_ENTER();

    if(pGuid && !IS_VALID_READ_GUID(pGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppIDirectSoundCapture8))
    {
        RPF(DPFLVL_ERROR, "Invalid interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    // Create a new DirectSoundCapture object
    if(SUCCEEDED(hr))
    {
        pDirectSoundCapture = NEW(CDirectSoundCapture);
        hr = HRFROMP(pDirectSoundCapture);
    }

    if(SUCCEEDED(hr))
    {
        // Set the DX8 functional level on the object
        pDirectSoundCapture->SetDsVersion(DSVERSION_DX8);

        // Initialize the object
        hr = pDirectSoundCapture->Initialize(pGuid, NULL);
    }

    // Query for an IDirectSoundCapture8 interface
    if(SUCCEEDED(hr))
    {
        hr = pDirectSoundCapture->QueryInterface(IID_IDirectSoundCapture8, TRUE, (LPVOID *)&pIDirectSoundCapture8);
    }

    if(SUCCEEDED(hr))
    {
        *ppIDirectSoundCapture8 = pIDirectSoundCapture8;
    }
    else
    {
        RELEASE(pDirectSoundCapture);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DirectSoundFullDuplexCreate
 *
 *  Description:
 *      Creates and initializes a DirectSoundFullDuplex object.
 *
 *  Arguments:
 *      REFGUID [in]: driver GUID or NULL to use preferred capture driver.
 *      REFGUID [in]: driver GUID or NULL to use preferred render driver.
 *      LPDIRECTSOUNDAEC * [out]: receives IDirectSoundFullDuplex interface to the new
 *                             DirectSoundFullDuplex object.
 *      IUnknown * [in]: Controlling unknown.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundFullDuplexCreate"

HRESULT WINAPI
DirectSoundFullDuplexCreate
(
    LPCGUID                         pCaptureGuid,
    LPCGUID                         pRenderGuid,
    LPCDSCBUFFERDESC                lpDscBufferDesc,
    LPCDSBUFFERDESC                 lpDsBufferDesc,
    HWND                            hWnd,
    DWORD                           dwLevel,
    LPDIRECTSOUNDFULLDUPLEX*        lplpDSFD,
    LPLPDIRECTSOUNDCAPTUREBUFFER8   lplpDirectSoundCaptureBuffer8,
    LPLPDIRECTSOUNDBUFFER8          lplpDirectSoundBuffer8,
    LPUNKNOWN                       pUnkOuter
)
{
    CDirectSoundFullDuplex *       pDirectSoundFullDuplex    = NULL;
    LPDIRECTSOUNDFULLDUPLEX        pIDirectSoundFullDuplex   = NULL;
    CDirectSoundCaptureBuffer *    pCaptureBuffer            = NULL;
    LPDIRECTSOUNDCAPTUREBUFFER8    pIdsCaptureBuffer8        = NULL;
    CDirectSoundBuffer *           pBuffer                   = NULL;
    LPDIRECTSOUNDBUFFER8           pIdsBuffer8               = NULL;
    HRESULT                        hr                        = DS_OK;
    DSCBUFFERDESC                  dscbdi;
    DSBUFFERDESC                   dsbdi;

    ENTER_DLL_MUTEX();
    DPF_API10(DirectSoundFullDuplexCreate, pCaptureGuid, pRenderGuid, lpDscBufferDesc, lpDsBufferDesc, lplpDSFD, hWnd, dwLevel, lplpDirectSoundCaptureBuffer8, lplpDirectSoundBuffer8, pUnkOuter);
    DPF_ENTER();

    if(pCaptureGuid && !IS_VALID_READ_GUID(pCaptureGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid capture guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(pRenderGuid && !IS_VALID_READ_GUID(pRenderGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid render guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSCBUFFERDESC(lpDscBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid DSC buffer description pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDscBufferDesc(lpDscBufferDesc, &dscbdi, DSVERSION_DX8);
        if (FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid capture buffer description");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSBUFFERDESC(lpDsBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid DS buffer description pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDsBufferDesc(lpDsBufferDesc, &dsbdi, DSVERSION_DX8, FALSE);
        if (FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid buffer description");
        }
    }

    if(SUCCEEDED(hr) && (dsbdi.dwFlags & DSBCAPS_PRIMARYBUFFER))
    {
        RPF(DPFLVL_ERROR, "Cannot specify DSBCAPS_PRIMARYBUFFER with DirectSoundFullDuplexCreate");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_HWND(hWnd))
    {
        RPF(DPFLVL_ERROR, "Invalid window handle");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwLevel < DSSCL_FIRST || dwLevel > DSSCL_LAST))
    {
        RPF(DPFLVL_ERROR, "Invalid cooperative level");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(lplpDSFD))
    {
        RPF(DPFLVL_ERROR, "Invalid DirectSoundFullDuplex interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(lplpDirectSoundCaptureBuffer8))
    {
        RPF(DPFLVL_ERROR, "Invalid capture buffer interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(lplpDirectSoundBuffer8))
    {
        RPF(DPFLVL_ERROR, "Invalid render buffer interface buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    // Create a new DirectSoundFullDuplex object
    if(SUCCEEDED(hr))
    {
        pDirectSoundFullDuplex = NEW(CDirectSoundFullDuplex);
        hr = HRFROMP(pDirectSoundFullDuplex);
    }

    // Initialize the object
    if(SUCCEEDED(hr))
    {
        // Set the DX8 functional level on the object
        pDirectSoundFullDuplex->SetDsVersion(DSVERSION_DX8);

        hr = pDirectSoundFullDuplex->Initialize(pCaptureGuid, pRenderGuid, &dscbdi, &dsbdi, hWnd, dwLevel, &pCaptureBuffer, &pBuffer);
    }

    // Query for an IDirectSoundFullDuplex interface
    if(SUCCEEDED(hr))
    {
        hr = pDirectSoundFullDuplex->QueryInterface(IID_IDirectSoundFullDuplex, TRUE, (LPVOID *)&pIDirectSoundFullDuplex);
    }

    // Query for an IDirectSoundCaptureBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pCaptureBuffer->QueryInterface(IID_IDirectSoundCaptureBuffer8, TRUE, (LPVOID *)&pIdsCaptureBuffer8);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8, TRUE, (LPVOID *)&pIdsBuffer8);
    }

    if(SUCCEEDED(hr))
    {
        *lplpDSFD = pIDirectSoundFullDuplex;
        *lplpDirectSoundCaptureBuffer8 = pIdsCaptureBuffer8;
        *lplpDirectSoundBuffer8 = pIdsBuffer8;
    }
    else
    {
        RELEASE(pCaptureBuffer);
        RELEASE(pBuffer);
        RELEASE(pDirectSoundFullDuplex);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CallDirectSoundEnumerateCallback
 *
 *  Description:
 *      Helper function for DirectSoundEnumerate.  This function converts
 *      arguments into the proper format and calls the callback function.
 *
 *  Arguments:
 *      LPDSENUMCALLBACKA [in]: pointer to the ANSI callback function.
 *      LPDSENUMCALLBACKW [in]: pointer to the Unicode callback function.
 *      CDeviceDescription * [in]: driver information.
 *      LPVOID [in]: passed directly to the callback function.
 *      LPBOOL: [in/out]: TRUE to continue enumerating.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CallDirectSoundEnumerateCallback"

HRESULT CallDirectSoundEnumerateCallback(LPDSENUMCALLBACKA pfnCallbackA, LPDSENUMCALLBACKW pfnCallbackW, CDeviceDescription *pDesc, LPVOID pvContext, LPBOOL pfContinue)
{
    static const LPCSTR     pszEmptyA   = "";
    static const LPCWSTR    pszEmptyW   = L"";
    LPGUID                  pguid;
    LPCSTR                  pszNameA;
    LPCWSTR                 pszNameW;
    LPCSTR                  pszPathA;
    LPCWSTR                 pszPathW;

    DPF_ENTER();

    if(IS_NULL_GUID(&pDesc->m_guidDeviceId))
    {
        pguid = NULL;
    }
    else
    {
        pguid = &pDesc->m_guidDeviceId;
    }

    if(pDesc->m_strName.IsEmpty())
    {
        pszNameA = pszEmptyA;
        pszNameW = pszEmptyW;
    }
    else
    {
        pszNameA = pDesc->m_strName;
        pszNameW = pDesc->m_strName;
    }

    if(pDesc->m_strPath.IsEmpty())
    {
        pszPathA = pszEmptyA;
        pszPathW = pszEmptyW;
    }
    else
    {
        pszPathA = pDesc->m_strPath;
        pszPathW = pDesc->m_strPath;
    }

    if(*pfContinue && pfnCallbackA)
    {
        *pfContinue = pfnCallbackA(pguid, pszNameA, pszPathA, pvContext);
    }

    if(*pfContinue && pfnCallbackW)
    {
        *pfContinue = pfnCallbackW(pguid, pszNameW, pszPathW, pvContext);
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  InternalDirectSoundEnumerate
 *
 *  Description:
 *      Enumerates available drivers.  The GUIDs passed to the callback
 *      function can be passed to DirectSoundCreate in order to create
 *      a DirectSound object using that driver.
 *
 *  Arguments:
 *      LPDSENUMCALLBACK [in]: pointer to the callback function.
 *      LPVOID [in]: passed directly to the callback function.
 *      BOOL [in]: TRUE if the callback expects Unicode strings.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "InternalDirectSoundEnumerate"

HRESULT InternalDirectSoundEnumerate(LPDSENUMCALLBACKA pfnCallbackA, LPDSENUMCALLBACKW pfnCallbackW, LPVOID pvContext, VADDEVICETYPE vdt)
{
    const DWORD                     dwEnumDriversFlags      = VAD_ENUMDRIVERS_ORDER | VAD_ENUMDRIVERS_REMOVEPROHIBITEDDRIVERS | VAD_ENUMDRIVERS_REMOVEDUPLICATEWAVEDEVICES;
    BOOL                            fContinue               = TRUE;
    CDeviceDescription *            pPreferred              = NULL;
    HRESULT                         hr                      = DS_OK;
    DSAPPHACKS                      ahAppHacks;
    CObjectList<CDeviceDescription> lstDrivers;
    CNode<CDeviceDescription *> *   pNode;
    TCHAR                           szDescription[0x100];

    ENTER_DLL_MUTEX();
    DPF_ENTER();

    if(SUCCEEDED(hr) && pfnCallbackA && !IS_VALID_CODE_PTR(pfnCallbackA))
    {
        RPF(DPFLVL_ERROR, "Invalid callback function pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pfnCallbackW && !IS_VALID_CODE_PTR(pfnCallbackW))
    {
        RPF(DPFLVL_ERROR, "Invalid callback function pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pfnCallbackA && !pfnCallbackW)
    {
        RPF(DPFLVL_ERROR, "No callback function pointer supplied");
        hr = DSERR_INVALIDPARAM;
    }

    // Load apphacks in order to disable certain devices
    if(SUCCEEDED(hr))
    {
        AhGetAppHacks(&ahAppHacks);
        vdt &= ~ahAppHacks.vdtDisabledDevices;
    }

    // Enumerate available drivers for all device types corresponding
    // to the supplied device type mask.
    if(SUCCEEDED(hr))
    {
        hr = g_pVadMgr->EnumDrivers(vdt, dwEnumDriversFlags, &lstDrivers);
    }

    // Pass the preferred device to the callback function
    if(SUCCEEDED(hr))
    {
        pPreferred = NEW(CDeviceDescription);
        hr = HRFROMP(pPreferred);
    }

    if(SUCCEEDED(hr) && IS_RENDER_VAD(vdt) && fContinue)
    {
        if(LoadString(hModule, IDS_PRIMARYDRIVER, szDescription, NUMELMS(szDescription)))
        {
            pPreferred->m_strName = szDescription;

            hr = CallDirectSoundEnumerateCallback(pfnCallbackA, pfnCallbackW, pPreferred, pvContext, &fContinue);
        }
    }

    if(SUCCEEDED(hr) && IS_CAPTURE_VAD(vdt) && fContinue)
    {
        if(LoadString(hModule, IDS_PRIMARYCAPDRIVER, szDescription, NUMELMS(szDescription)))
        {
            pPreferred->m_strName = szDescription;

            hr = CallDirectSoundEnumerateCallback(pfnCallbackA, pfnCallbackW, pPreferred, pvContext, &fContinue);
        }
    }

    // Pass each driver to the callback function
    for(pNode = lstDrivers.GetListHead(); pNode && SUCCEEDED(hr); pNode = pNode->m_pNext)
    {
        hr = CallDirectSoundEnumerateCallback(pfnCallbackA, pfnCallbackW, pNode->m_data, pvContext, &fContinue);
    }

    // Clean up
    RELEASE(pPreferred);

    DPF_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DirectSoundEnumerate
 *
 *  Description:
 *      Enumerates available drivers.  The GUIDs passed to the callback
 *      function can be passed to DirectSoundCreate in order to create
 *      a DirectSound object using that driver.
 *
 *  Arguments:
 *      LPDSENUMCALLBACK [in]: pointer to the callback function.
 *      LPVOID [in]: passed directly to the callback function.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundEnumerateA"

HRESULT WINAPI DirectSoundEnumerateA(LPDSENUMCALLBACKA pfnCallback, LPVOID pvContext)
{
    HRESULT                 hr;

    DPF_API2(DirectSoundEnumerateA, pfnCallback, pvContext);
    DPF_ENTER();

    hr = InternalDirectSoundEnumerate(pfnCallback, NULL, pvContext, VAD_DEVICETYPE_RENDERMASK);

    DPF_API_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "DirectSoundEnumerateW"

HRESULT WINAPI DirectSoundEnumerateW(LPDSENUMCALLBACKW pfnCallback, LPVOID pvContext)
{
    HRESULT                 hr;

    DPF_API2(DirectSoundEnumerateW, pfnCallback, pvContext);
    DPF_ENTER();

    hr = InternalDirectSoundEnumerate(NULL, pfnCallback, pvContext, VAD_DEVICETYPE_RENDERMASK);

    DPF_API_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DirectSoundCaptureEnumerate
 *
 *  Description:
 *      Enumerates available drivers.  The GUIDs passed to the callback
 *      function can be passed to DirectSoundCaptureCreate in order to create
 *      a DirectSoundCapture object using that driver.
 *
 *  Arguments:
 *      LPDSENUMCALLBACK [in]: pointer to the callback function.
 *      LPVOID [in]: passed directly to the callback function.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCaptureEnumerateA"

HRESULT WINAPI DirectSoundCaptureEnumerateA(LPDSENUMCALLBACKA pfnCallback, LPVOID pvContext)
{
    HRESULT                 hr;

    DPF_API2(DirectSoundCaptureEnumerateA, pfnCallback, pvContext);
    DPF_ENTER();

    hr = InternalDirectSoundEnumerate(pfnCallback, NULL, pvContext, VAD_DEVICETYPE_CAPTUREMASK);

    DPF_API_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "DirectSoundCaptureEnumerateW"

HRESULT WINAPI DirectSoundCaptureEnumerateW(LPDSENUMCALLBACKW pfnCallback, LPVOID pvContext)
{
    HRESULT                 hr;

    DPF_API2(DirectSoundCaptureEnumerateW, pfnCallback, pvContext);
    DPF_ENTER();

    hr = InternalDirectSoundEnumerate(NULL, pfnCallback, pvContext, VAD_DEVICETYPE_CAPTUREMASK);

    DPF_API_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDeviceID
 *
 *  Description:
 *      Translates from default device IDs to specific device IDs.
 *
 *      If the 'pGuidSrc' argument is one of the default IDs defined
 *      in dsound.h (DSDEVID_DefaultPlayback, DSDEVID_DefaultCapture,
 *      DSDEVID_DefaultVoicePlayback or DSDEVID_DefaultVoiceCapture),
 *      we return the corresponding device GUID in 'pGuidDest'.
 *
 *      Otherwise, if 'pGuidSrc' is already a valid specific device
 *      ID, we just copy it to 'pGuidDest' and return success.
 *
 *  Arguments:
 *      LPCGUID [in]: a (speficic or default) device ID.
 *      LPGUID [out]: receives the corresponding device ID.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetDeviceID"

HRESULT WINAPI GetDeviceID(LPCGUID pGuidSrc, LPGUID pGuidDest)
{
    HRESULT hr = DS_OK;
    ENTER_DLL_MUTEX();
    DPF_API2(GetDeviceID, pGuidSrc, pGuidDest);
    DPF_ENTER();

    if (!IS_VALID_READ_GUID(pGuidSrc) || !IS_VALID_WRITE_GUID(pGuidDest))
    {
        RPF(DPFLVL_ERROR, "Invalid GUID pointer");
        hr = DSERR_INVALIDPARAM;
    }
    else
    {
        // GetDeviceDescription() maps from a default ID to a specific ID
        CDeviceDescription *pDesc = NULL;
        hr = g_pVadMgr->GetDeviceDescription(*pGuidSrc, &pDesc);

        if (SUCCEEDED(hr))
        {
            *pGuidDest = pDesc->m_guidDeviceId;
            pDesc->Release();
        }
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsbnotes.cpp ===
//--------------------------------------------------------------------------;
//
//  File: dsbnotes.cpp
//
//  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  History:
//      03/11/97        FrankYe         Created
//
//--------------------------------------------------------------------------;
#define NODSOUNDSERVICETABLE

#include "dsoundi.h"
#include <limits.h>

#ifndef Not_VxD
#pragma warning(disable:4002)
#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG
#endif

#ifndef NOVXD
extern "C" DWORD WINAPI OpenVxDHandle(HANDLE hSource);
#endif // NOVXD

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::CDsbNotes"

// The debug output from dsound.vxd is overwhelming some people.
// This is a stopgap solution until someone is inspired to set up
// the same fine-grained debug level system here as in dsound.dll.
// Define DPF_VERBOSE as 1 if you want to re-enable all traces...
#define DPF_VERBOSE 0

CDsbNotes::CDsbNotes(void)
{
#ifdef Not_VxD
    m_cNotes = 0;
    m_cPosNotes = 0;
    m_paNotes = NULL;
    m_iNextPositionNote = 0;
#else
    ASSERT(FALSE);
#endif
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::~CDsbNotes"

CDsbNotes::~CDsbNotes(void)
{
#ifdef Not_VxD
    FreeNotificationPositions();
#else
    ASSERT(FALSE);
#endif
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::Initialize"

HRESULT CDsbNotes::Initialize(int cbBuffer)
{
#ifdef Not_VxD
    m_cbBuffer = cbBuffer;
    return S_OK;
#else
    ASSERT(FALSE);
    return E_NOTIMPL;
#endif
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::SetNotificationPositions"

HRESULT CDsbNotes::SetNotificationPositions(int cEvents, LPCDSBPOSITIONNOTIFY paNotes)
{
#ifdef Not_VxD
    const DWORD dwProcessId = GetCurrentProcessId();
    HRESULT hr;
    int i, j;

    hr = S_OK;

    // First remove existing notifications
    FreeNotificationPositions();

    //
    // The VxDHandles are opened only once for each Win32 event handle.  And
    // it is valid for the client to use the same Win32 event handle for
    // multiple position events.
    //
    // So, we need use nested loops such that for each Win32 event handle
    // we open a VxDHandle and use that same VxDHandle if the same
    // Win32 event handle is used again in the list.
    //
    // Pseudocode:
    //
    //  For each element in list
    //      If VxD handle is not open, then open it
    //          For remaining elements in list
    //              If Win32 handle is the same as the one we just processed
    //                  Use the same VxD handle
    //

    m_cNotes = cEvents;
    m_cPosNotes = m_cNotes;

    if(m_cNotes) {
        m_paNotes = MEMALLOC_A(DSBPOSITIONNOTIFY, m_cNotes);
        if(m_paNotes) {
            for(i = 0; i < m_cNotes; i++) {
                m_paNotes[i].dwOffset = paNotes[i].dwOffset;
                if(DSBPN_OFFSETSTOP == m_paNotes[i].dwOffset) m_cPosNotes--;
                if(!m_paNotes[i].hEventNotify) {
#ifndef NOVXD
                    if(g_hDsVxd) {
                        m_paNotes[i].hEventNotify = (HANDLE)OpenVxDHandle(paNotes[i].hEventNotify);
                    } else {
#endif // NOVXD
                        m_paNotes[i].hEventNotify = GetGlobalHandleCopy(paNotes[i].hEventNotify, dwProcessId, FALSE);
#ifndef NOVXD
                    }
#endif // NOVXD
                } else {
                    for(j = i + 1; j < m_cNotes; j++) {
                        if(paNotes[j].hEventNotify == paNotes[i].hEventNotify) {
                            m_paNotes[j].hEventNotify = m_paNotes[i].hEventNotify;
                        }
                    }
                }
            }

        } else {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
#else
    ASSERT(FALSE);
    return E_NOTIMPL;
#endif
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::SetPosition"

void CDsbNotes::SetPosition(int ibPosition)
{
    if (0 == m_cPosNotes) return;
    
    for(int i = 0; i < m_cPosNotes; i++) {
        if(m_paNotes[i].dwOffset >= (DWORD)ibPosition) break;
    }

    if(i == m_cPosNotes) i = 0;

    ASSERT(i >= 0);
    ASSERT(i < m_cPosNotes);

    m_ibLastPosition = ibPosition;
    m_iNextPositionNote = i;

    return;
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::NotifyToPosition"

void CDsbNotes::NotifyToPosition(IN  int ibPosition,
                 OUT int *pdbNextNotify)
{
    int ibNotify;
    int dbNextNotify;
    int cSignals;
    BOOL fSignal;
    int i;

    *pdbNextNotify = INT_MAX;
    
    if (0 == m_cPosNotes) return;

    // Setup loop

#if DPF_VERBOSE
#ifdef Not_VxD
    DPF(DPFLVL_MOREINFO, "Position = %lu", ibPosition);
#else // Not_VxD
    DPF(("Position = %lu", ibPosition));
#endif // Not_VxD
#endif // DPF_VERBOSE
    
    cSignals = 0;
    fSignal = TRUE;
    i = m_iNextPositionNote - 1;
    
    while (fSignal && cSignals++ < m_cPosNotes) {

        HANDLE Event;

        // Advance index into ring buffer;
        if (++i == m_cPosNotes) i = 0;

        fSignal = FALSE;
        ibNotify = m_paNotes[i].dwOffset;
        Event = m_paNotes[i].hEventNotify;

        // If the notify position is >= last position and < current position
        // then we should signal it.
        if (m_ibLastPosition <= ibPosition) {
            // We have not wrapped
            if (ibNotify >= m_ibLastPosition && ibNotify < ibPosition) {
#if DPF_VERBOSE
#ifdef Not_VxD
                DPF(DPFLVL_MOREINFO, "Signalling %lu", ibNotify);
#else // Not_VxD
                DPF(("Signalling %lu", ibNotify));
#endif // Not_VxD
#endif // DPF_VERBOSE
                SetDsbEvent(Event);
                fSignal = TRUE;
            }
        } else {
            // We have wrapped
            if (ibNotify >= m_ibLastPosition || ibNotify < ibPosition) {
#if DPF_VERBOSE
#ifdef Not_VxD
                DPF(DPFLVL_MOREINFO, "Signalling %lu (wrapped)", ibNotify);
#else // Not_VxD
                DPF(("Signalling %lu (wrapped)", ibNotify));
#endif // Not_VxD
#endif // DPF_VERBOSE
                SetDsbEvent(Event);
                fSignal = TRUE;
            }
        }

    }

    // New state
    m_iNextPositionNote = i;
    m_ibLastPosition = ibPosition;

    // Compute time, in bytes, 'til next notify
    if (ibNotify >= ibPosition) {
        dbNextNotify = ibNotify - ibPosition;
    } else {
        dbNextNotify = ibNotify + m_cbBuffer - ibPosition;
    }

    *pdbNextNotify = dbNextNotify;
    
    return;
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::NotifyStop"

void CDsbNotes::NotifyStop(void)
{
    for (int i = m_cPosNotes; i < m_cNotes; i++) SetDsbEvent(m_paNotes[i].hEventNotify);
    return;
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::SetDsbEvent"

void CDsbNotes::SetDsbEvent(HANDLE Event)
{
#ifdef Not_VxD
#ifndef NOVXD
    if(g_hDsVxd) {
    VxdEventScheduleWin32Event((DWORD)Event, 0);
    } else {
#endif // NOVXD
    SetEvent(Event);
#ifndef NOVXD
    }
#endif // NOVXD
#else
    eventScheduleWin32Event((DWORD)Event, 0);
#endif
    return;
}

#undef DPF_FNAME
#define DPF_FNAME "CDsbNotes::FreeNotificationPositions"

void CDsbNotes::FreeNotificationPositions(void)
{
#ifdef Not_VxD
    //
    // The VxDHandles are opened only once for each Win32 event handle.  And
    // it is valid for the client to use the same Win32 event handle for
    // multiple position events.
    //
    // So, we need use nested loops such that for each VxDHandle that we
    // close we find all duplicates and mark them as closed, too.
    //
    // Pseudocode:
    //
    //  For each element in list
    //      If VxD handle is open, then close it
    //          For remaining elements in list
    //              If VxD handle is the same as the one we just closed
    //                  Mark it closed
    //
    
    if (m_cNotes) {
        ASSERT(m_paNotes);
        for (int i = 0; i < m_cNotes; i++) {
            if (m_paNotes[i].hEventNotify) {
#ifndef NOVXD
                if(g_hDsVxd) {
                    VxdEventCloseVxdHandle((DWORD)m_paNotes[i].hEventNotify);
                } else {
#endif //NOVXD
                    CloseHandle(m_paNotes[i].hEventNotify);
#ifndef NOVXD
                }
#endif // NOVXD

                for (int j = i+1; j < m_cNotes; j++) {
                    if (m_paNotes[j].hEventNotify == m_paNotes[i].hEventNotify) {
                        m_paNotes[j].hEventNotify = NULL;
                    }
                }
            }
        }
        MEMFREE(m_paNotes);
        m_paNotes = NULL;
        m_cNotes = 0;
        m_cPosNotes = 0;
    } else {
        ASSERT(!(m_paNotes));
        ASSERT(!(m_cPosNotes));
    }
#else
    ASSERT(FALSE);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsaphack.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsaphack.h
 *  Content:    DirectSound "app-hack" extension.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  02/16/98    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSAPHACK_H__
#define __DSAPHACK_H__

#define DSAPPHACK_MAXNAME   (MAX_PATH + 16 + 16)

typedef enum
{
    DSAPPHACKID_DEVACCEL,           // Turn off certain acceleration flags on per-device basis
    DSAPPHACKID_DISABLEDEVICE,      // Turn off certain devices (force them into emulation)
    DSAPPHACKID_PADCURSORS,         // Pad the play and write cursors
    DSAPPHACKID_MODIFYCSBFAILURE,   // Change all CreateSoundBuffer failure codes to this
    DSAPPHACKID_RETURNWRITEPOS,     // Return write position as play position
    DSAPPHACKID_SMOOTHWRITEPOS,     // Return write position as play position + a constant
    DSAPPHACKID_CACHEPOSITIONS      // Cache device positions for apps which poll too often
} DSAPPHACKID, *LPDSAPPHACKID;

typedef struct tagDSAPPHACK_DEVACCEL
{
    DWORD           dwAcceleration;
    VADDEVICETYPE   vdtDevicesAffected;
} DSAPPHACK_DEVACCEL, *LPDSAPPHACK_DEVACCEL;

typedef struct tagDSAPPHACK_SMOOTHWRITEPOS
{
    BOOL            fEnable;
    LONG            lCursorPad;
} DSAPPHACK_SMOOTHWRITEPOS, *LPDSAPPHACK_SMOOTHWRITEPOS;

typedef struct tagDSAPPHACKS
{
    DSAPPHACK_DEVACCEL          daDevAccel;
    VADDEVICETYPE               vdtDisabledDevices;
    LONG                        lCursorPad;
    HRESULT                     hrModifyCsbFailure;
    VADDEVICETYPE               vdtReturnWritePos;
    DSAPPHACK_SMOOTHWRITEPOS    swpSmoothWritePos;
    VADDEVICETYPE               vdtCachePositions;
} DSAPPHACKS, *LPDSAPPHACKS;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern BOOL AhGetApplicationId(LPTSTR);
extern HKEY AhOpenApplicationKey(LPCTSTR);
extern BOOL AhGetHackValue(HKEY, DSAPPHACKID, LPVOID, DWORD);
extern BOOL AhGetAppHacks(LPDSAPPHACKS);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSAPHACK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsbnotes.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbnotes.h
 *  Content:    Notification events.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  3/11/97     FrankYe Created.
 *
 ***************************************************************************/

#ifndef __DSBNOTES_H__
#define __DSBNOTES_H__

#ifdef __cplusplus

class CDsbNotes {
    public:
	CDsbNotes();
	~CDsbNotes();
	HRESULT Initialize(int cbBuffer);
	__inline BOOL HasNotifications(void);
	HRESULT SetNotificationPositions(int cNotes, LPCDSBPOSITIONNOTIFY paNotes);
	void SetPosition(int ibPosition);
	void NotifyToPosition(int ibNewPosition, int *pdbNextNotify);
	void NotifyStop(void);

    private:
	void SetDsbEvent(HANDLE Event);
	void FreeNotificationPositions(void);
	
	int			m_cNotes;
        int                     m_cPosNotes;
	LPDSBPOSITIONNOTIFY	m_paNotes;
	
	int			m_cbBuffer;

	int			m_ibLastPosition;
	int			m_iNextPositionNote;
};

__inline BOOL CDsbNotes::HasNotifications(void) { return (0 != m_cNotes); }

#endif // __cplusplus

#endif // __DSBNOTES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsbufcfg.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbufcfg.cpp
 *  Content:    DirectSound Buffer Configuration 
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 * 11/17/99     jimge   Created.
 * 11/24/99     petchey Completed implementation.
 *
 ***************************************************************************/

#include "dsoundi.h"

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::QueryInterface"

HRESULT CDirectSoundBufferConfig::QueryInterface(REFIID riid, BOOL fInternalQuery, LPVOID *ppvObj)
{
    if (IsEqualGUID(riid, CLSID_PRIVATE_CDirectSoundBufferConfig))
    {
        *ppvObj = this;
        return S_OK;
    }
    return CUnknown::QueryInterface(riid, fInternalQuery, ppvObj);
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::CDirectSoundBufferConfig"

CDirectSoundBufferConfig::CDirectSoundBufferConfig()
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundBufferConfig);

    CreateAndRegisterInterface(this, IID_IPersistStream, this, &m_pImpPersistStream);
    // FIXME: Should RegisterInterface(IID_IPersist, m_pImpPersistStream, (IPersist*)m_pImpPersistStream) too?
    CreateAndRegisterInterface(this, IID_IDirectMusicObject, this, &m_pImpDirectMusicObject);

    m_pdwFuncIDs = NULL;
    m_dwFuncIDsCount = 0;

    m_pDXDMOMapList = NULL;
    m_dwDXDMOMapCount = 0;

    ZeroMemory(&m_DMUSObjectDesc,sizeof(m_DMUSObjectDesc));
    ZeroMemory(&m_DSBufferDesc,sizeof(m_DSBufferDesc));

    m_DMUSObjectDesc.dwSize      = sizeof(m_DMUSObjectDesc);
    m_DMUSObjectDesc.dwValidData = DMUS_OBJ_CLASS;
    m_DMUSObjectDesc.guidClass   = CLSID_DirectSoundBufferConfig;

    m_fLoadFlags = 0;

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::~CDirectSoundBufferConfig"

CDirectSoundBufferConfig::~CDirectSoundBufferConfig()
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundBufferConfig);

    // Unregister with the administrator
    g_pDsAdmin->UnregisterObject(this);

    if (m_pDXDMOMapList)
    {
        CDXDMODesc *pObj = m_pDXDMOMapList;
        CDXDMODesc *pNextObj;
        while (pObj) 
        {
            pNextObj = pObj->pNext;
            if (pObj->m_pMediaObject)
            {
                // We are releasing an object in another DLL.  If we are called
                // via an AbsoluteRelease call, this DLL may already be unloaded.
                try
                {
                    pObj->m_pMediaObject->Release();
                }
                catch (...) {}
            }
            DELETE(pObj);
            pObj = pNextObj;
        }
    }
    MEMFREE(m_pdwFuncIDs);
    DELETE(m_pImpPersistStream);
    DELETE(m_pImpDirectMusicObject);

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::GetClassID"

HRESULT CDirectSoundBufferConfig::GetClassID(CLSID *pClassID)
{
    DPF_ENTER();

    HRESULT hr = S_OK;

    *pClassID = CLSID_DirectSoundBufferConfig;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::Load"

HRESULT CDirectSoundBufferConfig::Load(IStream *pStream)
{
    DPF_ENTER();

    //
    // Parse file
    //

    CRiffParser Parser(pStream);
    HRESULT hr = S_OK;
    RIFFIO ckMain;
    RIFFIO ckNext;
    RIFFIO ckChild;
    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_DSBC_FORM))
    {
        Parser.EnterList(&ckNext);
        while(Parser.NextChunk(&hr))
        {
            switch(ckNext.ckid)
            {
            case DMUS_FOURCC_GUID_CHUNK:
                hr = Parser.Read( &m_DMUSObjectDesc.guidObject, sizeof(GUID));
                m_DMUSObjectDesc.dwValidData |= DMUS_OBJ_OBJECT;
                break;
            case DMUS_FOURCC_DSBD_CHUNK:
                hr = Parser.Read( &m_DSBufferDesc, sizeof(DSOUND_IO_DSBUFFERDESC) );
                m_fLoadFlags |= DSBCFG_DSBD;
                break;
            case DMUS_FOURCC_BSID_CHUNK:
                m_pdwFuncIDs = (LPDWORD)MEMALLOC_A(char,ckNext.cksize);
                if ( m_pdwFuncIDs )
                {
                    hr = Parser.Read( m_pdwFuncIDs, ckNext.cksize );
                    if( SUCCEEDED(hr) )
                    {
                        m_fLoadFlags |= DSBCFG_BSID;
                        m_dwFuncIDsCount = ckNext.cksize/sizeof(DWORD);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                break;
            case DMUS_FOURCC_DS3D_CHUNK:
                hr = Parser.Read( &m_DS3DDesc, sizeof(DSOUND_IO_3D) );
                m_fLoadFlags |= DSBCFG_DS3D;
                break;
            case FOURCC_LIST:
                switch(ckNext.fccType)
                {
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckChild);
                    while(Parser.NextChunk(&hr))
                    {
                        if ( ckChild.ckid == DMUS_FOURCC_UNAM_CHUNK)
                        {
                            hr = Parser.Read(&m_DMUSObjectDesc.wszName, DMUS_MAX_NAME * sizeof(WCHAR));
                            m_DMUSObjectDesc.dwValidData |= DMUS_OBJ_NAME;
                        }
                    }
                    Parser.LeaveList();
                    break;
                case DMUS_FOURCC_DSBC_LIST:
                    Parser.EnterList(&ckChild);
                    while(Parser.NextChunk(&hr))
                    {
                        if ((ckChild.ckid == FOURCC_RIFF) && (ckChild.fccType == DMUS_FOURCC_DSFX_FORM))
                        {
                            hr = LoadFx(&Parser);
                        }
                    }
                    Parser.LeaveList();
                    break;
                }
                break;
            }
        }
        Parser.LeaveList();
    }
    else
    {
        hr = DMUS_E_INVALIDCHUNK;
    }

    if (SUCCEEDED(hr))
    {
        m_DMUSObjectDesc.dwValidData |= DMUS_OBJ_LOADED;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::GetDescriptor"

HRESULT CDirectSoundBufferConfig::GetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    DPF_ENTER();

    HRESULT hr = S_OK;

    CopyMemory(pDesc, &m_DMUSObjectDesc, sizeof(m_DMUSObjectDesc));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::SetDescriptor"

HRESULT CDirectSoundBufferConfig::SetDescriptor(LPDMUS_OBJECTDESC pDesc)
{
    DPF_ENTER();

    HRESULT hr = E_INVALIDARG;
    DWORD dw = 0;

    if( pDesc->dwSize >= sizeof(DMUS_OBJECTDESC) )
    {
        if( pDesc->dwValidData & DMUS_OBJ_OBJECT )
        {
            m_DMUSObjectDesc.guidObject = pDesc->guidObject;
            dw |= DMUS_OBJ_OBJECT;
        }
        if( pDesc->dwValidData & DMUS_OBJ_NAME )
        {
            lstrcpyW(m_DMUSObjectDesc.wszName, pDesc->wszName);
            dw |= DMUS_OBJ_NAME;
        }
        if( pDesc->dwValidData & DMUS_OBJ_CATEGORY )
        {
            lstrcpyW(m_DMUSObjectDesc.wszCategory, pDesc->wszCategory);
            dw |= DMUS_OBJ_CATEGORY;
        }
        if( ( pDesc->dwValidData & DMUS_OBJ_FILENAME ) ||
            ( pDesc->dwValidData & DMUS_OBJ_FULLPATH ) )
        {
            memcpy( m_DMUSObjectDesc.wszFileName, pDesc->wszFileName, sizeof(WCHAR)*DMUS_MAX_FILENAME );
            dw |= (pDesc->dwValidData & (DMUS_OBJ_FILENAME | DMUS_OBJ_FULLPATH));
        }
        if ( pDesc->dwValidData & DMUS_OBJ_VERSION )
        {
            m_DMUSObjectDesc.vVersion = pDesc->vVersion;
            dw |= DMUS_OBJ_VERSION;
        }
        if( pDesc->dwValidData & DMUS_OBJ_DATE )
        {
            m_DMUSObjectDesc.ftDate = pDesc->ftDate;
            dw |= DMUS_OBJ_DATE;
        }

        m_DMUSObjectDesc.dwValidData |= dw;
        if( pDesc->dwValidData & (~dw) )
        {
            hr = S_FALSE; // there were extra fields we didn't parse;
            pDesc->dwValidData = dw;
        }
        else
        {
            hr = S_OK;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::ParseDescriptor"

HRESULT CDirectSoundBufferConfig::ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc)
{
    DPF_ENTER();
    CRiffParser Parser(pStream);
    RIFFIO ckMain;
	RIFFIO ckNext;
    RIFFIO ckUNFO;
    HRESULT hr = S_OK;
    DWORD dwValidData;

    Parser.EnterList(&ckMain);  
    if (Parser.NextChunk(&hr) && (ckMain.fccType == DMUS_FOURCC_DSBC_FORM))
    {
        dwValidData = 0;
        Parser.EnterList(&ckNext);
	    while(Parser.NextChunk(&hr))
	    {
		    switch(ckNext.ckid)
		    {
            case DMUS_FOURCC_GUID_CHUNK:
				hr = Parser.Read( &pDesc->guidObject, sizeof(GUID) );
				dwValidData |= DMUS_OBJ_OBJECT;
				break;
            case DMUS_FOURCC_VERSION_CHUNK:
				hr = Parser.Read( &pDesc->vVersion, sizeof(DMUS_VERSION) );
				dwValidData |= DMUS_OBJ_VERSION;
				break;
			case DMUS_FOURCC_CATEGORY_CHUNK:
				hr = Parser.Read( &pDesc->wszCategory, sizeof(pDesc->wszCategory) );
				dwValidData |= DMUS_OBJ_CATEGORY;
				break;
			case DMUS_FOURCC_DATE_CHUNK:
				hr = Parser.Read( &pDesc->ftDate, sizeof(FILETIME) );
                dwValidData |= DMUS_OBJ_DATE;
				break;
			case FOURCC_LIST:
				switch(ckNext.fccType)
				{
                case DMUS_FOURCC_UNFO_LIST:
                    Parser.EnterList(&ckUNFO);
                    while (Parser.NextChunk(&hr))
					{
						if (ckUNFO.ckid == DMUS_FOURCC_UNAM_CHUNK)
						{
							hr = Parser.Read(&pDesc->wszName, sizeof(pDesc->wszName));
                            dwValidData |= DMUS_OBJ_NAME;
						}
					}
                    Parser.LeaveList();
					break;            
				}
				break;
		    }
        }
        Parser.LeaveList();
    }
    else
    {
        hr = DMUS_E_CHUNKNOTFOUND;
    }

    if (SUCCEEDED(hr))
    {
        pDesc->dwValidData = dwValidData;
    }
    DPF_LEAVE_HRESULT(hr);

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::Save"

HRESULT CDirectSoundBufferConfig::Save(IStream *pStream, BOOL fClearDirty)
{
    DPF_ENTER();

    HRESULT hr = E_NOTIMPL;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::GetSizeMax"

HRESULT CDirectSoundBufferConfig::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
    DPF_ENTER();

    HRESULT hr = E_NOTIMPL;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::IsDirty"

HRESULT CDirectSoundBufferConfig::IsDirty()
{
    DPF_ENTER();

    HRESULT hr = E_NOTIMPL;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBufferConfig::LoadFx"

HRESULT CDirectSoundBufferConfig::LoadFx(CRiffParser *pParser)
{
    DPF_ENTER();

    RIFFIO ckNext;
    
    DSOUND_IO_DXDMO_HEADER ioDxDMOHdr;
    CDXDMODesc *pCurrDXDMODesc = NULL;

    HRESULT hr = S_OK;
    pParser->EnterList(&ckNext);
    while (pParser->NextChunk(&hr))
    {
        if(ckNext.ckid == DMUS_FOURCC_DSFX_CHUNK)
        {    
            hr = pParser->Read(&ioDxDMOHdr, sizeof(DSOUND_IO_DXDMO_HEADER));
            if(SUCCEEDED(hr) && (ioDxDMOHdr.dwReserved != 0 || ioDxDMOHdr.guidReserved != GUID_NULL))
            {
                DPF(DPFLVL_WARNING, "DSOUND_IO_DXDMO_HEADER chunk invalid: reserved fields must be zero");
                hr = DMUS_E_INVALIDCHUNK;
            }

            if (SUCCEEDED(hr) && (ioDxDMOHdr.guidDSFXClass == GUID_DSFX_SEND
#ifdef ENABLE_I3DL2SOURCE
                || ioDxDMOHdr.guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE
#endif
                ))
            {
                if (ioDxDMOHdr.guidSendBuffer == GUID_NULL)
                {
                    DPF(DPFLVL_WARNING, "DSOUND_IO_DXDMO_HEADER chunk invalid: send effect must specify a non-null guidSendBuffer");
                    hr = DMUS_E_INVALIDCHUNK;
                }
            }
            else
            {
                if (ioDxDMOHdr.guidSendBuffer != GUID_NULL)
                {
                    DPF(DPFLVL_WARNING, "DSOUND_IO_DXDMO_HEADER chunk invalid: not a send effect, so guidSendBuffer must be null");
                    hr = DMUS_E_INVALIDCHUNK;
                }
            }

            if(SUCCEEDED(hr) && (m_fLoadFlags & DSBCFG_DSBD))
            {
                pCurrDXDMODesc = NULL;

                CDXDMODesc *pDXDMODesc = NEW(CDXDMODesc);
                hr = HRFROMP(pDXDMODesc);
                if (SUCCEEDED(hr))
                {
                    pCurrDXDMODesc = pDXDMODesc;
                    pDXDMODesc->m_dwEffectFlags = ioDxDMOHdr.dwEffectFlags;
                    pDXDMODesc->m_guidDSFXClass = ioDxDMOHdr.guidDSFXClass;
                    pDXDMODesc->m_guidSendBuffer = ioDxDMOHdr.guidSendBuffer;
                    pDXDMODesc->m_dwReserved = ioDxDMOHdr.dwReserved;
                    pDXDMODesc->m_lSendLevel = 0;

                    if (!IsEqualGUID(pDXDMODesc->m_guidDSFXClass, GUID_DSFX_SEND)
#ifdef ENABLE_I3DL2SOURCE
                        && !IsEqualGUID(pDXDMODesc->m_guidDSFXClass, GUID_DSFX_STANDARD_I3DL2SOURCE)
#endif
                        )
                    {
                        hr = CoCreateInstance(pDXDMODesc->m_guidDSFXClass, NULL, CLSCTX_INPROC_SERVER, IID_IMediaObject, (void**)&pDXDMODesc->m_pMediaObject);
                    }

                    if (SUCCEEDED(hr))
                    {
                        AddDXDMODesc(pDXDMODesc);
                        // FIXME: we shouldn't be ferreting away all this info (m_pDXDMOMapList etc);
                        // once we have the DMOs, we don't need all this data just to call Clone()
                        m_fLoadFlags |= DSBCFG_DSFX;
                    }

                    if (FAILED(hr))
                    {
                        DELETE(pDXDMODesc);
                    }
                }
            }
        }
        else if(ckNext.ckid == DMUS_FOURCC_DSFX_DATA && pCurrDXDMODesc)
        {    
            if (pCurrDXDMODesc->m_pMediaObject)
            {
                IPersistStream* pPersistStream = NULL;
                hr = pCurrDXDMODesc->m_pMediaObject->QueryInterface(IID_IPersistStream,(void**)&pPersistStream);
                if (SUCCEEDED(hr))
                {
                    pParser->MarkPosition();
                    hr = pPersistStream->Load(pParser->GetStream());
                    pParser->SeekForward();
                    pPersistStream->Release();
                }
            }
            // Special case for Send Effects -- Read the send level manually.  The
            // Send effect doesn't implement IPersistStream.
            else if (IsEqualGUID(pCurrDXDMODesc->m_guidDSFXClass, GUID_DSFX_SEND))
            {
                hr = pParser->Read((void*)&pCurrDXDMODesc->m_lSendLevel, sizeof(long));
                if (SUCCEEDED(hr))
                {
                    // validate the SendLevel
                    if (!((pCurrDXDMODesc->m_lSendLevel <= 0) && (pCurrDXDMODesc->m_lSendLevel >= -10000)))
                    {
                        // Invalid Send Level
                        pCurrDXDMODesc->m_lSendLevel = 0;
                        hr = DSERR_INVALIDPARAM;
                    }
                }
            }
            pCurrDXDMODesc = NULL;    // clear this just in case 
        }
    }
    pParser->LeaveList();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dscap.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscap.h
 *  Content:    DirectSoundCapture object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   5/25/97    johnnyl Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifndef __DSCAP_H__
#define __DSCAP_H__

#ifdef __cplusplus

//
// The main DirectSoundCapture object
//

class CDirectSoundCapture : public CUnknown
{
    friend class CDirectSoundCaptureBuffer;
    friend class CDirectSoundAdministrator;
    friend class CDirectSoundPrivate;
    friend class CDirectSoundFullDuplex;

private:

    CCaptureDevice *                    m_pDevice;      // The audio device
    CList<CDirectSoundCaptureBuffer *>  m_lstBuffers;   // List of capture buffers
    DSCCAPS                             m_dscCaps;      // Device caps
    HKEY                                m_hkeyParent;   // Root key for this device
    HRESULT                             m_hrInit;       // Has the object been initialized?
    CDirectSoundFullDuplex *            m_pFullDuplex;  // Owning full-duplex object

    // Interfaces
    CImpDirectSoundCapture<CDirectSoundCapture> *m_pImpDirectSoundCapture;

public:

    CDirectSoundCapture();
    CDirectSoundCapture(CUnknown*);
    virtual ~CDirectSoundCapture();

    // Creation
    virtual HRESULT Initialize(LPCGUID, CDirectSoundFullDuplex *);
    HRESULT IsInit(void) {return m_hrInit;}

    // Functionality versioning
    virtual void SetDsVersion(DSVERSION);

    // Caps
    virtual HRESULT GetCaps(LPDSCCAPS);

    // Buffers
    virtual HRESULT CreateCaptureBuffer(LPCDSCBUFFERDESC, CDirectSoundCaptureBuffer **);
    virtual void AddBufferToList(CDirectSoundCaptureBuffer* pBuffer) {m_lstBuffers.AddNodeToList(pBuffer);}
    virtual void RemoveBufferFromList(CDirectSoundCaptureBuffer* pBuffer) {m_lstBuffers.RemoveDataFromList(pBuffer);}

    // AEC
    virtual BOOL HasMicrosoftAEC(void);
};


//
// The DirectSoundCapture Buffer object
//

class CDirectSoundCaptureBuffer : public CUnknown
{
    friend class CDirectSoundCapture;
    friend class CDirectSoundAdministrator;

private:

    CDirectSoundCapture *   m_pDSC;                     // Parent DirectSoundCapture object
    CCaptureWaveBuffer *    m_pDeviceBuffer;            // The device buffer
    LPWAVEFORMATEX          m_pwfxFormat;               // Current format
    DWORD                   m_dwFXCount;                // Number of capture effects
    LPDSCEFFECTDESC         m_pDSCFXDesc;               // Array of capture effects
    DWORD                   m_dwBufferFlags;            // Creation flags
    DWORD                   m_dwBufferBytes;            // Buffer size
    HWND                    m_hWndFocus;                // Focus window
    HRESULT                 m_hrInit;                   // Has the object been initialized?
    CCaptureEffectChain *   m_fxChain;                  // The effects chain object

    // Interfaces
    CImpDirectSoundCaptureBuffer<CDirectSoundCaptureBuffer> *m_pImpDirectSoundCaptureBuffer;
    CImpDirectSoundNotify<CDirectSoundCaptureBuffer> *m_pImpDirectSoundNotify;

    // Methods
    HRESULT ChangeFocus(HWND hWndFocus);

public:

    CDirectSoundCaptureBuffer(CDirectSoundCapture *);
    virtual ~CDirectSoundCaptureBuffer();

    // Creation
    virtual HRESULT Initialize(LPCDSCBUFFERDESC);
    HRESULT IsInit(void) {return m_hrInit;}

    // Caps
    virtual HRESULT GetCaps(LPDSCBCAPS);

    // Buffer properties
    virtual HRESULT GetFormat(LPWAVEFORMATEX, LPDWORD);
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

    // Buffer function
    virtual HRESULT GetCurrentPosition(LPDWORD, LPDWORD);
    virtual HRESULT GetStatus(LPDWORD);
    virtual HRESULT Start(DWORD);
    virtual HRESULT Stop(void);

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD);
    virtual HRESULT Unlock(LPVOID, DWORD, LPVOID, DWORD);

    // New DirectSound 7.1 methods
    virtual HRESULT SetVolume(LONG);
    virtual HRESULT GetVolume(LPLONG);
    virtual HRESULT SetMicVolume(LONG);
    virtual HRESULT GetMicVolume(LPLONG);
    virtual HRESULT EnableMic(BOOL);
    virtual HRESULT YieldFocus();
    virtual HRESULT ClaimFocus();
    virtual HRESULT SetFocusHWND(HWND);
    virtual HRESULT GetFocusHWND(HWND *);
    virtual HRESULT EnableFocusNotifications(HANDLE);

    // New DirectSound 8.0 methods
    HRESULT GetObjectInPath(REFGUID, DWORD, REFGUID, LPVOID *);
    HRESULT GetFXStatus(DWORD, LPDWORD);
    BOOL    HasFX()             {return m_fxChain != NULL;}
    BOOL    NeedsMicrosoftAEC() {return m_fxChain ? m_fxChain->NeedsMicrosoftAEC() : FALSE;}
};

#endif // __cplusplus

#endif // __DSCAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsbufcfg.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbufcfg.h
 *  Content:    DirectSound Buffer Descriptor.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/17/99    jimge   Created.
 *  11/24/99    petchey Completed implementation.
 *
 ***************************************************************************/

#ifndef __DSBUFCFG_H__
#define __DSBUFCFG_H__

#ifdef __cplusplus

//>>>>>>>>>>>>>> should this be inside a DSOUND id header?
#include "dmusicf.h"

#define DMUS_E_INVALID_FX_HDR E_FAIL
#define DMUS_E_FX_HDR_NOT_FIRST_CK E_FAIL

#define DSBC_PARTIALLOAD_S_OK   (1 << 1)
#define DSBC_PARTIALLOAD_E_FAIL (1 << 2)

class CDirectSoundSink;
class CRiffParser;

enum {
    DSBCFG_DSBD = 0x00000001,
    DSBCFG_BSID = 0x00000002,
    DSBCFG_DS3D = 0x00000004,
    DSBCFG_DSFX = 0x00000008,
};

class CDirectSoundBufferConfig
    : public CUnknown
{
friend CDirectSoundSink;
friend CEffectChain;
friend CEffect;

protected:
    struct CDXDMODesc
    {
        DWORD m_dwEffectFlags;
        GUID m_guidDSFXClass;
        GUID m_guidSendBuffer;
        DWORD m_dwReserved;
        IMediaObject* m_pMediaObject;
        long m_lSendLevel;
        CDXDMODesc* pNext;
    };

private:
    void AddDXDMODesc(CDXDMODesc *pDXDMODesc)
    {
        if ( m_pDXDMOMapList )
        {
            CDXDMODesc *pObj = m_pDXDMOMapList;
            while(pObj->pNext)
                pObj = pObj->pNext;
            pObj->pNext = pDXDMODesc;
        }
        else
        {
            m_pDXDMOMapList = pDXDMODesc;
        }
        m_dwDXDMOMapCount++;
    };

public:
    CDirectSoundBufferConfig();
    virtual ~CDirectSoundBufferConfig();

    // IUnknown
    //
    HRESULT QueryInterface(REFIID riid,BOOL fInternalQuery,LPVOID *ppvObj);

    // IPersist
    //
    HRESULT GetClassID(CLSID *pClassID);

    // IPersistStream
    //
    HRESULT IsDirty();
    HRESULT Load(IStream *pStream);
    HRESULT Save(IStream *pStream, BOOL fClearDirty);
    HRESULT GetSizeMax(ULARGE_INTEGER* pcbSize);

    // IDirectMusicObject
    //
    HRESULT GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    HRESULT SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    HRESULT ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);

protected:
    DWORD                    m_fLoadFlags;
    DMUS_OBJECTDESC          m_DMUSObjectDesc;  // DirectMusicObjectDescription
    DSOUND_IO_DSBUFFERDESC   m_DSBufferDesc;
    DSOUND_IO_3D             m_DS3DDesc;
    LPDWORD                  m_pdwFuncIDs;      // Array of functional IDs associated with the bus
    DWORD                    m_dwFuncIDsCount;  // Number of functional IDs
    CDXDMODesc              *m_pDXDMOMapList;   // Pointer to a list of FX descriptions
    DWORD                    m_dwDXDMOMapCount;

    HRESULT LoadFx(CRiffParser *pParser);

private:
    CImpPersistStream<CDirectSoundBufferConfig> *m_pImpPersistStream;
    CImpDirectMusicObject<CDirectSoundBufferConfig> *m_pImpDirectMusicObject;
};

#endif // __cplusplus

#endif // __DSBUFCFG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsbuf.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbuf.cpp
 *  Content:    DirectSound Buffer object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *  1999-2001   duganp  Many changes, fixes and updates
 *
 ***************************************************************************/

#include "dsoundi.h"

inline DWORD DSBCAPStoDSBPLAY(DWORD dwCaps)     {return (dwCaps >> 1) & DSBPLAY_LOCMASK;}
inline DWORD DSBCAPStoDSBSTATUS(DWORD dwCaps)   {return (dwCaps << 1) & DSBSTATUS_LOCMASK;}
inline DWORD DSBPLAYtoDSBCAPS(DWORD dwPlay)     {return (dwPlay << 1) & DSBCAPS_LOCMASK;}
inline DWORD DSBPLAYtoDSBSTATUS(DWORD dwPlay)   {return (dwPlay << 2) & DSBSTATUS_LOCMASK;}
inline DWORD DSBSTATUStoDSBCAPS(DWORD dwStatus) {return (dwStatus >> 1) & DSBCAPS_LOCMASK;}
inline DWORD DSBSTATUStoDSBPLAY(DWORD dwStatus) {return (dwStatus >> 2) & DSBPLAY_LOCMASK;}


/***************************************************************************
 *
 *  CDirectSoundBuffer
 *
 *  Description:
 *      DirectSound buffer object constructor.
 *
 *  Arguments:
 *      CDirectSound * [in]: parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::CDirectSoundBuffer"

CDirectSoundBuffer::CDirectSoundBuffer(CDirectSound *pDirectSound)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundBuffer);

    // Initialize defaults
    m_pDirectSound = pDirectSound;
    m_dwStatus = 0;

    InitStruct(&m_dsbd, sizeof(m_dsbd));

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundBuffer
 *
 *  Description:
 *      DirectSound buffer object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::~CDirectSoundBuffer"

CDirectSoundBuffer::~CDirectSoundBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundBuffer);

    // Free memory
    MEMFREE(m_dsbd.lpwfxFormat);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateBufferStatusFlags
 *
 *  Description:
 *      Converts a set of VAD_BUFFERSTATE_* flags to DSBSTATUS_* flags.
 *
 *  Arguments:
 *      DWORD [in]: VAD_BUFFERSTATE_* flags.
 *      LPDWORD [in/out]: current buffer flags.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundBuffer::UpdateBufferStatusFlags"

void CDirectSoundBuffer::UpdateBufferStatusFlags(DWORD dwState, LPDWORD pdwStatus)
{
    const DWORD dwStateMask = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING;

    DPF_ENTER();

    dwState &= dwStateMask;

    if(!(dwState & VAD_BUFFERSTATE_STARTED))
    {
        ASSERT(!(dwState & VAD_BUFFERSTATE_LOOPING));
        dwState &= ~VAD_BUFFERSTATE_LOOPING;
    }

    if(dwState & VAD_BUFFERSTATE_STARTED)
    {
        *pdwStatus |= DSBSTATUS_PLAYING;
    }
    else
    {
        *pdwStatus &= ~DSBSTATUS_PLAYING;
    }

    if(dwState & VAD_BUFFERSTATE_LOOPING)
    {
        *pdwStatus |= DSBSTATUS_LOOPING;
    }
    else
    {
        *pdwStatus &= ~DSBSTATUS_LOOPING;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CDirectSoundPrimaryBuffer
 *
 *  Description:
 *      DirectSound primary buffer object constructor.
 *
 *  Arguments:
 *      CDirectSound * [in]: pointer to the parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::CDirectSoundPrimaryBuffer"

CDirectSoundPrimaryBuffer::CDirectSoundPrimaryBuffer(CDirectSound *pDirectSound)
    : CDirectSoundBuffer(pDirectSound)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundPrimaryBuffer);

    // Initialize defaults
    m_pImpDirectSoundBuffer = NULL;
    m_pDeviceBuffer = NULL;
    m_p3dListener = NULL;
    m_pPropertySet = NULL;
    m_dwRestoreState = VAD_BUFFERSTATE_STOPPED | VAD_BUFFERSTATE_WHENIDLE;
    m_fWritePrimary = FALSE;
    m_ulUserRefCount = 0;
    m_hrInit = DSERR_UNINITIALIZED;
    m_bDataLocked = FALSE; 

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundPrimaryBuffer
 *
 *  Description:
 *      DirectSound primary buffer object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::~CDirectSoundPrimaryBuffer"

CDirectSoundPrimaryBuffer::~CDirectSoundPrimaryBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundBuffer);

    // Make sure to give up WRITEPRIMARY access
    if(m_pDeviceBuffer)
    {
        SetPriority(DSSCL_NONE);
    }

    // Free all interfaces
    DELETE(m_pImpDirectSoundBuffer);

    // Free owned objects
    ABSOLUTE_RELEASE(m_p3dListener);
    ABSOLUTE_RELEASE(m_pPropertySet);

    // Free the device buffer
    RELEASE(m_pDeviceBuffer);

    // The owning DirectSound object is responsible for updating the global
    // focus state.

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes a buffer object.  If this function fails, the object
 *      should be immediately deleted.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: buffer description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Initialize"

HRESULT CDirectSoundPrimaryBuffer::Initialize(LPCDSBUFFERDESC pDesc)
{
    VADRBUFFERCAPS          vrbc;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(IsInit() == DSERR_UNINITIALIZED);
    ASSERT(pDesc);

    // Create the device buffer
    hr = m_pDirectSound->m_pDevice->CreatePrimaryBuffer(pDesc->dwFlags, m_pDirectSound, &m_pDeviceBuffer);

    // Attempt to create the property set object
    if(SUCCEEDED(hr))
    {
        m_pPropertySet = NEW(CDirectSoundPropertySet(this));
        hr = HRFROMP(m_pPropertySet);

        if(SUCCEEDED(hr))
        {
            hr = m_pPropertySet->Initialize();
        }

        if(SUCCEEDED(hr))
        {
            // We don't care if this fails
            m_pPropertySet->AcquireResources(m_pDeviceBuffer);
        }
    }

    // Attempt to create the 3D listener
    if(SUCCEEDED(hr) && (pDesc->dwFlags & DSBCAPS_CTRL3D))
    {
        m_p3dListener = NEW(CDirectSound3dListener(this));
        hr = HRFROMP(m_p3dListener);

        if(SUCCEEDED(hr))
        {
            hr = m_p3dListener->Initialize(m_pDeviceBuffer);
        }
    }

    // Register the standard buffer interface with the interface manager
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(this, IID_IDirectSoundBuffer, this, &m_pImpDirectSoundBuffer);
    }

    // Build the local buffer description
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->GetCaps(&vrbc);
    }

    if(SUCCEEDED(hr))
    {
        m_dsbd.dwFlags = (vrbc.dwFlags & DSBCAPS_LOCMASK);
        m_dsbd.dwBufferBytes = vrbc.dwBufferBytes;

        m_dsbd.lpwfxFormat = AllocDefWfx();
        hr = HRFROMP(m_dsbd.lpwfxFormat);
    }

    // If the 3D listener has been created, he's already registered the
    // 3D listener interface.
    if(SUCCEEDED(hr) && m_p3dListener)
    {
        m_dsbd.dwFlags |= DSBCAPS_CTRL3D;
    }

    // Handle buffer caps flags change
    if(SUCCEEDED(hr))
    {
        hr = SetBufferFlags(pDesc->dwFlags);
    }

    // Handle priority change
    if(SUCCEEDED(hr))
    {
        hr = SetPriority(m_pDirectSound->m_dsclCooperativeLevel.dwPriority);
    }

    // The DirectSound object creating this buffer is responsible for updating
    // the global focus state.

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Queries capabilities for the buffer.
 *
 *  Arguments:
 *      LPDSBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetCaps"

HRESULT CDirectSoundPrimaryBuffer::GetCaps(LPDSBCAPS pDsbCaps)
{
    DPF_ENTER();

    ASSERT(LXOR(m_dsbd.dwFlags & DSBCAPS_LOCSOFTWARE, m_dsbd.dwFlags & DSBCAPS_LOCHARDWARE));

    pDsbCaps->dwFlags = m_dsbd.dwFlags;
    pDsbCaps->dwBufferBytes = m_dsbd.dwBufferBytes;
    pDsbCaps->dwUnlockTransferRate = 0;
    pDsbCaps->dwPlayCpuOverhead = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  OnCreateSoundBuffer
 *
 *  Description:
 *      Called in response to an application calling
 *      CreateSoundBuffer(DSBCAPS_PRIMARYBUFFER).
 *
 *  Arguments:
 *      DWORD [in]: new buffer flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::OnCreateSoundBuffer"

HRESULT CDirectSoundPrimaryBuffer::OnCreateSoundBuffer(DWORD dwFlags)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // COMPATCOMPAT: in previous versions of DirectSound, calling
    // CreateSoundBuffer(PRIMARYBUFFER) once would change the buffer flags,
    // but calling it twice would just return a pointer to the same,
    // unmodified buffer.  I've introduced new behavior in this version
    // that would allow an app to modify the capabilities of the primary
    // buffer on-the-fly by calling CreateSoundBuffer(PRIMARYBUFFER) more
    // than once.  This could potentially free interfaces that the app
    // will later try to use.  One way to fix this would be to add a data
    // member to the DirectSound or primary buffer object that stores
    // whether or not the application has created a primary buffer already.

    // The steps outlined above are now implemented here:
    if(m_ulUserRefCount)
    {
        RPF((dwFlags == m_dsbd.dwFlags) ? DPFLVL_WARNING : DPFLVL_ERROR, "The primary buffer already exists.  Any changes made to the buffer description will be ignored.");
    }
    else
    {
        hr = SetBufferFlags(dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        AddRef();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetBufferFlags
 *
 *  Description:
 *      Changes capabilities for the buffer.  This function is also
 *      responsible for creating and freeing interfaces.
 *
 *  Arguments:
 *      DWORD [in]: new buffer flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetBufferFlags"

HRESULT CDirectSoundPrimaryBuffer::SetBufferFlags(DWORD dwFlags)
{
    HRESULT                 hr              = DS_OK;
    DWORD                   dwVolPanCaps;

    DPF_ENTER();

    // Make sure we can handle the requested flags
    if((dwFlags & DSBCAPS_CTRL3D) && !m_p3dListener)
    {
        RPF(DPFLVL_ERROR, "No 3D listener support");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Not all capabilities of the DirectSound primary buffer map to the
    // methods of the device primary buffer.  Specifically, attenuation is
    // handled by the render device.  Let's check these flags before
    // proceeding.
    if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLATTENUATION))
    {
        hr = m_pDirectSound->m_pDevice->GetVolumePanCaps(&dwVolPanCaps);

        if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLVOLUME) && !(dwVolPanCaps & DSBCAPS_CTRLVOLUME))
        {
            RPF(DPFLVL_ERROR, "The device does not support CTRLVOLUME");
            hr = DSERR_CONTROLUNAVAIL;
        }

        if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLPAN) && !(dwVolPanCaps & DSBCAPS_CTRLPAN))
        {
            RPF(DPFLVL_ERROR, "The device does not support CTRLPAN");
            hr = DSERR_CONTROLUNAVAIL;
        }
    }

    // Fix up the 3D listener interface
    if(SUCCEEDED(hr) && ((m_dsbd.dwFlags & DSBCAPS_CTRL3D) != (dwFlags & DSBCAPS_CTRL3D)))
    {
        if(dwFlags & DSBCAPS_CTRL3D)
        {
            DPF(DPFLVL_INFO, "Primary buffer becoming CTRL3D.  Registering IID_IDirectSound3DListener");
            hr = RegisterInterface(IID_IDirectSound3DListener, m_p3dListener->m_pImpDirectSound3dListener, m_p3dListener->m_pImpDirectSound3dListener);
        }
        else
        {
            DPF(DPFLVL_INFO, "Primary buffer becoming ~CTRL3D.  Unregistering IID_IDirectSound3DListener");
            hr = UnregisterInterface(IID_IDirectSound3DListener);
        }
    }

    // Save buffer flags.  We're assuming that the buffer location has
    // already been saved to m_dsbd.dwFlags at this point.
    if(SUCCEEDED(hr))
    {
        m_dsbd.dwFlags = (dwFlags & ~DSBCAPS_LOCMASK) | (m_dsbd.dwFlags & DSBCAPS_LOCMASK);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Retrieves the format for the given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives the format.
 *      LPDWORD [in/out]: size of the format structure.  On entry, this
 *                        must be initialized to the size of the structure.
 *                        On exit, this will be filled with the size that
 *                        was required.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetFormat"

HRESULT CDirectSoundPrimaryBuffer::GetFormat(LPWAVEFORMATEX pwfxFormat, LPDWORD pdwSize)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CopyWfxApi(m_dsbd.lpwfxFormat, pwfxFormat, pdwSize);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the format for a given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: new format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetFormat"

HRESULT CDirectSoundPrimaryBuffer::SetFormat(LPCWAVEFORMATEX pwfxFormat)
{
    LPWAVEFORMATEX              pwfxLocal   = NULL;
    BOOL                        fActive     = MAKEBOOL(m_dwStatus & DSBSTATUS_ACTIVE);
    HRESULT                     hr          = DS_OK;
    CNode<CDirectSound *> *     pNode;
    BOOL bRewriteStartupSilence             = FALSE;

    DPF_ENTER();

    // Check access rights
    if(m_pDirectSound->m_dsclCooperativeLevel.dwPriority < DSSCL_PRIORITY)
    {
        RPF(DPFLVL_ERROR, "Cooperative level is not PRIORITY");
        hr = DSERR_PRIOLEVELNEEDED;
    }

    // Save a local copy of the format
    if(SUCCEEDED(hr))
    {
        pwfxLocal = CopyWfxAlloc(pwfxFormat);
        hr = HRFROMP(pwfxLocal);
    }

    // We can only change the format if we're active
    if(SUCCEEDED(hr) && !fActive)
    {
        // The Administrator says we're out of focus.  If there's not really anyone
        // else in focus, we're going to cheat and set the format anyway.

        // DuganP: This is weird - presumably done so fewer apps will break when the
        // user switches focus away from them temporarily.  There's the problem that
        // if multiple apps are in this state, whoever's last to set the format wins.
        // However, app-compat probably means we can't touch this code any more, so...

        for(pNode = g_pDsAdmin->m_lstDirectSound.GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            if(pNode->m_data && SUCCEEDED(pNode->m_data->IsInit()))
            {
                if(pNode->m_data->m_pPrimaryBuffer && this != pNode->m_data->m_pPrimaryBuffer && SUCCEEDED(pNode->m_data->m_pPrimaryBuffer->IsInit()))
                {
                    if(DSBUFFERFOCUS_INFOCUS == g_pDsAdmin->GetBufferFocusState(pNode->m_data->m_pPrimaryBuffer))
                    {
                        // NOTE: We added a "&& pNode->m_data->GetOwnerProcessId() != GetOwnerProcessId())"
                        // clause to fix WinME bug 120317, and we removed it again to fix DX8 bug 40627.

                        // We found an in-focus primary buffer [in another app], so fail.
                        break;
                    }
                }
            }
        }

        if(!pNode)
        {
            fActive = TRUE;
        }
    }

    // Apply the format to the device
    if(SUCCEEDED(hr))
    {
        if( m_fWritePrimary )
        {        
            //
            // See if this a WRITEPRIMARY app that's about to change to a new sample size.
            // If so, silence will need to be re-written for the new sample size
            // (providing the app hasn't locked any data yet).
            //
            LPWAVEFORMATEX pwfxOld;
            DWORD dwSize;
            HRESULT hrTmp = m_pDirectSound->m_pDevice->GetGlobalFormat(NULL, &dwSize);
            if(SUCCEEDED(hrTmp))
            {
                pwfxOld = (LPWAVEFORMATEX)MEMALLOC_A(BYTE, dwSize);
                if( pwfxOld )
                {
                    hrTmp = m_pDirectSound->m_pDevice->GetGlobalFormat(pwfxOld, &dwSize);
                    if( SUCCEEDED( hr ) )
                    {
                        if( pwfxLocal->wBitsPerSample != pwfxOld->wBitsPerSample )
                        {
                            bRewriteStartupSilence = TRUE;
                        }
                    }                                    
                    MEMFREE(pwfxOld);
                }
            }                
        }    
    
        if(fActive)
        {
            DPF(DPFLVL_INFO, "Setting the format on device " DPF_GUID_STRING, DPF_GUID_VAL(m_pDirectSound->m_pDevice->m_pDeviceDescription->m_guidDeviceId));

            // If we're WRITEPRIMARY, the format needs to be exact.  Otherwise,
            // we'll try to set the next closest format.  We're checking the
            // actual focus priority instead of our local writeprimary flag
            // in case the buffer is lost.
            if(DSSCL_WRITEPRIMARY == m_pDirectSound->m_dsclCooperativeLevel.dwPriority)
            {
                hr = m_pDirectSound->SetDeviceFormatExact(pwfxLocal);
            }
            else
            {
                hr = m_pDirectSound->SetDeviceFormat(pwfxLocal);
            }
        }
        else
        {
            DPF(DPFLVL_INFO, "NOT setting the format on device " DPF_GUID_STRING, DPF_GUID_VAL(m_pDirectSound->m_pDevice->m_pDeviceDescription->m_guidDeviceId));
        }
    }

    // Update the stored format
    if(SUCCEEDED(hr))
    {
        MEMFREE(m_dsbd.lpwfxFormat);
        m_dsbd.lpwfxFormat = pwfxLocal;
        
        if( bRewriteStartupSilence && !m_bDataLocked )
        {        
            // Refill the buffer with silence in the new sample size format,
            // only if the primary buffer was started playing before Locking any data.
            DSBUFFERFOCUS bfFocus = g_pDsAdmin->GetBufferFocusState(this);
            if( bfFocus == DSBUFFERFOCUS_INFOCUS)
            {
                ASSERT( m_fWritePrimary );
                // Request write access first
                HRESULT hrTmp = m_pDeviceBuffer->RequestWriteAccess(TRUE);
                if(SUCCEEDED(hrTmp))
                {
                    // Fill the buffer with silence.  At this point, we MUST be WRITEPRIMARY.
                    ::FillSilence(m_pDeviceBuffer->m_pSysMemBuffer->GetPlayBuffer(), m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat->wBitsPerSample);
                    hrTmp = m_pDeviceBuffer->CommitToDevice(0, m_pDeviceBuffer->m_pSysMemBuffer->GetSize());
#ifdef DEBUG                    
                    if(FAILED( hrTmp ) )
                    {
                        // Not a catastrophic failure if we fail this
                        DPF(DPFLVL_WARNING, "CommitToDevice for buffer at 0x%p failed (%ld) ", this, hrTmp);
                    }
#endif                    
                }   
#ifdef DEBUG                
                else
                {
                    // again, not a catastrophic failure
                    DPF(DPFLVL_WARNING, "RequestWriteAccess failed for buffer at 0x%p failed with %ld", this, hrTmp );
                }
#endif                
            }
        }            
                
    }
    else
    {
        MEMFREE(pwfxLocal);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetFrequency
 *
 *  Description:
 *      Retrieves frequency for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetFrequency"

HRESULT CDirectSoundPrimaryBuffer::GetFrequency(LPDWORD pdwFrequency)
{
    DPF_ENTER();

    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLFREQUENCY");

    DPF_LEAVE_HRESULT(DSERR_CONTROLUNAVAIL);

    return DSERR_CONTROLUNAVAIL;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Retrieves frequency for the given buffer.
 *
 *  Arguments:
 *      DWORD [in]: frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetFrequency"

HRESULT CDirectSoundPrimaryBuffer::SetFrequency(DWORD dwFrequency)
{
    DPF_ENTER();

    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLFREQUENCY");

    DPF_LEAVE_HRESULT(DSERR_CONTROLUNAVAIL);

    return DSERR_CONTROLUNAVAIL;
}


/***************************************************************************
 *
 *  GetPan
 *
 *  Description:
 *      Retrieves pan for the given buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetPan"

HRESULT CDirectSoundPrimaryBuffer::GetPan(LPLONG plPan)
{
    HRESULT                 hr      = DS_OK;
    DSVOLUMEPAN             dsvp;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLPAN))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLPAN");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Ask the device for global attenuation and convert to pan
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->m_pDevice->GetGlobalAttenuation(&dsvp);
    }

    if(SUCCEEDED(hr))
    {
        *plPan = dsvp.lPan;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPan
 *
 *  Description:
 *      Sets the pan for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetPan"

HRESULT CDirectSoundPrimaryBuffer::SetPan(LONG lPan)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLPAN))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLPAN");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Set device pan
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->SetDevicePan(lPan);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetVolume
 *
 *  Description:
 *      Retrieves volume for the given buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetVolume"

HRESULT CDirectSoundPrimaryBuffer::GetVolume(LPLONG plVolume)
{
    HRESULT                 hr      = DS_OK;
    DSVOLUMEPAN             dsvp;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLVOLUME))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Ask the device for global attenuation and convert to volume
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->m_pDevice->GetGlobalAttenuation(&dsvp);
    }

    if(SUCCEEDED(hr))
    {
        *plVolume = dsvp.lVolume;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the volume for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetVolume"

HRESULT CDirectSoundPrimaryBuffer::SetVolume(LONG lVolume)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLVOLUME))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Set device volume
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->SetDeviceVolume(lVolume);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetNotificationPositions"

HRESULT CDirectSoundPrimaryBuffer::SetNotificationPositions(DWORD dwCount, LPCDSBPOSITIONNOTIFY paNotes)
{
    DPF_ENTER();

    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLPOSITIONNOTIFY");

    DPF_LEAVE_HRESULT(DSERR_CONTROLUNAVAIL);

    return DSERR_CONTROLUNAVAIL;
}


/***************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives play cursor position.
 *      LPDWORD [out]: receives write cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetCurrentPosition"

HRESULT CDirectSoundPrimaryBuffer::GetCurrentPosition(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwPlay;
    DWORD                   dwWrite;

    DPF_ENTER();

    // Check for BUFFERLOST
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        hr = DSERR_BUFFERLOST;
    }

    // Check access rights
    if(SUCCEEDED(hr) && !m_fWritePrimary)
    {
        RPF(DPFLVL_ERROR, "Cooperative level is not WRITEPRIMARY");
        hr = DSERR_PRIOLEVELNEEDED;
    }

    // We save the position to local variables so that the object we're
    // calling into doesn't have to worry about whether one or both of
    // the arguments are NULL.
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->GetCursorPosition(&dwPlay, &dwWrite);
    }

    // Block-align the positions
    if(SUCCEEDED(hr))
    {
        dwPlay = BLOCKALIGN(dwPlay, m_dsbd.lpwfxFormat->nBlockAlign);
        dwWrite = BLOCKALIGN(dwWrite, m_dsbd.lpwfxFormat->nBlockAlign);
    }

    // Apply app-hacks
    if(SUCCEEDED(hr) && m_pDirectSound->m_ahAppHacks.lCursorPad)
    {
        dwPlay = PadCursor(dwPlay, m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat, m_pDirectSound->m_ahAppHacks.lCursorPad);
        dwWrite = PadCursor(dwWrite, m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat, m_pDirectSound->m_ahAppHacks.lCursorPad);
    }

    if(SUCCEEDED(hr) && (m_pDirectSound->m_ahAppHacks.vdtReturnWritePos & m_pDirectSound->m_pDevice->m_vdtDeviceType))
    {
        dwPlay = dwWrite;
    }

    if(SUCCEEDED(hr) && m_pDirectSound->m_ahAppHacks.swpSmoothWritePos.fEnable)
    {
        dwWrite = PadCursor(dwPlay, m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat, m_pDirectSound->m_ahAppHacks.swpSmoothWritePos.lCursorPad);
    }

    // Success
    if(SUCCEEDED(hr) && pdwPlay)
    {
        *pdwPlay = dwPlay;
    }

    if(SUCCEEDED(hr) && pdwWrite)
    {
        *pdwWrite = dwWrite;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetCurrentPosition
 *
 *  Description:
 *      Sets the current play position for a given buffer.
 *
 *  Arguments:
 *      DWORD [in]: new play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetCurrentPosition"

HRESULT CDirectSoundPrimaryBuffer::SetCurrentPosition(DWORD dwPlayCursor)
{
    DPF_ENTER();

    RPF(DPFLVL_ERROR, "Primary buffers don't support SetCurrentPosition");

    DPF_LEAVE_HRESULT(DSERR_INVALIDCALL);

    return DSERR_INVALIDCALL;
}


/***************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Retrieves status for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the status.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetStatus"

HRESULT CDirectSoundPrimaryBuffer::GetStatus(LPDWORD pdwStatus)
{
    HRESULT                 hr          = DS_OK;
    DWORD                   dwStatus;
    DWORD                   dwState;

    DPF_ENTER();

    // Update the buffer status.  If we're lost, that's the only state we
    // care about
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        dwStatus = DSBSTATUS_BUFFERLOST;
    }
    else
    {
        // Get the current device buffer state
        hr = m_pDeviceBuffer->GetState(&dwState);

        if(SUCCEEDED(hr))
        {
            dwStatus = m_dwStatus;
            UpdateBufferStatusFlags(dwState, &m_dwStatus);
        }

        // Fill in the buffer location
        if(SUCCEEDED(hr))
        {
            m_dwStatus |= DSBCAPStoDSBSTATUS(m_dsbd.dwFlags);
        }

        if(SUCCEEDED(hr))
        {
            dwStatus = m_dwStatus;
        }
    }

    // Mask off bits that shouldn't get back to the app
    if(SUCCEEDED(hr))
    {
        dwStatus &= DSBSTATUS_USERMASK;
    }

    if(SUCCEEDED(hr) && !(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        dwStatus &= ~DSBSTATUS_LOCDEFERMASK;
    }

    if(SUCCEEDED(hr) && pdwStatus)
    {
        *pdwStatus = dwStatus;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Play
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      DWORD [in]: priority.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Play"

HRESULT CDirectSoundPrimaryBuffer::Play(DWORD dwPriority, DWORD dwFlags)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Validate flags
    if(dwFlags != DSBPLAY_LOOPING)
    {
        RPF(DPFLVL_ERROR, "The only valid flag for primary buffers is LOOPING, which must always be set");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && dwPriority)
    {
        RPF(DPFLVL_ERROR, "Priority is not valid for primary buffers");
        hr = DSERR_INVALIDPARAM;
    }

    // Check for BUFFERLOST
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        hr = DSERR_BUFFERLOST;
    }

    // Set the buffer state
    if(SUCCEEDED(hr))
    {
        hr = SetBufferState(VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops playing the given buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Stop"

HRESULT CDirectSoundPrimaryBuffer::Stop(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check for BUFFERLOST
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        hr = DSERR_BUFFERLOST;
    }

    // Set the buffer state
    if(SUCCEEDED(hr))
    {
        hr = SetBufferState(VAD_BUFFERSTATE_STOPPED);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetBufferState
 *
 *  Description:
 *      Sets the buffer play/stop state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetBufferState"

HRESULT CDirectSoundPrimaryBuffer::SetBufferState(DWORD dwNewState)
{
    DWORD                   dwOldState;
    HRESULT                 hr;

    DPF_ENTER();

    if(m_fWritePrimary)
    {
        dwNewState &= ~VAD_BUFFERSTATE_WHENIDLE;
    }
    else
    {
        dwNewState |= VAD_BUFFERSTATE_WHENIDLE;
    }

    hr = m_pDeviceBuffer->GetState(&dwOldState);

    if(SUCCEEDED(hr) && dwNewState != dwOldState)
    {
        hr = m_pDeviceBuffer->SetState(dwNewState);
    }

    if(SUCCEEDED(hr))
    {
        m_dwRestoreState = dwNewState;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Activate
 *
 *  Description:
 *      Activates or deactivates the buffer object.
 *
 *  Arguments:
 *      BOOL [in]: Activation state.  TRUE to activate, FALSE to deactivate.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Activate"

HRESULT CDirectSoundPrimaryBuffer::Activate(BOOL fActive)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Apply cached properties.  If we fail while doing this, hard luck,
    // but there's nothing we can do about it.  We should never return
    // failure from Activate.
    if(MAKEBOOL(m_dwStatus & DSBSTATUS_ACTIVE) != fActive)
    {
        if(fActive)
        {
            m_dwStatus |= DSBSTATUS_ACTIVE;

            // Restore cached format
            hr = m_pDirectSound->SetDeviceFormatExact(m_dsbd.lpwfxFormat);

            if(FAILED(hr))
            {
                RPF(DPFLVL_WARNING, "Unable to restore cached primary buffer format");
            }

            // Restore primary buffer state
            hr = SetBufferState(m_dwRestoreState);

            if(FAILED(hr))
            {
                RPF(DPFLVL_WARNING, "Unable to restore cached primary buffer state");
            }
        }
        else
        {
            m_dwStatus &= ~DSBSTATUS_ACTIVE;
        }
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetPriority
 *
 *  Description:
 *      Sets buffer priority.
 *
 *  Arguments:
 *      DWORD [in]: new priority.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::SetPriority"

HRESULT CDirectSoundPrimaryBuffer::SetPriority(DWORD dwPriority)
{
    const BOOL              fCurrent    = m_fWritePrimary;
    const BOOL              fNew        = (DSSCL_WRITEPRIMARY == dwPriority);
    HRESULT                 hr          = DS_OK;
    const DSBUFFERFOCUS     bfFocus     = g_pDsAdmin->GetBufferFocusState(this);

    DPF_ENTER();

    // Update our copy of the priority
    m_fWritePrimary = fNew;

    // If we're becoming WRITEPRIMARY but are out of focus, become immediately
    // lost.
    if (fNew && !fCurrent && bfFocus != DSBUFFERFOCUS_INFOCUS)
    {
        // Give up WRITEPRIMARY access
        m_fWritePrimary = FALSE;

        // Deactivate the buffer
        Activate(FALSE);

        // Flag the buffer as lost
        m_dwStatus |= DSBSTATUS_BUFFERLOST;

        hr = DSERR_OTHERAPPHASPRIO;
    }


    // Make sure the WRITEPRIMARY state has actually changed
    if(SUCCEEDED(hr) && fNew != fCurrent)
    {
        // If we're becoming WRITEPRIMARY, we need to request primary
        // access to the device.
        if(fNew)
        {
            // Request write access
            hr = m_pDeviceBuffer->RequestWriteAccess(TRUE);

            if(SUCCEEDED(hr))
            {
                DPF(DPFLVL_INFO, "Buffer at 0x%p has become WRITEPRIMARY", this);
            }
        }

        // Fill the buffer with silence.  At this point, we MUST be WRITEPRIMARY.
        if(SUCCEEDED(hr))
        {
            ::FillSilence(m_pDeviceBuffer->m_pSysMemBuffer->GetPlayBuffer(), m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat->wBitsPerSample);
            hr = m_pDeviceBuffer->CommitToDevice(0, m_pDeviceBuffer->m_pSysMemBuffer->GetSize());
        }

        // If we're leaving WRITEPRIMARY, we need to relinquish primary
        // access to the device.
        if(!fNew)
        {
            // Free any open locks on the buffer
            m_pDeviceBuffer->OverrideLocks();

            // Give up write access
            hr = m_pDeviceBuffer->RequestWriteAccess(FALSE);

            if(SUCCEEDED(hr))
            {
                DPF(DPFLVL_INFO, "Buffer at 0x%p is no longer WRITEPRIMARY", this);
            }
        }

        // Reset the buffer state
        if(SUCCEEDED(hr))
        {
            SetBufferState(VAD_BUFFERSTATE_STOPPED);
        }
    }

    // If we're currently lost, but the cooperative level has changed to
    // something other than WRITEPRIMARY, we'll go ahead and restore the
    // buffer for the app.  Only WRITEPRIMARY buffers can be lost.
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST) && !fNew)
    {
        m_dwStatus &= ~DSBSTATUS_BUFFERLOST;
    }

    // Recover from any errors
    if(FAILED(hr))
    {
        m_fWritePrimary = fCurrent;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks the buffer memory to allow for writing.
 *
 *  Arguments:
 *      DWORD [in]: offset, in bytes, from the start of the buffer to where
 *                  the lock begins. This parameter is ignored if
 *                  DSBLOCK_FROMWRITECURSOR is specified in the dwFlags
 *                  parameter.
 *      DWORD [in]: size, in bytes, of the portion of the buffer to lock.
 *                  Note that the sound buffer is conceptually circular.
 *      LPVOID * [out]: address for a pointer to contain the first block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the ppvAudioPtr1 parameter. If this
 *                     value is less than the dwWriteBytes parameter,
 *                     ppvAudioPtr2 will point to a second block of sound
 *                     data.
 *      LPVOID * [out]: address for a pointer to contain the second block of
 *                      the sound buffer to be locked. If the value of this
 *                      parameter is NULL, the ppvAudioPtr1 parameter
 *                      points to the entire locked portion of the sound
 *                      buffer.
 *      LPDWORD [out]: address of a variable to contain the number of bytes
 *                     pointed to by the ppvAudioPtr2 parameter. If
 *                     ppvAudioPtr2 is NULL, this value will be 0.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Lock"

HRESULT CDirectSoundPrimaryBuffer::Lock(DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check for BUFFERLOST
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        hr = DSERR_BUFFERLOST;
    }

    // Check access rights
    if(SUCCEEDED(hr) && !m_fWritePrimary)
    {
        RPF(DPFLVL_ERROR, "Cooperative level is not WRITEPRIMARY");
        hr = DSERR_PRIOLEVELNEEDED;
    }

    // Handle flags
    if(SUCCEEDED(hr) && (dwFlags & DSBLOCK_FROMWRITECURSOR))
    {
        hr = GetCurrentPosition(NULL, &dwWriteCursor);
    }

    if(SUCCEEDED(hr) && (dwFlags & DSBLOCK_ENTIREBUFFER))
    {
        dwWriteBytes = m_dsbd.dwBufferBytes;
    }

    // Cursor validation
    if(SUCCEEDED(hr) && dwWriteCursor >= m_dsbd.dwBufferBytes)
    {
        ASSERT(!(dwFlags & DSBLOCK_FROMWRITECURSOR));

        RPF(DPFLVL_ERROR, "Write cursor past buffer end");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && dwWriteBytes > m_dsbd.dwBufferBytes)
    {
        ASSERT(!(dwFlags & DSBLOCK_ENTIREBUFFER));

        RPF(DPFLVL_ERROR, "Lock size larger than buffer size");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !dwWriteBytes)
    {
        ASSERT(!(dwFlags & DSBLOCK_ENTIREBUFFER));

        RPF(DPFLVL_ERROR, "Lock size must be > 0");
        hr = DSERR_INVALIDPARAM;
    }

    // Lock the device buffer
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->Lock(dwWriteCursor, dwWriteBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2);
    }
    m_bDataLocked = TRUE; // used to signal that app has written data (reset only required 1 per buffer creation)

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks the given buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Unlock"

HRESULT CDirectSoundPrimaryBuffer::Unlock(LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check for BUFFERLOST
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        hr = DSERR_BUFFERLOST;
    }

    // Check access rights
    if(SUCCEEDED(hr) && !m_fWritePrimary)
    {
        RPF(DPFLVL_ERROR, "Cooperative level is not WRITEPRIMARY");
        hr = DSERR_PRIOLEVELNEEDED;
    }

    // Unlock the device buffer.  Because we fail the call when the buffer is
    // lost (or out of focus), there's no need to notify the device buffer of
    // any state change.
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->Unlock(pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Lose
 *
 *  Description:
 *      Flags the buffer as lost.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Lose"

HRESULT CDirectSoundPrimaryBuffer::Lose(void)
{
    DPF_ENTER();

    // We can only be lost if we're WRITEPRIMARY
    if(!(m_dwStatus & DSBSTATUS_BUFFERLOST) && m_fWritePrimary)
    {
        // Stop the buffer.  All lost buffers are stopped by definition.
        SetBufferState(VAD_BUFFERSTATE_STOPPED);

        // Give up WRITEPRIMARY access
        SetPriority(DSSCL_NONE);

        // Deactivate the buffer
        Activate(FALSE);

        // Flag the buffer as lost
        m_dwStatus |= DSBSTATUS_BUFFERLOST;
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  Restore
 *
 *  Description:
 *      Attempts to restore a lost bufer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::Restore"

HRESULT CDirectSoundPrimaryBuffer::Restore(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        // Are we still lost?
        if(DSBUFFERFOCUS_LOST == g_pDsAdmin->GetBufferFocusState(this))
        {
            hr = DSERR_BUFFERLOST;
        }

        // Remove the lost flag
        if(SUCCEEDED(hr))
        {
            m_dwStatus &= ~DSBSTATUS_BUFFERLOST;
        }

        // Reset the focus priority
        if(SUCCEEDED(hr))
        {
            hr = SetPriority(m_pDirectSound->m_dsclCooperativeLevel.dwPriority);
        }

        // Clean up
        if(FAILED(hr))
        {
            m_dwStatus |= DSBSTATUS_BUFFERLOST;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CDirectSoundSecondaryBuffer
 *
 *  Description:
 *      DirectSound secondary buffer object constructor.
 *
 *  Arguments:
 *      CDirectSound * [in]: pointer to the parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::CDirectSoundSecondaryBuffer"

CDirectSoundSecondaryBuffer::CDirectSoundSecondaryBuffer(CDirectSound *pDirectSound)
    : CDirectSoundBuffer(pDirectSound)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundSecondaryBuffer);

    // Initialize/check defaults
    ASSERT(m_pImpDirectSoundBuffer == NULL);
    ASSERT(m_pImpDirectSoundNotify == NULL);
    ASSERT(m_pOwningSink == NULL);
    ASSERT(m_pDeviceBuffer == NULL);
    ASSERT(m_p3dBuffer == NULL);
    ASSERT(m_pPropertySet == NULL);
    ASSERT(m_fxChain == NULL);
    ASSERT(m_dwPriority == 0);
    ASSERT(m_dwVmPriority == 0);
    ASSERT(m_fMute == FALSE);
#ifdef FUTURE_MULTIPAN_SUPPORT
    ASSERT(m_dwChannelCount == 0);
    ASSERT(m_pdwChannels == NULL);
    ASSERT(m_plChannelVolumes == NULL);
#endif
    ASSERT(m_guidBufferID == GUID_NULL);
    ASSERT(m_dwAHLastGetPosTime == 0);
    ASSERT(m_dwAHCachedPlayPos == 0);
    ASSERT(m_dwAHCachedWritePos == 0);

    m_fCanStealResources = TRUE;
    m_hrInit = DSERR_UNINITIALIZED;
    m_hrPlay = DS_OK;
    m_playState = Stopped;
    m_dwSliceBegin = MAX_DWORD;
    m_dwSliceEnd = MAX_DWORD;

#ifdef ENABLE_PERFLOG
    // Initialize performance state if logging is enabled
    m_pPerfState = NULL;
    if (PerflogTracingEnabled())
    {
        m_pPerfState = NEW(BufferPerfState(this));
        // We don't mind if this allocation fails
    }
#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundSecondaryBuffer
 *
 *  Description:
 *      DirectSound secondary buffer object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::~CDirectSoundSecondaryBuffer"

CDirectSoundSecondaryBuffer::~CDirectSoundSecondaryBuffer(void)
{
    HRESULT                 hr;

    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundBuffer);

    // If we're a MIXIN buffer, inform all our senders that we're going
    // away, and unregister with the streaming thread
    if ((m_dsbd.dwFlags & DSBCAPS_MIXIN) && SUCCEEDED(m_hrInit))
    {
        CNode<CDirectSoundSecondaryBuffer*>* pDsbNode;
        for (pDsbNode = m_pDirectSound->m_lstSecondaryBuffers.GetListHead(); pDsbNode; pDsbNode = pDsbNode->m_pNext)
            if (pDsbNode->m_data->HasFX())
                pDsbNode->m_data->m_fxChain->NotifyRelease(this);
        m_pStreamingThread->UnregisterMixBuffer(this);
    }

    // If we're a SINKIN buffer, unregister with our owning sink
    if (m_pOwningSink)
    {
        hr = m_pOwningSink->RemoveBuffer(this);
        ASSERT(SUCCEEDED(hr));
        RELEASE(m_pOwningSink);
    }

    // Release our FX chain, if we have one
    RELEASE(m_fxChain);

    // Make sure the buffer is stopped
    if(m_pDeviceBuffer)
    {
        hr = SetBufferState(VAD_BUFFERSTATE_STOPPED);
        ASSERT(SUCCEEDED(hr) || hr == DSERR_NODRIVER);
    }

    // Unregister with the parent object
    m_pDirectSound->m_lstSecondaryBuffers.RemoveDataFromList(this);

    // Free all interfaces
    DELETE(m_pImpDirectSoundNotify);
    DELETE(m_pImpDirectSoundBuffer);

    // Free owned objects
    ABSOLUTE_RELEASE(m_p3dBuffer);
    ABSOLUTE_RELEASE(m_pPropertySet);

    // Release the device buffer
    RELEASE(m_pDeviceBuffer);

    // Clean up memory
#ifdef FUTURE_MULTIPAN_SUPPORT
    MEMFREE(m_pdwChannels);
    MEMFREE(m_plChannelVolumes);
#endif

#ifdef ENABLE_PERFLOG
    DELETE(m_pPerfState);
#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes a buffer object.  If this function fails, the object
 *      should be immediately deleted.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: buffer description.
 *      CDirectSoundBuffer * [in]: source buffer to duplicate from, or NULL
 *                                 to create a new buffer object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Initialize"

HRESULT CDirectSoundSecondaryBuffer::Initialize(LPCDSBUFFERDESC pDesc, CDirectSoundSecondaryBuffer *pSource)
{
#ifdef DEBUG
    const ULONG             ulKsIoctlCount  = g_ulKsIoctlCount;
#endif // DEBUG

    DSBUFFERFOCUS           bfFocus;
    VADRBUFFERCAPS          vrbc;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(IsInit() == DSERR_UNINITIALIZED);
    ASSERT(LXOR(pSource, pDesc));

    if(pDesc)
    {
        DPF(DPFLVL_MOREINFO, "dwFlags: 0x%8.8lX", pDesc->dwFlags);
        DPF(DPFLVL_MOREINFO, "dwBufferBytes: %lu", pDesc->dwBufferBytes);
        DPF(DPFLVL_MOREINFO, "dwReserved: %lu", pDesc->dwReserved);

        if(pDesc->lpwfxFormat)
        {
            DPF(DPFLVL_MOREINFO, "lpwfxFormat->wFormatTag: %u", pDesc->lpwfxFormat->wFormatTag);
            DPF(DPFLVL_MOREINFO, "lpwfxFormat->nChannels: %u", pDesc->lpwfxFormat->nChannels);
            DPF(DPFLVL_MOREINFO, "lpwfxFormat->nSamplesPerSec: %lu", pDesc->lpwfxFormat->nSamplesPerSec);
            DPF(DPFLVL_MOREINFO, "lpwfxFormat->nAvgBytesPerSec: %lu", pDesc->lpwfxFormat->nAvgBytesPerSec);
            DPF(DPFLVL_MOREINFO, "lpwfxFormat->nBlockAlign: %u", pDesc->lpwfxFormat->nBlockAlign);
            DPF(DPFLVL_MOREINFO, "lpwfxFormat->wBitsPerSample: %u", pDesc->lpwfxFormat->wBitsPerSample);

            if(WAVE_FORMAT_PCM != pDesc->lpwfxFormat->wFormatTag)
            {
                DPF(DPFLVL_MOREINFO, "lpwfxFormat->cbSize: %u", pDesc->lpwfxFormat->cbSize);
            }
        }

        DPF(DPFLVL_MOREINFO, "guid3DAlgorithm: " DPF_GUID_STRING, DPF_GUID_VAL(pDesc->guid3DAlgorithm));
    }

    // Initialize the buffer
    hr = InitializeEmpty(pDesc, pSource);

    // Register with the parent object
    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pDirectSound->m_lstSecondaryBuffers.AddNodeToList(this));
    }

    // Set default properties
    if(SUCCEEDED(hr))
    {
        if(pSource && (m_dsbd.dwFlags & DSBCAPS_CTRLVOLUME) && DSBVOLUME_MAX != pSource->m_lVolume)
        {
            SetVolume(pSource->m_lVolume);
        }
        else
        {
            m_lVolume = DSBVOLUME_MAX;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(pSource && (m_dsbd.dwFlags & DSBCAPS_CTRLPAN) && DSBPAN_CENTER != pSource->m_lPan)
        {
            SetPan(pSource->m_lPan);
        }
        else
        {
            m_lPan = DSBPAN_CENTER;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(pSource && (m_dsbd.dwFlags & DSBCAPS_CTRLFREQUENCY) && m_dsbd.lpwfxFormat->nSamplesPerSec != pSource->m_dwFrequency)
        {
            SetFrequency(pSource->m_dwFrequency);
        }
        else
        {
            m_dwFrequency = m_dsbd.lpwfxFormat->nSamplesPerSec;
        }
    }

    // Attempt to create the property set object
    if(SUCCEEDED(hr))
    {
        m_pPropertySet = NEW(CDirectSoundSecondaryBufferPropertySet(this));
        hr = HRFROMP(m_pPropertySet);

        if(SUCCEEDED(hr))
        {
            hr = m_pPropertySet->Initialize();
        }
    }

    // Attempt to create the 3D buffer
    if(SUCCEEDED(hr) && (m_dsbd.dwFlags & DSBCAPS_CTRL3D))
    {
        m_p3dBuffer = NEW(CDirectSound3dBuffer(this));
        hr = HRFROMP(m_p3dBuffer);

        if(SUCCEEDED(hr))
        {
            hr = m_p3dBuffer->Initialize(m_dsbd.guid3DAlgorithm, m_dsbd.dwFlags, m_dwFrequency, m_pDirectSound->m_pPrimaryBuffer->m_p3dListener, pSource ? pSource->m_p3dBuffer : NULL);
        }
    }

    // Handle any possible resource acquisitions
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->GetCaps(&vrbc);
    }

    // Manbug 36422: CEmSecondaryRenderWaveBuffer objects can return LOCSOFTWARE|LOCDEFER,
    // in which case we incorrectly acquired resources here for deferred emulated buffers.
    // Hence the "&& !(vrbc.dwFlags & DSBCAPS_LOCDEFER)" below.

    if(SUCCEEDED(hr) && (vrbc.dwFlags & DSBCAPS_LOCMASK) && !(vrbc.dwFlags & DSBCAPS_LOCDEFER))
    {
        hr = HandleResourceAcquisition(vrbc.dwFlags & DSBCAPS_LOCMASK);
    }

    // Register the interfaces with the interface manager
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(this, IID_IDirectSoundBuffer, this, &m_pImpDirectSoundBuffer);
    }

    if(SUCCEEDED(hr) && GetDsVersion() >= DSVERSION_DX8)
    {
        hr = RegisterInterface(IID_IDirectSoundBuffer8, m_pImpDirectSoundBuffer, m_pImpDirectSoundBuffer);
    }

    if(SUCCEEDED(hr) && (m_dsbd.dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY))
    {
        hr = CreateAndRegisterInterface(this, IID_IDirectSoundNotify, this, &m_pImpDirectSoundNotify);
    }

    // Initialize focus state
    if(SUCCEEDED(hr))
    {
        bfFocus = g_pDsAdmin->GetBufferFocusState(this);

        switch(bfFocus)
        {
            case DSBUFFERFOCUS_INFOCUS:
                hr = Activate(TRUE);
                break;

            case DSBUFFERFOCUS_OUTOFFOCUS:
                hr = Activate(FALSE);
                break;

            case DSBUFFERFOCUS_LOST:
                hr = Lose();
                break;
        }
    }

    // If this is a MIXIN buffer, register it with the streaming thread
    if (SUCCEEDED(hr) && (m_dsbd.dwFlags & DSBCAPS_MIXIN))
    {
        m_pStreamingThread = GetStreamingThread();
        hr = HRFROMP(m_pStreamingThread);
        if (SUCCEEDED(hr))
        {
            hr = m_pStreamingThread->RegisterMixBuffer(this);
        }
    }

    // Success
    if(SUCCEEDED(hr))
    {

#ifdef DEBUG
        if(IS_KS_VAD(m_pDirectSound->m_pDevice->m_vdtDeviceType))
        {
            DPF(DPFLVL_MOREINFO, "%s used %lu IOCTLs", TEXT(DPF_FNAME), g_ulKsIoctlCount - ulKsIoctlCount);
        }
#endif // DEBUG

        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  InitializeEmpty
 *
 *  Description:
 *      Initializes a buffer object.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: buffer description.
 *      CDirectSoundBuffer * [in]: source buffer to duplicate from, or NULL
 *                                 to create a new buffer object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::InitializeEmpty"

HRESULT CDirectSoundSecondaryBuffer::InitializeEmpty(LPCDSBUFFERDESC pDesc, CDirectSoundSecondaryBuffer *pSource)
{
    BOOL                    fRealDuplicate  = FALSE;
    VADRBUFFERDESC          vrbd;
    HRESULT                 hr;

    DPF_ENTER();

    // Save buffer description
    if(pSource)
    {
        m_dwOriginalFlags = pSource->m_dwOriginalFlags;
        hr = CopyDsBufferDesc(&pSource->m_dsbd, &m_dsbd);

        // We're going to reset the flags back to those originally passed to
        // CreateSoundBuffer so that the duplicate buffer is created with
        // the same *requested* capabilities as the original.

        // COMPATCOMPAT: one side effect of doing this is that if the source buffer
        // is in hardware, but no location flags were specified when creating it,
        // any number of its duplicates may potentially live in software.  This
        // is new behavior as of version 5.0a.

        if(SUCCEEDED(hr))
        {
            m_dsbd.dwFlags = m_dwOriginalFlags;
        }
    }
    else
    {
        m_dwOriginalFlags = pDesc->dwFlags;
        hr = CopyDsBufferDesc(pDesc, &m_dsbd);
    }

    // Fill in any missing pieces
    if(SUCCEEDED(hr) && !pSource)
    {
        m_dsbd.dwBufferBytes = GetAlignedBufferSize(m_dsbd.lpwfxFormat, m_dsbd.dwBufferBytes);
    }

    // Include legacy Voice Manager stuff
    if(SUCCEEDED(hr) && DSPROPERTY_VMANAGER_MODE_DEFAULT != m_pDirectSound->m_vmmMode)
    {
        m_dsbd.dwFlags |= DSBCAPS_LOCDEFER;
    }

    // Attempt to duplicate the device buffer
    if(SUCCEEDED(hr) && pSource)
    {
        hr = pSource->m_pDeviceBuffer->Duplicate(&m_pDeviceBuffer);

        // If we failed to duplicate the buffer, and the source buffer's
        // original flags don't specify a location, fall back on software.
        fRealDuplicate = SUCCEEDED(hr);

        if(FAILED(hr) && !(pSource->m_dwOriginalFlags & DSBCAPS_LOCHARDWARE))
        {
            hr = DS_OK;
        }
    }

    // Attempt to create the device buffer
    if(SUCCEEDED(hr) && !m_pDeviceBuffer)
    {
        vrbd.dwFlags = m_dsbd.dwFlags;
        vrbd.dwBufferBytes = m_dsbd.dwBufferBytes;
        vrbd.pwfxFormat = m_dsbd.lpwfxFormat;
        vrbd.guid3dAlgorithm = m_dsbd.guid3DAlgorithm;

        hr = m_pDirectSound->m_pDevice->CreateSecondaryBuffer(&vrbd, m_pDirectSound, &m_pDeviceBuffer);
    }

    // Initialize the buffer data
    if(SUCCEEDED(hr))
    {
        if(pSource)
        {
            if(!fRealDuplicate)
            {
                ASSERT(m_pDeviceBuffer->m_pSysMemBuffer->GetSize() == m_dsbd.dwBufferBytes);
                ASSERT(pSource->m_pDeviceBuffer->m_pSysMemBuffer->GetSize() == m_dsbd.dwBufferBytes);

                CopyMemory(GetWriteBuffer(), pSource->GetWriteBuffer(), m_dsbd.dwBufferBytes);
            }
        }
        else if(GetBufferType())  // If true, buffer is MIXIN or SINKIN (FIXME - does this simplify the sink?)
        {
            ClearWriteBuffer();
        }
        else
        {
#ifdef RDEBUG
            // Write some ugly noise into the buffer to catch remiss apps
            ::FillNoise(GetWriteBuffer(), m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat->wBitsPerSample);
#else // RDEBUG
            if(GetDsVersion() < DSVERSION_DX8)
            {
                // For apps written for DirectX 8 or later, we decided not to
                // waste time initializing all secondary buffers with silence.
                // They'll still be zeroed out by our memory allocator, though ;-)
                ClearWriteBuffer();
            }
#endif // RDEBUG
        }

        if(!pSource || !fRealDuplicate)
        {
            hr = CommitToDevice(0, m_dsbd.dwBufferBytes);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AttemptResourceAcquisition
 *
 *  Description:
 *      Acquires hardware resources.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::AttemptResourceAcquisition"

HRESULT CDirectSoundSecondaryBuffer::AttemptResourceAcquisition(DWORD dwFlags)
{
    HRESULT                                 hr              = DSERR_INVALIDPARAM;
    CList<CDirectSoundSecondaryBuffer *>    lstBuffers;
    CNode<CDirectSoundSecondaryBuffer *> *  pNode;
    HRESULT                                 hrTemp;

    DPF_ENTER();
    ASSERT(m_pDeviceBuffer);

    if (m_dwStatus & DSBSTATUS_RESOURCESACQUIRED)
    {
        hr = DS_OK;
    }
    else
    {
        // Include legacy Voice Manager stuff
        if(DSPROPERTY_VMANAGER_MODE_DEFAULT != m_pDirectSound->m_vmmMode)
        {
            ASSERT(m_dsbd.dwFlags & DSBCAPS_LOCDEFER);
            ASSERT(!(dwFlags & DSBPLAY_LOCDEFERMASK));

            dwFlags &= ~DSBPLAY_LOCDEFERMASK;
            dwFlags |= DSBCAPStoDSBPLAY(m_dsbd.dwFlags);

            switch(m_pDirectSound->m_vmmMode)
            {
                case DSPROPERTY_VMANAGER_MODE_AUTO:
                    dwFlags |= DSBPLAY_TERMINATEBY_TIME;
                    break;

               case DSPROPERTY_VMANAGER_MODE_USER:
                    dwFlags |= DSBPLAY_TERMINATEBY_PRIORITY;
                    break;
            }
        }

        // Try to acquire resources.  If any of the TERMINATEBY flags were specified,
        // we'll need to try to explicitly acquire hardware resources, then attempt
        // to steal, then fall back on software.
        if(!(dwFlags & DSBPLAY_LOCSOFTWARE))
        {
            hr = AcquireResources(DSBCAPS_LOCHARDWARE);

            if(FAILED(hr) && (dwFlags & DSBPLAY_TERMINATEBY_MASK))
            {
                hrTemp = GetResourceTheftCandidates(dwFlags & DSBPLAY_TERMINATEBY_MASK, &lstBuffers);
                if(SUCCEEDED(hrTemp))
                {
                    if(pNode = lstBuffers.GetListHead())
                        hr = StealResources(pNode->m_data);
                }
                else
                {
                    hr = hrTemp;
                }
            }
        }

        if(FAILED(hr) && !(dwFlags & DSBPLAY_LOCHARDWARE))
        {
            hr = AcquireResources(DSBCAPS_LOCSOFTWARE);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AcquireResources
 *
 *  Description:
 *      Acquires hardware resources.
 *
 *  Arguments:
 *      DWORD [in]: buffer location flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::AcquireResources"

HRESULT CDirectSoundSecondaryBuffer::AcquireResources(DWORD dwFlags)
{
    VADRBUFFERCAPS          vrbc;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pDeviceBuffer);
    ASSERT(!(m_dwStatus & DSBSTATUS_RESOURCESACQUIRED));

    hr = m_pDeviceBuffer->GetCaps(&vrbc);

    if(SUCCEEDED(hr))
    {
        if(!(vrbc.dwFlags & DSBCAPS_LOCMASK))
        {
            // Try to acquire the device buffer
            hr = m_pDeviceBuffer->AcquireResources(dwFlags);
        }
        else if((dwFlags & DSBCAPS_LOCMASK) != (vrbc.dwFlags & DSBCAPS_LOCMASK))
        {
            hr = DSERR_INVALIDCALL;
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has acquired resources at 0x%p", this, m_pDeviceBuffer);
        hr = CommitToDevice(0, m_dsbd.dwBufferBytes);

        // Handle the resource acquisition
        if(SUCCEEDED(hr))
        {
            hr = HandleResourceAcquisition(vrbc.dwFlags & DSBCAPS_LOCMASK);
        }

        if (FAILED(hr))
        {
            // Free any resources acquired so far
            HRESULT hrTemp = FreeResources(FALSE);

            ASSERT(SUCCEEDED(hrTemp));  // Not much we can do if this fails
        }            
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  StealResources
 *
 *  Description:
 *      Steals hardware resources from another buffer.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer * [in]: buffer to steal from.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::StealResources"

HRESULT CDirectSoundSecondaryBuffer::StealResources(CDirectSoundSecondaryBuffer *pSource)
{
    VADRBUFFERCAPS          vrbc;
    HRESULT                 hrTemp;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pDeviceBuffer);
    ASSERT(!(m_dwStatus & DSBSTATUS_RESOURCESACQUIRED));

    DPF(DPFLVL_INFO, "Stealing resources from buffer at 0x%p", pSource);

    ASSERT(pSource->m_dwStatus & DSBSTATUS_RESOURCESACQUIRED);

    // Get the buffer location
    hr = pSource->m_pDeviceBuffer->GetCaps(&vrbc);

    if(SUCCEEDED(hr))
    {
        ASSERT(vrbc.dwFlags & DSBCAPS_LOCHARDWARE);
    }

    // Steal hardware resources
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->StealResources(pSource->m_pDeviceBuffer);
    }

    if(SUCCEEDED(hr))
    {
        // Free the source buffer's resources (since they're now our resources).
        hr = pSource->FreeResources(TRUE);

        if(SUCCEEDED(hr))
        {
            hr = CommitToDevice(0, m_dsbd.dwBufferBytes);
        }

        // Handle the resource acquisition
        if(SUCCEEDED(hr))
        {
            hr = HandleResourceAcquisition(vrbc.dwFlags & DSBCAPS_LOCMASK);
        }

    }
    else if(DSERR_UNSUPPORTED == hr)
    {
        // The device buffer doesn't support resource theft.  Free the
        // source buffer's resources and try to acquire our own.
        hr = pSource->FreeResources(TRUE);

        if(SUCCEEDED(hr))
        {
            hr = AcquireResources(DSBCAPS_LOCHARDWARE);

            // Try to reacquire the source buffer's resources
            if(FAILED(hr))
            {
                hrTemp = pSource->AcquireResources(DSBCAPS_LOCHARDWARE);

                if(FAILED(hrTemp))
                {
                    RPF(DPFLVL_ERROR, "Unable to reacquire hardware resources!");
                }
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetResourceTheftCandidates
 *
 *  Description:
 *      Finds objects that are available to have their resources stolen.
 *
 *  Arguments:
 *      CList * [out]: destination list.
 *      DWORD [in]: TERMINATEBY flags.  If none are specified, all
 *                  compatible buffers are added to the list.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetResourceTheftCandidates"

HRESULT CDirectSoundSecondaryBuffer::GetResourceTheftCandidates(DWORD dwFlags, CList<CDirectSoundSecondaryBuffer *> *plstDest)
{
    HRESULT                                 hr              = DS_OK;
    CNode<CDirectSoundSecondaryBuffer *> *  pNode;
    CNode<CDirectSoundSecondaryBuffer *> *  pNext;
    CDirectSoundSecondaryBuffer *           pTimeBuffer;
    DWORD                                   dwStatus;
    DWORD                                   dwMinPriority;
    DWORD                                   dwPriority;
    DWORD                                   cbMinRemain;
    DWORD                                   cbRemain;
    COMPAREBUFFER                           cmp[2];

    DPF_ENTER();

    ASSERT(m_pDeviceBuffer);

    // First, find all compatible buffers
    for(pNode = m_pDirectSound->m_lstSecondaryBuffers.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        // We never want to look at ourselves.  It's just sick.
        if(this == pNode->m_data)
        {
            continue;
        }

        // We can only steal from LOCDEFER buffers
        if(!(pNode->m_data->m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
        {
            continue;
        }

        // This flag prevents us from stealing resources from buffers that have
        // just called UserAcquireResources() and haven't called Play() yet
        if(!pNode->m_data->m_fCanStealResources)
        {
            continue;
        }

        // Make sure the object actually has some hardware resources
        hr = pNode->m_data->GetStatus(&dwStatus);

        if(FAILED(hr))
        {
            break;
        }

        if(!(dwStatus & DSBSTATUS_LOCHARDWARE))
        {
            continue;
        }

        // Compare the buffer properties
        cmp[0].dwFlags = m_dsbd.dwFlags;
        cmp[0].pwfxFormat = m_dsbd.lpwfxFormat;
        cmp[0].guid3dAlgorithm = m_dsbd.guid3DAlgorithm;

        cmp[1].dwFlags = pNode->m_data->m_dsbd.dwFlags;
        cmp[1].pwfxFormat = pNode->m_data->m_dsbd.lpwfxFormat;
        cmp[1].guid3dAlgorithm = pNode->m_data->m_dsbd.guid3DAlgorithm;

        if(!CompareBufferProperties(&cmp[0], &cmp[1]))
        {
            continue;
        }

        hr = HRFROMP(plstDest->AddNodeToList(pNode->m_data));
        if (FAILED(hr))
        {
            break;
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Found %lu compatible buffers", plstDest->GetNodeCount());
    }

    // Remove all buffers that are > the lowest priority
    if(SUCCEEDED(hr) && (dwFlags & DSBPLAY_TERMINATEBY_PRIORITY))
    {
        dwMinPriority = GetBufferPriority();

        for(pNode = plstDest->GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            dwPriority = pNode->m_data->GetBufferPriority();

            if(dwPriority < dwMinPriority)
            {
                dwMinPriority = dwPriority;
            }
        }

        pNode = plstDest->GetListHead();

        while(pNode)
        {
            pNext = pNode->m_pNext;

            dwPriority = pNode->m_data->GetBufferPriority();

            if(dwPriority > dwMinPriority)
            {
                plstDest->RemoveNodeFromList(pNode);
            }

            pNode = pNext;
        }

#ifdef DEBUG
        DPF(DPFLVL_MOREINFO, "%lu buffers passed the priority test", plstDest->GetNodeCount());
        for(pNode = plstDest->GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has priority %lu", pNode->m_data, pNode->m_data->GetBufferPriority());
        }
#endif // DEBUG

    }

    // Remove any buffers that aren't at max distance
    if(SUCCEEDED(hr) && (dwFlags & DSBPLAY_TERMINATEBY_DISTANCE))
    {
        pNode = plstDest->GetListHead();

        while(pNode)
        {
            pNext = pNode->m_pNext;

            if(!pNode->m_data->m_p3dBuffer || !pNode->m_data->m_p3dBuffer->m_pWrapper3dObject->IsAtMaxDistance())
            {
                plstDest->RemoveNodeFromList(pNode);
            }

            pNode = pNext;
        }

#ifdef DEBUG
        DPF(DPFLVL_MOREINFO, "%lu buffers passed the distance test", plstDest->GetNodeCount());
        for(pNode = plstDest->GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            DPF(DPFLVL_MOREINFO, "Buffer at 0x%p is at max distance", pNode->m_data);
        }
#endif // DEBUG

    }

    // Find the buffer with the least amount of time remaining
    if(SUCCEEDED(hr) && (dwFlags & DSBPLAY_TERMINATEBY_TIME))
    {
        cbMinRemain = MAX_DWORD;
        pTimeBuffer = NULL;

        for(pNode = plstDest->GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            hr = pNode->m_data->GetPlayTimeRemaining(&cbRemain);

            if(FAILED(hr))
            {
                break;
            }

            DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has %lu bytes remaining", pNode->m_data, cbRemain);

            if(cbRemain < cbMinRemain)
            {
                cbMinRemain = cbRemain;
                pTimeBuffer = pNode->m_data;
            }
        }

        if(SUCCEEDED(hr))
        {
            plstDest->RemoveAllNodesFromList();

            if(pTimeBuffer)
            {
                hr = HRFROMP(plstDest->AddNodeToList(pTimeBuffer));
            }

            DPF(DPFLVL_MOREINFO, "%lu buffers passed the time test", plstDest->GetNodeCount());
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetPlayTimeRemaining
 *
 *  Description:
 *      Gets the amount of time the buffer has remaining before stopping.
 *
 *  Arguments:
 *      LPDWORD [out]: receives time (in bytes).
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetPlayTimeRemaining"

HRESULT CDirectSoundSecondaryBuffer::GetPlayTimeRemaining(LPDWORD pdwRemain)
{
    DWORD                   dwRemain    = MAX_DWORD;
    HRESULT                 hr          = DS_OK;
    DWORD                   dwPlay;

    DPF_ENTER();

    if(!(m_dwStatus & DSBSTATUS_LOOPING))
    {
        hr = GetCurrentPosition(&dwPlay, NULL);

        if(SUCCEEDED(hr))
        {
            dwRemain = m_dsbd.dwBufferBytes - dwPlay;
        }
    }

    if(SUCCEEDED(hr))
    {
        *pdwRemain = dwRemain;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeResources
 *
 *  Description:
 *      Frees hardware resources.
 *
 *  Arguments:
 *      BOOL [in]: TRUE if the buffer has been terminated as a result of
 *                 resources being stolen.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::FreeResources"

HRESULT CDirectSoundSecondaryBuffer::FreeResources(BOOL fTerminate)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pDeviceBuffer);

    // Make sure the buffer is stopped
    hr = SetBufferState(VAD_BUFFERSTATE_STOPPED);

    // Free owned objects' resources
    if(SUCCEEDED(hr) && m_p3dBuffer)
    {
        hr = m_p3dBuffer->FreeResources();
    }

    if(SUCCEEDED(hr) && m_pPropertySet)
    {
        hr = m_pPropertySet->FreeResources();
    }

    // Free the device buffer's resources
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->FreeResources();
    }

    // Resources have been freed
    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has freed its resources", this);
        m_dwStatus &= ~DSBSTATUS_RESOURCESACQUIRED;
    }

    // If resources were freed as a result of a termination, update
    // the status.
    if(SUCCEEDED(hr) && fTerminate)
    {
        m_dwStatus |= DSBSTATUS_TERMINATED;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  HandleResourceAcquisition
 *
 *  Description:
 *      Handles acquisition of hardware resources.
 *
 *  Arguments:
 *      DWORD [in]: location flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::HandleResourceAcquisition"

HRESULT CDirectSoundSecondaryBuffer::HandleResourceAcquisition(DWORD dwFlags)
{
    HRESULT                 hr  = S_OK;

    DPF_ENTER();

    ASSERT(m_pDeviceBuffer);

    // Acquire 3D resources
    if(SUCCEEDED(hr) && m_p3dBuffer)
    {
        hr = m_p3dBuffer->AcquireResources(m_pDeviceBuffer);
    }

    // Acquire property set resources.  It's OK if this fails.
    if(SUCCEEDED(hr) && m_pPropertySet)
    {
        m_pPropertySet->AcquireResources(m_pDeviceBuffer);
    }

    // Acquire effect handling resources if necessary
    if(SUCCEEDED(hr) && HasFX())
    {
        hr = m_fxChain->AcquireFxResources();
    }

    // Resources have been acquired
    if(SUCCEEDED(hr))
    {
        m_dwStatus |= DSBSTATUS_RESOURCESACQUIRED;
    }

    // If the buffer was created *without* LOCDEFER, the caps must reflect
    // the location.  If the buffer was create *with* LOCDEFER, the caps
    // will never reflect anything other than that; call GetStatus instead.
    if(SUCCEEDED(hr) && !(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        m_dsbd.dwFlags |= dwFlags & DSBCAPS_LOCMASK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Queries capabilities for the buffer.
 *
 *  Arguments:
 *      LPDSBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetCaps"

HRESULT CDirectSoundSecondaryBuffer::GetCaps(LPDSBCAPS pDsbCaps)
{
    DPF_ENTER();

    ASSERT(sizeof(DSBCAPS) == pDsbCaps->dwSize);

    if(m_dsbd.dwFlags & DSBCAPS_LOCDEFER)
    {
        ASSERT(!(m_dsbd.dwFlags & DSBCAPS_LOCMASK));
    }
    else
    {
        ASSERT(LXOR(m_dsbd.dwFlags & DSBCAPS_LOCSOFTWARE, m_dsbd.dwFlags & DSBCAPS_LOCHARDWARE));
    }

    pDsbCaps->dwFlags = m_dsbd.dwFlags & DSBCAPS_VALIDFLAGS;  // Remove any special internal flags (e.g. DSBCAPS_SINKIN)
    pDsbCaps->dwBufferBytes = GetBufferType() ? 0 : m_dsbd.dwBufferBytes;  // Shouldn't report internal size of sink/MIXIN buffers
    pDsbCaps->dwUnlockTransferRate = 0;
    pDsbCaps->dwPlayCpuOverhead = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Retrieves the format for the given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives the format.
 *      LPDWORD [in/out]: size of the format structure.  On entry, this
 *                        must be initialized to the size of the structure.
 *                        On exit, this will be filled with the size that
 *                        was required.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetFormat"

HRESULT CDirectSoundSecondaryBuffer::GetFormat(LPWAVEFORMATEX pwfxFormat, LPDWORD pdwSize)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    hr = CopyWfxApi(m_dsbd.lpwfxFormat, pwfxFormat, pdwSize);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the format for a given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: new format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetFormat"

HRESULT CDirectSoundSecondaryBuffer::SetFormat(LPCWAVEFORMATEX pwfxFormat)
{
    DPF_ENTER();

    RPF(DPFLVL_ERROR, "Secondary buffers don't support SetFormat");

    DPF_LEAVE_HRESULT(DSERR_INVALIDCALL);

    return DSERR_INVALIDCALL;
}


/***************************************************************************
 *
 *  GetFrequency
 *
 *  Description:
 *      Retrieves frequency for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrimaryBuffer::GetFrequency"

HRESULT CDirectSoundSecondaryBuffer::GetFrequency(LPDWORD pdwFrequency)
{
    HRESULT                     hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLFREQUENCY))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLFREQUENCY");
        hr = DSERR_CONTROLUNAVAIL;
    }

    if(SUCCEEDED(hr))
    {
        *pdwFrequency = m_dwFrequency;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the frequency for the given buffer.
 *
 *  Arguments:
 *      DWORD [in]: frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetFrequency"

HRESULT CDirectSoundSecondaryBuffer::SetFrequency(DWORD dwFrequency)
{
    BOOL                    fContinue   = TRUE;
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLFREQUENCY))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLFREQUENCY");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Handle default frequency
    if(SUCCEEDED(hr) && DSBFREQUENCY_ORIGINAL == dwFrequency)
    {
        dwFrequency = m_dsbd.lpwfxFormat->nSamplesPerSec;
    }

    // Validate the frequency
    if(SUCCEEDED(hr) && (dwFrequency < DSBFREQUENCY_MIN || dwFrequency > DSBFREQUENCY_MAX))
    {
        RPF(DPFLVL_ERROR, "Specified invalid frequency %lu (valid range is %lu to %lu)", dwFrequency, DSBFREQUENCY_MIN, DSBFREQUENCY_MAX);
        hr = DSERR_INVALIDPARAM;
    }

    // Only set the frequency if it's changed
    if(SUCCEEDED(hr) && dwFrequency == m_dwFrequency)
    {
        fContinue = FALSE;
    }

    // Update the 3D object
    if(SUCCEEDED(hr) && m_p3dBuffer && fContinue)
    {
        hr = m_p3dBuffer->SetFrequency(dwFrequency, &fContinue);
    }

    // Update the device buffer
    if(SUCCEEDED(hr) && fContinue)
    {
        hr = m_pDeviceBuffer->SetBufferFrequency(dwFrequency);
    }

    // Update our local copy
    if(SUCCEEDED(hr))
    {
        m_dwFrequency = dwFrequency;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetPan
 *
 *  Description:
 *      Retrieves pan for the given buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetPan"

HRESULT CDirectSoundSecondaryBuffer::GetPan(LPLONG plPan)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLPAN))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLPAN");
        hr = DSERR_CONTROLUNAVAIL;
    }

    if(SUCCEEDED(hr))
    {
        *plPan = m_lPan;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPan
 *
 *  Description:
 *      Sets the pan for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetPan"

HRESULT CDirectSoundSecondaryBuffer::SetPan(LONG lPan)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLPAN))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLPAN");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Set the pan if it has changed
    if(SUCCEEDED(hr) && lPan != m_lPan)
    {
        hr = SetAttenuation(m_lVolume, lPan);

        // Update our local copy
        if(SUCCEEDED(hr))
        {
            m_lPan = lPan;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetVolume
 *
 *  Description:
 *      Retrieves volume for the given buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetVolume"

HRESULT CDirectSoundSecondaryBuffer::GetVolume(LPLONG plVolume)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLVOLUME))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    if(SUCCEEDED(hr))
    {
        *plVolume = m_lVolume;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the volume for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetVolume"

HRESULT CDirectSoundSecondaryBuffer::SetVolume(LONG lVolume)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLVOLUME))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Set the volume if it has changed
    if(SUCCEEDED(hr) && lVolume != m_lVolume)
    {
#ifdef FUTURE_MULTIPAN_SUPPORT
        if (m_dsbd.dwFlags & DSBCAPS_CTRLCHANNELVOLUME)
        {
            hr = m_pDeviceBuffer->SetChannelAttenuations(lVolume, m_dwChannelCount, m_pdwChannels, m_plChannelVolumes);
        }
        else
#endif
        {
            hr = SetAttenuation(lVolume, m_lPan);
        }

        // Update our local copy
        if(SUCCEEDED(hr))
        {
            m_lVolume = lVolume;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetAttenuation
 *
 *  Description:
 *      Obtains the buffer's true current attenuation, after 3D processing
 *      (unlike GetVolume, which returns the last volume set by the app).
 *
 *  Arguments:
 *      FLOAT* [out]: attenuation in millibels.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetAttenuation"

HRESULT CDirectSoundSecondaryBuffer::GetAttenuation(FLOAT* pfAttenuation)
{
    DPF_ENTER();

    // FIXME: this function needs to obtain the buffer's true attenuation
    // (i.e. the attenuation set via SetVolume() plus the extra attenuation
    // caused by DS3D processing).  Unfortunately we don't have a method in
    // our device buffer class hierarchy (vad.h - CRenderWaveBuffer et al)
    // to obtain a buffer's attenuation.  And the code in ds3d.cpp doesn't
    // explicitly save this info either (it just passes it along to the 3D
    // object implemenation - which in some cases is external to dsound,
    // e.g. ks3d.cpp).
    //
    // So we have two options:
    //
    // - Add a GetVolume() to the CSecondaryRenderWaveBuffer hierarchy;
    //   In some cases it can read the volume directly off the buffer
    //   (e.g. for KS buffers); in others (e.g. VxD buffers) the DDI
    //   doesn't provide for that, so we'd have to remember the last
    //   successfully set volume and return that (this last may be the
    //   best implementation; in fact it may be possibly to do it just
    //   once, in the base class).
    //
    // - Make the C3dObject hierarchy do attenuation calculations for
    //   all 3d objects (even KS ones that don't require it), and save
    //   the result.
    //
    // The first option looks much easier.
    // (MANBUG 39130 - POSTPONED TO DX8.1)
    
    HRESULT hr = DS_OK;
    *pfAttenuation = 0.0f;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Sets the volume and pan for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume.
 *      LONG [in]: new pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetAttenuation"

HRESULT CDirectSoundSecondaryBuffer::SetAttenuation(LONG lVolume, LONG lPan)
{
    BOOL                    fContinue   = TRUE;
    HRESULT                 hr          = DS_OK;
    DSVOLUMEPAN             dsvp;

    DPF_ENTER();

    // Calculate the attenuation based on the volume and pan
    if(SUCCEEDED(hr) && fContinue)
    {
        FillDsVolumePan(lVolume, lPan, &dsvp);
    }

    // Update the 3D object
    if(SUCCEEDED(hr) && m_p3dBuffer && fContinue)
    {
        hr = m_p3dBuffer->SetAttenuation(&dsvp, &fContinue);
    }

    // Update the device buffer
    if(SUCCEEDED(hr) && fContinue)
    {
        hr = m_pDeviceBuffer->SetAttenuation(&dsvp);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetNotificationPositions"

HRESULT CDirectSoundSecondaryBuffer::SetNotificationPositions(DWORD dwCount, LPCDSBPOSITIONNOTIFY paNotes)
{
    HRESULT                 hr              = DS_OK;
    LPDSBPOSITIONNOTIFY     paNotesOrdered  = NULL;
    DWORD                   dwState;

    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLPOSITIONNOTIFY");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Validate notifications
    if(SUCCEEDED(hr))
    {
        hr = ValidateNotificationPositions(m_dsbd.dwBufferBytes, dwCount, paNotes, m_dsbd.lpwfxFormat->nBlockAlign, &paNotesOrdered);
    }

    // We must be stopped in order to set notification positions
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->GetState(&dwState);

        if(SUCCEEDED(hr) && dwState & VAD_BUFFERSTATE_STARTED)
        {
            RPF(DPFLVL_ERROR, "Buffer must be stopped before setting notification positions");
            hr = DSERR_INVALIDCALL;
        }
    }

    // Set notifications
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->SetNotificationPositions(dwCount, paNotesOrdered);
    }

    MEMFREE(paNotesOrdered);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetOwningSink
 *
 *  Description:
 *      Sets the owning CDirectSoundSink object for this buffer.
 *
 *  Arguments:
 *      CDirectSoundSink * [in]: The new the owning sink object.
 *
 *  Returns:
 *      void 
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetOwningSink"

void CDirectSoundSecondaryBuffer::SetOwningSink(CDirectSoundSink* pOwningSink)
{
    DPF_ENTER();

    ASSERT(m_dsbd.dwFlags & DSBCAPS_SINKIN);
    ASSERT(m_pOwningSink == NULL);
    CHECK_WRITE_PTR(pOwningSink);

    m_pOwningSink = pOwningSink;
    m_pOwningSink->AddRef();

    m_pDeviceBuffer->SetOwningSink(pOwningSink);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives play cursor position.
 *      LPDWORD [out]: receives write cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetCurrentPosition"

HRESULT CDirectSoundSecondaryBuffer::GetCurrentPosition(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwPlay;
    DWORD                   dwWrite;

    DPF_ENTER();

    // Forbid certain calls for MIXIN and SINKIN buffers
    if(m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN))
    {
        RPF(DPFLVL_ERROR, "GetCurrentPosition() not valid for MIXIN/sink buffers");
        hr = DSERR_INVALIDCALL;
    }

    // Check for BUFFERLOST
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        hr = DSERR_BUFFERLOST;
    }

    // We save the position to local variables so that the object we're
    // calling into doesn't have to worry about whether one or both of
    // the arguments are NULL.
    if(SUCCEEDED(hr))
    {
        if( m_pDirectSound->m_ahAppHacks.vdtCachePositions & m_pDirectSound->m_pDevice->m_vdtDeviceType )
        {
            // App hack for Furby calling GetCurrentPosition every .5ms on multiple buffers which stresses NT/WDM systems
            DWORD dwNow = timeGetTime();
            if( m_dwAHLastGetPosTime > 0 && 
                dwNow >= m_dwAHLastGetPosTime &&   // catch unlikely wrap-around and '=' because of 5ms accuracy of timeGetTime()
                dwNow - m_dwAHLastGetPosTime < 5 ) // 5ms tolerance
            {
                dwPlay  = m_dwAHCachedPlayPos;
                dwWrite = m_dwAHCachedWritePos;
            }
            else
            {
                hr = m_pDeviceBuffer->GetCursorPosition(&dwPlay, &dwWrite);
                m_dwAHCachedPlayPos  = dwPlay;
                m_dwAHCachedWritePos = dwWrite;
            }
            m_dwAHLastGetPosTime = dwNow;
        }
        else
        {
            hr = m_pDeviceBuffer->GetCursorPosition(&dwPlay, &dwWrite);
        }
    }

    // Block-align the positions
    if(SUCCEEDED(hr))
    {
        dwPlay = BLOCKALIGN(dwPlay, m_dsbd.lpwfxFormat->nBlockAlign);
        dwWrite = BLOCKALIGN(dwWrite, m_dsbd.lpwfxFormat->nBlockAlign);
    }

    // Apply app-hacks and cursor adjustments
    if(SUCCEEDED(hr))
    {
        // If the buffer has effects, we return the FX cursor as the write cursor
        if(HasFX())
        {
            DWORD dwDistance = BytesToMs(DISTANCE(dwWrite, m_dwSliceEnd, GetBufferSize()), Format());
            if (dwDistance > 200)
                DPF(DPFLVL_WARNING, "FX cursor suspiciously far ahead of write cursor (%ld ms)", dwDistance);
            else
                dwWrite = m_dwSliceEnd;  // FIXME: may not always be valid
        }

        if (m_pDirectSound->m_ahAppHacks.lCursorPad)
        {
            dwPlay = PadCursor(dwPlay, m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat, m_pDirectSound->m_ahAppHacks.lCursorPad);
            dwWrite = PadCursor(dwWrite, m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat, m_pDirectSound->m_ahAppHacks.lCursorPad);
        }

        if(m_pDirectSound->m_ahAppHacks.vdtReturnWritePos & m_pDirectSound->m_pDevice->m_vdtDeviceType)
        {
            dwPlay = dwWrite;
        }

        if(m_pDirectSound->m_ahAppHacks.swpSmoothWritePos.fEnable)
        {
            dwWrite = PadCursor(dwPlay, m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat, m_pDirectSound->m_ahAppHacks.swpSmoothWritePos.lCursorPad);
        }
    }

    // Success
    if(SUCCEEDED(hr) && pdwPlay)
    {
        *pdwPlay = dwPlay;
    }

    if(SUCCEEDED(hr) && pdwWrite)
    {
        *pdwWrite = dwWrite;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetCurrentPosition
 *
 *  Description:
 *      Sets the current play position for a given buffer.
 *
 *  Arguments:
 *      DWORD [in]: new play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetCurrentPosition"

HRESULT CDirectSoundSecondaryBuffer::SetCurrentPosition(DWORD dwPlay)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Forbid certain calls for MIXIN and SINKIN buffers
    if(m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN))
    {
        RPF(DPFLVL_ERROR, "SetCurrentPosition() not valid for MIXIN/sink buffers");
        hr = DSERR_INVALIDCALL;
    }

    // Check for BUFFERLOST
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        hr = DSERR_BUFFERLOST;
    }

    // Check the cursor position
    if(SUCCEEDED(hr) && dwPlay >= m_dsbd.dwBufferBytes)
    {
        RPF(DPFLVL_ERROR, "Cursor position out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    // Make sure dwPlay is block-aligned
    if(SUCCEEDED(hr))
    {
        dwPlay = BLOCKALIGN(dwPlay, m_dsbd.lpwfxFormat->nBlockAlign);
    }

    // Prime the effects chain for the new play position
    if(SUCCEEDED(hr) && HasFX())
    {
        hr = m_fxChain->PreRollFx(dwPlay);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->SetCursorPosition(dwPlay);
    }

    // Mark the play state as stopped to force the streaming thread
    // to react to our new cursor position
    if(SUCCEEDED(hr))
    {
        m_playState = Stopped;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Retrieves status for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the status.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetStatus"

HRESULT CDirectSoundSecondaryBuffer::GetStatus(LPDWORD pdwStatus)
{
    HRESULT                 hr          = DS_OK;
    DWORD                   dwStatus;
    DWORD                   dwState;
    VADRBUFFERCAPS          vrbc;

    DPF_ENTER();

    // Update the buffer status.  If we're lost, that's the only state we care about
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        dwStatus = DSBSTATUS_BUFFERLOST;
    }
    else
    {
        // Get the current device buffer state
        hr = m_pDeviceBuffer->GetState(&dwState);

        if(SUCCEEDED(hr))
        {
            dwStatus = m_dwStatus;
            UpdateBufferStatusFlags(dwState, &m_dwStatus);
        
            // If we thought we were playing, but now we're stopped, handle
            // the transition.
            if((dwStatus & DSBSTATUS_PLAYING) && !(m_dwStatus & DSBSTATUS_PLAYING))
            {
                hr = Stop();
            }
        }

        // Fill in the buffer location
        if(SUCCEEDED(hr))
        {
            m_dwStatus &= ~DSBSTATUS_LOCMASK;

            if(m_dwStatus & DSBSTATUS_RESOURCESACQUIRED)
            {
                hr = m_pDeviceBuffer->GetCaps(&vrbc);

                if(SUCCEEDED(hr))
                {
                    m_dwStatus |= DSBCAPStoDSBSTATUS(vrbc.dwFlags);
                }
            }
        }

        if(SUCCEEDED(hr))
        {
            dwStatus = m_dwStatus;
        }
    }

    // Mask off bits that shouldn't get back to the app
    if(SUCCEEDED(hr))
    {
        dwStatus &= DSBSTATUS_USERMASK;
    }

    if(SUCCEEDED(hr) && !(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        dwStatus &= ~DSBSTATUS_LOCDEFERMASK;
    }

    if(SUCCEEDED(hr) && pdwStatus)
    {
        *pdwStatus = dwStatus;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Play
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      DWORD [in]: priority.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Play"

HRESULT CDirectSoundSecondaryBuffer::Play(DWORD dwPriority, DWORD dwFlags)
{
#ifdef DEBUG
    const ULONG             ulKsIoctlCount  = g_ulKsIoctlCount;
#endif // DEBUG

    DWORD                   dwState = VAD_BUFFERSTATE_STARTED;
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    // Make sure cooperative level has been set
    if(SUCCEEDED(hr) && (!m_pDirectSound->m_dsclCooperativeLevel.dwThreadId || DSSCL_NONE == m_pDirectSound->m_dsclCooperativeLevel.dwPriority))
    {
        RPF(DPFLVL_ERROR, "Cooperative level must be set before calling Play");
        hr = DSERR_PRIOLEVELNEEDED;
    }

    // Priority is only valid if we're LOCDEFER
    if(SUCCEEDED(hr) && dwPriority && !(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        RPF(DPFLVL_ERROR, "Priority is only valid on LOCDEFER buffers");
        hr = DSERR_INVALIDPARAM;
    }

    // Validate flags
    if(SUCCEEDED(hr) && (dwFlags & DSBPLAY_LOCDEFERMASK) && !(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        RPF(DPFLVL_ERROR, "Specified a flag that is only valid on LOCDEFER buffers");
        hr = DSERR_INVALIDPARAM;
    }

    // For MIXIN/sink buffers, the DSBPLAY_LOOPING flag is mandatory
    if(SUCCEEDED(hr) && GetBufferType() && !(dwFlags & DSBPLAY_LOOPING))
    {
        RPF(DPFLVL_ERROR, "The LOOPING flag must always be set for MIXIN/sink buffers");
        hr = DSERR_INVALIDPARAM;
    }

    // Check for BUFFERLOST
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        hr = DSERR_BUFFERLOST;
    }

    // Refresh the current buffer status
    if(SUCCEEDED(hr))
    {
        hr = GetStatus(NULL);
    }

    // Set buffer priority
    if(SUCCEEDED(hr))
    {
        m_dwPriority = dwPriority;
    }

    // Reset the special success code
    m_pDeviceBuffer->m_hrSuccessCode = DS_OK;

    // Make sure resources have been acquired
    if(SUCCEEDED(hr))
    {
        hr = AttemptResourceAcquisition(dwFlags);
    }

    // Set the buffer state
    if(SUCCEEDED(hr))
    {
        if(dwFlags & DSBPLAY_LOOPING)
        {
            dwState |= VAD_BUFFERSTATE_LOOPING;
        }

        hr = SetBufferState(dwState);
    }

    if(SUCCEEDED(hr))
    {
        // If the buffer was previously terminated, remove the flag from the status
        m_dwStatus &= ~DSBSTATUS_TERMINATED;

        // Make it possible to steal this buffer's resources
        m_fCanStealResources = TRUE;
    }

    // Save the result code
    m_hrPlay = hr;

#ifdef DEBUG
    if(IS_KS_VAD(m_pDirectSound->m_pDevice->m_vdtDeviceType))
    {
        DPF(DPFLVL_INFO, "%s used %lu IOCTLs", TEXT(DPF_FNAME), g_ulKsIoctlCount - ulKsIoctlCount);
    }
#endif // DEBUG

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops playing the given buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Stop"

HRESULT CDirectSoundSecondaryBuffer::Stop(void)
{
#ifdef DEBUG
    const ULONG             ulKsIoctlCount  = g_ulKsIoctlCount;
#endif // DEBUG

    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

#ifdef ENABLE_PERFLOG
    // Check if there were any glitches
    if (m_pPerfState)
    {
        m_pPerfState->OnUnlockBuffer(0, GetBufferSize());
    }
#endif

    // Check for BUFFERLOST
    if(m_dwStatus & DSBSTATUS_BUFFERLOST)
    {
        hr = DSERR_BUFFERLOST;
    }

    // Set the buffer state
    if(SUCCEEDED(hr))
    {
        hr = SetBufferState(VAD_BUFFERSTATE_STOPPED);
    }

    // If we're LOCDEFER and the buffer is stopped, resources can be freed
    if(SUCCEEDED(hr) && (m_dsbd.dwFlags & DSBCAPS_LOCDEFER) && (m_dwStatus & DSBSTATUS_RESOURCESACQUIRED))
    {
        hr = FreeResources(FALSE);
    }

#ifdef DEBUG
    if(IS_KS_VAD(m_pDirectSound->m_pDevice->m_vdtDeviceType))
    {
        DPF(DPFLVL_MOREINFO, "%s used %lu IOCTLs", TEXT(DPF_FNAME), g_ulKsIoctlCount - ulKsIoctlCount);
    }
#endif // DEBUG

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetBufferState
 *
 *  Description:
 *      Sets the buffer play/stop state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetBufferState"

HRESULT CDirectSoundSecondaryBuffer::SetBufferState(DWORD dwNewState)
{
    DWORD                   dwOldState;
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDeviceBuffer->GetState(&dwOldState);

    if(SUCCEEDED(hr) && dwNewState != dwOldState)
    {
        // Our state is changing; reset the performance tracing state
        #ifdef ENABLE_PERFLOG
        if (PerflogTracingEnabled())
        {
            if (!m_pPerfState)
                m_pPerfState = NEW(BufferPerfState(this));
            if (m_pPerfState) 
                m_pPerfState->Reset();
        }
        #endif

        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p going from %s to %s", this, StateName(dwOldState), StateName(dwNewState));

        hr = m_pDeviceBuffer->SetState(dwNewState);

        if (SUCCEEDED(hr) && HasSink())
        {
            #ifdef FUTURE_WAVE_SUPPORT
            if ((m_dsbd.dwFlags & DSBCAPS_FROMWAVEOBJECT) && (dwNewState & VAD_BUFFERSTATE_STARTED))
                hr = m_pOwningSink->Activate(TRUE);

            // FIXME: maybe this activation should be handled by the sink
            // itself in SetBufferState() below, so it can also take care
            // of deactivation when it runs out of active clients

            if (SUCCEEDED(hr))
            #endif // FUTURE_WAVE_SUPPORT

            hr = m_pOwningSink->SetBufferState(this, dwNewState, dwOldState);
        }

        if (SUCCEEDED(hr) && HasFX())
            hr = m_fxChain->NotifyState(dwNewState);

        // If a MIXIN or SINKIN buffer is stopping, clear it and set its position to 0
        if (SUCCEEDED(hr) && GetBufferType() && !(dwNewState & VAD_BUFFERSTATE_STARTED))
        {
            ClearWriteBuffer();  // FIXME - does this simplify the sink?
            ClearPlayBuffer();
            m_pDeviceBuffer->SetCursorPosition(0);
            m_playState = Stopped;  // This stops FX processing on this buffer,
                                    // and forces the streaming thread to reset
                                    // our current slice next time it wakes up
            m_dwSliceBegin = m_dwSliceEnd = MAX_DWORD;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Activate
 *
 *  Description:
 *      Activates or deactivates the buffer object.
 *
 *  Arguments:
 *      BOOL [in]: Activation state.  TRUE to activate, FALSE to deactivate.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Activate"

HRESULT CDirectSoundSecondaryBuffer::Activate(BOOL fActive)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = SetMute(!fActive);

    if(SUCCEEDED(hr))
    {
        if(fActive)
        {
            m_dwStatus |= DSBSTATUS_ACTIVE;

            // If we're a MIXIN or SINKIN buffer, we have to clear our lost
            // status (since the app can't call Restore() to do it for us)
            if (GetBufferType())
            {
                // If the buffer was playing before it got lost, restart it
                if (m_dwStatus & DSBSTATUS_STOPPEDBYFOCUS)
                    hr = SetBufferState(VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING);

                // Clear our BUFFERLOST and STOPPEDBYFOCUS status flags
                m_dwStatus &= ~(DSBSTATUS_BUFFERLOST | DSBSTATUS_STOPPEDBYFOCUS);
            }
        }
        else
        {
            m_dwStatus &= ~DSBSTATUS_ACTIVE;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Mutes or unmutes the buffer.
 *
 *  Arguments:
 *      BOOL [in]: Mute state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetMute"

HRESULT CDirectSoundSecondaryBuffer::SetMute(BOOL fMute)
{
    BOOL                    fContinue   = TRUE;
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    // Only set the mute status if it's changed
    if(SUCCEEDED(hr) && fMute == m_fMute)
    {
        fContinue = FALSE;
    }

    // Update the 3D object
    if(SUCCEEDED(hr) && m_p3dBuffer && fContinue)
    {
        hr = m_p3dBuffer->SetMute(fMute, &fContinue);
    }

    // Update the device buffer
    if(SUCCEEDED(hr) && fContinue)
    {
        hr = m_pDeviceBuffer->SetMute(fMute);
    }

    // Update our local copy
    if(SUCCEEDED(hr))
    {
        m_fMute = fMute;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks the buffer memory to allow for writing.
 *
 *  Arguments:
 *      DWORD [in]: offset, in bytes, from the start of the buffer to where
 *                  the lock begins. This parameter is ignored if
 *                  DSBLOCK_FROMWRITECURSOR is specified in the dwFlags
 *                  parameter.
 *      DWORD [in]: size, in bytes, of the portion of the buffer to lock.
 *                  Note that the sound buffer is conceptually circular.
 *      LPVOID * [out]: address for a pointer to contain the first block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the ppvAudioPtr1 parameter. If this
 *                     value is less than the dwWriteBytes parameter,
 *                     ppvAudioPtr2 will point to a second block of sound
 *                     data.
 *      LPVOID * [out]: address for a pointer to contain the second block of
 *                      the sound buffer to be locked. If the value of this
 *                      parameter is NULL, the ppvAudioPtr1 parameter
 *                      points to the entire locked portion of the sound
 *                      buffer.
 *      LPDWORD [out]: address of a variable to contain the number of bytes
 *                     pointed to by the ppvAudioPtr2 parameter. If
 *                     ppvAudioPtr2 is NULL, this value will be 0.
 *      DWORD [in]: locking flags
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Lock"

HRESULT CDirectSoundSecondaryBuffer::Lock(DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Forbid certain calls for MIXIN and SINKIN buffers
    if(m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN))
    {
        RPF(DPFLVL_ERROR, "Lock() not valid for MIXIN/sink buffers");
        hr = DSERR_INVALIDCALL;
    }

    // Check for BUFFERLOST
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        hr = DSERR_BUFFERLOST;
    }

    // Handle flags
    if(SUCCEEDED(hr) && (dwFlags & DSBLOCK_FROMWRITECURSOR))
    {
        hr = GetCurrentPosition(NULL, &dwWriteCursor);
    }

    if(SUCCEEDED(hr) && (dwFlags & DSBLOCK_ENTIREBUFFER))
    {
        dwWriteBytes = m_dsbd.dwBufferBytes;
    }

    // Cursor validation
    if(SUCCEEDED(hr) && dwWriteCursor >= m_dsbd.dwBufferBytes)
    {
        ASSERT(!(dwFlags & DSBLOCK_FROMWRITECURSOR));

        RPF(DPFLVL_ERROR, "Write cursor past buffer end");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && dwWriteBytes > m_dsbd.dwBufferBytes)
    {
        ASSERT(!(dwFlags & DSBLOCK_ENTIREBUFFER));

        RPF(DPFLVL_ERROR, "Lock size larger than buffer size");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !dwWriteBytes)
    {
        ASSERT(!(dwFlags & DSBLOCK_ENTIREBUFFER));

        RPF(DPFLVL_ERROR, "Lock size must be > 0");
        hr = DSERR_INVALIDPARAM;
    }

    // Lock the device buffer
    if(SUCCEEDED(hr))
    {
        if (GetDsVersion() >= DSVERSION_DX8)
        {
            // DX8 removes support for apps that lock their buffers
            // and never bother to unlock them again (see the comment
            // in CVxdSecondaryRenderWaveBuffer::Lock for explanation)
            hr = DirectLock(dwWriteCursor, dwWriteBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2);
        }
        else    
        {
            hr = m_pDeviceBuffer->Lock(dwWriteCursor, dwWriteBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks the given buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Unlock"

HRESULT CDirectSoundSecondaryBuffer::Unlock(LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Forbid certain calls for MIXIN and SINKIN buffers
    if(m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN))
    {
        RPF(DPFLVL_ERROR, "Unlock() not valid for MIXIN/sink buffers");
        hr = DSERR_INVALIDCALL;
    }

    // Check for BUFFERLOST
    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        hr = DSERR_BUFFERLOST;
    }

    // Unlock the device buffer
    if(SUCCEEDED(hr))
    {
        if (GetDsVersion() >= DSVERSION_DX8)
        {
            // DX8 removes support for apps that lock their buffers
            // and never bother to unlock them again (see the comment
            // in CVxdSecondaryRenderWaveBuffer::Lock for explanation)
            hr = DirectUnlock(pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
        }
        else
        {
            hr = m_pDeviceBuffer->Unlock(pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
        }
    }

    // Update the processed FX buffer if necessary
    if(SUCCEEDED(hr) && HasFX())
    {
        m_fxChain->UpdateFx(pvAudioPtr1, dwAudioBytes1);
        if (pvAudioPtr2 && dwAudioBytes2)
            m_fxChain->UpdateFx(pvAudioPtr2, dwAudioBytes2);
    }

#ifdef ENABLE_PERFLOG
    // Check if there were any glitches
    if (m_pPerfState)
    {
        if (pvAudioPtr1)
            m_pPerfState->OnUnlockBuffer(PtrDiffToUlong(LPBYTE(pvAudioPtr1) - GetPlayBuffer()), dwAudioBytes1);
        if (pvAudioPtr2)
            m_pPerfState->OnUnlockBuffer(PtrDiffToUlong(LPBYTE(pvAudioPtr2) - GetPlayBuffer()), dwAudioBytes2);
    }
#endif

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Lose
 *
 *  Description:
 *      Flags the buffer as lost.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Lose"

HRESULT CDirectSoundSecondaryBuffer::Lose(void)
{
    DPF_ENTER();

    if(!(m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        // If the buffer is MIXIN or SINKIN, and is currently playing,
        // flag it as stopped due to a focus change
        if (GetBufferType())
        {
            DWORD dwState = 0;
            m_pDeviceBuffer->GetState(&dwState);
            if (dwState & VAD_BUFFERSTATE_STARTED)
                m_dwStatus |= DSBSTATUS_STOPPEDBYFOCUS;
        }

        // Stop the buffer.  All lost buffers are stopped by definition.
        SetBufferState(VAD_BUFFERSTATE_STOPPED);

        // Flag the buffer as lost
        m_dwStatus |= DSBSTATUS_BUFFERLOST;

        // Deactivate the buffer
        Activate(FALSE);

        // Free any open locks on the buffer
        m_pDeviceBuffer->OverrideLocks();
    }

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  Restore
 *
 *  Description:
 *      Attempts to restore a lost bufer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::Restore"

HRESULT CDirectSoundSecondaryBuffer::Restore(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Forbid certain calls for MIXIN and SINKIN buffers
    if(m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN))
    {
        RPF(DPFLVL_ERROR, "Restore() not valid for MIXIN/sink buffers");
        hr = DSERR_INVALIDCALL;
    }

    if(SUCCEEDED(hr) && (m_dwStatus & DSBSTATUS_BUFFERLOST))
    {
        // Are we still lost?
        if(DSBUFFERFOCUS_LOST == g_pDsAdmin->GetBufferFocusState(this))
        {
            hr = DSERR_BUFFERLOST;
        }
        else
        {
            m_dwStatus &= ~DSBSTATUS_BUFFERLOST;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetVoiceManagerMode
 *
 *  Description:
 *      Gets the current voice manager mode.
 *
 *  Arguments:
 *      VmMode * [out]: receives voice manager mode.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetVoiceManagerMode"

HRESULT CDirectSoundSecondaryBuffer::GetVoiceManagerMode(VmMode *pvmmMode)
{
    DPF_ENTER();

    *pvmmMode = m_pDirectSound->m_vmmMode;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetVoiceManagerMode
 *
 *  Description:
 *      Sets the current voice manager mode.
 *
 *  Arguments:
 *      VmMode [in]: voice manager mode.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetVoiceManagerMode"

HRESULT CDirectSoundSecondaryBuffer::SetVoiceManagerMode(VmMode vmmMode)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(vmmMode < DSPROPERTY_VMANAGER_MODE_FIRST || vmmMode > DSPROPERTY_VMANAGER_MODE_LAST)
    {
        RPF(DPFLVL_ERROR, "Invalid Voice Manager mode");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        m_pDirectSound->m_vmmMode = vmmMode;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetVoiceManagerPriority
 *
 *  Description:
 *      Gets the current voice manager priority.
 *
 *  Arguments:
 *      LPDWORD [out]: receives voice manager priority.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetVoiceManagerPriority"

HRESULT CDirectSoundSecondaryBuffer::GetVoiceManagerPriority(LPDWORD pdwPriority)
{
    DPF_ENTER();

    *pdwPriority = m_dwVmPriority;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetVoiceManagerPriority
 *
 *  Description:
 *      Sets the current voice manager priority.
 *
 *  Arguments:
 *      DWORD [in]: voice manager priority.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetVoiceManagerPriority"

HRESULT CDirectSoundSecondaryBuffer::SetVoiceManagerPriority(DWORD dwPriority)
{
    DPF_ENTER();

    m_dwVmPriority = dwPriority;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


#ifdef DEAD_CODE
/***************************************************************************
 *
 *  GetVoiceManagerState
 *
 *  Description:
 *      Gets the current voice manager state.
 *
 *  Arguments:
 *      VmState * [out]: receives voice manager state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetVoiceManagerState"

HRESULT CDirectSoundSecondaryBuffer::GetVoiceManagerState(VmState *pvmsState)
{
    DWORD                   dwStatus;
    HRESULT                 hr;
    DPF_ENTER();

    hr = GetStatus(&dwStatus);

    if(SUCCEEDED(hr))
    {
        if(dwStatus & DSBSTATUS_PLAYING)
        {
            *pvmsState = DSPROPERTY_VMANAGER_STATE_PLAYING3DHW;
        }
        else if(FAILED(m_hrPlay))
        {
            *pvmsState = DSPROPERTY_VMANAGER_STATE_PLAYFAILED;
        }
        else if(dwStatus & DSBSTATUS_TERMINATED)
        {
            *pvmsState = DSPROPERTY_VMANAGER_STATE_BUMPED;
        }
        else
        {
            ASSERT(!dwStatus);
            *pvmsState = DSPROPERTY_VMANAGER_STATE_SILENT;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // DEAD_CODE


/***************************************************************************
 *
 *  SetFX
 *
 *  Description:
 *      Sets a chain of effects on this buffer, replacing any previous
 *      effect chain and, if necessary, allocating or deallocating the
 *      shadow buffer used to hold unprocessed audio .
 *
 *  Arguments:
 *      DWORD [in]: Number of effects.  0 to remove current FX chain.
 *      DSEFFECTDESC * [in]: Array of effect descriptor structures.
 *      DWORD * [out]: Receives the creation statuses of the effects.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetFX"

HRESULT CDirectSoundSecondaryBuffer::SetFX(DWORD dwFxCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes)
{
    DWORD                   dwStatus;
    HRESULT                 hr = DS_OK;
    DPF_ENTER();

    ASSERT(IS_VALID_READ_PTR(pDSFXDesc, dwFxCount * sizeof *pDSFXDesc));
    ASSERT(!pdwResultCodes || IS_VALID_WRITE_PTR(pdwResultCodes, dwFxCount * sizeof *pdwResultCodes));

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLFX))
    {
        RPF(DPFLVL_ERROR, "Buffer was not created with DSBCAPS_CTRLFX flag");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Check the buffer is inactive
    if(SUCCEEDED(hr))
    {
        hr = GetStatus(&dwStatus);
        if(SUCCEEDED(hr) && (dwStatus & DSBSTATUS_PLAYING))
        {
            RPF(DPFLVL_ERROR, "Cannot change effects, because buffer is playing");
            hr = DSERR_INVALIDCALL;
        }
    }

    // Check there are no pending locks on the buffer
    if(SUCCEEDED(hr) && m_pDeviceBuffer->m_pSysMemBuffer->GetLockCount())
    {
        RPF(DPFLVL_ERROR, "Cannot change effects, because buffer has pending locks");
        hr = DSERR_INVALIDCALL;
    }

    if(SUCCEEDED(hr))
    {
        // Release the old FX chain, if necessary
        RELEASE(m_fxChain);

        // If the effects count is 0, we can free up associated resources
        if (dwFxCount == 0)
        {
            m_pDeviceBuffer->m_pSysMemBuffer->FreeFxBuffer();
        }
        else // Allocate the pre-FX buffer and create the FX chain requested
        {
            hr = m_pDeviceBuffer->m_pSysMemBuffer->AllocateFxBuffer();
            if (SUCCEEDED(hr))
            {
                m_fxChain = NEW(CEffectChain(this));
                hr = HRFROMP(m_fxChain);
            }
            if (SUCCEEDED(hr))
            {
                hr = m_fxChain->Initialize(dwFxCount, pDSFXDesc, pdwResultCodes);
            }
            if (SUCCEEDED(hr))
            {
                if (!(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
                {
                    hr = m_fxChain->AcquireFxResources();
                }

                // We need to preserve the return code from AcquireFxResources, in case it's
                // DS_INCOMPLETE, so we omit "hr=" from GetFxStatus (which always succeeds):
                if (pdwResultCodes)
                {
                    m_fxChain->GetFxStatus(pdwResultCodes);
                }
            }
            if (FAILED(hr))
            {
                RELEASE(m_fxChain);
                m_pDeviceBuffer->m_pSysMemBuffer->FreeFxBuffer();
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetFXBufferConfig
 *
 *  Description:
 *      Sets a chain of effects described in a CDirectSoundBufferConfig
 *      object, which represents a buffer description previously loaded
 *      from a file (or other IStream provider).
 *
 *  Arguments:
 *      CDirectSoundBufferConfig * [in]: describes the effects to be set.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetFXBufferConfig"

HRESULT CDirectSoundSecondaryBuffer::SetFXBufferConfig(CDirectSoundBufferConfig* pDSBConfigObj)
{
    DWORD                   dwStatus;
    HRESULT                 hr;
    DPF_ENTER();

    CHECK_READ_PTR(pDSBConfigObj);
    ASSERT(m_dsbd.dwFlags & DSBCAPS_CTRLFX);

    hr = GetStatus(&dwStatus);
    if(SUCCEEDED(hr) && (dwStatus & DSBSTATUS_PLAYING))
    {
        DPF(DPFLVL_ERROR, "Cannot change effects, because buffer is playing");
        hr = DSERR_GENERIC;
    }

    if(SUCCEEDED(hr))
    {
        // Release the old FX chain, if necessary
        RELEASE(m_fxChain);

        // Allocate the pre-FX buffer and create the FX chain requested
        hr = m_pDeviceBuffer->m_pSysMemBuffer->AllocateFxBuffer();
        if (SUCCEEDED(hr))
        {
            m_fxChain = NEW(CEffectChain(this));
            hr = HRFROMP(m_fxChain);
        }
        if (SUCCEEDED(hr))
        {
            hr = m_fxChain->Clone(pDSBConfigObj);
        }
        if (SUCCEEDED(hr) && !(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
        {
            hr = m_fxChain->AcquireFxResources();
        }
        if (FAILED(hr))
        {
            RELEASE(m_fxChain);
            m_pDeviceBuffer->m_pSysMemBuffer->FreeFxBuffer();
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  UserAcquireResources
 *
 *  Description:
 *      Acquires hardware resources, and reports on FX creation status.
 *      The "User" means this is called only from the app (via dsimp.cpp).
 *
 *  Arguments:
 *      DWORD [in]: count of FX status flags to be returned.
 *      LPDWORD [out]: pointer to array of FX status flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::UserAcquireResources"

HRESULT CDirectSoundSecondaryBuffer::UserAcquireResources(DWORD dwFlags, DWORD dwFxCount, LPDWORD pdwResultCodes)
{
    HRESULT                 hr = DS_OK;
    DPF_ENTER();

    // Check that buffer is LOCDEFER
    if(!(m_dsbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        RPF(DPFLVL_ERROR, "AcquireResources() is only valid for buffers created with DSBCAPS_LOCDEFER");
        hr = DSERR_INVALIDCALL;
    }

    if (SUCCEEDED(hr) && pdwResultCodes && (!HasFX() || dwFxCount != m_fxChain->GetFxCount()))
    {
        RPF(DPFLVL_ERROR, "Specified an incorrect effect count");
        hr = DSERR_INVALIDPARAM;
    }

    if (SUCCEEDED(hr))
        hr = AttemptResourceAcquisition(dwFlags);

    // We need to preserve the return code from AttemptResourceAcquisition, in case it's
    // DS_INCOMPLETE, so we omit the "hr=" from GetFxStatus (which always succeeds):
    if (HasFX() && pdwResultCodes)
        m_fxChain->GetFxStatus(pdwResultCodes);

    // If successful, prevent this buffer from having its resources stolen before it's played
    if (SUCCEEDED(hr))
        m_fCanStealResources = FALSE;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetObjectInPath
 *
 *  Description:
 *      Obtains a given interface on a given effect on this buffer.
 *
 *  Arguments:
 *      REFGUID [in]: Class ID of the effect that is being searched for,
 *                    or GUID_ALL_OBJECTS to search for any effect.
 *      DWORD [in]: Index of the effect, in case there is more than one
 *                  effect with this CLSID on this buffer.
 *      REFGUID [in]: IID of the interface requested.  The selected effect
 *                    will be queried for this interface. 
 *      LPVOID * [out]: Receives the interface requested.
 * 
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetObjectInPath"

HRESULT CDirectSoundSecondaryBuffer::GetObjectInPath(REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID *ppObject)
{
    HRESULT hr;
    DPF_ENTER();

    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLFX))
    {
        RPF(DPFLVL_ERROR, "Buffer was not created with DSBCAPS_CTRLFX flag");
        hr = DSERR_CONTROLUNAVAIL;
    }
    if (!HasFX())
    {
        hr = DSERR_OBJECTNOTFOUND;
    }
    else
    {
        hr = m_fxChain->GetEffectInterface(guidObject, dwIndex, iidInterface, ppObject);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetInternalCursors
 *
 *  Description:
 *      This method is used by streamer.cpp and effects.cpp (new in DX8).
 *      It obtains the current play and write cursors from our contained
 *      m_pDeviceBuffer object, and aligns them on sample block boundaries.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the play position.
 *      LPDWORD [out]: receives the write position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetInternalCursors"

HRESULT CDirectSoundSecondaryBuffer::GetInternalCursors(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    DPF_ENTER();

    HRESULT hr = m_pDeviceBuffer->GetCursorPosition(pdwPlay, pdwWrite);
    // ASSERT(SUCCEEDED(hr)); // Removed this ASSERT because the device will
    // sometimes mysteriously disappear out from under us - which is a pity,
    // because we depend utterly on GetCursorPosition() being reliable.

    if (SUCCEEDED(hr))
    {
        // If our device is emulated, add EMULATION_LATENCY_BOOST ms to the write cursor
        // FIXME: this code should be in m_pDeviceBuffer->GetCursorPosition() once we've
        // figured out what's up with cursor reporting on emulation.  For now, let's just
        // avoid regressions!  This method is only used by effects.cpp and dssink.cpp...

// DISABLED UNTIL DX8.1:
//        if (pdwWrite && IsEmulated())
//            *pdwWrite = PadCursor(*pdwWrite, GetBufferSize(), Format(), EMULATION_LATENCY_BOOST);
// OR:
//        if (IsEmulated())
//        {
//            if (pdwPlay)
//                *pdwPlay = PadCursor(*pdwPlay, GetBufferSize(), Format(), EMULATION_LATENCY_BOOST);
//            if (pdwWrite)
//                *pdwWrite = PadCursor(*pdwWrite, GetBufferSize(), Format(), EMULATION_LATENCY_BOOST);
//        }

        // The cursors aren't guaranteed to be on block boundaries - fix them:
        if (pdwPlay)
            *pdwPlay = BLOCKALIGN(*pdwPlay, Format()->nBlockAlign);
        if (pdwWrite)
            *pdwWrite = BLOCKALIGN(*pdwWrite, Format()->nBlockAlign);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCurrentSlice
 *
 *  Description:
 *      Obtains the part of the audio buffer that is being processed
 *      during the streaming thread's current pass.
 *
 *      The "slice" terminology is whimsical but makes it easy to search
 *      for the slice-handling code in an editor.  It's better than yet
 *      another overloaded usage of "buffer".
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer slice start (as byte offset).
 *      LPDWORD [out]: receives buffer slice end (as byte offset).
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::GetCurrentSlice"

void CDirectSoundSecondaryBuffer::GetCurrentSlice(LPDWORD pdwSliceBegin, LPDWORD pdwSliceEnd)
{
    DPF_ENTER();

    // Make sure the slice endpoints have been initialized and are within range
    if (!(m_dsbd.dwFlags & DSBCAPS_SINKIN))
    {
        // NB: Sink buffers can be uninitialized if the sink is starting,
        // or if it decided not to advance its play position on this run.
        ASSERT(m_dwSliceBegin != MAX_DWORD && m_dwSliceEnd != MAX_DWORD);
        ASSERT(m_dwSliceBegin < GetBufferSize() && m_dwSliceEnd < GetBufferSize());
    }

    if (pdwSliceBegin) *pdwSliceBegin = m_dwSliceBegin;
    if (pdwSliceEnd) *pdwSliceEnd = m_dwSliceEnd;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SetCurrentSlice
 *
 *  Description:
 *      Establishes the part of this audio buffer that is being processed
 *      during the streaming thread's current pass.
 *
 *  Arguments:
 *      DWORD [in]: Slice start (as byte offset from audio buffer start),
 *                  or the special argument CURRENT_WRITE_POS which means
 *                  "make the slice start at our current write position".
 *      DWORD [in]: Slice size in bytes.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetCurrentSlice"

void CDirectSoundSecondaryBuffer::SetCurrentSlice(DWORD dwSliceBegin, DWORD dwBytes)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    DPF_TIMING(DPFLVL_MOREINFO, "begin=%lu size=%lu (%s%s%sbuffer%s at 0x%p)", dwSliceBegin, dwBytes,
               m_dsbd.dwFlags & DSBCAPS_MIXIN ? TEXT("MIXIN ") : TEXT(""),
               m_dsbd.dwFlags & DSBCAPS_SINKIN ? TEXT("SINKIN ") : TEXT(""),
               !(m_dsbd.dwFlags & (DSBCAPS_MIXIN|DSBCAPS_SINKIN)) ? TEXT("regular ") : TEXT(""),
               HasFX() ? TEXT(" w/effects") : TEXT(""), this);

    ASSERT(dwBytes > 0 && dwBytes < GetBufferSize());

    if (dwSliceBegin == CURRENT_WRITE_POS)
    {
        hr = GetInternalCursors(NULL, &dwSliceBegin);
        if (SUCCEEDED(hr))
        {
            m_dwSliceBegin = PadCursor(dwSliceBegin, GetBufferSize(), Format(), INITIAL_WRITEAHEAD);
            DPF_TIMING(DPFLVL_MOREINFO, "CURRENT_WRITE_POS is %lu; setting slice start to %lu", dwSliceBegin, m_dwSliceBegin);
        }
        else  // GetInternalCursors failed; stop FX processing and force the
        {     // streaming thread to reset our slice next time it wakes up
            m_playState = Stopped;
            m_dwSliceBegin = m_dwSliceEnd = MAX_DWORD;
        }
    }
    else // dwSliceBegin != CURRENT_WRITE_POS
    {
        // Normal case: set the new slice begin position explicitly
        m_dwSliceBegin = dwSliceBegin;
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(m_dwSliceBegin < GetBufferSize());

        if (HasFX() && m_dwSliceBegin != m_dwSliceEnd)  // Discontinuous buffer slices
            m_fxChain->FxDiscontinuity();  // Inform effects of break in their input data

        m_dwSliceEnd = (m_dwSliceBegin + dwBytes) % GetBufferSize();

        // If this is a MIXIN buffer, write silence to the new slice
        if (m_dsbd.dwFlags & DSBCAPS_MIXIN)
            m_pDeviceBuffer->m_pSysMemBuffer->WriteSilence(m_dsbd.lpwfxFormat->wBitsPerSample, m_dwSliceBegin, m_dwSliceEnd);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  MoveCurrentSlice
 *
 *  Description:
 *      Shifts forward the audio buffer slice that is being processed.
 *
 *  Arguments:
 *      DWORD [in]: Size in bytes for the new buffer slice.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::MoveCurrentSlice"

void CDirectSoundSecondaryBuffer::MoveCurrentSlice(DWORD dwBytes)
{
    DPF_ENTER();

    DPF_TIMING(DPFLVL_MOREINFO, "dwBytes=%lu (%s%s%sbuffer%s at 0x%p)", dwBytes,
               m_dsbd.dwFlags & DSBCAPS_MIXIN ? TEXT("MIXIN ") : TEXT(""),
               m_dsbd.dwFlags & DSBCAPS_SINKIN ? TEXT("SINKIN ") : TEXT(""),
               !(m_dsbd.dwFlags & (DSBCAPS_MIXIN|DSBCAPS_SINKIN)) ? TEXT("regular ") : TEXT(""),
               HasFX() ? TEXT(" w/effects") : TEXT(""), this);

    ASSERT(dwBytes > 0 && dwBytes < GetBufferSize());

    // Slide the current slice forwards and make it dwBytes wide
    if (m_dwSliceBegin == MAX_DWORD) // FIXME: for debugging only
    {
        ASSERT(!"Unset processing slice detected");
        m_playState = Stopped;
        m_dwSliceBegin = m_dwSliceEnd = MAX_DWORD;
        // FIXME: this code can disappear once all bugs are ironed out
    }
    else
    {
        m_dwSliceBegin = m_dwSliceEnd;
    }

    ASSERT(m_dwSliceBegin < GetBufferSize());

    m_dwSliceEnd = (m_dwSliceBegin + dwBytes) % GetBufferSize();

    // If this is a MIXIN buffer, write silence to the new slice
    if (m_dsbd.dwFlags & DSBCAPS_MIXIN)
        m_pDeviceBuffer->m_pSysMemBuffer->WriteSilence(m_dsbd.lpwfxFormat->wBitsPerSample, m_dwSliceBegin, m_dwSliceEnd);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  DirectLock
 *
 *  Description:
 *      An abbreviation for the frequent operation of locking a region of
 *      our contained audio buffer.
 *
 *  Arguments:
 *      DWORD [in]: Byte offset to where the lock begins in the buffer.
 *      DWORD [in]: Size, in bytes, of the portion of the buffer to lock.
 *      LPVOID* [out]: Returns the first part of the locked region.
 *      LPDWORD [out]: Returns the size in bytes of the first part.
 *      LPVOID* [out]: Returns the second part of the locked region.
 *      LPDWORD [out]: Returns the size in bytes of the second part.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::DirectLock"

HRESULT CDirectSoundSecondaryBuffer::DirectLock(DWORD dwPosition, DWORD dwSize, LPVOID* ppvPtr1, LPDWORD pdwSize1, LPVOID* ppvPtr2, LPDWORD pdwSize2)
{
    DPF_ENTER();

    ASSERT(m_pDeviceBuffer != NULL);
    HRESULT hr = m_pDeviceBuffer->CRenderWaveBuffer::Lock(dwPosition, dwSize, ppvPtr1, pdwSize1, ppvPtr2, pdwSize2);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DirectUnlock
 *
 *  Description:
 *      An abbreviation for the frequent operation of unlocking a region of
 *      our contained audio buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::DirectUnlock"

HRESULT CDirectSoundSecondaryBuffer::DirectUnlock(LPVOID pvPtr1, DWORD dwSize1, LPVOID pvPtr2, DWORD dwSize2)
{
    DPF_ENTER();

    ASSERT(m_pDeviceBuffer != NULL);
    HRESULT hr = m_pDeviceBuffer->CRenderWaveBuffer::Unlock(pvPtr1, dwSize1, pvPtr2, dwSize2);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindSendLoop
 *
 *  Description:
 *      Auxiliary function used in effects.cpp to detect send loops.
 *      Returns DSERR_SENDLOOP if a send effect pointing to this buffer
 *      is detected anywhere in the send graph rooted at pCurBuffer.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Current buffer in graph traversal.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code; DSERR_SENDLOOP if a send loop
 *               is found, otherwise DS_OK.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::FindSendLoop"

HRESULT CDirectSoundSecondaryBuffer::FindSendLoop(CDirectSoundSecondaryBuffer* pCurBuffer)
{
    HRESULT hr = DS_OK;

    DPF_ENTER();
    CHECK_WRITE_PTR(pCurBuffer);

    if (pCurBuffer == this)
    {
        RPF(DPFLVL_ERROR, "Send loop detected from buffer at 0x%p to itself", this);
        hr = DSERR_SENDLOOP;
    }
    else if (pCurBuffer->HasFX())
    {
        // Buffer has effects - look for send effects and call ourself recursively.
        for (CNode<CEffect*>* pFxNode = pCurBuffer->m_fxChain->m_fxList.GetListHead();
             pFxNode && SUCCEEDED(hr);
             pFxNode = pFxNode->m_pNext)
        {
            CDirectSoundSecondaryBuffer* pDstBuffer = pFxNode->m_data->GetDestBuffer();
            if (pDstBuffer)
                hr = FindSendLoop(pDstBuffer); 
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CalculateOffset
 *
 *  Description:
 *      Given a CDirectSoundSecondaryBuffer and a byte offset into that
 *      buffer, calculates the "corresponding" byte offset in this buffer
 *      such that both buffers' play cursors will reach their respective
 *      offsets at the same time.  To do this we need to know the exact
 *      difference between the buffers' play positions, which we obtain
 *      using a voting heuristic, since our underlying driver models
 *      (VxD, WDM) don't support this operation directly.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Buffer to get offset from.
 *      DWORD [in]: Position in the buffer to which to synchronize.
 *      DWORD* [out]: Returns the corresponding position in this buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::CalculateOffset"

// Our compiler doesn't allow this POSOFFSET type to be local to
// the function below, because it is used as a template argument.
struct POSOFFSET {LONG offset; int count; POSOFFSET(LONG _o =0) {offset=_o; count=1;}};

HRESULT CDirectSoundSecondaryBuffer::CalculateOffset(CDirectSoundSecondaryBuffer* pDsBuffer, DWORD dwTargetPos, DWORD* pdwSyncPos)
{
    const int nMaxAttempts = 7;  // Getting the cursor positions takes a surprisingly long time
    const int nQuorum = 3;       // How many "votes" are required to determine the offset

    // Note: these arbitrary constants were found to result in an accurate
    // offset calculation "almost always".  An out-of-sync send is very easy
    // to hear (it sound phasy and flangy); if we ever detect this problem in
    // testing, this code should be revisited.

    // Sanity checks
    CHECK_WRITE_PTR(pDsBuffer);
    CHECK_WRITE_PTR(pdwSyncPos);
    ASSERT(dwTargetPos < pDsBuffer->GetBufferSize());

    CList<POSOFFSET> lstOffsets;                // List of cursor offsets found
    CNode<POSOFFSET>* pCheckNode;               // Used to check AddNoteToList failures
    DWORD dwFirstPos1 = 0, dwFirstPos2 = 0;     // First cursor positions found
    DWORD dwPos1, dwPos2;                       // Current cursor positions found
    LONG lOffset;                               // Current offset
    BOOL fOffsetFound = FALSE;                  // Found the best offset?
    int nOurBlockSize = Format()->nBlockAlign;  // Used for brevity below
    int nBufferBlockSize = pDsBuffer->Format()->nBlockAlign; // Ditto
    HRESULT hr = DS_OK;

    DPF_ENTER();

    // Uncomment this to see how long this function takes to run
    // DWORD dwTimeBefore = timeGetTime();

    for (int i=0; i<nMaxAttempts && SUCCEEDED(hr); ++i)
    {
        hr = GetInternalCursors(&dwPos1, NULL);
        if (SUCCEEDED(hr))
            hr = pDsBuffer->GetInternalCursors(&dwPos2, NULL);
        if (SUCCEEDED(hr))
        {
            // Save the first buffer positions found
            if (i == 0)
                dwFirstPos1 = dwPos1, dwFirstPos2 = dwPos2;

            // If we detect a cursor wraparound, start all over again [??]
            if (dwPos1 < dwFirstPos1 || dwPos2 < dwFirstPos2)
            {
#ifdef ENABLE_SENDS  // Debug output for later debugging
                for (int j=0; j<5; ++j)
                {
                    DPF(DPFLVL_INFO, "Take %d: dwPos1=%d < dwFirstPos1=%d || dwPos2=%d < dwFirstPos2=%d", i, dwPos1, dwFirstPos1, dwPos2, dwFirstPos2);
                    Sleep(10); GetInternalCursors(&dwPos1, NULL); pDsBuffer->GetInternalCursors(&dwPos2, NULL);
                }
#endif
                break;
            }

            // Convert dwPos2 from pDsBuffer's sample block units into ours
            dwPos2 = dwPos2 * nOurBlockSize / nBufferBlockSize;

            LONG lNewOffset = dwPos2 - dwPos1;

            DPF_TIMING(DPFLVL_INFO, "Play offset #%d = %ld", i, lNewOffset);

            for (CNode<POSOFFSET>* pOff = lstOffsets.GetListHead(); pOff; pOff = pOff->m_pNext)
                if (pOff->m_data.offset >= lNewOffset - nOurBlockSize &&
                    pOff->m_data.offset <= lNewOffset + nOurBlockSize)
                {   // I.e. if the offsets are equal or only off by 1 sample block
                    ++pOff->m_data.count;
                    break;
                }

            if (pOff == NULL)  // A new offset was found - add it to the list
            {
                pCheckNode = lstOffsets.AddNodeToList(POSOFFSET(lNewOffset));
                ASSERT(pCheckNode != NULL);
            }
            else if (pOff->m_data.count == nQuorum)  // We have a winner!
            {
                lOffset = pOff->m_data.offset;
                fOffsetFound = TRUE;
#ifdef ENABLE_SENDS  // Debug output for later debugging
                DPF(DPFLVL_INFO, "QUORUM REACHED");
#endif
                break;
            }
        }                  
    }

    if (SUCCEEDED(hr) && !fOffsetFound)  // Didn't get enough votes for any one offset
    {
        // Just pick the one with the most "votes"
        int nBestSoFar = 0;
        for (CNode<POSOFFSET>* pOff = lstOffsets.GetListHead(); pOff; pOff = pOff->m_pNext)
            if (pOff->m_data.count > nBestSoFar)
            {
                lOffset = pOff->m_data.offset;
                nBestSoFar = pOff->m_data.count;
            }
        ASSERT(nBestSoFar > 0);
    }

    if (SUCCEEDED(hr))
    {
        // If dwTargetPos is smaller than the play position on pDsBuffer, it must have
        // wrapped around, so we put it back where it would be if it hadn't wrapped
        if (dwTargetPos < dwFirstPos2)
            dwTargetPos += pDsBuffer->GetBufferSize();

        // Convert dwTargetPos from pDsBuffer's sample block units into ours
        dwTargetPos = dwTargetPos * nOurBlockSize / nBufferBlockSize;

        #ifdef DEBUG_TIMING
        if (dwTargetPos - dwFirstPos2*nOurBlockSize/nBufferBlockSize > GetBufferSize())
            ASSERT(!"Sync buffer's target and play positions are further apart than our buffer size");
        #endif
        
        // And finally...
        *pdwSyncPos = dwTargetPos - lOffset;
        if (*pdwSyncPos >= GetBufferSize())
        {
            *pdwSyncPos -= GetBufferSize();
            ASSERT(*pdwSyncPos < GetBufferSize());
        }

        DPF_TIMING(DPFLVL_INFO, "Target buffer size=%lu, play pos=%lu, target pos=%lu", pDsBuffer->GetBufferSize(), dwFirstPos2, dwTargetPos);
        DPF_TIMING(DPFLVL_INFO, "Source buffer size=%lu, play pos=%lu, sync pos=%lu", GetBufferSize(), dwFirstPos1, *pdwSyncPos);
    }

    // Uncomment this to see how long this function takes to run
    // DWORD dwTimeAfter = timeGetTime();
    // DPF(DPFLVL_MOREINFO, "Calculations took %ld ms", dwTimeAfter-dwTimeBefore);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SynchronizeToBuffer
 *
 *  Description:
 *      Synchronizes this buffer's current processing slice to that of the
 *      buffer passed in as an argument.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Buffer to synchronize to.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SynchronizeToBuffer"

void CDirectSoundSecondaryBuffer::SynchronizeToBuffer(CDirectSoundSecondaryBuffer* pSyncBuffer)
{
    DPF_ENTER();

    DWORD dwSliceBegin, dwSliceEnd, dwSliceSize;
    pSyncBuffer->GetCurrentSlice(&dwSliceBegin, &dwSliceEnd);
    dwSliceSize = DISTANCE(dwSliceBegin, dwSliceEnd, pSyncBuffer->GetBufferSize());

    // Convert dwSliceSize from pSyncBuffer's sample block units into ours
    dwSliceSize = dwSliceSize * Format()->nBlockAlign / pSyncBuffer->Format()->nBlockAlign;

    // Convert dwSliceBegin into an offset into our buffer (taking into
    // account the relative play cursors of our buffer and pSyncBuffer)
    CalculateOffset(pSyncBuffer, dwSliceBegin, &dwSliceBegin);

    // Establish our new processing slice
    SetCurrentSlice(dwSliceBegin, dwSliceSize);

    // No point propagating an error to our caller, which is the streaming thread;
    // CalculateOffset() can only fail if GetCurrentPosition() fails, in which case
    // everything will come to a grinding halt soon enough anyway.

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdatePlayState
 *
 *  Description:
 *      Auxiliary function used by the streaming thread to update this
 *      buffer's playing state.  This is called once per buffer when the
 *      effects/streaming thread begins a processing pass; then for the
 *      rest of the pass, individual effects can query our state using
 *      GetPlayState(), without needing to call GetState() repeatedly
 *      on our device buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void) - If GetState() fails, we simply set our state to FALSE.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::UpdatePlayState"

DSPLAYSTATE CDirectSoundSecondaryBuffer::UpdatePlayState(void)
{
    DSPLAYSTATE oldPlayState = m_playState;
    DWORD dwState;
    DPF_ENTER();

    if (SUCCEEDED(m_pDeviceBuffer->GetState(&dwState)))
    {
        if (dwState & VAD_BUFFERSTATE_STARTED)
            if (m_playState <= Playing)
                m_playState = Playing;
            else
                m_playState = Starting;
        else
            if (m_playState >= Stopping)
                m_playState = Stopped;
            else
                m_playState = Stopping;
    }
    else
    {
        DPF(DPFLVL_ERROR, "Cataclysmic GetState() failure");
        m_playState = Stopped;
    }

    if (oldPlayState != m_playState)
    {
        static TCHAR* szStates[] = {TEXT("Starting"), TEXT("Playing"), TEXT("Stopping"), TEXT("Stopped")};
        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p went from %s to %s", this, szStates[oldPlayState], szStates[m_playState]);
    }

    DPF_LEAVE(m_playState);
    return m_playState;
}


/***************************************************************************
 *
 *  SetInitialSlice
 *
 *  Description:
 *      Auxiliary function used by the streaming thread to establish an
 *      initial processing slice for this buffer when it starts playing.
 *      We try to synchronize with an active buffer that is sending to us,
 *      and if none are available we start at our current write cursor.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: Size of processing slice to be established.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetInitialSlice"

void CDirectSoundSecondaryBuffer::SetInitialSlice(REFERENCE_TIME rtSliceSize)
{
    DPF_ENTER();

    if (GetPlayState() == Starting && !(GetBufferType() & DSBCAPS_SINKIN))
    {
        CNode<CDirectSoundSecondaryBuffer*>* pSender;
        for (pSender = m_lstSenders.GetListHead(); pSender; pSender = pSender->m_pNext)
            if (pSender->m_data->IsPlaying())
            {
                // Found an active buffer sending to us
                DPF_TIMING(DPFLVL_INFO, "Synchronizing MIXIN buffer at 0x%p with send buffer at 0x%p", this, pSender->m_data);
                SynchronizeToBuffer(pSender->m_data);
                break;
            }
        if (pSender == NULL)
        {
            DPF_TIMING(DPFLVL_INFO, "No active buffers found sending to MIXIN buffer at 0x%p", this);
            SetCurrentSlice(CURRENT_WRITE_POS, RefTimeToBytes(rtSliceSize, Format()));
        }
    }

    DPF_LEAVE_VOID();
}


#ifdef FUTURE_MULTIPAN_SUPPORT
/***************************************************************************
 *
 *  SetChannelVolume
 *
 *  Description:
 *      Sets the volume on a set of output channels for a given mono buffer.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBuffer::SetChannelVolume"

HRESULT CDirectSoundSecondaryBuffer::SetChannelVolume(DWORD dwChannelCount, LPDWORD pdwChannels, LPLONG plVolumes)
{
    HRESULT                 hr = DS_OK;
    BOOL                    fChanged = FALSE;
    DPF_ENTER();

    // Check access rights
    if(!(m_dsbd.dwFlags & DSBCAPS_CTRLCHANNELVOLUME))
    {
        RPF(DPFLVL_ERROR, "Buffer does not have CTRLCHANNELVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Check if channel levels have changed
    if(SUCCEEDED(hr))
    {
        if (dwChannelCount != m_dwChannelCount)
            fChanged = TRUE;
        else for (DWORD i=0; i<dwChannelCount && !fChanged; ++i)
            if (pdwChannels[i] != m_pdwChannels[i] || plVolumes[i] != m_plChannelVolumes[i])
                fChanged = TRUE;
    }
                
    // Set channel volumes if they've changed
    if(SUCCEEDED(hr) && fChanged)
    {
        hr = m_pDeviceBuffer->SetChannelAttenuations(m_lVolume, dwChannelCount, pdwChannels, plVolumes);

        // Update our local copy if successful
        if(SUCCEEDED(hr))
        {
            MEMFREE(m_pdwChannels);
            MEMFREE(m_plChannelVolumes);
            m_pdwChannels = MEMALLOC_A(DWORD, dwChannelCount);
            hr = HRFROMP(m_pdwChannels);
        }
        if (SUCCEEDED(hr))
        {
            m_plChannelVolumes = MEMALLOC_A(LONG, dwChannelCount);
            hr = HRFROMP(m_plChannelVolumes);
        }
        if (SUCCEEDED(hr))
        {
            CopyMemory(m_pdwChannels, pdwChannels, sizeof(DWORD) * dwChannelCount);
            CopyMemory(m_plChannelVolumes, plVolumes, sizeof(LONG) * dwChannelCount);
            m_dwChannelCount = dwChannelCount;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // FUTURE_MULTIPAN_SUPPORT


/***************************************************************************
 *
 *  CDirectSound3dListener
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::CDirectSound3dListener"

CDirectSound3dListener::CDirectSound3dListener(CDirectSoundPrimaryBuffer *pParent)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSound3dListener);

    // Initialize defaults
    m_pParent = pParent;
    m_pImpDirectSound3dListener = NULL;
    m_pDevice3dListener = NULL;
    m_hrInit = DSERR_UNINITIALIZED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSound3dListener
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::~CDirectSound3dListener"

CDirectSound3dListener::~CDirectSound3dListener(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSound3dListener);

    // Free 3D listener object
    RELEASE(m_pDevice3dListener);

    // Free interface(s)
    DELETE(m_pImpDirectSound3dListener);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      CPrimaryRenderWaveBuffer * [in]: device buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::Initialize"

HRESULT CDirectSound3dListener::Initialize(CPrimaryRenderWaveBuffer *pDeviceBuffer)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Create the device 3D listener
    hr = pDeviceBuffer->Create3dListener(&m_pDevice3dListener);

    // Create the 3D listener interfaces
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(m_pParent, IID_IDirectSound3DListener, this, &m_pImpDirectSound3dListener);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetAllParameters
 *
 *  Description:
 *      Gets all listener properties.
 *
 *  Arguments:
 *      LPDS3DLISTENER [out]: receives properties.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetAllParameters"

HRESULT CDirectSound3dListener::GetAllParameters(LPDS3DLISTENER pParam)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetAllParameters(pParam);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetDistanceFactor
 *
 *  Description:
 *      Gets the world's distance factor.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives distance factor.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetDistanceFactor"

HRESULT CDirectSound3dListener::GetDistanceFactor(D3DVALUE* pflDistanceFactor)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetDistanceFactor(pflDistanceFactor);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetDopplerFactor
 *
 *  Description:
 *      Gets the world's doppler factor.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives doppler factor.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetDopplerFactor"

HRESULT CDirectSound3dListener::GetDopplerFactor(D3DVALUE* pflDopplerFactor)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetDopplerFactor(pflDopplerFactor);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetOrientation
 *
 *  Description:
 *      Gets the listener's orientation.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives front orientation.
 *      D3DVECTOR* [out]: receives top orientation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetOrientation"

HRESULT CDirectSound3dListener::GetOrientation(D3DVECTOR* pvrOrientationFront, D3DVECTOR* pvrOrientationTop)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetOrientation(pvrOrientationFront, pvrOrientationTop);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetPosition
 *
 *  Description:
 *      Gets the listener's position.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetPosition"

HRESULT CDirectSound3dListener::GetPosition(D3DVECTOR* pvrPosition)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetPosition(pvrPosition);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetRolloffFactor
 *
 *  Description:
 *      Gets the world's rolloff factor.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives rolloff factor.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetRolloffFactor"

HRESULT CDirectSound3dListener::GetRolloffFactor(D3DVALUE* pflRolloffFactor)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetRolloffFactor(pflRolloffFactor);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetVelocity
 *
 *  Description:
 *      Gets the listener's velocity.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives velocity.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::GetVelocity"

HRESULT CDirectSound3dListener::GetVelocity(D3DVECTOR* pvrVelocity)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->GetVelocity(pvrVelocity);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all listener properties.
 *
 *  Arguments:
 *      LPDS3DLISTENER [in]: properties.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetAllParameters"

HRESULT CDirectSound3dListener::SetAllParameters(LPCDS3DLISTENER pParam, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetAllParameters(pParam, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDistanceFactor
 *
 *  Description:
 *      Sets the world's distance factor.
 *
 *  Arguments:
 *      D3DVALUE [in]: distance factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetDistanceFactor"

HRESULT CDirectSound3dListener::SetDistanceFactor(D3DVALUE flDistanceFactor, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetDistanceFactor(flDistanceFactor, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDopplerFactor
 *
 *  Description:
 *      Sets the world's Doppler factor.
 *
 *  Arguments:
 *      D3DVALUE [in]: Doppler factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetDopplerFactor"

HRESULT CDirectSound3dListener::SetDopplerFactor(D3DVALUE flDopplerFactor, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetDopplerFactor(flDopplerFactor, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetOrientation
 *
 *  Description:
 *      Sets the listener's orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: front orientation.
 *      REFD3DVECTOR [in]: top orientation.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetOrientation"

HRESULT CDirectSound3dListener::SetOrientation(REFD3DVECTOR vrOrientationFront, REFD3DVECTOR vrOrientationTop, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetOrientation(vrOrientationFront, vrOrientationTop, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the listener's position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetPosition"

HRESULT CDirectSound3dListener::SetPosition(REFD3DVECTOR vrPosition, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetPosition(vrPosition, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetRolloffFactor
 *
 *  Description:
 *      Sets the world's rolloff factor.
 *
 *  Arguments:
 *      D3DVALUE [in]: rolloff factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetRolloffFactor"

HRESULT CDirectSound3dListener::SetRolloffFactor(D3DVALUE flRolloffFactor, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetRolloffFactor(flRolloffFactor, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the listener's velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: velocity.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetVelocity"

HRESULT CDirectSound3dListener::SetVelocity(REFD3DVECTOR vrVelocity, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetVelocity(vrVelocity, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitDeferredSettings
 *
 *  Description:
 *      Commits deferred settings.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::CommitDeferredSettings"

HRESULT CDirectSound3dListener::CommitDeferredSettings(void)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Commit all listener settings
    hr = m_pDevice3dListener->CommitDeferred();

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetSpeakerConfig
 *
 *  Description:
 *      Sets device speaker configuration.
 *
 *  Arguments:
 *      DWORD [in]: speaker configuration.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dListener::SetSpeakerConfig"

HRESULT CDirectSound3dListener::SetSpeakerConfig(DWORD dwSpeakerConfig)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice3dListener->SetSpeakerConfig(dwSpeakerConfig);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CDirectSound3dBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::CDirectSound3dBuffer"

CDirectSound3dBuffer::CDirectSound3dBuffer(CDirectSoundSecondaryBuffer *pParent)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSound3dBuffer);

    // Initialize defaults
    m_pParent = pParent;
    m_pImpDirectSound3dBuffer = NULL;
    m_pWrapper3dObject = NULL;
    m_pDevice3dObject = NULL;
    m_hrInit = DSERR_UNINITIALIZED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSound3dBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::~CDirectSound3dBuffer"

CDirectSound3dBuffer::~CDirectSound3dBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSound3dBuffer);

    // Free 3D buffer objects
    RELEASE(m_pWrapper3dObject);
    RELEASE(m_pDevice3dObject);

    // Free all interfaces
    DELETE(m_pImpDirectSound3dBuffer);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes a buffer object.  If this function fails, the object
 *      should be immediately deleted.
 *
 *  Arguments:
 *      REFGUID [in]: 3D algorithm identifier.
 *      DWORD [in]: buffer creation flags.
 *      DWORD [in]: buffer frequency.
 *      CDirectSound3dListener * [in]: listener object.
 *      CDirectSound3dBuffer * [in]: source object to duplicate from.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::Initialize"

HRESULT CDirectSound3dBuffer::Initialize(REFGUID guid3dAlgorithm, DWORD dwFlags, DWORD dwFrequency, CDirectSound3dListener *pListener, CDirectSound3dBuffer *pSource)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    const BOOL              fDopplerEnabled         = !MAKEBOOL((dwFlags & DSBCAPS_CTRLFX) && !(dwFlags & DSBCAPS_SINKIN));
    DS3DBUFFER              param;
    HRESULT                 hr;

    DPF_ENTER();

    // Create the wrapper 3D object
    m_pWrapper3dObject = NEW(CWrapper3dObject(pListener->m_pDevice3dListener, guid3dAlgorithm, fMute3dAtMaxDistance, fDopplerEnabled, dwFrequency));
    hr = HRFROMP(m_pWrapper3dObject);

    // Copy the source buffer's 3D properties
    if(SUCCEEDED(hr) && pSource)
    {
        InitStruct(&param, sizeof(param));

        hr = pSource->GetAllParameters(&param);

        if(SUCCEEDED(hr))
        {
            hr = SetAllParameters(&param, 0);
        }
    }

    // Register the 3D buffer interfaces
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(m_pParent, IID_IDirectSound3DBuffer, this, &m_pImpDirectSound3dBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pParent->RegisterInterface(IID_IDirectSound3DBufferPrivate, m_pImpDirectSound3dBuffer, (IDirectSound3DBufferPrivate*)m_pImpDirectSound3dBuffer);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AcquireResources
 *
 *  Description:
 *      Acquires hardware resources.
 *
 *  Arguments:
 *      CSecondaryRenderWaveBuffer * [in]: device buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::AcquireResources"

HRESULT CDirectSound3dBuffer::AcquireResources(CSecondaryRenderWaveBuffer *pDeviceBuffer)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Create the device 3D object
    hr = pDeviceBuffer->Create3dObject(m_pWrapper3dObject->GetListener(), &m_pDevice3dObject);

    if(SUCCEEDED(hr))
    {
        hr = m_pWrapper3dObject->SetObjectPointer(m_pDevice3dObject);
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "3D buffer at 0x%p has acquired resources at 0x%p", this, m_pDevice3dObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeResources
 *
 *  Description:
 *      Frees hardware resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::FreeResources"

HRESULT CDirectSound3dBuffer::FreeResources(void)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Free the device 3D object
    hr = m_pWrapper3dObject->SetObjectPointer(NULL);

    if(SUCCEEDED(hr))
    {
        RELEASE(m_pDevice3dObject);
        DPF(DPFLVL_MOREINFO, "3D buffer at 0x%p has freed its resources", this);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Sets the attenuation for a given buffer.  This function is
 *      overridden in the 3D buffer because the 3D object may need
 *      notification.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: new attenuation.
 *      LPBOOL [out]: receives TRUE if the device buffer should be notified
 *                    of the change.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetAttenuation"

HRESULT CDirectSound3dBuffer::SetAttenuation(PDSVOLUMEPAN pdsvp, LPBOOL pfContinue)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetAttenuation(pdsvp, pfContinue);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the frequency for a given buffer.  This function is
 *      overridden in the 3D buffer because the 3D object may need
 *      notification.
 *
 *  Arguments:
 *      DWORD [in]: new frequency.
 *      LPBOOL [out]: receives TRUE if the device buffer should be notified
 *                    of the change.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetFrequency"

HRESULT CDirectSound3dBuffer::SetFrequency(DWORD dwFrequency, LPBOOL pfContinue)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetFrequency(dwFrequency, pfContinue);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Sets the mute status for a given buffer.  This function is
 *      overridden in the 3D buffer because the 3D object may need
 *      notification.
 *
 *  Arguments:
 *      BOOL [in]: new mute status.
 *      LPBOOL [out]: receives TRUE if the device buffer should be notified
 *                    of the change.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetMute"

HRESULT CDirectSound3dBuffer::SetMute(BOOL fMute, LPBOOL pfContinue)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetMute(fMute, pfContinue);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetAllParameters
 *
 *  Description:
 *      Retrieves all 3D properties for the buffer.
 *
 *  Arguments:
 *      LPDS3DBUFFER [out]: recieves properties.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetAllParameters"

HRESULT CDirectSound3dBuffer::GetAllParameters(LPDS3DBUFFER pParam)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetAllParameters(pParam);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}

/***************************************************************************
 *
 *  GetConeAngles
 *
 *  Description:
 *      Gets inside and outside cone angles.
 *
 *  Arguments:
 *      LPDWORD [out]: receives inside cone angle.
 *      LPDWORD [out]: receives outside cone angle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetConeAngles"

HRESULT CDirectSound3dBuffer::GetConeAngles(LPDWORD pdwInside, LPDWORD pdwOutside)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetConeAngles(pdwInside, pdwOutside);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetConeOrientation
 *
 *  Description:
 *      Gets cone orienation.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives cone orientation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetConeOrientation"

HRESULT CDirectSound3dBuffer::GetConeOrientation(D3DVECTOR* pvrConeOrientation)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetConeOrientation(pvrConeOrientation);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetConeOutsideVolume
 *
 *  Description:
 *      Gets cone orienation.
 *
 *  Arguments:
 *      LPLONG [out]: receives volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetConeOutsideVolume"

HRESULT CDirectSound3dBuffer::GetConeOutsideVolume(LPLONG plVolume)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetConeOutsideVolume(plVolume);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetMaxDistance
 *
 *  Description:
 *      Gets the object's maximum distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives max distance.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetMaxDistance"

HRESULT CDirectSound3dBuffer::GetMaxDistance(D3DVALUE* pflMaxDistance)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetMaxDistance(pflMaxDistance);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetMinDistance
 *
 *  Description:
 *      Gets the object's minimim distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives min distance.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetMinDistance"

HRESULT CDirectSound3dBuffer::GetMinDistance(D3DVALUE* pflMinDistance)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetMinDistance(pflMinDistance);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetMode
 *
 *  Description:
 *      Gets the object's mode.
 *
 *  Arguments:
 *      LPDWORD [out]: receives mode.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetMode"

HRESULT CDirectSound3dBuffer::GetMode(LPDWORD pdwMode)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetMode(pdwMode);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetPosition
 *
 *  Description:
 *      Gets the object's position.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetPosition"

HRESULT CDirectSound3dBuffer::GetPosition(D3DVECTOR* pvrPosition)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetPosition(pvrPosition);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetVelocity
 *
 *  Description:
 *      Gets the object's velocity.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives velocity.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetVelocity"

HRESULT CDirectSound3dBuffer::GetVelocity(D3DVECTOR* pvrVelocity)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->GetVelocity(pvrVelocity);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all object properties.
 *
 *  Arguments:
 *      LPDS3DBUFFER [in]: object parameters.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetAllParameters"

HRESULT CDirectSound3dBuffer::SetAllParameters(LPCDS3DBUFFER pParam, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetAllParameters(pParam, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeAngles
 *
 *  Description:
 *      Sets the sound cone's angles.
 *
 *  Arguments:
 *      DWORD [in]: inside angle.
 *      DWORD [in]: outside angle.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetConeAngles"

HRESULT CDirectSound3dBuffer::SetConeAngles(DWORD dwInside, DWORD dwOutside, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetConeAngles(dwInside, dwOutside, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeOrientation
 *
 *  Description:
 *      Sets the sound cone's orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: orientation.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetConeOrientation"

HRESULT CDirectSound3dBuffer::SetConeOrientation(REFD3DVECTOR vrOrientation, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetConeOrientation(vrOrientation, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetConeOutsideVolume
 *
 *  Description:
 *      Sets the sound cone's outside volume.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetConeOutsideVolume"

HRESULT CDirectSound3dBuffer::SetConeOutsideVolume(LONG lVolume, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetConeOutsideVolume(lVolume, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMaxDistance
 *
 *  Description:
 *      Sets the objects maximum distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE [in]: maximum distance.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetMaxDistance"

HRESULT CDirectSound3dBuffer::SetMaxDistance(D3DVALUE flMaxDistance, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetMaxDistance(flMaxDistance, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMinDistance
 *
 *  Description:
 *      Sets the objects minimum distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE [in]: minimum distance.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetMinDistance"

HRESULT CDirectSound3dBuffer::SetMinDistance(D3DVALUE flMinDistance, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetMinDistance(flMinDistance, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the objects mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetMode"

HRESULT CDirectSound3dBuffer::SetMode(DWORD dwMode, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetMode(dwMode, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the objects position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetPosition"

HRESULT CDirectSound3dBuffer::SetPosition(REFD3DVECTOR vrPosition, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetPosition(vrPosition, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the objects velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: velocity.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::SetVelocity"

HRESULT CDirectSound3dBuffer::SetVelocity(REFD3DVECTOR vrVelocity, DWORD dwFlags)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapper3dObject->SetVelocity(vrVelocity, !(dwFlags & DS3D_DEFERRED));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetAttenuation
 *
 *  Description:
 *      Obtains the buffer's current true attenuation (as opposed to
 *      GetVolume, which just returns the last volume set by the app).
 *
 *  Arguments:
 *      FLOAT* [out]: attenuation in millibels.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound3dBuffer::GetAttenuation"

HRESULT CDirectSound3dBuffer::GetAttenuation(FLOAT* pfAttenuation)
{
    DPF_ENTER();

    HRESULT hr = m_pParent->GetAttenuation(pfAttenuation);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CDirectSoundPropertySet
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::CDirectSoundPropertySet"

CDirectSoundPropertySet::CDirectSoundPropertySet(CUnknown *pParent)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundPropertySet);

    // Set defaults
    m_pParent = pParent;
    m_pImpKsPropertySet = NULL;
    m_pWrapperPropertySet = NULL;
    m_pDevicePropertySet = NULL;
    m_hrInit = DSERR_UNINITIALIZED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundPropertySet
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::~CDirectSoundPropertySet"

CDirectSoundPropertySet::~CDirectSoundPropertySet(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundPropertySet);

    // Free property set objects
    RELEASE(m_pWrapperPropertySet);
    RELEASE(m_pDevicePropertySet);

    // Free interface(s)
    DELETE(m_pImpKsPropertySet);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::Initialize"

HRESULT CDirectSoundPropertySet::Initialize(void)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Create the wrapper property set object
    m_pWrapperPropertySet = NEW(CWrapperPropertySet);
    hr = HRFROMP(m_pWrapperPropertySet);

    // Register interface
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(m_pParent, IID_IKsPropertySet, this, &m_pImpKsPropertySet);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AcquireResources
 *
 *  Description:
 *      Acquires hardware resources.
 *
 *  Arguments:
 *      CRenderWaveBuffer * [in]: device buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::AcquireResources"

HRESULT CDirectSoundPropertySet::AcquireResources(CRenderWaveBuffer *pDeviceBuffer)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Create the device property set object
    ASSERT(m_pDevicePropertySet == NULL);
    hr = pDeviceBuffer->CreatePropertySet(&m_pDevicePropertySet);

    if(SUCCEEDED(hr))
    {
        hr = m_pWrapperPropertySet->SetObjectPointer(m_pDevicePropertySet);
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Property set at 0x%p has acquired resources at 0x%p", this, m_pDevicePropertySet);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeResources
 *
 *  Description:
 *      Frees hardware resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::FreeResources"

HRESULT CDirectSoundPropertySet::FreeResources(void)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Free the device property set object
    hr = m_pWrapperPropertySet->SetObjectPointer(NULL);

    if(SUCCEEDED(hr))
    {
        RELEASE(m_pDevicePropertySet);
        DPF(DPFLVL_MOREINFO, "Property set at 0x%p has freed its resources", this);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  QuerySupport
 *
 *  Description:
 *      Queries for support of a given property set or property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id, or 0 to query for support of the property
 *                  set as a whole.
 *      PULONG [out]: receives support flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::QuerySupport"

HRESULT CDirectSoundPropertySet::QuerySupport(REFGUID guidPropertySetId, ULONG ulPropertyId, PULONG pulSupport)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapperPropertySet->QuerySupport(guidPropertySetId, ulPropertyId, pulSupport);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetProperty
 *
 *  Description:
 *      Gets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: size of property parameters.
 *      LPVOID [out]: receives property data.
 *      PULONG [in/out]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::GetProperty"

HRESULT CDirectSoundPropertySet::GetProperty(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, PULONG pcbPropertyData)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapperPropertySet->GetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, pcbPropertyData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetProperty
 *
 *  Description:
 *      Sets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: size of property parameters.
 *      LPVOID [in]: property data.
 *      ULONG [in]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPropertySet::SetProperty"

HRESULT CDirectSoundPropertySet::SetProperty(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, ULONG cbPropertyData)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pWrapperPropertySet->SetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, cbPropertyData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CDirectSoundSecondaryBufferPropertySet
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer * [in]: parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::CDirectSoundSecondaryBufferPropertySet"

CDirectSoundSecondaryBufferPropertySet::CDirectSoundSecondaryBufferPropertySet(CDirectSoundSecondaryBuffer *pParent)
    : CDirectSoundPropertySet(pParent)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundSecondaryBufferPropertySet);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundSecondaryBufferPropertySet
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::~CDirectSoundSecondaryBufferPropertySet"

CDirectSoundSecondaryBufferPropertySet::~CDirectSoundSecondaryBufferPropertySet(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundSecondaryBufferPropertySet);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  QuerySupport
 *
 *  Description:
 *      Queries for support of a given property set or property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id, or 0 to query for support of the property
 *                  set as a whole.
 *      PULONG [out]: receives support flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::QuerySupport"

HRESULT CDirectSoundSecondaryBufferPropertySet::QuerySupport(REFGUID guidPropertySetId, ULONG ulPropertyId, PULONG pulSupport)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CPropertySetHandler::QuerySupport(guidPropertySetId, ulPropertyId, pulSupport);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetProperty
 *
 *  Description:
 *      Gets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: size of property parameters.
 *      LPVOID [out]: receives property data.
 *      PULONG [in/out]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::GetProperty"

HRESULT CDirectSoundSecondaryBufferPropertySet::GetProperty(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, PULONG pcbPropertyData)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CPropertySetHandler::GetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, pcbPropertyData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetProperty
 *
 *  Description:
 *      Sets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: size of property parameters.
 *      LPVOID [in]: property data.
 *      ULONG [in]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::SetProperty"

HRESULT CDirectSoundSecondaryBufferPropertySet::SetProperty(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, ULONG cbPropertyData)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CPropertySetHandler::SetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, cbPropertyData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UnsupportedQueryHandler
 *
 *  Description:
 *      Queries for support of a given property set or property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id, or 0 to query for support of the property
 *                  set as a whole.
 *      PULONG [out]: receives support flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::UnsupportedQueryHandler"

HRESULT CDirectSoundSecondaryBufferPropertySet::UnsupportedQueryHandler(REFGUID guidPropertySetId, ULONG ulPropertyId, PULONG pulSupport)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CDirectSoundPropertySet::QuerySupport(guidPropertySetId, ulPropertyId, pulSupport);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UnsupportedGetHandler
 *
 *  Description:
 *      Gets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: size of property parameters.
 *      LPVOID [out]: receives property data.
 *      PULONG [in/out]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::UnsupportedGetHandler"

HRESULT CDirectSoundSecondaryBufferPropertySet::UnsupportedGetHandler(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, PULONG pcbPropertyData)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CDirectSoundPropertySet::GetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, pcbPropertyData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UnsupportedSetHandler
 *
 *  Description:
 *      Sets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: size of property parameters.
 *      LPVOID [in]: property data.
 *      ULONG [in]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSecondaryBufferPropertySet::UnsupportedSetHandler"

HRESULT CDirectSoundSecondaryBufferPropertySet::UnsupportedSetHandler(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, ULONG cbPropertyData)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CDirectSoundPropertySet::SetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, cbPropertyData);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dscap.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscap.cpp
 *  Content:    DirectSoundCapture object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   5/25/97    johnnyl Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "nt.h"         // For USER_SHARED_DATA
#include "ntrtl.h"
#include "nturtl.h"
#include "dsoundi.h"


/***************************************************************************
 *
 *  CDirectSoundCapture
 *
 *  Description:
 *      DirectSoundCapture object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::CDirectSoundCapture"

CDirectSoundCapture::CDirectSoundCapture()
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundCapture);

    // Initialize defaults
    m_hrInit = DSERR_UNINITIALIZED;

    // Register the interfaces with the interface manager.  Normally, this
    // would be done in the ::Initialize method, but because we support
    // creating an uninitialized DirectSoundCapture object from CoCreateInstance
    // or IClassFactory::CreateInstance, we have to give at least basic QI
    // support from here.  We don't have to worry about returning an
    // error code because if we run out of memory, QI will return
    // E_NOINTERFACE.
    CreateAndRegisterInterface(this, IID_IDirectSoundCapture, this, &m_pImpDirectSoundCapture);

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CDirectSoundCapture
 *
 *  Description:
 *      DirectSoundCapture object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::CDirectSoundCapture"

CDirectSoundCapture::CDirectSoundCapture
(
    CUnknown* pControllingUnknown
) : CUnknown(pControllingUnknown)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundCapture);

    // Initialize defaults
    m_hrInit = DSERR_UNINITIALIZED;

    // Register the interfaces with the interface manager.  Normally, this
    // would be done in the ::Initialize method, but because we support
    // creating an uninitialized DirectSoundCapture object from CoCreateInstance
    // or IClassFactory::CreateInstance, we have to give at least basic QI
    // support from here.  We don't have to worry about returning an
    // error code because if we run out of memory, QI will return
    // E_NOINTERFACE.
    CreateAndRegisterInterface(this, IID_IDirectSoundCapture, this, &m_pImpDirectSoundCapture);

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundCapture
 *
 *  Description:
 *      DirectSoundCapture object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::~CDirectSoundCapture"

CDirectSoundCapture::~CDirectSoundCapture()
{
    CNode<CDirectSoundCaptureBuffer *> *    pNode;

    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundCapture);

    // Unregister with the administrator
    g_pDsAdmin->UnregisterObject(this);

    // Free all buffers
    while(pNode = m_lstBuffers.GetListHead())
    {
        RPF(DPFLVL_WARNING, "Releasing buffer object");
        pNode->m_data->AbsoluteRelease();
    }

    // Free the audio device
    RELEASE(m_pDevice);

    // Free all interfaces
    DELETE(m_pImpDirectSoundCapture);

    // Close the registry key
    RhRegCloseKey(&m_hkeyParent);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CreateCaptureBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSoundCapture Buffer object.
 *
 *  Arguments:
 *      LPDSCBUFFERDESC [in]: description of the buffer to be created.
 *      CDirectSoundCaptureBuffer ** [out]: receives a pointer to the
 *                                   new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::CreateCaptureBuffer"

HRESULT CDirectSoundCapture::CreateCaptureBuffer(LPCDSCBUFFERDESC pDesc, CDirectSoundCaptureBuffer **ppBuffer)
{
    CDirectSoundCaptureBuffer *    pBuffer = NULL;
    HRESULT                        hr      = DS_OK;

    DPF_ENTER();

    // Create the buffer object
    pBuffer = NEW(CDirectSoundCaptureBuffer(this));
    hr = HRFROMP(pBuffer);

    // Initialize the buffer
    if(SUCCEEDED(hr))
    {
        pBuffer->SetDsVersion(GetDsVersion());  // Always succeeds

        hr = pBuffer->Initialize(pDesc);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        if (!(pDesc->dwFlags & (DSCBCAPS_STRICTFOCUS|DSCBCAPS_FOCUSAWARE)))
        {
            // This is a regular buffer, let's add it to the list
            g_pDsAdmin->UpdateCaptureState();
        }
        *ppBuffer = pBuffer;
    }

    // Free resources
    if(FAILED(hr))
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCCAPS structure with capabilities of the object.
 *
 *  Arguments:
 *      LPDSCCAPS pdscCaps [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::GetCaps"

HRESULT CDirectSoundCapture::GetCaps(LPDSCCAPS pCaps)
{
    DWORD                   dwCertification;
    HRESULT                 hr;

    DPF_ENTER();

    // Get general caps
    hr = m_pDevice->GetCaps(pCaps);

    if(SUCCEEDED(hr))
    {
        ASSERT(!(pCaps->dwFlags & DSCAPS_CERTIFIED));
    }

    // Get certification
    if(SUCCEEDED(hr))
    {
        hr = g_pVadMgr->GetDriverCertificationStatus(m_pDevice, &dwCertification);
    }

    if(SUCCEEDED(hr) && VERIFY_CERTIFIED == dwCertification)
    {
        pCaps->dwFlags |= DSCAPS_CERTIFIED;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.  Normally, an object would have a pointer
 *      to another object of the same type to duplicate from.  DirectSoundCapture
 *      objects, however, are responsible for duplicating themselves based
 *      on the driver GUID.  DirectSoundCapture objects are special because they
 *      can be initialized by either DirectSoundCaptureCreate or CoInitialize.
 *      If this function fails, the object should be immediately deleted.
 *
 *  Arguments:
 *      REFGUID [in]: driver GUID, or NULL to use the preferred device.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::Initialize"

HRESULT CDirectSoundCapture::Initialize
(
    LPCGUID pGuid,
    CDirectSoundFullDuplex* pFullDuplex
)
{
    GUID                    guidDevice;
    VADDEVICETYPE           vdt = VAD_DEVICETYPE_CAPTUREMASK;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(IsInit() == DSERR_UNINITIALIZED);

    // Make a local copy of the driver GUID
    guidDevice = *BuildValidGuid(pGuid, NULL);

    // Take note of our owning full-duplex object, if any
    m_pFullDuplex = pFullDuplex;

    // If the given GUID is one of the special default device IDs,
    // map it to the corresponding "real" DirectSound device ID.
    // Note: if guidDevice is GUID_NULL, GetDeviceIdFromDefaultId()
    // will fail, which is OK because GUID_NULL is handled below.
    g_pVadMgr->GetDeviceIdFromDefaultId(&guidDevice, &guidDevice);

    // Open the audio device
    hr = g_pVadMgr->OpenDevice(vdt, guidDevice, (CDevice **)&m_pDevice);

    // Open the device's registry key
    if(SUCCEEDED(hr))
    {
#ifdef WINNT
        g_pVadMgr->OpenPersistentDataKey(m_pDevice->m_vdtDeviceType, m_pDevice->m_pDeviceDescription->m_strInterface, &m_hkeyParent);
#else
        g_pVadMgr->OpenPersistentDataKey(m_pDevice->m_vdtDeviceType, m_pDevice->m_pDeviceDescription->m_dwDevnode, &m_hkeyParent);
#endif
    }

    // Initialize the Administrator
    if(SUCCEEDED(hr))
    {
        hr = g_pDsAdmin->Initialize();
    }

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetDsVersion
 *
 *  Description:
 *      Makes us aware of our "functional level", so we can have different
 *      behavior depending on whether we're in a DX7 app, a DX8 app, etc.
 *
 *  Arguments:
 *      DSVERSION [in]: Owning application's functional level.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::SetDsVersion"

void CDirectSoundCapture::SetDsVersion(DSVERSION nVersion)
{
    DPF_ENTER();

    CUnknown::SetDsVersion(nVersion);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  HasMicrosoftAEC
 *
 *  Description:
 *      Determines whether this capture object belongs to a full-duplex
 *      object which has the Microsoft AEC effect enabled.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE if the capture object has Microsoft AEC.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCapture::HasMicrosoftAEC"

BOOL CDirectSoundCapture::HasMicrosoftAEC(void)
{
    BOOL fReturn = FALSE;
    DPF_ENTER();

    // Note: currently all our defined full-duplex effects (AEC, NS and AGC)
    // are dependent on AEC; they won't run if AEC isn't enabled, so we only
    // have to check for AEC here.

    if (m_pFullDuplex && m_pFullDuplex->HasAEC())
    {
        fReturn = IsEqualGUID(m_pFullDuplex->AecInstanceGuid(), GUID_DSCFX_MS_AEC);
    }

    DPF_LEAVE(fReturn);
    return fReturn;
}


/***************************************************************************
 *
 *  CDirectSoundCaptureBuffer
 *
 *  Description:
 *      DirectSoundCapture Buffer object constructor.
 *
 *  Arguments:
 *      CDirectSoundCapture * [in]: pointer to the parent object.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::CDirectSoundCaptureBuffer"

CDirectSoundCaptureBuffer::CDirectSoundCaptureBuffer(CDirectSoundCapture *pDSC)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundBuffer);

    // Initialize defaults
    m_pImpDirectSoundCaptureBuffer = NULL;
    m_pImpDirectSoundNotify = NULL;
    m_pDSC = pDSC;
    m_pDeviceBuffer = NULL;
    m_pwfxFormat = NULL;
    m_hWndFocus = NULL;
    m_fxChain = NULL;
    m_hrInit = DSERR_UNINITIALIZED;

    // Register with the parent
    m_pDSC->AddBufferToList(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundCaptureBuffer
 *
 *  Description:
 *      DirectSoundCapture Buffer object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::~CDirectSoundCaptureBuffer"

CDirectSoundCaptureBuffer::~CDirectSoundCaptureBuffer()
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundCaptureBuffer);

    // Free up our FX chain, if present
    DELETE(m_fxChain);

    // Unregister with the parent
    m_pDSC->RemoveBufferFromList(this);

    g_pDsAdmin->UpdateCaptureState();
    DPF(DPFLVL_MOREINFO, "Updated focus on destructor.");

    // Free all interfaces
    DELETE(m_pImpDirectSoundNotify);
    DELETE(m_pImpDirectSoundCaptureBuffer);

    // Free the device buffer
    RELEASE(m_pDeviceBuffer);

    // Free memory
    MEMFREE(m_pDSCFXDesc);
    MEMFREE(m_pwfxFormat);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes a buffer object.  If this function fails, the object
 *      should be immediately deleted.
 *
 *  Arguments:
 *      LPDIRECTSOUNDCAPTURE [in]: parent DirectSound object.
 *      LPDSCBUFFERDESC [in]: buffer description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::Initialize"

HRESULT CDirectSoundCaptureBuffer::Initialize(LPCDSCBUFFERDESC pDscbDesc)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwFlags = pDscbDesc->dwFlags;
    DSCBCAPS                dscbc;

    DPF_ENTER();

    ASSERT(IsInit() == DSERR_UNINITIALIZED);

    if (dwFlags & DSCBCAPS_STRICTFOCUS)
        dwFlags |= DSCBCAPS_FOCUSAWARE;  // Implied by DSCBCAPS_STRICTFOCUS

    if (dwFlags & DSCBCAPS_CTRLVOLUME)
        hr = m_pDSC->m_pDevice->HasVolCtrl();

    // Initialize default format
    if(SUCCEEDED(hr))
    {
        m_pwfxFormat = CopyWfxAlloc(pDscbDesc->lpwfxFormat);
        hr = HRFROMP(m_pwfxFormat);
    }

    // Make a copy of the FX descriptor
    if(SUCCEEDED(hr))
    {
        m_dwFXCount = pDscbDesc->dwFXCount;
        if(m_dwFXCount > 0)
        {
            m_pDSCFXDesc = CopyDSCFXDescAlloc(m_dwFXCount, pDscbDesc->lpDSCFXDesc);
            hr = HRFROMP(m_pDSCFXDesc);
        }
    }

    if(SUCCEEDED(hr))
    {
        // Release the old FX chain, if necessary
        DELETE(m_fxChain);

        if (pDscbDesc->dwFXCount != 0)
        {
            // Create the FX chain requested
            m_fxChain = NEW(CCaptureEffectChain(this));
            hr = HRFROMP(m_fxChain);

            if (SUCCEEDED(hr))
                hr = m_fxChain->Initialize(pDscbDesc->dwFXCount, pDscbDesc->lpDSCFXDesc);

            if (FAILED(hr))
                DELETE(m_fxChain);
        }
    }

    // Create the device buffer
    if(SUCCEEDED(hr))
    {
        hr = m_pDSC->m_pDevice->CreateBuffer(dwFlags,
                                             pDscbDesc->dwBufferBytes,
                                             m_pwfxFormat,
                                             m_fxChain,
                                             NULL,
                                             &m_pDeviceBuffer);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(m_pDeviceBuffer);
    }

    // Save the buffer size and flags for quick reference
    if(SUCCEEDED(hr))
    {
        InitStruct(&dscbc, sizeof(dscbc));

        hr = m_pDeviceBuffer->GetCaps(&dscbc);
    }

    if(SUCCEEDED(hr))
    {
        m_dwBufferBytes = dscbc.dwBufferBytes;
        m_dwBufferFlags = dscbc.dwFlags;
    }

    // Register the capture interfaces with the interface manager
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(this, IID_IDirectSoundCaptureBuffer, this, &m_pImpDirectSoundCaptureBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = RegisterInterface(IID_IDirectSoundCaptureBuffer7_1, m_pImpDirectSoundCaptureBuffer, (IDirectSoundCaptureBuffer7_1*)m_pImpDirectSoundCaptureBuffer);
    }

    if(SUCCEEDED(hr) && GetDsVersion() >= DSVERSION_DX8)
    {
        hr = RegisterInterface(IID_IDirectSoundCaptureBuffer8, m_pImpDirectSoundCaptureBuffer, (IDirectSoundCaptureBuffer8*)m_pImpDirectSoundCaptureBuffer);
    }

    // Register the notification interfaces with the interface manager
    if(SUCCEEDED(hr))
    {
        hr = CreateAndRegisterInterface(this, IID_IDirectSoundNotify, this, &m_pImpDirectSoundNotify);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Queries capabilities for the buffer.
 *
 *  Arguments:
 *      LPDSCBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetCaps"

HRESULT CDirectSoundCaptureBuffer::GetCaps(LPDSCBCAPS pDscbCaps)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDeviceBuffer->GetCaps(pDscbCaps);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Retrieves the format for the given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives the format.
 *      LPDWORD [in/out]: size of the format structure.  On entry, this
 *                        must be initialized to the size of the structure.
 *                        On exit, this will be filled with the size that
 *                        was required.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetFormat"

HRESULT CDirectSoundCaptureBuffer::GetFormat(LPWAVEFORMATEX pwfxFormat, LPDWORD pdwSize)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CopyWfxApi(m_pwfxFormat, pwfxFormat, pdwSize);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::SetNotificationPositions"

HRESULT CDirectSoundCaptureBuffer::SetNotificationPositions(DWORD cpn, LPCDSBPOSITIONNOTIFY pdsbpn)
{
    HRESULT                 hr = DS_OK;
    LPDSBPOSITIONNOTIFY     paNotesOrdered = NULL;
    DWORD                   dwState;

    DPF_ENTER();

    // Validate notifications
    if (SUCCEEDED(hr))
    {
        hr = ValidateNotificationPositions(m_dwBufferBytes,
                                           cpn,
                                           pdsbpn,
                                           m_pwfxFormat->nBlockAlign,
                                           &paNotesOrdered);
    }

    // We must be stopped in order to set notification positions
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->GetState(&dwState);

        if(SUCCEEDED(hr) && dwState & VAD_BUFFERSTATE_STARTED)
        {
            RPF(DPFLVL_ERROR, "Buffer must be stopped before setting notification positions");
            hr = DSERR_INVALIDCALL;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->SetNotificationPositions(cpn, paNotesOrdered);
    }

    MEMFREE(paNotesOrdered);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives capture cursor position.
 *      LPDWORD [out]: receives read cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetCurrentPosition"

HRESULT CDirectSoundCaptureBuffer::GetCurrentPosition(LPDWORD pdwCapture, LPDWORD pdwRead)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwCapture;
    DWORD                   dwRead;

    DPF_ENTER();

    if(SUCCEEDED(hr))
    {
        // We save the position to local variables so that the object we're
        // calling into doesn't have to worry about whether one or both of
        // the arguments are NULL.
        hr = m_pDeviceBuffer->GetCursorPosition(&dwCapture, &dwRead);
    }

    if(SUCCEEDED(hr))
    {
        if(pdwCapture)
        {
            *pdwCapture = BLOCKALIGN(dwCapture, m_pwfxFormat->nBlockAlign);
        }

        if(pdwRead)
        {
            *pdwRead = BLOCKALIGN(dwRead, m_pwfxFormat->nBlockAlign);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Retrieves status for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the status.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetStatus"

HRESULT CDirectSoundCaptureBuffer::GetStatus(LPDWORD pdwStatus)
{
    DWORD                   dwState;
    DPF_ENTER();

    HRESULT hr = m_pDeviceBuffer->GetState(&dwState);

    // Convert to DSCBSTATUS
    if(SUCCEEDED(hr))
    {
        if(dwState & VAD_BUFFERSTATE_STARTED)
        {
            *pdwStatus = DSCBSTATUS_CAPTURING;
        }
        else
        {
            *pdwStatus = 0;
        }

        if(dwState & VAD_BUFFERSTATE_LOOPING)
        {
            *pdwStatus |= DSCBSTATUS_LOOPING;
        }

        if(dwState & (VAD_BUFFERSTATE_OUTOFFOCUS | VAD_BUFFERSTATE_LOSTCONSOLE))
        {
            // These flags should never be set for non-FOCUSAWARE buffers
            ASSERT(m_dwBufferFlags & DSCBCAPS_FOCUSAWARE);
            *pdwStatus |= DSCBSTATUS_LOSTFOCUS;
        }

        if(dwState & VAD_BUFFERSTATE_INFOCUS)
        {
            // This flag should never be set for non-FOCUSAWARE buffers
            ASSERT(m_dwBufferFlags & DSCBCAPS_FOCUSAWARE);
            *pdwStatus |= DSCBSTATUS_INFOCUS;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Start
 *
 *  Description:
 *      Starts the buffer capturing.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::Start"

HRESULT CDirectSoundCaptureBuffer::Start(DWORD dwFlags)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    if ((m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE) && m_hWndFocus == NULL)
    {
        hr = DSERR_INVALIDCALL;
    }

    if (SUCCEEDED(hr))
    {
        // Start the buffer capturing
        DWORD dwState = VAD_BUFFERSTATE_STARTED;
        if (dwFlags & DSCBSTART_LOOPING)
            dwState |= VAD_BUFFERSTATE_LOOPING;

        hr = m_pDeviceBuffer->SetState(dwState);

#ifdef SHARED_THREAD_LIST
        if (hr == DSERR_INVALIDCALL && (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE))
        {
            // We probably failed because the device is allocated; return success
            hr = DS_OK;
        }
        g_pDsAdmin->WriteCaptureFocusList();
#endif
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops capturing to the given buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::Stop"

HRESULT CDirectSoundCaptureBuffer::Stop(void)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    // Set the buffer state
    hr = m_pDeviceBuffer->SetState(VAD_BUFFERSTATE_STOPPED);

#ifdef SHARED_THREAD_LIST
    g_pDsAdmin->WriteCaptureFocusList();
#endif

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks the buffer memory to allow for reading.
 *
 *  Arguments:
 *      DWORD [in]: offset, in bytes, from the start of the buffer to where
 *                  the lock begins.
 *      DWORD [in]: size, in bytes, of the portion of the buffer to lock.
 *                  Note that the sound buffer is conceptually circular.
 *      LPVOID * [out]: address for a pointer to contain the first block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr1 parameter. If this
 *                     value is less than the dwWriteBytes parameter,
 *                     lplpvAudioPtr2 will point to a second block of sound
 *                     data.
 *      LPVOID * [out]: address for a pointer to contain the second block of
 *                      the sound buffer to be locked. If the value of this
 *                      parameter is NULL, the lplpvAudioPtr1 parameter
 *                      points to the entire locked portion of the sound
 *                      buffer.
 *      LPDWORD [out]: address of a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr2 parameter. If
 *                     lplpvAudioPtr2 is NULL, this value will be 0.
 *      DWORD [in]: flags for lock operation. Can be DSCBLOCK_ENTIREBUFFER.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::Lock"

HRESULT CDirectSoundCaptureBuffer::Lock(DWORD dwReadCursor,
                                        DWORD dwReadBytes,
                                        LPVOID *ppvAudioPtr1,
                                        LPDWORD pdwAudioBytes1,
                                        LPVOID *ppvAudioPtr2,
                                        LPDWORD pdwAudioBytes2,
                                        DWORD dwFlags)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Read Cursor out of range?
    if (dwReadCursor >= m_dwBufferBytes)
    {
        hr = DSERR_INVALIDPARAM;
    }

    // Check for invalid lock flags
    if (SUCCEEDED(hr) && (dwFlags & ~DSCBLOCK_VALIDFLAGS))
    {
        hr = DSERR_INVALIDPARAM;
    }

    // Lock entire buffer?
    if (SUCCEEDED(hr))
    {
        if (dwFlags & DSCBLOCK_ENTIREBUFFER)
        {
            dwReadBytes = m_dwBufferBytes;
        }
        // Read more than buffer size?
        else if (dwReadBytes > m_dwBufferBytes || dwReadBytes == 0)
        {
            hr = DSERR_INVALIDPARAM;
        }
    }

    // Lock the device buffer
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->Lock(dwReadCursor, dwReadBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks the given buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::Unlock"

HRESULT CDirectSoundCaptureBuffer::Unlock(LPVOID pvAudioPtr1,
                                          DWORD dwAudioBytes1,
                                          LPVOID pvAudioPtr2,
                                          DWORD dwAudioBytes2)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Unlock the device buffer.
    if(SUCCEEDED(hr))
    {
        hr = m_pDeviceBuffer->Unlock(pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the master recording level for this capture buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume level, in 100ths of a dB.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::SetVolume"

HRESULT CDirectSoundCaptureBuffer::SetVolume(LONG lVolume)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Check access rights
    if (!(m_dwBufferFlags & DSCBCAPS_CTRLVOLUME))
    {
        DPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Check whether the buffer has capture focus
    if (SUCCEEDED(hr) && (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE))
    {
        DWORD dwState;
        m_pDeviceBuffer->GetState(&dwState);
        if (!(dwState & VAD_BUFFERSTATE_INFOCUS))
        {
            DPF(DPFLVL_ERROR, "Buffer doesn't have capture focus");
            hr = DSERR_INVALIDCALL;
        }
    }

    // Set device volume
    if (SUCCEEDED(hr))
    {
        hr = m_pDSC->m_pDevice->SetVolume(lVolume);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetVolume
 *
 *  Description:
 *      Gets the master recording level for this capture buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetVolume"

HRESULT CDirectSoundCaptureBuffer::GetVolume(LPLONG plVolume)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Check access rights
    if (!(m_dwBufferFlags & DSCBCAPS_CTRLVOLUME))
    {
        DPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Get device volume
    if (SUCCEEDED(hr))
    {
        hr = m_pDSC->m_pDevice->GetVolume(plVolume);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetMicVolume
 *
 *  Description:
 *      Sets the microphone recording level for this capture buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume level, in 100ths of a dB.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::SetMicVolume"

HRESULT CDirectSoundCaptureBuffer::SetMicVolume(LONG lVolume)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Check access rights
    if (!(m_dwBufferFlags & DSCBCAPS_CTRLVOLUME))
    {
        DPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Check whether the buffer has capture focus
    if (SUCCEEDED(hr) && (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE))
    {
        DWORD dwState;
        m_pDeviceBuffer->GetState(&dwState);
        if (!(dwState & VAD_BUFFERSTATE_INFOCUS))
        {
            DPF(DPFLVL_ERROR, "Buffer doesn't have capture focus");
            hr = DSERR_INVALIDCALL;
        }
    }

    // Set device volume
    if (SUCCEEDED(hr))
    {
        hr = m_pDSC->m_pDevice->SetMicVolume(lVolume);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetMicVolume
 *
 *  Description:
 *      Gets the microphone recording level for this capture buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetMicVolume"

HRESULT CDirectSoundCaptureBuffer::GetMicVolume(LPLONG plVolume)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Check access rights
    if (!(m_dwBufferFlags & DSCBCAPS_CTRLVOLUME))
    {
        DPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Get device volume
    if (SUCCEEDED(hr))
    {
        hr = m_pDSC->m_pDevice->GetMicVolume(plVolume);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  EnableMic
 *
 *  Description:
 *      Enables/disables the microphone line on this capture buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to enable the microphone, FALSE to disable it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::EnableMic"

HRESULT CDirectSoundCaptureBuffer::EnableMic(BOOL fEnable)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Check access rights
    if (!(m_dwBufferFlags & DSCBCAPS_CTRLVOLUME))
    {
        DPF(DPFLVL_ERROR, "Buffer does not have CTRLVOLUME");
        hr = DSERR_CONTROLUNAVAIL;
    }

    // Check whether the buffer has capture focus
    if (SUCCEEDED(hr) && (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE))
    {
        DWORD dwState;
        m_pDeviceBuffer->GetState(&dwState);
        if (!(dwState & VAD_BUFFERSTATE_INFOCUS))
        {
            DPF(DPFLVL_ERROR, "Buffer doesn't have capture focus");
            hr = DSERR_INVALIDCALL;
        }
    }

    // Set device volume
    if (SUCCEEDED(hr))
    {
        hr = m_pDSC->m_pDevice->EnableMic(fEnable);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  YieldFocus
 *
 *  Description:
 *      Yields the capture focus to another capture buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::YieldFocus"

HRESULT CDirectSoundCaptureBuffer::YieldFocus(void)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // This is only valid if we're focus-aware and have a focus window
    if (!(m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE) || !m_hWndFocus)
    {
        hr = DSERR_INVALIDCALL;
    }
    else
    {
        // Oh, it's valid...
        m_pDeviceBuffer->m_fYieldedFocus = TRUE;
        g_pDsAdmin->UpdateCaptureState();
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  ClaimFocus
 *
 *  Description:
 *      Regains the capture focus.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::ClaimFocus"

HRESULT CDirectSoundCaptureBuffer::ClaimFocus(void)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // This is only valid if we're focus-aware and have a focus window
    if (!(m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE) || !m_hWndFocus)
    {
        hr = DSERR_INVALIDCALL;
    }
    else
    {
        // Oh, it's valid...
        m_pDeviceBuffer->m_fYieldedFocus = FALSE;
        g_pDsAdmin->UpdateCaptureState();
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetFocusHWND
 *
 *  Description:
 *      Sets the current HWND associated with this capture buffer.
 *
 *  Arguments:
 *      HWND [in]: HWND to be associated with this buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::SetFocusHWND"

HRESULT CDirectSoundCaptureBuffer::SetFocusHWND(HWND hwndMainWindow)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE)
    {
        m_hWndFocus = hwndMainWindow;
        g_pDsAdmin->UpdateCaptureState();
    }
    else
    {
        hr = DSERR_INVALIDCALL;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetFocusHWND
 *
 *  Description:
 *      Gets the current HWND associated with this capture buffer.
 *
 *  Arguments:
 *      HWND * [out]: receives HWND associated with this buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetFocusHWND"

HRESULT CDirectSoundCaptureBuffer::GetFocusHWND(HWND *pHwndMainWindow)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE)
    {
        *pHwndMainWindow = m_hWndFocus;
    }
    else
    {
        hr = DSERR_INVALIDCALL;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  EnableFocusNotifications
 *
 *  Description:
 *      Requests focus change notifications to be sent.
 *
 *  Arguments:
 *      HANDLE [in]: event to signal when a capture focus change occurs.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::EnableFocusNotifications"

HRESULT CDirectSoundCaptureBuffer::EnableFocusNotifications(HANDLE hFocusEvent)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE)
    {
        m_pDeviceBuffer->m_hEventFocus = hFocusEvent;
    }
    else
    {
        hr = DSERR_INVALIDCALL;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  ChangeFocus
 *
 *  Description:
 *      Notifies the buffer of the new HWND with focus.
 *
 *  Arguments:
 *      HWND [in]: Window handle that has focus.
 *
 *  Returns:
 *      None.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::ChangeFocus"

HRESULT CDirectSoundCaptureBuffer::ChangeFocus(HWND hWndFocus)
{
    HRESULT hr = DS_OK;

    DPF_ENTER();

    if (m_pDeviceBuffer->m_dwFlags & DSCBCAPS_FOCUSAWARE)
    {
        DWORD dwState;

        #ifdef WINNT
        // On NT platforms we only grant an application capture focus if it is running
        // in the Terminal Services session that currently owns the console, to prevent
        // a Fast User Switching scenario in which an app in an inactive session could
        // "spy" on the audio being recorded at the console (Whistler bug 350622).
        if (USER_SHARED_DATA->ActiveConsoleId != NtCurrentPeb()->SessionId)
        {
            dwState = VAD_BUFFERSTATE_LOSTCONSOLE;
        }
        else
        #endif
        if (hWndFocus == m_hWndFocus)
        {
            dwState = VAD_BUFFERSTATE_INFOCUS;
        }
        else
        {
            dwState = VAD_BUFFERSTATE_OUTOFFOCUS;
        }

        hr = m_pDeviceBuffer->SetState(dwState);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetObjectInPath
 *
 *  Description:
 *      Obtains a given interface on a given effect on this buffer.
 *
 *  Arguments:
 *      REFGUID [in]: Class ID of the effect that is being searched for,
 *                    or GUID_ALL_OBJECTS to search for any effect.
 *      DWORD [in]: Index of the effect, in case there is more than one
 *                  effect with this CLSID on this buffer.
 *      REFGUID [in]: IID of the interface requested.  The selected effect
 *                    will be queried for this interface. 
 *      LPVOID * [out]: Receives the interface requested.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetObjectInPath"

HRESULT CDirectSoundCaptureBuffer::GetObjectInPath
(
    REFGUID guidObject,
    DWORD dwIndex,
    REFGUID iidInterface,
    LPVOID *ppObject
)
{
    HRESULT hr;
    DPF_ENTER();

    if(!(m_dwBufferFlags & DSCBCAPS_CTRLFX))
    {
        RPF(DPFLVL_ERROR, "Buffer was not created with DSCBCAPS_CTRLFX flag");
        hr = DSERR_CONTROLUNAVAIL;
    }
    else if (!HasFX())
    {
        hr = DSERR_OBJECTNOTFOUND;
    }
    else
    {
        hr = m_fxChain->GetEffectInterface(guidObject, dwIndex, iidInterface, ppObject);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetFXStatus
 *
 *  Description:
 *      Obtains the current statuses of the effects on this buffer.
 *
 *  Arguments:
 *      DWORD [in]: length of array pointed to by second argument.
 *      LPDWORD [out]: pointer to array which receives the statuses.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundCaptureBuffer::GetFXStatus"

HRESULT CDirectSoundCaptureBuffer::GetFXStatus
(
    DWORD   dwFXCount,
    LPDWORD pdwResultCodes
)
{
    HRESULT                 hr = DSERR_INVALIDPARAM;
    DPF_ENTER();

    ASSERT(!pdwResultCodes || IS_VALID_WRITE_PTR(pdwResultCodes, dwFXCount * sizeof *pdwResultCodes));

    if (pdwResultCodes && m_fxChain)
    {
        hr = m_fxChain->GetFxStatus(pdwResultCodes);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsbuf.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsbuf.h
 *  Content:    DirectSound Buffer object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *
 ***************************************************************************/

#ifndef __DSBUF_H__
#define __DSBUF_H__

// Type used by class CDirectSoundSecondaryBuffer below
enum DSPLAYSTATE {Starting, Playing, Stopping, Stopped}; 
// "Stopping" isn't used yet, but may come in handy to implement effect tails later

// Special argument used by CDirectSoundSecondaryBuffer::SetCurrentSlice()
#define CURRENT_WRITE_POS MAX_DWORD


#ifdef __cplusplus

// Fwd decl
class CDirectSound;
class CDirectSound3dListener;
class CDirectSound3dBuffer;
class CDirectSoundPropertySet;
class CDirectSoundSink;

// We actually need CDirectSound to be declared here,
// since we use it in IsEmulated() below:
#include "dsobj.h"

// The DirectSound Buffer object base class
class CDirectSoundBuffer
    : public CUnknown
{
    friend class CDirectSound;
    friend class CDirectSoundAdministrator;
    friend class CDirectSoundPrivate;
    friend class CDirectSoundSink;

protected:
    CDirectSound *              m_pDirectSound;     // Parent object
    DSBUFFERDESC                m_dsbd;             // Buffer description
    DWORD                       m_dwStatus;         // Buffer status

public:
    CDirectSoundBuffer(CDirectSound *);
    virtual ~CDirectSoundBuffer();

public:
    // Initialization
    virtual HRESULT IsInit() = 0;

    // Caps
    virtual HRESULT GetCaps(LPDSBCAPS) = 0;

    // Buffer properties
    virtual HRESULT GetFormat(LPWAVEFORMATEX, LPDWORD) = 0;
    virtual HRESULT SetFormat(LPCWAVEFORMATEX) = 0;
    virtual HRESULT GetFrequency(LPDWORD) = 0;
    virtual HRESULT SetFrequency(DWORD) = 0;
    virtual HRESULT GetPan(LPLONG) = 0;
    virtual HRESULT SetPan(LONG) = 0;
    virtual HRESULT GetVolume(LPLONG) = 0;
    virtual HRESULT SetVolume(LONG) = 0;
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY) = 0;

    // Buffer function
    virtual HRESULT GetCurrentPosition(LPDWORD, LPDWORD) = 0;
    virtual HRESULT SetCurrentPosition(DWORD) = 0;
    virtual HRESULT GetStatus(LPDWORD) = 0;
    virtual HRESULT Play(DWORD, DWORD) = 0;
    virtual HRESULT Stop() = 0;
    virtual HRESULT Activate(BOOL) = 0;

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD) = 0;
    virtual HRESULT Unlock(LPVOID, DWORD, LPVOID, DWORD) = 0;
    virtual HRESULT Lose() = 0;
    virtual HRESULT Restore() = 0;

    // New methods for the DirectSound 8.0 release
    // (These have to be present in the base class but are valid only for secondary buffers)
    virtual HRESULT SetFX(DWORD, LPDSEFFECTDESC, LPDWORD) {BREAK(); return DSERR_GENERIC;}
    virtual HRESULT UserAcquireResources(DWORD, DWORD, LPDWORD) {BREAK(); return DSERR_GENERIC;}
    virtual HRESULT GetObjectInPath(REFGUID, DWORD, REFGUID, LPVOID *) {BREAK(); return DSERR_GENERIC;}
#ifdef FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT SetChannelVolume(DWORD, LPDWORD, LPLONG) {BREAK(); return DSERR_GENERIC;}
#endif

    // Inline query for buffer type (regular, MIXIN or SINKIN)
    DWORD GetBufferType() {return m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN);}

    // Public accessors to try to cut down on the excessive friendship goin' on
    const CDirectSound* GetDirectSound() {return m_pDirectSound;}

    // For modifying the final success code returned to the app if necessary
    virtual HRESULT SpecialSuccessCode() {return DS_OK;}

protected:
    virtual void UpdateBufferStatusFlags(DWORD, LPDWORD);
};

// DirectSound primary buffer
class CDirectSoundPrimaryBuffer
    : public CDirectSoundBuffer
{
    friend class CDirectSound;
    friend class CDirectSoundSecondaryBuffer;

private:
    CPrimaryRenderWaveBuffer *  m_pDeviceBuffer;    // The device buffer
    CDirectSound3dListener *    m_p3dListener;      // The 3D listener
    CDirectSoundPropertySet *   m_pPropertySet;     // The property set object
    DWORD                       m_dwRestoreState;   // Primary buffer state before going out of focus
    BOOL                        m_fWritePrimary;    // Is the buffer WRITEPRIMARY?
    ULONG                       m_ulUserRefCount;   // Reference count exposed to the user
    HRESULT                     m_hrInit;           // Has the object been initialized?
    BOOL                        m_bDataLocked;      // Signals that a WRITEPRIMARY app has written data since creating the buffer

private:
    // Interfaces
    CImpDirectSoundBuffer<CDirectSoundPrimaryBuffer> *m_pImpDirectSoundBuffer;

public:
    CDirectSoundPrimaryBuffer(CDirectSound *);
    virtual ~CDirectSoundPrimaryBuffer();

public:
    // CDsBasicRuntime overrides
    virtual ULONG AddRef();
    virtual ULONG Release();

    // Creation
    virtual HRESULT Initialize(LPCDSBUFFERDESC);
    virtual HRESULT IsInit();
    virtual HRESULT OnCreateSoundBuffer(DWORD);

    // Buffer Caps
    virtual HRESULT GetCaps(LPDSBCAPS);
    virtual HRESULT SetBufferFlags(DWORD);

    // Buffer properties
    virtual HRESULT GetFormat(LPWAVEFORMATEX, LPDWORD);
    virtual HRESULT SetFormat(LPCWAVEFORMATEX);
    virtual HRESULT GetFrequency(LPDWORD);
    virtual HRESULT SetFrequency(DWORD);
    virtual HRESULT GetPan(LPLONG);
    virtual HRESULT SetPan(LONG);
    virtual HRESULT GetVolume(LPLONG);
    virtual HRESULT SetVolume(LONG);
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

    // Buffer function
    virtual HRESULT GetCurrentPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetCurrentPosition(DWORD);
    virtual HRESULT GetStatus(LPDWORD);
    virtual HRESULT Play(DWORD, DWORD);
    virtual HRESULT Stop();
    virtual HRESULT Activate(BOOL);
    virtual HRESULT SetPriority(DWORD);

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD);
    virtual HRESULT Unlock(LPVOID, DWORD, LPVOID, DWORD);
    virtual HRESULT Lose();
    virtual HRESULT Restore();

private:
    virtual HRESULT SetBufferState(DWORD);
};

inline ULONG CDirectSoundPrimaryBuffer::AddRef()
{
    return ::AddRef(&m_ulUserRefCount);
}

inline ULONG CDirectSoundPrimaryBuffer::Release()
{
    return ::Release(&m_ulUserRefCount);
}

inline HRESULT CDirectSoundPrimaryBuffer::IsInit()
{
    return m_hrInit;
}

// DirectSound secondary buffer
class CDirectSoundSecondaryBuffer
    : public CDirectSoundBuffer
{
    friend class CEffectChain;      // CEffectChain currently needs access to our m_pOwningSink, m_pDeviceBuffer
                                    // and m_pImpDirectSoundBuffer; maybe this can be cleaned up later.
    friend class CDirectSoundSink;  // Likewise, needs access to m_pDeviceBuffer.
#ifdef ENABLE_PERFLOG
    friend class BufferPerfState;
    friend void OnPerflogStateChanged(void);
#endif

private:
    CDirectSoundSink *              m_pOwningSink;          // Parent sink object (maybe)
    CSecondaryRenderWaveBuffer *    m_pDeviceBuffer;        // The device buffer
    CDirectSound3dBuffer *          m_p3dBuffer;            // The 3D buffer
    CDirectSoundPropertySet *       m_pPropertySet;         // The property set object
    CEffectChain *                  m_fxChain;              // The effects chain object
    LONG                            m_lPan;                 // Pan
    LONG                            m_lVolume;              // Volume
#ifdef FUTURE_MULTIPAN_SUPPORT
    LPLONG                          m_plChannelVolumes;     // Volumes from last SetChannelVolume() call
    DWORD                           m_dwChannelCount;       // No. of channels from last SetChannelVolume()
    LPDWORD                         m_pdwChannels;          // Channels used in last SetChannelVolume()
#endif
    DWORD                           m_dwFrequency;          // Frequency
    DWORD                           m_dwOriginalFlags;      // Original buffer flags
    HRESULT                         m_hrInit;               // Has the object been initialized?
    HRESULT                         m_hrPlay;               // Last return code from ::Play
    DWORD                           m_dwPriority;           // Buffer priority
    DWORD                           m_dwVmPriority;         // Voice Manager priority
    BOOL                            m_fMute;                // Is the buffer muted?
    BOOL                            m_fCanStealResources;   // Are we allowed to steal buffer's resources?
    
    DWORD                           m_dwAHCachedPlayPos;    // for CACHEPOSITIONS apphack
    DWORD                           m_dwAHCachedWritePos;   // 
    DWORD                           m_dwAHLastGetPosTime;   // 

    // New in DX8: used by the streaming thread to handle sink/FX/MIXIN buffers
    DSPLAYSTATE                     m_playState;            // Current playing state of the buffer
    CStreamingThread*               m_pStreamingThread;     // Pointer to our owning streaming thread
    DWORD                           m_dwSliceBegin;         // The "slice" is the part of the buffer that is currently
    DWORD                           m_dwSliceEnd;           // being effects-processed and/or written to by the sink
    GUID                            m_guidBufferID;         // Unique identifier for this buffer
    CList<CDirectSoundSecondaryBuffer*> m_lstSenders;       // Buffers sending to us, if we're a MIXIN buffer
                                                            // Note: all this really belongs in a derived class
#ifdef ENABLE_PERFLOG
    BufferPerfState*                m_pPerfState;           // Performance logging helper
#endif

private:
    // Interfaces
    CImpDirectSoundBuffer<CDirectSoundSecondaryBuffer>   *m_pImpDirectSoundBuffer;
    CImpDirectSoundNotify<CDirectSoundSecondaryBuffer>   *m_pImpDirectSoundNotify;

public:
    CDirectSoundSecondaryBuffer(CDirectSound *);
    virtual ~CDirectSoundSecondaryBuffer();

public:
    // Creation
    virtual HRESULT Initialize(LPCDSBUFFERDESC, CDirectSoundSecondaryBuffer *);
    virtual HRESULT IsInit() {return m_hrInit;}

    // Caps
    virtual HRESULT GetCaps(LPDSBCAPS);

    // Buffer properties
    virtual HRESULT GetFormat(LPWAVEFORMATEX, LPDWORD);
    virtual HRESULT SetFormat(LPCWAVEFORMATEX);
    virtual HRESULT GetFrequency(LPDWORD);
    virtual HRESULT SetFrequency(DWORD);
    virtual HRESULT GetPan(LPLONG);
    virtual HRESULT SetPan(LONG);
    virtual HRESULT GetVolume(LPLONG);
    virtual HRESULT SetVolume(LONG);
    virtual HRESULT GetAttenuation(FLOAT*);
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

    // Buffer function
    virtual HRESULT GetCurrentPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetCurrentPosition(DWORD);
    virtual HRESULT GetStatus(LPDWORD);
    virtual HRESULT Play(DWORD, DWORD);
    virtual HRESULT Stop();
    virtual HRESULT Activate(BOOL);

    // Buffer data
    virtual HRESULT Lock(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD, DWORD);
    virtual HRESULT Unlock(LPVOID, DWORD, LPVOID, DWORD);
    virtual HRESULT Lose();
    virtual HRESULT Restore();

    // Legacy voice management
    virtual HRESULT GetVoiceManagerMode(VmMode *);
    virtual HRESULT SetVoiceManagerMode(VmMode);
    virtual HRESULT GetVoiceManagerPriority(LPDWORD);
    virtual HRESULT SetVoiceManagerPriority(DWORD);
    #ifdef DEAD_CODE
    virtual HRESULT GetVoiceManagerState(VmState *);
    #endif // DEAD_CODE

    // Inline abbreviations for filling the buffer with silence
    void ClearWriteBuffer() {::FillSilence(GetWriteBuffer(), m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat->wBitsPerSample);}
    void ClearPlayBuffer()  {::FillSilence(GetPlayBuffer(),  m_dsbd.dwBufferBytes, m_dsbd.lpwfxFormat->wBitsPerSample);}

    // For modifying the final success code returned to the app if necessary
    virtual HRESULT SpecialSuccessCode() {return m_pDeviceBuffer->SpecialSuccessCode();}

    // New in DX8: used by the streaming thread to handle sink/FX/MIXIN buffers
    void SetOwningSink(CDirectSoundSink *);
    void SetGUID(REFGUID guidBufferID) {m_guidBufferID = guidBufferID;}
    REFGUID GetGUID() {return m_guidBufferID;}
    virtual HRESULT SetFX(DWORD, LPDSEFFECTDESC, LPDWORD);
    virtual HRESULT SetFXBufferConfig(CDirectSoundBufferConfig*);
    virtual HRESULT UserAcquireResources(DWORD, DWORD, LPDWORD);
    virtual HRESULT GetObjectInPath(REFGUID, DWORD, REFGUID, LPVOID *);

    BOOL HasFX() {return m_fxChain != NULL;}
    BOOL HasSink() {return m_pOwningSink != NULL;}

    // For manipulations by the streaming sink/FX thread
    HRESULT GetInternalCursors(LPDWORD, LPDWORD);
    void    GetCurrentSlice(LPDWORD, LPDWORD);
    void    SetCurrentSlice(DWORD, DWORD);
    void    MoveCurrentSlice(DWORD);
    HRESULT DirectLock(DWORD, DWORD, LPVOID*, LPDWORD, LPVOID*, LPDWORD);
    HRESULT DirectUnlock(LPVOID, DWORD, LPVOID, DWORD);
    HRESULT FindSendLoop(CDirectSoundSecondaryBuffer*);
    HRESULT CalculateOffset(CDirectSoundSecondaryBuffer*, DWORD, DWORD*);
    void    SynchronizeToBuffer(CDirectSoundSecondaryBuffer*);
    void    RegisterSender(CDirectSoundSecondaryBuffer* pSender) {m_lstSenders.AddNodeToList(pSender);}
    void    UnregisterSender(CDirectSoundSecondaryBuffer* pSender) {m_lstSenders.RemoveDataFromList(pSender);}
    DSPLAYSTATE UpdatePlayState();
    void    SetInitialSlice(REFERENCE_TIME);

    // Inline helpers
    HRESULT CommitToDevice(DWORD ibCommit, DWORD cbCommit) {return m_pDeviceBuffer->CommitToDevice(ibCommit, cbCommit);}
    LPBYTE  GetPreFxBuffer()    {return m_pDeviceBuffer->m_pSysMemBuffer->GetPreFxBuffer();}
    LPBYTE  GetPostFxBuffer()   {return m_pDeviceBuffer->m_pSysMemBuffer->GetPostFxBuffer();}
    LPBYTE  GetWriteBuffer()    {return m_pDeviceBuffer->m_pSysMemBuffer->GetWriteBuffer();}
    LPBYTE  GetPlayBuffer()     {return m_pDeviceBuffer->m_pSysMemBuffer->GetPlayBuffer();}
    DWORD   GetBufferSize()     {return m_dsbd.dwBufferBytes;}
    // Was: GetBufferSize()     {return m_pDeviceBuffer->m_pSysMemBuffer->GetSize();}
    LPWAVEFORMATEX Format()     {return m_dsbd.lpwfxFormat;}
    BOOL    IsPlaying()         {return m_playState == Starting || m_playState == Playing;}
    DSPLAYSTATE GetPlayState()  {return m_playState;}
    BOOL    IsEmulated()        {return IS_EMULATED_VAD(m_pDirectSound->m_pDevice->m_vdtDeviceType);}

#ifdef FUTURE_MULTIPAN_SUPPORT
    // The DX8 multichannel volume control API
    virtual HRESULT SetChannelVolume(DWORD, LPDWORD, LPLONG);
#endif

private:
    // Initialization helpers
    virtual HRESULT InitializeEmpty(LPCDSBUFFERDESC, CDirectSoundSecondaryBuffer *);

    // Buffer properties
    virtual HRESULT SetAttenuation(LONG, LONG);
    virtual HRESULT SetMute(BOOL);

    // Buffer state
    virtual HRESULT SetBufferState(DWORD);

    // Resource management
    virtual HRESULT AttemptResourceAcquisition(DWORD);
    virtual HRESULT AcquireResources(DWORD);
    virtual HRESULT GetResourceTheftCandidates(DWORD, CList<CDirectSoundSecondaryBuffer *> *);
    virtual HRESULT StealResources(CDirectSoundSecondaryBuffer *);
    virtual HRESULT HandleResourceAcquisition(DWORD);
    virtual HRESULT FreeResources(BOOL);
    virtual DWORD GetBufferPriority();
    virtual HRESULT GetPlayTimeRemaining(LPDWORD);
};

inline DWORD CDirectSoundSecondaryBuffer::GetBufferPriority()
{
    ASSERT((!m_dwPriority && !m_dwVmPriority) || LXOR(m_dwPriority, m_dwVmPriority));
    return max(m_dwPriority, m_dwVmPriority);
}

// The DirectSound 3D Listener object.  This object cannot be instantiated
// directly.  It must be owned or inherited by a class derived from CUnknown.
class CDirectSound3dListener
    : public CDsBasicRuntime
{
    friend class CDirectSound3dBuffer;
    friend class CDirectSoundPrimaryBuffer;
    friend class CDirectSoundSecondaryBuffer;

protected:
    CDirectSoundPrimaryBuffer * m_pParent;              // The parent object
    C3dListener *               m_pDevice3dListener;    // The device 3D listener
    HRESULT                     m_hrInit;               // Has the object been initialized?

private:
    // Interfaces
    CImpDirectSound3dListener<CDirectSound3dListener> *m_pImpDirectSound3dListener;

public:
    CDirectSound3dListener(CDirectSoundPrimaryBuffer *);
    virtual ~CDirectSound3dListener();

public:
    // Creation
    virtual HRESULT Initialize(CPrimaryRenderWaveBuffer *);
    virtual HRESULT IsInit();

    // 3D properties
    virtual HRESULT GetAllParameters(LPDS3DLISTENER);
    virtual HRESULT GetDistanceFactor(D3DVALUE*);
    virtual HRESULT GetDopplerFactor(D3DVALUE*);
    virtual HRESULT GetOrientation(D3DVECTOR*, D3DVECTOR*);
    virtual HRESULT GetPosition(D3DVECTOR*);
    virtual HRESULT GetRolloffFactor(D3DVALUE*);
    virtual HRESULT GetVelocity(D3DVECTOR*);
    virtual HRESULT SetAllParameters(LPCDS3DLISTENER, DWORD);
    virtual HRESULT SetDistanceFactor(D3DVALUE, DWORD);
    virtual HRESULT SetDopplerFactor(D3DVALUE, DWORD);
    virtual HRESULT SetOrientation(REFD3DVECTOR, REFD3DVECTOR, DWORD);
    virtual HRESULT SetPosition(REFD3DVECTOR, DWORD);
    virtual HRESULT SetRolloffFactor(D3DVALUE, DWORD);
    virtual HRESULT SetVelocity(REFD3DVECTOR, DWORD);
    virtual HRESULT CommitDeferredSettings();

    // Speaker configuration
    virtual HRESULT SetSpeakerConfig(DWORD);
};

inline HRESULT CDirectSound3dListener::IsInit()
{
    return m_hrInit;
}

// The DirectSound 3D Buffer object.  This object cannot be instantiated
// directly.  It must be owned or inherited by a class derived from CUnknown.
class CDirectSound3dBuffer
    : public CDsBasicRuntime
{
    friend class CDirectSoundSecondaryBuffer;

protected:
    CDirectSoundSecondaryBuffer *   m_pParent;              // The parent object
    CWrapper3dObject *              m_pWrapper3dObject;     // The wrapper 3D object
    C3dObject *                     m_pDevice3dObject;      // The device 3D object
    HRESULT                         m_hrInit;               // Has the object been initialized?

private:
    // Interfaces
    CImpDirectSound3dBuffer<CDirectSound3dBuffer> *m_pImpDirectSound3dBuffer;

public:
    CDirectSound3dBuffer(CDirectSoundSecondaryBuffer *);
    virtual ~CDirectSound3dBuffer();

public:
    // Creation
    virtual HRESULT Initialize(REFGUID, DWORD, DWORD, CDirectSound3dListener *, CDirectSound3dBuffer *);
    virtual HRESULT IsInit();

    // 3D properties
    virtual HRESULT GetAllParameters(LPDS3DBUFFER);
    virtual HRESULT GetConeAngles(LPDWORD, LPDWORD);
    virtual HRESULT GetConeOrientation(D3DVECTOR*);
    virtual HRESULT GetConeOutsideVolume(LPLONG);
    virtual HRESULT GetMaxDistance(D3DVALUE*);
    virtual HRESULT GetMinDistance(D3DVALUE*);
    virtual HRESULT GetMode(LPDWORD);
    virtual HRESULT GetPosition(D3DVECTOR*);
    virtual HRESULT GetVelocity(D3DVECTOR*);
    virtual HRESULT SetAllParameters(LPCDS3DBUFFER, DWORD);
    virtual HRESULT SetConeAngles(DWORD, DWORD, DWORD);
    virtual HRESULT SetConeOrientation(REFD3DVECTOR, DWORD);
    virtual HRESULT SetConeOutsideVolume(LONG, DWORD);
    virtual HRESULT SetMaxDistance(D3DVALUE, DWORD);
    virtual HRESULT SetMinDistance(D3DVALUE, DWORD);
    virtual HRESULT SetMode(DWORD, DWORD);
    virtual HRESULT SetPosition(REFD3DVECTOR, DWORD);
    virtual HRESULT SetVelocity(REFD3DVECTOR, DWORD);

    // Buffer properties
    virtual HRESULT GetAttenuation(FLOAT*);
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN, LPBOOL);
    virtual HRESULT SetFrequency(DWORD, LPBOOL);
    virtual HRESULT SetMute(BOOL, LPBOOL);

protected:
    // Resource management
    virtual HRESULT AcquireResources(CSecondaryRenderWaveBuffer *);
    virtual HRESULT FreeResources();
};

inline HRESULT CDirectSound3dBuffer::IsInit()
{
    return m_hrInit;
}

// The DirectSound Property Set object.  This object cannot be instantiated
// directly.  It must be owned or inherited by a class derived from CUnknown.
class CDirectSoundPropertySet
    : public CDsBasicRuntime
{
    friend class CDirectSoundPrimaryBuffer;
    friend class CDirectSoundSecondaryBuffer;

protected:
    CUnknown *              m_pParent;              // The parent object
    CWrapperPropertySet *   m_pWrapperPropertySet;  // The wrapper property set object
    CPropertySet *          m_pDevicePropertySet;   // The device property set object
    HRESULT                 m_hrInit;               // Has the object been initialized?

private:
    // Interfaces
    CImpKsPropertySet<CDirectSoundPropertySet> *m_pImpKsPropertySet;

public:
    CDirectSoundPropertySet(CUnknown *);
    virtual ~CDirectSoundPropertySet();

public:
    // Initialization
    virtual HRESULT Initialize();
    virtual HRESULT IsInit();

    // Property sets
    virtual HRESULT QuerySupport(REFGUID, ULONG, PULONG);
    virtual HRESULT GetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG);
    virtual HRESULT SetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);

protected:
    // Resource management
    virtual HRESULT AcquireResources(CRenderWaveBuffer *);
    virtual HRESULT FreeResources();
};

inline HRESULT CDirectSoundPropertySet::IsInit()
{
    return m_hrInit;
}

// The DirectSound Property Set object.  This object cannot be instantiated
// directly.  It must be owned or inherited by a class derived from CUnknown.
class CDirectSoundSecondaryBufferPropertySet
    : public CDirectSoundPropertySet, public CPropertySetHandler
{
private:
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_VoiceManager);
    DECLARE_PROPERTY_SET_DATA_MEMBER(m_aPropertySets);

public:
    CDirectSoundSecondaryBufferPropertySet(CDirectSoundSecondaryBuffer *);
    virtual ~CDirectSoundSecondaryBufferPropertySet();

public:
    // Property handlers
    virtual HRESULT QuerySupport(REFGUID, ULONG, PULONG);
    virtual HRESULT GetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG);
    virtual HRESULT SetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);

    // Unsupported property handlers
    virtual HRESULT UnsupportedQueryHandler(REFGUID, ULONG, PULONG);
    virtual HRESULT UnsupportedGetHandler(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG);
    virtual HRESULT UnsupportedSetHandler(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);
};

#endif // __cplusplus

#endif // __DSBUF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsclock.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dssink.h
 *  Content:    The clock code from orginally derived from dmsynth DX7
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/25/0     petchey	Created
 *
 ***************************************************************************/

#include "dsoundi.h"

#define MILS_TO_REF	10000

CPhaseLockClock::CPhaseLockClock()
{
	m_rfOffset = 0;
    m_rfBaseOffset = 0;
}

// When the clock starts, it needs to mark down the 
// difference between the time it is given and its concept of time. 

void CPhaseLockClock::Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime)
{
	m_rfOffset = 0;
    m_rfBaseOffset = rfMasterTime - rfSlaveTime;
}	


// Convert the passed time to use the same base as the master clock.

void CPhaseLockClock::GetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)
{
	rfSlaveTime += m_rfBaseOffset;
	*prfTime = rfSlaveTime;
}

void CPhaseLockClock::SetSlaveTime(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME *prfTime)

{
	rfSlaveTime -= m_rfBaseOffset;
	*prfTime = rfSlaveTime;
}

/*	SyncToMaster provides the needed magic to keep the clock
	in sync. Since the clock uses its own clock (rfSlaveTime)
	to increment, it can drift. This call provides a reference
	time which the clock compares with its internal 
	concept of time. The difference between the two is
	considered the drift. Since the sync time may increment in
	a lurching way, the correction has to be subtle. 
	So, the difference between the two is divided by
	100 and added to the offset.
*/
void CPhaseLockClock::SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime, BOOL fLockToMaster)
{
	rfSlaveTime += (m_rfOffset + m_rfBaseOffset);
	rfSlaveTime -= rfMasterTime;	// Find difference between calculated and expected time.
	rfSlaveTime /= 100;				// Reduce in magnitude.
    // If fLockToMaster is true, we want to adjust our offset that we use for conversions, 
    // so our clock will slave to the master clock.
    if (fLockToMaster)
    {
        m_rfBaseOffset -= rfSlaveTime;
    }
    // Otherwise, we want to put a value into m_rfOffset that will be used to 
    // tweak the master clock so it will slave to our time.
    else
    {
	    m_rfOffset -= rfSlaveTime;		// Subtract that from the original offset.
    }
}

CSampleClock::CSampleClock()
{
	m_dwStart = 0;
	m_dwSampleRate = 22050;
}

void CSampleClock::Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples)
{
	REFERENCE_TIME rfStart;
	m_dwStart = dwSamples;
	m_dwSampleRate = dwSampleRate;
	if (pIClock)
	{
		pIClock->GetTime(&rfStart);
		m_PLClock.Start(rfStart,0);
	}
}

CSampleClock::~CSampleClock()
{
}

void CSampleClock::SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prfTime)
{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	m_PLClock.GetSlaveTime(llSampleTime, prfTime);
}

LONGLONG CSampleClock::RefToSampleTime(REFERENCE_TIME rfTime)
{
	m_PLClock.SetSlaveTime(rfTime, &rfTime);
	rfTime /= 1000;
	rfTime *= m_dwSampleRate;
	rfTime /= MILS_TO_REF;
	rfTime += m_dwStart;
	return rfTime;
}

void CSampleClock::SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock, BOOL fLockToMaster)
{
	llSampleTime -= m_dwStart;
	llSampleTime *= MILS_TO_REF;
	llSampleTime /= m_dwSampleRate;
	llSampleTime *= 1000;
	if (pIClock)
	{
		REFERENCE_TIME rfMasterTime;
		pIClock->GetTime(&rfMasterTime);
		m_PLClock.SyncToMaster(llSampleTime, rfMasterTime,fLockToMaster);
	}
}


CDirectSoundClock::CDirectSoundClock()
{
    m_pDSSink  = NULL;
}

void CDirectSoundClock::Init(CDirectSoundSink *pDSSink)
{
    m_pDSSink = pDSSink;
}

HRESULT CDirectSoundClock::QueryInterface( REFIID riid, LPVOID FAR* ppvObj )
{
    if( ::IsEqualIID( riid, IID_IReferenceClock ) ||
        ::IsEqualIID( riid, IID_IUnknown ) )
    {
        AddRef();
        *ppvObj = this;
        return S_OK;
    }
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

ULONG CDirectSoundClock::AddRef()
{
    if (m_pDSSink)
    {
        return m_pDSSink->AddRef();
    }
    else return 0;
}

ULONG CDirectSoundClock::Release()
{
    if (m_pDSSink)
    {
        return m_pDSSink->Release();
    }
    else return 0;
}

HRESULT STDMETHODCALLTYPE CDirectSoundClock::AdviseTime(REFERENCE_TIME /*baseTime*/,
                                                        REFERENCE_TIME /*streamTime*/,
                                                        HANDLE /*hEvent*/,
                                                        DWORD * /*pdwAdviseCookie*/)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CDirectSoundClock::AdvisePeriodic(REFERENCE_TIME /*startTime*/,
                                                            REFERENCE_TIME /*periodTime*/,
                                                            HANDLE /*hSemaphore*/,
                                                            DWORD * /*pdwAdviseCookie*/)
{
    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CDirectSoundClock::Unadvise( DWORD /*dwAdviseCookie*/ )
{
    return E_NOTIMPL;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundClock::GetTime"

HRESULT STDMETHODCALLTYPE CDirectSoundClock::GetTime(LPREFERENCE_TIME pTime)
{
    HRESULT hr = E_FAIL;

    if( pTime == NULL )
    {
        return E_INVALIDARG;
    }

    if (m_pDSSink != NULL)
    {
        REFERENCE_TIME rtCompare;
        if (m_pDSSink->m_pIMasterClock)
        {

            m_pDSSink->m_pIMasterClock->GetTime(&rtCompare);

            hr = m_pDSSink->SampleToRefTime(m_pDSSink->ByteToSample(m_pDSSink->m_llAbsWrite), pTime);


            if (FAILED(hr))
            {
                DPF(DPFLVL_WARNING, "Sink Latency Clock: SampleToRefTime failed");
                return hr;
            }

            if (*pTime < rtCompare)
            {
                // Make this DPFLVL_WARNING level again when 33786 is fixed
                DPF(DPFLVL_INFO, "Sink Latency Clock off. Latency time is %ldms, Master time is %ldms",
                    (long) (*pTime / 10000), (long) (rtCompare / 10000));
                *pTime = rtCompare;
            }
            else if (*pTime > (rtCompare + (10000 * 1000)))
            {
                // Make this DPFLVL_WARNING level again when 33786 is fixed
                DPF(DPFLVL_INFO, "Sink Latency Clock off. Latency time is %ldms, Master time is %ldms",
                    (long) (*pTime / 10000), (long) (rtCompare / 10000));
                *pTime = rtCompare + (10000 * 1000);
            }

            hr = S_OK;
        }
        else
        {
            DPF(DPFLVL_WARNING, "Sink Latency Clock - GetTime called with no master clock");
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsclock.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dssink.h
 *  Content:    The clock code from orginally derived from dmsynth DX7
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  03/25/0     petchey	Created
 *
 ***************************************************************************/

#ifndef __DSCLOCK_H__
#define __DSCLOCK_H__

#ifdef __cplusplus

class CPhaseLockClock
{
public:
						CPhaseLockClock();
	void				Start(REFERENCE_TIME rfMasterTime, REFERENCE_TIME rfSlaveTime);
	void				GetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SetSlaveTime(REFERENCE_TIME rfSlaveTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(REFERENCE_TIME rfSlaveTime, REFERENCE_TIME rfMasterTime,BOOL fLockToMaster);
	void				GetClockOffset(REFERENCE_TIME *prfTime) { *prfTime = m_rfOffset; };
private:
	REFERENCE_TIME		m_rfOffset;
    REFERENCE_TIME      m_rfBaseOffset;
};

class CSampleClock
{
public:
						CSampleClock();
						~CSampleClock();
	void				Start(IReferenceClock *pIClock, DWORD dwSampleRate, DWORD dwSamples);
	void				SampleToRefTime(LONGLONG llSampleTime,REFERENCE_TIME *prfTime);
	void				SyncToMaster(LONGLONG llSampleTime, IReferenceClock *pIClock,BOOL fLockToMaster);
	LONGLONG			RefToSampleTime(REFERENCE_TIME rfTime);
	void				GetClockOffset(REFERENCE_TIME *prfTime) { m_PLClock.GetClockOffset(prfTime); };

private:
	CPhaseLockClock		m_PLClock;
	DWORD				m_dwStart;			// Initial sample offset.
	DWORD				m_dwSampleRate;
};

class CDirectSoundClock : public IReferenceClock
{
public:
    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);

    /* IReferenceClock methods */
    HRESULT STDMETHODCALLTYPE GetTime( 
		/* [out] */ REFERENCE_TIME *pTime);
    
    HRESULT STDMETHODCALLTYPE AdviseTime( 
        /* [in] */ REFERENCE_TIME baseTime,
        /* [in] */ REFERENCE_TIME streamTime,
        /* [in] */ HANDLE hEvent,
        /* [out] */ DWORD *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE AdvisePeriodic( 
        /* [in] */ REFERENCE_TIME startTime,
        /* [in] */ REFERENCE_TIME periodTime,
        /* [in] */ HANDLE hSemaphore,
        /* [out] */ DWORD *pdwAdviseCookie);
    
    HRESULT STDMETHODCALLTYPE Unadvise( 
		/* [in] */ DWORD dwAdviseCookie);

public: 
                CDirectSoundClock();
    void        Init(CDirectSoundSink *m_pDSSink);
    void        Stop();         // Call store current time as offset.
    void        Start();        // Call to reinstate running.
private:
    BOOL        m_fStopped;      // Currently changing configuration.
    CDirectSoundSink *m_pDSSink; // Pointer to parent sink object.
};

#endif // __cplusplus

#endif //__DSCLOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dscom.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscom.h
 *  Content:    COM/OLE helpers
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/26/97     dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSCOM_H__
#define __DSCOM_H__

#ifdef __cplusplus

// Interface list
typedef struct tagINTERFACENODE
{
    GUID                guid;
    CImpUnknown *       pImpUnknown;
    LPVOID              pvInterface;
} INTERFACENODE, *LPINTERFACENODE;

// IUnknown implementation
class CUnknown
    : public CDsBasicRuntime
{
private:
    CList<INTERFACENODE>    m_lstInterfaces;        // List of registered interfaces
    CImpUnknown *           m_pImpUnknown;          // IUnknown interface pointer
    CUnknown*               m_pControllingUnknown;  // Used for aggregation.

public:
    CUnknown(void);
    CUnknown(CUnknown*);
    virtual ~CUnknown(void);

public:
    // Interface management
    virtual HRESULT RegisterInterface(REFGUID, CImpUnknown *, LPVOID);
    virtual HRESULT UnregisterInterface(REFGUID);

    // IUnknown methods
    virtual HRESULT QueryInterface(REFGUID, BOOL, LPVOID *);
    virtual ULONG AddRef(void);
    virtual ULONG Release(void);

    // INonDelegatingUnknown methods
    virtual HRESULT NonDelegatingQueryInterface(REFGUID, BOOL, LPVOID *);
    virtual ULONG NonDelegatingAddRef(void);
    virtual ULONG NonDelegatingRelease(void);

    // Functionality versioning
    virtual void SetDsVersion(DSVERSION nVersion) {m_nVersion = nVersion;}
    DSVERSION GetDsVersion() {return m_nVersion;}

protected:
    virtual HRESULT FindInterface(REFGUID, CNode<INTERFACENODE> **);

private:
    // Functionality versioning
    DSVERSION m_nVersion;
};

__inline ULONG CUnknown::NonDelegatingAddRef(void)
{
    return CRefCount::AddRef();
}

__inline ULONG CUnknown::NonDelegatingRelease(void)
{
    return CDsBasicRuntime::Release();
}

// IClassFactory implementation
class CClassFactory
    : public CUnknown
{
public:
    static ULONG            m_ulServerLockCount;

private:
    // Interfaces
    CImpClassFactory<CClassFactory> *m_pImpClassFactory;

public:
    CClassFactory(void);
    virtual ~CClassFactory(void);

public:
    virtual HRESULT CreateInstance(REFIID, LPVOID *) = 0;
    virtual HRESULT LockServer(BOOL);
};

// DirectSound class factory template definition
template <class object_type> class CDirectSoundClassFactory
    : public CClassFactory
{
public:
    virtual HRESULT CreateInstance(REFIID, LPVOID *);
};

#endif // __cplusplus

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

STDAPI DllCanUnloadNow(void);
STDAPI DllGetClassObject(REFCLSID, REFIID, LPVOID *);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsdriver.inc ===
;
;DSVXD.INC
;
;Include file for HAL and HEL VXD layers
;
;Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
;

                ;
                ;Return byte count to caller
                ;
                ;Do not use ESI as parameter!
                ;

OUTCNT          MACRO RetCnt
                LOCAL exit

                push esi
                mov esi,IOCTL_parms
                mov esi,[esi].lpcbBytesReturned
                or esi,esi
                jz exit
                mov DWORD PTR [esi],RetCnt
exit:           pop esi

                ENDM

                ;
                ;Return 4-byte DWORD to caller
                ;
                ;Do not use ESI as parameter!
                ;

OUTDWORD        MACRO RetVal
                LOCAL exit

                push esi
                mov esi,IOCTL_parms
                mov esi,[esi].lpvOutBuffer
                or esi,esi
                jz exit
                mov DWORD PTR [esi],RetVal
                OUTCNT 4
exit:           pop esi

                ENDM

                ;
                ;Read 4-byte DWORD from caller
                ;
                ;Do not use ESI as parameter!
                ;

INDWORD         MACRO RetVal
                LOCAL exit

                push esi
                mov esi,IOCTL_parms
                mov esi,[esi].lpvInBuffer
                mov RetVal,-1
                or esi,esi
                jz exit
                mov RetVal,DWORD PTR [esi]
exit:           pop esi

                ENDM

                ;
                ;String copy/write macros
                ;

REP_MOVSB       MACRO

                push ecx
                and ecx,3
                rep movsb
                pop ecx
                shr ecx,2
                rep movsd

                ENDM

REP_STOSB       MACRO

                push ecx
                and ecx,3
                rep stosb
                pop ecx
                shr ecx,2
                rep stosd

                ENDM

                ;
                ;Scale definition
                ;
DS_SCALE_MAX	equ 65535
DS_SCALE_MID	equ 32768

                ;
                ;Error codes
                ;

HAL_OK              equ 0
HAL_ERROR           equ 1
HAL_CANT_OPEN_VXD   equ 2
HAL_ALLOC_FAILED    equ 3
HAL_NOT_ALLOCATED   equ 4
HAL_MUST_STOP_FIRST equ 5

HAL_SYSALLOCMEM	    equ 11

                ;
                ;Base mode flag equates
                ;        Note: This file is generated by modeflag.m4

include <modeflag.inc>

                ;
                ;HALHWMODE afAbilityFlags values
                ;
                ;These flags describe dynamic capabilities (what the device
                ;can/cannot do)
                ;

A_CAN_CHANGE_VOLUME         equ 00000001b  ;Can change volume while playing
A_CANNOT_CHANGE_VOLUME      equ 00000000b  ;Cannot change volume while playing

A_CAN_CHANGE_MODE           equ 00000010b  ;Can change PCM mode while playing
A_CANNOT_CHANGE_MODE        equ 00000000b  ;Cannot change PCM mode while playing

A_CAN_CHANGE_RATE           equ 00000100b  ;Can change rate while playing
A_CANNOT_CHANGE_RATE        equ 00000000b  ;Cannot change rate while playing

A_CAN_LOOP_SECONDARY        equ 00001000b  ;Can loop secondary buffers before starting
A_CANNOT_LOOP_SECONDARY     equ 00000000b  ;Cannot loop secondary buffers before starting

A_CAN_UNLOOP_SECONDARY      equ 00010000b  ;Secondary bufers do not have to loop
A_CANNOT_UNLOOP_SECONDARY   equ 00000000b  ;Secondary buffers must always loop

A_CAN_CHANGE_LOOP_STATUS    equ 00100000b  ;Can turn looping on/off during playback
A_CANNOT_CHANGE_LOOP_STATUS equ 00000000b  ;Cannot turn looping on/off during playback

                ;
                ;HALSTRBUF.dwFlags values
                ;

HSB_DMA_ALLOC   equ 1h		;Buffer was allocated from DMA services
HSB_RAM_ALLOC   equ 2h		;Buffer was allocated from sound card RAM

                ;
                ;
                ;Passed to HAL_ChangeStreamFormat() to inhibit parameter
                ;change
                ;

HF_NO_CHANGE    equ -1


                ;
                ;DSound Caps
                ;


DSC_LOCK_SYSMEM		equ 65535
DSC_LOCK_SLOW		equ 64
DSC_PLAY_DMA		equ 20
DSC_PLAY_ONBOARD	equ 0


DSC_CAPSF_MONO		equ 1
DSC_CAPSF_STEREO	equ 2
DSC_CAPSF_8BIT		equ 4
DSC_CAPSF_16BIT		equ 8


                ;
                ;Stream buffer descriptor
                ;
HALSTRBUF STRUCT
 hfFormat       DWORD ?
 dwSampleRate   DWORD ?
 dwUserSampleRate DWORD ?
 dwVolume       DWORD ?
 dwPan	        DWORD ?
 dwLVolume      DWORD ?
 dwRVolume      DWORD ?
 dwMVolume      DWORD ?
HALSTRBUF ENDS

                ;
                ;Mix session descriptor
                ;

MIXSESSION STRUCT
 lpBuildBuffer  DWORD ?
 dwBuildSize    DWORD ?
 HALOutStrBuf   HALSTRBUF <>
 pBuffer	DWORD ?
 cbBuffer	DWORD ?
 nOutputBytes   DWORD ?
MIXSESSION ENDS

                ;
                ;Mixer input descriptor
                ;

MIXERINPUT STRUCT
 HALInStrBuf    HALSTRBUF <>
 pBuffer	DWORD ?
 cbBuffer	DWORD ?
 lpdwInputPos   DWORD ?
 dwInputBytes   DWORD ?
 dwOutputOffset DWORD ?
MIXERINPUT ENDS


; VxD ID registered to DSHEL.VXD
DSOUND_Device_ID		EQU	357Eh

ifdef DDB_Sys_Crit_Init_Done

; DSound Driver  VxDs use this service to

Begin_Service_Table	DSOUND
        DSOUND_Service  _DSOUND_GetVersion, LOCAL
        DSOUND_Service  _DSOUND_RegisterDeviceDriver, VxD_CODE
        DSOUND_Service  _DSOUND_DeregisterDeviceDriver, VxD_CODE
End_Service_Table DSOUND


ENDIF   ; DDB_Sys_Crit_Init_Done (VxD's only)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dscom.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dscom.cpp
 *  Content:    COM/OLE helpers
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/26/97     dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  CImpUnknown
 *
 *  Description:
 *      IUnknown implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: controlling unknown object.
 *      LPVOID [in]: ignored.  Provided for compatibility with other
 *                   interfaces' constructors.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpUnknown::CImpUnknown"

CImpUnknown::CImpUnknown
(
    CUnknown *pUnknown,
    LPVOID pvIgnored
) : m_signature(INTSIG_IUNKNOWN)
{
    ENTER_DLL_MUTEX();
    DPF_ENTER();
    DPF_CONSTRUCT(CImpUnknown);

    // Initialize defaults
    m_pUnknown = pUnknown;
    m_ulRefCount = 0;
    m_fValid = FALSE;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpUnknown
 *
 *  Description:
 *      IUnknown implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpUnknown::~CImpUnknown"

CImpUnknown::~CImpUnknown(void)
{
    ENTER_DLL_MUTEX();
    DPF_ENTER();
    DPF_DESTRUCT(CImpUnknown);

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  QueryInterface
 *
 *  Description:
 *      Queries the object for a given interface.
 *
 *  Arguments:
 *      REFIID [in]: interface id.
 *      LPVOID FAR * [out]: receives pointer to new interface.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpUnknown::QueryInterface"

HRESULT STDMETHODCALLTYPE CImpUnknown::QueryInterface
(
    REFIID riid,
    LPVOID *ppvObj
)
{
    HRESULT                 hr  = DS_OK;

    ENTER_DLL_MUTEX();
    DPF_API2(IUnknown::QueryInterface, &riid, ppvObj);
    DPF_ENTER();

    if(!IS_VALID_IUNKNOWN(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&riid))
    {
        RPF(DPFLVL_ERROR, "Invalid interface id pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_WRITE_PTR(ppvObj, sizeof(LPVOID)))
        {
            *ppvObj = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid interface buffer");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pUnknown->QueryInterface(riid, FALSE, ppvObj);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  AddRef
 *
 *  Description:
 *      Increases the object reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpUnknown::AddRef"

ULONG STDMETHODCALLTYPE CImpUnknown::AddRef(void)
{
    ULONG                   ulRefCount  = MAX_ULONG;

    ENTER_DLL_MUTEX();
    DPF_API0(IUnknown::AddRef);
    DPF_ENTER();

    if(IS_VALID_IUNKNOWN(this))
    {
        ulRefCount = ::AddRef(&m_ulRefCount);
        m_pUnknown->AddRef();
    }
    else
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
    }

    DPF_API_LEAVE(ulRefCount);
    LEAVE_DLL_MUTEX();
    return ulRefCount;
}


/***************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decreases the object reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpUnknown::Release"

ULONG STDMETHODCALLTYPE CImpUnknown::Release(void)
{
    ULONG                   ulRefCount  = MAX_ULONG;

    ENTER_DLL_MUTEX();
    DPF_API0(IUnknown::Release);
    DPF_ENTER();

    if(IS_VALID_IUNKNOWN(this))
    {
        ulRefCount = ::Release(&m_ulRefCount);
        m_pUnknown->Release();
    }
    else
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
    }

    DPF_API_LEAVE(ulRefCount);
    LEAVE_DLL_MUTEX();
    return ulRefCount;
}


/***************************************************************************
 *
 *  CUnknown
 *
 *  Description:
 *      Unknown object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::CUnknown"

CUnknown::CUnknown(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CUnknown);

    // Initialize defaults
    m_pControllingUnknown = NULL;
    m_nVersion = DSVERSION_DX7;  // Baseline functional level is DirectX 7.0

    // Register the interface(s) with the interface manager.  Normally, this
    // would be done from the object's ::Initialize method, but we have to
    // guarantee that all objects can be QI'd for IUnknown, regardless of
    // whether they're initialized or not.
    CreateAndRegisterInterface(this, IID_IUnknown, this, &m_pImpUnknown);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CUnknown
 *
 *  Description:
 *      Unknown object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::CUnknown"

CUnknown::CUnknown
(
    CUnknown*               pControllingUnknown
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CUnknown);

    // Initialize defaults
    m_pControllingUnknown = pControllingUnknown;
    m_nVersion = DSVERSION_DX7;  // Baseline functional level is DirectX 7.0

    // Register the interface(s) with the interface manager.  Normally, this
    // would be done from the object's ::Initialize method, but we have to
    // guarantee that all objects can be QI'd for IUnknown, regardless of
    // whether they're initialized or not.
    CreateAndRegisterInterface(this, IID_IUnknown, this, &m_pImpUnknown);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CUnknown
 *
 *  Description:
 *      Unknown object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::~CUnknown"

CUnknown::~CUnknown(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CUnknown);

    // Free all interfaces
    DELETE(m_pImpUnknown);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  QueryInterface
 *
 *  Description:
 *      Finds an interface in the list and returns a pointer to its
 *      implementation object.
 *
 *  Arguments:
 *      REFGUID [in]: GUID of the interface.
 *      LPVOID * [out]: recieves pointer to implementation object.
 *      BOOL [in]: TRUE if this is an internal query (i.e. from within
 *                 DirectSoundCreate for example).
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::QueryInterface"

HRESULT CUnknown::QueryInterface
(
    REFGUID     guid,
    BOOL        fInternalQuery,
    LPVOID*     ppvInterface
)
{
    HRESULT                 hr;

    DPF_ENTER();

    if(m_pControllingUnknown)
    {
        hr = m_pControllingUnknown->QueryInterface(guid, fInternalQuery, ppvInterface);
    }
    else
    {
        hr = NonDelegatingQueryInterface(guid, fInternalQuery, ppvInterface);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  AddRef
 *
 *  Description:
 *      Increments the object's reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::AddRef"

ULONG
CUnknown::AddRef
(
    void
)
{
    ULONG                   ulRefCount;

    DPF_ENTER();

    if(m_pControllingUnknown)
    {
        ulRefCount = m_pControllingUnknown->AddRef();
    }
    else
    {
        ulRefCount = NonDelegatingAddRef();
    }

    DPF_LEAVE(ulRefCount);
    return ulRefCount;
}


/***************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decrements the object's reference count by 1.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      ULONG: object reference count.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::Release"

ULONG
CUnknown::Release
(
    void
)
{
    ULONG                   ulRefCount;

    DPF_ENTER();

    if(m_pControllingUnknown)
    {
        ulRefCount = m_pControllingUnknown->Release();
    }
    else
    {
        ulRefCount = NonDelegatingRelease();
    }

    DPF_LEAVE(ulRefCount);
    return ulRefCount;
}


/***************************************************************************
 *
 *  RegisterInterface
 *
 *  Description:
 *      Registers a new interface with the object.
 *
 *  Arguments:
 *      REFGUID [in]: GUID of the interface.
 *      CImpUnknown * [in]: pointer to the CImpUnknown piece of the
 *                          interface.
 *      LPVOID [in]: pointer to the interface implementation object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::RegisterInterface"

HRESULT CUnknown::RegisterInterface
(
    REFGUID guid,
    CImpUnknown *pImpUnknown,
    LPVOID pvInterface
)
{
    INTERFACENODE           iface;
    HRESULT                 hr;

    DPF_ENTER();

    DPF(DPFLVL_MOREINFO, "Registering interface " DPF_GUID_STRING " at 0x%p", DPF_GUID_VAL(guid), pvInterface);

    ASSERT(!IS_NULL_GUID(&guid));

#ifdef DEBUG

    hr = FindInterface(guid, NULL);
    ASSERT(FAILED(hr));

#endif // DEBUG

    // Validate the interface
    pImpUnknown->m_ulRefCount = 0;
    pImpUnknown->m_fValid = TRUE;

    // Add the interface to the list
    iface.guid = guid;
    iface.pImpUnknown = pImpUnknown;
    iface.pvInterface = pvInterface;

    hr = HRFROMP(m_lstInterfaces.AddNodeToList(iface));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  UnregisterInterface
 *
 *  Description:
 *      Removes a registered interface from the list.
 *
 *  Arguments:
 *      REFGUID [in]: GUID of the interface.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::UnregisterInterface"

HRESULT CUnknown::UnregisterInterface
(
    REFGUID guid
)
{
    const BOOL              fAll    = IS_NULL_GUID(&guid);
    HRESULT                 hr      = DS_OK;
    CNode<INTERFACENODE> *  pNode;

    DPF_ENTER();

    do
    {
        // Find the node in the list
        if(fAll)
        {
            pNode = m_lstInterfaces.GetListHead();
        }
        else
        {
            hr = FindInterface(guid, &pNode);
        }

        if(FAILED(hr) || !pNode)
        {
            break;
        }

        DPF(DPFLVL_MOREINFO, "Unregistering interface " DPF_GUID_STRING, DPF_GUID_VAL(pNode->m_data.guid));

        // Invalidate the interface
        pNode->m_data.pImpUnknown->m_ulRefCount = 0;
        pNode->m_data.pImpUnknown->m_fValid = FALSE;

        // Remove the node from the list
        m_lstInterfaces.RemoveNodeFromList(pNode);
    }
    while(fAll);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  NonDelegatingQueryInterface
 *
 *  Description:
 *      Finds an interface in the list and returns a pointer to its
 *      implementation object.
 *
 *  Arguments:
 *      REFGUID [in]: GUID of the interface.
 *      LPVOID * [out]: recieves pointer to implementation object.
 *
 *  Returns:
 *      HRESULT: COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::NonDelegatingQueryInterface"

HRESULT
CUnknown::NonDelegatingQueryInterface
(
    REFGUID                 guid,
    BOOL                    fInternalQuery,
    LPVOID *                ppvInterface
)
{
    CNode<INTERFACENODE> *  pNode;
    HRESULT                 hr;

    DPF_ENTER();

    // Find the node in the list
    hr = FindInterface(guid, &pNode);

    // Increase the interface and object's reference counts
    if(SUCCEEDED(hr))
    {
        // Internal queries only addref the interface, not the object.
        // The reason for this is that interface reference counts are
        // initialized to 0, while objects reference counts are initialized
        // to 1.
        ::AddRef(&pNode->m_data.pImpUnknown->m_ulRefCount);

        if(!fInternalQuery)
        {
            AddRef();
        }
    }

    // Success
    if(SUCCEEDED(hr))
    {
        *ppvInterface = pNode->m_data.pvInterface;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindInterface
 *
 *  Description:
 *      Finds an interface in the list and returns a pointer to its
 *      implementation object.
 *
 *  Arguments:
 *      REFGUID [in]: GUID of the interface.
 *      CNode ** [out]: receives pointer to the node in the list.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::FindInterface"

HRESULT CUnknown::FindInterface
(
    REFGUID                 guid,
    CNode<INTERFACENODE>**  ppNode
)
{
    CNode<INTERFACENODE> *  pNode;
    HRESULT                 hr;

    DPF_ENTER();

    for(pNode = m_lstInterfaces.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        if(guid == pNode->m_data.guid)
        {
            break;
        }
    }

    hr = pNode ? S_OK : E_NOINTERFACE;

    if(SUCCEEDED(hr) && ppNode)
    {
        *ppNode = pNode;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CClassFactory
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CClassFactory::CClassFactory"

ULONG CClassFactory::m_ulServerLockCount = 0;

CClassFactory::CClassFactory(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CClassFactory);

    // Register the interface(s) with the interface manager
    CreateAndRegisterInterface(this, IID_IClassFactory, this, &m_pImpClassFactory);

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CClassFactory
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CClassFactory::~CClassFactory"

CClassFactory::~CClassFactory(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CClassFactory);

    // Unregister with the administrator
    g_pDsAdmin->UnregisterObject(this);

    // Free the interface(s)
    DELETE(m_pImpClassFactory);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  LockServer
 *
 *  Description:
 *      Locks or unlocks the dll.  Note that this function does not
 *      currently lock the application into memory.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to lock the dll, FALSE to unlock it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CClassFactory::LockServer"

HRESULT CClassFactory::LockServer(BOOL fLock)
{
    DPF_ENTER();

    if(fLock)
    {
        ASSERT(m_ulServerLockCount < MAX_ULONG);

        if(m_ulServerLockCount < MAX_ULONG)
        {
            m_ulServerLockCount++;
        }
    }
    else
    {
        ASSERT(m_ulServerLockCount > 0);

        if(m_ulServerLockCount > 0)
        {
            m_ulServerLockCount--;
        }
    }

    DPF_LEAVE(S_OK);
    return S_OK;
}


/***************************************************************************
 *
 *  CreateInstance
 *
 *  Description:
 *      Creates an object corresponding to the given IID.
 *
 *  Arguments:
 *      REFIID [in]: object interface id.
 *      LPVOID * [out]: receives pointer to the new object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundClassFactory::CreateInstance"

template <class object_type> HRESULT CDirectSoundClassFactory<object_type>::CreateInstance(REFIID iid, LPVOID *ppvInterface)
{
    object_type *           pObject;
    HRESULT                 hr;

    DPF_ENTER();

    // Create a new DirectSound object
    DPF(DPFLVL_INFO, "Creating object via IClassFactory::CreateInstance");

    pObject = NEW(object_type);
    hr = HRFROMP(pObject);

    if(SUCCEEDED(hr))
    {
        // Set the functional level on the object
        pObject->SetDsVersion(GetDsVersion());

        // Query for the requested interface
        hr = pObject->QueryInterface(iid, TRUE, ppvInterface);
    }

    // Free resources
    if(FAILED(hr))
    {
        ABSOLUTE_RELEASE(pObject);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DllGetClassObject
 *
 *  Description:
 *      Creates a DirectSound Class Factory object.
 *
 *  Arguments:
 *      REFCLSID [in]: CLSID of the class factory object to create.
 *      REFIID [in]: IID of the interface to return.
 *      LPVOID * [out]: receives interface pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllGetClassObject"

STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID *ppvInterface)
{
    CClassFactory *         pClassFactory   = NULL;
    HRESULT                 hr              = S_OK;

    ENTER_DLL_MUTEX();
    DPF_ENTER();
    DPF_API3(DllGetClassObject, &clsid, &iid, ppvInterface);

    if(!IS_VALID_READ_GUID(&clsid))
    {
        RPF(DPFLVL_ERROR, "Invalid class id pointer");
        hr = E_INVALIDARG;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&iid))
    {
        RPF(DPFLVL_ERROR, "Invalid interface id pointer");
        hr = E_INVALIDARG;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppvInterface))
    {
        RPF(DPFLVL_ERROR, "Invalid interface buffer");
        hr = E_INVALIDARG;
    }

    // Create a new ClassFactory object
    if(SUCCEEDED(hr))
    {
        if(CLSID_DirectSound == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSound>);
        }
        else if(CLSID_DirectSound8 == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSound>);

            // Set the DX8 functional level on the factory object
            if (pClassFactory)
                pClassFactory->SetDsVersion(DSVERSION_DX8);
        }
        else if(CLSID_DirectSoundCapture == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSoundCapture>);
        }
        else if(CLSID_DirectSoundCapture8 == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSoundCapture>);

            // Set the DX8 functional level on the factory object
            if (pClassFactory)
                pClassFactory->SetDsVersion(DSVERSION_DX8);
        }
        else if(CLSID_DirectSoundPrivate == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSoundPrivate>);
        }
        else if(CLSID_DirectSoundFullDuplex == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSoundFullDuplex>);
        }
        else if(CLSID_DirectSoundBufferConfig == clsid)
        {
            pClassFactory = NEW(CDirectSoundClassFactory<CDirectSoundBufferConfig>);
        }
        else
        {
            RPF(DPFLVL_ERROR, "Unknown class id");
            hr = CLASS_E_CLASSNOTAVAILABLE;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(pClassFactory);
    }

    // Query for the requested interface
    if(SUCCEEDED(hr))
    {
        hr = pClassFactory->QueryInterface(iid, TRUE, ppvInterface);
    }

    // Free resources
    if(FAILED(hr))
    {
        ABSOLUTE_RELEASE(pClassFactory);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DllCanUnloadNow
 *
 *  Description:
 *      Returns whether or not the dll can be freed by the calling process.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DllCanUnloadNow"

STDAPI DllCanUnloadNow(void)
{
    DWORD                           dwCount = 0;
    HRESULT                         hr      = S_OK;

    ENTER_DLL_MUTEX();
    DPF_ENTER();
    DPF_API0(DllCanUnloadNow);

    // The dll can be unloaded if there's no locks on the server or objects
    // owned by the calling process.
    if(g_pDsAdmin)
    {
        dwCount = g_pDsAdmin->FreeOrphanedObjects(GetCurrentProcessId(), FALSE);
    }

    if(CClassFactory::m_ulServerLockCount > 0)
    {
        RPF(DPFLVL_ERROR, "%lu active locks on the server", CClassFactory::m_ulServerLockCount);
        hr = S_FALSE;
    }

    if(dwCount > 0)
    {
        RPF(DPFLVL_ERROR, "%lu objects still exist", dwCount);
        hr = S_FALSE;
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsfd.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsfd.h
 *  Content:    DirectSoundFullDuplex object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   12/1/98    jstokes Created
 *
 ***************************************************************************/

#ifndef __DSFULLDUPLEX_H__
#define __DSFULLDUPLEX_H__

#ifdef __cplusplus

// The main DirectSoundFullDuplex object
class CDirectSoundFullDuplex
    : public CUnknown
{
    friend class CDirectSoundPrivate;
    friend class CDirectSoundAdministrator;

protected:
    HRESULT                             m_hrInit;
    CDirectSoundCapture*                m_pDirectSoundCapture;
    CDirectSound*                       m_pDirectSound;
    BOOL                                m_fIncludeAec;
    GUID                                m_guidAecInstance;
    DWORD                               m_dwAecFlags;

private:
    // Interfaces
    CImpDirectSoundFullDuplex<CDirectSoundFullDuplex>* m_pImpDirectSoundFullDuplex;

public:
    CDirectSoundFullDuplex();
    virtual ~CDirectSoundFullDuplex();

public:
    // Creation
    virtual HRESULT Initialize(LPCGUID, LPCGUID, LPCDSCBUFFERDESC, LPCDSBUFFERDESC, HWND, DWORD, CDirectSoundCaptureBuffer**, CDirectSoundBuffer**);
    virtual HRESULT IsInit(void) {return m_hrInit;}

    // Public accessors
    BOOL HasAEC() {return m_fIncludeAec;}
    REFGUID AecInstanceGuid() {return m_guidAecInstance;}
    DWORD AecCreationFlags() {return m_dwAecFlags;}
};

#endif // __cplusplus

#endif // __DSFULLDUPLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsimp.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsimp.h
 *  Content:    DirectSound object implementation
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *
 ***************************************************************************/

#ifndef __DSIMP_H__
#define __DSIMP_H__

// Interface signatures
typedef enum
{
    INTSIG_DELETED                      = 'KCUS',
    INTSIG_IUNKNOWN                     = 'KNUI',
    INTSIG_IDIRECTSOUND                 = 'DNSD',
    INTSIG_IDIRECTSOUNDBUFFER           = 'FBSD',
    INTSIG_IDIRECTSOUND3DBUFFER         = 'FBD3',
    INTSIG_IDIRECTSOUND3DLISTENER       = 'SLD3',
    INTSIG_ICLASSFACTORY                = 'FSLC',
    INTSIG_IDIRECTSOUNDNOTIFY           = 'ETON',
    INTSIG_IKSPROPERTYSET               = 'PSKI',
    INTSIG_IDIRECTSOUNDCAPTURE          = 'PCSD',
    INTSIG_IDIRECTSOUNDCAPTUREBUFFER    = 'BCSD',
    INTSIG_IDIRECTSOUNDFULLDUPLEX       = 'FDSD',
    INTSIG_IDIRECTSOUNDSINK             = 'KSSD',
    INTSIG_IPERSIST                     = 'TSRP',
    INTSIG_IPERSISTSTREAM               = 'MSRP',
    INTSIG_IDIRECTMUSICOBJECT           = 'BOMD',
} INTERFACE_SIGNATURE;

#ifdef __cplusplus

// COMPATCOMPAT: previous versions of DirectSound used a static structure
// to represent the vtbl.  void meant that an application could call a
// method on a released object and simply fail.  Now, the user will almost
// certainly page fault.

// Fwd decl
class CUnknown;

// IUnknown
class CImpUnknown
    : public IUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    CUnknown *                  m_pUnknown;
    ULONG                       m_ulRefCount;
    BOOL                        m_fValid;

public:
    CImpUnknown(CUnknown *, LPVOID = NULL);
    virtual ~CImpUnknown(void);

public:
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID *);
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);
};

#define IMPLEMENT_IUNKNOWN() \
    inline virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID FAR *ppv) \
    { \
        return CImpUnknown::QueryInterface(riid, ppv); \
    } \
    \
    inline virtual ULONG STDMETHODCALLTYPE AddRef(void) \
    { \
        return CImpUnknown::AddRef(); \
    } \
    \
    inline virtual ULONG STDMETHODCALLTYPE Release(void) \
    { \
        return CImpUnknown::Release(); \
    }

// IDirectSound
template <class object_type> class CImpDirectSound
    : public IDirectSound8, public IDirectSoundPrivate, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSound(CUnknown *, object_type *);
    virtual ~CImpDirectSound(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    // IDirectSound methods
    virtual HRESULT STDMETHODCALLTYPE CreateSoundBuffer(LPCDSBUFFERDESC, LPDIRECTSOUNDBUFFER *, LPUNKNOWN);
    virtual HRESULT STDMETHODCALLTYPE GetCaps(LPDSCAPS);
    virtual HRESULT STDMETHODCALLTYPE DuplicateSoundBuffer(LPDIRECTSOUNDBUFFER, LPDIRECTSOUNDBUFFER *);
    virtual HRESULT STDMETHODCALLTYPE SetCooperativeLevel(HWND, DWORD);
    virtual HRESULT STDMETHODCALLTYPE Compact(void);
    virtual HRESULT STDMETHODCALLTYPE GetSpeakerConfig(LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE SetSpeakerConfig(DWORD);
    virtual HRESULT STDMETHODCALLTYPE Initialize(LPCGUID);

    // IDirectSound8 methods
    virtual HRESULT STDMETHODCALLTYPE AllocSink(LPWAVEFORMATEX, LPDIRECTSOUNDCONNECT *);
    virtual HRESULT STDMETHODCALLTYPE VerifyCertification(LPDWORD);
#ifdef FUTURE_WAVE_SUPPORT
    virtual HRESULT STDMETHODCALLTYPE CreateSoundBufferFromWave(IUnknown*, DWORD, LPDIRECTSOUNDBUFFER*);
#endif
};

// IDirectSoundBuffer
template <class object_type> class CImpDirectSoundBuffer
    : public IDirectSoundBuffer8, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSoundBuffer(CUnknown *, object_type *);
    virtual ~CImpDirectSoundBuffer(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    // IDirectSoundBuffer methods
    virtual HRESULT STDMETHODCALLTYPE GetCaps(LPDSBCAPS);
    virtual HRESULT STDMETHODCALLTYPE GetCurrentPosition(LPDWORD, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetFormat(LPWAVEFORMATEX, DWORD, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetVolume(LPLONG);
    virtual HRESULT STDMETHODCALLTYPE GetPan(LPLONG);
    virtual HRESULT STDMETHODCALLTYPE GetFrequency(LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE Initialize(LPDIRECTSOUND, LPCDSBUFFERDESC);
    virtual HRESULT STDMETHODCALLTYPE Lock(DWORD, DWORD, LPVOID FAR *, LPDWORD, LPVOID FAR *, LPDWORD, DWORD);
    virtual HRESULT STDMETHODCALLTYPE Play(DWORD, DWORD, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetCurrentPosition(DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetFormat(LPCWAVEFORMATEX);
    virtual HRESULT STDMETHODCALLTYPE SetVolume(LONG);
    virtual HRESULT STDMETHODCALLTYPE SetPan(LONG);
    virtual HRESULT STDMETHODCALLTYPE SetFrequency(DWORD);
    virtual HRESULT STDMETHODCALLTYPE Stop(void);
    virtual HRESULT STDMETHODCALLTYPE Unlock(LPVOID, DWORD, LPVOID, DWORD);
    virtual HRESULT STDMETHODCALLTYPE Restore(void);

    // IDirectSoundBuffer8 methods
    virtual HRESULT STDMETHODCALLTYPE SetFX(DWORD, LPDSEFFECTDESC, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE AcquireResources(DWORD, DWORD, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetObjectInPath(REFGUID, DWORD, REFGUID, LPVOID *);
#ifdef FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT STDMETHODCALLTYPE SetChannelVolume(DWORD, LPDWORD, LPLONG);
#endif
};

// IDirectSound3DListener
template <class object_type> class CImpDirectSound3dListener
    : public IDirectSound3DListener, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSound3dListener(CUnknown *, object_type *);
    virtual ~CImpDirectSound3dListener(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    virtual HRESULT STDMETHODCALLTYPE GetAllParameters(LPDS3DLISTENER);
    virtual HRESULT STDMETHODCALLTYPE GetDistanceFactor(D3DVALUE*);
    virtual HRESULT STDMETHODCALLTYPE GetDopplerFactor(D3DVALUE*);
    virtual HRESULT STDMETHODCALLTYPE GetOrientation(D3DVECTOR*, D3DVECTOR*);
    virtual HRESULT STDMETHODCALLTYPE GetPosition(D3DVECTOR*);
    virtual HRESULT STDMETHODCALLTYPE GetRolloffFactor(D3DVALUE*);
    virtual HRESULT STDMETHODCALLTYPE GetVelocity(D3DVECTOR*);
    virtual HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DLISTENER, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetDistanceFactor(D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetDopplerFactor(D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetOrientation(D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetPosition(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetRolloffFactor(D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetVelocity(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE CommitDeferredSettings(void);
};

// IDirectSound3DBuffer
template <class object_type> class CImpDirectSound3dBuffer
    : public IDirectSound3DBuffer, public IDirectSound3DBufferPrivate, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSound3dBuffer(CUnknown *, object_type *);
    virtual ~CImpDirectSound3dBuffer(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    virtual HRESULT STDMETHODCALLTYPE GetAllParameters(LPDS3DBUFFER);
    virtual HRESULT STDMETHODCALLTYPE GetConeAngles(LPDWORD, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetConeOrientation(D3DVECTOR*);
    virtual HRESULT STDMETHODCALLTYPE GetConeOutsideVolume(LPLONG);
    virtual HRESULT STDMETHODCALLTYPE GetMaxDistance(D3DVALUE*);
    virtual HRESULT STDMETHODCALLTYPE GetMinDistance(D3DVALUE*);
    virtual HRESULT STDMETHODCALLTYPE GetMode(LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetPosition(D3DVECTOR*);
    virtual HRESULT STDMETHODCALLTYPE GetVelocity(D3DVECTOR*);
    virtual HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDS3DBUFFER, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetConeAngles(DWORD, DWORD, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetConeOrientation(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetConeOutsideVolume(LONG, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetMaxDistance(D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetMinDistance(D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetMode(DWORD, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetPosition(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE SetVelocity(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    virtual HRESULT STDMETHODCALLTYPE GetAttenuation(FLOAT*);
};

// IClassFactory
template <class object_type> class CImpClassFactory
    : public IClassFactory, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpClassFactory(CUnknown *, object_type *);
    virtual ~CImpClassFactory(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    virtual HRESULT STDMETHODCALLTYPE CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    virtual HRESULT STDMETHODCALLTYPE LockServer(BOOL);
};

// IDirectSoundNotify
template <class object_type> class CImpDirectSoundNotify
    : public IDirectSoundNotify, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSoundNotify(CUnknown *, object_type *);
    virtual ~CImpDirectSoundNotify(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    virtual HRESULT STDMETHODCALLTYPE SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);
};

// IKsPropertySet
template <class object_type> class CImpKsPropertySet
    : public IKsPropertySet, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpKsPropertySet(CUnknown *, object_type *);
    virtual ~CImpKsPropertySet(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    virtual HRESULT STDMETHODCALLTYPE Get(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG, PULONG);
    virtual HRESULT STDMETHODCALLTYPE Set(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);
    virtual HRESULT STDMETHODCALLTYPE QuerySupport(REFGUID, ULONG, PULONG);
};

// IDirectSoundCapture
template <class object_type> class CImpDirectSoundCapture
    : public IDirectSoundCapture, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSoundCapture(CUnknown *, object_type *);
    virtual ~CImpDirectSoundCapture(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    virtual HRESULT STDMETHODCALLTYPE CreateCaptureBuffer(LPCDSCBUFFERDESC, LPDIRECTSOUNDCAPTUREBUFFER *, LPUNKNOWN);
    virtual HRESULT STDMETHODCALLTYPE GetCaps(LPDSCCAPS);
    virtual HRESULT STDMETHODCALLTYPE Initialize(LPCGUID);
};

// IDirectSoundCaptureBuffer
template <class object_type> class CImpDirectSoundCaptureBuffer
    : public IDirectSoundCaptureBuffer7_1, public IDirectSoundCaptureBuffer8, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSoundCaptureBuffer(CUnknown *, object_type *);
    virtual ~CImpDirectSoundCaptureBuffer(void);

public:
    IMPLEMENT_IUNKNOWN()

public:
    // IDirectSoundCaptureBuffer methods
    virtual HRESULT STDMETHODCALLTYPE GetCaps(LPDSCBCAPS);
    virtual HRESULT STDMETHODCALLTYPE GetCurrentPosition(LPDWORD, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetFormat(LPWAVEFORMATEX, DWORD, LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD);
    virtual HRESULT STDMETHODCALLTYPE Initialize(LPDIRECTSOUNDCAPTURE, LPCDSCBUFFERDESC);
    virtual HRESULT STDMETHODCALLTYPE Lock(DWORD, DWORD, LPVOID FAR *, LPDWORD, LPVOID FAR *, LPDWORD, DWORD);
    virtual HRESULT STDMETHODCALLTYPE Start(DWORD);
    virtual HRESULT STDMETHODCALLTYPE Stop();
    virtual HRESULT STDMETHODCALLTYPE Unlock(LPVOID, DWORD, LPVOID, DWORD);

    // IDirectSoundCaptureBuffer7_1 methods
    virtual HRESULT STDMETHODCALLTYPE SetVolume(LONG);
    virtual HRESULT STDMETHODCALLTYPE GetVolume(LPLONG);
    virtual HRESULT STDMETHODCALLTYPE SetMicVolume(LONG);
    virtual HRESULT STDMETHODCALLTYPE GetMicVolume(LPLONG);
    virtual HRESULT STDMETHODCALLTYPE EnableMic(BOOL);
    virtual HRESULT STDMETHODCALLTYPE YieldFocus(void);
    virtual HRESULT STDMETHODCALLTYPE ClaimFocus(void);
    virtual HRESULT STDMETHODCALLTYPE SetFocusHWND(HWND);
    virtual HRESULT STDMETHODCALLTYPE GetFocusHWND(HWND FAR *);
    virtual HRESULT STDMETHODCALLTYPE EnableFocusNotifications(HANDLE);

    // IDirectSoundCaptureBuffer8 methods
    virtual HRESULT STDMETHODCALLTYPE GetObjectInPath(REFGUID, DWORD, REFGUID, LPVOID *);
    virtual HRESULT STDMETHODCALLTYPE GetFXStatus(DWORD, LPDWORD);
};

// DirectSound sink object
template <class object_type> class CImpDirectSoundSink
    : public IDirectSoundConnect, public IDirectSoundSynthSink, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSoundSink(CUnknown *, object_type *);
    virtual ~CImpDirectSoundSink();

public:
    IMPLEMENT_IUNKNOWN();

public:
    // IDirectSoundConnect methods
    virtual HRESULT STDMETHODCALLTYPE AddSource(IDirectSoundSource *pSource);
    virtual HRESULT STDMETHODCALLTYPE RemoveSource(IDirectSoundSource *pSource);
    virtual HRESULT STDMETHODCALLTYPE SetMasterClock(IReferenceClock *pClock);
    virtual HRESULT STDMETHODCALLTYPE CreateSoundBuffer(LPCDSBUFFERDESC pcDSBufferDesc, LPDWORD pdwFuncID, DWORD dwBusCount, REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppDSBuffer);
    virtual HRESULT STDMETHODCALLTYPE CreateSoundBufferFromConfig(IUnknown *pUnknown, LPDIRECTSOUNDBUFFER *ppDSBuffer);
    virtual HRESULT STDMETHODCALLTYPE GetSoundBuffer(DWORD dwBusId, LPDIRECTSOUNDBUFFER *ppBuffer);
    virtual HRESULT STDMETHODCALLTYPE GetBusCount(DWORD *pdwCount);
    virtual HRESULT STDMETHODCALLTYPE GetBusIDs(DWORD *pdwBusIDs, DWORD *pdwFuncIDs, DWORD dwBusCount);
    virtual HRESULT STDMETHODCALLTYPE GetFunctionalID(DWORD dwBusID, LPDWORD pdwFuncID);
    virtual HRESULT STDMETHODCALLTYPE GetSoundBufferBusIDs(LPDIRECTSOUNDBUFFER pBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount);

    // IDirectSoundSynthSink methods
    virtual HRESULT STDMETHODCALLTYPE GetLatencyClock(IReferenceClock **ppClock);
    virtual HRESULT STDMETHODCALLTYPE Activate(BOOL fEnable);
    virtual HRESULT STDMETHODCALLTYPE SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prt);
    virtual HRESULT STDMETHODCALLTYPE RefToSampleTime(REFERENCE_TIME rt, LONGLONG *pllSampleTime);
    virtual HRESULT STDMETHODCALLTYPE GetFormat(LPWAVEFORMATEX, DWORD, LPDWORD);
};

// IPersistStream
template <class object_type> class CImpPersistStream
    : public IPersistStream, public CImpUnknown  // FIXME: should derive from IPersist too?
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpPersistStream(CUnknown *, object_type *);
    virtual ~CImpPersistStream();

public:
    IMPLEMENT_IUNKNOWN();

public:
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClassID);
    virtual HRESULT STDMETHODCALLTYPE IsDirty();
    virtual HRESULT STDMETHODCALLTYPE Load(IStream *pStream);
    virtual HRESULT STDMETHODCALLTYPE Save(IStream *pStream, BOOL fClearDirty);
    virtual HRESULT STDMETHODCALLTYPE GetSizeMax(ULARGE_INTEGER* pcbSize);
};

// IDirectMusicObject
template <class object_type> class CImpDirectMusicObject
    : public IDirectMusicObject, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectMusicObject(CUnknown *, object_type *);
    virtual ~CImpDirectMusicObject();

public:
    IMPLEMENT_IUNKNOWN();

public:
    virtual HRESULT STDMETHODCALLTYPE GetDescriptor(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT STDMETHODCALLTYPE SetDescriptor(LPDMUS_OBJECTDESC pDesc);
    virtual HRESULT STDMETHODCALLTYPE ParseDescriptor(LPSTREAM pStream, LPDMUS_OBJECTDESC pDesc);
};


// IDirectSoundFullDuplex
template <class object_type> class CImpDirectSoundFullDuplex
    : public IDirectSoundFullDuplex, public CImpUnknown
{
public:
    INTERFACE_SIGNATURE         m_signature;
    object_type *               m_pObject;

public:
    CImpDirectSoundFullDuplex(CUnknown *, object_type *);
    virtual ~CImpDirectSoundFullDuplex(void);

public:
    // IDirectSoundFullDuplex methods
    virtual HRESULT STDMETHODCALLTYPE Initialize(LPCGUID, LPCGUID, LPCDSCBUFFERDESC, LPCDSBUFFERDESC, HWND, DWORD, LPLPDIRECTSOUNDCAPTUREBUFFER8, LPLPDIRECTSOUNDBUFFER8);

public:
    inline virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID FAR *ppv)
    {
        return CImpUnknown::QueryInterface(riid, ppv);
    }

    inline virtual ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return CImpUnknown::AddRef();
    }

    inline virtual ULONG STDMETHODCALLTYPE Release(void)
    {
        return CImpUnknown::Release();
    }
};

// Helper functions
template <class interface_type, class object_type> HRESULT CreateAndRegisterInterface(CUnknown *, REFGUID, object_type *, interface_type **);

#endif // __cplusplus

#endif // __DSIMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsimp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsimp.cpp
 *  Content:    DirectSound interface implementations.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *  1999-2001   duganp  Changed, updated, expanded, tidied up
 *
 ***************************************************************************/


/***************************************************************************
 *
 *  CreateAndRegisterInterface
 *
 *  Description:
 *      Creates and registers a new interface with the object.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      REFGUID [in]: GUID of the interface.
 *      object_type * [in]: owning object pointer.
 *      interface_type * [in]: interface implementation object pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CUnknown::CreateAndRegisterInterface"

template <class interface_type, class object_type> HRESULT CreateAndRegisterInterface(CUnknown *pUnknown, REFGUID guid, object_type *pObject, interface_type **ppInterface)
{
    interface_type *        pInterface;
    HRESULT                 hr;

    DPF_ENTER();

    pInterface = NEW(interface_type(pUnknown, pObject));
    hr = HRFROMP(pInterface);

    if(SUCCEEDED(hr))
    {
        hr = pUnknown->RegisterInterface(guid, pInterface, pInterface);
    }

    if(SUCCEEDED(hr))
    {
        *ppInterface = pInterface;
    }
    else
    {
        DELETE(pInterface);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSound
 *
 *  Description:
 *      IDirectSound implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::CImpDirectSound"

template <class object_type> CImpDirectSound<object_type>::CImpDirectSound(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUND)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSound);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSound
 *
 *  Description:
 *      IDirectSound implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::~CImpDirectSound"

template <class object_type> CImpDirectSound<object_type>::~CImpDirectSound(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSound);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  CreateSoundBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSoundBuffer object.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: description of the buffer to be created.
 *      LPDIRECTSOUNDBUFFER * [out]: receives a pointer to the new buffer.
 *      LPUNKNOWN [in]: unused.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::CreateSoundBuffer"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::CreateSoundBuffer(LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter)
{
    CDirectSoundBuffer *    pBuffer     = NULL;
    HRESULT                 hr          = DS_OK;
    DSBUFFERDESC            dsbdi;

    DPF_API3(IDirectSound::CreateSoundBuffer, pcDSBufferDesc, ppDSBuffer, pUnkOuter);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSBUFFERDESC(pcDSBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer description pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDsBufferDesc(pcDSBufferDesc, &dsbdi, m_pObject->GetDsVersion(), FALSE);
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid buffer description");
        }
    }

    if(SUCCEEDED(hr) && (pcDSBufferDesc->dwFlags & DSBCAPS_MIXIN))
    {
        RPF(DPFLVL_ERROR, "Flag 0x00002000 not valid");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppDSBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer interface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // Create the buffer object
    if(SUCCEEDED(hr))
    {
        *ppDSBuffer = NULL;
        hr = m_pObject->CreateSoundBuffer(&dsbdi, &pBuffer);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer, TRUE, (LPVOID*)ppDSBuffer);
    }

    // Clean up
    if(FAILED(hr))
    {
        RELEASE(pBuffer);
    }
    else
    {
        // Let the buffer use a special successful return code if it wants to
        hr = pBuffer->SpecialSuccessCode();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCAPS structure with the capabilities of the object.
 *
 *  Arguments:
 *      LPDSCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::GetCaps"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::GetCaps(LPDSCAPS pCaps)
{
    HRESULT                 hr  = DS_OK;

    DPF_API1(IDirectSound::GetCaps, pCaps);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_DSCAPS(pCaps))
    {
        RPF(DPFLVL_ERROR, "Invalid caps buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetCaps(pCaps);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  DuplicateSoundBuffer
 *
 *  Description:
 *      Makes a copy of an existing sound buffer object.
 *
 *  Arguments:
 *      LPDIRECTSOUNDBUFFER [in]: source buffer.
 *      LPDIRECTSOUNDBUFFER * [out]: receives destination buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::DuplicateSoundBuffer"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::DuplicateSoundBuffer(LPDIRECTSOUNDBUFFER pIdsbSource, LPDIRECTSOUNDBUFFER *ppIdsbDest)
{
    CImpDirectSoundBuffer<CDirectSoundBuffer> * pSource = (CImpDirectSoundBuffer<CDirectSoundBuffer> *)pIdsbSource;
    CDirectSoundBuffer *                        pDest   = NULL;
    HRESULT                                     hr      = DS_OK;

    DPF_API2(IDirectSound::DuplicateSoundBuffer, pIdsbSource, ppIdsbDest);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_IDIRECTSOUNDBUFFER(pSource))
    {
        RPF(DPFLVL_ERROR, "Invalid source buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = pSource->m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Source buffer not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_TYPED_WRITE_PTR(ppIdsbDest))
        {
            *ppIdsbDest = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid dest buffer");
            hr = DSERR_INVALIDPARAM;
        }
    }

    // Duplicate the buffer
    if(SUCCEEDED(hr))
    {
        hr = m_pObject->DuplicateSoundBuffer(pSource->m_pObject, &pDest);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pDest->QueryInterface(IID_IDirectSoundBuffer, TRUE, (LPVOID*)ppIdsbDest);
    }

    // Clean up
    if(FAILED(hr))
    {
        RELEASE(pDest);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetCooperativeLevel
 *
 *  Description:
 *      Sets the object's cooperative level.
 *
 *  Arguments:
 *      HWND [in]: window handle to associate sounds with.
 *      DWORD [in]: cooperative level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::SetCooperativeLevel"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::SetCooperativeLevel(HWND hWnd, DWORD dwPriority)
{
    HRESULT                 hr  = DS_OK;

    DPF_API2(IDirectSound::SetCooperativeLevel, hWnd, dwPriority);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_HWND(hWnd))
    {
        RPF(DPFLVL_ERROR, "Invalid window handle");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwPriority < DSSCL_FIRST || dwPriority > DSSCL_LAST))
    {
        RPF(DPFLVL_ERROR, "Invalid cooperative level");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetCooperativeLevel(GetWindowThreadProcessId(GetRootParentWindow(hWnd), NULL), dwPriority);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Compact
 *
 *  Description:
 *      Compacts memory.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::Compact"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::Compact(void)
{
    HRESULT                     hr  = DS_OK;

    DPF_API0(IDirectSound::Compact);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Compact();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetSpeakerConfig
 *
 *  Description:
 *      Retrieves the current speaker configuration.
 *
 *  Arguments:
 *      LPDWORD [out]: receives speaker config.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::GetSpeakerConfig"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::GetSpeakerConfig(LPDWORD pdwSpeakerConfig)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound::GetSpeakerConfig, pdwSpeakerConfig);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwSpeakerConfig))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwSpeakerConfig pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetSpeakerConfig(pdwSpeakerConfig);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetSpeakerConfig
 *
 *  Description:
 *      Sets the current speaker configuration.
 *
 *  Arguments:
 *      DWORD [in]: speaker config.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::SetSpeakerConfig"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::SetSpeakerConfig(DWORD dwSpeakerConfig)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound::SetSpeakerConfig, dwSpeakerConfig);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && dwSpeakerConfig & ~(DSSPEAKER_CONFIG_MASK | DSSPEAKER_GEOMETRY_MASK))
    {
        RPF(DPFLVL_ERROR, "Invalid dwSpeakerConfig value");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (DSSPEAKER_CONFIG(dwSpeakerConfig) < DSSPEAKER_FIRST || DSSPEAKER_CONFIG(dwSpeakerConfig) > DSSPEAKER_LAST))
    {
        RPF(DPFLVL_ERROR, "Invalid dwSpeakerConfig value");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && DSSPEAKER_STEREO != DSSPEAKER_CONFIG(dwSpeakerConfig) && DSSPEAKER_GEOMETRY(dwSpeakerConfig))
    {
        RPF(DPFLVL_ERROR, "Geometry only valid with STEREO");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && DSSPEAKER_GEOMETRY(dwSpeakerConfig) && (DSSPEAKER_GEOMETRY(dwSpeakerConfig) < DSSPEAKER_GEOMETRY_MIN || DSSPEAKER_GEOMETRY(dwSpeakerConfig) > DSSPEAKER_GEOMETRY_MAX))
    {
        RPF(DPFLVL_ERROR, "Invalid geometry value");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetSpeakerConfig(dwSpeakerConfig);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPGUID [in]: driver GUID.  This parameter may be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::Initialize"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::Initialize(LPCGUID pGuid)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound::Initialize, pGuid);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pGuid && !IS_VALID_READ_GUID(pGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DS_OK == hr)
        {
            RPF(DPFLVL_ERROR, "DirectSound object already initialized");
            hr = DSERR_ALREADYINITIALIZED;
        }
        else if(DSERR_UNINITIALIZED == hr)
        {
            hr = DS_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Initialize(pGuid, NULL);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(SUCCEEDED(m_pObject->IsInit()));
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  AllocSink
 *
 *  Description:
 *      Allocate a new DirectSound sink.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: The format the sink will run in
 *      LPDIRECTSOUNDSINK * [out]: The returned sink
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::AllocSink"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::AllocSink(LPWAVEFORMATEX pwfex, LPDIRECTSOUNDCONNECT *ppSinkConnect)
{
    HRESULT             hr    = DS_OK;
    CDirectSoundSink *  pSink = NULL;

    DPF_API2(IDirectSoundPrivate::AllocSink, pwfex, ppSinkConnect);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    // Only DX8 apps should be able to obtain the IDirectSoundPrivate interface.
    ASSERT(m_pObject->GetDsVersion() >= DSVERSION_DX8);

    if(SUCCEEDED(hr) && !IS_VALID_READ_WAVEFORMATEX(pwfex))
    {
        RPF(DPFLVL_ERROR, "Invalid wave format pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // Currently the only supported format is 16-bit mono PCM
    if(SUCCEEDED(hr) && !IsValidWfx(pwfex))
    {
        RPF(DPFLVL_ERROR, "Invalid sink wave format");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (pwfex->nChannels != 1 || pwfex->wBitsPerSample != 16))
    {
        RPF(DPFLVL_ERROR, "Sink wave format must be 16 bit mono");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppSinkConnect))
    {
        RPF(DPFLVL_ERROR, "Invalid IDirectSoundConnect interface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->AllocSink(pwfex, &pSink);
    }

    if(SUCCEEDED(hr))
    {
        hr = pSink->QueryInterface(IID_IDirectSoundConnect, TRUE, (void**)ppSinkConnect);
    }

    if(FAILED(hr))
    {
        RELEASE(pSink);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  VerifyCertification
 *
 *  Description:
 *      Verify driver is certified.
 *
 *  Arguments:
 *      LPDWORD [out]: The value DS_CERTIFIED or DS_UNCERTIFIED
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::VerifyCertification"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::VerifyCertification(LPDWORD lpdwCertified)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSound8::VerifyCertification, lpdwCertified);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(lpdwCertified))
    {
        RPF(DPFLVL_ERROR, "Invalid certification flag pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->VerifyCertification(lpdwCertified);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


#ifdef FUTURE_WAVE_SUPPORT
/***************************************************************************
 *
 *  CreateSoundBufferFromWave
 *
 *  Description:
 *      Create a buffer from an IDirectSoundWave object.
 *
 *  Arguments:
 *      LPUNKNOWN [in]: IUnknown interface of wave object.
 *      DWORD [in]: Buffer creation flags.
 *      LPDIRECTSOUNDBUFFER * [out]: receives destination buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound::CreateSoundBufferFromWave"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound<object_type>::CreateSoundBufferFromWave(IUnknown *pUnkWave, DWORD dwFlags, LPDIRECTSOUNDBUFFER *ppDSBuffer)
{
    HRESULT  hr;
    CDirectSoundBuffer *    pBuffer     = NULL;
    IDirectSoundWave *      pDSWave     = (IDirectSoundWave*)pUnkWave;
    LPWAVEFORMATEX          pwfxFormat;
    DWORD                   dwWfxSize;

    DPF_API3(IDirectSound8::CreateSoundBufferFromWave, pUnkWave, dwFlags, ppDSBuffer);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_EXTERNAL_INTERFACE(pDSWave))
    {
        RPF(DPFLVL_ERROR, "Invalid pDSWave pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IsValidDsBufferFlags(dwFlags, DSBCAPS_FROMWAVEVALIDFLAGS))
    {
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppDSBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer interface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        *ppDSBuffer = NULL;

        hr = pDSWave->GetFormat(NULL, 0, &dwWfxSize);
        if(SUCCEEDED(hr))
        {
            pwfxFormat = LPWAVEFORMATEX(MEMALLOC_A(BYTE, dwWfxSize));
            hr = HRFROMP(pwfxFormat);
        }

        if(SUCCEEDED(hr))
        {
            hr = pDSWave->GetFormat(pwfxFormat, dwWfxSize, NULL);
        }

        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Could not obtain wave format");
        }
        else if(!IsValidWfx(pwfxFormat))
        {
            RPF(DPFLVL_ERROR, "Invalid wave format");
            hr = DSERR_INVALIDPARAM;
        }
    }

    // Create the buffer object
    if(SUCCEEDED(hr))
    {
        hr = m_pObject->CreateSoundBufferFromWave(pDSWave, dwFlags, &pBuffer);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer, TRUE, (LPVOID*)ppDSBuffer);
    }

    // Clean up
    if(FAILED(hr))
    {
        RELEASE(pBuffer);
    }
    else
    {
        // Let the buffer use a special successful return code if it wants to
        hr = pBuffer->SpecialSuccessCode();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}
#endif // FUTURE_WAVE_SUPPORT


/***************************************************************************
 *
 *  CImpDirectSoundBuffer
 *
 *  Description:
 *      IDirectSoundBuffer implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::CImpDirectSoundBuffer"

template <class object_type> CImpDirectSoundBuffer<object_type>::CImpDirectSoundBuffer(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUNDBUFFER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSoundBuffer);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSoundBuffer
 *
 *  Description:
 *      IDirectSoundBuffer implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::~CImpDirectSoundBuffer"

template <class object_type> CImpDirectSoundBuffer<object_type>::~CImpDirectSoundBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSoundBuffer);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSBCAPS structure with the capabilities of the buffer.
 *
 *  Arguments:
 *      LPDSBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetCaps"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetCaps(LPDSBCAPS pCaps)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::GetCaps, pCaps);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_DSBCAPS(pCaps))
    {
        RPF(DPFLVL_ERROR, "Invalid caps pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetCaps(pCaps);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives play cursor position.
 *      LPDWORD [out]: receives write cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetCurrentPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetCurrentPosition(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    HRESULT                     hr  = DS_OK;

    DPF(DPFLVL_BUSYAPI, "IDirectSoundBuffer::GetCurrentPosition: pdwPlay=0x%p, pdwWrite=0x%p", pdwPlay, pdwWrite);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && pdwPlay && !IS_VALID_TYPED_WRITE_PTR(pdwPlay))
    {
        RPF(DPFLVL_ERROR, "Invalid play cursor pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwWrite && !IS_VALID_TYPED_WRITE_PTR(pdwWrite))
    {
        RPF(DPFLVL_ERROR, "Invalid write cursor pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pdwPlay && !pdwWrite)
    {
        RPF(DPFLVL_ERROR, "Both cursor pointers can't be NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetCurrentPosition(pdwPlay, pdwWrite);
    }

    DPF(DPFLVL_BUSYAPI, "IDirectSoundBuffer::GetCurrentPosition: Leave, returning %s (Play=%ld, Write=%ld)", HRESULTtoSTRING(hr), pdwPlay ? *pdwPlay: -1, pdwWrite ? *pdwWrite : -1);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Retrieves the format for the given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives the format.
 *      DWORD [in]: size of the above structure.
 *      LPDWORD [in/out]: On exit, this will be filled with the size that
 *                        was required.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetFormat"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSoundBuffer::GetFormat, pwfxFormat, dwSizeAllocated, pdwSizeWritten);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && pwfxFormat && !IS_VALID_WRITE_WAVEFORMATEX(pwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Invalid format buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwSizeWritten && !IS_VALID_TYPED_WRITE_PTR(pdwSizeWritten))
    {
        RPF(DPFLVL_ERROR, "Invalid size pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pwfxFormat && !pdwSizeWritten)
    {
        RPF(DPFLVL_ERROR, "Either pwfxFormat or pdwSizeWritten must be non-NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        if(!pwfxFormat)
        {
            dwSizeAllocated = 0;
        }

        hr = m_pObject->GetFormat(pwfxFormat, &dwSizeAllocated);

        if(SUCCEEDED(hr) && pdwSizeWritten)
        {
            *pdwSizeWritten = dwSizeAllocated;
        }
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetVolume
 *
 *  Description:
 *      Retrieves volume for the given buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetVolume(LPLONG plVolume)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::GetVolume, plVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(plVolume))
    {
        RPF(DPFLVL_ERROR, "Invalid volume pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetVolume(plVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetPan
 *
 *  Description:
 *      Retrieves pan for the given buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetPan"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetPan(LPLONG plPan)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::GetPan, plPan);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(plPan))
    {
        RPF(DPFLVL_ERROR, "Invalid pan pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetPan(plPan);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetFrequency
 *
 *  Description:
 *      Retrieves frequency for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetFrequency"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetFrequency(LPDWORD pdwFrequency)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::GetFrequency, pdwFrequency);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwFrequency))
    {
        RPF(DPFLVL_ERROR, "Invalid frequency buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetFrequency(pdwFrequency);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Retrieves status for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the status.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetStatus"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetStatus(LPDWORD pdwStatus)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::GetStatus, pdwStatus);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwStatus))
    {
        RPF(DPFLVL_ERROR, "Invalid status pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetStatus(pdwStatus);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes a buffer object.
 *
 *  Arguments:
 *      LPDIRECTSOUND [in]: parent DirectSound object.
 *      LPDSBUFFERDESC [in]: buffer description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::Initialize"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::Initialize(LPDIRECTSOUND pIds, LPCDSBUFFERDESC pcDSBufferDesc)
{
    CImpDirectSound<CDirectSound> * pImpDirectSound = (CImpDirectSound<CDirectSound> *)pIds;
    HRESULT                         hr              = DS_OK;
    DSBUFFERDESC                    dsbdi;

    DPF_API2(IDirectSoundBuffer::Initialize, pIds, pcDSBufferDesc);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_IDIRECTSOUND(pImpDirectSound))
    {
        RPF(DPFLVL_ERROR, "Invalid parent interface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSBUFFERDESC(pcDSBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid pcDSBufferDesc pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDsBufferDesc(pcDSBufferDesc, &dsbdi, m_pObject->GetDsVersion(), FALSE);
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid buffer description");
        }
    }

    // It's never valid to call this function.  We don't support
    // creating a DirectSoundBuffer object from anywhere but
    // IDirectSound::CreateSoundBuffer.
    if(SUCCEEDED(hr))
    {
        RPF(DPFLVL_ERROR, "DirectSound buffer already initialized");
        hr = DSERR_ALREADYINITIALIZED;
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks the buffer memory to allow for writing.
 *
 *  Arguments:
 *      DWORD [in]: offset, in bytes, from the start of the buffer to where
 *                  the lock begins. This parameter is ignored if
 *                  DSBLOCK_FROMWRITECURSOR is specified in the dwFlags
 *                  parameter.
 *      DWORD [in]: size, in bytes, of the portion of the buffer to lock.
 *                  Note that the sound buffer is conceptually circular.
 *      LPVOID * [out]: address for a pointer to contain the first block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr1 parameter. If this
 *                     value is less than the dwWriteBytes parameter,
 *                     lplpvAudioPtr2 will point to a second block of sound
 *                     data.
 *      LPVOID * [out]: address for a pointer to contain the second block of
 *                      the sound buffer to be locked. If the value of this
 *                      parameter is NULL, the lplpvAudioPtr1 parameter
 *                      points to the entire locked portion of the sound
 *                      buffer.
 *      LPDWORD [out]: address of a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr2 parameter. If
 *                     lplpvAudioPtr2 is NULL, this value will be 0.
 *      DWORD [in]: flags modifying the lock event.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::Lock"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::Lock(DWORD dwWriteCursor, DWORD dwWriteBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
{
    HRESULT                     hr              = DS_OK;

    DPF(DPFLVL_BUSYAPI, "IDirectSoundBuffer::Lock: WriteCursor=%lu, WriteBytes=%lu, Flags=0x%lX", dwWriteCursor, dwWriteBytes, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_TYPED_WRITE_PTR(ppvAudioPtr1))
        {
            *ppvAudioPtr1 = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid audio ptr 1");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_TYPED_WRITE_PTR(pdwAudioBytes1))
        {
            *pdwAudioBytes1 = 0;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid audio bytes 1");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && ppvAudioPtr2)
    {
        if(IS_VALID_TYPED_WRITE_PTR(ppvAudioPtr2))
        {
            *ppvAudioPtr2 = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid audio ptr 2");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && pdwAudioBytes2)
    {
        if(IS_VALID_TYPED_WRITE_PTR(pdwAudioBytes2))
        {
            *pdwAudioBytes2 = 0;
        }
        else if(ppvAudioPtr2)
        {
            RPF(DPFLVL_ERROR, "Invalid audio bytes 2");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DSBLOCK_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Lock(dwWriteCursor, dwWriteBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2, dwFlags);
    }

    DPF(DPFLVL_BUSYAPI, "IDirectSoundBuffer::Lock: Leave, returning %s (AudioPtr1=0x%p, AudioBytes1=%lu, AudioPtr2=0x%p, AudioBytes2=%lu)",
        HRESULTtoSTRING(hr),
        ppvAudioPtr1 ? *ppvAudioPtr1 : NULL,
        pdwAudioBytes1 ? *pdwAudioBytes1 : NULL,
        ppvAudioPtr2 ? *ppvAudioPtr2 : NULL,
        pdwAudioBytes2 ? *pdwAudioBytes2 : NULL);

    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Play
 *
 *  Description:
 *      Starts the buffer playing.
 *
 *  Arguments:
 *      DWORD [in]: reserved.  Must be 0.
 *      DWORD [in]: priority.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::Play"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::Play(DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSoundBuffer::Play, dwReserved1, dwPriority, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && dwReserved1)
    {
        RPF(DPFLVL_ERROR, "Reserved argument(s) are not zero");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DSBPLAY_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwFlags & DSBPLAY_TERMINATEBY_TIME) && (dwFlags & DSBPLAY_TERMINATEBY_DISTANCE))
    {
        RPF(DPFLVL_ERROR, "Cannot use DSBPLAY_TERMINATEBY_TIME and DSBPLAY_TERMINATEBY_DISTANCE simultaneously");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Play(dwPriority, dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        // Let the buffer use a special successful return code if it wants to
        hr = m_pObject->SpecialSuccessCode();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetCurrentPosition
 *
 *  Description:
 *      Sets the current play position for a given buffer.
 *
 *  Arguments:
 *      DWORD [in]: new play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetCurrentPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetCurrentPosition(DWORD dwPlayCursor)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::SetCurrentPosition, dwPlayCursor);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetCurrentPosition(dwPlayCursor);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the format for a given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: new format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetFormat"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetFormat(LPCWAVEFORMATEX pwfxFormat)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::SetFormat, pwfxFormat);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_WAVEFORMATEX(pwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Invalid format pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IsValidWfx(pwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Invalid format");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetFormat(pwfxFormat);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the volume for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetVolume(LONG lVolume)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::SetVolume, lVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX))
    {
        RPF(DPFLVL_ERROR, "Volume out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetVolume(lVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetPan
 *
 *  Description:
 *      Sets the pan for a given buffer.
 *
 *  Arguments:
 *      LONG [in]: new pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetPan"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetPan(LONG lPan)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::SetPan, lPan);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (lPan < DSBPAN_LEFT || lPan > DSBPAN_RIGHT))
    {
        RPF(DPFLVL_ERROR, "Pan out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetPan(lPan);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the pan for a given buffer.
 *
 *  Arguments:
 *      DWORD [in]: new frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetFrequency"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetFrequency(DWORD dwFrequency)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundBuffer::SetFrequency, dwFrequency);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (dwFrequency != DSBFREQUENCY_ORIGINAL && (dwFrequency < DSBFREQUENCY_MIN || dwFrequency > DSBFREQUENCY_MAX)))
    {
        RPF(DPFLVL_ERROR, "Frequency out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetFrequency(dwFrequency);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops playing the given buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::Stop"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::Stop(void)
{
    HRESULT                     hr  = DS_OK;

    DPF_API0(IDirectSoundBuffer::Stop);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Stop();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks the given buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::Unlock"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::Unlock(LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2)
{
    HRESULT                     hr  = DS_OK;

    DPF(DPFLVL_BUSYAPI, "IDirectSoundBuffer::Unlock: AudioPtr1=0x%p, AudioBytes1=%lu, AudioPtr2=0x%p, AudioBytes2=%lu",
        pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pvAudioPtr1, dwAudioBytes1))
    {
        RPF(DPFLVL_ERROR, "Invalid audio ptr 1");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && dwAudioBytes2 && !IS_VALID_READ_PTR(pvAudioPtr2, dwAudioBytes2))
    {
        RPF(DPFLVL_ERROR, "Invalid audio ptr 2");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Unlock(pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
    }

    DPF(DPFLVL_BUSYAPI, "IDirectSoundBuffer::Unlock: Leave, returning %s", HRESULTtoSTRING(hr));
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Restore
 *
 *  Description:
 *      Restores a lost buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::Restore"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::Restore(void)
{
    HRESULT                     hr  = DS_OK;

    DPF_API0(IDirectSoundBuffer::Restore);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Restore();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetFX
 *
 *  Description:
 *      Sets a chain of effects on this buffer, replacing any previous
 *      effect chain and, if necessary, allocating or deallocating the
 *      shadow buffer used to hold unprocessed audio .
 *
 *  Arguments:
 *      DWORD [in]: Number of effects.  0 to remove current FX chain.
 *      DSEFFECTDESC * [in]: Array of effect descriptor structures.
 *      DWORD * [out]: Receives the creation statuses of the effects.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetFX"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetFX(DWORD dwFxCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes)
{
    HRESULT hr = DS_OK;

    DPF_API3(IDirectSoundBuffer8::SetFX, dwFxCount, pDSFXDesc, pdwResultCodes);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (dwFxCount == 0) != (pDSFXDesc == NULL))
    {
        RPF(DPFLVL_ERROR, "Inconsistent dwFxCount and pDSFXDesc parameters");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwFxCount == 0) && (pdwResultCodes != NULL))
    {
        RPF(DPFLVL_ERROR, "If dwFxCount is 0, pdwResultCodes must be NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pDSFXDesc, dwFxCount * sizeof *pDSFXDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid pDSFXDesc pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwResultCodes && !IS_VALID_WRITE_PTR(pdwResultCodes, dwFxCount * sizeof *pdwResultCodes))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwResultCodes pointer");
        hr = DSERR_INVALIDPARAM;
    }

    for(DWORD i=0; SUCCEEDED(hr) && i<dwFxCount; ++i)
    {
        // This is ugly, but we know the <CDirectSoundPrimaryBuffer> instantiation
        // of this template doesn't get linked in, so we can cast safely here...
        if(!IsValidEffectDesc(pDSFXDesc+i, (CDirectSoundSecondaryBuffer*)m_pObject))
        {
            RPF(DPFLVL_ERROR, "Invalid DSEFFECTDESC structure #%d", i);
            hr = DSERR_INVALIDPARAM;
        }
        else if(pDSFXDesc[i].dwReserved1 != 0)
        {
            RPF(DPFLVL_ERROR, "Reserved fields in the DSEFFECTDESC structure must be 0");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetFX(dwFxCount, pDSFXDesc, pdwResultCodes);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  AcquireResources
 *
 *  Description:
 *      Acquire resources for this buffer and report on effect status.
 *
 *  Arguments:
 *      DWORD [in]: Flags to control resource acquisition.
 *      DWORD [in]: Number of FX currently present on this buffer
 *      LPDWORD [out]: Array of effect status codes.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::AcquireResources"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::AcquireResources(DWORD dwFlags, DWORD dwFxCount, LPDWORD pdwResultCodes)
{
    HRESULT hr = DS_OK;

    DPF_API3(IDirectSoundBuffer8::AcquireResources, dwFlags, dwFxCount, pdwResultCodes);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DSBPLAY_LOCDEFERMASK))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwFlags & DSBPLAY_TERMINATEBY_TIME) && (dwFlags & DSBPLAY_TERMINATEBY_DISTANCE))
    {
        RPF(DPFLVL_ERROR, "Cannot use DSBPLAY_TERMINATEBY_TIME and DSBPLAY_TERMINATEBY_DISTANCE simultaneously");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwFxCount == 0) && (pdwResultCodes != NULL))
    {
        RPF(DPFLVL_ERROR, "If the dwFxCount argument is 0, pdwResultCodes must be NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwFxCount != 0) && (!IS_VALID_WRITE_PTR(pdwResultCodes, dwFxCount * sizeof(DWORD))))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwResultCodes pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->UserAcquireResources(dwFlags, dwFxCount, pdwResultCodes);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetObjectInPath
 *
 *  Description:
 *      Obtains a given interface on a given effect on this buffer.
 *
 *  Arguments:
 *      REFGUID [in]: Class ID of the effect that is being searched for,
 *                    or GUID_ALL_OBJECTS to search for any effect.
 *      DWORD [in]: Index of the effect, in case there is more than one
 *                  effect with this CLSID on this buffer.
 *      REFGUID [in]: IID of the interface requested.  The selected effect
 *                    will be queried for this interface.
 *      LPVOID * [out]: Receives the interface requested.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::GetObjectInPath"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::GetObjectInPath(REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID *ppObject)
{
    HRESULT hr = DS_OK;

    DPF_API4(IDirectSoundBuffer8::GetObjectInPath, &guidObject, dwIndex, &iidInterface, ppObject);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&guidObject))
    {
        RPF(DPFLVL_ERROR, "Invalid guidObject pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&iidInterface))
    {
        RPF(DPFLVL_ERROR, "Invalid iidInterface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppObject))
    {
        RPF(DPFLVL_ERROR, "Invalid ppObject pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetObjectInPath(guidObject, dwIndex, iidInterface, ppObject);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


#ifdef FUTURE_MULTIPAN_SUPPORT
/***************************************************************************
 *
 *  SetChannelVolume
 *
 *  Description:
 *      Sets the volume on a set of output channels for a given mono buffer.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundBuffer::SetChannelVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundBuffer<object_type>::SetChannelVolume(DWORD dwChannelCount, LPDWORD pdwChannels, LPLONG plVolumes)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSoundBuffer::SetChannelVolume, dwChannelCount, pdwChannels, plVolumes);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (dwChannelCount < 1 || dwChannelCount > 64))
    {
        RPF(DPFLVL_ERROR, "dwChannelCount out of bounds (1 to 64)");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pdwChannels, dwChannelCount * sizeof(DWORD)))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwChannels pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(plVolumes, dwChannelCount * sizeof(LONG)))
    {
        RPF(DPFLVL_ERROR, "Invalid plVolumes pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        DWORD dwChannelsSoFar = 0;
        for(DWORD i=0; i<dwChannelCount && SUCCEEDED(hr); ++i)
        {
            // The channel position must have exactly one bit set, other than the top bit (SPEAKER_ALL)
            if(!pdwChannels[i] || (pdwChannels[i] & (pdwChannels[i]-1)) || pdwChannels[i] == SPEAKER_ALL)
            {
                RPF(DPFLVL_ERROR, "Channel %d invalid", i);
                hr = DSERR_INVALIDPARAM;
            }
            if(dwChannelsSoFar & pdwChannels[i])
            {
                RPF(DPFLVL_ERROR, "Repeated channel position in pdwChannels");
                hr = DSERR_INVALIDPARAM;
            }
            else
            {
                dwChannelsSoFar |= pdwChannels[i];
            }
            if(plVolumes[i] < DSBVOLUME_MIN || plVolumes[i] > DSBVOLUME_MAX)
            {
                RPF(DPFLVL_ERROR, "Volume %d out of bounds", i);
                hr = DSERR_INVALIDPARAM;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetChannelVolume(dwChannelCount, pdwChannels, plVolumes);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}
#endif // FUTURE_MULTIPAN_SUPPORT


/***************************************************************************
 *
 *  CImpClassFactory
 *
 *  Description:
 *      IClassFactory implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpClassFactory::CImpClassFactory"

template <class object_type> CImpClassFactory<object_type>::CImpClassFactory(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_ICLASSFACTORY)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpClassFactory);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpClassFactory
 *
 *  Description:
 *      IClassFactory implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpClassFactory::~CImpClassFactory"

template <class object_type> CImpClassFactory<object_type>::~CImpClassFactory(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpClassFactory);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  CreateInstance
 *
 *  Description:
 *      Creates an instance of an object supported by this class factory.
 *
 *  Arguments:
 *      LPUNKNOWN [in]: controlling unknown.
 *      REFIID [in]: interface ID.
 *      LPVOID * [out]: receives requested interface.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpClassFactory::CreateInstance"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpClassFactory<object_type>::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID* ppvInterface)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IClassFactory::CreateInstance, pUnkOuter, &riid, ppvInterface);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_ICLASSFACTORY(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation not supported");
        hr = DSERR_NOAGGREGATION;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&riid))
    {
        RPF(DPFLVL_ERROR, "Invalid interface ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_TYPED_WRITE_PTR(ppvInterface))
        {
            *ppvInterface = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid interface buffer");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->CreateInstance(riid, ppvInterface);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  LockServer
 *
 *  Description:
 *      Increases or decreases the lock count on the dll.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to lock the server, FALSE to unlock it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpClassFactory::LockServer"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpClassFactory<object_type>::LockServer(BOOL fLock)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IClassFactory::LockServer, fLock);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_ICLASSFACTORY(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->LockServer(fLock);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSound3dBuffer
 *
 *  Description:
 *      IDirectSound3dBuffer implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::CImpDirectSound3dBuffer"

template <class object_type> CImpDirectSound3dBuffer<object_type>::CImpDirectSound3dBuffer(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUND3DBUFFER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSound3dBuffer);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CDirectSound3dBuffer
 *
 *  Description:
 *      IDirectSound3dBuffer implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::~CDirectSound3dBuffer"

template <class object_type> CImpDirectSound3dBuffer<object_type>::~CImpDirectSound3dBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSound3dBuffer);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  GetAllParameters
 *
 *  Description:
 *      Retrieves all 3D properties for the buffer.
 *
 *  Arguments:
 *      LPDS3DBUFFER [out]: recieves properties.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetAllParameters"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetAllParameters(LPDS3DBUFFER pParam)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetAllParameters, pParam);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_DS3DBUFFER(pParam))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetAllParameters(pParam);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetConeAngles
 *
 *  Description:
 *      Gets inside and outside cone angles.
 *
 *  Arguments:
 *      LPDWORD [out]: receives inside cone angle.
 *      LPDWORD [out]: receives outside cone angle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetConeAngles"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetConeAngles(LPDWORD pdwInside, LPDWORD pdwOutside)
{
    HRESULT hr  = DS_OK;

    DPF_API2(IDirectSound3DBuffer::GetConeAngles, pdwInside, pdwOutside);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwInside && !IS_VALID_TYPED_WRITE_PTR(pdwInside))
    {
        RPF(DPFLVL_ERROR, "Invalid inside pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwOutside && !IS_VALID_TYPED_WRITE_PTR(pdwOutside))
    {
        RPF(DPFLVL_ERROR, "Invalid inside pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pdwInside && !pdwOutside)
    {
        RPF(DPFLVL_ERROR, "Both inside and outside pointers are NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetConeAngles(pdwInside, pdwOutside);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetConeOrientation
 *
 *  Description:
 *      Gets cone orienation.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives cone orientation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetConeOrientation"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetConeOrientation(D3DVECTOR* pvrConeOrientation)
{
    HRESULT hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetConeOrientation, pvrConeOrientation);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pvrConeOrientation))
    {
        RPF(DPFLVL_ERROR, "Invalid vector pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetConeOrientation(pvrConeOrientation);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetConeOutsideVolume
 *
 *  Description:
 *      Gets cone orienation.
 *
 *  Arguments:
 *      LPLONG [out]: receives volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetConeOutsideVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetConeOutsideVolume(LPLONG plVolume)
{
    HRESULT hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetConeOutsideVolume, plVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(plVolume))
    {
        RPF(DPFLVL_ERROR, "Invalid volume pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetConeOutsideVolume(plVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetMaxDistance
 *
 *  Description:
 *      Gets the object's maximum distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives max distance.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetMaxDistance"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetMaxDistance(D3DVALUE* pflMaxDistance)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetMaxDistance, pflMaxDistance);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pflMaxDistance))
    {
        RPF(DPFLVL_ERROR, "Invalid distance pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetMaxDistance(pflMaxDistance);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetMinDistance
 *
 *  Description:
 *      Gets the object's minimim distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives min distance.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetMinDistance"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetMinDistance(D3DVALUE* pflMinDistance)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetMinDistance, pflMinDistance);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pflMinDistance))
    {
        RPF(DPFLVL_ERROR, "Invalid distance pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetMinDistance(pflMinDistance);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetMode
 *
 *  Description:
 *      Gets the object's mode.
 *
 *  Arguments:
 *      LPDWORD [out]: receives mode.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetMode"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetMode(LPDWORD pdwMode)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetMode, pdwMode);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwMode))
    {
        RPF(DPFLVL_ERROR, "Invalid mode pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetMode(pdwMode);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetPosition
 *
 *  Description:
 *      Gets the object's position.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetPosition(D3DVECTOR* pvrPosition)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetPosition, pvrPosition);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pvrPosition))
    {
        RPF(DPFLVL_ERROR, "Invalid position pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetPosition(pvrPosition);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetVelocity
 *
 *  Description:
 *      Gets the object's velocity.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives velocity.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::GetVelocity"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetVelocity(D3DVECTOR* pvrVelocity)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetVelocity, pvrVelocity);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pvrVelocity))
    {
        RPF(DPFLVL_ERROR, "Invalid velocity pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetVelocity(pvrVelocity);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all object properties.
 *
 *  Arguments:
 *      LPDS3DBUFFER [in]: object parameters.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetAllParameters"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetAllParameters(LPCDS3DBUFFER pParam, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vr;
    BOOL                        fNorm;

    DPF_API2(IDirectSound3DBuffer::SetAllParameters, pParam, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DS3DBUFFER(pParam))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && (_isnan(pParam->vPosition.x) || _isnan(pParam->vPosition.y) || _isnan(pParam->vPosition.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vPosition");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (_isnan(pParam->vVelocity.x) || _isnan(pParam->vVelocity.y) || _isnan(pParam->vVelocity.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vVelocity");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (_isnan(pParam->flMinDistance) || _isnan(pParam->flMaxDistance)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter flMinDistance or flMaxDistance");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IsValidDs3dBufferConeAngles(pParam->dwInsideConeAngle, pParam->dwOutsideConeAngle))
    {
        hr = DSERR_INVALIDPARAM;
    }

    // NOTE: For an explanation of why we validate these particular FLOAT
    // parameters even in the retail build, see DX8 manbug 48027.

    if(SUCCEEDED(hr) && (_isnan(pParam->vConeOrientation.x) || _isnan(pParam->vConeOrientation.y) || _isnan(pParam->vConeOrientation.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vConeOrientation");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        vr = pParam->vConeOrientation;
        CheckVector(&vr);
        fNorm = NormalizeVector(&vr);
        if(!fNorm)
        {
            RPF(DPFLVL_ERROR, "Invalid zero-length vector vConeOrientation");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_CONE_OUTSIDE_VOLUME(pParam->lConeOutsideVolume))
    {
        RPF(DPFLVL_ERROR, "Volume out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_MAX_DISTANCE(pParam->flMaxDistance))
    {
        RPF(DPFLVL_ERROR, "Max Distance out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_MIN_DISTANCE(pParam->flMinDistance))
    {
        RPF(DPFLVL_ERROR, "Min Distance out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_MODE(pParam->dwMode))
    {
        RPF(DPFLVL_ERROR, "Invalid mode");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector((D3DVECTOR*)&(pParam->vPosition));
        CheckVector((D3DVECTOR*)&(pParam->vVelocity));
        CheckVector((D3DVECTOR*)&(pParam->vConeOrientation));
        fNorm = NormalizeVector((D3DVECTOR*)&(pParam->vConeOrientation));
        hr = m_pObject->SetAllParameters(pParam, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetConeAngles
 *
 *  Description:
 *      Sets the sound cone's angles.
 *
 *  Arguments:
 *      DWORD [in]: inside angle.
 *      DWORD [in]: outside angle.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetConeAngles"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetConeAngles(DWORD dwInside, DWORD dwOutside, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSound3DBuffer::SetConeAngles, dwInside, dwOutside, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IsValidDs3dBufferConeAngles(dwInside, dwOutside))
    {
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetConeAngles(dwInside, dwOutside, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetConeOrientation
 *
 *  Description:
 *      Sets the sound cone's orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: orientation.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetConeOrientation"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetConeOrientation(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vr;
    BOOL                        fNorm;

    DPF_API4(IDirectSound3DBuffer::SetConeOrientation, x, y, z, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    // NOTE: For an explanation of why we validate these particular FLOAT
    // parameters even in the retail build, see DX8 manbug 48027.

    if(SUCCEEDED(hr) && (_isnan(x) || _isnan(y) || _isnan(z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        SET_VECTOR(vr, x, y, z);

        CheckVector(&vr);
        fNorm = NormalizeVector(&vr);
        if(!fNorm)
        {
            RPF(DPFLVL_ERROR, "Invalid zero-length cone orientation vector");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetConeOrientation(vr, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetConeOutsideVolume
 *
 *  Description:
 *      Sets the sound cone's outside volume.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetConeOutsideVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetConeOutsideVolume(LONG lVolume, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DBuffer::SetConeOutsideVolume, lVolume, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_CONE_OUTSIDE_VOLUME(lVolume))
    {
        RPF(DPFLVL_ERROR, "Volume out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetConeOutsideVolume(lVolume, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetMaxDistance
 *
 *  Description:
 *      Sets the object's maximum distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE [in]: maximum distance.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetMaxDistance"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetMaxDistance(D3DVALUE flMaxDistance, DWORD dwFlags)
{
    HRESULT hr  = DS_OK;

    DPF_API2(IDirectSound3DBuffer::SetMaxDistance, flMaxDistance, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && _isnan(flMaxDistance))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter flMaxDistance");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_MAX_DISTANCE(flMaxDistance))
    {
        RPF(DPFLVL_ERROR, "Max Distance out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetMaxDistance(flMaxDistance, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetMinDistance
 *
 *  Description:
 *      Sets the object's minimum distance from the listener.
 *
 *  Arguments:
 *      D3DVALUE [in]: minimum distance.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetMinDistance"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetMinDistance(D3DVALUE flMinDistance, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DBuffer::SetMinDistance, flMinDistance, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && _isnan(flMinDistance))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter flMinDistance");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_MIN_DISTANCE(flMinDistance))
    {
        RPF(DPFLVL_ERROR, "Min Distance out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetMinDistance(flMinDistance, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetMode
 *
 *  Description:
 *      Sets the object's mode.
 *
 *  Arguments:
 *      DWORD [in]: mode.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetMode"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetMode(DWORD dwMode, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DBuffer::SetMode, dwMode, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DBUFFER_MODE(dwMode))
    {
        RPF(DPFLVL_ERROR, "Invalid mode");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetMode(dwMode, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the object's position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetPosition(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vr;

    DPF_API4(IDirectSound3DBuffer::SetPosition, x, y, z, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    SET_VECTOR(vr, x, y, z);

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && (_isnan(x) || _isnan(y) || _isnan(z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vr);
        hr = m_pObject->SetPosition(vr, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the object's velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: velocity.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBuffer::SetVelocity"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::SetVelocity(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vr;

    DPF_API4(IDirectSound3DBuffer::SetVelocity, x, y, z, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    SET_VECTOR(vr, x, y, z);

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && (_isnan(x) || _isnan(y) || _isnan(z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vr);
        hr = m_pObject->SetVelocity(vr, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetAttenuation
 *
 *  Description:
 *      Obtains the buffer's current true attenuation (as opposed to
 *      GetVolume, which just returns the last volume set by the app).
 *
 *  Arguments:
 *      FLOAT* [out]: attenuation in millibels.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dBufferPrivate::GetAttenuation"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dBuffer<object_type>::GetAttenuation(FLOAT* pfAttenuation)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DBuffer::GetAttenuation, pfAttenuation);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pfAttenuation))
    {
        RPF(DPFLVL_ERROR, "Invalid attenuation pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetAttenuation(pfAttenuation);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSound3dListener
 *
 *  Description:
 *      IDirectSound3dListener implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::CImpDirectSound3dListener"

template <class object_type> CImpDirectSound3dListener<object_type>::CImpDirectSound3dListener(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUND3DLISTENER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSound3dListener);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSound3dListener
 *
 *  Description:
 *      IDirectSound3dListener implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::~CImpDirectSound3dListener"

template <class object_type> CImpDirectSound3dListener<object_type>::~CImpDirectSound3dListener(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSound3dListener);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  GetAllParameters
 *
 *  Description:
 *      Gets all listener properties.
 *
 *  Arguments:
 *      LPDS3DLISTENER [out]: receives properties.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetAllParameters"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetAllParameters(LPDS3DLISTENER pParam)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DListener::GetAllParameters, pParam);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_DS3DLISTENER(pParam))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetAllParameters(pParam);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetDistanceFactor
 *
 *  Description:
 *      Gets the world's distance factor.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives distance factor.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetDistanceFactor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetDistanceFactor(D3DVALUE* pflDistanceFactor)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DListener::GetDistanceFactor, pflDistanceFactor);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pflDistanceFactor))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetDistanceFactor(pflDistanceFactor);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetDopplerFactor
 *
 *  Description:
 *      Gets the world's doppler factor.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives doppler factor.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetDopplerFactor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetDopplerFactor(D3DVALUE* pflDopplerFactor)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DListener::GetDopplerFactor, pflDopplerFactor);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pflDopplerFactor))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetDopplerFactor(pflDopplerFactor);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetOrientation
 *
 *  Description:
 *      Gets the listener's orientation.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives front orientation.
 *      D3DVECTOR* [out]: receives top orientation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetOrientation"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetOrientation(D3DVECTOR* pvrOrientationFront, D3DVECTOR* pvrOrientationTop)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DListener::GetOrientation, pvrOrientationFront, pvrOrientationTop);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pvrOrientationFront) || !IS_VALID_TYPED_WRITE_PTR(pvrOrientationTop))
    {
        RPF(DPFLVL_ERROR, "Invalid orientation buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetOrientation(pvrOrientationFront, pvrOrientationTop);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetPosition
 *
 *  Description:
 *      Gets the listener's position.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetPosition(D3DVECTOR* pvrPosition)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DListener::GetPosition, pvrPosition);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pvrPosition))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetPosition(pvrPosition);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetRolloffFactor
 *
 *  Description:
 *      Gets the world's rolloff factor.
 *
 *  Arguments:
 *      D3DVALUE* [out]: receives rolloff factor.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetRolloffFactor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetRolloffFactor(D3DVALUE* pflRolloffFactor)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DListener::GetRolloffFactor, pflRolloffFactor);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pflRolloffFactor))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetRolloffFactor(pflRolloffFactor);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetVelocity
 *
 *  Description:
 *      Gets the listener's velocity.
 *
 *  Arguments:
 *      D3DVECTOR* [out]: receives velocity.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::GetVelocity"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::GetVelocity(D3DVECTOR* pvrVelocity)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSound3DListener::GetVelocity, pvrVelocity);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pvrVelocity))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetVelocity(pvrVelocity);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetAllParameters
 *
 *  Description:
 *      Sets all listener properties.
 *
 *  Arguments:
 *      LPDS3DLISTENER [in]: properties.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetAllParameters"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetAllParameters(LPCDS3DLISTENER pParam, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vrFront;
    D3DVECTOR                   vrTop;
    BOOL                        fNorm;

    DPF_API2(IDirectSound3DListener::SetAllParameters, pParam, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DS3DLISTENER(pParam))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DLISTENER_DISTANCE_FACTOR(pParam->flDistanceFactor))
    {
        RPF(DPFLVL_ERROR, "Distance factor out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DLISTENER_DOPPLER_FACTOR(pParam->flDopplerFactor))
    {
        RPF(DPFLVL_ERROR, "Doppler factor out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && (_isnan(pParam->vPosition.x) || _isnan(pParam->vPosition.y) || _isnan(pParam->vPosition.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vPosition");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (_isnan(pParam->vVelocity.x) || _isnan(pParam->vVelocity.y) || _isnan(pParam->vVelocity.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vVelocity");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (_isnan(pParam->flDistanceFactor) || _isnan(pParam->flRolloffFactor) || _isnan(pParam->flDopplerFactor)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    CopyMemory(&vrFront, &(pParam->vOrientFront), sizeof(vrFront));
    CopyMemory(&vrTop, &(pParam->vOrientTop), sizeof(vrTop));

    // NOTE: For an explanation of why we validate these particular FLOAT
    // parameters even in the retail build, see DX8 manbug 48027.

    if(SUCCEEDED(hr) && (_isnan(vrFront.x) || _isnan(vrFront.y) || _isnan(vrFront.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vOrientFront");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (_isnan(vrTop.x) || _isnan(vrTop.y) || _isnan(vrTop.z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point value in vOrientTop");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vrFront);
        fNorm = NormalizeVector(&vrFront);
        if(!fNorm)
        {
            RPF(DPFLVL_ERROR, "Invalid zero-length vector vOrientFront");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vrTop);
        fNorm = NormalizeVector(&vrTop);
        if(!fNorm)
        {
            RPF(DPFLVL_ERROR, "Invalid zero-length vector vOrientTop");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && !MakeOrthogonal(&vrFront, &vrTop))
    {
        RPF(DPFLVL_ERROR, "Invalid orientation vectors");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_DS3DLISTENER_ROLLOFF_FACTOR(pParam->flRolloffFactor))
    {
        RPF(DPFLVL_ERROR, "Rolloff factor out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector((D3DVECTOR*)&(pParam->vPosition));
        CheckVector((D3DVECTOR*)&(pParam->vVelocity));
        CheckVector((D3DVECTOR*)&(pParam->vOrientFront));
        CheckVector((D3DVECTOR*)&(pParam->vOrientTop));
        fNorm = NormalizeVector((D3DVECTOR*)&(pParam->vOrientFront));
        fNorm = NormalizeVector((D3DVECTOR*)&(pParam->vOrientTop));
        MakeOrthogonal((D3DVECTOR*)&(pParam->vOrientFront), (D3DVECTOR*)&(pParam->vOrientTop));
        hr = m_pObject->SetAllParameters(pParam, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetDistanceFactor
 *
 *  Description:
 *      Sets the world's distance factor.
 *
 *  Arguments:
 *      D3DVALUE [in]: distance factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetDistanceFactor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetDistanceFactor(D3DVALUE flDistanceFactor, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DListener::SetDistanceFactor, flDistanceFactor, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && _isnan(flDistanceFactor))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter flDistanceFactor");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_DS3DLISTENER_DISTANCE_FACTOR(flDistanceFactor))
    {
        RPF(DPFLVL_ERROR, "Distance factor out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetDistanceFactor(flDistanceFactor, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetDopplerFactor
 *
 *  Description:
 *      Sets the world's Doppler factor.
 *
 *  Arguments:
 *      D3DVALUE [in]: Doppler factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetDopplerFactor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetDopplerFactor(D3DVALUE flDopplerFactor, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DListener::SetDopplerFactor, flDopplerFactor, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && _isnan(flDopplerFactor))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter flDopplerFactor");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_DS3DLISTENER_DOPPLER_FACTOR(flDopplerFactor))
    {
        RPF(DPFLVL_ERROR, "Doppler factor out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetDopplerFactor(flDopplerFactor, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetOrientation
 *
 *  Description:
 *      Sets the listener's orientation.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: front orientation.
 *      REFD3DVECTOR [in]: top orientation.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetOrientation"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetOrientation(D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront, D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop, DWORD dwFlags)
{
    HRESULT                     hr      = DS_OK;
    D3DVECTOR                   vrFront;
    D3DVECTOR                   vrTop;
    D3DVECTOR                   vrTemp;
    BOOL                        fNorm;

    DPF_API7(IDirectSound3DListener::SetOrientation, xFront, yFront, zFront, xTop, yTop, zTop, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    // NOTE: For an explanation of why we validate these particular FLOAT
    // parameters even in the retail build, see DX8 manbug 48027.

    if(SUCCEEDED(hr) && (_isnan(xFront) || _isnan(yFront) || _isnan(zFront) ||
                         _isnan(xTop)   || _isnan(yTop)   || _isnan(zTop)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        SET_VECTOR(vrFront, xFront, yFront, zFront);
        SET_VECTOR(vrTop, xTop, yTop, zTop);
        SET_VECTOR(vrTemp, xTop, yTop, zTop);

        CheckVector(&vrFront);
        fNorm = NormalizeVector(&vrFront);
        if(!fNorm)
        {
            RPF(DPFLVL_ERROR, "Invalid zero-length front vector");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vrTop);
        fNorm = NormalizeVector(&vrTop);
        if(!fNorm)
        {
            RPF(DPFLVL_ERROR, "Invalid zero-length top vector");
            hr = DSERR_INVALIDPARAM;
        }
    }

    // Normalize vrTemp so the subsequent call to MakeOrthogonal is valid
    if(SUCCEEDED(hr))
    {
        CheckVector(&vrTemp);
        fNorm = NormalizeVector(&vrTemp);
        if(!fNorm)
        {
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && !MakeOrthogonal(&vrFront, &vrTemp))
    {
        RPF(DPFLVL_ERROR, "Invalid orientation vectors");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetOrientation(vrFront, vrTemp, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetPosition
 *
 *  Description:
 *      Sets the listener's position.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: position.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetPosition(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vr;

    DPF_API4(IDirectSound3DListener::SetPosition, x, y, z, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    SET_VECTOR(vr, x, y, z);

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && (_isnan(x) || _isnan(y) || _isnan(z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vr);
        hr = m_pObject->SetPosition(vr, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetRolloffFactor
 *
 *  Description:
 *      Sets the world's rolloff factor.
 *
 *  Arguments:
 *      D3DVALUE [in]: rolloff factor.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetRolloffFactor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetRolloffFactor(D3DVALUE flRolloffFactor, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSound3DListener::SetRolloffFactor, flRolloffFactor, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && _isnan(flRolloffFactor))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter flRolloffFactor");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_DS3DLISTENER_ROLLOFF_FACTOR(flRolloffFactor))
    {
        RPF(DPFLVL_ERROR, "Rolloff factor out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetRolloffFactor(flRolloffFactor, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetVelocity
 *
 *  Description:
 *      Sets the listener's velocity.
 *
 *  Arguments:
 *      REFD3DVECTOR [in]: velocity.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::SetVelocity"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::SetVelocity(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;
    D3DVECTOR                   vr;

    DPF_API4(IDirectSound3DListener::SetVelocity, x, y, z, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    SET_VECTOR(vr, x, y, z);

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    #ifdef RDEBUG
    // In the debug build we validate all floating point parameters,
    // to help developers catch bugs.
    if(SUCCEEDED(hr) && (_isnan(x) || _isnan(y) || _isnan(z)))
    {
        RPF(DPFLVL_ERROR, "Invalid NaN floating point parameter");
        hr = DSERR_INVALIDPARAM;
    }
    #endif // RDEBUG

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DS3D_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        CheckVector(&vr);
        hr = m_pObject->SetVelocity(vr, dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CommitDeferredSettings
 *
 *  Description:
 *      Commits deferred settings.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSound3dListener::CommitDeferredSettings"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSound3dListener<object_type>::CommitDeferredSettings(void)
{
    HRESULT                     hr  = DS_OK;

    DPF_API0(IDirectSound3DListener::CommitDeferredSettings);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUND3DLISTENER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->CommitDeferredSettings();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSoundNotify
 *
 *  Description:
 *      IDirectSoundNotify implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundNotify::CImpDirectSoundNotify"

template <class object_type> CImpDirectSoundNotify<object_type>::CImpDirectSoundNotify(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUNDNOTIFY)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSoundNotify);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSoundNotify
 *
 *  Description:
 *      IDirectSoundNotify implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundNotify::~CImpDirectSoundNotify"

template <class object_type> CImpDirectSoundNotify<object_type>::~CImpDirectSoundNotify(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSoundNotify);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundNotify::SetNotificationPositions"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundNotify<object_type>::SetNotificationPositions(DWORD dwCount, LPCDSBPOSITIONNOTIFY paNotes)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSoundNotify::SetNotificationPositions, dwCount, paNotes);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDNOTIFY(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && dwCount && !IS_VALID_READ_PTR(paNotes, dwCount * sizeof(DSBPOSITIONNOTIFY)))
    {
        RPF(DPFLVL_ERROR, "Invalid notify buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (!paNotes || !dwCount))
    {
        paNotes = NULL;
        dwCount = 0;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetNotificationPositions(dwCount, paNotes);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpKsPropertySet
 *
 *  Description:
 *      IKsPropertySet implementation object constructor.
 *
 *  Arguments:
 *      CUnknown * [in]: pointer to controlling unknown.
 *      object_type * [in]: owning object pointer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpKsPropertySet::CImpKsPropertySet"

template <class object_type> CImpKsPropertySet<object_type>::CImpKsPropertySet(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IKSPROPERTYSET)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpKsPropertySet);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpKsPropertySet
 *
 *  Description:
 *      IKsPropertySet implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpKsPropertySet::~CImpKsPropertySet"

template <class object_type> CImpKsPropertySet<object_type>::~CImpKsPropertySet(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpKsPropertySet);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  Get
 *
 *  Description:
 *      Gets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set ID.
 *      ULONG [in]: property ID.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: property parameters size.
 *      LPVOID [out]: receives property data.
 *      ULONG [in]: size of data passed in.
 *      PULONG [out]: size of data returned.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpKsPropertySet::Get"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpKsPropertySet<object_type>::Get(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, ULONG cbPropertyData, PULONG pcbPropertyData)
{
    HRESULT                     hr  = DS_OK;

    DPF_API7(IKsPropertySet::Get, &guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, cbPropertyData, pcbPropertyData);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IKSPROPERTYSET(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&guidPropertySetId))
    {
        RPF(DPFLVL_ERROR, "Invalid property set ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IsValidPropertySetId(guidPropertySetId))
    {
        RPF(DPFLVL_ERROR, "Invalid property set ID");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (!pvPropertyParams || !cbPropertyParams))
    {
        pvPropertyParams = NULL;
        cbPropertyParams = 0;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pvPropertyParams, cbPropertyParams))
    {
        RPF(DPFLVL_ERROR, "Invalid property parameters pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (!pvPropertyData || !IS_VALID_READ_PTR(pvPropertyData, cbPropertyData)))
    {
        RPF(DPFLVL_ERROR, "Invalid property data pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, &cbPropertyData);

        if(pcbPropertyData)
        {
            *pcbPropertyData = cbPropertyData;
        }
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Set
 *
 *  Description:
 *      Sets data for a given property.
 *
 *  Arguments:
 *      REFGUID [in]: property set ID.
 *      ULONG [in]: property ID.
 *      LPVOID [in]: property parameters.
 *      ULONG [in]: property parameters size.
 *      LPVOID [in/out]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpKsPropertySet::Set"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpKsPropertySet<object_type>::Set(REFGUID guidPropertySetId, ULONG ulPropertyId, LPVOID pvPropertyParams, ULONG cbPropertyParams, LPVOID pvPropertyData, ULONG cbPropertyData)
{
    HRESULT                     hr  = DS_OK;

    DPF_API6(IKsPropertySet::Set, &guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, cbPropertyData);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IKSPROPERTYSET(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&guidPropertySetId))
    {
        RPF(DPFLVL_ERROR, "Invalid property set ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IsValidPropertySetId(guidPropertySetId))
    {
        RPF(DPFLVL_ERROR, "Invalid property set ID");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (!pvPropertyParams || !cbPropertyParams))
    {
        pvPropertyParams = NULL;
        cbPropertyParams = 0;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pvPropertyParams, cbPropertyParams))
    {
        RPF(DPFLVL_ERROR, "Invalid property parameters pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (!pvPropertyData || !cbPropertyData))
    {
        pvPropertyData = NULL;
        cbPropertyData = 0;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pvPropertyData, cbPropertyData))
    {
        RPF(DPFLVL_ERROR, "Invalid property data pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetProperty(guidPropertySetId, ulPropertyId, pvPropertyParams, cbPropertyParams, pvPropertyData, cbPropertyData);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  QuerySupport
 *
 *  Description:
 *      Queries for support of a given property set or property.
 *
 *  Arguments:
 *      REFGUID [in]: property set ID.
 *      ULONG [in]: property ID, or 0 to query for support of the property
 *                  set as a whole.
 *      PULONG [out]: receives support bits.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpKsPropertySet::QuerySupport"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpKsPropertySet<object_type>::QuerySupport(REFGUID guidPropertySetId, ULONG ulPropertyId, PULONG pulSupport)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IKsPropertySet::QuerySupport, &guidPropertySetId, ulPropertyId, pulSupport);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IKSPROPERTYSET(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&guidPropertySetId))
    {
        RPF(DPFLVL_ERROR, "Invalid property set ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IsValidPropertySetId(guidPropertySetId))
    {
        RPF(DPFLVL_ERROR, "Invalid property set ID");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pulSupport))
    {
        RPF(DPFLVL_ERROR, "Invalid support pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->QuerySupport(guidPropertySetId, ulPropertyId, pulSupport);

        #ifdef DEBUG
        static GUID DSPROPSETID_EAX20_ListenerProperties = {0x306a6a8, 0xb224, 0x11d2, 0x99, 0xe5, 0x0, 0x0, 0xe8, 0xd8, 0xc7, 0x22};
        static GUID DSPROPSETID_EAX20_BufferProperties = {0x306a6a7, 0xb224, 0x11d2, 0x99, 0xe5, 0x0, 0x0, 0xe8, 0xd8, 0xc7, 0x22};
        static GUID DSPROPSETID_I3DL2_ListenerProperties = {0xda0f0520, 0x300a, 0x11d3, 0x8a, 0x2b, 0x00, 0x60, 0x97, 0x0d, 0xb0, 0x11};
        static GUID DSPROPSETID_I3DL2_BufferProperties = {0xda0f0521, 0x300a, 0x11d3, 0x8a, 0x2b, 0x00, 0x60, 0x97, 0x0d, 0xb0, 0x11};
        TCHAR* pszPropSetName = NULL;

        if (guidPropertySetId == DSPROPSETID_VoiceManager)
            pszPropSetName = TEXT("DSPROPSETID_VoiceManager");
        else if (guidPropertySetId == DSPROPSETID_EAX20_ListenerProperties)
            pszPropSetName = TEXT("DSPROPSETID_EAX20_ListenerProperties");
        else if (guidPropertySetId == DSPROPSETID_EAX20_BufferProperties)
            pszPropSetName = TEXT("DSPROPSETID_EAX20_BufferProperties");
        else if (guidPropertySetId == DSPROPSETID_I3DL2_ListenerProperties)
            pszPropSetName = TEXT("DSPROPSETID_I3DL2_ListenerProperties");
        else if (guidPropertySetId == DSPROPSETID_I3DL2_BufferProperties)
            pszPropSetName = TEXT("DSPROPSETID_I3DL2_BufferProperties");

        if (pszPropSetName)
            DPF(DPFLVL_INFO, "Request for %s %sed", pszPropSetName, SUCCEEDED(hr) ? TEXT("succeed") : TEXT("fail"));
        else
            DPF(DPFLVL_INFO, "Request for unknown property set " DPF_GUID_STRING " %sed",
                DPF_GUID_VAL(guidPropertySetId), SUCCEEDED(hr) ? TEXT("succeed") : TEXT("fail"));
        #endif
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSoundCapture
 *
 *  Description:
 *      IDirectSoundCapture implementation object constructor.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCapture::CImpDirectSoundCapture"

template <class object_type> CImpDirectSoundCapture<object_type>::CImpDirectSoundCapture(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUNDCAPTURE)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSoundCapture);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSoundCapture
 *
 *  Description:
 *      IDirectSoundCapture implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCapture::~CImpDirectSoundCapture"

template <class object_type> CImpDirectSoundCapture<object_type>::~CImpDirectSoundCapture(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSoundCapture);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  CreateCaptureBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSoundCaptureBuffer object.
 *
 *  Arguments:
 *      LPCDSCBUFFERDESC [in]: description of the buffer to be created.
 *      LPDIRECTSOUNDCAPTUREBUFFER * [out]: receives a pointer to the new buffer.
 *      LPUNKNOWN [in]: unused.  Must be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCapture::CreateCaptureBuffer"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCapture<object_type>::CreateCaptureBuffer(LPCDSCBUFFERDESC pDesc, LPDIRECTSOUNDCAPTUREBUFFER *ppIdscb, LPUNKNOWN pUnkOuter)
{
    CDirectSoundCaptureBuffer * pBuffer = NULL;
    HRESULT                     hr      = DS_OK;
    DSCBUFFERDESC               dscbdi;

    DPF_API3(IDirectSoundCapture::CreateCaptureBuffer, pDesc, ppIdscb, pUnkOuter);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTURE(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSCBUFFERDESC(pDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer description");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDscBufferDesc(pDesc, &dscbdi, m_pObject->GetDsVersion());
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid capture buffer description");
        }
    }

    if(SUCCEEDED(hr) && pUnkOuter)
    {
        RPF(DPFLVL_ERROR, "Aggregation is not supported");
        hr = DSERR_NOAGGREGATION;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppIdscb))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // Create the buffer object
    if(SUCCEEDED(hr))
    {
        *ppIdscb = NULL;
        hr = m_pObject->CreateCaptureBuffer(&dscbdi, &pBuffer);
    }

    // NOTE: This call to CreateCaptureBuffer() has the important side effect of
    // updating the instance GUIDs in our effect list, mapping GUID_DSCFX_SYSTEM_*
    // to GUID_DSCFX_MS_* etc. for the system effects that default to MS ones.

    // Restrict some capture effects for use only with FullDuplex objects
    if(SUCCEEDED(hr) && pBuffer->NeedsMicrosoftAEC() && !m_pObject->HasMicrosoftAEC())
    {
        RPF(DPFLVL_ERROR, "The MS AEC, AGC and NS effects can only be used on full-duplex objects created with MS_AEC enabled");
        hr = DSERR_INVALIDPARAM;
    }

    // Query for an IDirectSoundCaptureBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundCaptureBuffer, TRUE, (LPVOID*)ppIdscb);
    }

    // Free resources
    if(FAILED(hr))
    {
        RELEASE(pBuffer);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCCAPS structure with the capabilities of the object.
 *
 *  Arguments:
 *      LPDSCCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCapture::GetCaps"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCapture<object_type>::GetCaps(LPDSCCAPS pCaps)
{
    HRESULT                 hr  = DS_OK;

    DPF_API1(IDirectSoundCapture::GetCaps, pCaps);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTURE(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_DSCCAPS(pCaps))
    {
        RPF(DPFLVL_ERROR, "Invalid caps buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetCaps(pCaps);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      LPGUID [in]: driver GUID.  This parameter may be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCapture::Initialize"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCapture<object_type>::Initialize(LPCGUID pGuid)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundCapture::Initialize, pGuid);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTURE(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pGuid && !IS_VALID_READ_GUID(pGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DS_OK == hr)
        {
            RPF(DPFLVL_ERROR, "DirectSoundCapture object already initialized");
            hr = DSERR_ALREADYINITIALIZED;
        }
        else if(DSERR_UNINITIALIZED == hr)
        {
            hr = DS_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Initialize(pGuid, NULL);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(SUCCEEDED(m_pObject->IsInit()));
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSoundCaptureBuffer
 *
 *  Description:
 *      IDirectSoundCaptureBuffer implementation object constructor.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::CImpDirectSoundCaptureBuffer"

template <class object_type> CImpDirectSoundCaptureBuffer<object_type>::CImpDirectSoundCaptureBuffer(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUNDCAPTUREBUFFER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSoundCaptureBuffer);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSoundCaptureBuffer
 *
 *  Description:
 *      IDirectSoundCaptureBuffer implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::~CImpDirectSoundCaptureBuffer"

template <class object_type> CImpDirectSoundCaptureBuffer<object_type>::~CImpDirectSoundCaptureBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSoundCaptureBuffer);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCBCAPS structure with the capabilities of the buffer.
 *
 *  Arguments:
 *      LPDSCBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetCaps"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetCaps(LPDSCBCAPS pCaps)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer::GetCaps, pCaps);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_DSCBCAPS(pCaps))
    {
        RPF(DPFLVL_ERROR, "Invalid caps pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetCaps(pCaps);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetCurrentPosition
 *
 *  Description:
 *      Gets the current capture/read positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives capture cursor position.
 *      LPDWORD [out]: receives read cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetCurrentPosition"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetCurrentPosition(LPDWORD pdwCapture, LPDWORD pdwRead)
{
    HRESULT                     hr  = DS_OK;

    DPF(DPFLVL_BUSYAPI, "IDirectSoundCaptureBuffer::GetCurrentPosition: pdwCapture=0x%p, pdwRead=0x%p", pdwCapture, pdwRead);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && pdwCapture && !IS_VALID_TYPED_WRITE_PTR(pdwCapture))
    {
        RPF(DPFLVL_ERROR, "Invalid capture cursor pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwRead && !IS_VALID_TYPED_WRITE_PTR(pdwRead))
    {
        RPF(DPFLVL_ERROR, "Invalid read cursor pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pdwCapture && !pdwRead)
    {
        RPF(DPFLVL_ERROR, "Both cursor pointers can't be NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetCurrentPosition(pdwCapture, pdwRead);
    }

    DPF(DPFLVL_BUSYAPI, "IDirectSoundCaptureBuffer::GetCurrentPosition: Leave, returning %s (Capture=%ld, Read=%ld)", HRESULTtoSTRING(hr), pdwCapture ? *pdwCapture : -1, pdwRead ? *pdwRead : -1);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Retrieves the format for the given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives the format.
 *      DWORD [in]: size of the above structure.
 *      LPDWORD [in/out]: On exit, this will be filled with the size that
 *                        was required.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetFormat"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSoundCaptureBuffer::GetFormat, pwfxFormat, dwSizeAllocated, pdwSizeWritten);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && pwfxFormat)
    {
        DWORD dwSizeCheck = max(sizeof(WAVEFORMATEX), dwSizeAllocated);
        if(!IS_VALID_WRITE_PTR(pwfxFormat, dwSizeCheck))
        {
            RPF(DPFLVL_ERROR, "Invalid format buffer");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && pdwSizeWritten && !IS_VALID_TYPED_WRITE_PTR(pdwSizeWritten))
    {
        RPF(DPFLVL_ERROR, "Invalid size pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pwfxFormat && !pdwSizeWritten)
    {
        RPF(DPFLVL_ERROR, "Either pwfxFormat or pdwSizeWritten must be non-NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        if(!pwfxFormat)
        {
            dwSizeAllocated = 0;
        }

        hr = m_pObject->GetFormat(pwfxFormat, &dwSizeAllocated);

        if(SUCCEEDED(hr) && pdwSizeWritten)
        {
            *pdwSizeWritten = dwSizeAllocated;
        }
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Retrieves status for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the status.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetStatus"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetStatus(LPDWORD pdwStatus)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer::GetStatus, pdwStatus);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwStatus))
    {
        RPF(DPFLVL_ERROR, "Invalid status pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetStatus(pdwStatus);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes a buffer object.
 *
 *  Arguments:
 *      LPDIRECTSOUNDCAPTURE [in]: parent DirectSoundCapture object.
 *      LPDSCBUFFERDESC [in]: buffer description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::Initialize"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::Initialize(LPDIRECTSOUNDCAPTURE pIdsc, LPCDSCBUFFERDESC pDesc)
{
    CImpDirectSoundCapture<CDirectSoundCapture> *   pImpDsCap   = (CImpDirectSoundCapture<CDirectSoundCapture> *)pIdsc;
    HRESULT                                         hr          = DS_OK;
    DSCBUFFERDESC                                   dscbdi;

    DPF_API2(IDirectSoundCaptureBuffer::Initialize, pIdsc, pDesc);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_IDIRECTSOUNDCAPTURE(pImpDsCap))
    {
        RPF(DPFLVL_ERROR, "Invalid parent interface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSCBUFFERDESC(pDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer description");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDscBufferDesc(pDesc, &dscbdi, m_pObject->GetDsVersion());
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid capture buffer description");
        }
    }

    // It's never valid to call this function.  We don't support
    // creating a DirectSoundCaptureBuffer object from anywhere but
    // IDirectSoundCapture::CreateCaptureBuffer.
    if(SUCCEEDED(hr))
    {
        RPF(DPFLVL_ERROR, "DirectSoundCapture buffer already initialized");
        hr = DSERR_ALREADYINITIALIZED;
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Lock
 *
 *  Description:
 *      Locks the buffer memory to allow for reading.
 *
 *  Arguments:
 *      DWORD [in]: offset, in bytes, from the start of the buffer to where
 *                  the lock begins.
 *      DWORD [in]: size, in bytes, of the portion of the buffer to lock.
 *                  Note that the sound buffer is conceptually circular.
 *      LPVOID * [out]: address for a pointer to contain the first block of
 *                      the sound buffer to be locked.
 *      LPDWORD [out]: address for a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr1 parameter. If this
 *                     value is less than the dwWriteBytes parameter,
 *                     lplpvAudioPtr2 will point to a second block of sound
 *                     data.
 *      LPVOID * [out]: address for a pointer to contain the second block of
 *                      the sound buffer to be locked. If the value of this
 *                      parameter is NULL, the lplpvAudioPtr1 parameter
 *                      points to the entire locked portion of the sound
 *                      buffer.
 *      LPDWORD [out]: address of a variable to contain the number of bytes
 *                     pointed to by the lplpvAudioPtr2 parameter. If
 *                     lplpvAudioPtr2 is NULL, this value will be 0.
 *      DWORD [in]: flags modifying the lock event.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::Lock"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::Lock(DWORD dwReadCursor, DWORD dwReadBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1, LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags)
{
    HRESULT                     hr              = DS_OK;

    DPF(DPFLVL_BUSYAPI, "IDirectSoundCaptureBuffer::Lock: ReadCursor=%lu, ReadBytes=%lu, Flags=0x%lX", dwReadCursor, dwReadBytes, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_TYPED_WRITE_PTR(ppvAudioPtr1))
        {
            *ppvAudioPtr1 = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid audio ptr 1");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(IS_VALID_TYPED_WRITE_PTR(pdwAudioBytes1))
        {
            *pdwAudioBytes1 = 0;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid audio bytes 1");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && ppvAudioPtr2)
    {
        if(IS_VALID_TYPED_WRITE_PTR(ppvAudioPtr2))
        {
            *ppvAudioPtr2 = NULL;
        }
        else
        {
            RPF(DPFLVL_ERROR, "Invalid audio ptr 2");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && pdwAudioBytes2)
    {
        if(IS_VALID_TYPED_WRITE_PTR(pdwAudioBytes2))
        {
            *pdwAudioBytes2 = 0;
        }
        else if(ppvAudioPtr2)
        {
            RPF(DPFLVL_ERROR, "Invalid audio bytes 2");
            hr = DSERR_INVALIDPARAM;
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DSCBLOCK_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Lock(dwReadCursor, dwReadBytes, ppvAudioPtr1, pdwAudioBytes1, ppvAudioPtr2, pdwAudioBytes2, dwFlags);
    }

    DPF(DPFLVL_BUSYAPI, "IDirectSoundCaptureBuffer::Lock: Leave, returning %s (AudioPtr1=0x%p, AudioBytes1=%lu, AudioPtr2=0x%p, AudioBytes2=%lu)",
        HRESULTtoSTRING(hr),
        ppvAudioPtr1 ? *ppvAudioPtr1 : NULL,
        pdwAudioBytes1 ? *pdwAudioBytes1 : NULL,
        ppvAudioPtr2 ? *ppvAudioPtr2 : NULL,
        pdwAudioBytes2 ? *pdwAudioBytes2 : NULL);

    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Start
 *
 *  Description:
 *      Starts the buffer capturing.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::Start"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::Start(DWORD dwFlags)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer::Start, dwFlags);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_FLAGS(dwFlags, DSCBSTART_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Start(dwFlags);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Stop
 *
 *  Description:
 *      Stops capturing to the given buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::Stop"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::Stop(void)
{
    HRESULT                     hr  = DS_OK;

    DPF_API0(IDirectSoundCaptureBuffer::Stop);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Stop();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Unlock
 *
 *  Description:
 *      Unlocks the given buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to the first block.
 *      DWORD [in]: size of the first block.
 *      LPVOID [in]: pointer to the second block.
 *      DWORD [in]: size of the second block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::Unlock"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::Unlock(LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2)
{
    HRESULT                     hr  = DS_OK;

    DPF(DPFLVL_BUSYAPI, "IDirectSoundCaptureBuffer::Unlock: AudioPtr1=0x%p, AudioBytes1=%lu, AudioPtr2=0x%p, AudioBytes2=%lu",
        pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pvAudioPtr1, dwAudioBytes1))
    {
        RPF(DPFLVL_ERROR, "Invalid audio ptr 1");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && dwAudioBytes2 && !IS_VALID_READ_PTR(pvAudioPtr2, dwAudioBytes2))
    {
        RPF(DPFLVL_ERROR, "Invalid audio ptr 2");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Unlock(pvAudioPtr1, dwAudioBytes1, pvAudioPtr2, dwAudioBytes2);
    }

    DPF(DPFLVL_BUSYAPI, "IDirectSoundCaptureBuffer::Unlock: Leave, returning %s", HRESULTtoSTRING(hr));
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the master recording level for this capture buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume level, in 100ths of a dB.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::SetVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::SetVolume(LONG lVolume)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::SetVolume, lVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX))
    {
        DPF(DPFLVL_ERROR, "Volume out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetVolume(lVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetVolume
 *
 *  Description:
 *      Gets the master recording level for this capture buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetVolume(LPLONG plVolume)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::GetVolume, plVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(plVolume))
    {
        DPF(DPFLVL_ERROR, "Invalid volume ptr");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetVolume(plVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetMicVolume
 *
 *  Description:
 *      Sets the microphone recording level for this capture buffer.
 *
 *  Arguments:
 *      LONG [in]: new volume level, in 100ths of a dB.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::SetMicVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::SetMicVolume(LONG lVolume)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::SetMicVolume, lVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && (lVolume < DSBVOLUME_MIN || lVolume > DSBVOLUME_MAX))
    {
        DPF(DPFLVL_ERROR, "Volume out of bounds");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetMicVolume(lVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetMicVolume
 *
 *  Description:
 *      Gets the microphone recording level for this capture buffer.
 *
 *  Arguments:
 *      LPLONG [out]: receives the volume level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetMicVolume"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetMicVolume(LPLONG plVolume)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::GetMicVolume, plVolume);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(plVolume))
    {
        DPF(DPFLVL_ERROR, "Invalid volume ptr");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetMicVolume(plVolume);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  EnableMic
 *
 *  Description:
 *      Enables/disables the microphone line on this capture buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to enable the microphone, FALSE to disable it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::EnableMic"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::EnableMic(BOOL fEnable)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::EnableMic, fEnable);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->EnableMic(fEnable);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  YieldFocus
 *
 *  Description:
 *      Yields the capture focus to another capture buffer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::YieldFocus"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::YieldFocus(void)
{
    HRESULT hr = DS_OK;

    DPF_API0(IDirectSoundCaptureBuffer7_1::YieldFocus);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->YieldFocus();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  ClaimFocus
 *
 *  Description:
 *      Regains the capture focus.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::ClaimFocus"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::ClaimFocus(void)
{
    HRESULT hr = DS_OK;

    DPF_API0(IDirectSoundCaptureBuffer7_1::ClaimFocus);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->ClaimFocus();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetFocusHWND
 *
 *  Description:
 *      Sets the current HWND associated with this capture buffer.
 *
 *  Arguments:
 *      HWND [in]: HWND to be associated with this buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::SetFocusHWND"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::SetFocusHWND(HWND hwndMainWindow)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::SetFocusHWND, hwndMainWindow);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_HWND(hwndMainWindow))
    {
        DPF(DPFLVL_ERROR, "Invalid window handle");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetFocusHWND(hwndMainWindow);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetFocusHWND
 *
 *  Description:
 *      Gets the current HWND associated with this capture buffer.
 *
 *  Arguments:
 *      HWND * [out]: receives HWND associated with this buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetFocusHWND"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetFocusHWND(HWND *pHwndMainWindow)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::GetFocusHWND, pHwndMainWindow);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pHwndMainWindow))
    {
        DPF(DPFLVL_ERROR, "Invalid window handle ptr");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetFocusHWND(pHwndMainWindow);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  EnableFocusNotifications
 *
 *  Description:
 *      Requests focus change notifications to be sent.
 *
 *  Arguments:
 *      HANDLE [in]: event to signal when a capture focus change occurs.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::EnableFocusNotifications"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::EnableFocusNotifications(HANDLE hFocusEvent)
{
    HRESULT hr = DS_OK;

    DPF_API1(IDirectSoundCaptureBuffer7_1::EnableFocusNotifications, hFocusEvent);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            DPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !(hFocusEvent == NULL || IS_VALID_HANDLE(hFocusEvent)))
    {
        DPF(DPFLVL_ERROR, "Invalid event");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->EnableFocusNotifications(hFocusEvent);
    }

    DPF_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetObjectInPath
 *
 *  Description:
 *      Obtains a given interface on a given effect on this buffer.
 *
 *  Arguments:
 *      REFGUID [in]: Class ID of the effect that is being searched for,
 *                    or GUID_ALL_OBJECTS to search for any effect.
 *      DWORD [in]: Index of the effect, in case there is more than one
 *                  effect with this CLSID on this buffer.
 *      REFGUID [in]: IID of the interface requested.  The selected effect
 *                    will be queried for this interface.
 *      LPVOID * [out]: Receives the interface requested.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetObjectInPath"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetObjectInPath(REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID *ppObject)
{
    HRESULT hr = DS_OK;

    DPF_API4(IDirectSoundCaptureBuffer8::GetObjectInPath, &guidObject, dwIndex, &iidInterface, ppObject);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&guidObject))
    {
        RPF(DPFLVL_ERROR, "Invalid guidObject pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&iidInterface))
    {
        RPF(DPFLVL_ERROR, "Invalid iidInterface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppObject))
    {
        RPF(DPFLVL_ERROR, "Invalid ppObject pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetObjectInPath(guidObject, dwIndex, iidInterface, ppObject);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetFXStatus
 *
 *  Description:
 *      [MISSING]
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundCaptureBuffer::GetFXStatus"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundCaptureBuffer<object_type>::GetFXStatus(DWORD dwFXCount, LPDWORD pdwFXStatus)
{
    HRESULT hr = DS_OK;

    DPF_API2(IDirectSoundCaptureBuffer8::GetFXStatus, dwFXCount, pdwFXStatus);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DSERR_UNINITIALIZED == hr)
        {
            RPF(DPFLVL_ERROR, "Object not yet initialized");
        }
    }

    if(SUCCEEDED(hr) && dwFXCount <= 0)
    {
        RPF(DPFLVL_ERROR, "Invalid dwFXCount <= 0");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(pdwFXStatus))
    {
        RPF(DPFLVL_ERROR, "Invalid dwFXStatus pointer");
        hr = DSERR_INVALIDPARAM;
    }


    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetFXStatus(dwFXCount, pdwFXStatus);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSoundSink
 *
 *  Description:
 *      [MISSING]
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::CImpDirectSoundSink"

template <class object_type> CImpDirectSoundSink<object_type>::CImpDirectSoundSink(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUNDSINK)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSoundSink);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSoundSink
 *
 *  Description:
 *      [MISSING]
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::~CImpDirectSoundSink"

template <class object_type> CImpDirectSoundSink<object_type>::~CImpDirectSoundSink()
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSoundSink);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  AddSource
 *
 *  Description:
 *      Set attached source
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::AddSource"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::AddSource(IDirectSoundSource *pDSSource)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundConnect::AddSource, pDSSource);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->AddSource(pDSSource);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  RemoveSource
 *
 *  Description:
 *      Remove the attached source from the sink
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::RemoveSource"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::RemoveSource(IDirectSoundSource *pDSSource)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundConnect::RemoveSource, pDSSource);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->RemoveSource(pDSSource);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetMasterClock
 *
 *  Description:
 *      IDirectSoundSink set master clock
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::SetMasterClock"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::SetMasterClock(IReferenceClock *pClock)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundConnect::SetMasterClock, pClock);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetMasterClock(pClock);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetLatencyClock
 *
 *  Description:
 *      IDirectSoundSink get latency clock
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetLatencyClock"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetLatencyClock(IReferenceClock **ppClock)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundSynthSink::GetLatencyClock, ppClock);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppClock))
    {
        RPF(DPFLVL_ERROR, "Invalid ppClock pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetLatencyClock(ppClock);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Activate
 *
 *  Description:
 *      IDirectSoundSink activate
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::Activate"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::Activate(BOOL fEnable)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundSynthSink::Activate, fEnable);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Activate(fEnable);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SampleToRefTime
 *
 *  Description:
 *      IDirectSoundSink convert sample to reference time
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::SampleToRefTime"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prtTime)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSoundSynthSink::SampleToRefTime, llSampleTime, prtTime);
    DPF_ENTER();

    // This function doesn't take the DLL mutex because the clock object
    // itself is protected with a finer-grained critical section

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(prtTime))
    {
        RPF(DPFLVL_ERROR, "Invalid prtTime pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SampleToRefTime(llSampleTime, prtTime);
    }

    DPF_API_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  RefToSampleTime
 *
 *  Description:
 *      IDirectSoundSink convert reference to sample time
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::RefToSampleTime"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::RefToSampleTime(REFERENCE_TIME rtTime, LONGLONG *pllSampleTime)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectSoundSynthSink::RefToSampleTime, rtTime, pllSampleTime);
    DPF_ENTER();

    // This function doesn't take the DLL mutex because the clock object
    // itself is protected with a finer-grained critical section

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pllSampleTime))
    {
        RPF(DPFLVL_ERROR, "Invalid pllSampleTime pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->RefToSampleTime(rtTime, pllSampleTime);
    }

    DPF_API_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetFormat
 *
 *  Description:
 *      Retrieves the format for the given buffer.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives the format.
 *      LPDWORD [in/out]: On exit, size of waveformat passed in;
 *                        on exit, size required/used.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetFormat"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetFormat(LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSoundSynthSink::GetFormat, pwfxFormat, dwSizeAllocated, pdwSizeWritten);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pwfxFormat && !IS_VALID_WRITE_WAVEFORMATEX(pwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Invalid format buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && pdwSizeWritten && !IS_VALID_TYPED_WRITE_PTR(pdwSizeWritten))
    {
        RPF(DPFLVL_ERROR, "Invalid size pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !pwfxFormat && !pdwSizeWritten)
    {
        RPF(DPFLVL_ERROR, "Either pwfxFormat or pdwSizeWritten must be non-NULL");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        if(!pwfxFormat)
        {
            dwSizeAllocated = 0;
        }

        hr = m_pObject->GetFormat(pwfxFormat, &dwSizeAllocated);

        if(SUCCEEDED(hr) && pdwSizeWritten)
        {
            *pdwSizeWritten = dwSizeAllocated;
        }
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CreateSoundBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSoundBuffer object on a sink.
 *
 *  Arguments:
 *      LPCDSBUFFERDESC [in]: description of the buffer to be created.
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::CreateSoundBuffer"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::CreateSoundBuffer(LPCDSBUFFERDESC pcDSBufferDesc, LPDWORD pdwFuncID, DWORD dwBusIDCount, REFGUID guidBufferID, LPDIRECTSOUNDBUFFER *ppDSBuffer)
{
    CDirectSoundBuffer *    pBuffer     = NULL;
    HRESULT                 hr          = DS_OK;
    DSBUFFERDESC            dsbdi;

    DPF_API5(IDirectSoundConnect::CreateSoundBuffer, pcDSBufferDesc, pdwFuncID, dwBusIDCount, &guidBufferID, ppDSBuffer);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_PTR(pdwFuncID, sizeof(*pdwFuncID) * dwBusIDCount))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwFuncID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSBUFFERDESC(pcDSBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid pcDSBufferDesc pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDsBufferDesc(pcDSBufferDesc, &dsbdi, DSVERSION_DX8, TRUE);
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid buffer description");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_GUID(&guidBufferID))
    {
        RPF(DPFLVL_ERROR, "Invalid guidBufferID argument");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppDSBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid ppDSBuffer pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // Create the buffer object
    if(SUCCEEDED(hr))
    {
        *ppDSBuffer = NULL;
        hr = m_pObject->CreateSoundBuffer(&dsbdi, pdwFuncID, dwBusIDCount, guidBufferID, &pBuffer);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer, TRUE, (LPVOID*)ppDSBuffer);
    }

    // Clean up
    if(FAILED(hr))
    {
        RELEASE(pBuffer);
    }
    else
    {
        // Let the buffer use a special successful return code if it wants to
        hr = pBuffer->SpecialSuccessCode();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CreateSoundBufferFromConfig
 *
 *  Description:
 *      IDirectSoundSink CreateSoundBufferFromConfig
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::CreateSoundBufferFromConfig"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::CreateSoundBufferFromConfig(IUnknown *pConfig, LPDIRECTSOUNDBUFFER *ppDSBuffer)
{
    CDirectSoundBuffer *    pBuffer     = NULL;
    HRESULT                 hr          = DS_OK;

    DPF_API2(IDirectSoundConnect::CreateSoundBufferFromConfig, pConfig, ppDSBuffer);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_EXTERNAL_INTERFACE(pConfig))
    {
        RPF(DPFLVL_ERROR, "Invalid pConfig pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppDSBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer interface pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // Create the buffer object
    if(SUCCEEDED(hr))
    {
        *ppDSBuffer = NULL;
        hr = m_pObject->CreateSoundBufferFromConfig(pConfig, &pBuffer);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer, TRUE, (LPVOID*)ppDSBuffer);
    }

    // Clean up
    if(FAILED(hr))
    {
        RELEASE(pBuffer);
    }
    else
    {
        // Let the buffer use a special successful return code if it wants to
        hr = pBuffer->SpecialSuccessCode();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetSoundBuffer
 *
 *  Description:
 *      IDirectSoundSink GetSoundBuffer
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetSoundBuffer"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetSoundBuffer(DWORD dwBusId, LPDIRECTSOUNDBUFFER *ppDSBuffer)
{
    CDirectSoundBuffer *    pBuffer     = NULL;
    HRESULT                 hr          = DS_OK;

    DPF_API2(IDirectSoundConnect::GetSoundBuffer, dwBusId, ppDSBuffer);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(ppDSBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid ppDSBuffer pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        *ppDSBuffer = NULL;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetSoundBuffer(dwBusId, &pBuffer);
    }

    // Query for an IDirectSoundBuffer interface
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer, TRUE, (LPVOID *)ppDSBuffer);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetBusCount
 *
 *  Description:
 *      IDirectSoundSink get bus count
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetBusCount"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetBusCount(LPDWORD pdwCount)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectSoundConnect::GetBusCount, pdwCount);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwCount))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwCount pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetBusCount(pdwCount);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetBusIDs
 *
 *  Description:
 *      IDirectSoundSink get bus identifiers
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetBusIDs"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetBusIDs(DWORD *pdwBusIDs, DWORD *pdwFuncIDs, DWORD dwBusCount)
{
    HRESULT                     hr  = DS_OK;

    DPF_API3(IDirectSoundConnect::GetBusIDs, pdwBusIDs, pdwFuncIDs, dwBusCount);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_PTR(pdwBusIDs, sizeof(*pdwBusIDs) * dwBusCount))
    {
        RPF(DPFLVL_ERROR, "Invalid Bus ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_PTR(pdwFuncIDs, sizeof(*pdwFuncIDs) * dwBusCount))
    {
        RPF(DPFLVL_ERROR, "Invalid Function ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetBusIDs(pdwBusIDs, pdwFuncIDs, dwBusCount);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetSoundBufferBusIDs
 *
 *  Description:
 *      IDirectSoundSink get bus identifiers
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetSoundBufferBusIDs"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetSoundBufferBusIDs(LPDIRECTSOUNDBUFFER pDSBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount)
{
    HRESULT hr = DS_OK;

    DPF_API4(IDirectSoundConnect::GetSoundBufferBusIDs, pDSBuffer, pdwBusIDs, pdwFuncIDs, pdwBusCount);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_WRITE_PTR(pdwBusIDs, sizeof(*pdwBusIDs) * (*pdwBusCount)))
    {
        RPF(DPFLVL_ERROR, "Invalid Bus ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // pdwFuncIDs == NULL is acceptable
    if(SUCCEEDED(hr) && pdwFuncIDs && !IS_VALID_WRITE_PTR(pdwFuncIDs, sizeof(*pdwFuncIDs) * (*pdwBusCount)))
    {
        RPF(DPFLVL_ERROR, "Invalid Function ID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    CImpDirectSoundBuffer<CDirectSoundBuffer>* pDsBuffer = (CImpDirectSoundBuffer<CDirectSoundBuffer>*)pDSBuffer;
    if(SUCCEEDED(hr) && !IS_VALID_IDIRECTSOUNDBUFFER(pDsBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid source buffer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetSoundBufferBusIDs(pDsBuffer->m_pObject, pdwBusIDs, pdwFuncIDs, pdwBusCount);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetFunctionalID
 *
 *  Description:
 *      Gets the functional ID from a bus ID.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundSink::GetFunctionalID"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundSink<object_type>::GetFunctionalID(DWORD dwBusID, LPDWORD pdwFuncID)
{
    HRESULT hr = DS_OK;

    DPF_API2(IDirectSoundConnect::GetFunctionalID, dwBusID, pdwFuncID);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDSINK(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pdwFuncID))
    {
        RPF(DPFLVL_ERROR, "Invalid pdwFuncID pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetFunctionalID(dwBusID, pdwFuncID);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpPersistStream
 *
 *  Description:
 *      IPersistStream
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::CImpPersistStream"

template <class object_type> CImpPersistStream<object_type>::CImpPersistStream(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IPERSISTSTREAM)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpPersistStream);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpPersistStream
 *
 *  Description:
 *      IPersistStream implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::~CImpPersistStream"

template <class object_type> CImpPersistStream<object_type>::~CImpPersistStream()
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpPersistStream);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  GetClassID
 *
 *  Description:
 *      IPersist::GetClassID
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::GetClassID"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpPersistStream<object_type>::GetClassID(CLSID *pclsid)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IPersist::GetClassID, pclsid);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IPERSISTSTREAM(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pclsid))
    {
        RPF(DPFLVL_ERROR, "Invalid pclsid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetClassID(pclsid);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  IsDirty
 *
 *  Description:
 *      IPersistStream::IsDirty
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::IsDirty"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpPersistStream<object_type>::IsDirty()
{
    HRESULT                     hr;

    DPF_API0(IPersistStream::IsDirty);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IPERSISTSTREAM(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }
    else
    {
        hr = m_pObject->IsDirty();
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Load
 *
 *  Description:
 *      IPersistStream::Load
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::Load"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpPersistStream<object_type>::Load(IStream *pStream)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IPersistStream::Load, pStream);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IPERSISTSTREAM(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_EXTERNAL_INTERFACE(pStream))
    {
        RPF(DPFLVL_ERROR, "Invalid pStream pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Load(pStream);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  Save
 *
 *  Description:
 *      IPersistStream::Save
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::Save"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpPersistStream<object_type>::Save(IStream *pStream, BOOL fClearDirty)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IPersistStream::Save, pStream, fClearDirty);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IPERSISTSTREAM(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_EXTERNAL_INTERFACE(pStream))
    {
        RPF(DPFLVL_ERROR, "Invalid pStream pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->Save(pStream, fClearDirty);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  GetSizeMax
 *
 *  Description:
 *      IPersistStream::GetSizeMax
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpPersistStream::GetSizeMax"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpPersistStream<object_type>::GetSizeMax(ULARGE_INTEGER *pul)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IPersistStream::GetSizeMax, pul);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IPERSISTSTREAM(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pul))
    {
        RPF(DPFLVL_ERROR, "Invalid pul pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetSizeMax(pul);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectMusicObject
 *
 *  Description:
 *      IDirectMusicObject implementation object constructor.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectMusicObject::CImpDirectMusicObject"

template <class object_type> CImpDirectMusicObject<object_type>::CImpDirectMusicObject(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTMUSICOBJECT)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectMusicObject);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectMusicObject
 *
 *  Description:
 *      IDirectMusicObject implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectMusicObject::~CImpDirectMusicObject"

template <class object_type> CImpDirectMusicObject<object_type>::~CImpDirectMusicObject()
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectMusicObject);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  GetDescriptor
 *
 *  Description:
 *      CImpDirectMusicObject::GetDescriptor
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectMusicObject::GetDescriptor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectMusicObject<object_type>::GetDescriptor(DMUS_OBJECTDESC *pDesc)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectMusicObject::GetDescriptor, pDesc);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTMUSICOBJECT(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid pDesc pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->GetDescriptor(pDesc);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  SetDescriptor
 *
 *  Description:
 *      CImpDirectMusicObject::SetDescriptor
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectMusicObject::SetDescriptor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectMusicObject<object_type>::SetDescriptor(DMUS_OBJECTDESC *pDesc)
{
    HRESULT                     hr  = DS_OK;

    DPF_API1(IDirectMusicObject::SetDescriptor, pDesc);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTMUSICOBJECT(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid pDesc pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->SetDescriptor(pDesc);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  ParseDescriptor
 *
 *  Description:
 *      CImpDirectMusicObject::ParseDescriptor
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectMusicObject::ParseDescriptor"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectMusicObject<object_type>::ParseDescriptor(IStream *pStream, DMUS_OBJECTDESC *pDesc)
{
    HRESULT                     hr  = DS_OK;

    DPF_API2(IDirectMusicObject::ParseDescriptor, pStream, pDesc);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTMUSICOBJECT(this))
    {
        DPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_EXTERNAL_INTERFACE(pStream))
    {
        RPF(DPFLVL_ERROR, "Invalid pStream pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(pDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid pDesc pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->ParseDescriptor(pStream, pDesc);
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}


/***************************************************************************
 *
 *  CImpDirectSoundFullDuplex
 *
 *  Description:
 *      IDirectSoundFullDuplex implementation object constructor.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundFullDuplex::CImpDirectSoundFullDuplex"

template <class object_type> CImpDirectSoundFullDuplex<object_type>::CImpDirectSoundFullDuplex(CUnknown *pUnknown, object_type *pObject)
    : CImpUnknown(pUnknown), m_signature(INTSIG_IDIRECTSOUNDFULLDUPLEX)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpDirectSoundFullDuplex);
    ENTER_DLL_MUTEX();

    // Initialize defaults
    m_pObject = pObject;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}


/***************************************************************************
 *
 *  ~CImpDirectSoundFullDuplex
 *
 *  Description:
 *      IDirectSoundFullDuplex implementation object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundFullDuplex::~CImpDirectSoundFullDuplex"

template <class object_type> CImpDirectSoundFullDuplex<object_type>::~CImpDirectSoundFullDuplex(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CImpDirectSoundFullDuplex);
    ENTER_DLL_MUTEX();

    m_signature = INTSIG_DELETED;

    DPF_LEAVE_VOID();
    LEAVE_DLL_MUTEX();
}

/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the DirectSoundFullDuplex object.
 *
 *  Arguments: [MISSING]
 *      LPCGUID [in]:
 *      LPCGUID [in]:
 *      LPCDSCBUFFERDESC [in]:
 *      LPCDSBUFFERDESC [in]:
 *      HWND [in]:
 *      DWORD [in]:
 *      LPLPDIRECTSOUNDCAPTUREBUFFER8 [out]:
 *      LPLPDIRECTSOUNDBUFFER8 [out]:
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CImpDirectSoundFullDuplex::Initialize"

template <class object_type> HRESULT STDMETHODCALLTYPE CImpDirectSoundFullDuplex<object_type>::Initialize
(
    LPCGUID                         pCaptureGuid,
    LPCGUID                         pRenderGuid,
    LPCDSCBUFFERDESC                lpDscBufferDesc,
    LPCDSBUFFERDESC                 lpDsBufferDesc,
    HWND                            hWnd,
    DWORD                           dwLevel,
    LPLPDIRECTSOUNDCAPTUREBUFFER8   lplpDirectSoundCaptureBuffer8,
    LPLPDIRECTSOUNDBUFFER8          lplpDirectSoundBuffer8
)
{
    CDirectSoundCaptureBuffer *     pCaptureBuffer          = NULL;
    CDirectSoundBuffer *            pBuffer                 = NULL;
    HRESULT                         hr                      = DS_OK;
    DSCBUFFERDESC                   dscbdi;
    DSBUFFERDESC                    dsbdi;

    DPF_API8(IDirectSoundFullDuplex::Initialize, pCaptureGuid, pRenderGuid, lpDscBufferDesc, lpDsBufferDesc, hWnd, dwLevel, lplpDirectSoundCaptureBuffer8, lplpDirectSoundBuffer8);
    DPF_ENTER();
    ENTER_DLL_MUTEX();

    if(!IS_VALID_IDIRECTSOUNDFULLDUPLEX(this))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(pCaptureGuid && !IS_VALID_READ_GUID(pCaptureGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid capture guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(pRenderGuid && !IS_VALID_READ_GUID(pRenderGuid))
    {
        RPF(DPFLVL_ERROR, "Invalid render guid pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSCBUFFERDESC(lpDscBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid DSC buffer description pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDscBufferDesc(lpDscBufferDesc, &dscbdi, DSVERSION_DX8);
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid capture buffer description");
        }
    }

    if(SUCCEEDED(hr) && !IS_VALID_READ_DSBUFFERDESC(lpDsBufferDesc))
    {
        RPF(DPFLVL_ERROR, "Invalid DS buffer description pointer");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = BuildValidDsBufferDesc(lpDsBufferDesc, &dsbdi, DSVERSION_DX8, FALSE);
        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Invalid buffer description");
        }
    }

    if(SUCCEEDED(hr) && (dsbdi.dwFlags & DSBCAPS_PRIMARYBUFFER))
    {
        RPF(DPFLVL_ERROR, "Cannot specify DSBCAPS_PRIMARYBUFFER with DirectSoundFullDuplexCreate");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_HWND(hWnd))
    {
        RPF(DPFLVL_ERROR, "Invalid window handle");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && (dwLevel < DSSCL_FIRST || dwLevel > DSSCL_LAST))
    {
        RPF(DPFLVL_ERROR, "Invalid cooperative level");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(lplpDirectSoundCaptureBuffer8))
    {
        RPF(DPFLVL_ERROR, "Invalid capture buffer interface buffer8");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr) && !IS_VALID_TYPED_WRITE_PTR(lplpDirectSoundBuffer8))
    {
        RPF(DPFLVL_ERROR, "Invalid render buffer interface buffer8");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pObject->IsInit();

        if(DS_OK == hr)
        {
            RPF(DPFLVL_ERROR, "DirectSoundFullDuplex object already initialized");
            hr = DSERR_ALREADYINITIALIZED;
        }
        else if(DSERR_UNINITIALIZED == hr)
        {
            hr = DS_OK;
        }
    }

    if(SUCCEEDED(hr))
    {
        // Set the DX8 functional level on the object
        m_pObject->SetDsVersion(DSVERSION_DX8);

        hr = m_pObject->Initialize(pCaptureGuid, pRenderGuid, &dscbdi, &dsbdi,
                                   hWnd, dwLevel, &pCaptureBuffer, &pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(SUCCEEDED(m_pObject->IsInit()));
    }

    // Query for the required interfaces
    if(SUCCEEDED(hr))
    {
        hr = pCaptureBuffer->QueryInterface(IID_IDirectSoundCaptureBuffer8, TRUE, (LPVOID*)lplpDirectSoundCaptureBuffer8);
        ASSERT(SUCCEEDED(hr));
        hr = pBuffer->QueryInterface(IID_IDirectSoundBuffer8, TRUE, (LPVOID*)lplpDirectSoundBuffer8);
        ASSERT(SUCCEEDED(hr));
    }

    DPF_API_LEAVE_HRESULT(hr);
    LEAVE_DLL_MUTEX();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsfd.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsfd.cpp
 *  Content:    DirectSoundFullDuplex class implementation
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   12/1/98    jstokes Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  CDirectSoundFullDuplex
 *
 *  Description:
 *      DirectSoundFullDuplex object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundFullDuplex::CDirectSoundFullDuplex"

CDirectSoundFullDuplex::CDirectSoundFullDuplex()
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundFullDuplex);

    // Set defaults
    m_pImpDirectSoundFullDuplex = NULL;
    m_hrInit = DSERR_UNINITIALIZED;
    m_fIncludeAec = FALSE;
    m_guidAecInstance = GUID_NULL;
    m_dwAecFlags = 0;
    m_pDirectSound = NULL;
    m_pDirectSoundCapture = NULL;

    // Register the interface with the interface manager
    CreateAndRegisterInterface(this, IID_IDirectSoundFullDuplex, this, &m_pImpDirectSoundFullDuplex);

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundFullDuplex
 *
 *  Description:
 *      DirectSoundFullDuplex object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundFullDuplex::~CDirectSoundFullDuplex"

CDirectSoundFullDuplex::~CDirectSoundFullDuplex()
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundFullDuplex);

    // Unregister with the administrator
    g_pDsAdmin->UnregisterObject(this);

    if(m_pDirectSoundCapture)
    {
        m_pDirectSoundCapture->NonDelegatingRelease();
    }

    if(m_pDirectSound)
    {
        m_pDirectSound->NonDelegatingRelease();
    }

    // Free all interfaces
    DELETE(m_pImpDirectSoundFullDuplex);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundFullDuplex::Initialize"

HRESULT CDirectSoundFullDuplex::Initialize
(
    LPCGUID                         pguidCaptureDevice,
    LPCGUID                         pguidRenderDevice,
    LPCDSCBUFFERDESC                pDscBufferDesc,
    LPCDSBUFFERDESC                 pDsBufferDesc,
    HWND                            hWnd,
    DWORD                           dwLevel,
    CDirectSoundCaptureBuffer **    ppDirectSoundCaptureBuffer,
    CDirectSoundBuffer **           ppDirectSoundBuffer
)
{
    HRESULT                         hr = DS_OK;

    DPF_ENTER();

    *ppDirectSoundCaptureBuffer = NULL;
    *ppDirectSoundBuffer = NULL;

    // DirectSoundFullDuplex objects are only supported since Whistler
    if (GetWindowsVersion() < WIN_XP)
    {
        RPF(DPFLVL_ERROR, "IDirectSoundFullDuplex not supported on this OS");
        hr = DSERR_INVALIDCALL;
    }

    if(SUCCEEDED(hr))
    {
        // Create and initialize the DirectSoundCapture object
        m_pDirectSoundCapture = NEW(CDirectSoundCapture(this));
        hr = HRFROMP(m_pDirectSoundCapture);
    }

    if(SUCCEEDED(hr))
    {
        // Set the DX8 functional level on the object and initialize it
        m_pDirectSoundCapture->SetDsVersion(GetDsVersion());

        hr = m_pDirectSoundCapture->Initialize(pguidCaptureDevice, this);
    }

    // Register the IDirectSoundCapture8 (=IDirectSoundCapture) interface
    if(SUCCEEDED(hr))
    {
        hr = RegisterInterface(IID_IDirectSoundCapture8, m_pDirectSoundCapture->m_pImpDirectSoundCapture, (IDirectSoundCapture8*)(m_pDirectSoundCapture->m_pImpDirectSoundCapture));
    }

    // Create the DirectSoundCaptureBuffer
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSoundCapture->CreateCaptureBuffer(pDscBufferDesc, ppDirectSoundCaptureBuffer);
    }

    // NOTE: This call to CreateCaptureBuffer() has the important side effect of
    // updating the instance GUIDs in our effect list, mapping GUID_DSCFX_SYSTEM_*
    // to GUID_DSCFX_MS_* etc. for the system effects that default to MS ones.

    // Figure out our AEC status, flags, and implementation to be used
    if(SUCCEEDED(hr))
    {
        for (DWORD i=0; i<pDscBufferDesc->dwFXCount; i++)
        {
            if(pDscBufferDesc->lpDSCFXDesc[i].guidDSCFXClass == GUID_DSCFX_CLASS_AEC)
            {
                if (m_fIncludeAec)
                {
                    RPF(DPFLVL_ERROR, "Cannot request AEC effect twice");
                    hr = DSERR_INVALIDPARAM;
                    break;
                }
                m_fIncludeAec = TRUE;
                m_dwAecFlags = pDscBufferDesc->lpDSCFXDesc[i].dwFlags;
                m_guidAecInstance = pDscBufferDesc->lpDSCFXDesc[i].guidDSCFXInstance;
            }
        }
    }


#ifdef DEAD_CODE
    // This code is disabled because AEC.SYS now has status reporting,
    // and can inform the application whether it has converged or not.
    // Our current AEC implementation is almost guaranteed to fail if
    // used across different devices, but future versions may succeed,
    // so we don't want to disable this scenario here in DirectSound.

    // If the Microsoft AEC effect has been requested, we check here that the
    // device GUIDs requested both refer to the same WDM device, so that timing
    // will stay in sync.  This is a temporary measure until we get clock rate
    // matching working in Blackcomb (bug #99702).

    if (SUCCEEDED(hr) && m_guidAecInstance == GUID_DSCFX_MS_AEC)
    {
        // First translate the device IDs requested to specific device GUIDs
        GUID guidRender = IS_NULL_GUID(pguidRenderDevice) ? DSDEVID_DefaultPlayback : *pguidRenderDevice;
        GUID guidCapture = IS_NULL_GUID(pguidCaptureDevice) ? DSDEVID_DefaultCapture : *pguidCaptureDevice;
        g_pVadMgr->GetDeviceIdFromDefaultId(&guidRender, &guidRender);
        g_pVadMgr->GetDeviceIdFromDefaultId(&guidCapture, &guidCapture);

        // Now check that the device IDs correspond to the same device
        if (g_pVadMgr->GetDriverDeviceType(guidRender) != VAD_DEVICETYPE_KSRENDER ||
            g_pVadMgr->GetDriverDeviceType(guidCapture) != VAD_DEVICETYPE_KSCAPTURE ||
            guidRender.Data4[7] != guidCapture.Data4[7])
        {
            RPF(DPFLVL_ERROR, "The MS_AEC effect cannot be used across different audio render and capture devices");
            hr = DSERR_UNSUPPORTED;
        }

        // We don't allow AEC to run on USB devices, since all known full-duplex
        // USB devices (e.g. telephone handsets) have different sample rates in
        // their render and capture parts, which breaks AEC.

        if(SUCCEEDED(hr))
        {
            BOOL fAecAllowed;

            // See if the device has an AEC setting in the registry
            if (RhRegGetBinaryValue(m_pDirectSoundCapture->m_hkeyParent, REGSTR_ALLOW_MS_AEC, &fAecAllowed, sizeof fAecAllowed) == DS_OK)
            {
                RPF(fAecAllowed ? DPFLVL_INFO : DPFLVL_ERROR,
                    "The MS_AEC effect is explicitly %sabled for this device in the registry",
                    fAecAllowed ? TEXT("en") : TEXT("dis"));
            }
            else
            {
                // If there is no registry setting, allow AEC only on non-USB devices
                // (or USB devices that don't use the usbaudio.sys class driver)
                fAecAllowed = _stricmp(m_pDirectSoundCapture->m_pDevice->m_pDeviceDescription->m_strPath, "usbaudio.sys");
                if (!fAecAllowed)
                    RPF(DPFLVL_ERROR, "The MS_AEC effect cannot be used on USB devices unless explicitly enabled in the registry");
            }

            if (!fAecAllowed)
                hr = DSERR_UNSUPPORTED;
        }
    }
#endif // DEAD_CODE


    // Create and initialize the DirectSound object
    if(SUCCEEDED(hr))
    {
        m_pDirectSound = NEW(CDirectSound((CUnknown*)this));
        hr = HRFROMP(m_pDirectSound);
    }
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->Initialize(pguidRenderDevice, this);
    }

    // Register the IDirectSound and IDirectSound8 interfaces
    if(SUCCEEDED(hr))
    {
        hr = RegisterInterface(IID_IDirectSound, m_pDirectSound->m_pImpDirectSound, (IDirectSound*)(m_pDirectSound->m_pImpDirectSound));
    }
    if(SUCCEEDED(hr))
    {
        hr = RegisterInterface(IID_IDirectSound8, m_pDirectSound->m_pImpDirectSound, (IDirectSound8*)(m_pDirectSound->m_pImpDirectSound));
    }

    if(SUCCEEDED(hr))
    {
        // Set the functional level on the object
        m_pDirectSound->SetDsVersion(GetDsVersion());
    }

    // Set the cooperative level
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->SetCooperativeLevel(GetWindowThreadProcessId(GetRootParentWindow(hWnd), NULL), dwLevel);
    }

    // Create the DirectSoundBuffer
    if(SUCCEEDED(hr))
    {
        hr = m_pDirectSound->CreateSoundBuffer(pDsBufferDesc, ppDirectSoundBuffer);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        m_hrInit = DS_OK;
    }
    else
    {
        RELEASE(*ppDirectSoundCaptureBuffer);
        RELEASE(*ppDirectSoundBuffer);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsobj.cpp
 *  Content:    DirectSound object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  CDirectSound
 *
 *  Description:
 *      DirectSound object default constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CDirectSound"

CDirectSound::CDirectSound()
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSound);

    // Initialize defaults
    m_pDevice = NULL;
    m_pPrimaryBuffer = NULL;
    m_dsclCooperativeLevel.dwThreadId = 0;
    m_dsclCooperativeLevel.dwPriority = DSSCL_NORMAL;
    m_hkeyParent = NULL;
    m_hrInit = DSERR_UNINITIALIZED;
    m_vmmMode = DSPROPERTY_VMANAGER_MODE_DEFAULT;

    // Register the interfaces with the interface manager.  Normally, this
    // would be done in the ::Initialize method, but because we support
    // creating an uninitialized DirectSound object from CoCreateInstance or
    // IClassFactory::CreateInstance, we have to give at least basic QI
    // support from here.  We don't have to worry about returning an
    // error code because if we run out of memory, QI will return
    // E_NOINTERFACE.
    CreateAndRegisterInterface(this, IID_IDirectSound, this, &m_pImpDirectSound);

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CDirectSound
 *
 *  Description:
 *      DirectSound object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CDirectSound"

CDirectSound::CDirectSound
(
    CUnknown* pControllingUnknown
) : CUnknown(pControllingUnknown)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSound);

    // Initialize defaults
    m_pDevice = NULL;
    m_pPrimaryBuffer = NULL;
    m_dsclCooperativeLevel.dwThreadId = 0;
    m_dsclCooperativeLevel.dwPriority = DSSCL_NORMAL;
    m_hkeyParent = NULL;
    m_hrInit = DSERR_UNINITIALIZED;
    m_vmmMode = DSPROPERTY_VMANAGER_MODE_DEFAULT;

    // Register the interfaces with the interface manager (see comment above).
    CreateAndRegisterInterface(this, IID_IDirectSound, this, &m_pImpDirectSound);

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSound
 *
 *  Description:
 *      DirectSound object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::~CDirectSound"

CDirectSound::~CDirectSound(void)
{
    ULONG                                   ulCount;
    CNode<CDirectSoundSecondaryBuffer *> *  pNode;

    DPF_ENTER();
    DPF_DESTRUCT(CDirectSound);

    // Unregister with the administrator
    g_pDsAdmin->UnregisterObject(this);

    // Free all buffers
    if(ulCount = m_lstSecondaryBuffers.GetNodeCount())
    {
        while(pNode = m_lstSecondaryBuffers.GetListHead())
        {
            // Calling AbsoluteRelease instead of ABSOLUTE_RELEASE in
            // order to prevent a page fault.  ~CDirectSoundSecondaryBuffer
            // removes the buffer from the list, freeing pNode.
            // ABSOLUTE_RELEASE will try to set pNode->m_data to NULL after
            // calling AbsoluteRelease.
            pNode->m_data->AbsoluteRelease();
        }

        RPF(DPFLVL_ERROR, "Process 0x%8.8lX leaked %lu secondary buffers", GetCurrentProcessId(), ulCount);
    }

    ABSOLUTE_RELEASE(m_pPrimaryBuffer);

    // Free the audio device
    RELEASE(m_pDevice);

    // Free all interfaces
    DELETE(m_pImpDirectSound);

    // Close the registry key
    RhRegCloseKey(&m_hkeyParent);

    // Release the Administrator's worker thread
    if(SUCCEEDED(m_hrInit))
    {
        g_pDsAdmin->Terminate();
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.  Normally, an object would have a pointer
 *      to another object of the same type to duplicate from.  DirectSound
 *      objects, however, are responsible for duplicating themselves based
 *      on the driver GUID.  DirectSound objects are special because they
 *      can be initialized by either DirectSoundCreate or CoInitialize.
 *      If this function fails, the object should be immediately deleted.
 *
 *  Arguments:
 *      LPGUID [in]: driver GUID, or NULL to use the preferred device.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::Initialize"

HRESULT CDirectSound::Initialize
(
    LPCGUID pGuid,
    CDirectSoundFullDuplex * pFullDuplex
)
{
#ifdef DEBUG
    const ULONG                 ulKsIoctlCount  = g_ulKsIoctlCount;
#endif // DEBUG
    GUID                        guidDevice;
    VADDEVICETYPE               vdt             = VAD_DEVICETYPE_RENDERMASK;
    DWORD                       dwSpeakerConfig = DSSPEAKER_DEFAULT;
    DIRECTSOUNDMIXER_SRCQUALITY nSrcQuality     = DIRECTSOUNDMIXER_SRCQUALITY_DEFAULT;
    DWORD                       dwAcceleration  = DIRECTSOUNDMIXER_ACCELERATIONF_DEFAULT;
    HRESULT                     hr              = DS_OK;
    DSBUFFERDESC                dsbd;
    HKEY                        hkey;
    HRESULT                     hrTemp;

    DPF_ENTER();

    ASSERT(IsInit() == DSERR_UNINITIALIZED);

    // Make a local copy of the driver GUID
    guidDevice = *BuildValidGuid(pGuid, NULL);

    // If the given GUID is one of the special default device IDs,
    // map it to the corresponding "real" DirectSound device ID.
    // Note: if guidDevice is GUID_NULL, GetDeviceIdFromDefaultId()
    // will fail, which is OK because GUID_NULL is handled below.
    g_pVadMgr->GetDeviceIdFromDefaultId(&guidDevice, &guidDevice);

    // Load apphacks for the current application
    AhGetAppHacks(&m_ahAppHacks);

    // Mask off devices that are turned off via an apphack.  OpenDevice
    // handles devices that are disabled via the standard registry keys.
    vdt &= ~m_ahAppHacks.vdtDisabledDevices;

    // Is there an open device we can use?
    hr = g_pVadMgr->FindOpenDevice(vdt, guidDevice, (CDevice **)&m_pDevice);

    if(SUCCEEDED(hr))
    {
        // Yup
        DPF(DPFLVL_INFO, "Found open device at 0x%p", m_pDevice);
    }
    else
    {
        // Nope.  Attempt to open a new device.
        hr = g_pVadMgr->OpenDevice(vdt, guidDevice, (CDevice **)&m_pDevice);
    }

    if(SUCCEEDED(hr) && pFullDuplex)
    {
        hr = m_pDevice->IncludeAEC
        (
            pFullDuplex->HasAEC(),
            pFullDuplex->AecInstanceGuid(),
            pFullDuplex->AecCreationFlags()
        );
    }

    // Read default device settings (e.g. acceleration and src quality) before
    // trying to read them from the device's registry.
    if (SUCCEEDED(hr))
    {
        HKEY hkeyDefault;
        hrTemp = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, REGSTR_MIXERDEFAULTS);
        if (SUCCEEDED(hrTemp))
        {
            RhRegGetBinaryValue(hkeyDefault, REGSTR_SRCQUALITY, &nSrcQuality, sizeof(nSrcQuality));
            RhRegGetBinaryValue(hkeyDefault, REGSTR_ACCELERATION, &dwAcceleration, sizeof(dwAcceleration));
            RhRegCloseKey(&hkeyDefault);
        }
    }

    // Open the device's registry key
    if(SUCCEEDED(hr))
    {
#ifdef WINNT
        g_pVadMgr->OpenPersistentDataKey(m_pDevice->m_vdtDeviceType, m_pDevice->m_pDeviceDescription->m_strInterface, &m_hkeyParent);
#else // WINNT
        g_pVadMgr->OpenPersistentDataKey(m_pDevice->m_vdtDeviceType, m_pDevice->m_pDeviceDescription->m_dwDevnode, &m_hkeyParent);
#endif // WINNT
    }

    // Load and apply persistent data
    if(SUCCEEDED(hr))
    {
        hrTemp = RhRegOpenKey(m_hkeyParent, REGSTR_MIXERDEFAULTS, 0, &hkey);
        if(SUCCEEDED(hrTemp))
        {
            RhRegGetBinaryValue(hkey, REGSTR_SRCQUALITY, &nSrcQuality, sizeof(nSrcQuality));
            RhRegGetBinaryValue(hkey, REGSTR_ACCELERATION, &dwAcceleration, sizeof(dwAcceleration));
            RhRegCloseKey(&hkey);
        }

        hrTemp = RhRegOpenKey(m_hkeyParent, REGSTR_SPEAKERCONFIG, 0, &hkey);
        if(SUCCEEDED(hrTemp))
        {
            RhRegGetBinaryValue(hkey, REGSTR_SPEAKERCONFIG, &dwSpeakerConfig, sizeof(dwSpeakerConfig));
            RhRegCloseKey(&hkey);
        }
    }

    if(SUCCEEDED(hr))
    {
        hrTemp = m_pDevice->SetSrcQuality(nSrcQuality);
        if(FAILED(hrTemp) && DSERR_UNSUPPORTED != hrTemp)
        {
            RPF(DPFLVL_WARNING, "Unable to set mixer SRC quality");
        }

        if (m_pDevice->m_vdtDeviceType & m_ahAppHacks.daDevAccel.vdtDevicesAffected)
        {
            dwAcceleration |= m_ahAppHacks.daDevAccel.dwAcceleration;
        }

        hrTemp = m_pDevice->SetAccelerationFlags(dwAcceleration);
        if(FAILED(hrTemp) && DSERR_UNSUPPORTED != hrTemp)
        {
            RPF(DPFLVL_WARNING, "Unable to set mixer acceleration flags");
        }

        hrTemp = SetSpeakerConfig(dwSpeakerConfig);
        if(FAILED(hrTemp) && DSERR_UNSUPPORTED != hrTemp)
        {
            RPF(DPFLVL_WARNING, "Unable to set speaker configuration");
            // FIXME: make sure these messages don't *always* happen
        }
    }

    // Create the primary buffer.  Every DirectSound object has exactly one
    // primary buffer.  When the application attempts to create a primary buffer
    // of its own, we'll just change some settings on the internal primary.
    if(SUCCEEDED(hr))
    {
        m_pPrimaryBuffer = NEW(CDirectSoundPrimaryBuffer(this));
        hr = HRFROMP(m_pPrimaryBuffer);
    }

    if(SUCCEEDED(hr))
    {
        InitStruct(&dsbd, sizeof(dsbd));

        dsbd.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D;

        hr = m_pPrimaryBuffer->Initialize(&dsbd);
    }

    // Do not move this up before hr = m_pPrimaryBuffer->Initialize(&dsbd)
    // On a WDM driver, the dummy primary buffer isn't created until the
    // Initialize call.  After we have created the dummy primary buffer,
    // we can call GetCaps() successfully.
    if(SUCCEEDED(hr))
    {
        InitStruct(&m_dsc, sizeof(m_dsc));

        hr = m_pDevice->GetCaps(&m_dsc);
    }

    // We set the speaker config again now, after creating the primary buffer,
    // because the 3D listener also needs to receive this config.  [This call
    // to SetSpeakerConfig() is intentionally redundant with the one above.]
    if(SUCCEEDED(hr))
    {
        hrTemp = SetSpeakerConfig(dwSpeakerConfig);
        if(FAILED(hrTemp) && DSERR_UNSUPPORTED != hrTemp)
        {
            RPF(DPFLVL_WARNING, "Unable to set speaker configuration");
            // FIXME: make sure these message don't *always* happen
        }
    }

    // Initialize the Administrator
    if(SUCCEEDED(hr))
    {
        hr = g_pDsAdmin->Initialize();
    }

    // Success
    if(SUCCEEDED(hr))
    {
#ifdef DEBUG
        if(IS_KS_VAD(m_pDevice->m_vdtDeviceType))
        {
            DPF(DPFLVL_MOREINFO, "%s used %lu IOCTLs", TEXT(DPF_FNAME), g_ulKsIoctlCount - ulKsIoctlCount);
        }
#endif // DEBUG
        m_hrInit = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDsVersion
 *
 *  Description:
 *      Makes us aware of our "functional level", so we can have different
 *      behavior depending on whether we're in a DX7 app, a DX8 app, etc.
 *
 *  Arguments:
 *      DSVERSION [in]: Owning application's functional level.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDsVersion"

void CDirectSound::SetDsVersion(DSVERSION nVersion)
{
    DPF_ENTER();

    CUnknown::SetDsVersion(nVersion);

    if (nVersion >= DSVERSION_DX8)
    {
        RegisterInterface(IID_IDirectSound8, m_pImpDirectSound, (IDirectSound8*)m_pImpDirectSound);
        RegisterInterface(IID_IDirectSoundPrivate, m_pImpDirectSound, (IDirectSoundPrivate*)m_pImpDirectSound);
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CreateSoundBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSound Buffer object.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: description of the buffer to be
 *                                   created.
 *      CDirectSoundBuffer ** [out]: receives a pointer to the
 *                                   new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSoundBuffer"

HRESULT CDirectSound::CreateSoundBuffer(LPCDSBUFFERDESC pDesc, CDirectSoundBuffer **ppBuffer)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // COMPATCOMPAT: even though the spec says that you must call
    // SetCooperativeLevel before calling CreateSoundBuffer, previous
    // versions did not actually enforce this.

    // Cooperative level must be set before creating buffers
    if(!m_dsclCooperativeLevel.dwThreadId || DSSCL_NONE == m_dsclCooperativeLevel.dwPriority)
    {
        RPF(DPFLVL_INFO, "Called CreateSoundBuffer before SetCooperativeLevel");
    }

    // Create the buffer
    if(SUCCEEDED(hr))
    {
        if(pDesc->dwFlags & DSBCAPS_PRIMARYBUFFER)
        {
            hr = CreatePrimaryBuffer(pDesc, ppBuffer);
        }
        else
        {
            hr = CreateSecondaryBuffer(pDesc, ppBuffer);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateSinkBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSound Buffer object.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: description of the buffer to be created.
 *      CDirectSoundBuffer ** [out]: receives a pointer to the new buffer.
 *      CDirectSoundSink * [in]: pointer to the owning sink object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSinkBuffer"

HRESULT CDirectSound::CreateSinkBuffer(LPDSBUFFERDESC pDesc, REFGUID guidBufferID, CDirectSoundSecondaryBuffer **ppBuffer, CDirectSoundSink *pOwningSink)
{
    DPF_ENTER();

    CHECK_READ_PTR(pDesc);
    CHECK_WRITE_PTR(ppBuffer);
    CHECK_WRITE_PTR(pOwningSink);

    // Add the flag which tags this buffer as owned by a sink
    pDesc->dwFlags |= DSBCAPS_SINKIN;

    // Create the buffer object
    CDirectSoundSecondaryBuffer *pBuffer = NEW(CDirectSoundSecondaryBuffer(this));
    HRESULT hr = HRFROMP(pBuffer);

    // FIXME: CDirectSoundSecondaryBuffer is begging to be refactored into a base class (traditional
    // buffer functionality) and a derived CDirectSoundSinkBuffer class with the extra functionality/
    // data relevant only to the sink (SetOwningSink, SetGUID).

    if(SUCCEEDED(hr))
    {
        pBuffer->SetDsVersion(GetDsVersion());  // Always succeeds
        hr = pBuffer->Initialize(pDesc, NULL);
    }
    if(SUCCEEDED(hr))
    {
        pBuffer->SetGUID(guidBufferID);         // Always succeeds
        pBuffer->SetOwningSink(pOwningSink);    // Always succeeds
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreatePrimaryBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSound Buffer object.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: description of the buffer to be created.
 *      CDirectSoundBuffer ** [out]: receives a pointer to the
 *                                   new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreatePrimaryBuffer"

HRESULT CDirectSound::CreatePrimaryBuffer(LPCDSBUFFERDESC pDesc, CDirectSoundBuffer **ppBuffer)
{
    HRESULT                 hr;

    DPF_ENTER();

    // The primary buffer has already been created.  All we can do
    // here is change its flags.  The buffer will create and free
    // owned objects and interfaces based on the new flags.
    hr = m_pPrimaryBuffer->OnCreateSoundBuffer(pDesc->dwFlags);

    if(SUCCEEDED(hr))
    {
        *ppBuffer = m_pPrimaryBuffer;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateSecondaryBuffer
 *
 *  Description:
 *      Creates and initializes a DirectSound Buffer object.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: description of the buffer to be created.
 *      CDirectSoundBuffer ** [out]: receives a pointer to the
 *                                   new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSecondaryBuffer"

HRESULT CDirectSound::CreateSecondaryBuffer(LPCDSBUFFERDESC pDesc, CDirectSoundBuffer **ppBuffer)
{
    CDirectSoundSecondaryBuffer *   pBuffer;
    HRESULT                         hr;

    DPF_ENTER();

    // Create the buffer object
    pBuffer = NEW(CDirectSoundSecondaryBuffer(this));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        pBuffer->SetDsVersion(GetDsVersion());  // Always succeeds
        hr = pBuffer->Initialize(pDesc, NULL);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    // Handle any apphacked failures
    if(FAILED(hr) && FAILED(m_ahAppHacks.hrModifyCsbFailure))
    {
        hr = m_ahAppHacks.hrModifyCsbFailure;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  DuplicateSoundBuffer
 *
 *  Description:
 *      Duplicates an existing sound buffer object.
 *
 *  Arguments:
 *      CDirectSoundBuffer * [in]: source object.
 *      CDirectSoundBuffer ** [out]: receives new object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::DuplicateSoundBuffer"

HRESULT CDirectSound::DuplicateSoundBuffer(CDirectSoundBuffer *pSource, CDirectSoundBuffer **ppDest)
{
    CDirectSoundSecondaryBuffer *   pBuffer = NULL;
    HRESULT                         hr      = DS_OK;

    DPF_ENTER();

    // Can't duplicate primary buffers
    if(pSource->m_dsbd.dwFlags & DSBCAPS_PRIMARYBUFFER)
    {
        RPF(DPFLVL_ERROR, "Can't duplicate primary buffers");
        hr = DSERR_INVALIDCALL;
    }

    // Both the source and destination must be owned by this object
    if(SUCCEEDED(hr) && this != pSource->m_pDirectSound)
    {
        RPF(DPFLVL_ERROR, "Can't duplicate buffers from another DirectSound object");
        hr = DSERR_INVALIDCALL;
    }

    // Can't duplicate buffers that use new DX8 features
    if(SUCCEEDED(hr) && (pSource->m_dsbd.dwFlags & (DSBCAPS_MIXIN | DSBCAPS_SINKIN | DSBCAPS_CTRLFX)))
    {
        RPF(DPFLVL_ERROR, "Can't duplicate MIXIN/sink/effects buffers");
        hr = DSERR_INVALIDCALL;
    }

    // Create the buffer object
    if(SUCCEEDED(hr))
    {
        pBuffer = NEW(CDirectSoundSecondaryBuffer(this));
        hr = HRFROMP(pBuffer);
    }

    // Initialize the buffer
    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(NULL, (CDirectSoundSecondaryBuffer *)pSource);
    }

    if(SUCCEEDED(hr))
    {
        *ppDest = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCAPS structure with capabilities of the object.
 *
 *  Arguments:
 *      LPDSCAPS pdscCaps [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetCaps"

HRESULT CDirectSound::GetCaps(LPDSCAPS pCaps)
{
    const DWORD             dwValidFlags    = DSCAPS_VALIDFLAGS & ~DSCAPS_CERTIFIED;
    DWORD                   dwCertification;
    HRESULT                 hr;

    DPF_ENTER();

    // Get device caps
    hr = m_pDevice->GetCaps(pCaps);

    // Make sure the caps conform to the DirectSound API
    if(SUCCEEDED(hr))
    {
        ASSERT(IS_VALID_FLAGS(pCaps->dwFlags, dwValidFlags));

        pCaps->dwFlags &= dwValidFlags;

#if 0 // NT bug 252552

        if(pCaps->dwMinSecondarySampleRate)
        {
            pCaps->dwMinSecondarySampleRate = BETWEEN(pCaps->dwMinSecondarySampleRate, DSBFREQUENCY_MIN, DSBFREQUENCY_MAX);
        }

        if(pCaps->dwMaxSecondarySampleRate)
        {
            pCaps->dwMaxSecondarySampleRate = BETWEEN(pCaps->dwMaxSecondarySampleRate, DSBFREQUENCY_MIN, DSBFREQUENCY_MAX);
        }

#endif // 0

        if(!(pCaps->dwFlags & DSCAPS_EMULDRIVER))
        {
            pCaps->dwPrimaryBuffers = 1;
        }
    }

    // Get certification
    if(SUCCEEDED(hr))
    {
        hr = g_pVadMgr->GetDriverCertificationStatus(m_pDevice, &dwCertification);
    }

    if(SUCCEEDED(hr) && VERIFY_CERTIFIED == dwCertification)
    {
        pCaps->dwFlags |= DSCAPS_CERTIFIED;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetCooperativeLevel
 *
 *  Description:
 *      Sets the object's cooperative level.
 *
 *  Arguments:
 *      HWND [in]: window handle to associate sounds with.
 *      DWORD [in]: cooperative level.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetCooperativeLevel"

HRESULT CDirectSound::SetCooperativeLevel(DWORD dwThreadId, DWORD dwPriority)
{
    HRESULT                 hr      = DS_OK;
    DSCOOPERATIVELEVEL      dsclOld;

    DPF_ENTER();
    RPF(DPFLVL_INFO, "Setting DirectSound cooperative level to %s",
        dwPriority == DSSCL_NORMAL ? TEXT("DSSCL_NORMAL") :
        dwPriority == DSSCL_PRIORITY ? TEXT("DSSCL_PRIORITY") :
        dwPriority == DSSCL_EXCLUSIVE ? TEXT("DSSCL_EXCLUSIVE (treated as DSSCL_PRIORITY)") :
        dwPriority == DSSCL_WRITEPRIMARY ? TEXT("DSSCL_WRITEPRIMARY") :
        TEXT("an impossible level"));

#if 0

    // COMPATCOMPAT: In previous versions of DirectSound, any number of
    // DirectSound objects could have cooperative level set on the same
    // thread, producing unknown results.  In this version, we fail the
    // call if any other app already has cooperative level set on the given
    // thread.

    // Make sure no other DirectSound object has cooperative level set on
    // this thread
    for(CNode<CDirectSound *> *pObjectNode = g_pDsAdmin->m_lstDirectSound.GetListHead(); pObjectNode && SUCCEEDED(hr); pObjectNode = pObjectNode->m_pNext)
    {
        if(this != pObjectNode->m_data && dwThreadId == pObjectNode->m_data->m_dsclCooperativeLevel.dwThreadId)
        {
            RPF(DPFLVL_ERROR, "Another DirectSound object already has coperative level set on the specified thread");
            hr = DSERR_OTHERAPPHASPRIO;
        }
    }

#endif

    // Save the current settings
    if(SUCCEEDED(hr))
    {
        CopyMemory(&dsclOld, &m_dsclCooperativeLevel, sizeof(dsclOld));
    }

    if(SUCCEEDED(hr) && (m_dsclCooperativeLevel.dwThreadId != dwThreadId || m_dsclCooperativeLevel.dwPriority != dwPriority))
    {
        // Update local copies of the cooperative level.  The primary buffer
        // and Administrator expect these to be updated right away.
        m_dsclCooperativeLevel.dwThreadId = dwThreadId;
        m_dsclCooperativeLevel.dwPriority = dwPriority;

        // Update the focus state.  It's important that this happens before
        // we update the primary buffer.  If we're going WRITEPRIMARY, we
        // need the Administrator to stop all our playing secondary buffers
        // before we allow the primary buffer to do its thing.

#ifdef SHARED_THREAD_LIST
        g_pDsAdmin->UpdateSharedThreadList();
#endif // SHARED_THREAD_LIST

        g_pDsAdmin->UpdateGlobalFocusState(TRUE);

        // Allow the primary buffer to handle the change
        hr = m_pPrimaryBuffer->SetPriority(dwPriority);

        // If we failed, put things back the way they were
        if(FAILED(hr))
        {
            CopyMemory(&m_dsclCooperativeLevel, &dsclOld, sizeof(dsclOld));

#ifdef SHARED_THREAD_LIST
            g_pDsAdmin->UpdateSharedThreadList();
#endif // SHARED_THREAD_LIST

        }

        // Update the focus state one more time
        g_pDsAdmin->UpdateGlobalFocusState(TRUE);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetSpeakerConfig
 *
 *  Description:
 *      Gets device speaker configuration.
 *
 *  Arguments:
 *      LPDWORD [out]: receives speaker configuration.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::GetSpeakerConfig"

HRESULT CDirectSound::GetSpeakerConfig(LPDWORD pdwSpeakerConfig)
{
    DPF_ENTER();

    RhRegGetSpeakerConfig(m_hkeyParent, pdwSpeakerConfig);
    // We don't care about the return code

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  SetSpeakerConfig
 *
 *  Description:
 *      Sets device speaker configuration.
 *
 *  Arguments:
 *      DWORD [in]: speaker configuration.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetSpeakerConfig"

HRESULT CDirectSound::SetSpeakerConfig(DWORD dwSpeakerConfig)
{
    DPF_ENTER();

    ASSERT(m_pDevice);

    // If the speaker config is STEREO and lacks a geometry, give it one:
    if (dwSpeakerConfig == DSSPEAKER_STEREO)
    {
        dwSpeakerConfig |= (DSSPEAKER_GEOMETRY_WIDE << 16);
    }

    // First we try to set the speaker configuration on the audio device.
    // This may well fail, since the device is already open and possibly
    // playing, and may not be able to reconfigure itself on the fly.
    HRESULT hr = m_pDevice->SetSpeakerConfig(dwSpeakerConfig);

    // If that succeeded, pass the speaker config to our 3D listener too
    if (SUCCEEDED(hr) && m_pPrimaryBuffer && m_pPrimaryBuffer->m_p3dListener)
    {
        m_pPrimaryBuffer->m_p3dListener->SetSpeakerConfig(dwSpeakerConfig);
    }

    // Regardless of the success or failure of the above, we must set the
    // new configuration in the registry
    RhRegSetSpeakerConfig(m_hkeyParent, dwSpeakerConfig);

    // Ignore any errors (for backwards compatibility)
    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  Compact
 *
 *  Description:
 *      Compacts memory used by the audio device to allocate buffers.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::Compact"

HRESULT CDirectSound::Compact(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Check access rights
    if(m_dsclCooperativeLevel.dwPriority < DSSCL_PRIORITY)
    {
        RPF(DPFLVL_ERROR, "Must set cooperative level to at least PRIORITY to compact memory");
        hr = DSERR_PRIOLEVELNEEDED;
    }

    // This function is not implemented in the device

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDeviceFormat
 *
 *  Description:
 *      Sets the device output format.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in/out]: device format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDeviceFormat"

HRESULT CDirectSound::SetDeviceFormat(LPWAVEFORMATEX pwfx)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = EnumStandardFormats(pwfx, pwfx) ? DS_OK : DSERR_ALLOCATED;

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDeviceFormatExact
 *
 *  Description:
 *      Sets the device output format.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDeviceFormatExact"

HRESULT CDirectSound::SetDeviceFormatExact(LPCWAVEFORMATEX pwfx)
{
    LPWAVEFORMATEX          pwfxCurrent = NULL;
    DWORD                   dwSize;
    HRESULT                 hr;

    DPF_ENTER();

    // Only change the format if it's different
    hr = m_pDevice->GetGlobalFormat(NULL, &dwSize);

    if(SUCCEEDED(hr))
    {
        pwfxCurrent = (LPWAVEFORMATEX)MEMALLOC_A(BYTE, dwSize);
        hr = HRFROMP(pwfxCurrent);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pDevice->GetGlobalFormat(pwfxCurrent, &dwSize);
    }

    if(SUCCEEDED(hr) && !CmpWfx(pwfxCurrent, pwfx))
    {
        hr = m_pDevice->SetGlobalFormat(pwfx);

        if(SUCCEEDED(hr))
        {
            DPF(DPFLVL_INFO, "Device output format set to %lu Hz, %u-bit, %s...", pwfx->nSamplesPerSec, pwfx->wBitsPerSample, (1 == pwfx->nChannels) ? TEXT("mono") : TEXT("stereo"));
        }
    }

    MEMFREE(pwfxCurrent);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  EnumStandardFormatsCallback
 *
 *  Description:
 *      Callback function for EnumStandardFormats used when calling
 *      CDirectSoundPrimaryBuffer::SetFormat.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: format.
 *
 *  Returns:
 *      BOOL: TRUE to continue enumerating.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::EnumStandardFormatsCallback"

BOOL CDirectSound::EnumStandardFormatsCallback(LPCWAVEFORMATEX pwfx)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = SetDeviceFormatExact(pwfx);

    DPF_LEAVE(FAILED(hr));

    return FAILED(hr);
}


/***************************************************************************
 *
 *  SetDeviceVolume
 *
 *  Description:
 *      Sets the device output volume.
 *
 *  Arguments:
 *      LONG [in]: volume.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDeviceVolume"

HRESULT CDirectSound::SetDeviceVolume(LONG lVolume)
{
    DSVOLUMEPAN             dsvp;
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice->GetGlobalAttenuation(&dsvp);

    if(SUCCEEDED(hr))
    {
        FillDsVolumePan(lVolume, dsvp.lPan, &dsvp);

        hr = m_pDevice->SetGlobalAttenuation(&dsvp);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetDevicePan
 *
 *  Description:
 *      Sets the device output pan.
 *
 *  Arguments:
 *      LONG [in]: pan.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::SetDevicePan"

HRESULT CDirectSound::SetDevicePan(LONG lPan)
{
    DSVOLUMEPAN             dsvp;
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pDevice->GetGlobalAttenuation(&dsvp);

    if(SUCCEEDED(hr))
    {
        FillDsVolumePan(dsvp.lVolume, lPan, &dsvp);

        hr = m_pDevice->SetGlobalAttenuation(&dsvp);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AllocSink
 *
 *  Description:
 *      Allocates a sink
 *
 *  Arguments:
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::AllocSink"

HRESULT CDirectSound::AllocSink(LPWAVEFORMATEX pwfex, CDirectSoundSink **ppSink)
{
    HRESULT                 hr = DS_OK;
    DPF_ENTER();

    CDirectSoundSink *pSink = NEW(CDirectSoundSink(this));

    hr = HRFROMP(pSink);

    if (SUCCEEDED(hr))
    {
        hr = pSink->Initialize(pwfex, m_pDevice->m_vdtDeviceType);
    }

    if (SUCCEEDED(hr))
    {
        *ppSink = pSink;
    }

    if (FAILED(hr))
    {
        MEMFREE(pSink);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  VerifyCertification
 *
 *  Description:
 *      Checks the certification status of the driver
 *
 *  Arguments:
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::VerifyCertification"

HRESULT CDirectSound::VerifyCertification(LPDWORD lpdwCertified)
{
    HRESULT                 hr = DS_OK;
    DWORD                   dwCertified;
    DPF_ENTER();

    hr = m_pDevice->GetCertification(&dwCertified, FALSE);

    if(SUCCEEDED(hr))
    {
        *lpdwCertified = ((VERIFY_CERTIFIED == dwCertified)?DS_CERTIFIED:DS_UNCERTIFIED);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#ifdef FUTURE_WAVE_SUPPORT
/***************************************************************************
 *
 *  CreateSoundBufferFromWave
 *
 *  Description:
 *      Checks the certification status of the driver
 *
 *  Arguments:
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSound::CreateSoundBufferFromWave"

HRESULT CDirectSound::CreateSoundBufferFromWave(IDirectSoundWave *pWave, DWORD dwFlags, CDirectSoundBuffer **ppDsBuffer)
{
    DPF_ENTER();
    HRESULT hr = DS_OK;

    // FIXME - to do

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // FUTURE_WAVE_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsmemmgr.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsmemmgr.h
 *  Content:    DirectSound memory manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/02/98    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSMEMMGR_H__
#define __DSMEMMGR_H__

#ifdef Not_VxD

#ifdef SHARED
#define SHARED_MEMORY_BOUNDARY  0x7FFFFFFF
#else
#define SHARED_MEMORY_BOUNDARY  0
#endif

#define IN_SHARED_MEMORY(p) \
            (((DWORD_PTR)(p)) > SHARED_MEMORY_BOUNDARY)

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern BOOL MemInit(void);
extern void MemFini(void);

#ifdef DEBUG
extern LPVOID MemAlloc(SIZE_T, LPCTSTR, UINT, LPCTSTR);
extern LPVOID MemAllocCopy(LPCVOID, SIZE_T, LPCTSTR, UINT, LPCTSTR);
#else // DEBUG
extern LPVOID MemAlloc(SIZE_T);
extern LPVOID MemAllocCopy(LPCVOID, SIZE_T);
#endif // DEBUG

extern void MemFree(LPVOID);

#ifdef __cplusplus
}
#endif // __cplusplus

#else // Not_VxD

#define MemAlloc(a) \
            _HeapAllocate(a, HEAPZEROINIT | HEAPSWAP)

#define MemFree(a) \
            _HeapFree(a, 0)

#endif // Not_VxD

#if defined(DEBUG) && defined(Not_VxD)

#define MEMALLOC_A(type, count) \
            ((type *)MemAlloc(sizeof(type) * (count), TEXT(__FILE__), __LINE__, NULL))

#define MEMALLOC_A_COPY(type, count, src) \
            ((type *)MemAllocCopy(src, sizeof(type) * (count), TEXT(__FILE__), __LINE__, NULL))

#else // defined(DEBUG) && defined(Not_VxD)

#define MEMALLOC_A(type, count) \
            ((type *)MemAlloc(sizeof(type) * (count)))

#define MEMALLOC_A_COPY(type, count, src) \
            ((type *)MemAllocCopy(src, sizeof(type) * (count)))

#endif // defined(DEBUG) && defined(Not_VxD)

#define MEMALLOC(type) \
            MEMALLOC_A(type, 1)

#define MEMALLOC_COPY(type, src) \
            MEMALLOC_A_COPY(type, 1, src)

#define MEMALLOC_HR(p, type) \
            HRFROMP(p = MEMALLOC(type))

#define MEMALLOC_A_HR(p, type, count) \
            HRFROMP(p = MEMALLOC_A(type, count))

#define MEMALLOC_COPY_HR(p, type, src) \
            HRFROMP(p = MEMALLOC_COPY(type, src))

#define MEMALLOC_A_COPY_HR(p, type, count, src) \
            HRFROMP(p = MEMALLOC_A_COPY(type, count, src))

#define MEMFREE(p) \
            if (p) MemFree(p), (p) = NULL

#endif // __DSMEMMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsobj.h
 *  Content:    DirectSound object
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifndef __DSOBJ_H__
#define __DSOBJ_H__

#ifdef __cplusplus

// Fwd decl
class CDirectSoundBuffer;
class CDirectSoundSink;

// The main DirectSound object
class CDirectSound
    : public CUnknown, private CUsesEnumStandardFormats
{
    friend class CDirectSoundPrimaryBuffer;
    friend class CDirectSoundSecondaryBuffer;
    friend class CDirectSoundAdministrator;
    friend class CDirectSoundPrivate;
    friend class CDirectSoundSink;
    friend class CDirectSoundFullDuplex;
#ifdef ENABLE_PERFLOG
    friend void OnPerflogStateChanged(void);
#endif

protected:
    CRenderDevice *                         m_pDevice;                  // The audio device
    CDirectSoundPrimaryBuffer *             m_pPrimaryBuffer;           // The one and only primary buffer
    CList<CDirectSoundSecondaryBuffer *>    m_lstSecondaryBuffers;      // List of all secondary buffers owned by this object
    DSCOOPERATIVELEVEL                      m_dsclCooperativeLevel;     // Cooperative level
    DSCAPS                                  m_dsc;                      // Device caps
    HKEY                                    m_hkeyParent;               // Root key for this device
    HRESULT                                 m_hrInit;                   // Has the object been initialized?
    DSAPPHACKS                              m_ahAppHacks;               // App hacks
    VmMode                                  m_vmmMode;                  // Voice manager mode

private:
    // Interfaces
    CImpDirectSound<CDirectSound> *m_pImpDirectSound;

public:
    CDirectSound(void);
    CDirectSound(CUnknown*);
    virtual ~CDirectSound(void);

public:
    // Creation
    virtual HRESULT Initialize(LPCGUID,CDirectSoundFullDuplex *);
    virtual HRESULT IsInit(void) {return m_hrInit;}

    // Functionality versioning
    virtual void SetDsVersion(DSVERSION);

    // Caps
    virtual HRESULT GetCaps(LPDSCAPS);

    // Sound buffer manipulation
    virtual HRESULT CreateSoundBuffer(LPCDSBUFFERDESC, CDirectSoundBuffer **);
    virtual HRESULT CreateSinkBuffer(LPDSBUFFERDESC, REFGUID, CDirectSoundSecondaryBuffer **, CDirectSoundSink *);
    virtual HRESULT DuplicateSoundBuffer(CDirectSoundBuffer *, CDirectSoundBuffer **);

    // Object properties
    virtual HRESULT GetSpeakerConfig(LPDWORD);
    virtual HRESULT SetSpeakerConfig(DWORD);

    // Misc
    virtual HRESULT SetCooperativeLevel(DWORD, DWORD);
    virtual HRESULT Compact(void);

    // IDirectSound8 methods
    virtual HRESULT VerifyCertification(LPDWORD);
#ifdef FUTURE_WAVE_SUPPORT
    virtual HRESULT CreateSoundBufferFromWave(IDirectSoundWave *, DWORD, CDirectSoundBuffer **);
#endif

    // IDirectSoundPrivate methods
    virtual HRESULT AllocSink(LPWAVEFORMATEX, CDirectSoundSink **);

protected:
    // Buffer creation
    virtual HRESULT CreatePrimaryBuffer(LPCDSBUFFERDESC, CDirectSoundBuffer **);
    virtual HRESULT CreateSecondaryBuffer(LPCDSBUFFERDESC, CDirectSoundBuffer **);

    // Device properties
    virtual HRESULT SetDeviceFormat(LPWAVEFORMATEX);
    virtual HRESULT SetDeviceFormatExact(LPCWAVEFORMATEX);
    virtual HRESULT SetDeviceVolume(LONG);
    virtual HRESULT SetDevicePan(LONG);

    // Misc
    virtual BOOL EnumStandardFormatsCallback(LPCWAVEFORMATEX);
};

#endif // __cplusplus

#endif // __DSOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsprvobj.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.cpp
 *  Content:    DirectSound Private Object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/05/97    dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"

typedef struct tagDEVICEPRESENCE
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA  Emulated;
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA  VxD;
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA  WDM;
} DEVICEPRESENCE, *LPDEVICEPRESENCE;

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSoundMixer)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY, CDirectSoundPrivate::GetMixerSrcQuality, CDirectSoundPrivate::SetMixerSrcQuality)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION, CDirectSoundPrivate::GetMixerAcceleration, CDirectSoundPrivate::SetMixerAcceleration)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSoundDevice)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1, CDirectSoundPrivate::GetDevicePresence1, CDirectSoundPrivate::SetDevicePresence1)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A, CDirectSoundPrivate::GetWaveDeviceMappingA, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1, CDirectSoundPrivate::GetDeviceDescription1, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1, CDirectSoundPrivate::EnumerateDevices1, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W, CDirectSoundPrivate::GetWaveDeviceMappingW, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A, CDirectSoundPrivate::GetDeviceDescriptionA, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W, CDirectSoundPrivate::GetDeviceDescriptionW, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A, CDirectSoundPrivate::EnumerateDevicesA, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W, CDirectSoundPrivate::EnumerateDevicesW, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE, CDirectSoundPrivate::GetDevicePresence, CDirectSoundPrivate::SetDevicePresence)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSoundBasicAcceleration)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION, CDirectSoundPrivate::GetBasicAcceleration, CDirectSoundPrivate::SetBasicAcceleration)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT, CDirectSoundPrivate::GetDefaultAcceleration, NULL)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSoundDebug)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A, CDirectSoundPrivate::GetDebugDpfInfoA, CDirectSoundPrivate::SetDebugDpfInfoA)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W, CDirectSoundPrivate::GetDebugDpfInfoW, CDirectSoundPrivate::SetDebugDpfInfoW)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A, CDirectSoundPrivate::TranslateResultCodeA, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W, CDirectSoundPrivate::TranslateResultCodeW, NULL)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSoundPersistentData)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A, CDirectSoundPrivate::GetPersistentDataA, CDirectSoundPrivate::SetPersistentDataA)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W, CDirectSoundPrivate::GetPersistentDataW, CDirectSoundPrivate::SetPersistentDataW)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSoundBuffer)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID, CDirectSoundPrivate::GetBufferDeviceId, NULL)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_HANDLERS(CDirectSoundPrivate, DSPROPSETID_DirectSound)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUND_OBJECTS, CDirectSoundPrivate::GetDirectSoundObjects, NULL)
    DECLARE_PROPERTY_HANDLER(DSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS, CDirectSoundPrivate::GetDirectSoundCaptureObjects, NULL)
END_DECLARE_PROPERTY_HANDLERS()

BEGIN_DECLARE_PROPERTY_SETS(CDirectSoundPrivate, m_aPropertySets)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSoundMixer)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSoundDevice)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSoundBasicAcceleration)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSoundDebug)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSoundPersistentData)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSoundBuffer)
    DECLARE_PROPERTY_SET(CDirectSoundPrivate, DSPROPSETID_DirectSound)
END_DECLARE_PROPERTY_SETS()


/***************************************************************************
 *
 *  CDirectSoundPrivate
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::CDirectSoundPrivate"

CDirectSoundPrivate::CDirectSoundPrivate
(
    void
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundPrivate);

    // Register the interface(s) with the interface manager.  Normally, this
    // would be done in the ::Initialize method, but because we support
    // creating an uninitialized DirectSound object from CoCreateInstance or
    // IClassFactory::CreateInstance, we have to give at least basic QI
    // support from here.  We don't have to worry about returning an
    // error code because if we run out of memory, QI will return
    // E_NOINTERFACE.
    CreateAndRegisterInterface(this, IID_IKsPropertySet, this, &m_pImpKsPropertySet);

    // Initialize the base class
    SetHandlerData(m_aPropertySets, NUMELMS(m_aPropertySets), this);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CDirectSoundPrivate
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::~CDirectSoundPrivate"

CDirectSoundPrivate::~CDirectSoundPrivate
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundPrivate);

    // Free all interfaces
    DELETE(m_pImpKsPropertySet);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetMixerSrcQuality
 *
 *  Description:
 *      Gets the mixer SRC quality for a particular device or the default.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetMixerSrcQuality"

HRESULT WINAPI
CDirectSoundPrivate::GetMixerSrcQuality
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA            pData,
    PULONG                                                  pcbData
)
{
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   Persist;
    ULONG                                                   cbPersist;
    HRESULT                                                 hr;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    pData->Quality = DIRECTSOUNDMIXER_SRCQUALITY_DEFAULT;

    Persist.DeviceId = pData->DeviceId;
    Persist.SubKeyName = REGSTR_MIXERDEFAULTS;
    Persist.ValueName = REGSTR_SRCQUALITY;
    Persist.RegistryDataType = REG_DWORD;
    Persist.Data = &pData->Quality;
    Persist.DataSize = sizeof(pData->Quality);

    cbPersist = sizeof(Persist);

    hr = GetPersistentData(pThis, &Persist, &cbPersist);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetMixerSrcQuality
 *
 *  Description:
 *      Sets the mixer SRC quality for a particular device or the default.
 *
 *  Arguments:
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetMixerSrcQuality"

HRESULT WINAPI
CDirectSoundPrivate::SetMixerSrcQuality
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA            pData,
    ULONG                                                   cbData
)
{
    CNode<CDirectSound *> *                                 pNode;
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   Persist;
    VADDEVICETYPE                                           vdt;
    HRESULT                                                 hr;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    Persist.DeviceId = pData->DeviceId;
    Persist.SubKeyName = REGSTR_MIXERDEFAULTS;
    Persist.ValueName = REGSTR_SRCQUALITY;
    Persist.RegistryDataType = REG_DWORD;
    Persist.Data = &pData->Quality;
    Persist.DataSize = sizeof(pData->Quality);

    hr = SetPersistentData(pThis, &Persist, sizeof(Persist));

    if(SUCCEEDED(hr))
    {
        vdt = g_pVadMgr->GetDriverDeviceType(pData->DeviceId);
    }

    if(SUCCEEDED(hr) && IS_RENDER_VAD(vdt))
    {
        for(pNode = g_pDsAdmin->m_lstDirectSound.GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            if(SUCCEEDED(pNode->m_data->IsInit()))
            {
                if(pData->DeviceId == pNode->m_data->m_pDevice->m_pDeviceDescription->m_guidDeviceId)
                {
                    pNode->m_data->m_pDevice->SetSrcQuality(pData->Quality);
                    break;
                }
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_INFO, DPF_GUID_STRING " SRC quality set to %lu", DPF_GUID_VAL(pData->DeviceId), pData->Quality);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetMixerAcceleration
 *
 *  Description:
 *      Gets mixer accleration settings for a particular device or the
 *      default.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetMixerAcceleration"

HRESULT WINAPI
CDirectSoundPrivate::GetMixerAcceleration
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA          pData,
    PULONG                                                  pcbData
)
{
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   Persist;
    ULONG                                                   cbPersist;
    HRESULT                                                 hr;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    pData->Flags = DIRECTSOUNDMIXER_ACCELERATIONF_DEFAULT;

    Persist.DeviceId = pData->DeviceId;
    Persist.SubKeyName = REGSTR_MIXERDEFAULTS;
    Persist.ValueName = REGSTR_ACCELERATION;
    Persist.RegistryDataType = REG_DWORD;
    Persist.Data = &pData->Flags;
    Persist.DataSize = sizeof(pData->Flags);

    cbPersist = sizeof(Persist);

    hr = GetPersistentData(pThis, &Persist, &cbPersist);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetMixerAcceleration
 *
 *  Description:
 *      Sets mixer accleration settings for a particular device or the
 *      default.
 *
 *  Arguments:
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetMixerAcceleration"

HRESULT WINAPI
CDirectSoundPrivate::SetMixerAcceleration
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA          pData,
    ULONG                                                   cbData
)
{
    CNode<CDirectSound *> *                                 pNode;
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   Persist;
    VADDEVICETYPE                                           vdt;
    HRESULT                                                 hr;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    Persist.DeviceId = pData->DeviceId;
    Persist.SubKeyName = REGSTR_MIXERDEFAULTS;
    Persist.ValueName = REGSTR_ACCELERATION;
    Persist.RegistryDataType = REG_DWORD;
    Persist.Data = &pData->Flags;
    Persist.DataSize = sizeof(pData->Flags);

    hr = SetPersistentData(pThis, &Persist, sizeof(Persist));

    if(SUCCEEDED(hr))
    {
        vdt = g_pVadMgr->GetDriverDeviceType(pData->DeviceId);
    }

    if(SUCCEEDED(hr) && IS_RENDER_VAD(vdt))
    {
        for(pNode = g_pDsAdmin->m_lstDirectSound.GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            if(SUCCEEDED(pNode->m_data->IsInit()))
            {
                if(pData->DeviceId == pNode->m_data->m_pDevice->m_pDeviceDescription->m_guidDeviceId)
                {
                    pNode->m_data->m_pDevice->SetAccelerationFlags(pData->Flags);
                    break;
                }
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_INFO, DPF_GUID_STRING " acceleration flags set to %lu", DPF_GUID_VAL(pData->DeviceId), pData->Flags);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDevicePresence
 *
 *  Description:
 *      Gets whether or not a device is present (enabled) in the system.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDevicePresence"

HRESULT WINAPI
CDirectSoundPrivate::GetDevicePresence
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA             pData,
    PULONG                                                  pcbData
)
{
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   Persist;
    ULONG                                                   cbPersist;
    HRESULT                                                 hr;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    pData->Present = TRUE;

    Persist.DeviceId = pData->DeviceId;
    Persist.SubKeyName = REGSTR_DEVICEPRESENCE;
    Persist.RegistryDataType = REG_DWORD;
    Persist.Data = &pData->Present;
    Persist.DataSize = sizeof(pData->Present);

    switch(pData->DeviceType)
    {
        case DIRECTSOUNDDEVICE_TYPE_EMULATED:
            Persist.ValueName = REGSTR_EMULATED;
            break;

        case DIRECTSOUNDDEVICE_TYPE_VXD:
            Persist.ValueName = REGSTR_VXD;
            break;

        case DIRECTSOUNDDEVICE_TYPE_WDM:
            Persist.ValueName = REGSTR_WDM;
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    cbPersist = sizeof(Persist);

    hr = GetPersistentData(pThis, &Persist, &cbPersist);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetDevicePresence
 *
 *  Description:
 *      Sets whether or not a device is present (enabled) in the system.
 *
 *  Arguments:
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetDevicePresence"

HRESULT WINAPI
CDirectSoundPrivate::SetDevicePresence
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA             pData,
    ULONG                                                   cbData
)
{
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   Persist;
    HRESULT                                                 hr;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    Persist.DeviceId = pData->DeviceId;
    Persist.SubKeyName = REGSTR_DEVICEPRESENCE;
    Persist.RegistryDataType = REG_DWORD;
    Persist.Data = &pData->Present;
    Persist.DataSize = sizeof(pData->Present);

    switch(pData->DeviceType)
    {
        case DIRECTSOUNDDEVICE_TYPE_EMULATED:
            Persist.ValueName = REGSTR_EMULATED;
            break;

        case DIRECTSOUNDDEVICE_TYPE_VXD:
            Persist.ValueName = REGSTR_VXD;
            break;

        case DIRECTSOUNDDEVICE_TYPE_WDM:
            Persist.ValueName = REGSTR_WDM;
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    hr = SetPersistentData(pThis, &Persist, sizeof(Persist));


    // The chagnes above could change the available drivers.
    // Let's reset the static driver list.
    DPF(DPFLVL_INFO, "Resetting static driver list");
    g_pVadMgr->FreeStaticDriverList();


    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_INFO, DPF_GUID_STRING " (%s) presence set to %lu", DPF_GUID_VAL(pData->DeviceId), Persist.ValueName, pData->Present);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDevicePresence1
 *
 *  Description:
 *      Gets whether or not a device is present (enabled) in the system.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDevicePresence1"

HRESULT WINAPI
CDirectSoundPrivate::GetDevicePresence1
(
    CDirectSoundPrivate *                           pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA   pData,
    PULONG                                          pcbData
)
{
    HRESULT                                         hr      = DS_OK;
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA      Data;
    VADDEVICETYPE                                   vdt;
    ULONG                                           cbData;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    vdt = g_pVadMgr->GetDriverDeviceType(pData->DeviceId);

    if(!vdt)
    {
        RPF(DPFLVL_ERROR, "Invalid device GUID: " DPF_GUID_STRING, DPF_GUID_VAL(pData->DeviceId));
        hr = DSERR_NODRIVER;
    }

    if(SUCCEEDED(hr))
    {
        cbData = sizeof(Data);

        Data.DeviceId = pData->DeviceId;

        switch(vdt)
        {
            case VAD_DEVICETYPE_EMULATEDRENDER:
            case VAD_DEVICETYPE_EMULATEDCAPTURE:
                Data.DeviceType = DIRECTSOUNDDEVICE_TYPE_EMULATED;
                break;

            case VAD_DEVICETYPE_VXDRENDER:
                Data.DeviceType = DIRECTSOUNDDEVICE_TYPE_VXD;
                break;

            case VAD_DEVICETYPE_KSRENDER:
            case VAD_DEVICETYPE_KSCAPTURE:
                Data.DeviceType = DIRECTSOUNDDEVICE_TYPE_WDM;
                break;

            default:
                ASSERT(FALSE);
                break;
        }

        hr = GetDevicePresence(pThis, &Data, &cbData);
    }

    if(SUCCEEDED(hr))
    {
        pData->Present = Data.Present;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetDevicePresence1
 *
 *  Description:
 *      Sets whether or not a device is present (enabled) in the system.
 *
 *  Arguments:
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetDevicePresence1"

HRESULT WINAPI
CDirectSoundPrivate::SetDevicePresence1
(
    CDirectSoundPrivate *                           pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA   pData,
    ULONG                                           cbData
)
{
    HRESULT                                         hr      = DS_OK;
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA      Data;
    VADDEVICETYPE                                   vdt;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    vdt = g_pVadMgr->GetDriverDeviceType(pData->DeviceId);

    if(!vdt)
    {
        RPF(DPFLVL_ERROR, "Invalid device GUID: " DPF_GUID_STRING, DPF_GUID_VAL(pData->DeviceId));
        hr = DSERR_NODRIVER;
    }

    if(SUCCEEDED(hr))
    {
        Data.DeviceId = pData->DeviceId;
        Data.Present = pData->Present;

        switch(vdt)
        {
            case VAD_DEVICETYPE_EMULATEDRENDER:
            case VAD_DEVICETYPE_EMULATEDCAPTURE:
                Data.DeviceType = DIRECTSOUNDDEVICE_TYPE_EMULATED;
                break;

            case VAD_DEVICETYPE_VXDRENDER:
                Data.DeviceType = DIRECTSOUNDDEVICE_TYPE_VXD;
                break;

            case VAD_DEVICETYPE_KSRENDER:
            case VAD_DEVICETYPE_KSCAPTURE:
                Data.DeviceType = DIRECTSOUNDDEVICE_TYPE_WDM;
                break;

            default:
                ASSERT(FALSE);
                break;
        }

        hr = SetDevicePresence(pThis, &Data, sizeof(Data));
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetWaveDeviceMapping
 *
 *  Description:
 *      Gets the DirectSound device GUID based on a waveOut/waveIn device
 *      description string.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetWaveDeviceMapping"

HRESULT WINAPI
CDirectSoundPrivate::GetWaveDeviceMapping
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA    pData,
    PULONG                                                  pcbData
)
{
    const UINT                                              cWaveOutDevs    = waveOutGetNumDevs();
    const UINT                                              cWaveInDevs     = waveInGetNumDevs();
    HRESULT                                                 hr              = DS_OK;
    CObjectList<CDeviceDescription>                         lstDrivers;
    CNode<CDeviceDescription *> *                           pDriverNode;
    WAVEOUTCAPS                                             woc;
    WAVEINCAPS                                              wic;
    UINT                                                    uId;
    MMRESULT                                                mmr;
    VADDEVICETYPE                                           vdt;

    DPF_ENTER();

    if (pData == NULL)
    {
        hr = E_POINTER;
        DPF_LEAVE_HRESULT(hr);
        return hr;
    }

    ASSERT(*pcbData >= sizeof(*pData));

    DPF(DPFLVL_INFO, "Looking for %s", pData->DeviceName);

    switch(pData->DataFlow)
    {
        case DIRECTSOUNDDEVICE_DATAFLOW_RENDER:
            vdt = VAD_DEVICETYPE_RENDERMASK;

            for(uId = 0; uId < cWaveOutDevs; uId++)
            {
                mmr = waveOutGetDevCaps(uId, &woc, sizeof(woc));
                if(MMSYSERR_NOERROR == mmr && !lstrcmp(woc.szPname, pData->DeviceName))
                    break;
            }

            if(uId >= cWaveOutDevs)
            {
                RPF(DPFLVL_ERROR, "Invalid waveOut device string: %s", pData->DeviceName);
                hr = DSERR_NODRIVER;
            }

            break;

        case DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE:
            vdt = VAD_DEVICETYPE_CAPTUREMASK;

            for(uId = 0; uId < cWaveInDevs; uId++)
            {
                mmr = waveInGetDevCaps(uId, &wic, sizeof(wic));
                if(MMSYSERR_NOERROR == mmr && !lstrcmp(wic.szPname, pData->DeviceName))
                    break;
            }

            if(uId >= cWaveInDevs)
            {
                RPF(DPFLVL_ERROR, "Invalid waveIn device string: %s", pData->DeviceName);
                hr = DSERR_NODRIVER;
            }

            break;

        default:
            RPF(DPFLVL_ERROR, "Invalid data flow: %lu", pData->DataFlow);
            hr = DSERR_INVALIDPARAM;
            break;
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_INFO, "Wave device id: %lu", uId);
    }

    if(SUCCEEDED(hr))
    {
        hr = g_pVadMgr->EnumDrivers(vdt, VAD_ENUMDRIVERS_ORDER, &lstDrivers);
    }

    if(SUCCEEDED(hr))
    {
        for(pDriverNode = lstDrivers.GetListHead(); pDriverNode; pDriverNode = pDriverNode->m_pNext)
            if(uId == pDriverNode->m_data->m_uWaveDeviceId)
                break;

        if(!pDriverNode)
        {
            RPF(DPFLVL_ERROR, "Can't find matching DirectSound device");
            hr = DSERR_NODRIVER;
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_INFO, "Found matching device: %s " DPF_GUID_STRING, (LPCTSTR)pDriverNode->m_data->m_strName, DPF_GUID_VAL(pDriverNode->m_data->m_guidDeviceId));
        pData->DeviceId = pDriverNode->m_data->m_guidDeviceId;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetWaveDeviceMappingA"

HRESULT WINAPI
CDirectSoundPrivate::GetWaveDeviceMappingA
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA  pData,
    PULONG                                                  pcbData
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA     LocalData;
    ULONG                                                   cbLocalData;
    HRESULT                                                 hr;

    DPF_ENTER();

    LocalData.DeviceName = AnsiToTcharAlloc(pData->DeviceName);
    LocalData.DataFlow = pData->DataFlow;

    cbLocalData = sizeof(LocalData);

    hr = GetWaveDeviceMapping(pThis, &LocalData, &cbLocalData);

    if(SUCCEEDED(hr))
    {
        pData->DeviceId = LocalData.DeviceId;
    }

    MEMFREE(LocalData.DeviceName);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetWaveDeviceMappingW"

HRESULT WINAPI
CDirectSoundPrivate::GetWaveDeviceMappingW
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA  pData,
    PULONG                                                  pcbData
)
{
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA     LocalData;
    ULONG                                                   cbLocalData;
    HRESULT                                                 hr;

    DPF_ENTER();

    LocalData.DeviceName = UnicodeToTcharAlloc(pData->DeviceName);
    LocalData.DataFlow = pData->DataFlow;

    cbLocalData = sizeof(LocalData);

    hr = GetWaveDeviceMapping(pThis, &LocalData, &cbLocalData);

    if(SUCCEEDED(hr))
    {
        pData->DeviceId = LocalData.DeviceId;
    }

    MEMFREE(LocalData.DeviceName);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDeviceDescriptionA
 *
 *  Description:
 *      Gets the device description for a given DirectSound driver GUID.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDeviceDescriptionA"

HRESULT WINAPI
CDirectSoundPrivate::GetDeviceDescriptionA
(
    CDirectSoundPrivate *                               pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA    pData,
    PULONG                                              pcbData
)
{
    CDeviceDescription *                                pDesc   = NULL;
    HRESULT                                             hr;

    DPF_ENTER();

    hr = pData == NULL ? E_POINTER : S_OK;

    if (SUCCEEDED(hr))
    {
        ASSERT(*pcbData >= sizeof(*pData));

        if (IS_NULL_GUID(&pData->DeviceId))
            pData->DeviceId = (pData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER) ? DSDEVID_DefaultPlayback : DSDEVID_DefaultCapture;

        hr = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);

        if(SUCCEEDED(hr))
            hr = CvtDriverDescA(pDesc, pData, pcbData);

        RELEASE(pDesc);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDeviceDescriptionW"

HRESULT WINAPI
CDirectSoundPrivate::GetDeviceDescriptionW
(
    CDirectSoundPrivate *                               pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA    pData,
    PULONG                                              pcbData
)
{
    CDeviceDescription *                                pDesc   = NULL;
    HRESULT                                             hr;

    DPF_ENTER();

    hr = pData == NULL ? E_POINTER : S_OK;

    if (SUCCEEDED(hr))
    {
        ASSERT(*pcbData >= sizeof(*pData));

        if (IS_NULL_GUID(&pData->DeviceId))
            pData->DeviceId = (pData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER) ? DSDEVID_DefaultPlayback : DSDEVID_DefaultCapture;

        hr = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);

        if(SUCCEEDED(hr))
            hr = CvtDriverDescW(pDesc, pData, pcbData);

        RELEASE(pDesc);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDeviceDescription1"

HRESULT WINAPI
CDirectSoundPrivate::GetDeviceDescription1
(
    CDirectSoundPrivate *                               pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA    pData,
    PULONG                                              pcbData
)
{
    CDeviceDescription *                                pDesc   = NULL;
    HRESULT                                             hr;

    DPF_ENTER();

    hr = pData == NULL ? E_POINTER : S_OK;

    if (SUCCEEDED(hr))
    {
        ASSERT(*pcbData >= sizeof(*pData));

        if (IS_NULL_GUID(&pData->DeviceId))
            pData->DeviceId = (pData->DataFlow == DIRECTSOUNDDEVICE_DATAFLOW_RENDER) ? DSDEVID_DefaultPlayback : DSDEVID_DefaultCapture;

        hr = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);

        if(SUCCEEDED(hr))
            hr = CvtDriverDesc1(pDesc, pData);

        RELEASE(pDesc);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  EnumerateDevices
 *
 *  Description:
 *      Enumerates all DirectSound devices.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::EnumerateDevicesA"

HRESULT WINAPI
CDirectSoundPrivate::EnumerateDevicesA
(
    CDirectSoundPrivate *                               pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA      pData,
    PULONG                                              pcbData
)
{
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA    pDesc       = NULL;
    ULONG                                               cbDesc      = 0;
    BOOL                                                fContinue   = TRUE;
    HRESULT                                             hr          = DS_OK;
    CObjectList<CDeviceDescription>                     lstDrivers;
    CNode<CDeviceDescription *> *                       pNode;

    DPF_ENTER();

    hr = g_pVadMgr->EnumDrivers(VAD_DEVICETYPE_VALIDMASK, VAD_ENUMDRIVERS_ORDER, &lstDrivers);

    for(pNode = lstDrivers.GetListHead(); pNode && SUCCEEDED(hr) && fContinue; pNode = pNode->m_pNext)
    {
        hr = CvtDriverDescA(pNode->m_data, NULL, &cbDesc);

        if(SUCCEEDED(hr))
        {
            pDesc = (PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA)MEMALLOC_A(BYTE, cbDesc);
            hr = HRFROMP(pDesc);
        }

        if(SUCCEEDED(hr))
        {
            hr = CvtDriverDescA(pNode->m_data, pDesc, &cbDesc);
        }

        if(SUCCEEDED(hr))
        {
            fContinue = pData->Callback(pDesc, pData->Context);
        }

        MEMFREE(pDesc);
        cbDesc = 0;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::EnumerateDevicesW"

HRESULT WINAPI
CDirectSoundPrivate::EnumerateDevicesW
(
    CDirectSoundPrivate *                               pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA      pData,
    PULONG                                              pcbData
)
{
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA    pDesc       = NULL;
    ULONG                                               cbDesc      = 0;
    BOOL                                                fContinue   = TRUE;
    HRESULT                                             hr          = DS_OK;
    CObjectList<CDeviceDescription>                     lstDrivers;
    CNode<CDeviceDescription *> *                       pNode;

    DPF_ENTER();

    hr = g_pVadMgr->EnumDrivers(VAD_DEVICETYPE_VALIDMASK, VAD_ENUMDRIVERS_ORDER, &lstDrivers);

    for(pNode = lstDrivers.GetListHead(); pNode && SUCCEEDED(hr) && fContinue; pNode = pNode->m_pNext)
    {
        hr = CvtDriverDescW(pNode->m_data, NULL, &cbDesc);

        if(SUCCEEDED(hr))
        {
            pDesc = (PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA)MEMALLOC_A(BYTE, cbDesc);
            hr = HRFROMP(pDesc);
        }

        if(SUCCEEDED(hr))
        {
            hr = CvtDriverDescW(pNode->m_data, pDesc, &cbDesc);
        }

        if(SUCCEEDED(hr))
        {
            fContinue = pData->Callback(pDesc, pData->Context);
        }

        MEMFREE(pDesc);
        cbDesc = 0;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::EnumerateDevices1"

HRESULT WINAPI
CDirectSoundPrivate::EnumerateDevices1
(
    CDirectSoundPrivate *                               pThis,
    PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA      pData,
    PULONG                                              pcbData
)
{
    BOOL                                                fContinue   = TRUE;
    HRESULT                                             hr          = DS_OK;
    CObjectList<CDeviceDescription>                     lstDrivers;
    CNode<CDeviceDescription *> *                       pNode;
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA     Desc;

    DPF_ENTER();

    hr = g_pVadMgr->EnumDrivers(VAD_DEVICETYPE_VALIDMASK, VAD_ENUMDRIVERS_ORDER, &lstDrivers);

    for(pNode = lstDrivers.GetListHead(); pNode && SUCCEEDED(hr) && fContinue; pNode = pNode->m_pNext)
    {
        hr = CvtDriverDesc1(pNode->m_data, &Desc);

        if(SUCCEEDED(hr))
        {
            fContinue = pData->Callback(&Desc, pData->Context);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDebugDpfInfoA
 *
 *  Description:
 *      Gets DPF data.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDebugDpfInfoA"

HRESULT WINAPI
CDirectSoundPrivate::GetDebugDpfInfoA
(
    CDirectSoundPrivate *                       pThis,
    PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA pData,
    PULONG                                      pcbData
)
{
    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

#ifdef RDEBUG

    pData->Flags = g_dinfo.Data.Flags;
    pData->DpfLevel = g_dinfo.Data.DpfLevel;
    pData->BreakLevel = g_dinfo.Data.BreakLevel;
    TcharToAnsi(g_dinfo.Data.LogFile, pData->LogFile, NUMELMS(pData->LogFile));

#else // RDEBUG

    pData->Flags = pData->DpfLevel = pData->BreakLevel = 0;
    pData->LogFile[0] = '\0';

#endif // RDEBUG

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDebugDpfInfoW"

HRESULT WINAPI
CDirectSoundPrivate::GetDebugDpfInfoW
(
    CDirectSoundPrivate *                       pThis,
    PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA pData,
    PULONG                                      pcbData
)
{
    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

#ifdef RDEBUG

    pData->Flags = g_dinfo.Data.Flags;
    pData->DpfLevel = g_dinfo.Data.DpfLevel;
    pData->BreakLevel = g_dinfo.Data.BreakLevel;
    TcharToUnicode(g_dinfo.Data.LogFile, pData->LogFile, NUMELMS(pData->LogFile));

#else // RDEBUG

    pData->Flags = pData->DpfLevel = pData->BreakLevel = 0;
    pData->LogFile[0] = '\0';

#endif // RDEBUG

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  SetDebugDpfInfo
 *
 *  Description:
 *      Sets DPF data.
 *
 *  Arguments:
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetDebugDpfInfoA"

HRESULT
CDirectSoundPrivate::SetDebugDpfInfoA
(
    CDirectSoundPrivate *                       pThis,
    PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA pData,
    ULONG                                       cbData
)
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA    LocalData;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

#ifdef RDEBUG

    LocalData.Flags = pData->Flags;
    LocalData.DpfLevel = pData->DpfLevel;
    LocalData.BreakLevel = pData->BreakLevel;
    AnsiToTchar(pData->LogFile, LocalData.LogFile, NUMELMS(LocalData.LogFile));
    dopen(&LocalData);

#endif // RDEBUG

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetDebugDpfInfoW"

HRESULT
CDirectSoundPrivate::SetDebugDpfInfoW
(
    CDirectSoundPrivate *                       pThis,
    PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA pData,
    ULONG                                       cbData
)
{
    DSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_DATA    LocalData;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

#ifdef RDEBUG

    LocalData.Flags = pData->Flags;
    LocalData.DpfLevel = pData->DpfLevel;
    LocalData.BreakLevel = pData->BreakLevel;
    UnicodeToTchar(pData->LogFile, LocalData.LogFile, NUMELMS(LocalData.LogFile));
    dopen(&LocalData);

#endif // RDEBUG

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  TranslateResultCode
 *
 *  Description:
 *      Translates an error code to a friendly string.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::TranslateResultCodeA"

HRESULT WINAPI
CDirectSoundPrivate::TranslateResultCodeA
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA pData,
    PULONG                                                  pcbData
)
{
    TCHAR                                                   szString[0x100];
    TCHAR                                                   szExplanation[0x100];
    ULONG                                                   ccString;
    ULONG                                                   cbString;
    ULONG                                                   ibString;
    ULONG                                                   ccExplanation;
    ULONG                                                   cbExplanation;
    ULONG                                                   ibExplanation;
    ULONG                                                   cbRequired;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    HresultToString(pData->ResultCode, szString, NUMELMS(szString), szExplanation, NUMELMS(szExplanation));

    ccString = TcharToAnsi(szString, NULL, 0);
    cbString = ccString * sizeof(CHAR);

    ccExplanation = TcharToAnsi(szExplanation, NULL, 0);
    cbExplanation = ccExplanation * sizeof(CHAR);

    cbRequired = sizeof(*pData);

    ibString = cbRequired;
    cbRequired += cbString;

    ibExplanation = cbRequired;
    cbRequired += cbExplanation;

    if(*pcbData >= cbRequired)
    {
        pData->String = (LPSTR)((LPBYTE)pData + ibString);
        TcharToAnsi(szString, pData->String, ccString);

        pData->Explanation = (LPSTR)((LPBYTE)pData + ibExplanation);
        TcharToAnsi(szExplanation, pData->Explanation, ccExplanation);
    }

    *pcbData = cbRequired;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::TranslateResultCodeW"

HRESULT WINAPI
CDirectSoundPrivate::TranslateResultCodeW
(
    CDirectSoundPrivate *                                   pThis,
    PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA pData,
    PULONG                                                  pcbData
)
{
    TCHAR                                                   szString[0x100];
    TCHAR                                                   szExplanation[0x100];
    ULONG                                                   ccString;
    ULONG                                                   cbString;
    ULONG                                                   ibString;
    ULONG                                                   ccExplanation;
    ULONG                                                   cbExplanation;
    ULONG                                                   ibExplanation;
    ULONG                                                   cbRequired;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    HresultToString(pData->ResultCode, szString, NUMELMS(szString), szExplanation, NUMELMS(szExplanation));

    ccString = TcharToUnicode(szString, NULL, 0);
    cbString = ccString * sizeof(WCHAR);

    ccExplanation = TcharToUnicode(szExplanation, NULL, 0);
    cbExplanation = ccExplanation * sizeof(WCHAR);

    cbRequired = sizeof(*pData);

    ibString = cbRequired;
    cbRequired += cbString;

    ibExplanation = cbRequired;
    cbRequired += cbExplanation;

    if(*pcbData >= cbRequired)
    {
        pData->String = (LPWSTR)((LPBYTE)pData + ibString);
        TcharToUnicode(szString, pData->String, ccString);

        pData->Explanation = (LPWSTR)((LPBYTE)pData + ibExplanation);
        TcharToUnicode(szExplanation, pData->Explanation, ccExplanation);
    }

    *pcbData = cbRequired;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  GetDefaultAcceleration
 *
 *  Description:
 *      Gets default acceleration level.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDefaultAcceleration"

HRESULT WINAPI
CDirectSoundPrivate::GetDefaultAcceleration
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT_DATA       pData,
    PULONG                                                      pcbData
)
{
    HRESULT                                                     hr              = DS_OK;
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA               Acceleration;
    DEVICEPRESENCE                                              DevicePresence;
    ULONG                                                       cb;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    Acceleration.DeviceId = pData->DeviceId;

    DevicePresence.Emulated.DeviceId = pData->DeviceId;
    DevicePresence.Emulated.DeviceType = DIRECTSOUNDDEVICE_TYPE_EMULATED;

    DevicePresence.VxD.DeviceId = pData->DeviceId;
    DevicePresence.VxD.DeviceType = DIRECTSOUNDDEVICE_TYPE_VXD;

    DevicePresence.WDM.DeviceId = pData->DeviceId;
    DevicePresence.WDM.DeviceType = DIRECTSOUNDDEVICE_TYPE_WDM;

    // Get Default Mixer Acceleration
    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   DefaultMixer;
    ULONG                                                   cbDefaultMixer;

    Acceleration.Flags = DIRECTSOUNDMIXER_ACCELERATIONF_DEFAULT;

    DefaultMixer.DeviceId = Acceleration.DeviceId;
    DefaultMixer.SubKeyName = REGSTR_MIXERDEFAULTS;
    DefaultMixer.ValueName = REGSTR_ACCELERATION;
    DefaultMixer.RegistryDataType = REG_DWORD;
    DefaultMixer.Data = &Acceleration.Flags;
    DefaultMixer.DataSize = sizeof(Acceleration.Flags);

    cbDefaultMixer = sizeof(DefaultMixer);

    hr = GetDefaultData(pThis, &DefaultMixer, &cbDefaultMixer);


    // Get Device Presence

    DSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA   DefaultDevice;
    ULONG                                                   cbDefaultDevice;

    // Emulated
    if (SUCCEEDED (hr))
    {
        DevicePresence.Emulated.Present = TRUE;

        DefaultDevice.DeviceId = DevicePresence.Emulated.DeviceId;
        DefaultDevice.SubKeyName = REGSTR_DEVICEPRESENCE;
        DefaultDevice.RegistryDataType = REG_DWORD;
        DefaultDevice.Data = &DevicePresence.Emulated.Present;
        DefaultDevice.DataSize = sizeof(DevicePresence.Emulated.Present);

        DefaultDevice.ValueName = REGSTR_EMULATED;



        cbDefaultDevice = sizeof(DefaultDevice);

        hr = GetDefaultData(pThis, &DefaultDevice, &cbDefaultDevice);
    }

    // VxD

    if (SUCCEEDED (hr))
    {
        DevicePresence.VxD.Present = TRUE;

        DefaultDevice.DeviceId = DevicePresence.VxD.DeviceId;
        DefaultDevice.SubKeyName = REGSTR_DEVICEPRESENCE;
        DefaultDevice.RegistryDataType = REG_DWORD;
        DefaultDevice.Data = &DevicePresence.VxD.Present;
        DefaultDevice.DataSize = sizeof(DevicePresence.VxD.Present);

        DefaultDevice.ValueName = REGSTR_VXD;

        cbDefaultDevice = sizeof(DefaultDevice);

        hr = GetDefaultData(pThis, &DefaultDevice, &cbDefaultDevice);
    }

   // WDM

    if (SUCCEEDED (hr))
    {
        DevicePresence.WDM.Present = TRUE;

        DefaultDevice.DeviceId = DevicePresence.WDM.DeviceId;
        DefaultDevice.SubKeyName = REGSTR_DEVICEPRESENCE;
        DefaultDevice.RegistryDataType = REG_DWORD;
        DefaultDevice.Data = &DevicePresence.WDM.Present;
        DefaultDevice.DataSize = sizeof(DevicePresence.WDM.Present);

        DefaultDevice.ValueName = REGSTR_WDM;

        cbDefaultDevice = sizeof(DefaultDevice);

        hr = GetDefaultData(pThis, &DefaultDevice, &cbDefaultDevice);
    }


    // Return Default


    if(SUCCEEDED(hr))
    {
        if(!DevicePresence.VxD.Present && !DevicePresence.WDM.Present)
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_NONE;
        }
        else if(DIRECTSOUNDMIXER_ACCELERATIONF_FULL == Acceleration.Flags)
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_FULL;
        }
        else if((Acceleration.Flags & DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD) && !(Acceleration.Flags & ~DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD))
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_STANDARD;
        }
        else
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_SAFE;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetBasicAcceleration
 *
 *  Description:
 *      Gets basic acceleration level.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetBasicAcceleration"

HRESULT WINAPI
CDirectSoundPrivate::GetBasicAcceleration
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA  pData,
    PULONG                                                      pcbData
)
{
    HRESULT                                                     hr              = DS_OK;
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA               Acceleration;
    DEVICEPRESENCE                                              DevicePresence;
    ULONG                                                       cb;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    Acceleration.DeviceId = pData->DeviceId;

    DevicePresence.Emulated.DeviceId = pData->DeviceId;
    DevicePresence.Emulated.DeviceType = DIRECTSOUNDDEVICE_TYPE_EMULATED;

    DevicePresence.VxD.DeviceId = pData->DeviceId;
    DevicePresence.VxD.DeviceType = DIRECTSOUNDDEVICE_TYPE_VXD;

    DevicePresence.WDM.DeviceId = pData->DeviceId;
    DevicePresence.WDM.DeviceType = DIRECTSOUNDDEVICE_TYPE_WDM;

    if(SUCCEEDED(hr))
    {
        cb = sizeof(Acceleration);
        hr = GetMixerAcceleration(pThis, &Acceleration, &cb);
    }

    if(SUCCEEDED(hr))
    {
        cb = sizeof(DevicePresence.Emulated);
        hr = GetDevicePresence(pThis, &DevicePresence.Emulated, &cb);
    }

    if(SUCCEEDED(hr))
    {
        cb = sizeof(DevicePresence.VxD);
        hr = GetDevicePresence(pThis, &DevicePresence.VxD, &cb);
    }

    if(SUCCEEDED(hr))
    {
        cb = sizeof(DevicePresence.WDM);
        hr = GetDevicePresence(pThis, &DevicePresence.WDM, &cb);
    }

    if(SUCCEEDED(hr))
    {
        if(!DevicePresence.VxD.Present && !DevicePresence.WDM.Present)
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_NONE;
        }
        else if(DIRECTSOUNDMIXER_ACCELERATIONF_FULL == Acceleration.Flags)
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_FULL;
        }
        else if((Acceleration.Flags & DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD) && !(Acceleration.Flags & ~DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD))
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_STANDARD;
        }
        else
        {
            pData->Level = DIRECTSOUNDBASICACCELERATION_SAFE;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetBasicAcceleration
 *
 *  Description:
 *      Sets basic acceleration level.
 *
 *  Arguments:
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetBasicAcceleration"

HRESULT WINAPI
CDirectSoundPrivate::SetBasicAcceleration
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA  pData,
    ULONG                                                       cbData
)
{
    DSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA               Acceleration;
    DEVICEPRESENCE                                              DevicePresence;
    HRESULT                                                     hr;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    Acceleration.DeviceId = pData->DeviceId;

    DevicePresence.Emulated.DeviceId = pData->DeviceId;
    DevicePresence.Emulated.DeviceType = DIRECTSOUNDDEVICE_TYPE_EMULATED;
    DevicePresence.Emulated.Present = TRUE;

    DevicePresence.VxD.DeviceId = pData->DeviceId;
    DevicePresence.VxD.DeviceType = DIRECTSOUNDDEVICE_TYPE_VXD;
    DevicePresence.VxD.Present = TRUE;

    DevicePresence.WDM.DeviceId = pData->DeviceId;
    DevicePresence.WDM.DeviceType = DIRECTSOUNDDEVICE_TYPE_WDM;
    DevicePresence.WDM.Present = TRUE;

    switch(pData->Level)
    {
        case DIRECTSOUNDBASICACCELERATION_NONE:
            Acceleration.Flags = DIRECTSOUNDMIXER_ACCELERATIONF_NONE;

            DevicePresence.VxD.Present = FALSE;
            DevicePresence.WDM.Present = FALSE;

            break;

        case DIRECTSOUNDBASICACCELERATION_SAFE:
            Acceleration.Flags = DIRECTSOUNDMIXER_ACCELERATIONF_NONE;

            break;

        case DIRECTSOUNDBASICACCELERATION_STANDARD:
            Acceleration.Flags = DIRECTSOUNDMIXER_ACCELERATIONF_STANDARD;

            break;

        case DIRECTSOUNDBASICACCELERATION_FULL:
            Acceleration.Flags = DIRECTSOUNDMIXER_ACCELERATIONF_FULL;

            break;

        default:
            RPF(DPFLVL_ERROR, "Invalid basic acceleration level: %lu", pData->Level);
            hr = DSERR_INVALIDPARAM;
            break;
    }

    hr = SetMixerAcceleration(pThis, &Acceleration, sizeof(Acceleration));

    if(SUCCEEDED(hr))
    {
        hr = SetDevicePresence(pThis, &DevicePresence.Emulated, sizeof(DevicePresence.Emulated));
    }

    if(SUCCEEDED(hr))
    {
        hr = SetDevicePresence(pThis, &DevicePresence.VxD, sizeof(DevicePresence.VxD));
    }

    if(SUCCEEDED(hr))
    {
        hr = SetDevicePresence(pThis, &DevicePresence.WDM, sizeof(DevicePresence.WDM));
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDefaultData
 *
 *  Description:
 *      Gets default data from the registry.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDefaultDataA"

HRESULT WINAPI
CDirectSoundPrivate::GetDefaultDataA
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA    pData,
    PULONG                                                      pcbData
)
{
    HKEY                                                        hkeyParent  = NULL;
    HKEY                                                        hkey        = NULL;
    HRESULT                                                     hr          = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));


    HKEY hkeyDefault;
    CDeviceDescription * pDesc = NULL;
    HRESULT hrT;

    hrT = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);
    if (SUCCEEDED(hrT))
    {
        if (IS_RENDER_VAD(pDesc->m_vdtDeviceType))
        {
            // Check for default persistent data
            hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, pData->SubKeyName);
        }
        else
        {
            hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUNDCAPTURE, 1, pData->SubKeyName);
        }

        if(SUCCEEDED(hrT))
        {
            hrT = RhRegGetValueA(hkeyDefault, pData->ValueName, &pData->RegistryDataType, pData->Data, pData->DataSize, &pData->DataSize);
            RhRegCloseKey(&hkeyDefault);
        }

        RELEASE(pDesc);

        if (SUCCEEDED(hrT)) hr = hrT;
    }


    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDefaultDataW"

HRESULT WINAPI
CDirectSoundPrivate::GetDefaultDataW
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA    pData,
    PULONG                                                      pcbData
)
{
    HKEY                                                        hkeyParent  = NULL;
    HKEY                                                        hkey        = NULL;
    HRESULT                                                     hr          = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    HKEY hkeyDefault;
    CDeviceDescription * pDesc = NULL;
    HRESULT hrT;

    hrT = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);
    if (SUCCEEDED(hrT))
    {
        if (IS_RENDER_VAD(pDesc->m_vdtDeviceType)) {
                // Check for default persistent data
                hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, pData->SubKeyName);
        } else {
                hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUNDCAPTURE, 1, pData->SubKeyName);
        }

        if(SUCCEEDED(hrT))
        {
            hrT = RhRegGetValueW(hkeyDefault, pData->ValueName, &pData->RegistryDataType, pData->Data, pData->DataSize, &pData->DataSize);
            RhRegCloseKey(&hkeyDefault);
        }

        RELEASE(pDesc);

        if (SUCCEEDED(hrT)) hr = hrT;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetPersistentData
 *
 *  Description:
 *      Gets persistent data from the registry.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetPersistentDataA"

HRESULT WINAPI
CDirectSoundPrivate::GetPersistentDataA
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA    pData,
    PULONG                                                      pcbData
)
{
    HKEY                                                        hkeyParent  = NULL;
    HKEY                                                        hkey        = NULL;
    HRESULT                                                     hr          = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    hr = OpenPersistentDataKey(pData->DeviceId, &hkeyParent);

    if(SUCCEEDED(hr))
    {
        if(pData->SubKeyName)
        {
            hr = RhRegOpenKeyA(hkeyParent, pData->SubKeyName, REGOPENKEY_ALLOWCREATE, &hkey);
        }
        else
        {
            hkey = hkeyParent;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = RhRegGetValueA(hkey, pData->ValueName, &pData->RegistryDataType, pData->Data, pData->DataSize, &pData->DataSize);
    }

    if(hkey != hkeyParent)
    {
        RhRegCloseKey(&hkey);
    }

    RhRegCloseKey(&hkeyParent);


    //
    // If value was not present (S_FALSE) then lets try to read the
    // machine default values
    //
    if (S_FALSE == hr)
    {
    	HKEY hkeyDefault;
        CDeviceDescription * pDesc = NULL;
    	HRESULT hrT;

        hrT = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);
        if (SUCCEEDED(hrT))
        {
	    if (IS_RENDER_VAD(pDesc->m_vdtDeviceType)) {
    	        // Check for default persistent data
                hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, pData->SubKeyName);
	    } else {
                hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUNDCAPTURE, 1, pData->SubKeyName);
	    }
	
            if(SUCCEEDED(hrT))
            {
                hrT = RhRegGetValueA(hkeyDefault, pData->ValueName, &pData->RegistryDataType, pData->Data, pData->DataSize, &pData->DataSize);
                RhRegCloseKey(&hkeyDefault);
            }

            RELEASE(pDesc);

            if (SUCCEEDED(hrT)) hr = hrT;
        }

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetPersistentDataW"

HRESULT WINAPI
CDirectSoundPrivate::GetPersistentDataW
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA    pData,
    PULONG                                                      pcbData
)
{
    HKEY                                                        hkeyParent  = NULL;
    HKEY                                                        hkey        = NULL;
    HRESULT                                                     hr          = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    hr = OpenPersistentDataKey(pData->DeviceId, &hkeyParent);

    if(SUCCEEDED(hr))
    {
        if(pData->SubKeyName)
        {
            hr = RhRegOpenKeyW(hkeyParent, pData->SubKeyName, REGOPENKEY_ALLOWCREATE, &hkey);
        }
        else
        {
            hkey = hkeyParent;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = RhRegGetValueW(hkey, pData->ValueName, &pData->RegistryDataType, pData->Data, pData->DataSize, &pData->DataSize);
    }

    if(hkey != hkeyParent)
    {
        RhRegCloseKey(&hkey);
    }

    RhRegCloseKey(&hkeyParent);

    //
    // If value was not present (S_FALSE) then lets try to read the
    // machine default values
    //
    if (S_FALSE == hr)
    {
    	HKEY hkeyDefault;
        CDeviceDescription * pDesc = NULL;
    	HRESULT hrT;

        hrT = g_pVadMgr->GetDeviceDescription(pData->DeviceId, &pDesc);
        if (SUCCEEDED(hrT))
        {
	    if (IS_RENDER_VAD(pDesc->m_vdtDeviceType)) {
    	        // Check for default persistent data
                hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, pData->SubKeyName);
	    } else {
                hrT = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyDefault, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUNDCAPTURE, 1, pData->SubKeyName);
	    }
	
            if(SUCCEEDED(hrT))
            {
                hrT = RhRegGetValueW(hkeyDefault, pData->ValueName, &pData->RegistryDataType, pData->Data, pData->DataSize, &pData->DataSize);
                RhRegCloseKey(&hkeyDefault);
            }

            RELEASE(pDesc);

            if (SUCCEEDED(hrT)) hr = hrT;
        }

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetPersistentData
 *
 *  Description:
 *      Sets persistent data to the registry.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetPersistentDataA"

HRESULT WINAPI
CDirectSoundPrivate::SetPersistentDataA
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA    pData,
    ULONG                                                       cbData
)
{
    HKEY                                                        hkeyParent  = NULL;
    HKEY                                                        hkey        = NULL;
    HRESULT                                                     hr          = DS_OK;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    hr = OpenPersistentDataKey(pData->DeviceId, &hkeyParent);

    if(SUCCEEDED(hr))
    {
        if(pData->SubKeyName)
        {
            hr = RhRegOpenKeyA(hkeyParent, pData->SubKeyName, REGOPENKEY_ALLOWCREATE, &hkey);
        }
        else
        {
            hkey = hkeyParent;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = RhRegSetValueA(hkey, pData->ValueName, pData->RegistryDataType, pData->Data, pData->DataSize);
    }

    if(hkey != hkeyParent)
    {
        RhRegCloseKey(&hkey);
    }

    RhRegCloseKey(&hkeyParent);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::SetPersistentDataW"

HRESULT WINAPI
CDirectSoundPrivate::SetPersistentDataW
(
    CDirectSoundPrivate *                                       pThis,
    PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA    pData,
    ULONG                                                       cbData
)
{
    HKEY                                                        hkeyParent  = NULL;
    HKEY                                                        hkey        = NULL;
    HRESULT                                                     hr          = DS_OK;

    DPF_ENTER();

    ASSERT(cbData >= sizeof(*pData));

    hr = OpenPersistentDataKey(pData->DeviceId, &hkeyParent);

    if(SUCCEEDED(hr))
    {
        if(pData->SubKeyName)
        {
            hr = RhRegOpenKeyW(hkeyParent, pData->SubKeyName, REGOPENKEY_ALLOWCREATE, &hkey);
        }
        else
        {
            hkey = hkeyParent;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = RhRegSetValueW(hkey, pData->ValueName, pData->RegistryDataType, pData->Data, pData->DataSize);
    }

    if(hkey != hkeyParent)
    {
        RhRegCloseKey(&hkey);
    }

    RhRegCloseKey(&hkeyParent);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetBufferDeviceId
 *
 *  Description:
 *      Gets the device id that created the given buffer.
 *
 *  Arguments:
 *      LPVOID [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetBufferDeviceId"

HRESULT WINAPI
CDirectSoundPrivate::GetBufferDeviceId
(
    CDirectSoundPrivate *                       pThis,
    PDSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA pData,
    PULONG                                      pcbData
)
{
    CImpDirectSoundBuffer<CDirectSoundBuffer> *pBuffer = (CImpDirectSoundBuffer<CDirectSoundBuffer> *)pData->Buffer;
    HRESULT hr = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof(*pData));

    if(!IS_VALID_IDIRECTSOUNDBUFFER(pBuffer))
    {
        RPF(DPFLVL_ERROR, "Invalid object/interface");
        hr = DSERR_INVALIDPARAM;
    }

    if(SUCCEEDED(hr))
    {
        pData->DeviceId = pBuffer->m_pObject->m_pDirectSound->m_pDevice->m_pDeviceDescription->m_guidDeviceId;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDirectSoundObjects
 *
 *  Description:
 *      Get information about the DirectSound objects existing in the
 *      current process.  If the pData->DeviceId field isn't GUID_NULL,
 *      return only the objects associated with that device ID.
 *
 *  Arguments:
 *      CDirectSoundPrivate* [in]: 'this' pointer.
 *      PDSPROPERTY_DIRECTSOUND_OBJECTS_DATA [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDirectSoundObjects"

HRESULT WINAPI
CDirectSoundPrivate::GetDirectSoundObjects
(
    CDirectSoundPrivate *                   pThis,
    PDSPROPERTY_DIRECTSOUND_OBJECTS_DATA    pData,
    PULONG                                  pcbData
)
{
    CNode<CDirectSound*> *pNode;
    DWORD dwProcessId = GetCurrentProcessId();
    HRESULT hr = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof *pData);

    pData->Count = 0;

    for (pNode = g_pDsAdmin->m_lstDirectSound.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        if (SUCCEEDED(pNode->m_data->IsInit()) &&
            pNode->m_data->GetOwnerProcessId() == dwProcessId &&
            (IS_NULL_GUID(&pData->DeviceId) ||
             pData->DeviceId == pNode->m_data->m_pDevice->m_pDeviceDescription->m_guidDeviceId))
        {
            if (*pcbData >= (sizeof *pData + sizeof(DIRECTSOUND_INFO) * (1 + pData->Count)))
            {
                pData->Objects[pData->Count].DirectSound = pNode->m_data->m_pImpDirectSound;
                pData->Objects[pData->Count].DeviceId = pNode->m_data->m_pDevice->m_pDeviceDescription->m_guidDeviceId;
            }
            pData->Count++;
        }
    }

    // Set up the buffer size required to obtain all data:
    *pcbData = sizeof *pData + sizeof(DIRECTSOUND_INFO) * pData->Count;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDirectSoundCaptureObjects
 *
 *  Description:
 *      Get information about the DirectSoundCapture objects in the current
 *      process.  If the pData->DeviceId field isn't GUID_NULL, return only
 *      the DirectSoundCapture objects associated with that device ID.
 *
 *  Arguments:
 *      CDirectSoundPrivate* [in]: 'this' pointer.
 *      PDSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA [in/out]: property data.
 *      PULONG [in/out]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::GetDirectSoundCaptureObjects"

HRESULT WINAPI
CDirectSoundPrivate::GetDirectSoundCaptureObjects
(
    CDirectSoundPrivate *                       pThis,
    PDSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA pData,
    PULONG                                      pcbData
)
{
    CNode<CDirectSoundCapture*> *pNode;
    DWORD dwProcessId = GetCurrentProcessId();
    HRESULT hr = DS_OK;

    DPF_ENTER();

    ASSERT(*pcbData >= sizeof *pData);

    pData->Count = 0;

    for (pNode = g_pDsAdmin->m_lstCapture.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        if (SUCCEEDED(pNode->m_data->IsInit()) &&
            pNode->m_data->GetOwnerProcessId() == dwProcessId &&
            (IS_NULL_GUID(&pData->DeviceId) ||
             pData->DeviceId == pNode->m_data->m_pDevice->m_pDeviceDescription->m_guidDeviceId))
        {
            if (*pcbData >= (sizeof *pData + sizeof(DIRECTSOUNDCAPTURE_INFO) * (1 + pData->Count)))
            {
                pData->Objects[pData->Count].DirectSoundCapture = pNode->m_data->m_pImpDirectSoundCapture;
                pData->Objects[pData->Count].DeviceId = pNode->m_data->m_pDevice->m_pDeviceDescription->m_guidDeviceId;
            }
            pData->Count++;
        }
    }

    // Set up the buffer size required to obtain all data:
    *pcbData = sizeof *pData + sizeof(DIRECTSOUND_INFO) * pData->Count;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  OpenPersistentDataKey
 *
 *  Description:
 *      Opens the persistent data key for a given device, or the default.
 *
 *  Arguments:
 *      REFGUID [in]: device GUID.
 *      BOOL [in]: TRUE to allow for key creation.
 *
 *  Returns:
 *      HKEY: registry key.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::OpenPersistentDataKey"

HRESULT
CDirectSoundPrivate::OpenPersistentDataKey
(
    REFGUID                 guid,
    PHKEY                   phkey
)
{
    CDeviceDescription *    pDesc       = NULL;
    HRESULT                 hr;

    DPF_ENTER();

    hr = g_pVadMgr->GetDeviceDescription(guid, &pDesc);

    if(SUCCEEDED(hr))
    {
#ifdef WINNT
        hr = g_pVadMgr->OpenPersistentDataKey(pDesc->m_vdtDeviceType, pDesc->m_strInterface, phkey);
#else
        hr = g_pVadMgr->OpenPersistentDataKey(pDesc->m_vdtDeviceType, pDesc->m_dwDevnode, phkey);
#endif
    }

    RELEASE(pDesc);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CvtDriverDesc
 *
 *  Description:
 *      Converts a CDeviceDescription object to a
 *      DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA structure.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: source.
 *      PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA [out]: destination.
 *      PULONG [in/out]: destination size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::CvtDriverDescA"

HRESULT
CDirectSoundPrivate::CvtDriverDescA
(
    CDeviceDescription *                                pSource,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA    pDest,
    PULONG                                              pcbDest
)
{
    ULONG                                               cbDest;
    LPCSTR                                              pszName;
    ULONG                                               cbName;
    ULONG                                               ibName;
    LPCSTR                                              pszPath;
    ULONG                                               cbPath;
    ULONG                                               ibPath;
    LPCSTR                                              pszInterface;
    ULONG                                               cbInterface;
    ULONG                                               ibInterface;

    DPF_ENTER();

    cbDest = sizeof *pDest;

    pszName = pSource->m_strName;
    cbName = lstrsizeA(pszName);
    ibName = cbDest;
    cbDest += cbName;

    pszPath = pSource->m_strPath;
    cbPath = lstrsizeA(pszPath);
    ibPath = cbDest;
    cbDest += cbPath;

    pszInterface = pSource->m_strInterface;
    cbInterface = lstrsizeA(pszInterface);
    ibInterface = cbDest;
    cbDest += cbInterface;

    // Set up the basic output fields
    if(pDest && (*pcbDest >= sizeof *pDest))
    {
        if(IS_EMULATED_VAD(pSource->m_vdtDeviceType))
            pDest->Type = DIRECTSOUNDDEVICE_TYPE_EMULATED;
        else if(IS_VXD_VAD(pSource->m_vdtDeviceType))
            pDest->Type = DIRECTSOUNDDEVICE_TYPE_VXD;
        else if(IS_KS_VAD(pSource->m_vdtDeviceType))
            pDest->Type = DIRECTSOUNDDEVICE_TYPE_WDM;
        else
            ASSERT(FALSE);

        if(IS_RENDER_VAD(pSource->m_vdtDeviceType))
            pDest->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_RENDER;
        else if(IS_CAPTURE_VAD(pSource->m_vdtDeviceType))
            pDest->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE;
        else
            ASSERT(FALSE);

        pDest->DeviceId = pSource->m_guidDeviceId;
    }

    // Set up the string output fields (if there's room)
    if(*pcbDest >= cbDest)
    {
        if(pszName)
        {
            pDest->Description = (LPSTR)((LPBYTE)pDest + ibName);
            lstrcpyA(pDest->Description, pszName);
        }
        if(pszPath)
        {
            pDest->Module = (LPSTR)((LPBYTE)pDest + ibPath);
            lstrcpyA(pDest->Module, pszPath);
        }
        if(pszInterface)
        {
            pDest->Interface = (LPSTR)((LPBYTE)pDest + ibInterface);
            lstrcpyA(pDest->Interface, pszInterface);
        }
        pDest->WaveDeviceId = pSource->m_uWaveDeviceId;
    }

    *pcbDest = cbDest;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::CvtDriverDescW"

HRESULT
CDirectSoundPrivate::CvtDriverDescW
(
    CDeviceDescription *                                pSource,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA    pDest,
    PULONG                                              pcbDest
)
{
    ULONG                                               cbDest;
    LPCWSTR                                             pszName;
    ULONG                                               cbName;
    ULONG                                               ibName;
    LPCWSTR                                             pszPath;
    ULONG                                               cbPath;
    ULONG                                               ibPath;
    LPCWSTR                                             pszInterface;
    ULONG                                               cbInterface;
    ULONG                                               ibInterface;

    DPF_ENTER();

    cbDest = sizeof *pDest;


    pszName = pSource->m_strName;
    cbName = lstrsizeW(pszName);
    ibName = cbDest;
    cbDest += cbName;

    pszPath = pSource->m_strPath;
    cbPath = lstrsizeW(pszPath);
    ibPath = cbDest;
    cbDest += cbPath;

    pszInterface = pSource->m_strInterface;
    cbInterface = lstrsizeW(pszInterface);
    ibInterface = cbDest;
    cbDest += cbInterface;

    // Set up the basic output fields
    if(pDest && (*pcbDest >= sizeof *pDest))
    {
        if(IS_EMULATED_VAD(pSource->m_vdtDeviceType))
            pDest->Type = DIRECTSOUNDDEVICE_TYPE_EMULATED;
        else if(IS_VXD_VAD(pSource->m_vdtDeviceType))
            pDest->Type = DIRECTSOUNDDEVICE_TYPE_VXD;
        else if(IS_KS_VAD(pSource->m_vdtDeviceType))
            pDest->Type = DIRECTSOUNDDEVICE_TYPE_WDM;
        else
            ASSERT(FALSE);

        if(IS_RENDER_VAD(pSource->m_vdtDeviceType))
            pDest->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_RENDER;
        else if(IS_CAPTURE_VAD(pSource->m_vdtDeviceType))
            pDest->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE;
        else
            ASSERT(FALSE);

        pDest->DeviceId = pSource->m_guidDeviceId;
    }

    // Set up the string output fields (if there's room)
    if(pDest && (*pcbDest >= cbDest))
    {
        if(pszName)
        {
            pDest->Description = (LPWSTR)((LPBYTE)pDest + ibName);
            lstrcpyW(pDest->Description, pszName);
        }
        if(pszPath)
        {
            pDest->Module = (LPWSTR)((LPBYTE)pDest + ibPath);
            lstrcpyW(pDest->Module, pszPath);
        }
        if(pszInterface)
        {
            pDest->Interface = (LPWSTR)((LPBYTE)pDest + ibInterface);
            lstrcpyW(pDest->Interface, pszInterface);
        }
        pDest->WaveDeviceId = pSource->m_uWaveDeviceId;
    }

    *pcbDest = cbDest;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundPrivate::CvtDriverDesc1"

HRESULT
CDirectSoundPrivate::CvtDriverDesc1
(
    CDeviceDescription *                                pSource,
    PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA    pDest
)
{
    DPF_ENTER();

    if(IS_EMULATED_VAD(pSource->m_vdtDeviceType))
        pDest->Type = DIRECTSOUNDDEVICE_TYPE_EMULATED;
    else if(IS_VXD_VAD(pSource->m_vdtDeviceType))
        pDest->Type = DIRECTSOUNDDEVICE_TYPE_VXD;
    else if(IS_KS_VAD(pSource->m_vdtDeviceType))
        pDest->Type = DIRECTSOUNDDEVICE_TYPE_WDM;
    else
        ASSERT(FALSE);

    if(IS_RENDER_VAD(pSource->m_vdtDeviceType))
        pDest->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_RENDER;
    else if(IS_CAPTURE_VAD(pSource->m_vdtDeviceType))
        pDest->DataFlow = DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE;
    else
        ASSERT(FALSE);

    pDest->DeviceId = pSource->m_guidDeviceId;

    lstrcpynA(pDest->DescriptionA, pSource->m_strName, NUMELMS(pDest->DescriptionA));
    lstrcpynW(pDest->DescriptionW, pSource->m_strName, NUMELMS(pDest->DescriptionW));

    lstrcpynA(pDest->ModuleA, pSource->m_strPath, NUMELMS(pDest->ModuleA));
    lstrcpynW(pDest->ModuleW, pSource->m_strPath, NUMELMS(pDest->ModuleW));

    pDest->WaveDeviceId = pSource->m_uWaveDeviceId;
    pDest->Devnode = pSource->m_dwDevnode;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsmemmgr.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsmemmgr.c
 *  Content:    DirectSound memory manager.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/02/98    dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"

// On Win9x we have to use our own heap because we create it SHARED;
// and in debug builds we do also, so that our HeapValidate() calls
// will only validate dsound's memory allocations, not the app's.
// But on NT retail builds we use the process heap for efficiency:

// #if defined(SHARED) || defined(DEBUG)
#define USE_OWN_HEAP
// #endif

// NOTE: we had to revert to the old behavior (always using a
// private heap in dsound) because of major appcompat issues -
// see Whistler bug 307628 for details.

static HANDLE g_hHeap = NULL;

#define MEMALIGN(size)      BLOCKALIGNPAD(size, sizeof(SIZE_T))

#ifndef HEAP_SHARED
#define HEAP_SHARED         0x04000000
#endif

#ifdef DEBUG

typedef struct tagDSMEMBLOCK
{
    DWORD                   dwCookie;
    struct tagDSMEMBLOCK *  pPrev;
    struct tagDSMEMBLOCK *  pNext;
    SIZE_T                  cbBuffer;
    LPCTSTR                 pszFile;
    UINT                    nLine;
    LPCTSTR                 pszClass;
} DSMEMBLOCK, *LPDSMEMBLOCK;
typedef const DSMEMBLOCK *LPCDSMEMBLOCK;

#define DSMEMBLOCK_SIZE     MEMALIGN(sizeof(DSMEMBLOCK))

#define PTRFROMBLOCK(p)     (((LPBYTE)(p)) + DSMEMBLOCK_SIZE)

#define BLOCKFROMPTR(p)     ((LPDSMEMBLOCK)(((LPBYTE)(p)) - DSMEMBLOCK_SIZE))

#ifndef FREE_MEMORY_PATTERN
#define FREE_MEMORY_PATTERN 0xDEADBEEF
#endif

#ifndef VALID_MEMORY_COOKIE
#define VALID_MEMORY_COOKIE 0xBAAABAAA
#endif

#ifndef FREE_MEMORY_COOKIE
#define FREE_MEMORY_COOKIE  0xBABABABA
#endif

#ifdef WINNT
#define ASSERT_VALID_HEAP() ASSERT(HeapValidate(g_hHeap, 0, NULL))
#else
#define ASSERT_VALID_HEAP()
#endif

static LPDSMEMBLOCK g_pFirst = NULL;
static HANDLE g_hHeapMutex = NULL;

#endif // DEBUG


/***************************************************************************
 *
 *  EnterHeapMutex
 *
 *  Description:
 *      Takes the heap mutex.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#ifdef DEBUG

#undef DPF_FNAME
#define DPF_FNAME "EnterHeapMutex"

void EnterHeapMutex(void)
{
    DWORD dwWait = WaitObject(INFINITE, g_hHeapMutex);
    if (WAIT_OBJECT_0 != dwWait)
    {
        DPF(DPFLVL_WARNING, "WaitObject returned %s instead of WAIT_OBJECT_0", dwWait);
    }
    ASSERT_VALID_HEAP();
}

#endif // DEBUG


/***************************************************************************
 *
 *  LeaveHeapMutex
 *
 *  Description:
 *      Releases the heap mutex.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#ifdef DEBUG

#undef DPF_FNAME
#define DPF_FNAME "LeaveHeapMutex"

void LeaveHeapMutex(void)
{
    BOOL fSuccess;

    ASSERT_VALID_HEAP();

    fSuccess = ReleaseMutex(g_hHeapMutex);
    ASSERT(fSuccess);
}

#endif // DEBUG


/***************************************************************************
 *
 *  MemState
 *
 *  Description:
 *      Prints the current memory state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#ifdef DEBUG

#undef DPF_FNAME
#define DPF_FNAME "MemState"

static void MemState(void)
{
    LPDSMEMBLOCK pCurrent;
    
    EnterHeapMutex();

    for(pCurrent = g_pFirst; pCurrent; pCurrent = pCurrent->pNext)
    {
        DPF(DPFLVL_ERROR, "%s at 0x%p (%lu) allocated from %s, line %lu", pCurrent->pszClass ? pCurrent->pszClass : TEXT("Memory"), PTRFROMBLOCK(pCurrent), pCurrent->cbBuffer, pCurrent->pszFile, pCurrent->nLine);
    }

    LeaveHeapMutex();
}

#endif // DEBUG


/***************************************************************************
 *
 *  MemInit
 *
 *  Description:
 *      Initializes the memory manager.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemInit"

BOOL MemInit(void)
{
    BOOL fSuccess;

#ifdef USE_OWN_HEAP
    #ifdef SHARED
        g_hHeap = HeapCreate(HEAP_SHARED, 0x2000, 0);
    #else
        g_hHeap = HeapCreate(0, 0x2000, 0);
    #endif
#else
    g_hHeap = GetProcessHeap();
#endif

fSuccess = IsValidHandleValue(g_hHeap);
    
#ifdef DEBUG
    if(fSuccess)
    {
        g_hHeapMutex = CreateGlobalMutex(NULL);
        fSuccess = IsValidHandleValue(g_hHeapMutex);
    }
#endif

    DPF_LEAVE(fSuccess);
    return fSuccess;
}


/***************************************************************************
 *
 *  MemFini
 *
 *  Description:
 *      Frees the memory manager.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemFini"

void MemFini(void)
{
#ifdef DEBUG
    MemState();
    if (g_pFirst != NULL)
    {
        DPF(DPFLVL_ERROR, "Memory leak: g_pFirst = 0x%lX", g_pFirst);
        BREAK();
    }
    g_pFirst = NULL;
    CLOSE_HANDLE(g_hHeapMutex);
#endif

#ifdef USE_OWN_HEAP
    if(IsValidHandleValue(g_hHeap))
    {
        HeapDestroy(g_hHeap);
        g_hHeap = NULL;
    }
#endif
}


/***************************************************************************
 *
 *  MemAllocBuffer
 *
 *  Description:
 *      Allocates a buffer of memory.
 *
 *  Arguments:
 *      PSIZE_T [in/out]: size of buffer to allocate.
 *
 *  Returns:  
 *      LPVOID: buffer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemAllocBuffer"

LPVOID MemAllocBuffer(SIZE_T cbBuffer, PSIZE_T pcbAllocated)
{
    LPVOID pvBuffer;

    cbBuffer = MEMALIGN(cbBuffer);

    pvBuffer = HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, cbBuffer);

    if(pvBuffer && pcbAllocated)
    {
        *pcbAllocated = cbBuffer;
    }

    return pvBuffer;
}


/***************************************************************************
 *
 *  MemFreeBuffer
 *
 *  Description:
 *      Frees a buffer of memory.
 *
 *  Arguments:
 *      LPVOID [in]: buffer pointer.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemFreeBuffer"

void MemFreeBuffer(LPVOID pvBuffer)
{
    HeapFree(g_hHeap, 0, pvBuffer);
}


/***************************************************************************
 *
 *  MemAllocBlock
 *
 *  Description:
 *      Allocates a block of memory.
 *
 *  Arguments:
 *      SIZE_T [in]: size of buffer to allocate.
 *      char * [in]: file called from.
 *      unsigned int [in]: line called from.
 *      char * [in]: class name.
 *
 *  Returns:  
 *      LPDSMEMBLOCK: pointer to newly allocated block.
 *
 ***************************************************************************/

#ifdef DEBUG

#undef DPF_FNAME
#define DPF_FNAME "MemAllocBlock"

LPDSMEMBLOCK MemAllocBlock(SIZE_T cbBuffer, LPCTSTR pszFile, UINT nLine, LPCTSTR pszClass)
{
    LPDSMEMBLOCK pBlock;

    EnterHeapMutex();

    cbBuffer += DSMEMBLOCK_SIZE;
    
    pBlock = (LPDSMEMBLOCK)MemAllocBuffer(cbBuffer, &cbBuffer);

    if(pBlock)
    {
        pBlock->dwCookie = VALID_MEMORY_COOKIE;
        pBlock->pNext = g_pFirst;

        if(g_pFirst)
        {
            g_pFirst->pPrev = pBlock;
        }

        g_pFirst = pBlock;

        pBlock->cbBuffer = cbBuffer - DSMEMBLOCK_SIZE;
        pBlock->pszFile = pszFile;
        pBlock->nLine = nLine;
        pBlock->pszClass = pszClass;
    }

    LeaveHeapMutex();

    return pBlock;
}

#endif // DEBUG


/***************************************************************************
 *
 *  MemFreeBlock
 *
 *  Description:
 *      Frees a block of memory.
 *
 *  Arguments:
 *      LPDSMEMBLOCK [in]: block pointer.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#ifdef DEBUG

#undef DPF_FNAME
#define DPF_FNAME "MemFreeBlock"

void MemFreeBlock(LPDSMEMBLOCK pBlock)
{
    EnterHeapMutex();

    ASSERT(VALID_MEMORY_COOKIE == pBlock->dwCookie);
    ASSERT(IS_VALID_WRITE_PTR(pBlock, offsetof(DSMEMBLOCK, cbBuffer) + sizeof(pBlock->cbBuffer)));
    ASSERT(IS_VALID_WRITE_PTR(pBlock, pBlock->cbBuffer));

    pBlock->dwCookie = FREE_MEMORY_COOKIE;

    if(pBlock->pPrev)
    {
        pBlock->pPrev->pNext = pBlock->pNext;
    }

    if(pBlock->pNext)
    {
        pBlock->pNext->pPrev = pBlock->pPrev;
    }

    if(pBlock == g_pFirst)
    {
        ASSERT(!pBlock->pPrev);
        g_pFirst = pBlock->pNext;
    }

    FillMemoryDword(PTRFROMBLOCK(pBlock), pBlock->cbBuffer, FREE_MEMORY_PATTERN);

    MemFreeBuffer(pBlock);

    LeaveHeapMutex();
}

#endif // DEBUG


/***************************************************************************
 *
 *  MemAlloc
 *
 *  Description:
 *      Allocates memory.
 *
 *  Arguments:
 *      SIZE_T [in]: size of buffer to allocate.
 *      char * [in]: file called from.
 *      unsigned int [in]: line called from.
 *
 *  Returns:  
 *      LPVOID: pointer to newly allocated buffer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemAlloc"

LPVOID MemAlloc
(
#ifdef DEBUG
    SIZE_T cbBuffer, LPCTSTR pszFile, UINT nLine, LPCTSTR pszClass
#else // DEBUG
    SIZE_T cbBuffer
#endif // DEBUG
)
{
    LPVOID pvBuffer = NULL;

#ifdef DEBUG
    LPDSMEMBLOCK pBlock = MemAllocBlock(cbBuffer, pszFile, nLine, pszClass);
    if(pBlock)
    {
        pvBuffer = PTRFROMBLOCK(pBlock);
    }
#else // DEBUG
    pvBuffer = MemAllocBuffer(cbBuffer, NULL);
#endif // DEBUG

    return pvBuffer;
}


/***************************************************************************
 *
 *  MemAllocCopy
 *
 *  Description:
 *      Allocates memory and fills it with data from another buffer.
 *
 *  Arguments:
 *      LPVOID [in]: pointer to source buffer.
 *      SIZE_T [in]: size of buffer to allocate.
 *      char * [in]: file called from.
 *      unsigned int [in]: line called from.
 *
 *  Returns:  
 *      LPVOID: pointer to newly allocated buffer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemAllocCopy"

LPVOID MemAllocCopy
(
    LPCVOID pSource, 
#ifdef DEBUG
    SIZE_T cbBuffer, LPCTSTR pszFile, UINT nLine, LPCTSTR pszClass
#else // DEBUG
    SIZE_T cbBuffer
#endif // DEBUG
)
{
    LPVOID pDest;
    
#ifdef DEBUG
    pDest = MemAlloc(cbBuffer, pszFile, nLine, pszClass);
#else // DEBUG
    pDest = MemAlloc(cbBuffer);
#endif // DEBUG

    if(pDest)
    {
        CopyMemory(pDest, pSource, cbBuffer);
    }

    return pDest;
}


/***************************************************************************
 *
 *  MemFree
 *
 *  Description:
 *      Frees memory allocated by MemAlloc.
 *
 *  Arguments:
 *      LPVOID* [in]: buffer pointer.
 *      char * [in]: file called from.
 *      unsigned int [in]: line called from.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "MemFree"

void MemFree(LPVOID pvBuffer)
{
    if(pvBuffer)
    {
#ifdef DEBUG
        MemFreeBlock(BLOCKFROMPTR(pvBuffer));
#else // DEBUG
        MemFreeBuffer(pvBuffer);
#endif // DEBUG
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsprvobj.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsprvobj.h
 *  Content:    DirectSound Private Object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/05/97    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DSPRVOBJ_H__
#define __DSPRVOBJ_H__

#ifdef __cplusplus

// The DirectSound Private object
class CDirectSoundPrivate
    : public CUnknown, public CPropertySetHandler
{
protected:
    // Property handlers
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSoundMixer);
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSoundDevice);
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSoundBasicAcceleration);
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSoundDebug);
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSoundPersistentData);
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSoundBuffer);
    DECLARE_PROPERTY_HANDLER_DATA_MEMBER(DSPROPSETID_DirectSound);

    // Property sets
    DECLARE_PROPERTY_SET_DATA_MEMBER(m_aPropertySets);

private:
    // Interfaces
    CImpKsPropertySet<CDirectSoundPrivate> *m_pImpKsPropertySet;

public:
    CDirectSoundPrivate(void);
    virtual ~CDirectSoundPrivate(void);

public:
    // Property handlers
    static HRESULT WINAPI GetMixerSrcQuality(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA, PULONG);
    static HRESULT WINAPI SetMixerSrcQuality(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDMIXER_SRCQUALITY_DATA, ULONG);

    static HRESULT WINAPI GetMixerAcceleration(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA, PULONG);
    static HRESULT WINAPI SetMixerAcceleration(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDMIXER_ACCELERATION_DATA, ULONG);

    static HRESULT WINAPI GetDevicePresence(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA, PULONG);
    static HRESULT WINAPI GetDevicePresence1(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA, PULONG);
    static HRESULT WINAPI SetDevicePresence(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_DATA, ULONG);
    static HRESULT WINAPI SetDevicePresence1(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1_DATA, ULONG);

    static HRESULT WINAPI GetWaveDeviceMappingA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A_DATA, PULONG);
    static HRESULT WINAPI GetWaveDeviceMappingW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W_DATA, PULONG);
    
    static HRESULT WINAPI GetDeviceDescriptionA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, PULONG);
    static HRESULT WINAPI GetDeviceDescriptionW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, PULONG);
    static HRESULT WINAPI GetDeviceDescription1(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA, PULONG);

    static HRESULT WINAPI EnumerateDevicesA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A_DATA, PULONG);
    static HRESULT WINAPI EnumerateDevicesW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W_DATA, PULONG);
    static HRESULT WINAPI EnumerateDevices1(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1_DATA, PULONG);

    static HRESULT WINAPI GetDebugDpfInfoA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA, PULONG);
    static HRESULT WINAPI GetDebugDpfInfoW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA, PULONG);
    static HRESULT WINAPI SetDebugDpfInfoA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_A_DATA, ULONG);
    static HRESULT WINAPI SetDebugDpfInfoW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEBUG_DPFINFO_W_DATA, ULONG);

    static HRESULT WINAPI TranslateResultCodeA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_A_DATA, PULONG);
    static HRESULT WINAPI TranslateResultCodeW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEBUG_TRANSLATERESULTCODE_W_DATA, PULONG);

    static HRESULT WINAPI GetBasicAcceleration(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA, PULONG);
    static HRESULT WINAPI SetBasicAcceleration(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_ACCELERATION_DATA, ULONG);
    static HRESULT WINAPI GetDefaultAcceleration(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDBASICACCELERATION_DEFAULT_DATA, PULONG);

    static HRESULT WINAPI GetDefaultDataA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA, PULONG);
    static HRESULT WINAPI GetDefaultDataW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA, PULONG);

    static HRESULT WINAPI GetPersistentDataA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA, PULONG);
    static HRESULT WINAPI GetPersistentDataW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA, PULONG);
    static HRESULT WINAPI SetPersistentDataA(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_A_DATA, ULONG);
    static HRESULT WINAPI SetPersistentDataW(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_W_DATA, ULONG);

    static HRESULT WINAPI GetBufferDeviceId(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDBUFFER_DEVICEID_DATA, PULONG);

    static HRESULT WINAPI GetDirectSoundObjects(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUND_OBJECTS_DATA, PULONG);
    static HRESULT WINAPI GetDirectSoundCaptureObjects(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDCAPTURE_OBJECTS_DATA, PULONG);

private:
    static HRESULT WINAPI GetWaveDeviceMapping(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_DATA, PULONG);
    static HRESULT WINAPI GetPersistentData(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA, PULONG);
    static HRESULT WINAPI GetDefaultData(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA, PULONG);
    static HRESULT WINAPI SetPersistentData(CDirectSoundPrivate *, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA, ULONG);
    static HRESULT OpenPersistentDataKey(REFGUID, PHKEY);
    static HRESULT CvtDriverDescA(CDeviceDescription *, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, PULONG);
    static HRESULT CvtDriverDescW(CDeviceDescription *, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, PULONG);
    static HRESULT CvtDriverDesc1(CDeviceDescription *, PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA);
};

inline HRESULT WINAPI CDirectSoundPrivate::GetPersistentData(CDirectSoundPrivate *pThis, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA pData, PULONG pcbData)
{
#ifdef UNICODE
    return GetPersistentDataW(pThis, pData, pcbData);
#else // UNICODE
    return GetPersistentDataA(pThis, pData, pcbData);
#endif // UNICODE
}

inline HRESULT WINAPI CDirectSoundPrivate::SetPersistentData(CDirectSoundPrivate *pThis, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA pData, ULONG cbData)
{
#ifdef UNICODE
    return SetPersistentDataW(pThis, pData, cbData);
#else // UNICODE
    return SetPersistentDataA(pThis, pData, cbData);
#endif // UNICODE
}

inline HRESULT WINAPI CDirectSoundPrivate::GetDefaultData(CDirectSoundPrivate *pThis, PDSPROPERTY_DIRECTSOUNDPERSISTENTDATA_PERSISTDATA_DATA pData, PULONG pcbData)
{
#ifdef UNICODE
    return GetDefaultDataW(pThis, pData, pcbData);
#else // UNICODE
    return GetDefaultDataA(pThis, pData, pcbData);
#endif // UNICODE
}


#endif // __cplusplus

#endif // __DSPRVOBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsoundi.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsoundi.h
 *  Content:    DirectSound internal header
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/27/96    dereks  Created
 *  08/25/99    duganp  Added effects processing for DirectX 8
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifndef __DSOUNDI_H__
#define __DSOUNDI_H__

// Turn off spurious warnings about always true/false conditionals
// generated by some of our validation macros.
#pragma warning(disable:4296)

// We'll ask for what we need, thank you
#ifndef WIN32_LEAN_AND_MEAN
  #define WIN32_LEAN_AND_MEAN
#endif

#ifndef COM_NO_WINDOWS_H
  #define COM_NO_WINDOWS_H
#endif

// Define all flavors of 'WIN32'
#if defined(WIN32) || defined(_WIN32)
  #ifndef WIN32
    #define WIN32
  #endif
  #ifndef _WIN32
    #define _WIN32
  #endif
#endif // defined(WIN32) || defined(_WIN32)

// Define all flavors of 'WIN64'
#if defined(WIN64) || defined(_WIN64)
  #ifndef WIN64
    #define WIN64
  #endif
  #ifndef _WIN64
    #define _WIN64
  #endif
#endif // defined(WIN64) || defined(_WIN64)

// Define all flavors of 'DEBUG'
#ifdef DEBUG
  #ifndef _DEBUG
    #define _DEBUG
  #endif
  #ifndef RDEBUG
    #define RDEBUG
  #endif
  #ifndef DBG
    #define DBG 1
  #endif
#endif // DEBUG

// Either WIN95 or WINNT must always be defined.
// WIN95 really means "any Win9X platform" (including Windows 98 and ME).
// WINNT means "any NT-based platform" including Windows 2000, XP, etc.

#ifdef Not_VxD
  #if defined(WIN95) && defined(WINNT)
    #error Both WIN95 and WINNT defined
  #endif // defined(WIN95) && defined(WINNT)
  #if !defined(WIN95) && !defined(WINNT)
    #error Neither WIN95 nor WINNT defined
  #endif // !defined(WIN95) && !defined(WINNT)
#endif // Not_VxD

// Define or undefine all flavors of UNICODE
#ifdef WINNT
  #ifndef UNICODE
    #define UNICODE
  #endif
  #ifndef _UNICODE
    #define _UNICODE
  #endif
#else
  #undef UNICODE
  #undef _UNICODE
#endif // WINNT

// If we're building the VxD, we're obviously X86
#if !defined(Not_VxD) && !defined(_X86_)
  #define _X86_
#endif

// Can we use inline X86 assembler?  This definition must be before the
// inclusion of runtime.h and any other header files that use USE_INLINE_ASM
// in the future.
#if defined(_X86_) && !defined(WIN64)
  #define USE_INLINE_ASM
#endif

#include <windows.h>
#include <stddef.h>
#include <objbase.h>
#include <mmsystem.h>
#include <mmddkp.h>

#ifndef Not_VxD // If building dsound.vxd:

  #define WANTVXDWRAPS

  #ifdef __cplusplus
    extern "C" {
  #endif // __cplusplus
  #include <vmm.h>
  #include <vwin32.h>
  #include <vxdwraps.h>
  #include <vtd.h>
  #include <vmcpd.h>
  #ifdef __cplusplus
    }
  #endif // __cplusplus

#endif // Not_VxD

#include "dsmemmgr.h"
#include "dsoundp.h"
#include "dsprv.h"

#ifdef Not_VxD // If building dsound.dll:

  #include "debug.h"
  #include "runtime.h"

  #ifdef SHARED
    #include "ddrawp.h"
    #include "w95help.h"
  #endif // SHARED

  #ifndef NOKS
    #include <mmreg.h>      // Need to include mmreg.h before ksmedia.h; otherwise ksmedia.h
    #include <ks.h>         // will not define KSDATAFORMAT_SUBTYPE_IEEE_FLOAT etc.
    #include <ksmedia.h>
    #include <ksmediap.h>
    #include <dmksctrl.h>
  #endif // NOKS

  #ifdef WIN95
    #include "unicode.h"
  #endif // WIN95

  #include <dmusici.h>

  #include "resource.h"
  #include "dsdrvi.h"
  #include "dynaload.h"
  #include "decibels.h"
  #include "misc.h"
  #include "tlist.h"
  #include "vmanpset.h"
  #include "dsbasic.h"
  #include "dsvalid.h"
  #include "synch.h"
  #include "grace.h"
  #include "vad.h"
  #include "miscinl.h"
  #include "dsimp.h"
  #include "dscom.h"
  #include "dsadmin.h"
  #include "pnphlp.h"
  #include "iirlut.h"
  #include "vmaxcoef.h"
  #include "vmaxhead.h"
  #include "reghlp.h"
  #include "ds3d.h"
  #include "pset.h"
  #include "verify.h"
  #include "mxvad.h"
  #include "emvad.h"
  #include "vector.h"
  #include "capteff.h"
  #include "effects.h"
  #include "dsbufcfg.h"
  #include "dmstrm.h"
  #include "dsfd.h"

  #ifdef WINNT
    #define ENABLE_PERFLOG
    #include "perf.h"
  #endif

  #ifndef NOVXD
    #include "vxdvad.h"
    #include "dsvxdhlp.h"
    #include "dsvxd.h"
  #endif // NOVXD

  #ifndef NOKS
    #include "kshlp.h"
    #include "ks3d.h"
    #include "ksvad.h"
    #include "kscap.h"
  #endif // NOKS

  #include "dsaphack.h"
  #include "dsbuf.h"
  #include "dsclock.h"
  #include "dssink.h"
  #include "dsobj.h"
  #include "dsprvobj.h"
  #include "dscap.h"
  #include "ksuserw.h"

#else // !Not_VxD - building dsound.vxd:

  #include "runtime.h"
  #include "dsdrvi.h"
  #include "dsvxdi.h"
  #include "grace.h"

#endif // Not_VxD

#include "dsbnotes.h"

#if defined(Not_VxD) && defined(__cplusplus)
#include "dsimp.cpp"
#include "tlist.cpp"
#include "miscinl.cpp"
#endif // defined(Not_VxD) && defined(__cplusplus)

#endif // __DSOUNDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dssink.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dssink.cpp
 *  Content:    Implementation of CDirectSoundSink and CImpSinkKsControl
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/23/99    jimge   Created
 *  09/27/99    petchey Continued implementation
 *  04/15/00    duganp  Completed implementation
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <math.h>  // For log10()

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::CDirectSoundSink"


/***************************************************************************
 *
 * CDirectSoundSink methods
 *
 ***************************************************************************/


CDirectSoundSink::CDirectSoundSink(CDirectSound *pDirectSound)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDirectSoundSink);

    m_pDirectSound = pDirectSound;

    // DirectSound sink objects are inherently DX8 objects
    SetDsVersion(DSVERSION_DX8);

    // Initialize list of internal arrays
    m_InternalArrayList[i_m_pdwBusIDs]          = NEW(DSSinkArray(&m_pdwBusIDs, sizeof(DWORD)));
    m_InternalArrayList[i_m_pdwFuncIDs]         = NEW(DSSinkArray(&m_pdwFuncIDs, sizeof(DWORD)));
    m_InternalArrayList[i_m_plPitchBends]       = NEW(DSSinkArray(&m_plPitchBends, sizeof(long)));
    m_InternalArrayList[i_m_pdwActiveBusIDs]    = NEW(DSSinkArray(&m_pdwActiveBusIDs, sizeof(DWORD)));
    m_InternalArrayList[i_m_pdwActiveFuncIDs]   = NEW(DSSinkArray(&m_pdwActiveFuncIDs, sizeof(DWORD)));
    m_InternalArrayList[i_m_pdwActiveBusIDsMap] = NEW(DSSinkArray(&m_pdwActiveBusIDsMap, sizeof(DWORD)));
    m_InternalArrayList[i_m_ppvStart]           = NEW(DSSinkArray(&m_ppvStart, sizeof(LPVOID)));
    m_InternalArrayList[i_m_ppvEnd]             = NEW(DSSinkArray(&m_ppvEnd, sizeof(LPVOID)));
    m_InternalArrayList[i_m_ppDSSBuffers]       = (DSSinkArray*)NEW(DSSinkBuffersArray(&m_ppDSSBuffers, sizeof(DSSinkBuffers)));
    m_InternalArrayList[i_m_pDSSources]         = (DSSinkArray*)NEW(DSSinkSourceArray(&m_pDSSources, sizeof(DSSinkSources)));

    // Everything else gets initialized to 0 by our memory allocator

    // Register this object with the administrator
    g_pDsAdmin->RegisterObject(this);

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::~CDirectSoundSink"

CDirectSoundSink::~CDirectSoundSink()
{
    DPF_ENTER();
    DPF_DESTRUCT(CDirectSoundSink);

    // Unregister with the administrator
    g_pDsAdmin->UnregisterObject(this);

    // Make sure we're inactive (i.e. unregistered with the streaming thread)
    Activate(FALSE);

    RELEASE(m_pIMasterClock);

    MEMFREE(m_pdwBusIDs);
    MEMFREE(m_pdwFuncIDs);
    MEMFREE(m_plPitchBends);
    MEMFREE(m_pdwActiveBusIDs);
    MEMFREE(m_pdwActiveFuncIDs);
    MEMFREE(m_pdwActiveBusIDsMap);
    MEMFREE(m_ppvStart);
    MEMFREE(m_ppvEnd);

    DELETE(m_ppDSSBuffers);
    DELETE(m_pDSSources);

    DELETE(m_pImpDirectSoundSink);
    DELETE(m_pImpKsControl);

    for (int i = 0; i < NUM_INTERNAL_ARRAYS; i++)
        DELETE(m_InternalArrayList[i]);

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::Initialize"

HRESULT CDirectSoundSink::Initialize(LPWAVEFORMATEX pwfex, VADDEVICETYPE vdtDeviceType)
{
    DPF_ENTER();

    // Get our owning streaming thread
    m_pStreamingThread = GetStreamingThread();
    HRESULT hr = HRFROMP(m_pStreamingThread);

    if (SUCCEEDED(hr))
        hr = CreateAndRegisterInterface(this, IID_IDirectSoundConnect, this, &m_pImpDirectSoundSink);

    if (SUCCEEDED(hr))
        hr = RegisterInterface(IID_IDirectSoundSynthSink, m_pImpDirectSoundSink, (IDirectSoundSynthSink*)m_pImpDirectSoundSink);

    if (SUCCEEDED(hr))
        hr = CreateAndRegisterInterface(this, IID_IKsControl, this, &m_pImpKsControl);

    if (SUCCEEDED(hr))
    {
        // Future version: Make this work with wave format extensible.
        m_wfx = *pwfex;

        m_dwBusSize = INTERNAL_BUFFER_LENGTH;
        m_dwLatency = SINK_INITIAL_LATENCY;  // Will automatically drop to a better level if possible

        #ifdef DEBUG_TIMING  // Read some timing parameters from the registry
        HKEY hkey;
        if (SUCCEEDED(RhRegOpenPath(HKEY_CURRENT_USER, &hkey, REGOPENPATH_DEFAULTPATH | REGOPENPATH_DIRECTSOUND, 1, TEXT("Streaming thread settings"))))
        {
            if (SUCCEEDED(RhRegGetBinaryValue(hkey, TEXT("Sink buffer size"), &m_dwBusSize, sizeof m_dwBusSize)))
                DPF(DPFLVL_INFO, "Read initial sink buffer size %lu from registry", m_dwBusSize);
            if (SUCCEEDED(RhRegGetBinaryValue(hkey, TEXT("Sink latency"), &m_dwLatency, sizeof m_dwLatency)))
                DPF(DPFLVL_INFO, "Read initial sink latency %lu from registry", m_dwLatency);
            RhRegCloseKey(&hkey);
        }
        #endif

        // Hack to support our strangely broken emulation mixer (bug 42145)
        if (IS_EMULATED_VAD(vdtDeviceType))
            m_dwLatency += EMULATION_LATENCY_BOOST;

        // Can't have a latency of more than half our buffer size
        if (m_dwLatency > m_dwBusSize/2)
            m_dwLatency = m_dwBusSize/2;

        m_dwBusSize = MsToBytes(m_dwBusSize, &m_wfx);

        m_LatencyClock.Init(this);

        DPF(DPFLVL_MOREINFO, "Initializing DirectSound sink object:");
        DPF(DPFLVL_MOREINFO, "\tChannels     = %d", m_wfx.nChannels);
        DPF(DPFLVL_MOREINFO, "\tSample Rate  = %d", m_wfx.nSamplesPerSec);
        DPF(DPFLVL_MOREINFO, "\tBytes/Second = %d", m_wfx.nAvgBytesPerSec);
        DPF(DPFLVL_MOREINFO, "\tBlock Align  = %d", m_wfx.nBlockAlign);
        DPF(DPFLVL_MOREINFO, "\tBits/Sample  = %d", m_wfx.wBitsPerSample);
        DPF(DPFLVL_MOREINFO, "\tBus Size     = %d", m_dwBusSize);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

LPVOID CDirectSoundSink::DSSinkArray::Grow(DWORD dwgrowby)
{
    void *ptr;
    DWORD dwnumitems = m_numitems + dwgrowby;
    DWORD dwallocsize = m_itemsize*dwnumitems;

    ptr = MEMALLOC_A(char, dwallocsize);
    if (!ptr)
    {
        return NULL;
    }

    if (m_pvarray)
    {
        if (*((void**)m_pvarray))
        {
            ZeroMemory(ptr, dwallocsize);
            CopyMemory(ptr, *((void**)m_pvarray), m_itemsize*m_numitems);
            MEMFREE(*((void**)m_pvarray));
        }
    }

    *((void**)m_pvarray) = ptr;
    m_numitems = dwnumitems;

    return ptr;
}

LPVOID CDirectSoundSink::DSSinkBuffersArray::Grow(DWORD dwgrowby)
{
    void *ptr;
    DWORD dwnumitems = m_numitems + dwgrowby;

    ptr = NEW(DSSinkBuffers[dwnumitems]);
    if (!ptr)
    {
        return NULL;
    }

    if (m_pvarray)
    {
        if (*((void**)m_pvarray))
        {
            for (DWORD i = 0; i < m_numitems; i++)
            {
                ((DSSinkBuffers*)ptr)[i] = (*((DSSinkBuffers**)m_pvarray))[i];
            }
        }
        DELETE(*((void**)m_pvarray));
    }


    *((void**)m_pvarray) = ptr;
    m_numitems = dwnumitems;

    return ptr;
}

LPVOID CDirectSoundSink::DSSinkSourceArray::Grow(DWORD dwgrowby)
{
    void *ptr;
    DWORD dwnumitems = m_numitems + dwgrowby;

    ptr = NEW(DSSinkSources[dwnumitems]);
    if (!ptr)
    {
        return NULL;
    }

    if (m_pvarray)
    {
        if (*((void**)m_pvarray))
        {
            for (DWORD i = 0; i < m_numitems; i++)
            {
                ((DSSinkSources*)ptr)[i] = (*((DSSinkSources**)m_pvarray))[i];
            }
        }
        DELETE(*((void**)m_pvarray));
    }


    *((void**)m_pvarray) = ptr;
    m_numitems = dwnumitems;

    return ptr;
}

HRESULT CDirectSoundSink::DSSinkBuffers::Initialize(DWORD dwBusBufferSize)
{
    HRESULT hr = DS_OK;

    for (DWORD i = 0; i < m_dwBusCount; i++)
    {
        // These are all initialized to NULL in the constructor
        m_pvBussStart[i] = MEMALLOC_A(char, dwBusBufferSize);
        m_pvBussEnd[i]   = MEMALLOC_A(char, dwBusBufferSize);

        if (m_pvBussStart[i] == NULL || m_pvBussEnd[i] == NULL)
        {
            hr = DSERR_OUTOFMEMORY;

            // ERROR: Let's delete all of the memory we allocated
            for (i = 0; i < MAX_BUSIDS_PER_BUFFER; i++)
            {
                MEMFREE(m_pvBussStart[i]);
                MEMFREE(m_pvBussEnd[i]);
            }

            break;
        }

        ZeroMemory(m_pvBussStart[i], dwBusBufferSize);
        ZeroMemory(m_pvBussEnd[i], dwBusBufferSize);
    }

    if (SUCCEEDED(hr))
    {
        for (; i < MAX_BUSIDS_PER_BUFFER; i++)
        {
            m_pvBussStart[i] = NULL;
            m_pvBussEnd[i]   = NULL;
        }

        // Clear the remaining part of the arrays
        for (i = m_dwBusCount; i < MAX_BUSIDS_PER_BUFFER; i++) // Fill the reset up with null IDs
        {
            m_pdwBusIndex[i]  = -1;
            m_pdwBusIds[i]    = DSSINK_NULLBUSID;
            m_pdwFuncIds[i]   = DSSINK_NULLBUSID;
        }
        m_lPitchBend = 0;
    }
    return hr;
}

HRESULT CDirectSoundSink::GrowBusArrays(DWORD dwgrowby)
{
    DWORD dwnumitems = m_dwBusIDsAlloc + dwgrowby;

    if (dwgrowby == 0)
        return S_FALSE;

    dwnumitems = (dwnumitems + BUSID_BLOCK_SIZE - 1) & ~(BUSID_BLOCK_SIZE-1);

    for (DWORD i = i_m_pdwBusIDs; i <= i_m_ppvEnd; i++)
    {
        m_InternalArrayList[i]->Grow(dwnumitems);
    }

    if (m_pdwBusIDs        == NULL ||
         m_pdwFuncIDs       == NULL ||
         m_plPitchBends     == NULL ||
         m_pdwActiveBusIDs  == NULL ||
         m_pdwActiveFuncIDs == NULL ||
         m_ppDSSBuffers     == NULL ||
         m_ppvStart         == NULL ||
         m_ppvEnd           == NULL)
    {
        return DSERR_OUTOFMEMORY;
    }

    m_dwBusIDsAlloc += dwnumitems;

    return DS_OK;
}

HRESULT CDirectSoundSink::GrowSourcesArrays(DWORD dwgrowby)
{
    DWORD dwnumitems = m_dwDSSourcesAlloc + dwgrowby;

    if (dwgrowby == 0)
        return S_FALSE;

    dwnumitems = (dwnumitems + SOURCES_BLOCK_SIZE - 1) & ~(SOURCES_BLOCK_SIZE-1);

    m_InternalArrayList[i_m_pDSSources]->Grow(dwnumitems);

    if (m_pDSSources == NULL)
    {
        return DSERR_OUTOFMEMORY;
    }

    m_dwDSSourcesAlloc += dwnumitems;

    return DS_OK;
}

HRESULT CDirectSoundSink::SetBufferFrequency(CSecondaryRenderWaveBuffer *pBuffer, DWORD dwFrequency)
{
    // Find the buffer, then set its m_lPitchBend to a relative offset.
    // The relative offset is calculated by converting the difference in the buffer sample rate
    // to dwFrequency into a ratio of pitches and converting that ratio into pitch cents.
    for (DWORD dwBuffer = 0; dwBuffer < m_dwDSSBufCount; dwBuffer++)
    {
        if (pBuffer == m_ppDSSBuffers[dwBuffer].m_pDSBuffer->m_pDeviceBuffer)
        {
            double fTemp = (double) dwFrequency / (double) m_wfx.nSamplesPerSec;
            fTemp = log10(fTemp);
            fTemp *= 1200 * 3.3219280948873623478703194294894;    // Convert from Log10 to Log2 and multiply by cents per octave.
            m_ppDSSBuffers[dwBuffer].m_lPitchBend = (long) fTemp;
            UpdatePitchArray();
            return S_OK;
        }
    }
    return DSERR_INVALIDPARAM;
}

void CDirectSoundSink::UpdatePitchArray()
{
    // For each buffer:
    DWORD dwBuffer;
    for (dwBuffer = 0; dwBuffer < m_dwDSSBufCount; dwBuffer++)
    {
        // For each bus in each buffer:
        DWORD dwBusIndex;
        for (dwBusIndex = 0; dwBusIndex < m_ppDSSBuffers[dwBuffer].m_dwBusCount; dwBusIndex++)
        {
            DWORD dwGlobalBusIndex = m_ppDSSBuffers[dwBuffer].m_pdwBusIndex[dwBusIndex];
            m_plPitchBends[dwGlobalBusIndex] = m_ppDSSBuffers[dwBuffer].m_lPitchBend;
        }
    }
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::AddBuffer"

HRESULT CDirectSoundSink::AddBuffer(CDirectSoundBuffer *pDSBuffer, LPDWORD pdwNewFuncIDs, DWORD dwNewFuncIDsCount, DWORD dwNewBusIDsCount)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

#ifdef DEBUG
    // This function is only called internally.  It must be passed
    // a secondary buffer to make the cast below correct.
    DSBCAPS caps = {sizeof caps};
    HRESULT hrTemp = pDSBuffer->GetCaps(&caps);
    ASSERT(SUCCEEDED(hrTemp));
    ASSERT(!(caps.dwFlags & DSBCAPS_PRIMARYBUFFER));
#endif

    //
    // Check and set the range on the new bussid count
    //
    if (dwNewBusIDsCount < 1)
        dwNewBusIDsCount = 1;

    if (dwNewBusIDsCount > MAX_BUSIDS_PER_BUFFER)
        dwNewBusIDsCount = MAX_BUSIDS_PER_BUFFER;

    if (dwNewFuncIDsCount > dwNewBusIDsCount)
        dwNewFuncIDsCount = dwNewBusIDsCount;   // Can't have more functional IDs than bus IDs

    //
    // Reallocate buffers
    //
    if (m_dwBusIDs + dwNewBusIDsCount >= m_dwBusIDsAlloc)
    {
        hr = GrowBusArrays(dwNewBusIDsCount);  // More than we need, but what the heck
    }

    if (SUCCEEDED(hr))
    {
        DWORD i,j,l;
        DWORD dwNewBusIDIndex = m_dwBusIDs;

        // Add new ID's to master sink array's of id's
        for (i = 0; i < dwNewBusIDsCount; i++)
        {
            m_pdwBusIDs[dwNewBusIDIndex + i]  = m_dwNextBusID;
            if (i < dwNewFuncIDsCount)
            {
                m_pdwFuncIDs[dwNewBusIDIndex + i] = pdwNewFuncIDs[i];
            }
            else
            {
                m_pdwFuncIDs[dwNewBusIDIndex + i] = DSSINK_NULLBUSID;
            }

            m_dwNextBusID++;
            // we have rolled over, this case is very hard to get too, so we just bail
            // it would take 136years to get to if one created a new sound buffer every second
            if (m_dwNextBusID == DSSINK_NULLBUSID)
            {
                return E_FAIL;
            }
        }

        if (dwNewFuncIDsCount > 1)
        {
            // !!!!!!!!! Important asumption read !!!!!!!!!!!
            //
            // This is very important since, this is a built in assumption
            // By ordering the function ids, the coresponding bus id's are
            // also order in increasing value. Thus buses are appropriatly
            // mapped to their repective functionality in a interleaved buffer
            // For example if one passes in function ids right and left
            // in that order there will be swapped thus mapping correctly
            // to the appropriate interleaved channel. The DLS2 spec
            // states that channels are interleaved in their increasing
            // value of their functional ids.
            //
            // Ahh.. the old stand by, the bubble sort, an N^2 alogrithim
            // with a hopelessly wasteful use of cpu time moving and then
            // re-moving elements around. However in this case it is efficient,
            // since generally there will only be two elements in the array.
            // And when the day comes when we may handle N levels of interleaving
            // it should be converted to the straight insertion method instead.
            // If only as an exercise to remind one self that there are other
            // simple efficient sorts out there. The reason that their is a
            // sort at all is to handle any crazy person who passes in more
            // than 2 function IDs.

            for (i = dwNewBusIDIndex; i < dwNewBusIDIndex + dwNewFuncIDsCount; i++)
            {
                // Null busids are considered an undefined channel
                if (m_pdwFuncIDs[i] == DSSINK_NULLBUSID)
                {
                    continue;
                }

                for (j = i + 1; j < dwNewBusIDIndex + dwNewFuncIDsCount; j++)
                {
                    if (m_pdwFuncIDs[j] == DSSINK_NULLBUSID)
                    {
                        continue;
                    }

                    if (m_pdwFuncIDs[i] > m_pdwFuncIDs[j])
                    {
                        DWORD temp = m_pdwFuncIDs[i];
                        m_pdwFuncIDs[i] = m_pdwFuncIDs[j];
                        m_pdwFuncIDs[j] = temp;
                    }
                }
            }
        }

        //
        // Initialize new sound buffer wrapper object
        //
        DSSinkBuffers &pDSSBuffer = m_ppDSSBuffers[m_dwDSSBufCount];

        pDSSBuffer.m_pDSBuffer  = (CDirectSoundSecondaryBuffer*)pDSBuffer;
        pDSSBuffer.m_dwBusCount = dwNewBusIDsCount;

        for (i = 0; i < dwNewBusIDsCount; i++)
        {
            pDSSBuffer.m_pdwBusIds[i]   = m_pdwBusIDs[dwNewBusIDIndex+i];
            pDSSBuffer.m_pdwBusIndex[i] = dwNewBusIDIndex+i;

            if (i < dwNewFuncIDsCount)
            {
                pDSSBuffer.m_pdwFuncIds[i] = m_pdwFuncIDs[dwNewBusIDIndex+i];
            }
            else
            {
                pDSSBuffer.m_pdwFuncIds[i] = DSSINK_NULLBUSID;
            }
        }

        hr = pDSSBuffer.Initialize(m_dwBusSize);  // Allocate all internal arrays


        if (SUCCEEDED(hr))
        {
            m_ppDSSBuffers[m_dwDSSBufCount].m_pDSBuffer->ClearWriteBuffer();  // Fill the buffer with silence

            m_dwDSSBufCount++;
            m_dwBusIDs += dwNewBusIDsCount;

            // Remap all busid indexes
            for (i = 0; i < m_dwDSSBufCount; i++)
            {
                // Find the bus id in the buffer object
                for (j = 0; j < m_ppDSSBuffers[i].m_dwBusCount; j++)
                {
                    for (l = 0; l < m_dwBusIDs; l++)
                    {
                        if (m_ppDSSBuffers[i].m_pdwBusIds[j] == m_pdwBusIDs[l])
                        {
                            m_ppDSSBuffers[i].m_pdwBusIndex[j] = l;
                            break;
                        }
                    }
                }
            }

            for (i = 0; i < m_dwDSSources; i++)
            {
                for (j = 0; j < m_dwBusIDs; j++)
                {
                    if (m_pdwBusIDs[j] == m_pDSSources[i].m_dwBusID)
                    {
                        m_pDSSources[i].m_dwBusIndex = j;
                        break;
                    }
                }
            }

            DPF(DPFLVL_INFO, "Adding Bus [%d]", m_dwDSSBufCount-1);
            DPF(DPFLVL_INFO, "Number Buses = %d", dwNewBusIDsCount);
            for (i = 0; i < dwNewBusIDsCount; i++)
                DPF(DPFLVL_INFO, "Bus ID=%d  Function ID=%d", m_pdwBusIDs[dwNewBusIDIndex + i], m_pdwFuncIDs[dwNewBusIDIndex + i]);

            UpdatePitchArray();
        }
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::RemoveBuffer"

HRESULT CDirectSoundSink::RemoveBuffer(CDirectSoundBuffer *pDSBuffer)
{
    DWORD i,j,k,l;
    DPF_ENTER();

    for (i = 0; i < m_dwDSSBufCount; i++)
    {
        if (pDSBuffer == m_ppDSSBuffers[i].m_pDSBuffer)
        {
#ifdef DEBUG_SINK
            DPF(DPFLVL_INFO, "Removing Buffer %ld", i);
#endif
            // Find the bus id in the buffer objects
            for (j = 0; j < m_ppDSSBuffers[i].m_dwBusCount; j++)
            {
                for (k = 0; k < m_dwBusIDs; k++)
                {
                    if (m_ppDSSBuffers[i].m_pdwBusIds[j] == m_pdwBusIDs[k])
                    {
                        // contract the main array
                        for (l = k; l < m_dwBusIDs-1; l++)
                        {
                            m_pdwBusIDs[l]  = m_pdwBusIDs[l+1];
                            m_pdwFuncIDs[l] = m_pdwFuncIDs[l+1];
                        }
                        m_pdwBusIDs[l]  = DSSINK_NULLBUSID;
                        m_pdwFuncIDs[l] = DSSINK_NULLBUSID;


                        m_dwBusIDs--;
                    }
                }
            }

            // Delete allocated memory
            for (l = 0; l < m_ppDSSBuffers[i].m_dwBusCount; l++)
            {
                if (m_ppDSSBuffers[i].m_pvBussStart[l])
                {
                    MEMFREE(m_ppDSSBuffers[i].m_pvBussStart[l]);
                    m_ppDSSBuffers[i].m_pvBussStart[l] = NULL;
                }

                if (m_ppDSSBuffers[i].m_pvBussEnd[l])
                {
                    MEMFREE(m_ppDSSBuffers[i].m_pvBussEnd[l]);
                    m_ppDSSBuffers[i].m_pvBussEnd[l] = NULL;
                }
            }

            // Contract array
            for (k = i; k < m_dwDSSBufCount-1; k++)
            {
                // Shift the whole thang over. (There was a bug before where only some fields were being copied down.)
                m_ppDSSBuffers[k] = m_ppDSSBuffers[k+1];
            }

            // Clear last structure
            m_ppDSSBuffers[k].m_pDSBuffer    = NULL;
            m_ppDSSBuffers[k].m_dwBusCount   = 0;
            m_ppDSSBuffers[k].m_pvDSBufStart = NULL;
            m_ppDSSBuffers[k].m_pvDSBufEnd   = NULL;
            m_ppDSSBuffers[k].dwStart        = 0;
            m_ppDSSBuffers[k].dwEnd          = 0;
            for (l = 0; l < MAX_BUSIDS_PER_BUFFER; l++)
            {
                m_ppDSSBuffers[k].m_pdwBusIndex[l] = DSSINK_NULLBUSID;
                m_ppDSSBuffers[k].m_pdwBusIds[l]   = DSSINK_NULLBUSID;
                m_ppDSSBuffers[k].m_pdwFuncIds[l]  = DSSINK_NULLBUSID;
                m_ppDSSBuffers[k].m_pvBussStart[l] = NULL;
                m_ppDSSBuffers[k].m_pvBussEnd[l]   = NULL;
            }

            m_dwDSSBufCount--;
            break;
        }
    }

    // Remap all busid indexes
    for (i = 0; i < m_dwDSSBufCount; i++)
    {
        // Find the bus id in the buffer object
        for (j = 0; j < m_ppDSSBuffers[i].m_dwBusCount; j++)
        {
            for (l = 0; l < m_dwBusIDs; l++)
            {
                if (m_ppDSSBuffers[i].m_pdwBusIds[j] == m_pdwBusIDs[l])
                {
                    m_ppDSSBuffers[i].m_pdwBusIndex[j] = l;
                    break;
                }
            }
        }
    }

    for (i = 0; i < m_dwDSSources; i++)
    {
        for (j = 0; j < m_dwBusIDs; j++)
        {
            if (m_pdwBusIDs[j] == m_pDSSources[i].m_dwBusID)
            {
                m_pDSSources[i].m_dwBusIndex = j;
                break;
            }
        }
    }
    UpdatePitchArray();
    // BUGBUG WI 33785 goes here
    //
    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::AddSource"

HRESULT CDirectSoundSink::AddSource(IDirectSoundSource *pSource)
{
    DPF_ENTER();
    HRESULT hr = DS_OK;

    //
    // Check if source already exsists
    //
    for (DWORD i = 0; i < m_dwDSSources; i++)
    {
        if (pSource == m_pDSSources[i].m_pDSSource)
        {
            hr = S_FALSE;
        }
    }

    if (hr == DS_OK)
    {
        //
        // Reallocate buffers
        //
        if (m_dwDSSources + 1 >= m_dwDSSourcesAlloc)
        {
            hr = GrowSourcesArrays(1);
        }

        if (SUCCEEDED(hr))
        {
            if (pSource)
            {
                m_pDSSources[m_dwDSSources].m_pDSSource    = pSource;
#ifdef FUTURE_WAVE_SUPPORT
                m_pDSSources[m_dwDSSources].m_pWave        = NULL;
#endif
                m_pDSSources[m_dwDSSources].m_stStartTime  = 0;
                m_pDSSources[m_dwDSSources].m_dwBusID      = DSSINK_NULLBUSID;
                m_pDSSources[m_dwDSSources].m_dwBusCount   = 0;
                m_pDSSources[m_dwDSSources].m_dwBusIndex   = DSSINK_NULLBUSID;
                m_pDSSources[m_dwDSSources].m_bStreamEnd   = FALSE;
                m_pDSSources[m_dwDSSources].m_pDSSource->AddRef();
                m_dwDSSources++;
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::RemoveSource"

HRESULT CDirectSoundSink::RemoveSource(IDirectSoundSource *pSource)
{
    DPF_ENTER();

    HRESULT hr = DS_OK;
    DWORD i;

    //
    // Check if source exists
    //
    for (i = 0; i < m_dwDSSources; i++)
    {
        if (pSource == m_pDSSources[i].m_pDSSource)
        {
            break;
        }
    }

    if (i >= m_dwDSSources)
    {
        // Source not in this sink
        hr = DSERR_INVALIDPARAM;
    }

    if (SUCCEEDED(hr))
    {
#ifdef FUTURE_WAVE_SUPPORT
        // If this is a wave source, then remove associated sound buffer
        if (m_pDSSources[i].m_dwBusID != DSSINK_NULLBUSID)
        {
            for (DWORD j = 0; j < m_dwDSSBufCount; j++)
            {
                for (DWORD k = 0; k < m_ppDSSBuffers[j].m_dwBusCount; k++)
                {
                    if (m_ppDSSBuffers[j].m_pdwBusIds[k] == m_pDSSources[i].m_dwBusID)
                    {
//>>>>>>>>>>> look into this, possible critical section problem.
                        RELEASE(m_ppDSSBuffers[j].m_pDSBuffer);
//>>>> Should be:
//                        RemoveBuffer(m_ppDSSBuffers[j].m_pDSBuffer)
                        goto done;
                    }
                }
            }
        }
        done:
#endif

        // Remove source
        if (m_pDSSources[i].m_pDSSource)
        {
            m_pDSSources[i].m_pDSSource->Release();
        }
        m_pDSSources[i].m_pDSSource = NULL;

        // Contract arrays
        for (; i < m_dwDSSources-1; i++)
        {
            m_pDSSources[i] = m_pDSSources[i+1];
        }

        // Clear last element
        m_pDSSources[i].m_pDSSource    = NULL;
#ifdef FUTURE_WAVE_SUPPORT
        m_pDSSources[i].m_pWave        = NULL;
#endif
        m_pDSSources[i].m_stStartTime  = 0;
        m_pDSSources[i].m_dwBusID      = DSSINK_NULLBUSID;
        m_pDSSources[i].m_dwBusCount   = 0;
        m_pDSSources[i].m_dwBusIndex   = DSSINK_NULLBUSID;
        m_pDSSources[i].m_bStreamEnd   = FALSE;

        m_dwDSSources--;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetLatencyClock"

HRESULT CDirectSoundSink::GetLatencyClock(IReferenceClock **ppClock)
{
    DPF_ENTER();

    HRESULT hr = m_LatencyClock.QueryInterface(IID_IReferenceClock,(void **)ppClock);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::Activate"

HRESULT CDirectSoundSink::Activate(BOOL fEnable)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (m_fActive != fEnable)
    {
        if (fEnable)
            hr = m_pStreamingThread->RegisterSink(this);
        else
            m_pStreamingThread->UnregisterSink(this);

        if (SUCCEEDED(hr))
            m_fActive = fEnable;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::SampleToRefTime"

HRESULT CDirectSoundSink::SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prt)
{
    DPF_ENTER();

    m_SampleClock.SampleToRefTime(llSampleTime, prt);

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::RefToSampleTime"

HRESULT CDirectSoundSink::RefToSampleTime(REFERENCE_TIME rt, LONGLONG *pllSampleTime)
{
    DPF_ENTER();

    *pllSampleTime = m_SampleClock.RefToSampleTime(rt);

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetFormat"

HRESULT CDirectSoundSink::GetFormat(LPWAVEFORMATEX pwfx, LPDWORD pdwsize)
{
   DPF_ENTER();

   HRESULT hr = CopyWfxApi(&m_wfx, pwfx, pdwsize);

   DPF_LEAVE_HRESULT(hr);
   return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::CreateSoundBuffer"

HRESULT CDirectSoundSink::CreateSoundBuffer(LPCDSBUFFERDESC pDSBufferDesc, LPDWORD pdwFuncIDs, DWORD dwFuncIDsCount, REFGUID guidBufferID, CDirectSoundBuffer **ppDsBuffer)
{
    CDirectSoundSecondaryBuffer* pDsSecondaryBuffer;

    DPF_ENTER();

    HRESULT hr = DS_OK;
    DSBUFFERDESC DSBufferDesc;
    WAVEFORMATEX wfx;

    if (SUCCEEDED(hr))
    {
        //
        // Initialize buffer description
        //
        DSBufferDesc = *pDSBufferDesc;

        //
        // Retrieve number of channels from format struct and recalculate
        //

        // Future release: Make it work with wave format extensible.
        //
        wfx = m_wfx;
        if (pDSBufferDesc->lpwfxFormat)
        {
            wfx.nChannels = pDSBufferDesc->lpwfxFormat->nChannels;
            wfx.nBlockAlign = wfx.nChannels * (wfx.wBitsPerSample/8);
            wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
        }
        DSBufferDesc.lpwfxFormat = &wfx;
        DSBufferDesc.dwBufferBytes = m_dwBusSize * wfx.nChannels;

        //
        // Create the DirectSound buffer
        //
        hr = m_pDirectSound->CreateSinkBuffer(&DSBufferDesc, guidBufferID, &pDsSecondaryBuffer, this);
        if (SUCCEEDED(hr))
        {
            *ppDsBuffer = pDsSecondaryBuffer;
            //
            // Add the bus. Note that this really shouldn't be happening for MIXIN buffers, but we seem to need it...
            //
            hr = AddBuffer(pDsSecondaryBuffer, pdwFuncIDs, dwFuncIDsCount, wfx.nChannels);
            if (SUCCEEDED(hr))
            {
                // Initialize clock buffer
                //
                // BUGBUG WI 33785
                // Note that the audiopath code creates a mono buffer the very first time a buffer is requested and hangs
                // on to it until close down. This buffer ends up being the one set up as the clock reference.
                // Once the clock hopping bug is fixed, we can remove this.
                //
                if (m_dwDSSBufCount == 1)
                {
                    m_dwMasterBuffChannels = wfx.nChannels;
                    m_dwMasterBuffSize     = DSBufferDesc.dwBufferBytes;

                    // Flag m_dwWriteTo that m_dwLatency has changed for reset down in the render thread
                    m_dwWriteTo = 0;
                }
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::CreateSoundBufferFromConfig"

HRESULT CDirectSoundSink::CreateSoundBufferFromConfig(IUnknown *pIUnkDSBufferConfig, CDirectSoundBuffer **ppDsBuffer)
{
    CDirectSoundSecondaryBuffer* pDsSecondaryBuffer;
    CDirectSoundBufferConfig* pDSBConfigObj = NULL;

    HRESULT hr = DS_OK;
    DPF_ENTER();

    CHECK_READ_PTR(pIUnkDSBufferConfig);
    CHECK_WRITE_PTR(ppDsBuffer);

    //
    // Retrieve the DSBufferConfig Class object
    //
    if (pIUnkDSBufferConfig)
    {
        //
        // Identify the object as the correct class so it's safe to cast.
        // This breaks COM rules, and what is actually returned is a this pointer to the class.
        pDSBConfigObj = NULL;
        hr = pIUnkDSBufferConfig->QueryInterface(CLSID_PRIVATE_CDirectSoundBufferConfig, (void**)&pDSBConfigObj);
    }

    if (pDSBConfigObj == NULL)
    {
        hr = DSERR_INVALIDPARAM;
    }
    else if (!(pDSBConfigObj->m_fLoadFlags & DSBCFG_DSBD))
    {
        //
        // We are failing to create the buffers here because
        // we must have at least a loaded sound buffer description
        //
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        //
        // Retrieve number of channels from format struct and recalculate the waveformat structure
        //
        // Future release: make it work with wave format extensible.
        WAVEFORMATEX wfx = m_wfx;
        if (pDSBConfigObj->m_DSBufferDesc.nChannels > 0)  // Check for the presence of a channel value
        {
            wfx.nChannels = pDSBConfigObj->m_DSBufferDesc.nChannels;
            wfx.nBlockAlign = wfx.nChannels * (wfx.wBitsPerSample/8);
            wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
        }

        //
        // Set up a buffer description structure
        //
        DSBUFFERDESC DSBufferDesc = {sizeof DSBufferDesc,
                                     pDSBConfigObj->m_DSBufferDesc.dwFlags,
                                     m_dwBusSize * wfx.nChannels,
                                     pDSBConfigObj->m_DSBufferDesc.dwReserved,
                                     &wfx};

        if (DSBufferDesc.dwFlags & DSBCAPS_CTRL3D)
            DSBufferDesc.guid3DAlgorithm = pDSBConfigObj->m_DS3DDesc.guid3DAlgorithm;

        //
        // Create the DirectSound buffer
        //
        hr = m_pDirectSound->CreateSinkBuffer(&DSBufferDesc, pDSBConfigObj->m_DMUSObjectDesc.guidObject, &pDsSecondaryBuffer, this);
        if (SUCCEEDED(hr))
        {
            *ppDsBuffer = pDsSecondaryBuffer;

            if (DSBufferDesc.dwFlags & DSBCAPS_CTRLVOLUME)
            {
                hr = pDsSecondaryBuffer->SetVolume(pDSBConfigObj->m_DSBufferDesc.lVolume);
            }

            if (SUCCEEDED(hr) && (DSBufferDesc.dwFlags & DSBCAPS_CTRLPAN))
            {
                hr = pDsSecondaryBuffer->SetPan(pDSBConfigObj->m_DSBufferDesc.lPan);
            }

            if (SUCCEEDED(hr) && (DSBufferDesc.dwFlags & DSBCAPS_CTRL3D) && (pDSBConfigObj->m_fLoadFlags & DSBCFG_DS3D))
            {
                IDirectSound3DBuffer8 *p3D = NULL;
                hr = pDsSecondaryBuffer->QueryInterface(IID_IDirectSound3DBuffer8, FALSE, (void**)&p3D);
                if (SUCCEEDED(hr))
                {
                    hr = p3D->SetAllParameters(&pDSBConfigObj->m_DS3DDesc.ds3d, DS3D_IMMEDIATE);
                }
                RELEASE(p3D);
            }

            //
            // Pass the buffer config object so FX can be cloned from it
            //
            if (SUCCEEDED(hr) && (DSBufferDesc.dwFlags & DSBCAPS_CTRLFX) && (pDSBConfigObj->m_fLoadFlags & DSBCFG_DSFX))
            {
                hr = pDsSecondaryBuffer->SetFXBufferConfig(pDSBConfigObj);
            }

            if (SUCCEEDED(hr))
            {
                //
                // Add the bus.
                //
                hr = AddBuffer(pDsSecondaryBuffer, pDSBConfigObj->m_pdwFuncIDs, pDSBConfigObj->m_dwFuncIDsCount, wfx.nChannels);
                if (SUCCEEDED(hr))
                {
                    //
                    // Initialize master buffer paramters
                    //
                    if (m_dwDSSBufCount == 1)
                    {
                        m_dwMasterBuffChannels = wfx.nChannels;
                        m_dwMasterBuffSize = DSBufferDesc.dwBufferBytes;

                        // Flag m_dwWriteTo that m_dwLatency has changed for reset down in the render thread
                        m_dwWriteTo = 0;
                    }
                }
            }
            else
            {
                RELEASE(pDsSecondaryBuffer);
                *ppDsBuffer = NULL;
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#ifdef FUTURE_WAVE_SUPPORT
#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::CreateSoundBufferFromWave"

HRESULT CDirectSoundSink::CreateSoundBufferFromWave(IDirectSoundWave *pWave, DWORD dwFlags, CDirectSoundBuffer **ppDsBuffer)
{
    DPF_ENTER();

    HRESULT hr = DS_OK;
    DSBUFFERDESC DSBufferDesc;
    WAVEFORMATEX wfx;
    IDirectSoundSource *pSrc = NULL;
    DWORD dwSize = sizeof(wfx);
    DWORD dwBusID = DSSINK_NULLBUSID;
    DWORD dwBusIndex = DSSINK_NULLBUSID;
    DWORD dwBusCount = 1;

    ZeroMemory(&wfx, sizeof wfx);
    ZeroMemory(&DSBufferDesc, sizeof(DSBufferDesc));
    DSBufferDesc.dwSize = sizeof(DSBufferDesc);
    DSBufferDesc.dwFlags = dwFlags | DSBCAPS_FROMWAVEOBJECT;

    // Future release: Make it to work with wave format extensible.
    hr = pWave->GetFormat(&wfx, dwSize, NULL);
    if (SUCCEEDED(hr))
    {
        WORD nChannels = wfx.nChannels;  // Save off channels
        wfx = m_wfx;
        wfx.nChannels = nChannels;
        wfx.nBlockAlign = wfx.nChannels * (wfx.wBitsPerSample/8);
        wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

        hr = pWave->CreateSource(&pSrc, &wfx, 0);
        if (SUCCEEDED(hr) && pSrc != NULL)
        {
            DSBufferDesc.lpwfxFormat = &wfx;
            DSBufferDesc.dwBufferBytes = MsToBytes(m_dwBusSize, &wfx);
            hr = CreateSoundBuffer(&DSBufferDesc, NULL, 0, ppDsBuffer);
            if (SUCCEEDED(hr) && *ppDsBuffer)
            {
                hr = GetSoundBufferBusIDs(*ppDsBuffer, &dwBusID, NULL, &dwBusCount);
                if (SUCCEEDED(hr))
                {
                    // Flag newly created buffer a wavesource buffer
                    for (DWORD i = 0; i < m_dwDSSBufCount; i++)
                    {
                        for (DWORD j = 0; j < m_ppDSSBuffers[i].m_dwBusCount; j++)
                        {
                            if (m_ppDSSBuffers[i].m_pdwBusIds[j] == dwBusID)
                            {
                                dwBusCount = m_ppDSSBuffers[i].m_dwBusCount;
                                goto done;
                            }
                        }
                    }
                    done:

                    // Retrieve the index of the bus id
                    for (i = 0; i < m_dwBusIDs; i++)
                    {
                        if (m_pdwBusIDs[i] == dwBusID)
                        {
                            dwBusIndex = i;
                            break;
                        }
                    }

                    if (m_dwDSSources + 1 >= m_dwDSSourcesAlloc)
                    {
                        hr = GrowSourcesArrays(1);
                    }

                    if (SUCCEEDED(hr))
                    {
                        m_pDSSources[m_dwDSSources].m_pDSSource    = pSrc;
#ifdef FUTURE_WAVE_SUPPORT
                        m_pDSSources[m_dwDSSources].m_pWave        = pWave;
#endif
                        m_pDSSources[m_dwDSSources].m_stStartTime  = 0;
                        m_pDSSources[m_dwDSSources].m_dwBusID      = dwBusID;
                        m_pDSSources[m_dwDSSources].m_dwBusCount   = dwBusCount;
                        m_pDSSources[m_dwDSSources].m_dwBusIndex   = dwBusIndex;
                        m_pDSSources[m_dwDSSources].m_bStreamEnd   = FALSE;
                        m_dwDSSources++;
                    }
                }
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // FUTURE_WAVE_SUPPORT


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::FindBufferFromGUID"

CDirectSoundSecondaryBuffer* CDirectSoundSink::FindBufferFromGUID(REFGUID guidBufferID)
{
    CDirectSoundSecondaryBuffer* pBufferFound = NULL;
    DPF_ENTER();

    for (DWORD i = 0; i < m_dwDSSBufCount; i++)
        if (m_ppDSSBuffers[i].m_pDSBuffer->GetGUID() == guidBufferID)
            pBufferFound = m_ppDSSBuffers[i].m_pDSBuffer;

    // We intentionally loop through all buffers in order to return the
    // last matching buffer (i.e., the most recently created one).

    DPF_LEAVE(pBufferFound);
    return pBufferFound;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetSoundBuffer"

HRESULT CDirectSoundSink::GetSoundBuffer(DWORD dwBusId, CDirectSoundBuffer **ppCdsb)
{
    DPF_ENTER();
    HRESULT hr = DSERR_INVALIDPARAM;

    for (DWORD i = 0; i < m_dwDSSBufCount; i++)
    {
        for (DWORD j = 0; j < m_ppDSSBuffers[i].m_dwBusCount; j++)
        {
            if (m_ppDSSBuffers[i].m_pdwBusIds[j] == DSSINK_NULLBUSID)
                break;

            if (m_ppDSSBuffers[i].m_pdwBusIds[j] == dwBusId)
            {
                *ppCdsb = m_ppDSSBuffers[i].m_pDSBuffer;
                m_ppDSSBuffers[i].m_pDSBuffer->AddRef();
                hr = DS_OK;
                goto done;
            }
        }
    }
done:

    DPF_LEAVE_HRESULT(hr);
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetBusCount"

HRESULT CDirectSoundSink::GetBusCount(DWORD *pdwCount)
{
    DPF_ENTER();

    *pdwCount = m_dwBusIDs;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetBusIDs"

HRESULT CDirectSoundSink::GetBusIDs(LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount)
{
    DPF_ENTER();

    DWORD count;

    if (dwBusCount > m_dwBusIDs)
    {
        count = m_dwBusIDs;
    }
    else
    {
        count = dwBusCount;
    }

    FillMemory(pdwBusIDs, dwBusCount * sizeof *pdwBusIDs, 0xFF);  // Clear array
    CopyMemory(pdwBusIDs, m_pdwBusIDs, count * sizeof *m_pdwBusIDs);
    CopyMemory(pdwFuncIDs, m_pdwFuncIDs, count * sizeof *m_pdwFuncIDs);

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetSoundBufferBusIDs"

HRESULT CDirectSoundSink::GetSoundBufferBusIDs(CDirectSoundBuffer *pCDirectSoundBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount)
{
    HRESULT hr = DSERR_INVALIDPARAM;
    DPF_ENTER();

    ASSERT(pCDirectSoundBuffer);
    ASSERT(pdwBusIDs);
    ASSERT(pdwBusCount);

    for (DWORD i = 0; i < m_dwDSSBufCount; i++)
    {
        if (pCDirectSoundBuffer == m_ppDSSBuffers[i].m_pDSBuffer)
        {
            DWORD dwmaxbusscount = *pdwBusCount;
            if (dwmaxbusscount > m_ppDSSBuffers[i].m_dwBusCount)
            {
                dwmaxbusscount = m_ppDSSBuffers[i].m_dwBusCount;
            }
            *pdwBusCount = 0;

            for (DWORD j = 0; j < dwmaxbusscount; j++)
            {
                if (m_ppDSSBuffers[i].m_pdwBusIds[j] == DSSINK_NULLBUSID)
                    break;

                pdwBusIDs[j] = m_ppDSSBuffers[i].m_pdwBusIds[j];
                if (pdwFuncIDs)
                {
                    pdwFuncIDs[j] = m_ppDSSBuffers[i].m_pdwFuncIds[j];
                }
                (*pdwBusCount)++;
            }
            hr = DS_OK;
            break;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::GetFunctionalID"

HRESULT CDirectSoundSink::GetFunctionalID(DWORD dwBusIDs, LPDWORD pdwFuncID)
{
    HRESULT hr = DSERR_INVALIDPARAM;
    DPF_ENTER();

    for (DWORD i = 0; i < m_dwBusIDs; i++)
    {
        if (m_pdwBusIDs[i] == dwBusIDs)
        {
            *pdwFuncID = m_pdwFuncIDs[i];
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::SetMasterClock"

HRESULT CDirectSoundSink::SetMasterClock(IReferenceClock *pClock)
{
    DPF_ENTER();

    RELEASE(m_pDSSSinkSync);
    m_pDSSSinkSync = NULL;
    RELEASE(m_pIMasterClock);

    m_pIMasterClock = pClock;
    if (m_pIMasterClock)
    {
        m_pIMasterClock->AddRef();
        m_pIMasterClock->QueryInterface(IID_IDirectSoundSinkSync, (void**)&m_pDSSSinkSync);
    }

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::Render"

HRESULT CDirectSoundSink::Render(STIME stStartTime, DWORD dwLastWrite, DWORD dwBytesToFill, LPDWORD pdwBytesRendered)
{
    HRESULT hr = S_FALSE;
    ULONGLONG BytesToRead;
    CDirectSoundSecondaryBuffer* pDSBuffer;
    IDirectSoundSource *pSource;
    DWORD BusCount;
    DWORD dwChannels;
    DWORD BusIndex;
    DWORD CurrentBusIndex = 0;
    DWORD dwStart  = 0;
    DWORD dwEnd    = 0;
    DWORD dwMasterStart = 0;
    DWORD dwMasterEnd   = 0;
    DWORD dwBussStartBytes = 0;
    DWORD dwBussEndBytes   = 0;
    DWORD dwBytes;
    DWORD dwWriteCursor;
    LONGLONG llStartPosition;
    DWORD i, j;

    *pdwBytesRendered = 0;  // We haven't rendered anything yet...

    //
    // Make sure there are buffers, and at least one sound buffer
    //
    if (!m_ppDSSBuffers)
        return S_FALSE;

    if (m_ppDSSBuffers[0].m_pDSBuffer == NULL && m_ppDSSBuffers[0].m_bPlaying)
        return S_FALSE;

#ifdef DEBUG_SINK
    wsprintfA(m_szDbgDump, "DSOUND SINK: ");
#endif

    //
    // Fill an array of locked buffer pointers
    //
    for (i = 0; i < m_dwDSSBufCount; i++)
    {
        // Ignore this buffer; it's either inactive, or
        // hasn't retrieved its offset off the master buffer yet
        if (m_ppDSSBuffers[i].m_bPlaying == FALSE || m_ppDSSBuffers[i].m_bActive == FALSE)
        {
            DPF(DPFLVL_MOREINFO, "Skipping buffer %ld at %p", i, m_ppDSSBuffers[i]);
            continue;
        }
#ifdef DEBUG_SINK
        wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "%ld[", i);
#endif

        dwChannels = m_ppDSSBuffers[i].m_dwBusCount;
        BusCount   = m_ppDSSBuffers[i].m_dwBusCount;
        pDSBuffer  = m_ppDSSBuffers[i].m_pDSBuffer;

        if (pDSBuffer == NULL || BusCount == 0)
            continue;   // This is effectively an error condition

        dwBytes       = (dwBytesToFill*dwChannels)/m_dwMasterBuffChannels;
        dwWriteCursor = (dwLastWrite*dwChannels)/m_dwMasterBuffChannels;

        if (dwLastWrite % (m_dwMasterBuffChannels*2))
            DPF(DPFLVL_WARNING, "Master buffer last write cursor not sample aligned [%d]", dwLastWrite);

        if (dwBytesToFill % (m_dwMasterBuffChannels*2))
            DPF(DPFLVL_WARNING, "Master buffer dwBytesToFill not sample aligned [%d]", dwBytesToFill);

        if (dwWriteCursor % (dwChannels*2))
            DPF(DPFLVL_WARNING, "Master buffer write cursor not sample aligned [%d]", dwWriteCursor);

        if (dwBytes % (dwChannels*2))
            DPF(DPFLVL_WARNING, "Master buffer bytes not sample aligned [%d]", dwBytes);

        if (i != 0)
            dwWriteCursor = (dwWriteCursor + m_ppDSSBuffers[i].m_dwWriteOffset) % (m_dwBusSize*dwChannels);

        // BUGBUG
        // These traces assume 16-bit format.
        //
        if (dwWriteCursor % (dwChannels*2)) DPF(DPFLVL_WARNING, "Slave buffer write cursor not sample aligned");
        if (dwBytes % (dwChannels*2)) DPF(DPFLVL_WARNING, "Slave buffer bytes not sample aligned");

        // Mark the part of the buffer which will have fresh data for FX processing
        pDSBuffer->SetCurrentSlice(dwWriteCursor, dwBytes);

        hr = pDSBuffer->DirectLock(dwWriteCursor, dwBytes,
                                   &m_ppDSSBuffers[i].m_pvDSBufStart, &m_ppDSSBuffers[i].dwStart,
                                   &m_ppDSSBuffers[i].m_pvDSBufEnd,   &m_ppDSSBuffers[i].dwEnd);
        if (FAILED(hr))
        {
            BREAK();    // Break into the debugger
            continue;   // This is effectively an error condition
        }

        dwStart = m_ppDSSBuffers[i].dwStart;
        dwEnd   = m_ppDSSBuffers[i].dwEnd;

        // First buffer is the clock buffer, kick it aside just in case
        //
        // BUGBUG WI 33785
        //
        if (i == 0)
        {
            dwMasterStart    = dwStart;
            dwMasterEnd      = dwEnd;
            dwBussStartBytes = dwMasterStart/m_dwMasterBuffChannels;
            dwBussEndBytes   = dwMasterEnd/m_dwMasterBuffChannels;
        }
        else
        {
            if (dwBussStartBytes + dwBussEndBytes != (dwStart + dwEnd)/dwChannels)
            {
                DPF(DPFLVL_WARNING, "Play cursors out of sync: Master start[%d] end[%d] Slave start[%d] end[%d]", dwMasterStart, dwMasterEnd, dwStart, dwEnd);
                continue;
            }
        }

        if (SUCCEEDED(hr))
        {
            for (j = 0; j < BusCount; j++)
            {
                BusIndex = m_ppDSSBuffers[i].m_pdwBusIndex[j];
                if (BusIndex == DSSINK_NULLBUSID)
                {
                    continue;
                }
#ifdef DEBUG_SINK
                wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "%ld,", BusIndex);
#endif

                m_pdwActiveBusIDs[CurrentBusIndex]  = m_pdwBusIDs[BusIndex];
                m_pdwActiveFuncIDs[CurrentBusIndex] = m_pdwFuncIDs[BusIndex];
                m_pdwActiveBusIDsMap[BusIndex]      = CurrentBusIndex;

                if (dwBussStartBytes == dwStart && dwBussEndBytes == dwEnd && dwChannels == 1)
                {
                    // If mono bus write directly into the sound buffer
                    m_ppvStart[CurrentBusIndex] = m_ppDSSBuffers[i].m_pvDSBufStart;
                    m_ppvEnd[CurrentBusIndex]   = m_ppDSSBuffers[i].m_pvDSBufEnd;
                    m_ppDSSBuffers[i].m_bUsingLocalMemory = FALSE;
                    if (dwStart)
                    {
                        ZeroMemory(m_ppvStart[CurrentBusIndex], dwStart);
                    }
                    if (dwEnd)
                    {
                        ZeroMemory(m_ppvEnd[CurrentBusIndex], dwEnd);
                    }
                }
                else
                {
                    // If a stereo buss write directly into local sink buffer memory
                    m_ppvStart[CurrentBusIndex] = m_ppDSSBuffers[i].m_pvBussStart[j];
                    m_ppvEnd[CurrentBusIndex]   = m_ppDSSBuffers[i].m_pvBussEnd[j];
                    m_ppDSSBuffers[i].m_bUsingLocalMemory = TRUE;
                    if (dwBussStartBytes)
                    {
                        ZeroMemory(m_ppvStart[CurrentBusIndex], dwBussStartBytes);
                    }
                    if (dwBussEndBytes)
                    {
                        ZeroMemory(m_ppvEnd[CurrentBusIndex], dwBussEndBytes);
                    }
                }

                CurrentBusIndex++;
            }
        }
#ifdef DEBUG_SINK
        wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "]");
#endif
    }
    if (SUCCEEDED(hr) || dwMasterStart)
    {
        //
        // Read the data from the source
        //
        for (i = 0; i < m_dwDSSources; i++)
        {
            //
            // Check to see if source is ready to play
            //
            if (m_pDSSources[i].m_bStreamEnd)
            {
                continue;
            }

            //
            // Set start position in bytes to where to read from
            //
            llStartPosition = (stStartTime-m_pDSSources[i].m_stStartTime) * 2;  // Samples to Byte, not including channels!!!
            pSource  = m_pDSSources[i].m_pDSSource;
            BusIndex = m_pDSSources[i].m_dwBusIndex;
            BusCount = m_pDSSources[i].m_dwBusCount;

            if (pSource)
            {
                if (dwBussStartBytes)
                {
                    BytesToRead = dwBussStartBytes;

                    pSource->Seek(llStartPosition);

                    if (BusIndex != DSSINK_NULLBUSID)
                    {
                        BusIndex = m_pdwActiveBusIDsMap[BusIndex];  // Remap to current active buss
                        hr = pSource->Read((void**)&m_ppvStart[BusIndex], &m_pdwBusIDs[BusIndex], &m_pdwFuncIDs[BusIndex], &m_plPitchBends[BusIndex], BusCount, &BytesToRead);
#ifdef DEBUG_SINK
                        wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "Remap:");
#endif
                    }
                    else
                    {
                        hr = pSource->Read((void**)m_ppvStart, m_pdwActiveBusIDs, m_pdwActiveFuncIDs, m_plPitchBends, CurrentBusIndex, &BytesToRead);
                    }
#ifdef DEBUG_SINK
                    wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "Start:");
                    DWORD dwX;
                    for (dwX = 0;dwX < CurrentBusIndex;dwX++)
                    {
                        wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "(%ld:%ld,%ld),", dwX, m_pdwActiveBusIDs[dwX], m_pdwActiveFuncIDs[dwX]);
                    }
#endif
                    // It's ok to read silence before the synth gets going
                    if ((FAILED(hr) &&
                          hr != DMUS_E_SYNTHINACTIVE &&
                          hr != DMUS_E_SYNTHNOTCONFIGURED) || BytesToRead == 0)
                    {
                        m_pDSSources[i].m_bStreamEnd = TRUE; // end of buffer reached
                    }

                    hr = S_OK;
                }
                if (dwBussEndBytes)
                {
                    llStartPosition += dwBussStartBytes;
                    BytesToRead      = dwBussEndBytes;

                    if (BusIndex != DSSINK_NULLBUSID)
                    {
#ifdef DEBUG_SINK
                        wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "Remap:");
#endif
                        hr = pSource->Read((void**)&m_ppvEnd[BusIndex], &m_pdwBusIDs[BusIndex], &m_pdwFuncIDs[BusIndex], &m_plPitchBends[BusIndex], BusCount, &BytesToRead);
                    }
                    else
                    {
                        pSource->Seek(llStartPosition);
                        hr = pSource->Read((void**)m_ppvEnd, m_pdwActiveBusIDs, m_pdwActiveFuncIDs, m_plPitchBends, CurrentBusIndex, &BytesToRead);
#ifdef DEBUG_SINK
                        wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "End:");
                        for (DWORD dwX=0; dwX < CurrentBusIndex; dwX++)
                            wsprintfA(m_szDbgDump + strlen(m_szDbgDump), "(%ld:%ld,%ld),", dwX, m_pdwActiveBusIDs[dwX], m_pdwActiveFuncIDs[dwX]);
#endif
                    }
                    if ((FAILED(hr) &&
                          hr != DMUS_E_SYNTHINACTIVE &&
                          hr != DMUS_E_SYNTHNOTCONFIGURED) || BytesToRead == 0)
                    {
                        m_pDSSources[i].m_bStreamEnd = TRUE; // end of buffer reached
                        hr = DS_OK;
                    }
                }
            }
        }

        #ifdef DEBUG_SINK
        if (!m_dwPrintNow--)
        {
            OutputDebugStringA(m_szDbgDump);
            OutputDebugStringA("\n");
            m_dwPrintNow = 100;  // Print info every X times we go through this code
        }
        #endif

        //
        // Unlock all the buffer pointers
        //
        for (i = 0; i < m_dwDSSBufCount; i++)
        {
            if (!m_ppDSSBuffers[i].m_bPlaying)
            {
                continue;
            }

            dwChannels = m_ppDSSBuffers[i].m_dwBusCount;
            dwStart = m_ppDSSBuffers[i].dwStart;
            dwEnd = m_ppDSSBuffers[i].dwEnd;
            //
            // Interleave mono bus back into a 2 channel dsound buffer
            //
            if (m_ppDSSBuffers[i].m_bUsingLocalMemory)
            {
                DWORD  dwStartChannelBytes = dwStart/dwChannels;
                DWORD  dwBussStartIndex   = 0;
                DWORD  dwBussEndIndex     = 0;
                DWORD  dwBussSamples  = 0;

                if (dwStartChannelBytes > dwBussStartBytes)
                {
                    dwBussSamples = dwBussStartBytes/sizeof(WORD);   //Byte to samples, busses are always mono
                }
                else
                {
                    dwBussSamples = dwStartChannelBytes/sizeof(WORD);//Byte to samples
                }

                if (dwChannels == 2)
                {
                    short *pStartBuffer = (short *) m_ppDSSBuffers[i].m_pvDSBufStart;
                    short *pEndBuffer = (short *) m_ppDSSBuffers[i].m_pvDSBufEnd;
                    if (m_ppDSSBuffers[i].m_pdwFuncIds[0] == DSSINK_NULLBUSID)
                    {
                        // This should never happen, but just testing...
                        DPF(DPFLVL_INFO, "Mixin buffer receiving input from the synth!");
                        // FIXME: this happens constantly.  is it ok?
                    }
                    // Is the second bus empty? If so, we copy just from the first bus.
                    else if (m_ppDSSBuffers[i].m_pdwFuncIds[1] == DSSINK_NULLBUSID)
                    {
                        short *pBusStart = (short *) m_ppDSSBuffers[i].m_pvBussStart[0];
                        short *pBusEnd = (short *) m_ppDSSBuffers[i].m_pvBussEnd[0];
                        for (; dwBussStartIndex < dwBussSamples; dwBussStartIndex++)
                        {
                            *pStartBuffer++ = pBusStart[dwBussStartIndex];
                            *pStartBuffer++ = pBusStart[dwBussStartIndex];
                        }

                        // The start buffer is not full, consume some of the end buffer
                        if (dwStartChannelBytes > dwBussStartBytes)
                        {
                            dwBussSamples = (dwStartChannelBytes-dwBussStartBytes)/sizeof(WORD);

                            for (; dwBussEndIndex < dwBussSamples; dwBussEndIndex++)
                            {
                                *pStartBuffer++ = pBusEnd[dwBussEndIndex];
                                *pStartBuffer++ = pBusEnd[dwBussEndIndex];
                            }
                        }

                        // Consume what remains of the local mem start buffer and put it in the end buffer
                        dwBussSamples = dwBussStartBytes/sizeof(WORD);

                        for (; dwBussStartIndex < dwBussSamples; dwBussStartIndex++)
                        {
                            *pEndBuffer++ = pBusStart[dwBussStartIndex];
                            *pEndBuffer++ = pBusStart[dwBussStartIndex];
                        }

                        // Consume what remains of the local mem end buffer and put it in the end buffer
                        dwBussSamples = dwBussEndBytes/sizeof(WORD);
                        for (; dwBussEndIndex < dwBussSamples; dwBussEndIndex++)
                        {
                            *pEndBuffer++ = pBusEnd[dwBussEndIndex];
                            *pEndBuffer++ = pBusEnd[dwBussEndIndex];
                        }
                    }
                    else
                    {
                        short *pBusStart0 = (short *) m_ppDSSBuffers[i].m_pvBussStart[0];
                        short *pBusEnd0 = (short *) m_ppDSSBuffers[i].m_pvBussEnd[0];
                        short *pBusStart1 = (short *) m_ppDSSBuffers[i].m_pvBussStart[1];
                        short *pBusEnd1 = (short *) m_ppDSSBuffers[i].m_pvBussEnd[1];
                        for (; dwBussStartIndex < dwBussSamples; dwBussStartIndex++)
                        {
                            *pStartBuffer++ = pBusStart0[dwBussStartIndex];
                            *pStartBuffer++ = pBusStart1[dwBussStartIndex];
                        }

                        // The start buffer is not full, consume some of the end buffer
                        if (dwStartChannelBytes > dwBussStartBytes)
                        {
                            dwBussSamples = (dwStartChannelBytes-dwBussStartBytes)/sizeof(WORD);

                            for (; dwBussEndIndex < dwBussSamples; dwBussEndIndex++)
                            {
                                *pStartBuffer++ = pBusEnd0[dwBussEndIndex];
                                *pStartBuffer++ = pBusEnd1[dwBussEndIndex];
                            }
                        }

                        // Consume what remains of the local mem start buffer and put it in the end buffer
                        dwBussSamples = dwBussStartBytes/sizeof(WORD);

                        for (; dwBussStartIndex < dwBussSamples; dwBussStartIndex++)
                        {
                            *pEndBuffer++ = pBusStart0[dwBussStartIndex];
                            *pEndBuffer++ = pBusStart1[dwBussStartIndex];
                        }

                        // Consume what remains of the local mem end buffer and put it in the end buffer
                        dwBussSamples = dwBussEndBytes/sizeof(WORD);
                        for (; dwBussEndIndex < dwBussSamples; dwBussEndIndex++)
                        {
                            *pEndBuffer++ = pBusEnd0[dwBussEndIndex];
                            *pEndBuffer++ = pBusEnd1[dwBussEndIndex];
                        }
                    }
                }
                else if (dwChannels == 1)
                {
                    short *pStartBuffer = (short *) m_ppDSSBuffers[i].m_pvDSBufStart;
                    short *pEndBuffer = (short *) m_ppDSSBuffers[i].m_pvDSBufEnd;
                    if (m_ppDSSBuffers[i].m_pdwFuncIds[0] == DSSINK_NULLBUSID)
                    {
                        // This should never happen, but just testing...
                        DPF(DPFLVL_ERROR, "Mixin buffer receiving input from the synth!");
                    }
                    short *pBusStart = (short *) m_ppDSSBuffers[i].m_pvBussStart[0];
                    short *pBusEnd = (short *) m_ppDSSBuffers[i].m_pvBussEnd[0];
                    for (; dwBussStartIndex < dwBussSamples; dwBussStartIndex++)
                    {
                        *pStartBuffer++ = pBusStart[dwBussStartIndex];
                    }

                    // The start buffer is not full, consume some of the end buffer
                    if (dwStartChannelBytes > dwBussStartBytes)
                    {
                        dwBussSamples = (dwStartChannelBytes-dwBussStartBytes)/sizeof(WORD);

                        for (; dwBussEndIndex < dwBussSamples; dwBussEndIndex++)
                        {
                            *pStartBuffer++ = pBusEnd[dwBussEndIndex];
                        }
                    }

                    // Consume what remains of the local mem start buffer and put it in the end buffer
                    dwBussSamples = dwBussStartBytes/sizeof(WORD);

                    for (; dwBussStartIndex < dwBussSamples; dwBussStartIndex++)
                    {
                        *pEndBuffer++ = pBusStart[dwBussStartIndex];
                    }

                    // Consume what remains of the local mem end buffer and put it in the end buffer
                    dwBussSamples = dwBussEndBytes/sizeof(WORD);
                    for (; dwBussEndIndex < dwBussSamples; dwBussEndIndex++)
                    {
                        *pEndBuffer++ = pBusEnd[dwBussEndIndex];
                    }
                }
                else
                {
                    DPF(DPFLVL_ERROR, "DSSink does not handle %ld channels per buffer", dwChannels);
                }
            }

            m_ppDSSBuffers[i].m_pDSBuffer->DirectUnlock(m_ppDSSBuffers[i].m_pvDSBufStart, dwStart,
                                                        m_ppDSSBuffers[i].m_pvDSBufEnd, dwEnd);
        }
    }

    //
    // Set the amount written return values
    //
    *pdwBytesRendered = dwMasterStart + dwMasterEnd;

    return hr;
}


#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::RenderSilence"

HRESULT CDirectSoundSink::RenderSilence(DWORD dwLastWrite, DWORD dwBytesToFill)
{
    HRESULT hr = DS_OK;

    CDirectSoundSecondaryBuffer* m_pDSBuffer;
    DWORD dwChannels;
    LPVOID pStart, pEnd;
    DWORD dwStart, dwEnd;

    for (DWORD i = 0; i < m_dwDSSBufCount && SUCCEEDED(hr); i++)
    {
        if (m_ppDSSBuffers[i].m_pDSBuffer == NULL)
            continue;

        m_pDSBuffer = m_ppDSSBuffers[i].m_pDSBuffer;
        dwChannels  = m_ppDSSBuffers[i].m_dwBusCount;

        hr = m_pDSBuffer->DirectLock(dwChannels * dwLastWrite   / m_dwMasterBuffChannels,
                                     dwChannels * dwBytesToFill / m_dwMasterBuffChannels,
                                     &pStart, &dwStart, &pEnd, &dwEnd);

        if (SUCCEEDED(hr))
        {
            if (dwStart)
                ZeroMemory(pStart, dwStart);
            if (dwEnd)
                ZeroMemory(pEnd, dwEnd);

            m_pDSBuffer->DirectUnlock(pStart, dwStart, pEnd, dwEnd);
        }
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::SyncSink"

HRESULT CDirectSoundSink::SyncSink(LPDWORD pdwPlayCursor, LPDWORD pdwWriteCursor, LPDWORD pdwCursorDelta)
{
    HRESULT hr = S_FALSE;

    if (!m_ppDSSBuffers || m_ppDSSBuffers[0].m_pDSBuffer == NULL)
    {
        //
        // remove all sources
        //
        for (DWORD i = 0; i < m_dwDSSources; i++)
        {
            if (m_pDSSources[i].m_bStreamEnd == TRUE)
            {
                RemoveSource(m_pDSSources[i].m_pDSSource);
            }
        }

        //
        // If there are no buffers, keep the master clock working anyway
        // even if there are no buffers, this will keep things clean
        // during audiopath changes that pull the whole path.
        //
        REFERENCE_TIME rtMaster;
        LONGLONG llMasterSampleTime;
        LONGLONG llMasterBytes;

        m_pIMasterClock->GetTime(&rtMaster);
        RefToSampleTime(rtMaster, &llMasterSampleTime);
        llMasterBytes = SampleToByte(llMasterSampleTime);

        DWORD dwDelta = (DWORD)(llMasterBytes - m_llAbsPlay);
        m_llAbsPlay   += dwDelta;
        m_llAbsWrite  += dwDelta;
        m_dwLastPlay  += dwDelta;
        m_dwLastWrite += dwDelta;
        m_dwLastCursorDelta = dwDelta;

        m_SampleClock.SyncToMaster(ByteToSample(m_llAbsPlay), m_pIMasterClock, TRUE);

        if (pdwPlayCursor)
            *pdwPlayCursor = 0;

        if (pdwWriteCursor)
            *pdwWriteCursor = 0;

        if (pdwCursorDelta)
            *pdwCursorDelta = 0;

        hr = S_FALSE;  // Not playing anything to take a position on.
    }
    else
    {
        if (m_ppDSSBuffers[0].m_pDSBuffer)
        {
//>>>> to be removed
/*            if (m_dwLatencyCount < 100)
            {
                DWORD dwMasterCursor = 0;
                DWORD dwLatency     = 0;

                hr = m_ppDSSBuffers[0].m_pDSBuffer->GetCursorPosition(&dwMasterCursor, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = m_ppDSSBuffers[0].m_pDSBuffer->GetCursorPosition(&dwLatency, NULL);
                    if (SUCCEEDED(hr))
                    {
                        if (dwMasterCursor <= dwLatency)
                            dwLatency = dwLatency - dwMasterCursor;
                        else
                            dwLatency = (dwLatency + m_dwMasterBuffSize) - dwMasterCursor;

                        if (dwLatency < 100)
                        {
                            m_dwLatencyTotal += dwLatency;
                            m_dwLatencyCount++;
                            m_dwLatencyAverage = m_dwLatencyTotal / m_dwLatencyCount;
                            DPF(0, "MasterCursor[%d] Latency[%d] AvgLatency[%d]", dwMasterCursor, dwLatency, m_dwLatencyAverage);
                        }
                    }
                }
            }*/
//>>>> end to be removed

            //
            // Attempt to synchronize play buffers
            //
            hr = S_FALSE;
            for (DWORD i = 1; i < m_dwDSSBufCount; i++)
            {
                DWORD dwPlayCursor   = 0;
                DWORD dwMasterCursor = 0;
                DWORD dwOffset;

                if (m_ppDSSBuffers[i].m_bPlaying == FALSE && m_ppDSSBuffers[i].m_bActive == TRUE)
                {
                    hr = m_ppDSSBuffers[0].m_pDSBuffer->GetInternalCursors(&dwMasterCursor, NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_ppDSSBuffers[i].m_pDSBuffer->GetInternalCursors(&dwPlayCursor, NULL);
                        if (SUCCEEDED(hr))
                        {
                            // Adjust master cursor to current buffer cursor
                            dwMasterCursor = (dwMasterCursor*m_ppDSSBuffers[i].m_dwBusCount)/m_dwMasterBuffChannels;

                            if (dwPlayCursor >= dwMasterCursor)
                            {
                                dwOffset = dwPlayCursor - dwMasterCursor;
                            }
                            else
                            {
                                dwOffset = (dwPlayCursor + (m_dwBusSize*m_ppDSSBuffers[i].m_dwBusCount)) - dwMasterCursor;
                            }
                            if (dwOffset <= m_dwLatencyAverage)
                            {
                                dwOffset = 0;
                            }
                            dwOffset = (dwOffset >> m_ppDSSBuffers[i].m_dwBusCount) << m_ppDSSBuffers[i].m_dwBusCount;

                            m_ppDSSBuffers[i].m_dwWriteOffset = dwOffset; // FIXME make sure we go through this code for the master buffer (write offset should be 0)
                            m_ppDSSBuffers[i].m_bPlaying = TRUE;
#ifdef DEBUG_SINK
                            DPF(DPFLVL_INFO, "Turned on buffer %ld at %p", i, m_ppDSSBuffers[i]);
                            m_dwPrintNow = 0;
#endif
                            DPF(DPFLVL_MOREINFO, "MasterCursor[%d] PlayCursor-AvgLatency[%d] Offset[%d] WriteOffset[%d] AvgLatency[%d]",
                                dwMasterCursor, dwPlayCursor-m_dwLatencyAverage, dwOffset, m_ppDSSBuffers[i].m_dwWriteOffset, m_dwLatencyAverage);
                        }
                    }
                }
            }

            DWORD dwPlayCursor;         // Play position in the master buffer
            DWORD dwWriteCursor;        // Write position in the master buffer
            DWORD dwCursorDelta = 0;    // How far apart are the cursors

            hr =  m_ppDSSBuffers[0].m_pDSBuffer->GetInternalCursors(&dwPlayCursor, &dwWriteCursor);
            if (SUCCEEDED(hr))
            {
                if (dwWriteCursor >= dwPlayCursor)
                {
                    // write cursor is normally ahead on the play cursor
                    dwCursorDelta = dwWriteCursor - dwPlayCursor;
                }
                else
                {
                    // write cursor is at the begining of the buffer behind the play cursor
                    dwCursorDelta = (dwWriteCursor + m_dwMasterBuffSize) - dwPlayCursor;
                }

                // Logic Note: The actual play-to-write distance reported from the device
                // is not necessarily the one that is used; in the event that the distance
                // is shrinking off a maximum peak, the following code will decrease the
                // write cursor by a 1/100th the distance on each subsequent execution of
                // this loop. This brings up the issue that the calling thread must execute
                // this code on a very consistent interval.

                if (dwCursorDelta > m_dwLastCursorDelta)
                {
                    if (dwCursorDelta >= (m_dwMasterBuffSize >> 1))
                    {
                        // If the delta is greater than half the buffer, this is probably
                        // an error. Discard and come back later.
                        DPF(DPFLVL_WARNING, "Play to Write cursor delta value %lu rejected", dwCursorDelta);
                        return S_FALSE;
                    }
                    // use the maximimum reported delta, and save the peak value
                    m_dwLastCursorDelta = dwCursorDelta;
                }
                else
                {
                    // Decrease the distance by a hundredth of itself,
                    // creating a damping effect.
                    m_dwLastCursorDelta -= ((m_dwLastCursorDelta - dwCursorDelta) / 100);
                    m_dwLastCursorDelta = SampleAlign(m_dwLastCursorDelta);
                    dwCursorDelta = m_dwLastCursorDelta;
                }

                // Adjust the actual reported write cursor position.
                *pdwWriteCursor = (dwPlayCursor + dwCursorDelta) % m_dwMasterBuffSize;
                *pdwPlayCursor      = dwPlayCursor;
                *pdwCursorDelta     = dwCursorDelta;
            }
        }

        //
        // The only calls here that modify hr are GetPosition calls; if they fail
        // they may be stalled in some init function.  Return S_FALSE so the thread
        // calls again, but doesn't render.
        //
        if (hr != DS_OK)
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::ProcessSink"

HRESULT CDirectSoundSink::ProcessSink()
{
    DWORD dwPlayCursor, dwWriteCursor, dwCursorDelta;

    if (m_pIMasterClock == NULL)  // Happens on closedown sometimes
    {
        DPF(DPFLVL_WARNING, "NULL m_pIMasterClock - FIXME?");
        return DS_OK;
    }

    // First save our current notion of the latency clock for use during this
    // processing pass by any effect chains attached to this sink's buffers:
    m_rtSavedTime = 0;
    m_LatencyClock.GetTime(&m_rtSavedTime);

    HRESULT hr = SyncSink(&dwPlayCursor, &dwWriteCursor, &dwCursorDelta);

    if (hr != DS_OK)
    {
        DPF(DPFLVL_INFO, "SyncSink() returned %s", HRESULTtoSTRING(hr));
    }
    else // ...do everything else
    {
        REFERENCE_TIME rtMaster;
        LONGLONG llMasterSampleTime;
        LONGLONG llMasterBytes;
        LONGLONG llMasterAhead;     // How far master clock is ahead of last known play time
        LONGLONG llAbsWriteFrom;
        LONGLONG llAbsWriteTo;
        DWORD dwBytesToFill;
        DWORD dwBytesRendered;
        STIME stStartTime;
        DWORD dwPlayed;             // How much was played between execution of this code

        DWORD dwMaxDelta = m_dwMasterBuffSize / 2;  // Max play to write distance allowed

        //
        // Buffer starting off
        //
        if (m_llAbsWrite == 0)
        {
            // we just started
            m_llAbsWrite  = dwCursorDelta;
            m_llAbsPlay   = 0;
            m_dwLastWrite = dwWriteCursor;
            m_dwLastPlay  = dwPlayCursor;

            m_SampleClock.Start(m_pIMasterClock, m_wfx.nSamplesPerSec, 0);
        }

        //
        // Check to see if the master clock is ahead of the master buffer
        //
        m_pIMasterClock->GetTime(&rtMaster);
        RefToSampleTime(rtMaster, &llMasterSampleTime);
        llMasterBytes = SampleToByte(llMasterSampleTime);
        llMasterAhead = (llMasterBytes > m_llAbsPlay) ? llMasterBytes - m_llAbsPlay : 0;

        //
        // check for half-buffer underruns,
        // so backward-moving play cursors can be detected
        // >>>>>>>>>> document more backward moving cursors are the primary function of this code
        if (llMasterAhead > dwMaxDelta)
        {
            // Make this DPFLVL_WARNING level again when 33786 is fixed
            DPF(DPFLVL_INFO, "Buffer underrun by %lu", (long) llMasterAhead - dwMaxDelta);

            m_llAbsPlay   = llMasterBytes;
            m_llAbsWrite  = llAbsWriteFrom = m_llAbsPlay + dwCursorDelta;
            m_dwLastWrite = dwWriteCursor;
        }
        else
        {
            //
            // Track and cache the play cursor positions
            //
            // dwPlayCursor = current play cursor position
            // m_dwLastPlay = the last play cursor position
            // m_llAbsPlay  = the accumulated play cursor position
            // dwMaxDelta   = half the buffer size
            //
            if (dwPlayCursor >= m_dwLastPlay)
                dwPlayed = dwPlayCursor - m_dwLastPlay;
            else
                dwPlayed = (dwPlayCursor + m_dwMasterBuffSize) - m_dwLastPlay;

            if (dwPlayed > dwMaxDelta)
            {
                DPF(DPFLVL_INFO, "Play Cursor %lu looks invalid, rejecting it", dwPlayed);
                return DS_OK;
            }

            m_llAbsPlay += dwPlayed; // Accumulate the absolute play position

            //
            //  Track and cache the write cursor position
            //
            // dwWriteCursor  = the current write cursor position
            // dwCursorDelta  = the distance between the current cursor position
            // m_llAbsPlay    = the accumulated play cursor position
            // m_llAbsWrite   =
            // llAbsWriteFrom =
            //
            llAbsWriteFrom = m_llAbsPlay + dwCursorDelta;

            if (llAbsWriteFrom > m_llAbsWrite) // how far ahead of the write head are we?
            {
                // We are behind-- let's catch up
                DWORD dwWriteMissed;

                dwWriteMissed = DWORD(llAbsWriteFrom - m_llAbsWrite);
                m_dwLastWrite = dwWriteCursor;
                m_llAbsWrite += dwWriteMissed;

                // This should be DPFLVL_WARNING - but it happens too often.
                DPF(DPFLVL_INFO, "Write underrun: missed %lu bytes (latency=%lu)", dwWriteMissed, m_dwLatency);
            }
        }

        m_dwLastPlay = dwPlayCursor;  // Save the last play cursor

        // Now, sync the audio to the master clock.
        // If we are in the first two seconds, just let the sample clock sync to the master clock.
        // This allows it to overcome jitter and get a tight starting position.
        // Then, after that first two seconds, switch to letting the sample
        // clock drive the master clock.
        // Also, if there is no way of adjusting the master clock (no m_pDSSSinkSync),
        // then always adjust the sample clock instead.
        BOOL fLockToMaster = (!m_pDSSSinkSync) || (m_llAbsPlay < m_dwMasterBuffSize * 2);
        m_SampleClock.SyncToMaster(ByteToSample(m_llAbsPlay),m_pIMasterClock,fLockToMaster);
        // Then, take the same offset that was generated by the sync code
        // and use it to adjust the timing of the master clock.
        if (!fLockToMaster)
        {
            // First, get the new offset that was generated by SyncToMaster.
            REFERENCE_TIME rtOffset;
            m_SampleClock.GetClockOffset(&rtOffset);
            m_pDSSSinkSync->SetClockOffset(-rtOffset);
        }

        //
        // The m_dwWriteTo value is set to zero when either
        //  1) the sink is initialized
        //  2) the Latency property has been changed.
        //  3) the master buffer has been changed
        //
        if (m_dwWriteTo == 0)
        {
            m_dwWriteTo = SampleAlign((500 + (m_dwMasterBuffSize * m_dwLatency)) / 1000);
        }

        // how much to write?
        llAbsWriteTo = llAbsWriteFrom + m_dwWriteTo;
        if (llAbsWriteTo > m_llAbsWrite)
        {
            dwBytesToFill = DWORD(llAbsWriteTo - m_llAbsWrite);
        }
        else
        {
            dwBytesToFill = 0;
        }

//>>>>>>>>> check for small overlaps and ignore them

        if (dwBytesToFill)
        {
            stStartTime = ByteToSample(m_llAbsWrite);   // >>>>>>>> COMMENT

            hr = Render(stStartTime, m_dwLastWrite, dwBytesToFill, &dwBytesRendered);
            if (SUCCEEDED(hr))
            {
                m_dwLastWrite  = (m_dwLastWrite + dwBytesRendered) % m_dwMasterBuffSize;  // Set the how much we have written cursor
                m_llAbsWrite  += dwBytesRendered;  // Accumulate that actual number of bytes written
            }
            else
            {
                DPF(DPFLVL_WARNING, "Failed to render DS buffer (%s)", HRESULTtoSTRING(hr));
            }

//>>>>>>>>>> look closely into this render silence code
#if DEAD_CODE
            // write silence into unplayed buffer
            if (m_dwLastWrite >= dwPlayCursor)
                dwBytesToFill = m_dwMasterBuffSize - m_dwLastWrite + dwPlayCursor;
            else
                dwBytesToFill = dwPlayCursor - m_dwLastWrite;

            hr = RenderSilence(m_dwLastWrite, dwBytesToFill);
            if (FAILED(hr))
            {
                DPF(DPFLVL_WARNING, "Failed to render DS buffer (%s)", HRESULTtoSTRING(hr));
            }
#endif
        }
        else
        {
            DPF(DPFLVL_MOREINFO, "Skipped Render() call because dwBytesToFill was 0");
        }

        //
        // Remove any sources reporting end of stream
        // do it after the mix, so if it does take a
        // bit of time
        // at least the data is already in the buffer.
        //
        for (DWORD i = 0; i < m_dwDSSources; i++)
        {
            if (m_pDSSources[i].m_bStreamEnd == TRUE)
            {
                RemoveSource(m_pDSSources[i].m_pDSSource);
            }
        }
    }

    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::SetBufferState"

HRESULT CDirectSoundSink::SetBufferState(CDirectSoundBuffer *pCDirectSoundBuffer, DWORD dwNewState, DWORD dwOldState)
{
    HRESULT hr = DSERR_INVALIDPARAM;
    DPF_ENTER();

    for (DWORD i = 0; i < m_dwDSSBufCount; i++)
    {
        if (pCDirectSoundBuffer == m_ppDSSBuffers[i].m_pDSBuffer)
        {
            // Stopping buffer
            if (!(~VAD_BUFFERSTATE_STARTED & dwNewState) && (VAD_BUFFERSTATE_STARTED & dwOldState))
            {
#ifdef DEBUG_SINK
                DPF(DPFLVL_INFO, "Deactivating buffer %ld", i);
                m_dwPrintNow = 0;
#endif
                m_ppDSSBuffers[i].m_bActive  = FALSE;
                m_ppDSSBuffers[i].m_bPlaying = FALSE;

//>>>>>>>>>>>>>> make sure if we are stopping the master we jump to the next available master.
            }
            else if ((VAD_BUFFERSTATE_STARTED & dwNewState) && !(~VAD_BUFFERSTATE_STARTED & dwOldState))
            {
#ifdef DEBUG_SINK
                DPF(DPFLVL_INFO, "Activating buffer %ld", i);
                m_dwPrintNow = 0;
#endif
                m_ppDSSBuffers[i].m_bActive  = TRUE;    // Activate the buffer
                m_ppDSSBuffers[i].m_bPlaying = FALSE;   // The render thread will turn this on once it has a cursor offset

                // Hey this is the master buffer, kick it off imediately
                if (i == 0)
                {
                    m_ppDSSBuffers[i].m_bActive  = TRUE;    // Activate the buffer
                    m_ppDSSBuffers[i].m_bPlaying = TRUE;    // The render thread will turn this on once it has a cursor offset
                    m_ppDSSBuffers[i].m_dwWriteOffset = 0;
                }
            }

            hr = DS_OK;
            break;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::HandleLatency"

HRESULT CDirectSoundSink::HandleLatency(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)
{
    if (*pcbBuffer != sizeof(DWORD))
        return DSERR_INVALIDPARAM;

    if (fSet)
    {
        m_dwLatency = BETWEEN(*(DWORD*)pbBuffer, SINK_MIN_LATENCY, SINK_MAX_LATENCY);
        m_dwWriteTo = 0;  // Flag that latency has changed for reset down in render thread
    }
    else
        *(DWORD*)pbBuffer = m_dwLatency;

    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CDirectSoundSink::HandlePeriod"

HRESULT CDirectSoundSink::HandlePeriod(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)
{
    if (*pcbBuffer != sizeof(DWORD))
        return DSERR_INVALIDPARAM;

    if (fSet)
        m_pStreamingThread->SetWakePeriod(BETWEEN(*(DWORD*)pbBuffer, STREAMING_MIN_PERIOD, STREAMING_MAX_PERIOD));
    else
        *(DWORD*)pbBuffer = m_pStreamingThread->GetWakePeriod();

    return DS_OK;
}


/***************************************************************************
 *
 * CImpSinkKsControl methods
 *
 ***************************************************************************/


#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::CImpSinkKsControl"

CImpSinkKsControl::CImpSinkKsControl(CUnknown *pUnknown, CDirectSoundSink* pObject) : CImpUnknown(pUnknown, pObject)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CImpSinkKsControl);

    m_pDSSink = (CDirectSoundSink*)pUnknown;

    // This can't be static to avoid problems with the linker since
    // the data segment is shared.

    m_aProperty[0].pguidPropertySet = &GUID_DMUS_PROP_WriteLatency;
    m_aProperty[0].ulId = 0;
    m_aProperty[0].ulSupported = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
    m_aProperty[0].ulFlags = SINKPROP_F_FNHANDLER;
    m_aProperty[0].pPropertyData = NULL;
    m_aProperty[0].cbPropertyData = 0;
    m_aProperty[0].pfnHandler = HandleLatency;

    m_aProperty[1].pguidPropertySet = &GUID_DMUS_PROP_WritePeriod;
    m_aProperty[1].ulId = 0;
    m_aProperty[1].ulSupported = KSPROPERTY_SUPPORT_GET | KSPROPERTY_SUPPORT_SET;
    m_aProperty[1].ulFlags = SINKPROP_F_FNHANDLER;
    m_aProperty[1].pPropertyData = NULL;
    m_aProperty[1].cbPropertyData = 0;
    m_aProperty[1].pfnHandler = HandlePeriod;

    m_nProperty = 2;

    DPF_LEAVE_VOID();
}

#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::HandleLatency"

HRESULT CImpSinkKsControl::HandleLatency(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)
{
    DPF_ENTER();

    HRESULT hr = m_pDSSink->HandleLatency(ulId, fSet, pbBuffer, pcbBuffer);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::HandlePeriod"

HRESULT CImpSinkKsControl::HandlePeriod(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer)
{
    DPF_ENTER();

    HRESULT hr = m_pDSSink->HandlePeriod(ulId, fSet, pbBuffer, pcbBuffer);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

// CImpSinkKsControl::FindPropertyItem
//
// Given a GUID and an item ID, find the associated property item in the synth's
// table of SYNPROPERTYs.
//
// Returns a pointer to the entry or NULL if the item was not found.

#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::FindPropertyItem"

SINKPROPERTY *CImpSinkKsControl::FindPropertyItem(REFGUID rguid, ULONG ulId)
{
    DPF_ENTER();

    SINKPROPERTY *pPropertyItem = &m_aProperty[0];
    SINKPROPERTY *pEndOfItems = pPropertyItem + m_nProperty;

    for (; pPropertyItem != pEndOfItems; pPropertyItem++)
    {
        if (*pPropertyItem->pguidPropertySet == rguid &&
             pPropertyItem->ulId == ulId)
        {
            DPF_LEAVE(pPropertyItem);
            return pPropertyItem;
        }
    }

    DPF_LEAVE(NULL);
    return NULL;
}

#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::KsProperty"

STDMETHODIMP CImpSinkKsControl::KsProperty(PKSPROPERTY pPropertyIn, ULONG ulPropertyLength,
                                           LPVOID pvPropertyData, ULONG ulDataLength, PULONG pulBytesReturned)
{
    DWORD dwFlags;
    SINKPROPERTY *pProperty;
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (!IS_VALID_WRITE_PTR(pPropertyIn, ulPropertyLength))
    {
        DPF(DPFLVL_ERROR, "Invalid property pointer");
        hr = DSERR_INVALIDPARAM;
    }
    else if (pvPropertyData && !IS_VALID_WRITE_PTR(pvPropertyData, ulDataLength))
    {
        DPF(DPFLVL_ERROR, "Invalid property data");
        hr = DSERR_INVALIDPARAM;
    }
    else if (!IS_VALID_TYPED_WRITE_PTR(pulBytesReturned))
    {
        DPF(DPFLVL_ERROR, "Invalid pulBytesReturned");
        hr = DSERR_INVALIDPARAM;
    }
    else
    {
        dwFlags = pPropertyIn->Flags & (KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_BASICSUPPORT);
        pProperty = FindPropertyItem(pPropertyIn->Set, pPropertyIn->Id);
        if (pProperty == NULL)
            hr = DMUS_E_UNKNOWN_PROPERTY;
        else if (pvPropertyData == NULL)
            hr = DSERR_INVALIDPARAM;
    }

    if (SUCCEEDED(hr))
        switch (dwFlags)
        {
            case KSPROPERTY_TYPE_GET:
                if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_GET))
                {
                    hr = DMUS_E_GET_UNSUPPORTED;
                    break;
                }
                if (pProperty->ulFlags & SINKPROP_F_FNHANDLER)
                {
                    *pulBytesReturned = ulDataLength;
                    SINKPROPHANDLER pfn = pProperty->pfnHandler;
                    hr = (this->*pfn)(pPropertyIn->Id, FALSE, pvPropertyData, pulBytesReturned);
                    break;
                }
                if (ulDataLength > pProperty->cbPropertyData)
                    ulDataLength = pProperty->cbPropertyData;

                CopyMemory(pvPropertyData, pProperty->pPropertyData, ulDataLength);
                *pulBytesReturned = ulDataLength;
                break;

            case KSPROPERTY_TYPE_SET:
                if (!(pProperty->ulSupported & KSPROPERTY_SUPPORT_SET))
                {
                    hr = DMUS_E_SET_UNSUPPORTED;
                }
                else if (pProperty->ulFlags & SINKPROP_F_FNHANDLER)
                {
                    SINKPROPHANDLER pfn = pProperty->pfnHandler;
                    hr = (this->*pfn)(pPropertyIn->Id, TRUE, pvPropertyData, &ulDataLength);
                }
                else
                {
                    if (ulDataLength > pProperty->cbPropertyData)
                        ulDataLength = pProperty->cbPropertyData;
                    CopyMemory(pProperty->pPropertyData, pvPropertyData, ulDataLength);
                }
                break;

            case KSPROPERTY_TYPE_BASICSUPPORT:
                if (ulDataLength < sizeof(DWORD) || pvPropertyData == NULL)
                {
                    hr = DSERR_INVALIDPARAM;
                }
                else
                {
                    *(LPDWORD)pvPropertyData = pProperty->ulSupported;
                    *pulBytesReturned = sizeof(DWORD);
                }
                break;

            default:
                DPF(DPFLVL_WARNING, "KSProperty failed; flags must contain one of KSPROPERTY_TYPE_SET, "
                                    "KSPROPERTY_TYPE_GET, or KSPROPERTY_TYPE_BASICSUPPORT");
                hr = DSERR_INVALIDPARAM;
        }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::KsMethod"

STDMETHODIMP CImpSinkKsControl::KsMethod(
    PKSMETHOD pMethod, ULONG ulMethodLength,
    LPVOID pvMethodData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    DPF_ENTER();
    DPF_LEAVE(DMUS_E_UNKNOWN_PROPERTY);
    return DMUS_E_UNKNOWN_PROPERTY;
}

#undef DPF_FNAME
#define DPF_FNAME "CImpSinkKsControl::KsEvent"

STDMETHODIMP CImpSinkKsControl::KsEvent(
    PKSEVENT pEvent, ULONG ulEventLength,
    LPVOID pvEventData, ULONG ulDataLength,
    PULONG pulBytesReturned)
{
    DPF_ENTER();
    DPF_LEAVE(DMUS_E_UNKNOWN_PROPERTY);
    return DMUS_E_UNKNOWN_PROPERTY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsvalid.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsvalid.h
 *  Content:    DirectSound parameter validation.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/20/97     dereks  Created
 *
 ***************************************************************************/

#ifndef __DSVALID_H__
#define __DSVALID_H__

// Validation macros
#define IsValidHandleValue(h)           ((h) && ((h) != INVALID_HANDLE_VALUE))

#if defined(DEBUG) || defined(RDEBUG)

#define IS_VALID_READ_PTR(a, b)         !IsBadReadPtr(a, b)
#define IS_VALID_WRITE_PTR(a, b)        !IsBadWritePtr(a, b)
#define IS_VALID_TYPED_READ_PTR(a)      IS_VALID_READ_PTR((a), sizeof *(a))
#define IS_VALID_TYPED_WRITE_PTR(a)     IS_VALID_WRITE_PTR((a), sizeof *(a))
#define IS_VALID_CODE_PTR(a)            !IsBadCodePtr((FARPROC)(a))
#define IS_VALID_HWND(a)                IsWindow(a)
#define IS_VALID_HANDLE(a)              IsValidHandle(a)
#define IS_VALID_READ_WAVEFORMATEX(a)   IsValidWfxPtr(a)

#ifdef __cplusplus

template <class type> BOOL IS_VALID_INTERFACE(type *pthis, DWORD sig)
{
    if(!IS_VALID_TYPED_WRITE_PTR(pthis))
    {
        DPF(DPFLVL_ERROR, "Can't write to interface pointer");
        return FALSE;
    }

    if(sig != (DWORD)pthis->m_signature)
    {
        DPF(DPFLVL_ERROR, "Interface signature mismatch.  %c%c%c%c != %c%c%c%c", (BYTE)(pthis->m_signature), (BYTE)(pthis->m_signature >> 8), (BYTE)(pthis->m_signature >> 16), (BYTE)(pthis->m_signature >> 24), (BYTE)(sig), (BYTE)(sig >> 8), (BYTE)(sig >> 16), (BYTE)(sig >> 24));
        return FALSE;
    }

    if(pthis->m_ulRefCount <= 0)
    {
        DPF(DPFLVL_ERROR, "Interface reference count <= 0");
        return FALSE;
    }

    if(pthis->m_ulRefCount >= MAX_ULONG)
    {
        DPF(DPFLVL_ERROR, "Interface reference count >= MAX_ULONG");
        return FALSE;
    }

    return TRUE;
}

#endif // __cplusplus

#else // defined(DEBUG) || defined(RDEBUG)

#define IS_VALID_READ_PTR(a, b)         ((a) || (!(b)))
#define IS_VALID_WRITE_PTR(a, b)        ((a) || (!(b)))
#define IS_VALID_TYPED_READ_PTR(a)      (a)
#define IS_VALID_TYPED_WRITE_PTR(a)     (a)
#define IS_VALID_CODE_PTR(a)            (a)
#define IS_VALID_HWND(a)                (a)
#define IS_VALID_HANDLE(a)              (a)
#define IS_VALID_READ_WAVEFORMATEX(a)   (a)

#ifdef __cplusplus
#define IS_VALID_INTERFACE(a, b)        ((a) && (b == (a)->m_signature))
#endif // __cplusplus

#endif // defined(DEBUG) || defined(RDEBUG)

// Validation (of sorts) for external COM interfaces
#ifdef __cplusplus
struct _GENERIC_COM_INTERFACE {FARPROC *(vptr[1]);};
#define IS_VALID_EXTERNAL_INTERFACE(ptr) \
    (IS_VALID_READ_PTR(ptr, sizeof(_GENERIC_COM_INTERFACE)) && \
     IS_VALID_READ_PTR(*reinterpret_cast<_GENERIC_COM_INTERFACE*>(ptr)->vptr, sizeof(FARPROC)) && \
     IS_VALID_CODE_PTR(*(reinterpret_cast<_GENERIC_COM_INTERFACE*>(ptr)->vptr)[0]))
#endif // __cplusplus

#define CHECK_READ_PTR(p)       ASSERT(IS_VALID_TYPED_READ_PTR(p))
#define CHECK_WRITE_PTR(p)      ASSERT(IS_VALID_TYPED_WRITE_PTR(p))
#define CHECK_COM_INTERFACE(p)  ASSERT(IS_VALID_EXTERNAL_INTERFACE(p))

#define IS_VALID_WRITE_WAVEFORMATEX(a) \
            IS_VALID_WRITE_PTR(a, sizeof(WAVEFORMATEX))

#define IS_VALID_READ_DSBUFFERDESC(a) \
            ((IS_VALID_READ_PTR(a, sizeof(((LPCDSBUFFERDESC)(a))->dwSize))) && \
            (IS_VALID_READ_PTR(a, ((LPCDSBUFFERDESC)(a))->dwSize)))

#define IS_VALID_WRITE_DSBUFFERDESC(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DSBUFFERDESC)) && \
            sizeof(DSBUFFERDESC) == ((LPDSBUFFERDESC)(a))->dwSize)

#define IS_VALID_READ_DSCAPS(a) \
            (IS_VALID_READ_PTR(a, sizeof(DSCAPS)) && \
            sizeof(DSCAPS) == ((LPDSCAPS)(a))->dwSize)

#define IS_VALID_WRITE_DSCAPS(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DSCAPS)) && \
            sizeof(DSCAPS) == ((LPDSCAPS)(a))->dwSize)

#define IS_VALID_READ_DSBCAPS(a) \
            (IS_VALID_READ_PTR(a, sizeof(DSBCAPS)) && \
            sizeof(DSBCAPS) == ((LPDSBCAPS)(a))->dwSize)

#define IS_VALID_WRITE_DSBCAPS(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DSBCAPS)) && \
            sizeof(DSBCAPS) == ((LPDSBCAPS)(a))->dwSize)

#define IS_VALID_READ_DS3DBUFFER(a) \
            (IS_VALID_READ_PTR(a, sizeof(DS3DBUFFER)) && \
            sizeof(DS3DBUFFER) == ((LPDS3DBUFFER)(a))->dwSize)

#define IS_VALID_WRITE_DS3DBUFFER(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DS3DBUFFER)) && \
            sizeof(DS3DBUFFER) == ((LPDS3DBUFFER)(a))->dwSize)

#define IS_VALID_READ_DS3DLISTENER(a) \
            (IS_VALID_READ_PTR(a, sizeof(DS3DLISTENER)) && \
            sizeof(DS3DLISTENER) == ((LPDS3DLISTENER)(a))->dwSize)

#define IS_VALID_WRITE_DS3DLISTENER(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DS3DLISTENER)) && \
            sizeof(DS3DLISTENER) == ((LPDS3DLISTENER)(a))->dwSize)

#define IS_VALID_READ_GUID(a) \
            IS_VALID_READ_PTR(a, sizeof(GUID))

#define IS_VALID_WRITE_GUID(a) \
            IS_VALID_WRITE_PTR(a, sizeof(GUID))

#define IS_VALID_READ_DSCBUFFERDESC(a) \
            ((IS_VALID_READ_PTR(a, sizeof(((LPCDSCBUFFERDESC)(a))->dwSize))) && \
            (IS_VALID_READ_PTR(a, ((LPCDSCBUFFERDESC)(a))->dwSize)))

#define IS_VALID_WRITE_DSCBUFFERDESC(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DSCBUFFERDESC)) && \
            sizeof(DSCBUFFERDESC) == ((LPDSCBUFFERDESC)(a))->dwSize)

#define IS_VALID_READ_DSCCAPS(a) \
            (IS_VALID_READ_PTR(a, sizeof(DSCCAPS)) && \
            sizeof(DSCCAPS) == ((LPDSCCAPS)(a))->dwSize)

#define IS_VALID_WRITE_DSCCAPS(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DSCCAPS)) && \
            sizeof(DSCCAPS) == ((LPDSCCAPS)(a))->dwSize)

#define IS_VALID_READ_DSCBCAPS(a) \
            (IS_VALID_READ_PTR(a, sizeof(DSCBCAPS)) && \
            sizeof(DSCBCAPS) == ((LPDSCBCAPS)(a))->dwSize)

#define IS_VALID_WRITE_DSCBCAPS(a) \
            (IS_VALID_WRITE_PTR(a, sizeof(DSCBCAPS)) && \
            sizeof(DSCBCAPS) == ((LPDSCBCAPS)(a))->dwSize)

#define IS_VALID_FLAGS(a, b) \
            (!((a) & ~(b)))

#define IS_NULL_GUID(a) \
            (!(a) || CompareMemory(a, &GUID_NULL, sizeof(GUID)))

#define IS_VALID_DS3DLISTENER_DISTANCE_FACTOR(a) \
            (!((a) < DS3D_MINDISTANCEFACTOR || (a) > DS3D_MAXDISTANCEFACTOR))

#define IS_VALID_DS3DLISTENER_DOPPLER_FACTOR(a) \
            (!((a) < DS3D_MINDOPPLERFACTOR || (a) > DS3D_MAXDOPPLERFACTOR))

#define IS_VALID_DS3DLISTENER_ROLLOFF_FACTOR(a) \
            (!((a) < DS3D_MINROLLOFFFACTOR || (a) > DS3D_MAXROLLOFFFACTOR))

#define IS_VALID_DS3DBUFFER_CONE_OUTSIDE_VOLUME(a) \
            (!((a) < DSBVOLUME_MIN || (a) > DSBVOLUME_MAX))

#define IS_VALID_DS3DBUFFER_MAX_DISTANCE(a) \
            ((a) > 0.0f)

#define IS_VALID_DS3DBUFFER_MIN_DISTANCE(a) \
            ((a) > 0.0f)

#define IS_VALID_DS3DBUFFER_MODE(a) \
            (!((a) < DS3DMODE_FIRST || (a) > DS3DMODE_LAST))

#define IS_VALID_DSFULLDUPLEX_MODE(a) \
            (!((a) < DSFULLDUPLEXMODE_FIRST || (a) > DSFULLDUPLEXMODE_LAST))

#ifdef __cplusplus

#define IS_VALID_IUNKNOWN(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IUNKNOWN)

#define IS_VALID_IDIRECTSOUND(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUND)

#define IS_VALID_IDIRECTSOUNDBUFFER(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUNDBUFFER)

#define IS_VALID_IDIRECTSOUND3DBUFFER(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUND3DBUFFER)

#define IS_VALID_IDIRECTSOUND3DLISTENER(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUND3DLISTENER)

#define IS_VALID_ICLASSFACTORY(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_ICLASSFACTORY)

#define IS_VALID_IDIRECTSOUNDNOTIFY(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUNDNOTIFY)

#define IS_VALID_IKSPROPERTYSET(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IKSPROPERTYSET)

#define IS_VALID_IDIRECTSOUNDCAPTURE(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUNDCAPTURE)

#define IS_VALID_IDIRECTSOUNDCAPTUREBUFFER(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUNDCAPTUREBUFFER)

#define IS_VALID_IDIRECTSOUNDSINK(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUNDSINK)

#define IS_VALID_IPERSIST(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IPERSIST)

#define IS_VALID_IPERSISTSTREAM(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IPERSISTSTREAM)

#define IS_VALID_IDIRECTMUSICOBJECT(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTMUSICOBJECT)

#define IS_VALID_IDIRECTSOUNDFULLDUPLEX(ptr) \
            IS_VALID_INTERFACE(ptr, INTSIG_IDIRECTSOUNDFULLDUPLEX)

#endif // __cplusplus

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// DSBUFFERDESC versions
typedef enum
{
    DSVERSION_INITIAL = 0x0000,
    DSVERSION_DX7     = 0x0700,
    DSVERSION_DX7_1   = 0x0701,
    DSVERSION_DX8     = 0x0800,
} DSVERSION, *LPDSVERSION;

#define DSVERSION_CURRENT DIRECTSOUND_VERSION  // From dsound.h

extern HRESULT IsValidDsBufferDesc(DSVERSION, LPCDSBUFFERDESC, BOOL);
extern HRESULT IsValidDscBufferDesc(DSVERSION, LPCDSCBUFFERDESC);
extern BOOL IsValidDsBufferFlags(DWORD, DWORD);
extern BOOL IsValidWfxPtr(LPCWAVEFORMATEX);
extern BOOL IsValidWfx(LPCWAVEFORMATEX);
extern BOOL IsValidPcmWfx(LPCWAVEFORMATEX);
extern BOOL IsValidExtensibleWfx(PWAVEFORMATEXTENSIBLE);
extern BOOL IsValidHandle(HANDLE);
extern BOOL IsValidPropertySetId(REFGUID);
extern HRESULT ValidateNotificationPositions(DWORD, DWORD, LPCDSBPOSITIONNOTIFY, UINT, LPDSBPOSITIONNOTIFY *);
extern BOOL IsValidDs3dBufferConeAngles(DWORD, DWORD);
extern BOOL IsValidWaveDevice(UINT, BOOL, LPCVOID);
extern BOOL IsValid3dAlgorithm(REFGUID);
extern BOOL IsValidFxFlags(DWORD);
extern BOOL IsValidCaptureFxFlags(DWORD);
extern BOOL IsValidCaptureEffectDesc(LPCDSCEFFECTDESC pCaptureEffectDesc);
extern HRESULT BuildValidDsBufferDesc(LPCDSBUFFERDESC, LPDSBUFFERDESC, DSVERSION, BOOL);
extern HRESULT BuildValidDscBufferDesc(LPCDSCBUFFERDESC, LPDSCBUFFERDESC, DSVERSION);
extern LPCGUID BuildValidGuid(LPCGUID, LPGUID);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSVALID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsvalid.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsvalid.c
 *  Content:    DirectSound parameter validation.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/20/97     dereks  Created
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <mmddk.h>


/***************************************************************************
 *
 *  IsValidDsBufferDesc
 *
 *  Description:
 *      Determines if a DSBUFFERDESC structure is valid.
 *
 *  Arguments:
 *      DSVERSION [in]: structure version.
 *      LPDSBUFFERDESC [in]: structure to examime.
 *
 *  Returns:
 *      HRESULT: DS_OK if the structure is valid, otherwise the appropriate
 *               error code to be returned to the app/caller.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidDsBufferDesc"

HRESULT IsValidDsBufferDesc(DSVERSION nVersion, LPCDSBUFFERDESC pdsbd, BOOL fSinkBuffer)
{
    HRESULT                 hr              = DSERR_INVALIDPARAM;
    BOOL                    fValid          = TRUE;
    DWORD                   dwValidFlags    = DSBCAPS_VALIDFLAGS;

    DPF_ENTER();

    // Restrict the set of valid flags according to various bizarre rules
    if ((pdsbd->dwFlags & DSBCAPS_MIXIN) || fSinkBuffer)
        dwValidFlags &= DSBCAPS_STREAMINGVALIDFLAGS;

    if (fSinkBuffer)
    {
        dwValidFlags |= DSBCAPS_CTRLFREQUENCY;
        if (!(pdsbd->dwFlags & DSBCAPS_MIXIN))
            dwValidFlags |= DSBCAPS_LOCDEFER;
    }
    
#ifdef FUTURE_MULTIPAN_SUPPORT
    if (pdsbd->dwFlags & DSBCAPS_CTRLCHANNELVOLUME)
        dwValidFlags &= DSBCAPS_CHANVOLVALIDFLAGS;
#endif

    if (sizeof(DSBUFFERDESC) != pdsbd->dwSize)
    {
        RPF(DPFLVL_ERROR, "Invalid DSBUFFERDESC structure size");
        fValid = FALSE;
    }
    else if (pdsbd->dwReserved)
    {
        RPF(DPFLVL_ERROR, "Reserved field in the DSBUFFERDESC structure must be 0");
        fValid = FALSE;
    }
    else if (!fSinkBuffer && (pdsbd->dwFlags & DSBCAPS_CTRLFX) && (pdsbd->dwFlags & DSBCAPS_CTRLFREQUENCY))
    {
        RPF(DPFLVL_ERROR, "DSBCAPS_CTRLFREQUENCY is invalid with DSBCAPS_CTRLFX");
        fValid = FALSE;
    }
    else fValid = IsValidDsBufferFlags(pdsbd->dwFlags, dwValidFlags);

    if (fValid && (nVersion < DSVERSION_DX7) && (pdsbd->dwFlags & (DSBCAPS_LOCDEFER)))
    {
        RPF(DPFLVL_ERROR, "DSBCAPS_LOCDEFER is only valid on DirectSound 7 or higher");
        fValid = FALSE;
    }

    if (fValid && (nVersion < DSVERSION_DX8))
    {
#ifdef FUTURE_MULTIPAN_SUPPORT
        if (pdsbd->dwFlags & (DSBCAPS_CTRLFX | DSBCAPS_MIXIN | DSBCAPS_CTRLCHANNELVOLUME))
#else
        if (pdsbd->dwFlags & (DSBCAPS_CTRLFX | DSBCAPS_MIXIN))
#endif
        {
            #ifdef RDEBUG
                if (pdsbd->dwFlags & DSBCAPS_CTRLFX)
                    RPF(DPFLVL_ERROR, "DSBCAPS_CTRLFX is only valid on DirectSound8 objects");
                if (pdsbd->dwFlags & DSBCAPS_MIXIN)
                    RPF(DPFLVL_ERROR, "DSBCAPS_MIXIN is only valid on DirectSound8 objects");
#ifdef FUTURE_MULTIPAN_SUPPORT
                if (pdsbd->dwFlags & DSBCAPS_CTRLCHANNELVOLUME)
                    RPF(DPFLVL_ERROR, "DSBCAPS_CTRLCHANNELVOLUME is only valid on DirectSound8 objects");
#endif
            #endif
            hr = DSERR_DS8_REQUIRED;
            fValid = FALSE;
        }
    }

    if (fValid && (pdsbd->dwFlags & DSBCAPS_PRIMARYBUFFER))
    {
        if (pdsbd->dwBufferBytes)
        {
            RPF(DPFLVL_ERROR, "Primary buffers must be created with dwBufferBytes set to 0");
            fValid = FALSE;
        }
        else if (pdsbd->lpwfxFormat)
        {
            RPF(DPFLVL_ERROR, "Primary buffers must be created with NULL format");
            fValid = FALSE;
        }
        else if (!IS_NULL_GUID(&pdsbd->guid3DAlgorithm))
        {
            RPF(DPFLVL_ERROR, "No 3D algorithm may be specified for the listener");
            fValid = FALSE;
        }
    }
    else if (fValid)  // Secondary buffer
    {
        if (!IS_VALID_READ_WAVEFORMATEX(pdsbd->lpwfxFormat))
        {
            RPF(DPFLVL_ERROR, "Invalid format pointer");
            fValid = FALSE;
        }
        else if (!IsValidWfx(pdsbd->lpwfxFormat))
        {
            RPF(DPFLVL_ERROR, "Invalid buffer format");
            fValid = FALSE;
        }
        else if (fSinkBuffer || (pdsbd->dwFlags & DSBCAPS_MIXIN))
        {
            if (pdsbd->dwBufferBytes != 0)
            {
                RPF(DPFLVL_ERROR, "Buffer size must be 0 for MIXIN/sink buffers");
                fValid = FALSE;
            }
        }
        else  // Not a MIXIN or sink buffer
        {
            if (pdsbd->dwBufferBytes < DSBSIZE_MIN || pdsbd->dwBufferBytes > DSBSIZE_MAX)
            {
                RPF(DPFLVL_ERROR, "Buffer size out of bounds");
                fValid = FALSE;
            }
            else if ((pdsbd->dwFlags & DSBCAPS_CTRLFX) && (pdsbd->dwBufferBytes < MsToBytes(DSBSIZE_FX_MIN, pdsbd->lpwfxFormat)))
            {
                RPF(DPFLVL_ERROR, "Buffer too small for effect processing;\nmust hold at least %u ms of audio, "
                    "or %lu bytes in this format", DSBSIZE_FX_MIN, MsToBytes(DSBSIZE_FX_MIN, pdsbd->lpwfxFormat));
                hr = DSERR_BUFFERTOOSMALL;
                fValid = FALSE;
            }
        }

#ifdef FUTURE_MULTIPAN_SUPPORT
        if (fValid && (pdsbd->dwFlags & DSBCAPS_CTRLCHANNELVOLUME) && pdsbd->lpwfxFormat->nChannels != 1)
        {
            RPF(DPFLVL_ERROR, "DSBCAPS_CTRLCHANNELVOLUME is only valid for mono buffers");
            fValid = FALSE;
        }
#endif

        // Extra restrictions for sink buffers, MIXIN buffers and buffers with effects
        if (fValid && (fSinkBuffer || (pdsbd->dwFlags & (DSBCAPS_MIXIN | DSBCAPS_CTRLFX))))
        {
            // Only PCM, mono or stereo, 8- or 16-bit formats are currently supported
            if (pdsbd->lpwfxFormat->wFormatTag != WAVE_FORMAT_PCM)
            {
                RPF(DPFLVL_ERROR, "Wave format must be PCM for MIXIN/sink/effect buffers");
                fValid = FALSE;
            }
            else if (pdsbd->lpwfxFormat->nChannels != 1 && pdsbd->lpwfxFormat->nChannels != 2)
            {
                RPF(DPFLVL_ERROR, "MIXIN/sink/effect buffers must be mono or stereo");
                fValid = FALSE;
            }
            else if (pdsbd->lpwfxFormat->wBitsPerSample != 8 && pdsbd->lpwfxFormat->wBitsPerSample != 16)
            {
                RPF(DPFLVL_ERROR, "MIXIN/sink/effect buffers must be 8- or 16-bit");
                fValid = FALSE;
            }
        }

        if (fValid && !IS_NULL_GUID(&pdsbd->guid3DAlgorithm) && !(pdsbd->dwFlags & DSBCAPS_CTRL3D))
        {
            RPF(DPFLVL_ERROR, "Specified a 3D algorithm without DSBCAPS_CTRL3D");
            fValid = FALSE;
        }

        if (fValid && (pdsbd->dwFlags & DSBCAPS_CTRL3D))
        {
            if (pdsbd->lpwfxFormat->nChannels > 2)
            {
                RPF(DPFLVL_ERROR, "Specified DSBCAPS_CTRL3D with a multichannel wave format");
                fValid = FALSE;
            }
            else if (nVersion >= DSVERSION_DX8 &&
                     (pdsbd->lpwfxFormat->nChannels != 1 || (pdsbd->dwFlags & DSBCAPS_CTRLPAN)))
            {
                // For DirectX 8 and later, we forbid 3D buffers to have two
                // channels or pan control (as we always should have done).
                RPF(DPFLVL_ERROR, "Cannot use DSBCAPS_CTRLPAN or stereo buffers with DSBCAPS_CTRL3D");
                fValid = FALSE;
            }
        }
    }

    if (fValid)
    {
        hr = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  IsValidDsBufferFlags
 *
 *  Description:
 *      Determines if a set of buffer creation flags is valid.
 *
 *  Arguments:
 *      DWORD [in]: buffer flag set.
 *      DWORD [in]: mask of valid flags.
 *
 *  Returns:
 *      BOOL: TRUE if the flags are valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidDsBufferFlags"

BOOL IsValidDsBufferFlags(DWORD dwFlags, DWORD dwValidFlags)
{
    BOOL fValid = TRUE;

    DPF_ENTER();

    if (!IS_VALID_FLAGS(dwFlags, dwValidFlags))
    {
        RPF(DPFLVL_ERROR, "Invalid flags: 0x%8.8lX", dwFlags & ~dwValidFlags);
        fValid = FALSE;
    }
    else if ((dwFlags & DSBCAPS_LOCSOFTWARE) && (dwFlags & DSBCAPS_LOCHARDWARE))
    {
        RPF(DPFLVL_ERROR, "Specified both LOCSOFTWARE and LOCHARDWARE");
        fValid = FALSE;
    }
    else if ((dwFlags & DSBCAPS_LOCDEFER) && (dwFlags & DSBCAPS_LOCMASK))
    {
        RPF(DPFLVL_ERROR, "Specified LOCDEFER with either LOCHARDWARE or LOCSOFTWARE");
        fValid = FALSE;
    }
    else if ((dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE) && !(dwFlags & DSBCAPS_CTRL3D))
    {
        RPF(DPFLVL_ERROR, "Specified MUTE3DATMAXDISTANCE without CTRL3D");
        fValid = FALSE;
    }
    else if ((dwFlags & DSBCAPS_STATIC) && (dwFlags & DSBCAPS_CTRLFX))
    {
        RPF(DPFLVL_ERROR, "Specified both STATIC and CTRLFX");
        fValid = FALSE;
    }
    else if ((dwFlags & DSBCAPS_STATIC) && (dwFlags & DSBCAPS_MIXIN))
    {
        RPF(DPFLVL_ERROR, "Specified both STATIC and MIXIN");
        fValid = FALSE;
    }
    else if ((dwFlags & DSBCAPS_STATIC) && (dwFlags & DSBCAPS_SINKIN))
    {
        RPF(DPFLVL_ERROR, "Specified both STATIC and SINKIN");
        fValid = FALSE;
    }
    else if (dwFlags & DSBCAPS_PRIMARYBUFFER)
    {
        if (dwFlags & (DSBCAPS_CTRLFREQUENCY | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_GLOBALFOCUS |
                       DSBCAPS_STATIC | DSBCAPS_CTRLFX | DSBCAPS_MIXIN
#ifdef FUTURE_MULTIPAN_SUPPORT
             | DSBCAPS_CTRLCHANNELVOLUME 
#endif
           ))
        {
            #ifdef RDEBUG
                if (dwFlags & DSBCAPS_CTRLFREQUENCY)
                    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLFREQUENCY");
                if (dwFlags & DSBCAPS_CTRLPOSITIONNOTIFY)
                    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLPOSITIONNOTIFY");
                if (dwFlags & DSBCAPS_GLOBALFOCUS)
                    RPF(DPFLVL_ERROR, "Primary buffers don't support GLOBAL focus");
                if (dwFlags & DSBCAPS_STATIC)
                    RPF(DPFLVL_ERROR, "Primary buffers can't be STATIC");
#ifdef FUTURE_MULTIPAN_SUPPORT
                if (dwFlags & DSBCAPS_CTRLCHANNELVOLUME)
                    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLCHANNELVOLUME");
#endif
                if (dwFlags & DSBCAPS_CTRLFX)
                    RPF(DPFLVL_ERROR, "Primary buffers don't support CTRLFX");
                if (dwFlags & DSBCAPS_MIXIN)
                    RPF(DPFLVL_ERROR, "Primary buffers can't be MIXIN");
            #endif
            fValid = FALSE;
        }
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidWfxPtr
 *
 *  Description:
 *      Determines if an LPWAVEFORMATEX pointer is valid.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: pointer to examime.
 *
 *  Returns:
 *      BOOL: TRUE if the structure is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidWfxPtr"

BOOL IsValidWfxPtr(LPCWAVEFORMATEX pwfx)
{
    BOOL                    fValid;

    DPF_ENTER();

    fValid = IS_VALID_READ_PTR(pwfx, sizeof(PCMWAVEFORMAT));

    if (fValid && WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        fValid = IS_VALID_READ_PTR(pwfx, sizeof(WAVEFORMATEX));
    }

    if (fValid && WAVE_FORMAT_PCM != pwfx->wFormatTag)
    {
        fValid = IS_VALID_READ_PTR(pwfx, sizeof(WAVEFORMATEX) + pwfx->cbSize);
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidWfx
 *
 *  Description:
 *      Determines if a WAVEFORMATEX structure is valid.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: structure to examime.
 *
 *  Returns:
 *      BOOL: TRUE if the structure is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidWfx"

BOOL IsValidWfx(LPCWAVEFORMATEX pwfx)
{
    BOOL fValid;

    DPF_ENTER();

    switch (pwfx->wFormatTag)
    {
        case WAVE_FORMAT_PCM:
            fValid = IsValidPcmWfx(pwfx);
            break;

        case WAVE_FORMAT_EXTENSIBLE:
            fValid = IsValidExtensibleWfx((PWAVEFORMATEXTENSIBLE)pwfx);
            break;

        default:
            fValid = TRUE;
            break;
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidPcmWfx
 *
 *  Description:
 *      Determines if a WAVEFORMATEX structure is valid for PCM audio.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: structure to examime.
 *
 *  Returns:
 *      BOOL: TRUE if the structure is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidPcmWfx"

BOOL IsValidPcmWfx(LPCWAVEFORMATEX pwfx)
{
    BOOL                    fValid    = TRUE;
    DWORD                   dwAvgBytes;

    DPF_ENTER();

    if (pwfx->wFormatTag != WAVE_FORMAT_PCM)
    {
        RPF(DPFLVL_ERROR, "Format not PCM");
        fValid = FALSE;
    }

    if (fValid && pwfx->nChannels != 1 && pwfx->nChannels != 2)
    {
        RPF(DPFLVL_ERROR, "Not mono or stereo");
        fValid = FALSE;
    }

    if (fValid && pwfx->wBitsPerSample != 8 && pwfx->wBitsPerSample != 16)
    {
        RPF(DPFLVL_ERROR, "Not 8 or 16 bit");
        fValid = FALSE;
    }

    if (fValid && (pwfx->nSamplesPerSec < DSBFREQUENCY_MIN || pwfx->nSamplesPerSec > DSBFREQUENCY_MAX))
    {
        RPF(DPFLVL_ERROR, "Frequency out of bounds");
        fValid = FALSE;
    }

    if (fValid && pwfx->nBlockAlign != (pwfx->wBitsPerSample / 8) * pwfx->nChannels)
    {
        RPF(DPFLVL_ERROR, "Bad block alignment");
        fValid = FALSE;
    }

    if (fValid)
    {
        dwAvgBytes = pwfx->nSamplesPerSec * pwfx->nBlockAlign;

        if (pwfx->nAvgBytesPerSec > dwAvgBytes + (dwAvgBytes / 20) || pwfx->nAvgBytesPerSec < dwAvgBytes - (dwAvgBytes / 20))
        {
            RPF(DPFLVL_ERROR, "Bad average bytes per second");
            fValid = FALSE;
        }
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidExtensibleWfx
 *
 *  Description:
 *      Determines if a WAVEFORMATEXTENSIBLE structure is wellformed.
 *
 *  Arguments:
 *      PWAVEFORMATEXTENSIBLE [in]: structure to examime.
 *
 *  Returns:  
 *      BOOL: TRUE if the structure is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidExtensibleWfx"

BOOL IsValidExtensibleWfx(PWAVEFORMATEXTENSIBLE pwfx)
{
    BOOL fValid = TRUE;
    DPF_ENTER();
    
    if (pwfx->Format.wFormatTag != WAVE_FORMAT_EXTENSIBLE)
    {
        RPF(DPFLVL_ERROR, "Format tag not WAVE_FORMAT_EXTENSIBLE");
        fValid = FALSE;
    }
    else if (pwfx->Format.cbSize < (sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)))
    {
        RPF(DPFLVL_ERROR, "Field cbSize too small for WAVEFORMATEXTENSIBLE");
        fValid = FALSE;
    }
    else if (pwfx->Format.nChannels == 0)
    {
        RPF(DPFLVL_ERROR, "Zero channels is invalid for WAVEFORMATEXTENSIBLE");
        fValid = FALSE;
    }
    else if (pwfx->Format.wBitsPerSample != 8  && pwfx->Format.wBitsPerSample != 16 &&
             pwfx->Format.wBitsPerSample != 24 && pwfx->Format.wBitsPerSample != 32)
    {
        RPF(DPFLVL_ERROR, "Only 8, 16, 24 or 32 bit formats allowed for WAVEFORMATEXTENSIBLE");
        fValid = FALSE;
    }
    else if (pwfx->Format.nSamplesPerSec < DSBFREQUENCY_MIN || pwfx->Format.nSamplesPerSec > DSBFREQUENCY_MAX)
    {
        RPF(DPFLVL_ERROR, "Frequency out of bounds in WAVEFORMATEXTENSIBLE");
        fValid = FALSE;
    }
    else if (pwfx->Format.nBlockAlign != (pwfx->Format.wBitsPerSample / 8) * pwfx->Format.nChannels)
    {
        RPF(DPFLVL_ERROR, "Bad block alignment in WAVEFORMATEXTENSIBLE");
        fValid = FALSE;
    }
    else if (pwfx->Samples.wValidBitsPerSample > pwfx->Format.wBitsPerSample)
    {
        RPF(DPFLVL_ERROR, "WAVEFORMATEXTENSIBLE has higher wValidBitsPerSample than wBitsPerSample");
        fValid = FALSE;
    }

    // Check the average bytes per second (within 5%)
    if (fValid)
    {
        DWORD dwAvgBytes = pwfx->Format.nSamplesPerSec * pwfx->Format.nBlockAlign;
        if (pwfx->Format.nAvgBytesPerSec > dwAvgBytes + (dwAvgBytes / 20) || pwfx->Format.nAvgBytesPerSec < dwAvgBytes - (dwAvgBytes / 20))
        {
            RPF(DPFLVL_ERROR, "Bad average bytes per second in WAVEFORMATEXTENSIBLE");
            fValid = FALSE;
        }
    }

    // Check the number of bits set in the channel mask against nChannels
    if (fValid && CountBits(pwfx->dwChannelMask) > pwfx->Format.nChannels)
    {
        RPF(DPFLVL_INFO, "Number of bits set in dwChannelMask exceeds nChannels in WAVEFORMATEXTENSIBLE");
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidHandle
 *
 *  Description:
 *      Validates an object handle.
 *
 *  Arguments:
 *      HANDLE [in]: handle to validate.
 *
 *  Returns:
 *      BOOL: TRUE if the handle is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidHandle"

BOOL IsValidHandle(HANDLE hHandle)
{
    const HANDLE        hProcess    = GetCurrentProcess();
    HANDLE              hDuplicate;
    BOOL                fSuccess;

    DPF_ENTER();

    fSuccess = DuplicateHandle(hProcess, hHandle, hProcess, &hDuplicate, 0, FALSE, DUPLICATE_SAME_ACCESS);

    CLOSE_HANDLE(hDuplicate);

    DPF_LEAVE(fSuccess);
    return fSuccess;
}


/***************************************************************************
 *
 *  IsValidPropertySetId
 *
 *  Description:
 *      Validates a property set id.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *
 *  Returns:
 *      BOOL: TRUE if the property set ID is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidPropertySetId"

BOOL IsValidPropertySetId(REFGUID guidPropertySetId)
{
    LPCGUID const           apguidInvalid[] = { &DSPROPSETID_DirectSound3DListener, &DSPROPSETID_DirectSound3DBuffer, &DSPROPSETID_DirectSoundSpeakerConfig };
    BOOL                    fValid;
    UINT                    i;

    DPF_ENTER();

    ASSERT(!IS_NULL_GUID(guidPropertySetId));

    for (i=0, fValid=TRUE; i < NUMELMS(apguidInvalid) && fValid; i++)
    {
        fValid = !IsEqualGUID(guidPropertySetId, apguidInvalid[i]);
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidDscBufferDesc
 *
 *  Description:
 *      Determines if a DSCBUFFERDESC structure is valid.
 *
 *  Arguments:
 *      DSVERSION [in]: structure version.
 *      LPCDSCBUFFERDESC [in]: structure to examime.
 *
 *  Returns:
 *      HRESULT: DS_OK if the structure is valid, otherwise the appropriate
 *               error code to be returned to the app/caller.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidDscBufferDesc"

HRESULT IsValidDscBufferDesc(DSVERSION nVersion, LPCDSCBUFFERDESC pdscbd)
{
    HRESULT                 hr      = DSERR_INVALIDPARAM;
    BOOL                    fValid  = TRUE;
    DWORD                   i;

    DPF_ENTER();

    if (pdscbd->dwSize != sizeof(DSCBUFFERDESC))
    {
        RPF(DPFLVL_ERROR, "Invalid size");
        fValid = FALSE;
    }

    if (fValid && !IS_VALID_FLAGS(pdscbd->dwFlags, DSCBCAPS_VALIDFLAGS))
    {
        RPF(DPFLVL_ERROR, "Invalid flags");
        fValid = FALSE;
    }

    if (fValid)
    {
        if (pdscbd->dwFlags & DSCBCAPS_CTRLFX)
        {
            if (nVersion < DSVERSION_DX8)
            {
                RPF(DPFLVL_ERROR, "DSCBCAPS_CTRLFX is only valid on DirectSoundCapture8 objects");
                hr = DSERR_DS8_REQUIRED;
                fValid = FALSE;
            }
            else if (!pdscbd->dwFXCount != !pdscbd->lpDSCFXDesc)
            {
                RPF(DPFLVL_ERROR, "If either of dwFXCount or lpDSCFXDesc are 0, both must be 0");
                fValid = FALSE;
            }
        }
        else // !DSCBCAPS_CTRLFX
        {
            if (pdscbd->dwFXCount || pdscbd->lpDSCFXDesc)
            {
                RPF(DPFLVL_ERROR, "If DSCBCAPS_CTRLFX is not set, dwFXCount and lpDSCFXDesc must be 0");
                fValid = FALSE;
            }
        }
    }

    if (fValid && pdscbd->dwReserved)
    {
        RPF(DPFLVL_ERROR, "Reserved field in the DSCBUFFERDESC structure must be 0");
        fValid = FALSE;
    }

    if (fValid && (pdscbd->dwBufferBytes < DSBSIZE_MIN || pdscbd->dwBufferBytes > DSBSIZE_MAX))
    {
        RPF(DPFLVL_ERROR, "Invalid buffer size");
        fValid = FALSE;
    }

    if (fValid && !IS_VALID_READ_WAVEFORMATEX(pdscbd->lpwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Unreadable WAVEFORMATEX");
        fValid = FALSE;
    }

    if (fValid && !IsValidWfx(pdscbd->lpwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Invalid format");
        fValid = FALSE;
    }

    if (fValid && (pdscbd->dwFXCount != 0))
    {
        for (i=0; i<pdscbd->dwFXCount; i++)
        {
            fValid = IsValidCaptureEffectDesc(&pdscbd->lpDSCFXDesc[i]);
            if (!fValid)
                break;
        }
    }

    if (fValid)
    {
        hr = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  IsValidCaptureFxFlags
 *
 *  Description:
 *      Determines if a combination of DSCFX_* flags is valid.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      BOOL: TRUE if the flags are valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidCaptureFxFlags"

BOOL IsValidCaptureFxFlags(DWORD dwFlags)
{
    BOOL fValid;
    DPF_ENTER();

    fValid = IS_VALID_FLAGS(dwFlags, DSCFX_VALIDFLAGS) &&
             !((dwFlags & DSCFX_LOCHARDWARE) && (dwFlags & DSCFX_LOCSOFTWARE)) &&
             ((dwFlags & DSCFX_LOCHARDWARE) || (dwFlags & DSCFX_LOCSOFTWARE));

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidCaptureEffectDesc
 *
 *  Description:
 *      Determines if a capture effect descriptor structure is valid.
 *
 *  Arguments:
 *      LPGUID [in]: effect identifier.
 *
 *  Returns:
 *      BOOL: TRUE if the ID is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidCaptureEffectDesc"

BOOL IsValidCaptureEffectDesc(LPCDSCEFFECTDESC pCaptureEffectDesc)
{
    BOOL fValid = TRUE;

    DPF_ENTER();

    if (sizeof(DSCEFFECTDESC) != pCaptureEffectDesc->dwSize)
    {
        RPF(DPFLVL_ERROR, "Invalid size");
        fValid = FALSE;
    }

    if (fValid)
    {
        fValid = IsValidCaptureFxFlags(pCaptureEffectDesc->dwFlags);
    }

    // FIXME: Check that the GUID corresponds to a registered DMO?

    if (pCaptureEffectDesc->dwReserved1 || pCaptureEffectDesc->dwReserved2)
    {
        RPF(DPFLVL_ERROR, "Reserved fields in the DSCEFFECTDESC structure must be 0");
        fValid = FALSE;
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  ValidateNotificationPositions
 *
 *  Description:
 *      Validates array of notification positions and returns an allocated
 *      array of position.notifications sorted by increasing offset on success.
 *
 *  Arguments:
 *      DWORD [in]: size of buffer
 *      DWORD [in]: count of position.notifies
 *      LPCDSBPOSITIONNOTIFY [in]: array of position.notifies
 *      UINT [in]: size of samples in bytes
 *      LPDSBPOSITIONNOTIFY * [out]: receives array of sorted position.notifies
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "ValidateNotificationPositions"

HRESULT ValidateNotificationPositions(DWORD cbBuffer, DWORD cNotes, LPCDSBPOSITIONNOTIFY paNotes, UINT cbSample, LPDSBPOSITIONNOTIFY *ppaNotesOrdered)
{
    HRESULT                 hr              = DS_OK;
    LPDSBPOSITIONNOTIFY     paNotesOrdered  = NULL;
    DSBPOSITIONNOTIFY       dspnTemp;
    UINT                    i;

    DPF_ENTER();

    ASSERT(IS_VALID_WRITE_PTR(ppaNotesOrdered, sizeof(LPDSBPOSITIONNOTIFY)));

    if (paNotes && !IS_VALID_READ_PTR(paNotes, cNotes * sizeof(paNotes[0])))
    {
        RPF(DPFLVL_ERROR, "Invalid LPDSBPOSITIONNOTIFY pointer");
        hr = DSERR_INVALIDPARAM;
    }

    // Make a sample-aligned copy of the list
    if (SUCCEEDED(hr) && cNotes)
    {
        paNotesOrdered = MEMALLOC_A_COPY(DSBPOSITIONNOTIFY, cNotes, paNotes);
        hr = HRFROMP(paNotesOrdered);
    }

    for (i = 0; i < cNotes && SUCCEEDED(hr); i++)
    {
        if (DSBPN_OFFSETSTOP != paNotesOrdered[i].dwOffset)
        {
            paNotesOrdered[i].dwOffset = BLOCKALIGN(paNotesOrdered[i].dwOffset, cbSample);
        }
    }

    // Put the list into ascending order
    for (i = 0; i + 1 < cNotes && SUCCEEDED(hr); i++)
    {
        if (paNotesOrdered[i].dwOffset > paNotesOrdered[i + 1].dwOffset)
        {
            dspnTemp = paNotesOrdered[i];
            paNotesOrdered[i] = paNotesOrdered[i + 1];
            paNotesOrdered[i + 1] = dspnTemp;
            i = -1;
        }
    }

    // Validate the list
    for (i = 0; i < cNotes && SUCCEEDED(hr); i++)
    {
        // Buffer offset must be valid
        if ((DSBPN_OFFSETSTOP != paNotesOrdered[i].dwOffset) && (paNotesOrdered[i].dwOffset >= cbBuffer))
        {
            RPF(DPFLVL_ERROR, "dwOffset (%lu) of notify index %lu is invalid", paNotesOrdered[i].dwOffset, i);
            hr = DSERR_INVALIDPARAM;
            break;
        }

        // Event handle must be valid
        if (!IS_VALID_HANDLE(paNotesOrdered[i].hEventNotify))
        {
            RPF(DPFLVL_ERROR, "hEventNotify (0x%p) of notify index %lu is invalid", paNotesOrdered[i].hEventNotify, i);
            hr = DSERR_INVALIDPARAM;
            break;
        }

        // Only one event allowed per sample offset
        if ((i + 1) < cNotes)
        {
            if (DSBPN_OFFSETSTOP == paNotesOrdered[i].dwOffset)
            {
                RPF(DPFLVL_ERROR, "Additional stop event at notify index %lu", i);
                hr = DSERR_INVALIDPARAM;
                break;
            }
            else if (paNotesOrdered[i].dwOffset == paNotesOrdered[i + 1].dwOffset)
            {
                RPF(DPFLVL_ERROR, "Duplicate sample position at notify index %lu", paNotesOrdered[i].dwOffset, paNotesOrdered[i + 1].dwOffset, i + 1);
                hr = DSERR_INVALIDPARAM;
                break;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        *ppaNotesOrdered = paNotesOrdered;
    }
    else
    {
        MEMFREE(paNotesOrdered);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  IsValidDs3dBufferConeAngles
 *
 *  Description:
 *      Validates DirectSound3D Buffer Cone Angles.
 *
 *  Arguments:
 *      DWORD [in]: inside cone angle.
 *      DWORD [in]: outside cone angle.
 *
 *  Returns:
 *      BOOL: TRUE if the cone anlges are valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidDs3dBufferConeAngles"

BOOL IsValidDs3dBufferConeAngles(DWORD dwInside, DWORD dwOutside)
{
    BOOL fValid = TRUE;

    if (dwOutside < dwInside)
    {
        RPF(DPFLVL_ERROR, "Outside cone angle can't be less than inside");
        fValid = FALSE;
    }
    else if (dwInside > 360 || dwOutside > 360)
    {
        RPF(DPFLVL_ERROR, "There are only 360 degrees in a circle");
        fValid = FALSE;
    }

    return fValid;
}


/***************************************************************************
 *
 *  IsValidWaveDevice
 *
 *  Description:
 *      Determines if a waveOut device is useable.
 *
 *  Arguments:
 *      UINT [in]: device id.
 *      BOOL [in]: TRUE if capture.
 *      LPVOID [in]: device caps.  This parameter may be NULL.
 *
 *  Returns:
 *      BOOL: TRUE if the device is useable.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidWaveDevice"

BOOL IsValidWaveDevice(UINT uDeviceId, BOOL fCapture, LPCVOID pvCaps)
{
    const UINT              cDevices    = WaveGetNumDevs(fCapture);
    BOOL                    fOk         = TRUE;
    WAVEOUTCAPS             woc;
    WAVEINCAPS              wic;
    MMRESULT                mmr;

    DPF_ENTER();

    // Make sure this is a real device
    if (uDeviceId >= cDevices)
    {
        DPF(DPFLVL_ERROR, "Invalid waveOut device id");
        fOk = FALSE;
    }

    // Get device caps, if they weren't supplied to us
    if (fOk && !pvCaps)
    {
        if (fCapture)
        {
            pvCaps = &wic;
            mmr = waveInGetDevCaps(uDeviceId, &wic, sizeof(wic));
        }
        else
        {
            pvCaps = &woc;
            mmr = waveOutGetDevCaps(uDeviceId, &woc, sizeof(woc));
        }

        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(DPFLVL_ERROR, "Can't get device %lu caps", uDeviceId);
            fOk = FALSE;
        }
    }

    // Check for compatible caps
    if (fOk && !fCapture)
    {
        if (!(((LPWAVEOUTCAPS)pvCaps)->dwSupport & WAVECAPS_LRVOLUME))
        {
            RPF(DPFLVL_WARNING, "Device %lu does not support separate left and right volume control", uDeviceId);
        }

        if (!(((LPWAVEOUTCAPS)pvCaps)->dwSupport & WAVECAPS_VOLUME))
        {
            RPF(DPFLVL_WARNING, "Device %lu does not support volume control", uDeviceId);
        }

        if (!(((LPWAVEOUTCAPS)pvCaps)->dwSupport & WAVECAPS_SAMPLEACCURATE))
        {
            RPF(DPFLVL_WARNING, "Device %lu does not return sample-accurate position information", uDeviceId);
        }

        if (((LPWAVEOUTCAPS)pvCaps)->dwSupport & WAVECAPS_SYNC)
        {
            RPF(DPFLVL_ERROR, "Device %lu is synchronous and will block while playing a buffer", uDeviceId);
            fOk = FALSE;
        }
    }

    DPF_LEAVE(fOk);
    return fOk;
}


/***************************************************************************
 *
 *  IsValid3dAlgorithm
 *
 *  Description:
 *      Determines if a 3D algorithm GUID is valid.
 *
 *  Arguments:
 *      LPGUID [in]: 3D algorithm identifier.
 *
 *  Returns:
 *      BOOL: TRUE if the ID is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValid3dAlgorithm"

BOOL IsValid3dAlgorithm(REFGUID guid3dAlgorithm)
{
    LPCGUID                 apguidValid[]   = { &DS3DALG_ITD, &DS3DALG_NO_VIRTUALIZATION, &DS3DALG_HRTF_LIGHT, &DS3DALG_HRTF_FULL };
    BOOL                    fValid;
    UINT                    i;

    DPF_ENTER();

    if (IS_NULL_GUID(guid3dAlgorithm))
    {
        fValid = TRUE;
    }
    else
    {
        for (i = 0, fValid = FALSE; i < NUMELMS(apguidValid) && !fValid; i++)
        {
            fValid = IsEqualGUID(guid3dAlgorithm, apguidValid[i]);
        }
    }

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  IsValidFxFlags
 *
 *  Description:
 *      Determines if a combination of DSFX_* flags is valid.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      BOOL: TRUE if the flags are valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidFxFlags"

BOOL IsValidFxFlags(DWORD dwFlags)
{
    BOOL fValid;
    DPF_ENTER();

    fValid = IS_VALID_FLAGS(dwFlags, DSFX_VALIDFLAGS) &&
             !((dwFlags & DSFX_LOCHARDWARE) && (dwFlags & DSFX_LOCSOFTWARE));

    DPF_LEAVE(fValid);
    return fValid;
}


/***************************************************************************
 *
 *  BuildValidDsBufferDesc
 *
 *  Description:
 *      Builds a DSBUFFERDESC structure based on a potentially invalid
 *      external version.
 *
 *  Arguments:
 *      LPDSBUFFERDESC [in]: structure to examime.
 *      LPDSBUFFERDESC [out]: receives validated structure.
 *      DSVERSION [in]: version information from our caller.
 *      BOOL [in]: TRUE if this buffer is being created on a DS sink.
 *
 *  Returns:
 *      HRESULT: DS_OK if the structure is valid, otherwise the appropriate
 *               error code to be returned to the app/caller.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "BuildValidDsBufferDesc"

HRESULT BuildValidDsBufferDesc(LPCDSBUFFERDESC pOld, LPDSBUFFERDESC pNew, DSVERSION nVersion, BOOL fSinkBuffer)
{
    BOOL        fValid      = TRUE;
    HRESULT     hr          = DSERR_INVALIDPARAM;

    DPF_ENTER();

    // Determine the structure version from its size.
    // This is complementary to the nVersion argument, which is derived from
    // the COM interfaces requested so far on this object.  If the structure
    // size is smaller than the current size, we believe it.  Otherwise, we
    // go with the COM interface version.
    switch (pOld->dwSize)
    {
        case sizeof(DSBUFFERDESC1):
            nVersion = DSVERSION_INITIAL;
            break;

        case sizeof(DSBUFFERDESC):
            // Was nVersion = DSVERSION_CURRENT; but see comment above
            break;

        default:
            RPF(DPFLVL_ERROR, "Invalid size");
            fValid = FALSE;
            break;
    }

    if (fValid)
    {
        // Fill in the structure size.  We're always using the most current
        // version of the structure, so this should reflect the current
        // DSBUFFERDESC size.
        pNew->dwSize = sizeof(DSBUFFERDESC);

        // Fill in the rest of the structure
        CopyMemoryOffset(pNew, pOld, pOld->dwSize, sizeof(pOld->dwSize));
        ZeroMemoryOffset(pNew, pNew->dwSize, pOld->dwSize);
            
        // Fix the 3D algorithm GUID if invalid
        if (!IsValid3dAlgorithm(&pNew->guid3DAlgorithm))
        {
            DPF(DPFLVL_WARNING, "Invalid 3D algorithm GUID");
            pNew->guid3DAlgorithm = GUID_NULL;  // This means "use default algorithm"
        }

        // Validate the new structure
        hr = IsValidDsBufferDesc(nVersion, pNew, fSinkBuffer);
    }

    // Check and set up the buffer size for special buffer types
    if (SUCCEEDED(hr) && ((pNew->dwFlags & DSBCAPS_MIXIN) || fSinkBuffer))
    {
        // The size requested for internal buffers must be 0 - we always use
        // a size corresponding to INTERNAL_BUFFER_LENGTH milliseconds.
        // (FIXME - is the size of sinkin buffers determined here or in dssink.cpp?)
            
        pNew->dwBufferBytes = (INTERNAL_BUFFER_LENGTH * pNew->lpwfxFormat->nAvgBytesPerSec) / 1000;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  BuildValidDscBufferDesc
 *
 *  Description:
 *      Builds a DSCBUFFERDESC structure based on a potentially invalid
 *      external version.
 *
 *  Arguments:
 *      LPDSCBUFFERDESC [in]: structure to examime.
 *      LPDSCBUFFERDESC [out]: receives validated structure.
 *
 *  Returns:
 *      HRESULT: DS_OK if the structure is valid, otherwise the appropriate
 *               error code to be returned to the app/caller.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "BuildValidDscBufferDesc"

HRESULT BuildValidDscBufferDesc(LPCDSCBUFFERDESC pOld, LPDSCBUFFERDESC pNew, DSVERSION nVersion)
{
    BOOL        fValid      = TRUE;
    HRESULT     hr          = DSERR_INVALIDPARAM;

    DPF_ENTER();

    // Determine the structure version
    switch (pOld->dwSize)
    {
        case sizeof(DSCBUFFERDESC1):
            nVersion = DSVERSION_INITIAL;
            break;

        case sizeof(DSCBUFFERDESC):
            // nVersion = DSVERSION_CURRENT; - See comment in BuildValidDsBufferDesc
            break;

        default:
            RPF(DPFLVL_ERROR, "Invalid size");
            fValid = FALSE;
            break;
    }

    // Fill in the structure size.  We're always using the most current
    // version of the structure, so this should reflect the current
    // DSBUFFERDESC size.
    if (fValid)
    {
        pNew->dwSize = sizeof(DSCBUFFERDESC);

        // Fill in the rest of the structure
        CopyMemoryOffset(pNew, pOld, pOld->dwSize, sizeof(pOld->dwSize));
        ZeroMemoryOffset(pNew, pNew->dwSize, pOld->dwSize);

        // Validate the new structure
        hr = IsValidDscBufferDesc(nVersion, pNew);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  BuildValidGuid
 *
 *  Description:
 *      Builds a GUID based on a potentially invalid external version.
 *
 *  Arguments:
 *      REFGUID [in]: source GUID.
 *      LPGUID [out]: receives new GUID.
 *
 *  Returns:
 *      LPGUID: pointer to new GUID.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "BuildValidGuid"

LPCGUID BuildValidGuid(LPCGUID pguidSource, LPGUID pguidDest)
{
    DPF_ENTER();

    if (IS_NULL_GUID(pguidSource))
    {
        pguidSource = &GUID_NULL;
    }

    if (pguidDest)
    {
        CopyMemory(pguidDest, pguidSource, sizeof(GUID));
    }

    DPF_LEAVE(pguidSource);
    return pguidSource;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsvxdhlp.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsvxdhlp.c
 *  Content:    DSOUND.VXD wrappers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  3/7/95      John Miles (Miles Design, Incorporated)
 *  2/3/97      dereks  Ported to DX5
 *
 ***************************************************************************/

//
// Dear reader, please pay heed to the following warning:
//
// Because dsound.vxd reads directly from the stack, arguments passed
// to any of the following wrapper functions may not be modified.  The VxD
// will NOT see the changes.
//

#ifdef NOVXD
#error dsvxdhlp.c being built with NOVXD defined
#endif // NOVXD

#include "dsoundi.h"
#include "dsvxd.h"

// The VC compiler likes to try to pass arguments in registers
#pragma optimize("", off)

#ifndef FILE_FLAG_GLOBAL_HANDLE
#define FILE_FLAG_GLOBAL_HANDLE 0x00800000
#endif // FILE_FLAG_GLOBAL_HANDLE

int g_cReservedAliases;
int g_cCommittedAliases;


LPVOID __stdcall VxdMemReserveAlias(LPVOID pBuffer, DWORD cbBuffer)
{
    LPVOID pAlias;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(pBuffer && cbBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_MEMRESERVEALIAS,
			  &pBuffer,
			  2*4,
			  &pAlias,
			  sizeof(pAlias),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(pAlias));

    if (NULL != pAlias) g_cReservedAliases++;
    return pAlias;
}

BOOL __stdcall VxdMemCommitAlias(LPVOID pAlias, LPVOID pBuffer, DWORD cbBuffer)
{
    BOOL fReturn;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(pAlias && pBuffer && cbBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_MEMCOMMITALIAS,
			  &pAlias,
			  3*4,
			  &fReturn,
			  sizeof(fReturn),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(fReturn));

    if (fReturn) g_cCommittedAliases++;
    return fReturn;
}

BOOL __stdcall VxdMemRedirectAlias(LPVOID pAlias, DWORD cbBuffer)
{
    BOOL fReturn;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(pAlias && cbBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_MEMREDIRECTALIAS,
			  &pAlias,
			  2*4,
			  &fReturn,
			  sizeof(fReturn),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(fReturn));
    return fReturn;
}

BOOL __stdcall VxdMemDecommitAlias(LPVOID pAlias, DWORD cbBuffer)
{
    BOOL fReturn;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(pAlias && cbBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_MEMDECOMMITALIAS,
			  &pAlias,
			  2*4,
			  &fReturn,
			  sizeof(fReturn),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(fReturn));

    if (fReturn) g_cCommittedAliases--;
    return fReturn;
}

BOOL __stdcall VxdMemFreeAlias(LPVOID pAlias, DWORD cbBuffer)
{
    BOOL fReturn;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(pAlias && cbBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_MEMFREEALIAS,
			  &pAlias,
			  2*4,
			  &fReturn,
			  sizeof(fReturn),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(fReturn));

    if (fReturn) g_cReservedAliases--;
    return fReturn;
}


//===========================================================================
//
// Event APIs
//
//===========================================================================
BOOL __stdcall VxdEventScheduleWin32Event(DWORD VxdhEvent, DWORD dwDelay)
{
    BOOL fReturn;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(VxdhEvent);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_EVENTSCHEDULEWIN32EVENT,
			  &VxdhEvent,
			  2*4,
			  &fReturn,
			  sizeof(fReturn),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(fReturn));
    return fReturn;
}

BOOL __stdcall VxdEventCloseVxdHandle(DWORD VxdhEvent)
{
    BOOL fReturn;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(VxdhEvent);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_EVENTCLOSEVXDHANDLE,
			  &VxdhEvent,
			  1*4,
			  &fReturn,
			  sizeof(fReturn),
			  &cbReturned,
			  NULL);

    if (!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(fReturn));
    return fReturn;
}


//****************************************************************************
//**                                                                        **
//**                                                                        **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdDrvGetNextDriverDesc(LPGUID pGuidPrev, LPGUID pGuid, PDSDRIVERDESC pDrvDesc)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(pGuid && pDrvDesc);

    // If we don't have DSVXD around...
    if (NULL == g_hDsVxd) return DSERR_NODRIVER;
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_DRVGETNEXTDRIVERDESC,
			  &pGuidPrev,
			  3*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

HRESULT __stdcall VxdDrvGetDesc(REFGUID rguid, PDSDRIVERDESC pDrvDesc)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(rguid && pDrvDesc);
    
    // If we don't have DSVXD around...
    if (NULL == g_hDsVxd) return DSERR_NODRIVER;
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_DRVGETDESC,
			  (LPVOID)&rguid,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Open HAL VxD, writing VxD handle to user-supplied HANDLE               **
//**                                                                        **
//** Failure results in a return value of HAL_CANT_OPEN_VXD                 **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdDrvOpen
(
    REFGUID rguid,
    LPHANDLE pHandle
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(rguid && pHandle);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_DRVOPEN,
			  (LPVOID)&rguid,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Close HAL VxD                                                          **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdDrvClose
(
    HANDLE hDriver
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hDriver);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_DRVCLOSE,
			  &hDriver,
			  1*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Fill user-supplied HALCAPS structure with capability and mode list     **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdDrvGetCaps
(
 HANDLE hDriver,
 PDSDRIVERCAPS pDrvCaps
)
{
    HRESULT	    dsv;
    DWORD	    cbReturned;
    BOOL	    fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hDriver && pDrvCaps);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_DRVGETCAPS,
			  &hDriver,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Allocate stream buffer from HAL                                        **
//**                                                                        **
//** Fills a user-supplied stream buffer structure with buffer parameters;  **
//** returns HAL_ALLOC_FAILED if hardware cannot support any more buffers   **
//** or the requested format is unavailable                                 **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdDrvCreateSoundBuffer
(
 HANDLE hDriver,
 LPWAVEFORMATEX pwfx,
 DWORD dwFlags,
 DWORD dwCardAddress,
 LPDWORD pdwcbBufferSize,
 LPBYTE *ppBuffer,
 LPVOID *ppv
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hDriver && pwfx && pdwcbBufferSize && ppBuffer && ppv);

    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
 			  DSVXD_IOCTL_DRVCREATESOUNDBUFFER,
			  &hDriver,
			  7*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

HRESULT __stdcall VxdDrvDuplicateSoundBuffer
(
 HANDLE hDriver,
 HANDLE hBuffer,
 LPVOID *ppv
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hDriver && hBuffer && ppv);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
 			  DSVXD_IOCTL_DRVDUPLICATESOUNDBUFFER,
			  &hDriver,
			  3*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Free stream buffer allocated from HAL                                  **
//**                                                                        **
//** Returns Success or fail                                                **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferRelease
(    
 HANDLE hBuffer
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERRELEASE,
			  &hBuffer,
			  1*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Lock the data                                                          **
//**                                                                        **
//** Returns Success or fail                                                **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferLock
(
 HANDLE hBuffer,
 LPVOID *ppvAudio1,
 LPDWORD pdwLen1,
 LPVOID *ppvAudio2,
 LPDWORD pdwLen2,
 DWORD dwWritePosition,
 DWORD dwWriteLen,
 DWORD dwFlags
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer && ppvAudio1);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERLOCK,
			  &hBuffer,
			  8*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Unlock the data                                                        **
//**                                                                        **
//** Returns Success or fail                                                **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferUnlock
(
 HANDLE hBuffer,  
 LPVOID pvAudio1,
 DWORD dwLen1,
 LPVOID pvAudio2,
 DWORD dwLen2
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer && pvAudio1);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERUNLOCK,
			  &hBuffer,
			  5*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Set buffer format							    **
//**                                                                        **
//** Returns HAL_ERROR on failure, either because the rate/mode combination **
//** is not valid on this card						    **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferSetFormat
(
    HANDLE hBuffer,
    LPWAVEFORMATEX pwfxToSet
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer && pwfxToSet);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERSETFORMAT,
			  &hBuffer,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Set buffer rate							    **
//**                                                                        **
//** Returns HAL_ERROR on failure, because the frequency		    **
//** is not valid on this card						    **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferSetFrequency
(
 HANDLE hBuffer,
 DWORD dwFrequency
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERSETRATE,
			  &hBuffer,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Set new Buffer volume effect					    **
//**                                                                        **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferSetVolumePan
(
 HANDLE hBuffer,
 PDSVOLUMEPAN pDsVolPan
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer && pDsVolPan);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERSETVOLUMEPAN,
			  &hBuffer,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Set new Buffer Position value					    **
//**                                                                        **
//** Returns HAL_ERROR if the device does not support Position changes	    **
//**                                                                        **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferSetPosition
(
 HANDLE hBuffer,
 DWORD dwPosition
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERSETPOSITION,
			  &hBuffer,
			  2*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Get stream buffer cursors and play/stop status                         **
//**                                                                        **
//** Returns HAL_ERROR if status cannot be determined for any reason        **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferGetPosition
(
 HANDLE hBuffer,
 LPDWORD lpdwCurrentPlayCursor,
 LPDWORD lpdwCurrentWriteCursor
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer && lpdwCurrentPlayCursor && lpdwCurrentWriteCursor);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERGETPOSITION,
			  &hBuffer,
			  3*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Start buffer playing						    **
//**                                                                        **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferPlay
(
 HANDLE hBuffer,
 DWORD dwReserved1,
 DWORD dwReserved2,
 DWORD dwFlags
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERPLAY,
			  &hBuffer,
			  4*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}

//****************************************************************************
//**                                                                        **
//** Stop buffer playing						    **
//**                                                                        **
//**                                                                        **
//****************************************************************************

HRESULT __stdcall VxdBufferStop
(
 HANDLE hBuffer
)
{
    HRESULT dsv;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hBuffer);
    
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_BUFFERSTOP,
			  &hBuffer,
			  1*4,
			  &dsv,
			  sizeof(dsv),
			  &cbReturned,
			  NULL);

    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(dsv));
    return dsv;
}


HRESULT __stdcall VxdOpen(void)
{
    ASSERT(!g_hDsVxd);

    g_hDsVxd = CreateFile("\\\\.\\DSOUND.VXD", GENERIC_WRITE, FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE, NULL);

    if(INVALID_HANDLE_VALUE == g_hDsVxd)
    {
        DPF(0, "HEL create file failed");
        g_hDsVxd = NULL;
    }

    return g_hDsVxd ? DS_OK : DSERR_NODRIVER;
}


HRESULT __stdcall VxdClose(void)
{
    ASSERT(g_hDsVxd);

    if(CloseHandle(g_hDsVxd))
    {
        g_hDsVxd = NULL;
    }

    return g_hDsVxd ? DSERR_GENERIC : DS_OK;
}


HRESULT __stdcall VxdInitialize(void)
{
   DWORD	returned;
   BOOL		fOK;
   HRESULT	dsv;

   ASSERT(g_hDsVxd);

   fOK = DeviceIoControl(g_hDsVxd,
			 DSVXD_IOCTL_INITIALIZE,
			 NULL,
			 0,
			 &dsv,
			 sizeof( dsv ),
			 &returned,
			 NULL);
   
   // If DeviceIOControl failed
   if (!fOK) {
      DPF(0, "!DSVXD Initialize DevIOCTL failed " );
      return DSERR_GENERIC;
   }
   if (returned != sizeof(dsv)) {
      DPF(0, "!DSVXD Init returned %X", returned );
      return DSERR_GENERIC;
   }

   return dsv;
}


HRESULT __stdcall VxdShutdown(void)
{
   DWORD	returned;
   BOOL		fOK;
   HRESULT	dsv;

   ASSERT(g_hDsVxd);

   // This is a check to confirm we did not leave any
   // memory pages reserved or committed
   if (0 != g_cCommittedAliases) {
       DPF(0, "Detected committed page leak %d pages!", g_cCommittedAliases);
   }
   if (0 != g_cReservedAliases) {
       DPF(0, "Detected reserved page leak %d pages!", g_cReservedAliases);
   }

   fOK = DeviceIoControl(g_hDsVxd,
			 DSVXD_IOCTL_SHUTDOWN,
			 NULL,
			 0,
			 &dsv,
			 sizeof( dsv ),
			 &returned,
			 NULL);
   
   // If DeviceIOControl failed
   if (!fOK) {
      DPF(0, "!DSVXD Shutdown DevIOCTL failed " );
      return DSERR_GENERIC;
   }
   if (returned != sizeof(dsv)) {
      DPF(0, "!DSVXD Shutdown returned %X", returned );
      return DSERR_GENERIC;
   }
   

   return dsv;
}


void __stdcall VxdGetPagefileVersion(PDWORD pVersion, PDWORD pMaxSize, PDWORD pPagerType)
{
    BOOL fOK;
    DWORD returned = 0;

    if (g_hDsVxd) {
	fOK = DeviceIoControl(g_hDsVxd,
			      DSVXD_IOCTL_PageFile_Get_Version,
			      &pVersion,
			      3*4,
			      NULL,
			      0,
			      &returned,
			      NULL);
    } else {
	fOK = FALSE;
    }

    // If DeviceIOControl failed
    if (!fOK) {
	DPF(0, "DSVXD_IOCTL_PageFile_Get_Version failed" );
	*pVersion = 0;
	*pMaxSize = 0;
	*pPagerType = 0;
    } else {
	ASSERT(returned == 0);
    }

    return;
}


BOOL __stdcall VxdTestDebugInstalled(void)
{
    BOOL fOK;
    DWORD returned = 0;
    BOOL fInstalled;

    if (g_hDsVxd) {
	fOK = DeviceIoControl(g_hDsVxd,
			      DSVXD_IOCTL_VMM_Test_Debug_Installed,
			      NULL,
			      0*4,
			      &fInstalled,
			      sizeof(fInstalled),
			      &returned,
			      NULL);
    } else {
	fOK = FALSE;
    }

    // If DeviceIOControl failed
    if (!fOK) {
	DPF(0, "DSVXD_IOCTL_VMM_Test_Debug_Installed failed " );
	fInstalled = FALSE;
    } else {
	ASSERT(returned == sizeof(fInstalled));
    }

    return fInstalled;
}

//****************************************************************************
//**                                                                        **
//** DSVXD_VMCPD_Get_Version						    **
//**                                                                        **
//****************************************************************************

void __stdcall VxdGetVmcpdVersion(PLONG pMajorVersion, PLONG pMinorVersion, PLONG pLevel)
{
    BOOL fOK;
    DWORD returned = 0;

    if (g_hDsVxd) {
	fOK = DeviceIoControl(g_hDsVxd,
			      DSVXD_IOCTL_VMCPD_Get_Version,
			      &pMajorVersion,
			      3*4,
			      NULL,
			      0,
			      &returned,
			      NULL);
    } else {
	fOK = FALSE;
    }

    // If DeviceIOControl failed
    if (!fOK) {
	DPF(0, "DSVXD_IOCTL_VMCPD_Get_Version failed" );
	*pMajorVersion = 0;
	*pMinorVersion = 0;
	*pLevel = 0;
    } else {
	ASSERT(returned == 0);
    }

    return;
}

//****************************************************************************
//**                                                                        **
//** DSVXD_GetMixerMutexPtr						    **
//**                                                                        **
//****************************************************************************

PLONG __stdcall VxdGetMixerMutexPtr(void)
{
    BOOL fOK;
    PLONG plMixerMutex;
    DWORD returned = 0;

    ASSERT(g_hDsVxd);

    fOK = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_GetMixerMutexPtr,
			  NULL,
			  0*4,
			  &plMixerMutex,
			  sizeof(plMixerMutex),
			  &returned,
			  NULL);

    // If DeviceIOControl failed
    if (!fOK) {
	DPF(0, "!DSVXD_IOCTL_SetMixerMutex failed " );
	plMixerMutex = NULL;
    } else {
	ASSERT(returned == sizeof(plMixerMutex));
    }

    return plMixerMutex;
}





HRESULT __stdcall VxdIUnknown_QueryInterface(HANDLE VxdIUnknown, REFIID riid, LPVOID *ppv)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(VxdIUnknown && riid && ppv);
    
    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_IUnknown_QueryInterface,
			  &VxdIUnknown,
			  3*4,
			  &hr,
			  sizeof(hr),
			  &cbReturned,
			  NULL);
    
    if (!fOk) return DSERR_GENERIC;
    ASSERT(cbReturned == sizeof(hr));
    return hr;
}

ULONG __stdcall VxdIUnknown_AddRef(HANDLE VxdIUnknown)
{
    ULONG result;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(VxdIUnknown);

    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_IUnknown_AddRef,
			  &VxdIUnknown,
			  1*4,
			  &result,
			  sizeof(result),
			  &cbReturned,
			  NULL);

    if (!fOk) return 0;
    ASSERT(cbReturned == sizeof(result));
    return result;
}

ULONG __stdcall VxdIUnknown_Release(HANDLE VxdIUnknown)
{
    ULONG result;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(VxdIUnknown);

    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_IUnknown_Release,
			  &VxdIUnknown,
			  1*4,
			  &result,
			  sizeof(result),
			  &cbReturned,
			  NULL);

    if (!fOk) return 0;
    ASSERT(cbReturned == sizeof(result));
    return result;
}

HRESULT __stdcall VxdIDsDriverPropertySet_GetProperty(HANDLE hIDsDriverPropertySet, PDSPROPERTY pProperty, PVOID pPropertyParams, ULONG cbPropertyParams, PVOID pPropertyData, ULONG cbPropertyData, PULONG pcbReturnedData)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hIDsDriverPropertySet);

    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_IDirectSoundPropertySet_GetProperty,
			  &hIDsDriverPropertySet,
			  7*4,
			  &hr,
			  sizeof(hr),
			  &cbReturned,
			  NULL);

    if (!fOk) return E_NOTIMPL;
    ASSERT(cbReturned == sizeof(hr));
    return hr;
}

HRESULT __stdcall VxdIDsDriverPropertySet_SetProperty(HANDLE hIDsDriverPropertySet, PDSPROPERTY pProperty, PVOID pPropertyParams, ULONG cbPropertyParams, PVOID pPropertyData, ULONG cbPropertyData)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hIDsDriverPropertySet);

    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_IDirectSoundPropertySet_SetProperty,
			  &hIDsDriverPropertySet,
			  6*4,
			  &hr,
			  sizeof(hr),
			  &cbReturned,
			  NULL);

    if (!fOk) return E_NOTIMPL;
    ASSERT(cbReturned == sizeof(hr));
    return hr;
}

HRESULT __stdcall VxdIDsDriverPropertySet_QuerySupport(HANDLE hIDsDriverPropertySet, REFGUID PropertySet, ULONG PropertyId, PULONG pSupport)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    ASSERT(g_hDsVxd);
    ASSERT(hIDsDriverPropertySet);

    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
			  DSVXD_IOCTL_IDirectSoundPropertySet_QuerySupport,
			  &hIDsDriverPropertySet,
			  4*4,
			  &hr,
			  sizeof(hr),
			  &cbReturned,
			  NULL);

    if (!fOk) return E_NOTIMPL;
    ASSERT(cbReturned == sizeof(hr));
    return hr;
}

DWORD __stdcall VxdGetInternalVersionNumber(void)
{
    DWORD cbReturned;
    BOOL fOk;
    DWORD dwVersion;

    ASSERT(g_hDsVxd);

    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_GetInternalVersionNumber,
                          NULL,
                          0*4,
                          &dwVersion,
                          sizeof(dwVersion),
                          &cbReturned,
                          NULL);
    
    if(!fOk) return FALSE;
    ASSERT(cbReturned == sizeof(dwVersion));
    return dwVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dssink.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dssink.h
 *  Content:    DirectSoundSink object declaration.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  09/17/99    jimge   Created
 *  09/27/99    petchey Continued implementation
 *  04/15/00    duganp  Completed implementation
 *
 ***************************************************************************/

#ifndef __DSSINK_H__
#define __DSSINK_H__

#ifdef DEBUG
// #define DEBUG_SINK
// DEBUG_SINK turns on a series of trace statements that are useful
// for figuring out nasty bugs with multiple buffers and buses.
// CAUTION - this code may need some fixing to work right.
#endif

#define DSSINK_NULLBUSID        0xFFFFFFFF  // [MISSING]
#define BUSID_BLOCK_SIZE        16          // Must be power of 2
#define SOURCES_BLOCK_SIZE      8           // Must be power of 2
#define MAX_BUSIDS_PER_BUFFER   32          // [MISSING]

// Note: these "configuration values" should probably all be in one file.
#define STREAMING_MIN_PERIOD    3
#define STREAMING_MAX_PERIOD    50
#define SINK_MIN_LATENCY        5
#define SINK_MAX_LATENCY        500
#define SINK_INITIAL_LATENCY    80          // Initial writeahead for the sink in ms
#define EMULATION_LATENCY_BOOST 100         // How many ms to add if under emulation. FIXME: should fix our internal GetPosition instead

// Note: when the timing algorithms for effects and the sink are integrated,
// SINK_INITIAL_LATENCY and INITIAL_WRITEAHEAD should be integrated too.

typedef LONGLONG STIME;  // Time value, in samples

#ifdef __cplusplus

//
// CDirectSoundSink
//

class CDirectSoundSink : public CUnknown
{
    friend class CDirectSoundAdministrator;
    friend class CDirectSoundClock;
    friend class CImpSinkKsControl;  // Our property handler object

    class DSSinkBuffers
    {
    public:
        CDirectSoundSecondaryBuffer *m_pDSBuffer;
        BOOL    m_bActive;
        BOOL    m_bPlaying;
        BOOL    m_bUsingLocalMemory;
        DWORD   m_dwBusCount;
        DWORD   m_dwWriteOffset;
        DWORD   m_pdwBusIndex[MAX_BUSIDS_PER_BUFFER];
        DWORD   m_pdwBusIds[MAX_BUSIDS_PER_BUFFER];
        DWORD   m_pdwFuncIds[MAX_BUSIDS_PER_BUFFER];
        LONG    m_lPitchBend;  // Used to keep track of pitch shift to send to synth
        LPVOID  m_pvBussStart[MAX_BUSIDS_PER_BUFFER];
        LPVOID  m_pvBussEnd[MAX_BUSIDS_PER_BUFFER];
        LPVOID  m_pvDSBufStart;
        LPVOID  m_pvDSBufEnd;
        DWORD   dwStart;
        DWORD   dwEnd;
        DSSinkBuffers()
        {
            for (DWORD l = 0; l < MAX_BUSIDS_PER_BUFFER; l++)
            {
                m_pdwBusIndex[l] = DSSINK_NULLBUSID;
                m_pdwBusIds[l]   = DSSINK_NULLBUSID;
                m_pdwFuncIds[l]  = DSSINK_NULLBUSID;
                m_pvBussStart[l] = NULL;
                m_pvBussEnd[l]   = NULL;
            }
        };
        HRESULT Initialize(DWORD dwBusBufferSize);
    };

    class DSSinkSources
    {
    public:
        DWORD               m_bStreamEnd;   // The end of the stream has been rearched on this stream
        IDirectSoundSource *m_pDSSource;    // External source
#ifdef FUTURE_WAVE_SUPPORT
        IDirectSoundWave   *m_pWave;        // Wave object associated with this source, note: this is only used to id the wave
#endif
        STIME               m_stStartTime;  // Sample time to play source, this is used to offset a wave source into the current synth time
        DWORD               m_dwBusID;      // BusID associated with this source
        DWORD               m_dwBusCount;   // how many buses are associated with this source
        DWORD               m_dwBusIndex;   // Index in to the BusID's array associated with this source
        DSSinkSources() {m_dwBusID = m_dwBusIndex = DSSINK_NULLBUSID;}  // The rest is initialized to 0 by our MemAlloc
    };

    // "Growable array" helper classes: DSSinkArray, DSSinkBuffersArray, DSSinkSourceArray
    
    struct DSSinkArray
    {
        DSSinkArray(LPVOID pvarray, DWORD itemsize)
        {
            m_pvarray  = pvarray;
            m_itemsize = itemsize;
        };
        virtual LPVOID Grow(DWORD newsize);

    protected:
        LPVOID m_pvarray;
        DWORD  m_numitems;
        DWORD  m_itemsize;
    };

    struct DSSinkBuffersArray : DSSinkArray
    {
        DSSinkBuffersArray(LPVOID pvarray, DWORD itemsize) : DSSinkArray(pvarray, itemsize)
        {
            m_pvarray  = pvarray;
            m_itemsize = itemsize;
        };
        virtual PVOID Grow(DWORD newsize);
    };

    struct DSSinkSourceArray : DSSinkArray
    {
        DSSinkSourceArray(LPVOID pvarray, DWORD itemsize) : DSSinkArray(pvarray, itemsize)
        {
            m_pvarray  = pvarray;
            m_itemsize = itemsize;
        };
        virtual PVOID Grow(DWORD newsize);
    };

    enum
    {
        i_m_pdwBusIDs,
        i_m_pdwFuncIDs,
        i_m_plPitchBends,
        i_m_pdwActiveBusIDs,
        i_m_pdwActiveFuncIDs,
        i_m_pdwActiveBusIDsMap,
        i_m_ppDSSBuffers,
        i_m_ppvStart,
        i_m_ppvEnd,
        i_m_pDSSources,
        NUM_INTERNAL_ARRAYS
    };

    DSSinkArray* m_InternalArrayList[NUM_INTERNAL_ARRAYS];
    HRESULT GrowBusArrays(DWORD dwnewsize);
    HRESULT GrowSourcesArrays(DWORD dwnewsize);
    HRESULT AddBuffer(CDirectSoundBuffer *pIDirectSoundBuffer, LPDWORD pdwnewFuncIDs, DWORD dwnewFuncCount, DWORD dwnewBusIDsCount);
public:
    HRESULT RemoveBuffer(CDirectSoundBuffer *pIDirectSoundBuffer);  // Exposed for CDirectSoundSecondaryBuffer
private:
    HRESULT HandleLatency(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandlePeriod(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    void UpdatePitchArray();

    WAVEFORMATEX            m_wfx;              // Wave format of all our buffers
    DWORD                   m_dwBusSize;        // Size in ms of all our buffers
    IReferenceClock        *m_pIMasterClock;    // Master clock set by our user
    CDirectSoundClock       m_LatencyClock;     // Latency clock we provide to our user
    IDirectSoundSinkSync   *m_pDSSSinkSync;     // Interface we obtain from m_pIMasterClock and use to set clock offsets
    CSampleClock            m_SampleClock;      // Used to synchronize timing with master clock
    DWORD                   m_dwLatency;        // Current latency setting
    BOOL                    m_fActive;          // Whether sink is active
    REFERENCE_TIME          m_rtSavedTime;      // Reftime for current processing pass
    DWORD                   m_dwNextBusID;      // What is the current bus id value
    DWORD                   m_dwBusIDsAlloc;    // Number of allocated bus slots
    DWORD                   m_dwBusIDs;         // Number of active buses
    LPDWORD                 m_pdwBusIDs;        // Bus IDs
    LPDWORD                 m_pdwFuncIDs;       // Function IDs
    LPLONG                  m_plPitchBends;     // Pitch offsets
    LPVOID                 *m_ppvStart;         // Locked region[0] during render
    LPVOID                 *m_ppvEnd;           // Locked region[1] during render
    LPDWORD                 m_pdwActiveBusIDs;  // [MISSING]
    LPDWORD                 m_pdwActiveFuncIDs; // [MISSING]
    LPDWORD                 m_pdwActiveBusIDsMap;// [MISSING]
    DWORD                   m_dwLatencyTotal;   // [MISSING]
    DWORD                   m_dwLatencyCount;   // [MISSING]
    DWORD                   m_dwLatencyAverage; // [MISSING]
    DWORD                   m_dwDSSBufCount;    // Number of dsound buffers managed by the sink
    DSSinkBuffers          *m_ppDSSBuffers;     // Dsound buffers managed by the sink
    DWORD                   m_dwDSSourcesAlloc; // Number of allocated source slots
    DWORD                   m_dwDSSources;      // Number of active sources
    DSSinkSources          *m_pDSSources;       // External source

#ifdef DEBUG_SINK
    DWORD m_dwPrintNow;
    char m_szDbgDump[300];
#endif

    CStreamingThread       *m_pStreamingThread; // Our managing streaming thread
    CDirectSound           *m_pDirectSound;     // Parent DirectSound object
    CImpSinkKsControl      *m_pImpKsControl;    // IKsControl interface handler
    CImpDirectSoundSink<CDirectSoundSink> *m_pImpDirectSoundSink;  // Other COM interfaces handler

    LONGLONG                m_llAbsWrite;       // Absolute point we've written up to
    LONGLONG                m_llAbsPlay;        // Absolute point where play head is
    DWORD                   m_dwLastPlay;       // Point in buffer where play head is
    DWORD                   m_dwLastWrite;      // Last position we wrote to in buffer
    DWORD                   m_dwWriteTo;        // Distance between write head and where we are writing.
    DWORD                   m_dwLastCursorDelta;// The last used distance between the play and write cursors
    DWORD                   m_dwMasterBuffChannels; // Number of channels of the Master Buffer
    DWORD                   m_dwMasterBuffSize; // Size of the Master buffer

    // Conversion helpers - ALL THESE ASSUME A 16-BIT WAVE FORMAT
    LONGLONG SampleToByte(LONGLONG llSamples) {return llSamples << m_dwMasterBuffChannels;}
    DWORD SampleToByte(DWORD dwSamples)       {return dwSamples << m_dwMasterBuffChannels;}
    LONGLONG ByteToSample(LONGLONG llBytes)   {return llBytes   >> m_dwMasterBuffChannels;}
    DWORD ByteToSample(DWORD dwBytes)         {return dwBytes   >> m_dwMasterBuffChannels;}
    LONGLONG SampleAlign(LONGLONG llBytes)    {return SampleToByte(ByteToSample(llBytes));}
    DWORD SampleAlign(DWORD dwBytes)          {return SampleToByte(ByteToSample(dwBytes));}

public:
    CDirectSoundSink(CDirectSound *);
    ~CDirectSoundSink();

    HRESULT Render(STIME stStartTime, DWORD dwLastWrite, DWORD dwBytesToFill, LPDWORD pdwBytesRendered);
    HRESULT RenderSilence(DWORD dwLastWrite, DWORD dwBytesToFill);
    HRESULT SyncSink(LPDWORD pdwPlayCursor, LPDWORD pdwWriteFromCursor, LPDWORD pdwCursorDelta);
    HRESULT ProcessSink();
    HRESULT SetBufferState(CDirectSoundBuffer *pCdsb, DWORD dwNewState, DWORD dwOldState);
    HRESULT Initialize(LPWAVEFORMATEX pwfex, VADDEVICETYPE vdtDeviceType);
    HRESULT AddSource(IDirectSoundSource *pSource);
    HRESULT RemoveSource(IDirectSoundSource *pSource);
    HRESULT SetMasterClock(IReferenceClock *pClock);
    HRESULT GetLatencyClock(IReferenceClock **ppClock);
    HRESULT Activate(BOOL fEnable);
    HRESULT SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prt);
    HRESULT RefToSampleTime(REFERENCE_TIME rt, LONGLONG *pllSampleTime);
    HRESULT GetFormat(LPWAVEFORMATEX, LPDWORD);
    HRESULT CreateSoundBuffer(LPCDSBUFFERDESC pDSBufferDesc, LPDWORD pdwBusIDs, DWORD dwBusCount, REFGUID guidBufferID, CDirectSoundBuffer **ppIDirectSoundBuffer);
    HRESULT CreateSoundBufferFromConfig(IUnknown *pIUnkDSBufferDesc, CDirectSoundBuffer **ppIDirectSoundBuffer);
    HRESULT GetBusCount(LPDWORD pdwCount);
    HRESULT GetSoundBuffer(DWORD dwBusId, CDirectSoundBuffer **ppCdsb);
    HRESULT GetBusIDs(LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, DWORD dwBusCount);
    HRESULT GetSoundBufferBusIDs(CDirectSoundBuffer *ppIDirectSoundBuffer, LPDWORD pdwBusIDs, LPDWORD pdwFuncIDs, LPDWORD pdwBusCount);
    HRESULT GetFunctionalID(DWORD dwBusID, LPDWORD pdwFuncID);
    HRESULT SetBufferFrequency(CSecondaryRenderWaveBuffer *pBuffer, DWORD dwFrequency);
#ifdef FUTURE_WAVE_SUPPORT
    HRESULT CreateSoundBufferFromWave(IDirectSoundWave *pWave, DWORD dwFlags, CDirectSoundBuffer **ppIdsb);
#endif
    CDirectSoundSecondaryBuffer* FindBufferFromGUID(REFGUID guidBufferID);
    REFERENCE_TIME GetSavedTime() {ASSERT(m_rtSavedTime); return m_rtSavedTime;}
};

//
// CImpSinkKsControl: CDirectSoundSink's property handler object
//

#define SINKPROP_F_STATIC       0x00000001
#define SINKPROP_F_FNHANDLER    0x00000002

typedef HRESULT (CImpSinkKsControl::*SINKPROPHANDLER)(ULONG ulId, BOOL fSet, LPVOID pvPropertyData, PULONG pcbPropertyData);

struct SINKPROPERTY
{
    const GUID *pguidPropertySet;       // Which property set?
    ULONG       ulId;                   // Which property?
    ULONG       ulSupported;            // Get/Set flags for QuerySupported
    ULONG       ulFlags;                // SINKPROP_F_xxx
    LPVOID      pPropertyData;          // The property data buffer...
    ULONG       cbPropertyData;         // ...and its size
    SINKPROPHANDLER pfnHandler;         // Handler function if SINKPROP_F_FNHANDLER
};

class CImpSinkKsControl : public IKsControl, public CImpUnknown
{
public:
    CImpSinkKsControl(CUnknown *, CDirectSoundSink*);

private:
    HRESULT HandleLatency(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    HRESULT HandlePeriod(ULONG ulId, BOOL fSet, LPVOID pbBuffer, PULONG pcbBuffer);
    CDirectSoundSink *m_pDSSink;

    SINKPROPERTY m_aProperty[2];
    int m_nProperty;
    SINKPROPERTY *FindPropertyItem(REFGUID rguid, ULONG ulId);

public:
    IMPLEMENT_IUNKNOWN();

// IKsControl methods
public:
    virtual STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    virtual STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );

    virtual STDMETHODIMP KsEvent(
        IN PKSEVENT Event,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT PULONG BytesReturned
    );
};

#endif // __cplusplus

#endif // __DSSINK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dsvxdhlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dsvxdhlp.h
 *  Content:    DSOUND.VXD wrappers.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  3/7/95      John Miles (Miles Design, Incorporated)
 *  2/3/97      dereks  Ported to DX5
 *
 ***************************************************************************/

#ifndef __DSVXDHLP_H__
#define __DSVXDHLP_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern HANDLE g_hDsVxd;

extern HRESULT __stdcall VxdOpen(void);
extern HRESULT __stdcall VxdInitialize(void);
extern HRESULT __stdcall VxdShutdown(void);
extern HRESULT __stdcall VxdClose(void);

extern HRESULT __stdcall VxdDrvGetNextDriverDesc(LPGUID, LPGUID, PDSDRIVERDESC);
extern HRESULT __stdcall VxdDrvGetDesc(REFGUID, PDSDRIVERDESC);
extern HRESULT __stdcall VxdDrvOpen(REFGUID, LPHANDLE);
extern HRESULT __stdcall VxdDrvClose(HANDLE);
extern HRESULT __stdcall VxdDrvQueryInterface(HANDLE, REFIID, LPVOID *);
extern HRESULT __stdcall VxdDrvGetCaps(HANDLE, PDSDRIVERCAPS);
extern HRESULT __stdcall VxdDrvCreateSoundBuffer(HANDLE, LPWAVEFORMATEX, DWORD, DWORD, LPDWORD, LPBYTE *, LPVOID *);
extern HRESULT __stdcall VxdDrvDuplicateSoundBuffer(HANDLE, HANDLE, LPVOID *);

extern HRESULT __stdcall VxdBufferRelease(HANDLE);
extern HRESULT __stdcall VxdBufferLock(HANDLE, LPVOID *,LPDWORD, LPVOID *, LPDWORD, DWORD, DWORD, DWORD);
extern HRESULT __stdcall VxdBufferUnlock(HANDLE, LPVOID, DWORD, LPVOID, DWORD);
extern HRESULT __stdcall VxdBufferSetFormat(HANDLE, LPWAVEFORMATEX);
extern HRESULT __stdcall VxdBufferSetFrequency(HANDLE, DWORD);
extern HRESULT __stdcall VxdBufferSetVolumePan(HANDLE, PDSVOLUMEPAN);
extern HRESULT __stdcall VxdBufferSetPosition(HANDLE, DWORD);
extern HRESULT __stdcall VxdBufferGetPosition(HANDLE, LPDWORD, LPDWORD);
extern HRESULT __stdcall VxdBufferPlay(HANDLE, DWORD, DWORD, DWORD);
extern HRESULT __stdcall VxdBufferStop(HANDLE);

extern BOOL __stdcall VxdEventScheduleWin32Event(DWORD, DWORD);
extern BOOL __stdcall VxdEventCloseVxdHandle(DWORD);

extern LPVOID __stdcall VxdMemReserveAlias(LPVOID, DWORD);
extern BOOL __stdcall VxdMemCommitAlias(LPVOID, LPVOID, DWORD);
extern BOOL __stdcall VxdMemRedirectAlias(LPVOID, DWORD);
extern BOOL __stdcall VxdMemDecommitAlias(LPVOID, DWORD);
extern BOOL __stdcall VxdMemFreeAlias(LPVOID, DWORD);

extern BOOL __stdcall VxdTestDebugInstalled(void);
extern void __stdcall VxdGetPagefileVersion(LPDWORD, LPDWORD, LPDWORD);
extern void __stdcall VxdGetVmcpdVersion(LPLONG, LPLONG, LPLONG);
extern LPLONG __stdcall VxdGetMixerMutexPtr(void);

extern HRESULT __stdcall VxdIUnknown_QueryInterface(HANDLE, REFIID, LPVOID *);
extern ULONG __stdcall VxdIUnknown_Release(HANDLE);

HRESULT __stdcall VxdIDsDriverPropertySet_GetProperty(HANDLE, PDSPROPERTY, PVOID, ULONG, PVOID, ULONG, PULONG);
HRESULT __stdcall VxdIDsDriverPropertySet_SetProperty(HANDLE, PDSPROPERTY, PVOID, ULONG, PVOID, ULONG);
HRESULT __stdcall VxdIDsDriverPropertySet_QuerySupport(HANDLE, REFGUID, ULONG, PULONG);

extern DWORD __stdcall VxdGetInternalVersionNumber(void);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DSVXDHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dxcrt.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dxcrt.c
 *  Content:    Miscelaneous floating point calls
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/31/96    jstokes  Created
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <math.h>

#define LOGE_2_INV 1.44269504088896  // 1/log_e(2)

double _stdcall pow2(double x)
{
    double dvalue;
    
#ifdef USE_INLINE_ASM_UNUSED // Can only use if |x| <= 1!
    _asm
    {
        fld    x
        f2xm1
        fstp   dvalue
    }
#else
    dvalue = pow(2.0, x);
#endif

    return dvalue;
}

// fylog2x(y, x) = y * log2(x)

double _stdcall fylog2x(double y, double x)
{
    double dvalue;

#ifdef USE_INLINE_ASM
    _asm
    {
        fld    y
        fld    x
        fyl2x
        fstp   dvalue
    }
#else
    dvalue = LOGE_2_INV * y * log(x);
#endif

    return dvalue;
}

#ifdef DEAD_CODE

// fylog2xp1(y, x) = y * log2(x + 1)

double _stdcall fylog2xp1(double y, double x)
{
    double dvalue;

#ifdef USE_INLINE_ASM
    _asm
    {
        fld    y
        fld    x
        fyl2xp1
        fstp   dvalue
    }
#else
    dvalue = LOGE_2_INV * y * log(x+1.0);
#endif

    return dvalue;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dynaload.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dynaload.h
 *  Content:    Dynaload DLL helper functions
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/16/97    dereks  Created.
 *
 ***************************************************************************/

#ifndef __DYNALOAD_H__
#define __DYNALOAD_H__

#ifdef UNICODE
#define UNICODE_FUNCTION_NAME(str) str##"W"
#else // UNICODE
#define UNICODE_FUNCTION_NAME(str) str##"A"
#endif // UNICODE

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Generic DYNALOAD data
typedef struct tagDYNALOAD
{
    DWORD           dwSize;
    HINSTANCE       hInstance;
} DYNALOAD, *LPDYNALOAD;

// DYNALOAD helper functions
extern BOOL InitDynaLoadTable(LPCTSTR, const LPCSTR *, DWORD, LPDYNALOAD);
extern BOOL IsDynaLoadTableInit(LPDYNALOAD);
extern void FreeDynaLoadTable(LPDYNALOAD);
extern BOOL GetProcAddressEx(HINSTANCE, LPCSTR, FARPROC *);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __DYNALOAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\dynaload.c ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dynaload.c
 *  Content:    Dynaload DLL helper functions
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  12/16/97    dereks  Created.
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  InitDynaLoadTable
 *
 *  Description:
 *      Dynamically loads a DLL and initializes it's function table.
 *
 *  Arguments:
 *      LPTSTR [in]: library path.
 *      LPTSTR * [in]: function name array.
 *      DWORD [in]: number of elements in function name array.
 *      LPDYNALOAD [out]: receives initialized dynaload structure.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "InitDynaLoadTable"

BOOL InitDynaLoadTable(LPCTSTR pszLibrary, const LPCSTR *apszFunctions, DWORD cFunctions, LPDYNALOAD pDynaLoad)
{
    BOOL                    fSuccess    = TRUE;
    DWORD                   dwFunction;
    FARPROC *               apfn;
    
    DPF_ENTER();

    ASSERT(sizeof(*pDynaLoad) + (cFunctions * sizeof(FARPROC)) == pDynaLoad->dwSize);
    
    // Initialize the structure
    ZeroMemoryOffset(pDynaLoad, pDynaLoad->dwSize, sizeof(pDynaLoad->dwSize));
 
    // Load the library
    pDynaLoad->hInstance = LoadLibrary(pszLibrary);

    if(!pDynaLoad->hInstance)
    {
        DPF(DPFLVL_ERROR, "Unable to load %s", pszLibrary);
        fSuccess = FALSE;
    }

    // Start loading functions
    for(apfn = (FARPROC *)(pDynaLoad + 1), dwFunction = 0; fSuccess && dwFunction < cFunctions; dwFunction++)
    {
        apfn[dwFunction] = GetProcAddress(pDynaLoad->hInstance, apszFunctions[dwFunction]);

        if(!apfn[dwFunction])
        {
            DPF(DPFLVL_ERROR, "Unable to find %s", apszFunctions[dwFunction]);
            fSuccess = FALSE;
        }
    }

    // Clean up
    if(!fSuccess)
    {
        FreeDynaLoadTable(pDynaLoad);
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/***************************************************************************
 *
 *  IsDynaLoadTableInit
 *
 *  Description:
 *      Determines if a dyna-load table is initialized.
 *
 *  Arguments:
 *      LPDYNALOAD [out]: receives initialized dynaload structure.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsDynaLoadTableInit"

BOOL IsDynaLoadTableInit(LPDYNALOAD pDynaLoad)
{
    BOOL                    fSuccess    = TRUE;
    LPDWORD                 pdw;

    DPF_ENTER();

    for(pdw = (LPDWORD)pDynaLoad + 1; pdw < (LPDWORD)pDynaLoad + (pDynaLoad->dwSize / sizeof(DWORD)); pdw++)
    {
        if(!*pdw)
        {
            fSuccess = FALSE;
        }
    }

    DPF_LEAVE(fSuccess);

    return fSuccess;
}


/***************************************************************************
 *
 *  FreeDynaLoadTable
 *
 *  Description:
 *      Frees resources associated with a dynaload table.
 *
 *  Arguments:
 *      LPDYNALOAD [in]: initialized dynaload structure.
 *
 *  Returns:  
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "FreeDynaLoadTable"

void FreeDynaLoadTable(LPDYNALOAD pDynaLoad)
{
    DPF_ENTER();

    // Free the library
    if(pDynaLoad->hInstance)
    {
        FreeLibrary(pDynaLoad->hInstance);
    }

    // Uninitialize the structure
    ZeroMemoryOffset(pDynaLoad, pDynaLoad->dwSize, sizeof(pDynaLoad->dwSize));

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  GetProcAddressEx
 *
 *  Description:
 *      Gets a pointer to a function within a given library.
 *
 *  Arguments:
 *      HINSTANCE [in]: library instance handle.
 *      LPTSTR [in]: function name.
 *      FARPROC * [out]: receives function pointer.
 *
 *  Returns:  
 *      BOOL: TRUE on success.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "GetProcAddressEx"

BOOL GetProcAddressEx(HINSTANCE hInstance, LPCSTR pszFunction, FARPROC *ppfnFunction)
{
    DPF_ENTER();

    *ppfnFunction = GetProcAddress(hInstance, pszFunction);
    
    DPF_LEAVE(MAKEBOOL(*ppfnFunction));

    return MAKEBOOL(*ppfnFunction);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\effects.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        effects.cpp
 *
 *  Content:     Implementation of the CEffectChain class and the CEffect
 *               class hierarchy (CEffect, CDmoEffect and CSendEffect).
 *
 *  Description: These classes support audio effects and effect sends, a new
 *               feature in DX8.  The CDirectSoundSecondaryBuffer object is
 *               extended with a pointer to an associated CEffectChain,
 *               which in turn manages a list of CEffect-derived objects.
 *
 *               Almost everything here would fit more logically into the
 *               existing CDirectSoundSecondaryBuffer class, but has been
 *               segregated for ease of maintenance (and because dsbuf.cpp
 *               is complex enough as it is).  So the CEffectChain object
 *               should be understood as a sort of helper object belonging to
 *               CDirectSoundSecondaryBuffer.  In particular, a CEffectChain
 *               object's lifetime is contained by the lifetime of its owning
 *               CDirectSoundSecondaryBuffer, so we can safely fiddle with
 *               this buffer's innards at any time in CEffectChain code.
 *
 *  History:
 *
 * Date      By       Reason
 * ========  =======  ======================================================
 * 08/10/99  duganp   Created
 *
 ***************************************************************************/

#include "dsoundi.h"
#include <uuids.h>   // For MEDIATYPE_Audio, MEDIASUBTYPE_PCM and FORMAT_WaveFormatEx


/***************************************************************************
 *
 *  CEffectChain::CEffectChain
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Pointer to our associated buffer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::CEffectChain"

CEffectChain::CEffectChain(CDirectSoundSecondaryBuffer* pBuffer)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEffectChain);

    // Set up initial values
    m_hrInit        = DSERR_UNINITIALIZED;
    m_pDsBuffer     = pBuffer;
    m_pPreFxBuffer  = pBuffer->GetPreFxBuffer();
    m_pPostFxBuffer = pBuffer->GetPostFxBuffer();
    m_dwBufSize     = pBuffer->GetBufferSize();

    // Keep a pointer to the audio format for convenience
    m_pFormat = pBuffer->Format();

    // Some sanity checking
    ASSERT(m_dwBufSize % m_pFormat->nBlockAlign == 0);
    ASSERT(IS_VALID_WRITE_PTR(m_pPreFxBuffer, m_dwBufSize));
    ASSERT(IS_VALID_WRITE_PTR(m_pPostFxBuffer, m_dwBufSize));

    m_fHasSend = FALSE;

    DPF(DPFLVL_INFO, "Created effect chain with PreFxBuffer=0x%p, PostFxBuffer=0x%p, BufSize=%lu",
        m_pPreFxBuffer, m_pPostFxBuffer, m_dwBufSize);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CEffectChain::~CEffectChain
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::~CEffectChain"

CEffectChain::~CEffectChain(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CEffectChain);

    if (SUCCEEDED(m_hrInit))
        m_pStreamingThread->UnregisterFxChain(this);

    // m_fxList's destructor takes care of releasing our CEffect objects

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CEffectChain::Initialize
 *
 *  Description:
 *      Initializes the chain with the effects requested.
 *
 *  Arguments:
 *      DWORD [in]: Number of effects requested
 *      LPDSEFFECTDESC [in]: Pointer to effect description structures
 *      DWORD* [out]: Receives the effect creation status codes
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::Initialize"

HRESULT CEffectChain::Initialize(DWORD dwFxCount, LPDSEFFECTDESC pFxDesc, LPDWORD pdwResultCodes)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();
    HRESULT hrFirstFailure = DS_OK; // HR for the first FX creation failure

    ASSERT(dwFxCount > 0);
    CHECK_READ_PTR(pFxDesc);

    DMO_MEDIA_TYPE dmt;
    ZeroMemory(&dmt, sizeof dmt);
    dmt.majortype               = MEDIATYPE_Audio;
    dmt.subtype                 = MEDIASUBTYPE_PCM;
    dmt.bFixedSizeSamples       = TRUE;
    dmt.bTemporalCompression    = FALSE;
    dmt.lSampleSize             = m_pFormat->wBitsPerSample == 16 ? 2 : 1;
    dmt.formattype              = FORMAT_WaveFormatEx;
    dmt.cbFormat                = sizeof(WAVEFORMATEX);
    dmt.pbFormat                = PBYTE(m_pFormat);

    for (DWORD i=0; i<dwFxCount; ++i)
    {
        CEffect* pEffect;
        BOOL fIsSend;

        if (pFxDesc[i].guidDSFXClass == GUID_DSFX_SEND /*|| pFxDesc[i].guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE*/)
        {
            fIsSend = TRUE;
#ifdef ENABLE_SENDS
            pEffect = NEW(CSendEffect(pFxDesc[i], m_pDsBuffer));
#endif
        }
        else
        {
            fIsSend = FALSE;
            pEffect = NEW(CDmoEffect(pFxDesc[i]));
        }

#ifndef ENABLE_SENDS
        if (fIsSend)
            hr = DSERR_INVALIDPARAM;
        else
#endif
        hr = HRFROMP(pEffect);

        if (SUCCEEDED(hr))
            hr = pEffect->Initialize(&dmt);

        if (SUCCEEDED(hr))
            hr = HRFROMP(m_fxList.AddNodeToList(pEffect));

        if (SUCCEEDED(hr))
        {
            m_fHasSend = m_fHasSend || fIsSend;
            if (pdwResultCodes)
                pdwResultCodes[i] = DSFXR_PRESENT;
        }
        else // We didn't get the effect for some reason.
        {
            if (pdwResultCodes)
                pdwResultCodes[i] = (hr == DSERR_SENDLOOP) ? DSFXR_SENDLOOP : DSFXR_UNKNOWN;
            if (SUCCEEDED(hrFirstFailure))
                hrFirstFailure = hr;
        }

        RELEASE(pEffect);  // It's managed by m_fxList now
    }

    hr = hrFirstFailure;

    if (SUCCEEDED(hr))
        hr = HRFROMP(m_pStreamingThread = GetStreamingThread());

    if (SUCCEEDED(hr))
    {
        m_dwWriteAheadFixme = m_pStreamingThread->GetWriteAhead();
        if (m_pDsBuffer->IsEmulated())
            m_dwWriteAheadFixme += EMULATION_LATENCY_BOOST;
    }

    if (SUCCEEDED(hr))
        hr = PreRollFx();

    if (SUCCEEDED(hr))
        hr = m_pStreamingThread->RegisterFxChain(this);

    // Temporary hack until DX8.1 - FIXME:
    //
    // Get the sink's current WriteAhead value and boost it if we're
    // running in emulation.  This should be handled in the emulator's
    // GetPosition method itself rather than in dssink.cpp/effects.cpp
    //
    // This only works now because the sink doesn't ever change the
    // value returned by GetWriteAhead() - this too will change.

    m_hrInit = hr;
    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::Clone
 *
 *  Description:
 *      Creates a replica of this effect chain object (or should do!).
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::Clone"

HRESULT CEffectChain::Clone(CDirectSoundBufferConfig* pDSBConfigObj)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    CHECK_WRITE_PTR(pDSBConfigObj);

    DMO_MEDIA_TYPE dmt;
    ZeroMemory(&dmt, sizeof dmt);
    dmt.majortype               = MEDIATYPE_Audio;
    dmt.subtype                 = MEDIASUBTYPE_PCM;
    dmt.bFixedSizeSamples       = TRUE;
    dmt.bTemporalCompression    = FALSE;
    dmt.lSampleSize             = m_pFormat->wBitsPerSample == 16 ? 2 : 1;
    dmt.formattype              = FORMAT_WaveFormatEx;
    dmt.cbFormat                = sizeof(WAVEFORMATEX);
    dmt.pbFormat                = PBYTE(m_pFormat);

    CDirectSoundBufferConfig::CDXDMODesc *pDXDMOMap = pDSBConfigObj->m_pDXDMOMapList;
    for (; pDXDMOMap && SUCCEEDED(hr); pDXDMOMap = pDXDMOMap->pNext)
    {
        DSEFFECTDESC effectDesc;
        effectDesc.dwSize = sizeof effectDesc;
        effectDesc.dwFlags = pDXDMOMap->m_dwEffectFlags;
        effectDesc.guidDSFXClass = pDXDMOMap->m_guidDSFXClass;
        effectDesc.dwReserved2 = pDXDMOMap->m_dwReserved;
        effectDesc.dwReserved1 = NULL;

        CEffect* pEffect = NULL;

        // If this is a send effect, map the send buffer GUID to an actual buffer interface pointer
        if (pDXDMOMap->m_guidDSFXClass == GUID_DSFX_SEND
#ifdef ENABLE_I3DL2SOURCE
            || pDXDMOMap->m_guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE
#endif
            )
        {
            CDirectSoundSecondaryBuffer* pSendBuffer = m_pDsBuffer->m_pOwningSink->FindBufferFromGUID(pDXDMOMap->m_guidSendBuffer);
            if (pSendBuffer)
            {
                effectDesc.dwReserved1 = DWORD_PTR(pSendBuffer->m_pImpDirectSoundBuffer);
                if(IsValidEffectDesc(&effectDesc, m_pDsBuffer))
                {
                    CSendEffect* pSendEffect;
                    pSendEffect = NEW(CSendEffect(effectDesc, m_pDsBuffer));
                    pEffect = pSendEffect;
                    hr = HRFROMP(pEffect);
                    if (SUCCEEDED(hr))
                        hr = pEffect->Initialize(&dmt);
                    if (SUCCEEDED(hr))
                    {
                        DSFXSend SendParam;
                        SendParam.lSendLevel = pDXDMOMap->m_lSendLevel;
                        hr = pSendEffect->SetAllParameters(&SendParam);
                    }
                }
                else
                {
                    hr = DSERR_INVALIDPARAM;
                }
            }
            else
            {
                hr = DSERR_BADSENDBUFFERGUID;
            }
        }
        else
        {
            pEffect = NEW(CDmoEffect(effectDesc));
            hr = HRFROMP(pEffect);
            // FIXME: Do we need to validate pEffect as well?
            if (SUCCEEDED(hr))
                hr = pEffect->Clone(pDXDMOMap->m_pMediaObject, &dmt);
        }

        if (SUCCEEDED(hr))
            hr = HRFROMP(m_fxList.AddNodeToList(pEffect));

        if (SUCCEEDED(hr))
        {
            if (pDXDMOMap->m_guidDSFXClass == GUID_DSFX_SEND
#ifdef ENABLE_I3DL2SOURCE
                || pDXDMOMap->m_guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE
#endif
                )
                m_fHasSend = TRUE;
        }

        RELEASE(pEffect);  // It's managed by m_fxList now
    }

    if (SUCCEEDED(hr))
        hr = HRFROMP(m_pStreamingThread = GetStreamingThread());

    // Temp hack - see comment above
    if (SUCCEEDED(hr))
        m_dwWriteAheadFixme = m_pStreamingThread->GetWriteAhead();

    if (SUCCEEDED(hr))
        hr = PreRollFx();

    if (SUCCEEDED(hr))
        hr = m_pStreamingThread->RegisterFxChain(this);

    m_hrInit = hr;
    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::AcquireFxResources
 *
 *  Description:
 *      Allocates each effect to software (host processing) or hardware
 *      (processed by the audio device), according to its creation flags.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *               Will return the partial success code DS_INCOMPLETE if any
 *               effects that didn't obtain resources were marked OPTIONAL.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::AcquireFxResources"

HRESULT CEffectChain::AcquireFxResources(void)
{
    HRESULT hr = DS_OK;
    HRESULT hrTemp;
    DPF_ENTER();

    // FIXME: Don't reacquire resources unnecessarily; only if (we have none / they're suboptimal?)

    // We loop through all the effects, even if some of them fail,
    // in order to return more complete information to the app

    for (CNode<CEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
    {
        hrTemp = pFxNode->m_data->AcquireFxResources();
        if (FAILED(hrTemp))
            hr = hrTemp;
        else if (hrTemp == DS_INCOMPLETE && SUCCEEDED(hr))
            hr = DS_INCOMPLETE;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::GetFxStatus
 *
 *  Description:
 *      Obtains the current effects' resource allocation status codes.
 *
 *  Arguments:
 *      DWORD* [out]: Receives the resource acquisition status codes
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::GetFxStatus"

HRESULT CEffectChain::GetFxStatus(LPDWORD pdwResultCodes)
{
    DPF_ENTER();
    ASSERT(IS_VALID_WRITE_PTR(pdwResultCodes, GetFxCount() * sizeof(DWORD)));

    DWORD n = 0;
    for (CNode<CEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
        pdwResultCodes[n++] = pFxNode->m_data->m_fxStatus;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  CEffectChain::GetEffectInterface
 *
 *  Description:
 *      Searches the effect chain for an effect with a given COM CLSID and
 *      interface IID at a given index; returns a pointer to the interface.
 *
 *  Arguments:
 *      REFGUID [in]: CLSID required, or GUID_All_Objects for any CLSID.
 *      DWORD [in]: Index N of effect desired.  If the first argument was
 *                  GUID_All_Objects, we will return the Nth effect in the
 *                  chain; and if it was a specific CLSID, we return the
 *                  Nth effect with that CLSID.
 *      REFGUID [in]: Interface to query for from the selected effect.
 *      VOID** [out]: Receives a pointer to the requested COM interface.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::GetEffectInterface"

HRESULT CEffectChain::GetEffectInterface(REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID *ppObject)
{
    HRESULT hr = DSERR_OBJECTNOTFOUND;
    DPF_ENTER();

    BOOL fAllObjects = (guidObject == GUID_All_Objects);

    DWORD count = 0;
    for (CNode<CEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
        if (fAllObjects || pFxNode->m_data->m_fxDescriptor.guidDSFXClass == guidObject)
            if (count++ == dwIndex)
                break;

    if (pFxNode)
        hr = pFxNode->m_data->GetInterface(iidInterface, ppObject);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::NotifyState
 *
 *  Description:
 *      Informs this effect chain of a state change in its owning buffer
 *      (from stopped to playing, or vice versa).
 *
 *  Arguments:
 *      DWORD [in]: new buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::NotifyState"

HRESULT CEffectChain::NotifyState(DWORD dwBufferState)
{
    HRESULT hr;
    DPF_ENTER();

    if (dwBufferState & VAD_BUFFERSTATE_STARTED)
        // The buffer has started; schedule FX processing to happen
        // as soon as we return from the current API call
        hr = m_pStreamingThread->WakeUpNow();
    else
        // The buffer has stopped; pre-roll FX at current position
        hr = PreRollFx();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::NotifyRelease
 *
 *  Description:
 *      Informs this effect chain of the release of a MIXIN buffer.  We in
 *      turn traverse our list of effects informing them, so that if one of
 *      them was a send to the MIXIN buffer it can react appropriately.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Departing MIXIN buffer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::NotifyRelease"

void CEffectChain::NotifyRelease(CDirectSoundSecondaryBuffer* pDsBuffer)
{
    DPF_ENTER();

    // Call NotifyRelease() on each effect
    for (CNode<CEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
        pFxNode->m_data->NotifyRelease(pDsBuffer);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CEffectChain::SetInitialSlice
 *
 *  Description:
 *      Auxiliary function used by the streaming thread to establish an
 *      initial processing slice for this effects chain when it starts up.
 *      We try to synchronize with an active buffer we are sending to,
 *      and if none are available we start at our current write cursor.
 *
 *  Arguments:
 *      REFERENCE_TIME [in]: Size of processing slice to be established.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::SetInitialSlice"

void CEffectChain::SetInitialSlice(REFERENCE_TIME rtSliceSize)
{
    DPF_ENTER();

    if (m_pDsBuffer->GetPlayState() == Starting && !m_pDsBuffer->GetBufferType() && m_fHasSend)
    {
        CDirectSoundSecondaryBuffer* pDestBuf;
        CNode<CEffect*>* pFxNode;

        for (pFxNode = m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
            if ((pDestBuf = pFxNode->m_data->GetDestBuffer()) && pDestBuf->IsPlaying())
            {
                // Found an active destination buffer
                DPF_TIMING(DPFLVL_INFO, "Synchronizing send buffer at 0x%p with destination at 0x%p", m_pDsBuffer, pDestBuf);
                m_pDsBuffer->SynchronizeToBuffer(pDestBuf);
                break;
            }

        if (pFxNode == NULL)
        {
            DPF_TIMING(DPFLVL_INFO, "No active destination buffers found for send buffer at 0x%p", m_pDsBuffer);
            m_pDsBuffer->MoveCurrentSlice(RefTimeToBytes(rtSliceSize, m_pFormat));
        }
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CEffectChain::PreRollFx
 *
 *  Description:
 *      Prepare a buffer for future playback by processing effects on
 *      a piece of the buffer starting at a given cursor position.
 *
 *  Arguments:
 *      DWORD [in]: Position at which to begin processing effects
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::PreRollFx"

HRESULT CEffectChain::PreRollFx(DWORD dwPosition)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    DPF_TIMING(DPFLVL_INFO, "dwPosition=%ld (%s%s%sbuffer w/effects at 0x%p)", dwPosition,
               m_pDsBuffer->GetBufferType() & DSBCAPS_MIXIN ? TEXT("MIXIN ") : TEXT(""),
               m_pDsBuffer->GetBufferType() & DSBCAPS_SINKIN ? TEXT("SINKIN ") : TEXT(""),
               !(m_pDsBuffer->GetBufferType() & (DSBCAPS_MIXIN|DSBCAPS_SINKIN)) ? TEXT("regular ") : TEXT(""),
               m_pDsBuffer);

    // First we flush any obsolete FX-processed audio
    m_pDsBuffer->ClearPlayBuffer();

    // It doesn't make sense to preroll effects for MIXIN or SINKIN buffers,
    // because they don't yet have valid data
    if (!m_pDsBuffer->GetBufferType())
    {
        // If called with no arguments (i.e. with the default argument of
        // CURRENT_PLAY_POS), we preroll FX at our current play position
        if (dwPosition == CURRENT_PLAY_POS)
            hr = m_pDsBuffer->GetInternalCursors(&dwPosition, NULL);

        if (SUCCEEDED(hr))
        {
            // Set these up to avoid spurious asserts later
            m_dwLastPlayCursor = m_dwLastWriteCursor = dwPosition;

            // We want to process data up to WriteAhead ms ahead of the cursor
            DWORD dwSliceSize = MsToBytes(m_dwWriteAheadFixme, m_pFormat);
            DWORD dwNewPos = (dwPosition + dwSliceSize) % m_dwBufSize;

            // Set the current processing slice so the streaming thread can take over
            m_pDsBuffer->SetCurrentSlice(dwPosition, dwSliceSize);

            // We don't actually process the FX on buffers with sends, as it would
            // cause a discontinuity when the streaming thread synchronizes them
            // with their destinations; instead, we just copy the dry audio data
            // into the play buffer.  This is what will be heard when we we start
            // playing, until the effects kicks in - there may be be an audible
            // discontinuity if the effects change the sound a lot, but hopefully
            // it'll sound smoother than the .........

// ARGH - perhaps best to go ahead process just the non-send effects here - it
// will probably sound smoother that way.

            if (m_fHasSend)
                CopyMemory(m_pPostFxBuffer, m_pPreFxBuffer, m_dwBufSize);
            else
                hr = ReallyProcessFx(dwPosition, dwNewPos);

            // Schedule FX processing to happen as soon as we return from
            // this API call (if it was a SetPosition() call, we want to
            // start processing as soon as possible)
            m_pStreamingThread->WakeUpNow();
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::UpdateFx
 *
 *  Description:
 *      Informs this effect chain of a change in the audio data in our
 *      associated buffer, so we can update the post-FX data if necessary.
 *
 *  Arguments:
 *      VOID* [in]: Pointer to beginning of modified audio data
 *      DWORD [in]: Number of bytes modified
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::UpdateFx"

HRESULT CEffectChain::UpdateFx(LPVOID pChangedPos, DWORD dwChangedSize)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // FIXME: check whether play/write cursors have overtaken
    // our last write pos here before running

    // Convert the buffer position pointer into an offset
    DWORD dwChangedPos = (DWORD)(PBYTE(pChangedPos) - m_pPreFxBuffer);

    DPF_TIMING(DPFLVL_INFO, "dwChangedPos=%lu dwChangedSize=%lu (%s%s%sbuffer w/effects at 0x%p)", dwChangedPos, dwChangedSize,
               m_pDsBuffer->GetBufferType() & DSBCAPS_MIXIN ? TEXT("MIXIN ") : TEXT(""),
               m_pDsBuffer->GetBufferType() & DSBCAPS_SINKIN ? TEXT("SINKIN ") : TEXT(""),
               !(m_pDsBuffer->GetBufferType() & (DSBCAPS_MIXIN|DSBCAPS_SINKIN)) ? TEXT("regular ") : TEXT(""),
               m_pDsBuffer);

    // Find the last buffer position we have processed effects on
    DWORD dwSliceBegin, dwSliceEnd;
    m_pDsBuffer->GetCurrentSlice(&dwSliceBegin, &dwSliceEnd);

    // Find the buffer's current play position
    DWORD dwPlayCursor;
    m_pDsBuffer->GetInternalCursors(&dwPlayCursor, NULL);

    // If the audio region updated by the application overlaps the region
    // from dwPlayCursor to dwSliceEnd, we re-process FX on the latter
    if (CircularBufferRegionsIntersect(m_dwBufSize, dwChangedPos, dwChangedSize, dwPlayCursor,
                                       DISTANCE(dwPlayCursor, dwSliceEnd, m_dwBufSize)))
    {
        if (!m_fHasSend)
        {
            hr = FxDiscontinuity();
            if (SUCCEEDED(hr))
                hr = ReallyProcessFx(dwPlayCursor, dwSliceEnd);
        }
        else // The effect chain contains at least one send
        {
            hr = FxDiscontinuity();
            if (SUCCEEDED(hr))
                hr = ReallyProcessFx(dwSliceBegin, dwSliceEnd);
        }
            // Here things get a little tricky.  If our buffer isn't playing,
            // we can't preroll FX, because
            // NB: Send buffers need to send to a fixed 'slot', so they
            // can only reprocess the most-recently processed slice:
            // FIXME - unfinished
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::ProcessFx
 *
 *  Description:
 *      Handle FX processing for a specific buffer, dealing with timing,
 *      state changes, etc.  Called from CStreamingThread::ProcessAudio().
 *
 *  Arguments:
 *
 *      REFERENCE_TIME [in]: Size of the current processing slice
 *                           (ignored by regular FX-only buffers)
 *
 *      DWORD [in]: How many ms to stay ahead of the buffer's write cursor
 *                  (ignored by MIXIN/sink buffers and buffers with sends)
 *
 *      LPDWORD [out]: Lets this effect chain ask the streaming thread to
 *                     boost its latency by a few ms if we almost glitch.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::ProcessFx"

HRESULT CEffectChain::ProcessFx(DWORD dwWriteAhead, LPDWORD pdwLatencyBoost)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    ASSERT(dwWriteAhead > 0);
    CHECK_WRITE_PTR(pdwLatencyBoost);

    // Temp hack - FIXME in DX8.1
    if (m_pDsBuffer->IsEmulated())
        dwWriteAhead += EMULATION_LATENCY_BOOST;

    if (m_pDsBuffer->IsPlaying())
    {
        if (m_pDsBuffer->GetBufferType() || m_fHasSend)
        {
            DWORD dwStartPos, dwEndPos;
            m_pDsBuffer->GetCurrentSlice(&dwStartPos, &dwEndPos);

            if (dwStartPos != MAX_DWORD)  // Can happen with sink buffers
                hr = ReallyProcessFx(dwStartPos, dwEndPos);
        }
        else // Keep the old timing around for a while for experimenting:
        {
            // Get the buffer's play and write cursors (as byte offsets)
            DWORD dwPlayCursor, dwWriteCursor;
            hr = m_pDsBuffer->GetInternalCursors(&dwPlayCursor, &dwWriteCursor);

            if (SUCCEEDED(hr))
            {
                // State our assumptions about these cursors, just in case
                ASSERT(LONG(dwPlayCursor)  >= 0 && dwPlayCursor  < m_dwBufSize);
                ASSERT(LONG(dwWriteCursor) >= 0 && dwWriteCursor < m_dwBufSize);

                // Get our most-recently processed slice of audio
                DWORD dwLastPos;
                m_pDsBuffer->GetCurrentSlice(NULL, &dwLastPos);

                // Check whether the write or play cursors have overtaken us
                if (OVERTAKEN(m_dwLastPlayCursor, dwPlayCursor, dwLastPos))
                {
                    DPF(DPFLVL_WARNING, "Glitch detected (play cursor overtook FX cursor)");
                    if (*pdwLatencyBoost < 3) *pdwLatencyBoost = 3;  // FIXME - be cleverer
                }
                else if (OVERTAKEN(m_dwLastWriteCursor, dwWriteCursor, dwLastPos))
                {
                    DPF(DPFLVL_INFO, "Possible glitch detected (write cursor overtook FX cursor)");
                    if (*pdwLatencyBoost < 1) *pdwLatencyBoost = 1;  // FIXME - be cleverer
                }

                // Save the current play and write positions
                m_dwLastPlayCursor = dwPlayCursor;
                m_dwLastWriteCursor = dwWriteCursor;

                // We want to process data up to dwWriteAhead ms ahead of the write cursor
                DWORD dwNewPos = (dwWriteCursor + MsToBytes(dwWriteAhead, m_pFormat)) % m_dwBufSize;

                // Check that we're not writing through the play cursor
                // REMOVED: If we keep (writeahead < buffersize+wakeinterval+padding), this should
                // never happen - and it get false positives when we hit the glitch detection above.
                // if (STRICTLY_CONTAINED(dwLastPos, dwNewPos, dwPlayCursor))
                // {
                //     DPF(DPFLVL_WARNING, "FX processing thread caught up with play cursor at %lu", dwPlayCursor);
                //     dwNewPos = dwPlayCursor;
                // }

                // If we have less than 5 ms of data to process, don't bother
                DWORD dwProcessedBytes = DISTANCE(dwLastPos, dwNewPos, m_dwBufSize);
                if (dwProcessedBytes > MsToBytes(5, m_pFormat))
                {
                    // Do the actual processing
                    hr = ReallyProcessFx(dwLastPos, dwNewPos);

                    // Update the last-processed buffer slice
                    m_pDsBuffer->MoveCurrentSlice(dwProcessedBytes);
                }
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::ReallyProcessFx
 *
 *  Description:
 *      Process effects on a buffer, given the start and end positions of
 *      the audio region to be processed.  Handles wraparounds.
 *
 *  Arguments:
 *      DWORD [in]: Start position, as a byte offset into the buffer.
 *      DWORD [in]: Out position, as a byte offset into the buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::ReallyProcessFx"

HRESULT CEffectChain::ReallyProcessFx(DWORD dwStartPos, DWORD dwEndPos)
{
    HRESULT hr;
    DPF_ENTER();

    ASSERT(LONG(dwStartPos) >= 0 && dwStartPos < m_dwBufSize);
    ASSERT(LONG(dwEndPos) >= 0 && dwEndPos < m_dwBufSize);

    #ifdef DEBUG
    DWORD dwMilliseconds = BytesToMs(DISTANCE(dwStartPos, dwEndPos, m_dwBufSize), m_pFormat);
    if (dwMilliseconds > 2 * m_dwWriteAheadFixme)
        DPF(DPFLVL_WARNING, "Processing %lu ms! (from %lu to %lu, buffersize=%lu, writeahead=%lu ms)",
            dwMilliseconds, dwStartPos, dwEndPos, m_dwBufSize, m_dwWriteAheadFixme);
    #endif

    // If the buffer is SINKIN, get the time from its owning sink's latency clock;
    // the DMOs use this information to implement IMediaParams parameter curves
    REFERENCE_TIME rtTime = 0;
    if (m_pDsBuffer->GetBufferType() & DSBCAPS_SINKIN)
        rtTime = m_pDsBuffer->m_pOwningSink->GetSavedTime();

    if (dwStartPos < dwEndPos)
    {
        hr = ReallyReallyProcessFx(dwStartPos, dwEndPos - dwStartPos, rtTime);
    }
    else // The wraparound case
    {
        DWORD dwFirstChunk = m_dwBufSize - dwStartPos;
        hr = ReallyReallyProcessFx(dwStartPos, dwFirstChunk, rtTime);

        if (SUCCEEDED(hr))
            // Check for end of non-looping buffer
            if (!m_pDsBuffer->GetBufferType() && !(m_pDsBuffer->m_dwStatus & DSBSTATUS_LOOPING))
                DPF_TIMING(DPFLVL_MOREINFO, "Reached end of non-looping buffer");
            else if (dwEndPos != 0)
                hr = ReallyReallyProcessFx(0, dwEndPos, rtTime + BytesToRefTime(dwFirstChunk, m_pFormat), dwFirstChunk);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::ReallyReallyProcessFx
 *
 *  Description:
 *      Directly process effects on a buffer, given the start position and
 *      size of a (non-wrapped) audio region.  This function finally loops
 *      through the DMOs calling Process() on each of them.
 *
 *  Arguments:
 *      DWORD [in]: Start position, as a byte offset into the buffer.
 *      DWORD [in]: Size of region to be processed, in bytes.
 *      REFERENCE_TIME [in]: "Sink latency" time corresponding to the
 *                           first sample in this region.
 *      DWORD [in]: If non-zero, this argument means that we are currently
 *                  handling the second part of a wrapped-around region of
 *                  the buffer, and gives the offset of this second part;
 *                  this information can be used by any send effects in
 *                  the chain to send to the same offset in their target
 *                  buffers.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::ReallyReallyProcessFx"

HRESULT CEffectChain::ReallyReallyProcessFx(DWORD dwOffset, DWORD dwBytes, REFERENCE_TIME rtTime, DWORD dwSendOffset)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    ASSERT(LONG(dwOffset) >= 0);
    ASSERT(LONG(dwBytes) >= 0);
    ASSERT(dwOffset + dwBytes <= m_dwBufSize);

    PBYTE pAudioIn = m_pPreFxBuffer + dwOffset;
    PBYTE pAudioOut = m_pPostFxBuffer + dwOffset;

    // Copy data to the output buffer to process it in-place there
    CopyMemory(pAudioOut, pAudioIn, dwBytes);

    // Call Process() on each effect
    for (CNode<CEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode; pFxNode = pFxNode->m_pNext)
    {
        hr = pFxNode->m_data->Process(dwBytes, pAudioOut, rtTime, dwSendOffset, m_pFormat);
        if (FAILED(hr))
        {
            DPF(DPFLVL_WARNING, "DMO "DPF_GUID_STRING" failed with %s", DPF_GUID_VAL(pFxNode->m_data->m_fxDescriptor.guidDSFXClass), HRESULTtoSTRING(hr));
            break;
        }
    }

    // Commit the fresh data to the device (only important for VxD devices)
    if (SUCCEEDED(hr))
        hr = m_pDsBuffer->CommitToDevice(dwOffset, dwBytes);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffectChain::FxDiscontinuity
 *
 *  Description:
 *      Calls Discontinuity() on each effect of the effect chain.
 *
 *  Arguments:
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffectChain::FxDiscontinuity"

HRESULT CEffectChain::FxDiscontinuity(void)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    DPF_TIMING(DPFLVL_INFO, "Discontinuity on effects chain at 0x%08X", this);

    if (GetCurrentProcessId() != this->GetOwnerProcessId())
        DPF(DPFLVL_MOREINFO, "Bailing out because we're being called from a different process");
    else for (CNode<CEffect*>* pFxNode=m_fxList.GetListHead(); pFxNode && SUCCEEDED(hr); pFxNode = pFxNode->m_pNext)
        pFxNode->m_data->Discontinuity();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CEffect::CEffect
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      DSEFFECTDESC& [in]: Effect description structure.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffect::CEffect"

CEffect::CEffect(DSEFFECTDESC& fxDescriptor)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEffect);

    // Keep local copy of effect description structure
    m_fxDescriptor = fxDescriptor;

    // Initialize defaults
    m_fxStatus = DSFXR_UNALLOCATED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CEffect::AcquireFxResources
 *
 *  Description:
 *      Acquires the hardware or software resources necessary to perform
 *      this effect.  Currently a bit of a no-op, but will come into its
 *      own when we do hardware acceleration of effects.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEffect::AcquireFxResources"

HRESULT CEffect::AcquireFxResources(void)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    if (m_fxStatus == DSFXR_FAILED || m_fxStatus == DSFXR_UNKNOWN)
    {
        hr = DSERR_INVALIDCALL;
    }
    else if (m_fxStatus == DSFXR_UNALLOCATED)
    {
        if (m_fxDescriptor.dwFlags & DSFX_LOCHARDWARE)
        {
            hr = DSERR_INVALIDPARAM;
            m_fxStatus = DSFXR_FAILED;
        }
        else
        {
            m_fxStatus = DSFXR_LOCSOFTWARE;
        }
    }

    // Note: this code is due for resurrection in DX8.1
    //    if (FAILED(hr) && (m_fxDescriptor.dwFlags & DSFX_OPTIONAL))
    //        hr = DS_INCOMPLETE;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CDmoEffect::CDmoEffect
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      DSEFFECTDESC& [in]: Effect description structure.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDmoEffect::CDmoEffect"

CDmoEffect::CDmoEffect(DSEFFECTDESC& fxDescriptor)
    : CEffect(fxDescriptor)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CDmoEffect);

    // Check initial values
    ASSERT(m_pMediaObject == NULL);
    ASSERT(m_pMediaObjectInPlace == NULL);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CDmoEffect::~CDmoEffect
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDmoEffect::~CDmoEffect"

CDmoEffect::~CDmoEffect(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CDmoEffect);

    // During shutdown, if the buffer hasn't been freed, these calls can
    // cause an access violation because the DMO DLL has been unloaded.
    try
    {
        RELEASE(m_pMediaObject);
        RELEASE(m_pMediaObjectInPlace);
    }
    catch (...) {}

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CDmoEffect::Initialize
 *
 *  Description:
 *      Create the DirectX Media Object corresponding to this effect.
 *
 *  Arguments:
 *      DMO_MEDIA_TYPE* [in]: Information (wave format, etc.) used to
 *                            initialize our contained DMO.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDmoEffect::Initialize"

HRESULT CDmoEffect::Initialize(DMO_MEDIA_TYPE* pDmoMediaType)
{
    DPF_ENTER();

    HRESULT hr = CoCreateInstance(m_fxDescriptor.guidDSFXClass, NULL, CLSCTX_INPROC_SERVER, IID_IMediaObject, (void**)&m_pMediaObject);

    if (SUCCEEDED(hr))
    {
        CHECK_COM_INTERFACE(m_pMediaObject);
        hr = m_pMediaObject->QueryInterface(IID_IMediaObjectInPlace, (void**)&m_pMediaObjectInPlace);
        if (SUCCEEDED(hr))
        {
            CHECK_COM_INTERFACE(m_pMediaObjectInPlace);
        }
        else
        {
            ASSERT(m_pMediaObjectInPlace == NULL);
            DPF(DPFLVL_INFO, "Failed to obtain the IMediaObjectInPlace interface on effect "
                DPF_GUID_STRING " (%s)", DPF_GUID_VAL(m_fxDescriptor.guidDSFXClass), HRESULTtoSTRING(hr));
        }

        // Throw away the previous return code - we can live without IMediaObjectInPlace
        hr = m_pMediaObject->SetInputType(0, pDmoMediaType, 0);
        if (SUCCEEDED(hr))
            hr = m_pMediaObject->SetOutputType(0, pDmoMediaType, 0);
    }

    if (FAILED(hr))
    {
        RELEASE(m_pMediaObject);
        RELEASE(m_pMediaObjectInPlace);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CDmoEffect::Clone
 *
 *  Description:
 *      Creates a replica of this DMO effect object (or should do!).
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDmoEffect::Clone"

HRESULT CDmoEffect::Clone(IMediaObject *pMediaObject, DMO_MEDIA_TYPE* pDmoMediaType)
{
    DPF_ENTER();

    IMediaObjectInPlace *pMediaObjectInPlace = NULL;

    HRESULT hr = pMediaObject->QueryInterface(IID_IMediaObjectInPlace, (void**)&pMediaObjectInPlace);
    if (SUCCEEDED(hr))
    {
        CHECK_COM_INTERFACE(pMediaObjectInPlace);
        hr = pMediaObjectInPlace->Clone(&m_pMediaObjectInPlace);
        pMediaObjectInPlace->Release();

        if (SUCCEEDED(hr))
        {
            CHECK_COM_INTERFACE(m_pMediaObjectInPlace);
            hr = m_pMediaObjectInPlace->QueryInterface(IID_IMediaObject, (void**)&m_pMediaObject);
        }
        if (SUCCEEDED(hr))
        {
            CHECK_COM_INTERFACE(m_pMediaObject);
            hr = m_pMediaObject->SetInputType(0, pDmoMediaType, 0);
        }
        if (SUCCEEDED(hr))
        {
            hr = m_pMediaObject->SetOutputType(0, pDmoMediaType, 0);
        }
    }

    if (FAILED(hr))
    {
        RELEASE(m_pMediaObject);
        RELEASE(m_pMediaObjectInPlace);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CDmoEffect::Process
 *
 *  Description:
 *      Actually invoke effect processing on our contained DMO.
 *
 *  Arguments:
 *      DWORD [in]: Number of audio bytes to process.
 *      BYTE* [in, out]: Pointer to start of audio buffer to process.
 *      REFERENCE_TIME [in]: Timestamp of first sample to be processed
 *      DWORD [ignored]: Offset of a wrapped audio region.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CDmoEffect::Process"

HRESULT CDmoEffect::Process(DWORD dwBytes, BYTE *pAudio, REFERENCE_TIME rtTime, DWORD /*ignored*/, LPWAVEFORMATEX pFormat)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // if (m_fxStatus == DSFXR_LOCSOFTWARE) ...
    // FIXME: We may need to handle hardware and software buffers differently here.

    if (m_pMediaObjectInPlace)  // If the DMO provides this interface, use it
    {
        static const int nPeriod = 3;

        // We divide the region to be processed into nPeriod-ms pieces so that the
        // DMO's parameter curve will have a nPeriod-ms update period (manbug 36228)

        DWORD dwStep = MsToBytes(nPeriod, pFormat);
        for (DWORD dwCur = 0; dwCur < dwBytes && SUCCEEDED(hr); dwCur += dwStep)
        {
            if (dwStep > dwBytes - dwCur)
                dwStep = dwBytes - dwCur;

            hr = m_pMediaObjectInPlace->Process(dwStep, pAudio + dwCur, rtTime, DMO_INPLACE_NORMAL);

            rtTime += MsToRefTime(nPeriod);
        }
    }
    else  // FIXME: Support for IMediaObject-only DMOs goes here
    {
        #ifdef DEAD_CODE
        CMediaBuffer mbInput, mbDirectOutput, mbSendOutput;
        DMO_OUTPUT_DATA_BUFFER pOutputBuffers[2] = {{&mbDirectOutput, 0, 0, 0}, {&mbSendOutput, 0, 0, 0}};

        DWORD dwReserved;  // For the ignored return status from ProcessOutput()
        hr = m_pMediaObject->ProcessInput(0, pInput, DMO_INPUT_DATA_BUFFERF_TIME, rtTime, 0);
        if (SUCCEEDED(hr))
            hr = m_pMediaObject->ProcessOutput(0, 2, pOutputBuffers, &dwReserved);
        #endif

        hr = DSERR_GENERIC;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CSendEffect::CSendEffect
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      DSEFFECTDESC& [in]: Effect description structure.
 *      CDirectSoundSecondaryBuffer* [in]: Pointer to our source buffer.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::CSendEffect"

CSendEffect::CSendEffect(DSEFFECTDESC& fxDescriptor, CDirectSoundSecondaryBuffer* pSrcBuffer)
    : CEffect(fxDescriptor)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CSendEffect);

    // Double check we really are a send effect
#ifdef ENABLE_I3DL2SOURCE
    ASSERT(fxDescriptor.guidDSFXClass == GUID_DSFX_SEND || fxDescriptor.guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE);
#else
    ASSERT(fxDescriptor.guidDSFXClass == GUID_DSFX_SEND);
#endif

    // Figure out our destination buffer
    CImpDirectSoundBuffer<CDirectSoundSecondaryBuffer>* pImpBuffer =
        (CImpDirectSoundBuffer<CDirectSoundSecondaryBuffer>*)(fxDescriptor.dwReserved1);
    ASSERT(IS_VALID_IDIRECTSOUNDBUFFER(pImpBuffer));

    CDirectSoundSecondaryBuffer* pDestBuffer = pImpBuffer->m_pObject;
    CHECK_WRITE_PTR(pDestBuffer);

    // Set up the initial send configuration
    m_impDSFXSend.m_pObject = this;
    m_pMixFunction = pSrcBuffer->Format()->wBitsPerSample == 16 ? Mix16bit : Mix8bit;
    m_mixMode = pSrcBuffer->Format()->nChannels == pDestBuffer->Format()->nChannels ? OneToOne : MonoToStereo;
    m_pSrcBuffer = pSrcBuffer;
    m_pDestBuffer = pDestBuffer;
    m_lSendLevel = DSBVOLUME_MAX;
    m_dwAmpFactor = 0xffff;

#ifdef ENABLE_I3DL2SOURCE
    ASSERT(m_pI3DL2SrcDMO == NULL);
    ASSERT(m_pI3DL2SrcDMOInPlace == NULL);
#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CSendEffect::~CSendEffect
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::~CSendEffect"

CSendEffect::~CSendEffect()
{
    DPF_ENTER();
    DPF_DESTRUCT(CSendEffect);

    // Unregister in our destination buffer's list of senders
    // (as long as the buffer hasn't been released already)
    if (m_pDestBuffer)
        m_pDestBuffer->UnregisterSender(m_pSrcBuffer);

#ifdef ENABLE_I3DL2SOURCE
    // During shutdown, if the buffer hasn't been freed, these calls can
    // cause an access violation because the DMO DLL has been unloaded.
    try
    {
        RELEASE(m_pI3DL2SrcDMO);
        RELEASE(m_pI3DL2SrcDMOInPlace);
    }
    catch (...) {}
#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CSendEffect::Initialize
 *
 *  Description:
 *      Initializes the send effect object.
 *
 *  Arguments:
 *      DMO_MEDIA_TYPE* [in]: Wave format etc. information used to initialize
 *                            our contained I3DL2 source DMO, if we have one.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::Initialize"

HRESULT CSendEffect::Initialize(DMO_MEDIA_TYPE* pDmoMediaType)
{
    DPF_ENTER();

    // First we need to detect any send loops
    HRESULT hr = m_pSrcBuffer->FindSendLoop(m_pDestBuffer);

#ifdef ENABLE_I3DL2SOURCE
    if (SUCCEEDED(hr) && m_fxDescriptor.guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE)
    {
        hr = CoCreateInstance(GUID_DSFX_STANDARD_I3DL2SOURCE, NULL, CLSCTX_INPROC_SERVER, IID_IMediaObject, (void**)&m_pI3DL2SrcDMO);
        if (SUCCEEDED(hr))
        {
            CHECK_COM_INTERFACE(m_pI3DL2SrcDMO);
            hr = m_pI3DL2SrcDMO->QueryInterface(IID_IMediaObjectInPlace, (void**)&m_pI3DL2SrcDMOInPlace);
            if (SUCCEEDED(hr))
                CHECK_COM_INTERFACE(m_pI3DL2SrcDMOInPlace);
            else
                DPF(DPFLVL_WARNING, "Failed to obtain the IMediaObjectInPlace interface on the STANDARD_I3DL2SOURCE effect");

            // Throw away the return code - we can live without IMediaObjectInPlace

            // FIXME: maybe this will change when we restrict I3DL2 to mono buffers
            // and/or change the way the I3DL2 DMO returns two output streams.

            // If we have a mono buffer, special-case the I3DL2 DMO to use stereo
            BOOL fTweakedMediaType = FALSE;
            LPWAVEFORMATEX pFormat = LPWAVEFORMATEX(pDmoMediaType->pbFormat);
            if (pFormat->nChannels == 1)
            {
                fTweakedMediaType = TRUE;
                pFormat->nChannels = 2;
                pFormat->nBlockAlign *= 2;
                pFormat->nAvgBytesPerSec *= 2;
            }

            // Finally set up the (possibly tweaked) media type on the DMO
            hr = m_pI3DL2SrcDMO->SetInputType(0, pDmoMediaType, 0);
            if (SUCCEEDED(hr))
                hr = m_pI3DL2SrcDMO->SetOutputType(0, pDmoMediaType, 0);

            // Undo changes to the wave format if necessary
            if (fTweakedMediaType)
            {
                pFormat->nChannels = 1;
                pFormat->nBlockAlign /= 2;
                pFormat->nAvgBytesPerSec /= 2;
            }

            if (SUCCEEDED(hr))
            {
                // OK, we now need to hook-up the reverb source to its environment.
                // There is a special interface on the I3DL2SourceDMO just for this.

                LPDIRECTSOUNDFXI3DL2SOURCEENV pSrcEnv = NULL;
                LPDIRECTSOUNDFXI3DL2REVERB pEnvReverb = NULL;

                HRESULT hrTemp = m_pI3DL2SrcDMO->QueryInterface(IID_IDirectSoundFXI3DL2SourceEnv, (void**)&pSrcEnv);
                if (SUCCEEDED(hrTemp))
                {
                    CHECK_COM_INTERFACE(pSrcEnv);
                    hrTemp = m_pDestBuffer->GetObjectInPath(GUID_DSFX_STANDARD_I3DL2REVERB, 0, IID_IDirectSoundFXI3DL2Reverb, (void**)&pEnvReverb);
                }

                if (SUCCEEDED(hrTemp))
                {
                    CHECK_COM_INTERFACE(pEnvReverb);
                    hrTemp = pSrcEnv->SetEnvironmentReverb(pEnvReverb);
                }

                if (SUCCEEDED(hrTemp))
                    DPF(DPFLVL_INFO, "Connected the I3DL2 source to its environment successfully");

                // We're done with these interfaces.  The lifetime of the two buffers is managed
                // by DirectSound.  It will handle releasing the destination buffer.  We do not
                // hold a reference to it, and neither does the I3DL2 Source DMO.
                RELEASE(pSrcEnv);
                RELEASE(pEnvReverb);
            }
        }

        if (FAILED(hr))
        {
            RELEASE(m_pI3DL2SrcDMO);
            RELEASE(m_pI3DL2SrcDMOInPlace);
        }
    }
#endif

    // Register in our destination buffer's list of senders
    if (SUCCEEDED(hr))
        m_pDestBuffer->RegisterSender(m_pSrcBuffer);

    // Save the effect creation status for future reference
    m_fxStatus = SUCCEEDED(hr)              ? DSFXR_UNALLOCATED :
                 hr == REGDB_E_CLASSNOTREG  ? DSFXR_UNKNOWN     :
                 DSFXR_FAILED;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CSendEffect::Clone
 *
 *  Description:
 *      Creates a replica of this send effect object (or should do!).
 *
 *  Arguments:
 *      [MISSING]
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::Clone"

HRESULT CSendEffect::Clone(IMediaObject*, DMO_MEDIA_TYPE*)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // FIXME: todo - some code currently in CEffectChain::Clone() should move here.

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CSendEffect::CImpDirectSoundFXSend::QueryInterface
 *
 *  Description:
 *      Helper QueryInterface() method for our IDirectSoundFXSend interface.
 *
 *  Arguments:
 *      REFIID [in]: IID of interface desired.
 *      VOID** [out]: Receives pointer to COM interface.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::CImpDirectSoundFXSend::QueryInterface"

HRESULT CSendEffect::CImpDirectSoundFXSend::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr = E_NOINTERFACE;
    DPF_ENTER();

    // This should really be handled by our glorious COM interface manager, but... ;-)

    if (!IS_VALID_TYPED_WRITE_PTR(ppvObj))
    {
        RPF(DPFLVL_ERROR, "Invalid interface ID pointer");
        hr = E_INVALIDARG;
    }
#ifdef ENABLE_I3DL2SOURCE
    else if (m_pObject->m_pI3DL2SrcDMO)  // We are an I3DL2 Source - pass call to the DMO
    {
        DPF(DPFLVL_INFO, "Forwarding QueryInterface() call to the I3DL2 Source DMO");
        hr = m_pObject->m_pI3DL2SrcDMO->QueryInterface(riid, ppvObj);
    }
#endif
    else if (riid == IID_IUnknown)
    {
        *ppvObj = (IUnknown*)this;
        m_pObject->AddRef();
        hr = S_OK;
    }
    else if (riid == IID_IDirectSoundFXSend)
    {
        *ppvObj = (IDirectSoundFXSend*)this;
        m_pObject->AddRef();
        hr = S_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CSendEffect::SetAllParameters
 *
 *  Description:
 *      Sets all our parameters - i.e., our send level.
 *
 *  Arguments:
 *      DSFXSend* [in]: Pointer to send parameter structure.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::SetAllParameters"

HRESULT CSendEffect::SetAllParameters(LPCDSFXSend pcDsFxSend)
{
    HRESULT hr;
    DPF_ENTER();

    if (!IS_VALID_TYPED_READ_PTR(pcDsFxSend))
    {
        RPF(DPFLVL_ERROR, "Invalid pcDsFxSend pointer");
        hr = DSERR_INVALIDPARAM;
    }
    else if (pcDsFxSend->lSendLevel < DSBVOLUME_MIN || pcDsFxSend->lSendLevel > DSBVOLUME_MAX)
    {
        RPF(DPFLVL_ERROR, "Volume out of bounds");
        hr = DSERR_INVALIDPARAM;
    }
    else
    {
        m_lSendLevel = pcDsFxSend->lSendLevel;
        m_dwAmpFactor = DBToAmpFactor(m_lSendLevel);
        hr = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CSendEffect::GetAllParameters
 *
 *  Description:
 *      Gets all our parameters - i.e., our send level.
 *
 *  Arguments:
 *      DSFXSend* [out]: Receives send parameter structure.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::GetAllParameters"

HRESULT CSendEffect::GetAllParameters(LPDSFXSend pDsFxSend)
{
    HRESULT hr;
    DPF_ENTER();

    if (!IS_VALID_TYPED_WRITE_PTR(pDsFxSend))
    {
        RPF(DPFLVL_ERROR, "Invalid pDsFxSend pointer");
        hr = DSERR_INVALIDPARAM;
    }
    else
    {
        pDsFxSend->lSendLevel = m_lSendLevel;
        hr = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CSendEffect::NotifyRelease
 *
 *  Description:
 *      Informs this send effect of the release of a MIXIN buffer.  If it
 *      happens to be our destination buffer, we record that it's gone.
 *
 *  Arguments:
 *      CDirectSoundSecondaryBuffer* [in]: Departing MIXIN buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::NotifyRelease"

void CSendEffect::NotifyRelease(CDirectSoundSecondaryBuffer* pDsBuffer)
{
    DPF_ENTER();

    // Check if it was our destination buffer that was released
    if (pDsBuffer == m_pDestBuffer)
    {
        m_pDestBuffer = NULL;
        m_fxStatus = DSFXR_FAILED;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CSendEffect::Process
 *
 *  Description:
 *      Handles mixing data from our source buffer into its destination,
 *      and invokes effect processing on the I3DL2 source DMO if necessary.
 *
 *  Arguments:
 *      DWORD [in]: Number of audio bytes to process.
 *      BYTE* [in, out]: Pointer to start of audio buffer to process.
 *      REFERENCE_TIME [in]: Timestamp of first sample to be processed
 *      DWORD [in]: Offset of a wrapped audio region.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CSendEffect::Process"

HRESULT CSendEffect::Process(DWORD dwBytes, BYTE *pAudio, REFERENCE_TIME rtTime, DWORD dwSendOffset, LPWAVEFORMATEX /*ignored*/)
{
    DWORD dwDestSliceBegin, dwDestSliceEnd;
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Pointer to the audio data we'll actually send; this pointer
    // may be modified below if this is an I3DL2 send
    BYTE* pSendAudio = pAudio;

    // Check whether our source buffer is active.  If it isn't,
    // we must be pre-rolling FX, so we don't perform the send.
    BOOL fPlaying = m_pSrcBuffer->IsPlaying();

    // If the source buffer is active, check the destination too.
    // (Note: if it has been released, m_pDestBuffer will be NULL)
    BOOL fSending = fPlaying && m_pDestBuffer && m_pDestBuffer->IsPlaying();

    // If sending, figure out the region to mix to and check it's valid
    if (fSending)
    {
        m_pDestBuffer->GetCurrentSlice(&dwDestSliceBegin, &dwDestSliceEnd);
        if (dwDestSliceBegin == MAX_DWORD)  // Can happen with sink buffers
            fSending = FALSE;
    }

    // OPTIMIZE: replace the CopyMemorys below with BYTE, WORD or DWORD
    // assignments, since we only support nBlockSizes of 1, 2 or 4...
    // But hopefully this code can disappear altogether (see bug 40236).

#ifdef ENABLE_I3DL2SOURCE
    // First call the I3DL2 DMO if this is an I3DL2 Source effect
    if (m_pI3DL2SrcDMOInPlace)
    {
        // If we're processing a mono buffer, an ugly hack is required; copying
        // the data into the L and R channels of a temporary stereo buffer, so
        // we have room for the two output streams returned by the I3DL2 DMO.

        WORD nBlockSize = m_pSrcBuffer->Format()->nBlockAlign;

        if (m_pSrcBuffer->Format()->nChannels == 1)
        {
            hr = MEMALLOC_A_HR(pSendAudio, BYTE, 2*dwBytes);
            if (SUCCEEDED(hr))
            {
                for (DWORD i=0; i<dwBytes; i += nBlockSize)
                {
                    CopyMemory(pSendAudio + 2*i,              pAudio + i, nBlockSize); // L channel
                    CopyMemory(pSendAudio + 2*i + nBlockSize, pAudio + i, nBlockSize); // R channel
                }
                hr = m_pI3DL2SrcDMOInPlace->Process(dwBytes, pSendAudio, rtTime, DMO_INPLACE_NORMAL);
            }

            if (SUCCEEDED(hr))
            {
                // Now we extract the two output streams from the data returned;
                // the direct path goes back to pAudio, and the reflected path
                // goes to the first half of pSendAudio.
                for (DWORD i=0; i<dwBytes; i += nBlockSize)
                {
                    CopyMemory(pAudio + i, pSendAudio + 2*i, nBlockSize);
                    if (fSending)  // Needn't preserve the reflected audio if we aren't sending it anywhere
                        CopyMemory(pSendAudio + i, pSendAudio + 2*i + nBlockSize, nBlockSize);
                }
            }
        }
        else // Processing a stereo buffer
        {
            hr = m_pI3DL2SrcDMOInPlace->Process(dwBytes, pAudio, rtTime, DMO_INPLACE_NORMAL);

            if (SUCCEEDED(hr))
                hr = MEMALLOC_A_HR(pSendAudio, BYTE, dwBytes);

            if (SUCCEEDED(hr))
            {
                // Extract the output streams and stereoize them at the same time
                for (DWORD i=0; i<dwBytes; i += nBlockSize)
                {
                    if (fSending)  // Needn't preserve the reflected audio if we aren't sending it anywhere
                    {
                        // Copy the R channel from pAudio into both channels of pSendAudio
                        CopyMemory(pSendAudio + i,                pAudio + i + nBlockSize/2, nBlockSize/2);
                        CopyMemory(pSendAudio + i + nBlockSize/2, pAudio + i + nBlockSize/2, nBlockSize/2);
                    }
                    // Copy pAudio's L channel onto its R channel
                    CopyMemory(pAudio + i + nBlockSize/2, pAudio + i, nBlockSize/2);
                }
            }
        }
    }
#endif

    // Now we handle the actual send
    if (SUCCEEDED(hr) && fSending)
    {
        PBYTE pDestBuffer = m_pDestBuffer->GetWriteBuffer();
        DWORD dwDestBufferSize = m_pDestBuffer->GetBufferSize();

        // If the source of this send has wrapped around and is making a second Process
        // call to handle the wrapped audio chunk, we will have a nonzero dwSendOffset
        // representing how far into the destination slice we should mix.  We add this
        // offset to dwDestSliceBegin (after a sanity check).
        ASSERT(CONTAINED(dwDestSliceBegin, dwDestSliceEnd, dwDestSliceBegin + dwSendOffset * m_mixMode));
        dwDestSliceBegin = (dwDestSliceBegin + dwSendOffset * m_mixMode) % dwDestBufferSize;

        DPF_TIMING(DPFLVL_MOREINFO, "Sending %lu bytes from %08X to %08X (%s to %s)",
                   dwBytes, pSendAudio, pDestBuffer + dwDestSliceBegin,
                   m_pSrcBuffer->Format()->nChannels == 1 ? TEXT("mono") : TEXT("stereo"),
                   m_pDestBuffer->Format()->nChannels == 1 ? TEXT("mono") : TEXT("stereo"));

        // The source slice had better fit in the destination slice
        ASSERT(dwBytes*m_mixMode <= DISTANCE(dwDestSliceBegin, dwDestSliceEnd, dwDestBufferSize));

        // Perform actual mixing
        if (dwDestSliceBegin + dwBytes*m_mixMode < dwDestBufferSize)
        {
            m_pMixFunction(pSendAudio, pDestBuffer + dwDestSliceBegin, dwBytes, m_dwAmpFactor, m_mixMode);
        }
        else // Wraparound case
        {
            DWORD dwLastBytes = (dwDestBufferSize - dwDestSliceBegin) / m_mixMode;
            m_pMixFunction(pSendAudio, pDestBuffer + dwDestSliceBegin, dwLastBytes, m_dwAmpFactor, m_mixMode);
            m_pMixFunction(pSendAudio + dwLastBytes, pDestBuffer, dwBytes - dwLastBytes, m_dwAmpFactor, m_mixMode);
        }
    }

    if (pSendAudio != pAudio)
        MEMFREE(pSendAudio);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Mix8bit
 *
 *  Description:
 *      Primitive 8-bit mixing function.  Attenuates source audio by a
 *      given factor, adds it to the destination audio, and clips.
 *
 *  Arguments:
 *      VOID* [in]: Pointer to source audio buffer.
 *      VOID* [in, out]: Pointer to destination audio buffer.
 *      DWORD [in]: Number of bytes to mix.
 *      DWORD [in]: Amplification factor (in 1/65536 units).
 *      MIXMODE: Whether to double the channel data or not.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Mix8bit"

static void Mix8bit(PVOID pSrc, PVOID pDest, DWORD dwBytes, DWORD dwAmpFactor, MIXMODE mixMode)
{
    unsigned char* pSampSrc = (unsigned char*)pSrc;
    unsigned char* pSampDest = (unsigned char*)pDest;
    DPF_ENTER();

    while (dwBytes--)
    {
        INT sample = (INT(*pSampSrc++) - 0x80) * INT(dwAmpFactor) / 0xffff;
        INT mixedSample = sample + *pSampDest;
        if (mixedSample > 0xff) mixedSample = 0xff;
        else if (mixedSample < 0) mixedSample = 0;
        *pSampDest++ = unsigned char(mixedSample);
        if (mixMode == MonoToStereo)
        {
            mixedSample = sample + *pSampDest;
            if (mixedSample > 0xff) mixedSample = 0xff;
            else if (mixedSample < 0) mixedSample = 0;
            *pSampDest++ = unsigned char(mixedSample);
        }
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Mix16bit
 *
 *  Description:
 *      Primitive 16-bit mixing function.  Attenuates source audio by a
 *      given factor, adds it to the destination audio, and clips.
 *
 *  Arguments:
 *      VOID* [in]: Pointer to source audio buffer.
 *      VOID* [in, out]: Pointer to destination audio buffer.
 *      DWORD [in]: Number of bytes to mix.
 *      DWORD [in]: Amplification factor (in 1/65536 units).
 *      MIXMODE: Whether to double the channel data or not.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Mix16bit"

static void Mix16bit(PVOID pSrc, PVOID pDest, DWORD dwBytes, DWORD dwAmpFactor, MIXMODE mixMode)
{
    DWORD dwSamples = dwBytes / 2;
    short* pSampSrc = (short*)pSrc;
    short* pSampDest = (short*)pDest;
    DPF_ENTER();

    while (dwSamples--)
    {
        INT sample = INT(*pSampSrc++) * INT(dwAmpFactor) / 0xffff;
        INT mixedSample = sample + *pSampDest;
        if (mixedSample > 32767) mixedSample = 32767;
        else if (mixedSample < -32768) mixedSample = -32768;
        *pSampDest++ = short(mixedSample);
        if (mixMode == MonoToStereo)
        {
            mixedSample = sample + *pSampDest;
            if (mixedSample > 32767) mixedSample = 32767;
            else if (mixedSample < -32768) mixedSample = -32768;
            *pSampDest++ = short(mixedSample);
        }
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  IsValidEffectDesc
 *
 *  Description:
 *      Determines if the given effect descriptor structure is valid for
 *      the given secondary buffer.
 *
 *  Arguments:
 *      DSEFFECTDESC* [in]: Effect descriptor to be validated.
 *      CDirectSoundSecondaryBuffer* [in]: Host buffer for the effect.
 *
 *  Returns:
 *      BOOL: TRUE if the descriptor is valid.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsValidEffectDesc"

BOOL IsValidEffectDesc(LPCDSEFFECTDESC pEffectDesc, CDirectSoundSecondaryBuffer* pDsBuffer)
{
    BOOL fValid = TRUE;
    DPF_ENTER();

    if (pEffectDesc->dwSize != sizeof(DSEFFECTDESC))
    {
        RPF(DPFLVL_ERROR, "Invalid DSEFFECTDESC structure size");
        fValid = FALSE;
    }
    else if (pEffectDesc->dwReserved2 != 0)
    {
        RPF(DPFLVL_ERROR, "Reserved fields in the DSEFFECTDESC structure must be 0");
        fValid = FALSE;
    }

#ifdef DEAD_CODE
    if (fValid && !IsStandardEffect(pEffectDesc->guidDSFXClass))
        DPF(DPFLVL_INFO, DPF_GUID_STRING " is a third-party effect GUID", DPF_GUID_VAL(pEffectDesc->guidDSFXClass));
#endif

    if (fValid)
    {
        fValid = IsValidFxFlags(pEffectDesc->dwFlags);
    }

    if (fValid)
    {
        BOOL fSendEffect = pEffectDesc->guidDSFXClass == GUID_DSFX_SEND
#ifdef ENABLE_I3DL2SOURCE
                           || pEffectDesc->guidDSFXClass == GUID_DSFX_STANDARD_I3DL2SOURCE
#endif
                           ;
        if (!fSendEffect && pEffectDesc->dwReserved1)
        {
            RPF(DPFLVL_ERROR, "lpSendBuffer should only be specified with GUID_DSFX_SEND"
#ifdef ENABLE_I3DL2SOURCE
                              " or GUID_DSFX_STANDARD_I3DL2SOURCE"
#endif
            );
            fValid = FALSE;
        }
        else if (fSendEffect)
        {
            CImpDirectSoundBuffer<CDirectSoundSecondaryBuffer>* pImpBuffer =
                (CImpDirectSoundBuffer<CDirectSoundSecondaryBuffer>*) (pEffectDesc->dwReserved1);
            LPWAVEFORMATEX pSrcWfx, pDstWfx;

            if (!pImpBuffer)
            {
                RPF(DPFLVL_ERROR, "lpSendBuffer must be specified for GUID_DSFX_SEND"
#ifdef ENABLE_I3DL2SOURCE
                                  " and GUID_DSFX_STANDARD_I3DL2SOURCE"
#endif
                );
                fValid = FALSE;
            }
            else if (!IS_VALID_IDIRECTSOUNDBUFFER(pImpBuffer))
            {
                RPF(DPFLVL_ERROR, "lpSendBuffer points to an invalid DirectSound buffer");
                fValid = FALSE;
            }
            else if (!(pImpBuffer->m_pObject->GetBufferType() & DSBCAPS_MIXIN))
            {
                RPF(DPFLVL_ERROR, "lpSendBuffer must point to a DSBCAPS_MIXIN buffer");
                fValid = FALSE;
            }
            else if (pImpBuffer->m_pObject->GetDirectSound() != pDsBuffer->GetDirectSound())
            {
                RPF(DPFLVL_ERROR, "Can't send to a buffer on a different DirectSound object");
                fValid = FALSE;
            }
            else if ((pSrcWfx = pDsBuffer->Format())->nSamplesPerSec !=
                     (pDstWfx = pImpBuffer->m_pObject->Format())->nSamplesPerSec)
            {
                RPF(DPFLVL_ERROR, "The buffer sent to must have the same nSamplesPerSec as the sender");
                fValid = FALSE;
            }
            else if (pSrcWfx->wBitsPerSample != pDstWfx->wBitsPerSample)
            {
                RPF(DPFLVL_ERROR, "The buffer sent to must have the same wBitsPerSample as the sender");
                fValid = FALSE;
            }
            else if ((pSrcWfx->nChannels > 2 || pDstWfx->nChannels > 2) && (pSrcWfx->nChannels != pDstWfx->nChannels))
            {
                RPF(DPFLVL_ERROR, "If either the send buffer or the receive buffer has more than two channels, the number of channels must match");
                fValid = FALSE;
            }
            else if (pSrcWfx->nChannels == 2 && pDstWfx->nChannels == 1)
            {
                RPF(DPFLVL_ERROR, "You can't send from a stereo buffer to a mono buffer");
                fValid = FALSE;
            }
            else if (pEffectDesc->dwFlags & (DSFX_LOCSOFTWARE | DSFX_LOCHARDWARE))
            {
                RPF(DPFLVL_ERROR, "Location flags should not be specified for GUID_DSFX_SEND"
#ifdef ENABLE_I3DL2SOURCE
                                  " or GUID_DSFX_STANDARD_I3DL2SOURCE"
#endif
                );
                fValid = FALSE;
            }
        }
    }

    DPF_LEAVE(fValid);
    return fValid;
}


#ifdef DEAD_CODE
/***************************************************************************
 *
 *  IsStandardEffect
 *
 *  Description:
 *      Determines if an effect GUID refers to one of our internal effects.
 *
 *  Arguments:
 *      REFGUID [in]: effect identifier.
 *
 *  Returns:
 *      BOOL: TRUE if the ID refers to an internal effect.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "IsStandardEffect"

BOOL IsStandardEffect(REFGUID guidEffect)
{
    LPCGUID stdFx[] = {&GUID_DSFX_SEND, &GUID_DSFX_STANDARD_DISTORTION, &GUID_DSFX_STANDARD_COMPRESSOR,
                       &GUID_DSFX_STANDARD_ECHO, &GUID_DSFX_STANDARD_CHORUS, &GUID_DSFX_STANDARD_FLANGER,
                       &GUID_DSFX_STANDARD_I3DL2SOURCE, &GUID_DSFX_STANDARD_I3DL2REVERB};
    BOOL fStandard;
    UINT i;

    DPF_ENTER();

    for (i=0, fStandard=FALSE; i < NUMELMS(stdFx) && !fStandard; ++i)
        fStandard = (guidEffect == *stdFx[i]);

    DPF_LEAVE(fStandard);
    return fStandard;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\emvad.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       emvad.h
 *  Content:    Emulated (via mmsystem APIs) Virtual Audio Device class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/1/97      dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifndef __EMVAD_H__
#define __EMVAD_H__

#ifdef DEBUG
// #define DEBUG_CAPTURE  // Uncomment this for some extra capture tracing
#endif

#ifdef __cplusplus

// The Emulated Audio Device class
class CEmRenderDevice : public CMxRenderDevice, private CUsesEnumStandardFormats
{
    friend class CEmPrimaryRenderWaveBuffer;

public:
    CEmRenderDevice(void);
    virtual ~CEmRenderDevice(void);

    // Driver enumeration
    virtual HRESULT EnumDrivers(CObjectList<CDeviceDescription> *);

    // Creation
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device capabilities
    virtual HRESULT GetCaps(LPDSCAPS);
    virtual HRESULT GetCertification(LPDWORD, BOOL) {return DSERR_UNSUPPORTED;}

    // Buffer management
    virtual HRESULT CreatePrimaryBuffer(DWORD, LPVOID, CPrimaryRenderWaveBuffer **);

protected:
    virtual HRESULT LockMixerDestination(DWORD, DWORD, LPVOID *, LPDWORD, LPVOID *, LPDWORD);
    virtual HRESULT UnlockMixerDestination(LPVOID, DWORD, LPVOID, DWORD);

private:
    virtual BOOL EnumStandardFormatsCallback(LPCWAVEFORMATEX);
};

// The primary buffer
class CEmPrimaryRenderWaveBuffer : public CPrimaryRenderWaveBuffer
{
private:
    CEmRenderDevice* m_pEmDevice;   // Parent device

public:
    CEmPrimaryRenderWaveBuffer(CEmRenderDevice *, LPVOID);
    virtual ~CEmPrimaryRenderWaveBuffer(void);

    // Initialization
    virtual HRESULT Initialize(DWORD);

    // Buffer capabilities
    virtual HRESULT GetCaps(LPVADRBUFFERCAPS);

    // Access rights
    virtual HRESULT RequestWriteAccess(BOOL);

    // Buffer data
    virtual HRESULT CommitToDevice(DWORD, DWORD);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);

    // Owned objects
    virtual HRESULT CreatePropertySet(CPropertySet **);
    virtual HRESULT Create3dListener(C3dListener **);
};

inline HRESULT CEmPrimaryRenderWaveBuffer::CreatePropertySet(CPropertySet **)
{
    return DSERR_UNSUPPORTED;
}

// The emulated secondary buffer
class CEmSecondaryRenderWaveBuffer : public CSecondaryRenderWaveBuffer
{
private:
    CMxRenderDevice *       m_pMxDevice;                // Parent device
    CMixSource *            m_pMixSource;               // Mixer source
    PFIRCONTEXT             m_pFirContextLeft;          // FIR context used by the 3D filter
    PFIRCONTEXT             m_pFirContextRight;         // FIR context used by the 3D filter
    DWORD                   m_dwState;                  // Current buffer state

public:
    CEmSecondaryRenderWaveBuffer(CMxRenderDevice *, LPVOID);
    virtual ~CEmSecondaryRenderWaveBuffer(void);

    // Initialization
    virtual HRESULT Initialize(LPCVADRBUFFERDESC, CEmSecondaryRenderWaveBuffer *, CSysMemBuffer *);

    // Buffer creation
    virtual HRESULT Duplicate(CSecondaryRenderWaveBuffer **);

    // Buffer data
    virtual HRESULT CommitToDevice(DWORD, DWORD);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetCursorPosition(DWORD);

    // Buffer properties
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN);
#ifdef FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT SetChannelAttenuations(LONG, DWORD, const DWORD*, const LONG*);
#endif
    virtual HRESULT SetFrequency(DWORD, BOOL fClamp =FALSE);
    virtual HRESULT SetMute(BOOL);

    // Buffer position notifications
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

    // Owned objects
    virtual HRESULT CreatePropertySet(CPropertySet **);
    virtual HRESULT Create3dObject(C3dListener *, C3dObject **);

private:
    // Owned objects
    virtual HRESULT CreateItd3dObject(C3dListener *, C3dObject **);
};

inline HRESULT CEmSecondaryRenderWaveBuffer::CreatePropertySet(CPropertySet **)
{
    return DSERR_UNSUPPORTED;
}

// The emulated 3D object
class CEmItd3dObject : public CItd3dObject
{
private:
    CMixSource *            m_pMixSource;           // CMixSource used by the owning
    CMixDest *              m_pMixDest;             // CMixDest used by the owning
    PFIRCONTEXT             m_pContextLeft;         // Left channel FIR context
    PFIRCONTEXT             m_pContextRight;        // Right channel FIR context

public:
    CEmItd3dObject(C3dListener *, BOOL, BOOL, DWORD, CMixSource *, CMixDest *, PFIRCONTEXT, PFIRCONTEXT);
    virtual ~CEmItd3dObject(void);

protected:
    // Commiting 3D data to the device
    virtual HRESULT Commit3dChanges(void);
    virtual DWORD Get3dOutputSampleRate(void);

private:
    virtual void CvtContext(LPOBJECT_ITD_CONTEXT, PFIRCONTEXT);
};

class CEmCaptureDevice : public CCaptureDevice, private CUsesEnumStandardFormats
{
    friend class CEmCaptureWaveBuffer;

private:
    LPWAVEFORMATEX  m_pwfxFormat;   // Device format
    HWAVEIN         m_hwi;          // WaveIn device handle

protected:
    DWORD           m_fAllocated;   // Allocated

public:
    CEmCaptureDevice();
    virtual ~CEmCaptureDevice();

    // Driver enumeration
    virtual HRESULT EnumDrivers(CObjectList<CDeviceDescription> *);

    // Initialization
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device caps
    virtual HRESULT GetCaps(LPDSCCAPS);
    virtual HRESULT GetCertification(LPDWORD, BOOL);

    // Buffer management
    virtual HRESULT CreateBuffer(DWORD, DWORD, LPCWAVEFORMATEX, CCaptureEffectChain *, LPVOID, CCaptureWaveBuffer **);

    HRESULT SetGlobalFormat(LPVOID, LPCWAVEFORMATEX, LPVOID, DWORD);
    HWAVEIN HWaveIn(void);

private:
    virtual BOOL EnumStandardFormatsCallback(LPCWAVEFORMATEX);
};

inline HRESULT CEmCaptureDevice::GetCertification(LPDWORD pdwCertification, BOOL fGetCaps)
{
    return DSERR_UNSUPPORTED;
}

inline HWAVEIN CEmCaptureDevice::HWaveIn(void)
{
    return m_hwi;
}

// Base class for wave capturing buffers
class CEmCaptureWaveBuffer : public CCaptureWaveBuffer
{
#ifndef NOKS
    friend class CKsCaptureWaveBuffer;
#endif

private:
    enum { cwhdrDefault = 8 };
    enum { IWHDR_INVALID = -1 };

    enum
    {
        ihEventTerminate = 0,
        ihEventWHDRDone,
        ihEventFocusChange,
        ihEventThreadStart,
        chEvents
    };

    DWORD           m_dwState;      // state of buffer, i.e. capturing or not
    DWORD           m_fdwSavedState;// last buffer state set (ignoring capture focus)

    LONG            m_cwhdr;        // number of capture buffers
    LPWAVEHDR       m_rgpwhdr;      // array of WAVEHDRs for capturing
    LONG            m_cwhdrDone;    // count of WHDRs captured
    LONG            m_iwhdrDone;

    LPBYTE          m_pBuffer;      // buffer for data
    DWORD           m_cbBuffer;     // size of buffer
    DWORD           m_cbRecordChunk;// capture chunk size used for waveInAddBuffer
    LPBYTE          m_pBufferMac;   // end of buffer for data
    LPBYTE          m_pBufferNext;  // next part of buffer to be queued
    DWORD           m_cLoops;       // how many times we've looped around
    LPWAVEFORMATEX  m_pwfx;         // WAVEFORMATEX to capture in
    HWAVEIN         m_hwi;          // HWAVEIN for opened wave device

    DWORD           m_cpn;          // count of position.notifies
    LPDSBPOSITIONNOTIFY m_rgpdsbpn; // array of position.notifies
    DWORD           m_ipn;          // index to current pn - previous ones have been processed
    DWORD           m_cpnAllocated; // max available slots in m_rgdwPosition and m_rghEvent arrays

    BOOL            m_fCritSectsValid;// Critical sections currently OK
    CRITICAL_SECTION    m_cs;       // critical section to protect multi-thread access
    CRITICAL_SECTION    m_csPN;     // critical section to protect multi-thread access
                                    // used for position notification processing

    DWORD           m_dwCaptureCur; // offset to last processed capture head position
                                    // i.e. data up to this point is valid
    DWORD           m_dwCaptureLast;// offset into buffer where capturing stopped last

    HANDLE          m_hThread;      // handle of worker thread

    LONG            m_cwhdrDropped;
    LPBYTE          m_pBufferProcessed;

    HANDLE          m_rghEvent[chEvents];   // array of HEVENTs
    TCHAR           m_rgszEvent[chEvents][32];  // array of names for HEVENTs

    void            NotifyStop(void);
    HRESULT         QueueWaveHeader(LPWAVEHDR);

    #ifdef DEBUG_CAPTURE
    DWORD           m_iwhdrExpected; // Used to verify callback order
    #endif

public:
    CEmCaptureWaveBuffer(CCaptureDevice *);
    virtual ~CEmCaptureWaveBuffer();

    // Initialization
    virtual HRESULT Initialize(DWORD, DWORD, LPCWAVEFORMATEX);

    // Buffer capabilities
    virtual HRESULT GetCaps(LPDSCBCAPS);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

    // Callback function specified in waveInOpen
    //
    // From the SDK:
    // "Applications should not call any system-defined functions from inside a
    //  callback function, except for EnterCriticalSection, LeaveCriticalSection,
    //  midiOutLongMsg, midiOutShortMsg, OutputDebugString, PostMessage,
    //  PostThreadMessage, SetEvent, timeGetSystemTime, timeGetTime, timeKillEvent,
    //  and timeSetEvent. Calling other wave functions will cause deadlock."
    //
    static void CALLBACK waveInCallback(HWAVEIN hwi, UINT uMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    static DWORD WINAPI CaptureThreadStatic(LPVOID pv);
    void CaptureThread();
};

#endif // __cplusplus

#endif // __EMVAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\effects.h ===
/***************************************************************************
 *
 *  Copyright (C) 1999-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:        effects.h
 *
 *  Content:     Declarations for the CEffectChain class and the CEffect
 *               class hierarchy (CEffect, CDmoEffect and CSendEffect).
 *
 *  Description: These classes implement DX8 audio effects and sends.
 *               More info in effects.cpp.
 *
 *  History:
 *
 * Date      By       Reason
 * ========  =======  ======================================================
 * 08/10/99  duganp   Created
 *
 ***************************************************************************/

#ifndef __EFFECTS_H__
#define __EFFECTS_H__

// Various conversions between reftimes, milliseconds, samples and bytes.
// (Defining 'sample' as a sample *block*, with samples for all channels)
// REFERENCE_TIME is in 100-ns units (so 1 reftime tick == 1e-7 seconds).

__inline DWORD MsToBytes(DWORD ms, LPWAVEFORMATEX pwfx)
{
    return BLOCKALIGN(ms * pwfx->nAvgBytesPerSec / 1000, pwfx->nBlockAlign);
}
__inline DWORD BytesToMs(DWORD bytes, LPWAVEFORMATEX pwfx)
{
    return bytes * 1000 / pwfx->nAvgBytesPerSec;
}
__inline DWORD MsToSamples(DWORD ms, LPWAVEFORMATEX pwfx)
{
    return ms * pwfx->nSamplesPerSec / 1000;
}
__inline DWORD SamplesToMs(DWORD samples, LPWAVEFORMATEX pwfx)
{
    return samples * 1000 / pwfx->nSamplesPerSec;
}
__inline DWORD RefTimeToMs(REFERENCE_TIME rt)
{
    return (DWORD)(rt / 10000);
}
__inline REFERENCE_TIME MsToRefTime(DWORD ms)
{
    return (REFERENCE_TIME)ms * 10000;
}
__inline DWORD RefTimeToBytes(REFERENCE_TIME rt, LPWAVEFORMATEX pwfx)
{
    return (DWORD)(BLOCKALIGN(rt * pwfx->nAvgBytesPerSec / 10000000, pwfx->nBlockAlign));
}
__inline REFERENCE_TIME BytesToRefTime(DWORD bytes, LPWAVEFORMATEX pwfx)
{
    return (REFERENCE_TIME)bytes * 10000000 / pwfx->nAvgBytesPerSec;
}

// Figure out if position X is between A and B in a cyclic buffer
#define CONTAINED(A, B, X) ((A) < (B) ? (A) <= (X) && (X) <= (B) \
                                      : (A) <= (X) || (X) <= (B))

// As above, but excluding the boundary case
#define STRICTLY_CONTAINED(A, B, X) ((A) < (B) ? (A) < (X) && (X) < (B) \
                                               : (A) < (X) || (X) < (B))

// Figure out if a cursor has overtaken position X while moving from A to B
#define OVERTAKEN(A, B, X) !CONTAINED(A, X, B)

// Find the distance between positions A and B in a buffer of length L
#define DISTANCE(A, B, L) ((A) <= (B) ? (B) - (A) : (L) + (B) - (A))


#ifdef __cplusplus

#include "mediaobj.h"   // For DMO_MEDIA_TYPE

// Special argument used by CEffectChain::PreRollFx() below
#define CURRENT_PLAY_POS MAX_DWORD

// Forward declarations
class CDirectSoundSecondaryBuffer;
class CDirectSoundBufferConfig;
class CEffect;

// Utility functions for the simple mixer used by CSendEffect below
enum MIXMODE {OneToOne=1, MonoToStereo=2};
typedef void MIXFUNCTION(PVOID pSrc, PVOID pDest, DWORD dwSamples, DWORD dwAmpFactor, MIXMODE mixMode);
MIXFUNCTION Mix8bit;
MIXFUNCTION Mix16bit;

// Validator for effect descriptors (can't be in dsvalid.c because it uses C++)
BOOL IsValidEffectDesc(LPCDSEFFECTDESC, CDirectSoundSecondaryBuffer*);


//
// The DirectSound effects chain class
//

class CEffectChain : public CDsBasicRuntime
{
    friend class CStreamingThread;  // Note: should try to dissolve some of these friendships
    friend class CDirectSoundSecondaryBuffer;  // So FindSendLoop() can get at m_fxList

public:
    CEffectChain                 (CDirectSoundSecondaryBuffer* pBuffer);
    ~CEffectChain                (void);

    HRESULT Initialize           (DWORD dwFxCount, LPDSEFFECTDESC pFxDesc, LPDWORD pdwResultCodes);
    HRESULT Clone                (CDirectSoundBufferConfig* pDSBConfigObj);
    HRESULT AcquireFxResources   (void);
    HRESULT GetFxStatus          (LPDWORD pdwResultCodes);
    HRESULT GetEffectInterface   (REFGUID guidObject, DWORD dwIndex, REFGUID iidInterface, LPVOID* ppObject);
    HRESULT NotifyState          (DWORD dwState);
    void    NotifyRelease        (CDirectSoundSecondaryBuffer*);
    void    SetInitialSlice      (REFERENCE_TIME rtSliceSize);
    DWORD   GetFxCount()         {return m_fxList.GetNodeCount();}

    // Effects processing methods
    HRESULT PreRollFx            (DWORD dwPosition =CURRENT_PLAY_POS);
    HRESULT UpdateFx             (LPVOID pChangedPos, DWORD dwChangedSize);
    HRESULT ProcessFx            (DWORD dwWriteAhead, LPDWORD pdwLatencyBoost);

private:
    HRESULT ReallyProcessFx      (DWORD dwStartPos, DWORD dwEndPos);
    HRESULT ReallyReallyProcessFx(DWORD dwOffset, DWORD dwBytes, REFERENCE_TIME rtTime, DWORD dwSendOffset =0);
    HRESULT FxDiscontinuity      (void);

    // Effects processing state
    CStreamingThread*            m_pStreamingThread;    // Pointer to our owning streaming thread
    CObjectList<CEffect>         m_fxList;              // Effect object list
    CDirectSoundSecondaryBuffer* m_pDsBuffer;           // Owning DirectSound buffer object
    LPWAVEFORMATEX               m_pFormat;             // Pointer to owning buffer's audio format
    PBYTE                        m_pPreFxBuffer;        // "Dry" audio buffer (before FX processing)
    PBYTE                        m_pPostFxBuffer;       // "Wet" audio buffer (after FX processing)
    DWORD                        m_dwBufSize;           // Size of above two buffers in bytes
    DWORD                        m_dwLastPos;           // Last byte position written to
    DWORD                        m_dwLastPlayCursor;    // Play cursor from previous run
    DWORD                        m_dwLastWriteCursor;   // Write cursor from previous run
    BOOL                         m_fHasSend;            // Whether this FX chain contains any sends
                                                        // FIXME: may not be necessary later
    HRESULT                      m_hrInit;              // Return code from initialization
    DWORD                        m_dwWriteAheadFixme;   // FIXME: temporary
};


//
// Base class for all DirectSound audio effects
//

class CEffect : public CDsBasicRuntime  // FIXME: to save some memory we could derive CEffect from CRefCount 
                                        // and implement the ": CRefCount(1)", "delete this" stuff etc here.
{
public:
    CEffect                         (DSEFFECTDESC& fxDescriptor);
    virtual ~CEffect                (void) {}
    virtual HRESULT Initialize      (DMO_MEDIA_TYPE*) =0;
    virtual HRESULT Clone           (IMediaObject*, DMO_MEDIA_TYPE*) =0;
    virtual HRESULT Process         (DWORD dwBytes, BYTE* pAudio, REFERENCE_TIME refTimeStart, DWORD dwSendOffset, LPWAVEFORMATEX pFormat) =0;
    virtual HRESULT Discontinuity   (void) = 0;
    virtual HRESULT GetInterface    (REFIID, LPVOID*) =0;

    // These two methods are only required by CSendEffect:
    virtual void NotifyRelease(CDirectSoundSecondaryBuffer*) {}
    virtual CDirectSoundSecondaryBuffer* GetDestBuffer(void) {return NULL;}

    HRESULT AcquireFxResources      (void);

    DSEFFECTDESC                    m_fxDescriptor;     // Creation parameters
    DWORD                           m_fxStatus;         // Current effect status
};


//
// Class representing DirectX Media Object effects
//

class CDmoEffect : public CEffect
{
public:
    CDmoEffect              (DSEFFECTDESC& fxDescriptor);
    ~CDmoEffect             (void);
    HRESULT Initialize      (DMO_MEDIA_TYPE*);
    HRESULT Clone           (IMediaObject*, DMO_MEDIA_TYPE*);
    HRESULT Process         (DWORD dwBytes, BYTE* pAudio, REFERENCE_TIME refTimeStart, DWORD dwSendOffset =0, LPWAVEFORMATEX pFormat =NULL);
    HRESULT Discontinuity   (void)                          {return m_pMediaObject->Discontinuity(0);}
    HRESULT GetInterface    (REFIID riid, LPVOID* ppvObj)   {return m_pMediaObject->QueryInterface(riid, ppvObj);}

    IMediaObject*           m_pMediaObject;         // The DMO's standard interface (required)
    IMediaObjectInPlace*    m_pMediaObjectInPlace;  // The DMO's special interface (optional)
};


//
// Class representing DirectSound audio sends
//

class CSendEffect : public CEffect
{
public:
    CSendEffect(DSEFFECTDESC& fxDescriptor, CDirectSoundSecondaryBuffer* pSrcBuffer);
    ~CSendEffect(void);

    HRESULT Initialize      (DMO_MEDIA_TYPE*);
    HRESULT Clone           (IMediaObject*, DMO_MEDIA_TYPE*);
    HRESULT Process         (DWORD dwBytes, BYTE* pAudio, REFERENCE_TIME refTimeStart, DWORD dwSendOffset =0, LPWAVEFORMATEX pFormat =NULL);
    void    NotifyRelease   (CDirectSoundSecondaryBuffer*);
#ifdef ENABLE_I3DL2SOURCE
    HRESULT Discontinuity   (void)                          {return m_pI3DL2SrcDMO ? m_pI3DL2SrcDMO->Discontinuity(0) : DS_OK;}
#else
    HRESULT Discontinuity   (void)                          {return DS_OK;}
#endif
    HRESULT GetInterface    (REFIID riid, LPVOID* ppvObj)   {return m_impDSFXSend.QueryInterface(riid, ppvObj);}
    CDirectSoundSecondaryBuffer* GetDestBuffer(void)        {return m_pDestBuffer;}

    // IDirectSoundFXSend methods
    HRESULT SetAllParameters(LPCDSFXSend);
    HRESULT GetAllParameters(LPDSFXSend);

private:
    // COM interface helper object
    struct CImpDirectSoundFXSend : public IDirectSoundFXSend
    {
        // INTERFACE_SIGNATURE m_signature;
        CSendEffect* m_pObject;

        // IUnknown methods (FIXME - missing the param validation layer)
        ULONG   STDMETHODCALLTYPE AddRef()  {return m_pObject->AddRef();}
        ULONG   STDMETHODCALLTYPE Release() {return m_pObject->Release();}
        HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppvObj);

        // IDirectSoundFXSend methods (FIXME - missing the param validation layer)
        HRESULT STDMETHODCALLTYPE SetAllParameters(LPCDSFXSend pcDsFxSend) {return m_pObject->SetAllParameters(pcDsFxSend);}
        HRESULT STDMETHODCALLTYPE GetAllParameters(LPDSFXSend pDsFxSend)  {return m_pObject->GetAllParameters(pDsFxSend);}
    };
    friend struct CImpDirectSoundFXSend;

    // Data members
    CImpDirectSoundFXSend        m_impDSFXSend;         // COM interface helper object
    MIXFUNCTION*                 m_pMixFunction;        // Current mixing routine
    MIXMODE                      m_mixMode;             // Current mixing mode
    CDirectSoundSecondaryBuffer* m_pSrcBuffer;          // Source buffer for the send - FIXME: may be able to lose this
    CDirectSoundSecondaryBuffer* m_pDestBuffer;         // Destination buffer for the send
    LONG                         m_lSendLevel;          // DSBVOLUME attenuation (millibels)
    DWORD                        m_dwAmpFactor;         // Corresponding amplification factor
#ifdef ENABLE_I3DL2SOURCE
    IMediaObject*                m_pI3DL2SrcDMO;        // Interfaces on our contained I3DL2 source DMO
    IMediaObjectInPlace*         m_pI3DL2SrcDMOInPlace; // (if this happends to be an I3DL2 send effect).
#endif
};


#if DEAD_CODE
// FIXME: Support for IMediaObject-only DMOs goes here

//
// Utility class used to wrap our audio buffers in an IMediaBuffer interface,
// so we can use a DMO's IMediaObject interface if it lacks IMediaObjectInPlace.
//

class CMediaBuffer : public CUnknown // (but this has dependencies on CImpUnknown...)
{
    // Blah.
};

#endif // DEAD_CODE
#endif // __cplusplus
#endif // __EFFECTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\emvad.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       emvad.cpp
 *  Content:    Emulated Virtual Audio Device class
 *              "emvad.cpp" is a misnomer; it does contain CEmRenderDevice,
 *              the emulated (via the wave* API) audio device, but it also
 *              has the CEm*WaveBuffer classes, which represent software
 *              audio buffers that can be attached to *any* mixer device;
 *              that is, both to CEmRenderDevice and to CVxdRenderDevice.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/1/97      dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#include "dsoundi.h"


/***************************************************************************
 *
 *  CEmRenderDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::CEmRenderDevice"

CEmRenderDevice::CEmRenderDevice(void)
    : CMxRenderDevice(VAD_DEVICETYPE_EMULATEDRENDER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEmRenderDevice);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEmRenderDevice
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::~CEmRenderDevice"

CEmRenderDevice::~CEmRenderDevice(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CEmRenderDevice);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EnumDrivers
 *
 *  Description:
 *      Creates a list of driver GUIDs that can be used to initialize this
 *      device.
 *
 *  Arguments:
 *      CList& [in/out]: pointer to a CList object that will be filled with
 *                       CDeviceDescription objects.  The caller is
 *                       responsible for freeing these objects.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::EnumDrivers"

HRESULT CEmRenderDevice::EnumDrivers(CObjectList<CDeviceDescription> *plstDrivers)
{
    CDeviceDescription *    pDesc                   = NULL;
    LPTSTR                  pszInterface            = NULL;
    HRESULT                 hr                      = DS_OK;
    TCHAR                   szTemplate[0x100];
    TCHAR                   szEmulated[0x100];
    TCHAR                   szName[0x400];
    UINT                    cDevices;
    BYTE                    bDeviceId;
    WAVEOUTCAPS             woc;
    GUID                    guid;
    MMRESULT                mmr;

    DPF_ENTER();

    // LIMITATION: We can't support more than 0xFF emulated devices,
    // because we pack the device ID into a byte member of a GUID.
    cDevices = waveOutGetNumDevs();
    cDevices = NUMERIC_CAST(cDevices, BYTE);

    // Load string templates
    if(!LoadString(hModule, IDS_DS_DRIVERLD, szTemplate, NUMELMS(szTemplate)))
    {
        DPF(DPFLVL_ERROR, "Can't load driver template string");
        hr = DSERR_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr) && !LoadString(hModule, IDS_EMULATED, szEmulated, NUMELMS(szEmulated)))
    {
        DPF(DPFLVL_ERROR, "Can't load emulated template string");
        hr = DSERR_OUTOFMEMORY;
    }

    // Enumerate each waveOut device and add it to the list
    for(bDeviceId = 0; bDeviceId < cDevices && SUCCEEDED(hr); bDeviceId++)
    {
        // Get the driver GUID
        g_pVadMgr->GetDriverGuid(m_vdtDeviceType, bDeviceId, &guid);

        // Create the device description object
        pDesc = NEW(CDeviceDescription(m_vdtDeviceType, guid, bDeviceId));
        hr = HRFROMP(pDesc);

        // Get the device name
        if(SUCCEEDED(hr))
        {
            mmr = waveOutGetDevCaps(bDeviceId, &woc, sizeof(woc));
            hr = MMRESULTtoHRESULT(mmr);
        }

        if(SUCCEEDED(hr))
        {
            lstrcpy(szName, woc.szPname);
            lstrcat(szName, szEmulated);
        }

        if(SUCCEEDED(hr))
        {
            pDesc->m_strName = szName;
        }

        // Get the device path
        if(SUCCEEDED(hr))
        {
            wsprintf(szName, szTemplate, bDeviceId);
            pDesc->m_strPath = szName;
        }

        // Get the device interface
        if(SUCCEEDED(hr))
        {
            GetWaveDeviceInterface(bDeviceId, FALSE, &pszInterface);
            pDesc->m_strInterface = pszInterface;
        }

        // Get the device devnode
        if(SUCCEEDED(hr))
        {
            GetWaveDeviceDevnode(bDeviceId, FALSE, &pDesc->m_dwDevnode);
        }

        // Add the driver to the list
        if(SUCCEEDED(hr))
        {
            hr = HRFROMP(plstDrivers->AddNodeToList(pDesc));
        }

        // Clean up
        MEMFREE(pszInterface);
        RELEASE(pDesc);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the device.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: driver description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::Initialize"

HRESULT CEmRenderDevice::Initialize(CDeviceDescription *pDesc)
{
    LPWAVEFORMATEX              pwfxFormat  = NULL;
    HRESULT                     hr;

    DPF_ENTER();

    // Initialize the base class
    hr = CMxRenderDevice::Initialize(pDesc);

    // Allocate the default format
    if(SUCCEEDED(hr))
    {
        pwfxFormat = AllocDefWfx();
        hr = HRFROMP(pwfxFormat);
    }

    // Create the mixer
    if(SUCCEEDED(hr))
    {
        if(!EnumStandardFormats(pwfxFormat, pwfxFormat))
        {
            // If none of the formats worked, the device is probably allocated
            hr = DSERR_ALLOCATED;
        }
    }

    // Clean up
    MEMFREE(pwfxFormat);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCAPS structure with the capabilities of the device.
 *
 *  Arguments:
 *      LPDSCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::GetCaps"

HRESULT CEmRenderDevice::GetCaps(LPDSCAPS pCaps)
{
    HRESULT                     hr  = DS_OK;
    WAVEOUTCAPS                 woc;
    MMRESULT                    mmr;

    DPF_ENTER();

    ASSERT(sizeof(*pCaps) == pCaps->dwSize);

    // Query the waveOut device
    mmr = waveOutGetDevCaps(m_pDeviceDescription->m_uWaveDeviceId, &woc, sizeof(woc));
    hr = MMRESULTtoHRESULT(mmr);

    if(SUCCEEDED(hr))
    {
        ZeroMemoryOffset(pCaps, pCaps->dwSize, sizeof(pCaps->dwSize));

        if(woc.dwFormats & WAVE_FORMAT_1M08 || woc.dwFormats & WAVE_FORMAT_2M08 || woc.dwFormats & WAVE_FORMAT_4M08)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARYMONO | DSCAPS_PRIMARY8BIT;
        }

        if(woc.dwFormats & WAVE_FORMAT_1S08 || woc.dwFormats & WAVE_FORMAT_2S08 || woc.dwFormats & WAVE_FORMAT_4S08)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARYSTEREO | DSCAPS_PRIMARY8BIT;
        }

        if(woc.dwFormats & WAVE_FORMAT_1M16 || woc.dwFormats & WAVE_FORMAT_2M16 || woc.dwFormats & WAVE_FORMAT_4M16)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARYMONO | DSCAPS_PRIMARY16BIT;
        }

        if(woc.dwFormats & WAVE_FORMAT_1S16 || woc.dwFormats & WAVE_FORMAT_2S16 || woc.dwFormats & WAVE_FORMAT_4S16)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARYSTEREO | DSCAPS_PRIMARY16BIT;
        }

        pCaps->dwFlags |= DSCAPS_EMULDRIVER;
        pCaps->dwMinSecondarySampleRate = DSBFREQUENCY_MIN;
        pCaps->dwMaxSecondarySampleRate = DSBFREQUENCY_MAX;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreatePrimaryBuffer
 *
 *  Description:
 *      Creates a primary buffer object.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      LPVOID [in]: buffer instace identifier.
 *      CPrimaryRenderWaveBuffer ** [out]: receives pointer to primary buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::CreatePrimaryBuffer"

HRESULT CEmRenderDevice::CreatePrimaryBuffer(DWORD dwFlags, LPVOID pvInstance, CPrimaryRenderWaveBuffer **ppBuffer)
{
    CEmPrimaryRenderWaveBuffer *    pBuffer = NULL;
    HRESULT                         hr      = DS_OK;

    DPF_ENTER();

    // Create a new primary buffer wrapper object
    pBuffer = NEW(CEmPrimaryRenderWaveBuffer(this, pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  LockMixerDestination
 *
 *  Description:
 *      Locks the mixer destination for writes.
 *
 *  Arguments:
 *      DWORD [in]: starting position.
 *      DWORD [in]: amount to lock.
 *      LPVOID * [out]: receives first lock pointer.
 *      LPDWORD [out]: receives first lock size.
 *      LPVOID * [out]: receives second lock pointer.
 *      LPDWORD [out]: receives second lock size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::LockMixerDestination"

HRESULT CEmRenderDevice::LockMixerDestination(DWORD ibLock, DWORD cbLock, LPVOID *ppvLock1, LPDWORD pcbLock1, LPVOID *ppvLock2, LPDWORD pcbLock2)
{
    CWeGrDest *             pWeGrDest   = (CWeGrDest *)m_pMixDest;
    HRESULT                 hr;

    DPF_ENTER();

    hr = pWeGrDest->Lock(ppvLock1, (int *)pcbLock1, ppvLock2, (int *)pcbLock2, ibLock, min(cbLock, (DWORD)pWeGrDest->m_cbBuffer));

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  UnlockMixerDestination
 *
 *  Description:
 *      Unlocks the mixer destination for writes.
 *
 *  Arguments:
 *      LPVOID [in]: first lock pointer.
 *      DWORD [in]: first lock size.
 *      LPVOID [in]: second lock pointer.
 *      DWORD [in]: second lock size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::UnlockMixerDestination"

HRESULT CEmRenderDevice::UnlockMixerDestination(LPVOID pvLock1, DWORD cbLock1, LPVOID pvLock2, DWORD cbLock2)
{
    CWeGrDest *             pWeGrDest   = (CWeGrDest *)m_pMixDest;
    HRESULT                 hr;

    DPF_ENTER();

    hr = pWeGrDest->Unlock(pvLock1, cbLock1, pvLock2, cbLock2);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  EnumStandardFormatsCallback
 *
 *  Description:
 *      Callback function for EnumStandardFormats called from Initialize.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: format.
 *
 *  Returns:
 *      BOOL: TRUE to continue enumerating.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmRenderDevice::EnumStandardFormatsCallback"

BOOL CEmRenderDevice::EnumStandardFormatsCallback(LPCWAVEFORMATEX pwfx)
{
    CWeGrDest *             pMixDest;
    HRESULT                 hr;

    DPF_ENTER();

    // Create the mixer destination
    pMixDest = NEW(CWeGrDest(m_pDeviceDescription->m_uWaveDeviceId));
    hr = HRFROMP(pMixDest);

    // Attempt to create the mixer
    if SUCCEEDED(hr)
    {
        hr = CreateMixer(pMixDest, pwfx);
    }

    // Clean up after failures
    if (FAILED(hr))
    {
        // If we failed to create the mixer, then clean up the pMixDest.
        // we don't have to free the mixer; if CreateMixer had succeeded
        // we wouldn't be in this if-block.

        // We don't have to free the pMixDest, because if CreateMixer fails
        // it frees pMixDest.  This is a bit messy.  The object that
        // allocates the resource should be the one to free it.
        if (pMixDest)
        {
            pMixDest = NULL;
        }
    }

    DPF_LEAVE(FAILED(hr));

    return FAILED(hr);
}


/***************************************************************************
 *
 *  CEmPrimaryRenderWaveBuffer
 *
 *  Description:
 *      Emulated device primary wave buffer constructor.
 *
 *  Arguments:
 *      CEmRenderDevice * [in]: parent device.
 *      LPVOID [in]: instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::CEmPrimaryRenderWaveBuffer"

CEmPrimaryRenderWaveBuffer::CEmPrimaryRenderWaveBuffer(CEmRenderDevice *pEmDevice, LPVOID pvInstance)
    : CPrimaryRenderWaveBuffer(pEmDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEmPrimaryRenderWaveBuffer);

    // Initialize defaults
    m_pEmDevice = pEmDevice;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEmPrimaryRenderWaveBuffer
 *
 *  Description:
 *      Emulated device primary wave buffer destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::~CEmPrimaryRenderWaveBuffer"

CEmPrimaryRenderWaveBuffer::~CEmPrimaryRenderWaveBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CEmPrimaryRenderWaveBuffer);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::Initialize"

HRESULT CEmPrimaryRenderWaveBuffer::Initialize(DWORD dwFlags)
{
    VADRBUFFERDESC          vrbd;
    HRESULT                 hr;

    DPF_ENTER();

    ZeroMemory(&vrbd, sizeof(vrbd));

    vrbd.dwFlags = dwFlags | DSBCAPS_LOCSOFTWARE;

    hr = CPrimaryRenderWaveBuffer::Initialize(&vrbd, NULL);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Gets capabilities for the device.
 *
 *  Arguments:
 *      LPVADRBUFFERCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::GetCaps"

HRESULT CEmPrimaryRenderWaveBuffer::GetCaps(LPVADRBUFFERCAPS pCaps)
{
    CWeGrDest *             pWeGrDest   = (CWeGrDest *)m_pEmDevice->m_pMixDest;
    HRESULT                 hr;

    DPF_ENTER();

    hr = CRenderWaveBuffer::GetCaps(pCaps);

    if(SUCCEEDED(hr))
    {
        pCaps->dwBufferBytes = pWeGrDest->m_cbBuffer;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RequestWriteAccess
 *
 *  Description:
 *      Requests write access to the primary buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to request primary access, FALSE to relenquish it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::RequestWriteAccess"

HRESULT CEmPrimaryRenderWaveBuffer::RequestWriteAccess(BOOL)
{
    DPF_ENTER();

    // WRITEPRIMARY isn't good in the WeGrDest
    RPF(DPFLVL_ERROR, "The emulated device does not support WRITEPRIMARY");

    DPF_LEAVE_HRESULT(DSERR_UNSUPPORTED);

    return DSERR_UNSUPPORTED;
}


/***************************************************************************
 *
 *  CommitToDevice
 *
 *  Description:
 *      Commits changed buffer wave data to the device.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the system memory buffer of the changed
 *                  data.
 *      DWORD [in]: size, in bytes, of the changed data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::CommitToDevice"

HRESULT CEmPrimaryRenderWaveBuffer::CommitToDevice(DWORD ibCommit, DWORD cbCommit)
{
    ASSERT(FALSE);
    return DSERR_UNSUPPORTED;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::GetState"

HRESULT CEmPrimaryRenderWaveBuffer::GetState(LPDWORD pdwState)
{
    DPF_ENTER();

    *pdwState = m_pEmDevice->m_dwMixerState;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::SetState"

HRESULT CEmPrimaryRenderWaveBuffer::SetState(DWORD dwState)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = m_pEmDevice->SetMixerState(dwState);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives play cursor position.
 *      LPDWORD [out]: receives write cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::GetCursorPosition"

HRESULT CEmPrimaryRenderWaveBuffer::GetCursorPosition(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    HRESULT                 hr;

    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    hr = m_pEmDevice->m_pMixDest->GetSamplePosition((int *)pdwPlay, (int *)pdwWrite);

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Create3dListener
 *
 *  Description:
 *      Creates the 3D listener.
 *
 *  Arguments:
 *      C3dListener ** [out]: receives pointer to the 3D listener object.
 *                            The caller is responsible for freeing this
 *                            object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmPrimaryRenderWaveBuffer::Create3dListener"

HRESULT CEmPrimaryRenderWaveBuffer::Create3dListener(C3dListener **pp3dListener)
{
    C3dListener *           p3dListener;
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_vrbd.dwFlags & DSBCAPS_CTRL3D);

    p3dListener = NEW(C3dListener);
    hr = HRFROMP(p3dListener);

    if(SUCCEEDED(hr))
    {
        *pp3dListener = p3dListener;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CEmSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CMxRenderDevice * [in]: parent device.
 *      LPVOID [in]: instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::CEmSecondaryRenderWaveBuffer"

CEmSecondaryRenderWaveBuffer::CEmSecondaryRenderWaveBuffer(CMxRenderDevice *pDevice, LPVOID pvInstance)
    : CSecondaryRenderWaveBuffer(pDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEmSecondaryRenderWaveBuffer);

    // Initialize defaults
    m_pMxDevice = pDevice;
    m_pMixSource = NULL;
    m_pFirContextLeft = NULL;
    m_pFirContextRight = NULL;
    m_dwState = VAD_BUFFERSTATE_STOPPED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEmSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::~CEmSecondaryRenderWaveBuffer"

CEmSecondaryRenderWaveBuffer::~CEmSecondaryRenderWaveBuffer(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CEmSecondaryRenderWaveBuffer);

    // Free the mixer source
    DELETE(m_pMixSource);

    // Free memory
    MEMFREE(m_pFirContextLeft);
    MEMFREE(m_pFirContextRight);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the wave buffer object.  If this function fails, the
 *      object should be immediately deleted.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      DWORD [in]: buffer size, in bytes.
 *      LPWAVEFORMATEX [in]: buffer format.
 *      CSecondaryRenderWaveBuffer * [in]: pointer to the buffer to
 *                                         duplicate from, or NULL to
 *                                         initialize as a new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::Initialize"

HRESULT CEmSecondaryRenderWaveBuffer::Initialize(LPCVADRBUFFERDESC pDesc, CEmSecondaryRenderWaveBuffer *pSource, CSysMemBuffer *pSysMemBuffer)
{
    HRESULT                         hr  = DS_OK;

    DPF_ENTER();

    ASSERT(LXOR(pDesc, pSource));

    // Validate the buffer description
    if(pDesc)
    {
        ASSERT(!(pDesc->dwFlags & DSBCAPS_PRIMARYBUFFER));

        if(pDesc->dwFlags & DSBCAPS_LOCHARDWARE)
        {
            RPF(DPFLVL_ERROR, "LOCHARDWARE specified for a software buffer");
            hr = DSERR_INVALIDCALL;
        }

        if(SUCCEEDED(hr) && !IsValidPcmWfx(pDesc->pwfxFormat))
        {
            hr = DSERR_BADFORMAT;
        }
    }

    // Initialize the base class
    if(SUCCEEDED(hr))
    {
        hr = CSecondaryRenderWaveBuffer::Initialize(pDesc, pSource, pSysMemBuffer);
    }

    // Set the software bit
    if(SUCCEEDED(hr))
    {
        m_vrbd.dwFlags |= DSBCAPS_LOCSOFTWARE;
    }

    // Fill in the default 3D algorithm
    if(SUCCEEDED(hr) && (m_vrbd.dwFlags & DSBCAPS_CTRL3D) && IS_NULL_GUID(&m_vrbd.guid3dAlgorithm))
    {
        m_vrbd.guid3dAlgorithm = *m_pMxDevice->GetDefault3dAlgorithm();
        DPF(DPFLVL_MOREINFO, "Using default 3D algorithm " DPF_GUID_STRING, DPF_GUID_VAL(m_vrbd.guid3dAlgorithm));
    }

    // Allocate FIR context for the mixer
    if(SUCCEEDED(hr))
    {
        m_pFirContextLeft = MEMALLOC(FIRCONTEXT);
        hr = HRFROMP(m_pFirContextLeft);
    }

    if(SUCCEEDED(hr))
    {
        m_pFirContextRight = MEMALLOC(FIRCONTEXT);
        hr = HRFROMP(m_pFirContextRight);
    }

    // Create the mixer source
    if(SUCCEEDED(hr))
    {
        m_pMixSource = NEW(CMixSource(m_pMxDevice->m_pMixer));
        hr = HRFROMP(m_pMixSource);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pMixSource->Initialize(m_pSysMemBuffer->GetPlayBuffer(), m_pSysMemBuffer->GetSize(), m_vrbd.pwfxFormat, &m_pFirContextLeft, &m_pFirContextRight);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Duplicate
 *
 *  Description:
 *      Duplicates the buffer.
 *
 *  Arguments:
 *      CSecondaryRenderWaveBuffer ** [out]: receives duplicate buffer.  Use
 *                                           Release to free this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::Duplicate"

HRESULT CEmSecondaryRenderWaveBuffer::Duplicate(CSecondaryRenderWaveBuffer **ppBuffer)
{
    CEmSecondaryRenderWaveBuffer *  pBuffer = NULL;
    HRESULT                         hr      = DS_OK;

    DPF_ENTER();

    pBuffer = NEW(CEmSecondaryRenderWaveBuffer(m_pMxDevice, m_pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(NULL, this, NULL);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitToDevice
 *
 *  Description:
 *      Commits changed buffer wave data to the device.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the system memory buffer of the changed
 *                  data.
 *      DWORD [in]: size, in bytes, of the changed data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::CommitToDevice"

HRESULT CEmSecondaryRenderWaveBuffer::CommitToDevice(DWORD ibCommit, DWORD cbCommit)
{
    DWORD                   ib[2];
    DWORD                   cb[2];

    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    // Signal a remix of this buffer
    ib[0] = ibCommit;

    if(ibCommit + cbCommit > m_pSysMemBuffer->GetSize())
    {
        cb[0] = m_vrbd.dwBufferBytes - ibCommit;
    }
    else
    {
        cb[0] = cbCommit;
    }

    ib[1] = 0;
    cb[1] = cbCommit - cb[0];

    m_pMixSource->Update(ib[0], cb[0], ib[1], cb[1]);

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::GetState"

HRESULT CEmSecondaryRenderWaveBuffer::GetState(LPDWORD pdwState)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    if(m_dwState & VAD_BUFFERSTATE_STARTED)
    {
        if(!m_pMixSource->IsPlaying())
        {
            m_dwState = VAD_BUFFERSTATE_STOPPED;
        }
    }

    *pdwState = m_dwState;

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetState"

HRESULT CEmSecondaryRenderWaveBuffer::SetState(DWORD dwState)
{
    static const DWORD dwValidMask = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING | VAD_BUFFERSTATE_SUSPEND;
    DPF_ENTER();

    ASSERT(IS_VALID_FLAGS(dwState, dwValidMask));

    ENTER_MIXER_MUTEX();

    if(dwState & VAD_BUFFERSTATE_SUSPEND)
    {
        ASSERT((dwState & VAD_BUFFERSTATE_SUSPEND) == VAD_BUFFERSTATE_SUSPEND);
        dwState = m_dwState ^ VAD_BUFFERSTATE_SUSPEND;
    }

    if(dwState & VAD_BUFFERSTATE_STARTED && !(dwState & VAD_BUFFERSTATE_SUSPEND))
    {
        m_pMixSource->Play(MAKEBOOL(dwState & VAD_BUFFERSTATE_LOOPING));
    }
    else
    {
        m_pMixSource->Stop();

        if(!(dwState & VAD_BUFFERSTATE_SUSPEND) && m_pMixSource->HasNotifications())
        {
            m_pMixSource->NotifyStop();
        }
    }

    m_dwState = dwState;
    LEAVE_MIXER_MUTEX();

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Retrieves the current play and write cursor positions.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the play position.
 *      LPDWORD [out]: receives the write position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::GetCursorPosition"

HRESULT CEmSecondaryRenderWaveBuffer::GetCursorPosition(LPDWORD pdwPlay, LPDWORD pdwWrite)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    if(m_vrbd.dwFlags & (DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_MIXIN | DSBCAPS_SINKIN | DSBCAPS_CTRLFX))
    {
        m_pMixSource->GetBytePosition((int *)pdwPlay, (int *)pdwWrite, NULL);
    }
    else
    {
        m_pMixSource->GetBytePosition1((int *)pdwPlay, (int *)pdwWrite);
    }

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetCursorPosition
 *
 *  Description:
 *      Sets the current play cursor position.
 *
 *  Arguments:
 *      DWORD [in]: play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetCursorPosition"

HRESULT CEmSecondaryRenderWaveBuffer::SetCursorPosition(DWORD dwPlay)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    ASSERT(dwPlay < m_vrbd.dwBufferBytes);

    m_pMixSource->SetBytePosition(dwPlay);

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the buffer frequency.
 *
 *  Arguments:
 *      DWORD [in]: new frequency.
 *      BOOL [in]: whether to clamp to the driver's supported frequency
 *                 range if the call fails.  Ignored in this class.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetFrequency"

HRESULT CEmSecondaryRenderWaveBuffer::SetFrequency(DWORD dwFrequency, BOOL)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    m_pMixSource->SetFrequency(dwFrequency);
    m_vrbd.pwfxFormat->nSamplesPerSec = dwFrequency;

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Mutes or unmutes the buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to mute the buffer, FALSE to restore it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetMute"

HRESULT CEmSecondaryRenderWaveBuffer::SetMute(BOOL fMute)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    m_pMixSource->m_fMute = fMute;

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Sets the attenuation for each channel.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetAttenuation"

HRESULT CEmSecondaryRenderWaveBuffer::SetAttenuation(PDSVOLUMEPAN pdsvp)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    m_pMixSource->SetVolumePan(pdsvp);

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


#ifdef FUTURE_MULTIPAN_SUPPORT
/***************************************************************************
 *
 *  SetChannelAttenuations
 *
 *  Description:
 *      Sets the multichannel attenuation for a given buffer.
 *
 *  Arguments:
 *      TBD.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetChannelAttenuations"

HRESULT CEmSecondaryRenderWaveBuffer::SetChannelAttenuations(LONG lVolume, DWORD dwChannelCount, const DWORD* pdwChannels, const LONG* plChannelVolumes)
{
    HRESULT                     hr   = DS_OK;
    LONG                        lPan;

    DPF_ENTER();

    if (dwChannelCount == 0)
    {
        // SetChannelVolume() has not been called yet; use center panning
        ASSERT(!pdwChannels && !plChannelVolumes);  // Sanity checking
        lPan = 0;
    }
    else
    {
        // Calculate a global LR pan value based on the channel volumes
        lPan = MultiChannelToStereoPan(dwChannelCount, pdwChannels, plChannelVolumes);
    }

    DSVOLUMEPAN dsvp;
    FillDsVolumePan(lVolume, lPan, &dsvp);
    m_pMixSource->SetVolumePan(&dsvp);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // FUTURE_MULTIPAN_SUPPORT


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::SetNotificationPositions"

HRESULT CEmSecondaryRenderWaveBuffer::SetNotificationPositions(DWORD dwCount, LPCDSBPOSITIONNOTIFY paNotes)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    m_pMixSource->SetNotificationPositions(dwCount, paNotes);

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  Create3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      REFGUID [in]: 3D algorithm GUID.
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::Create3dObject"

HRESULT CEmSecondaryRenderWaveBuffer::Create3dObject(C3dListener *p3dListener, C3dObject **pp3dObject)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(m_vrbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_vrbd.dwFlags & DSBCAPS_CTRL3D);
    ASSERT(IsValid3dAlgorithm(m_vrbd.guid3dAlgorithm));

    m_hrSuccessCode = DS_OK;

    if(DS3DALG_ITD == m_vrbd.guid3dAlgorithm)
    {
        hr = CreateItd3dObject(p3dListener, pp3dObject);
    }
    else
    {
        // No matter whether the 3D algorithm requested is No Virtualization (Pan3D)
        // or one of the unsupported HRTF algorithms, we just do Pan3D.  If HRTF had
        // been requested, we return DS_NO_VIRTUALIZATION (as per manbug 23196).
        if (DS3DALG_NO_VIRTUALIZATION != m_vrbd.guid3dAlgorithm)
        {
            m_hrSuccessCode = DS_NO_VIRTUALIZATION;
            DPF(DPFLVL_INFO, "Replaced unsupported 3D algorithm " DPF_GUID_STRING " with Pan3D", DPF_GUID_VAL(m_vrbd.guid3dAlgorithm));
        }
        hr = CreatePan3dObject(p3dListener, fMute3dAtMaxDistance, m_vrbd.pwfxFormat->nSamplesPerSec, pp3dObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateItd3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmSecondaryRenderWaveBuffer::CreateItd3dObject"

HRESULT CEmSecondaryRenderWaveBuffer::CreateItd3dObject(C3dListener *p3dListener, C3dObject **pp3dObject)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(m_vrbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    const BOOL              fDopplerEnabled         = !MAKEBOOL((m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN));
    CEmItd3dObject *        p3dObject;
    HRESULT                 hr;

    DPF_ENTER();

    p3dObject = NEW(CEmItd3dObject(p3dListener, fMute3dAtMaxDistance, fDopplerEnabled, m_vrbd.pwfxFormat->nSamplesPerSec, m_pMixSource, m_pMxDevice->m_pMixDest, m_pFirContextLeft, m_pFirContextRight));
    hr = HRFROMP(p3dObject);

    if(SUCCEEDED(hr))
    {
        hr = p3dObject->Initialize();
    }

    if(SUCCEEDED(hr))
    {
        *pp3dObject = p3dObject;
    }
    else
    {
        RELEASE(p3dObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CEmItd3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      C3dListener * [in]: pointer to the owning listener.
 *      DWORD [in]: buffer frequency.
 *      CMixSource * [in]: mixer source used by the owning buffer.
 *      PFIRCONTEXT [in]: left channel FIR context.
 *      PFIRCONTEXT [in]: right channel FIR context.
 *      BOOL [in]: TRUE to mute at max distance.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmItd3dObject::CEmItd3dObject"

CEmItd3dObject::CEmItd3dObject(C3dListener *pListener, BOOL fMuteAtMaxDistance, BOOL fDopplerEnabled,
                               DWORD dwFrequency, CMixSource *pMixSource, CMixDest *pMixDest,
                               PFIRCONTEXT pContextLeft, PFIRCONTEXT pContextRight)
    : CItd3dObject(pListener, fMuteAtMaxDistance, fDopplerEnabled, dwFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEmItd3dObject);

    // Initialize defaults
    m_pMixSource = pMixSource;
    m_pMixDest = pMixDest;
    m_pContextLeft = pContextLeft;
    m_pContextRight = pContextRight;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEmItd3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmItd3dObject::~CEmItd3dObject"

CEmItd3dObject::~CEmItd3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CItd3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Commit3dChanges
 *
 *  Description:
 *      Writes updated 3D data to the device.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmItd3dObject::Commit3dChanges"

HRESULT CEmItd3dObject::Commit3dChanges(void)
{
    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    // Apply changed FIR data
    m_pContextLeft->fLeft = TRUE;
    m_pContextRight->fLeft = FALSE;

    CvtContext(&m_ofcLeft, m_pContextLeft);
    CvtContext(&m_ofcRight, m_pContextRight);

    // Turn the filter on or off and set proper frequency
    if(DS3DMODE_DISABLE == m_opCurrent.dwMode)
    {
        m_pMixSource->FilterOff();
        if (m_fDopplerEnabled)
            m_pMixSource->SetFrequency(m_dwUserFrequency);
    }
    else
    {
        m_pMixSource->FilterOn();
        if (m_fDopplerEnabled)
            m_pMixSource->SetFrequency(m_dwDopplerFrequency);
    }

    // If 3D is enabled, and the user wants to mute at max distance AND
    // we're at max distance, mute.  Otherwise, unmute.
    m_pMixSource->m_fMute3d = IsAtMaxDistance();

    // Signal a remix
    m_pMixSource->SignalRemix();

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  CvtContext
 *
 *  Description:
 *      Converts an OBJECT_ITD_CONTEXT to a FIRCONTEXT.
 *
 *  Arguments:
 *      LPOBJECTFIRCONTEXT [in]: source.
 *      PFIRCONTEXT [out]: destination.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmItd3dObject::CvtContext"

void CEmItd3dObject::CvtContext(LPOBJECT_ITD_CONTEXT pSource, PFIRCONTEXT pDest)
{
    DPF_ENTER();

    pDest->DistAttenuation = pSource->flDistanceAttenuation;
    pDest->ConeAttenuation = pSource->flConeAttenuation;
    pDest->ConeShadow = pSource->flConeShadow;
    pDest->PositionAttenuation = pSource->flPositionAttenuation;
    pDest->PositionShadow = pSource->flPositionShadow;
    pDest->VolSmoothScale = pSource->flVolSmoothScale;
    pDest->VolSmoothScaleRecip = pSource->flVolSmoothScaleRecip;
    pDest->VolSmoothScaleDry = pSource->flVolSmoothScaleDry;
    pDest->VolSmoothScaleWet = pSource->flVolSmoothScaleWet;
    pDest->iSmoothFreq = pSource->dwSmoothFreq;
    pDest->iDelay = pSource->dwDelay;

    pDest->TotalDryAttenuation = pSource->flPositionAttenuation * pSource->flConeAttenuation * pSource->flConeShadow * pSource->flPositionShadow;
    pDest->LastDryAttenuation = pDest->TotalDryAttenuation;

    pDest->TotalWetAttenuation = pSource->flPositionAttenuation * pSource->flConeAttenuation * (1.0f - pSource->flConeShadow * pSource->flPositionShadow);
    pDest->LastWetAttenuation = pDest->TotalWetAttenuation;

#ifdef SMOOTH_ITD

    pDest->iLastDelay = pDest->iDelay;

#endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Get3dOutputSampleRate
 *
 *  Description:
 *      Gets the sample rate of the final output.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmItd3dObject::Get3dOutputSampleRate"

DWORD CEmItd3dObject::Get3dOutputSampleRate(void)
{
    DWORD freq;

    DPF_ENTER();

    freq = m_pMixDest->GetFrequency();

    DPF_LEAVE(freq);

    return freq;
}


/***************************************************************************
 *
 *  CEmCaptureDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::CEmCaptureDevice"

CEmCaptureDevice::CEmCaptureDevice()
    : CCaptureDevice(VAD_DEVICETYPE_EMULATEDCAPTURE)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEmCaptureDevice);

    // Initialize defaults
    m_pwfxFormat    = NULL;
    m_hwi           = NULL;

    m_fAllocated    = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEmCaptureDevice
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::~CEmCaptureDevice"

CEmCaptureDevice::~CEmCaptureDevice()
{
    DPF_ENTER();
    DPF_DESTRUCT(CEmCaptureDevice);

    if (m_hwi)
        CloseWaveIn(&m_hwi);

    // Free memory
    MEMFREE(m_pwfxFormat);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EnumDrivers
 *
 *  Description:
 *      Creates a list of driver GUIDs that can be used to initialize this
 *      device.
 *
 *  Arguments:
 *      CList& [in/out]: pointer to a CList object that will be filled with
 *                       CDeviceDescription objects.  The caller is
 *                       responsible for freeing these objects.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::EnumDrivers"

HRESULT CEmCaptureDevice::EnumDrivers(CObjectList<CDeviceDescription> *plstDrivers)
{
    CDeviceDescription *    pDesc                   = NULL;
    LPTSTR                  pszInterface            = NULL;
    HRESULT                 hr                      = DS_OK;
    TCHAR                   szTemplate[0x100];
    TCHAR                   szEmulated[0x100];
    TCHAR                   szName[0x400];
    UINT                    cDevices;
    BYTE                    bDeviceId;
    WAVEINCAPS              wic;
    GUID                    guid;
    MMRESULT                mmr;

    DPF_ENTER();

    // LIMITATION: We can't support more than 0xFF emulated devices,
    // because we pack the device ID into a byte member of a GUID.
    cDevices = waveInGetNumDevs();
    cDevices = NUMERIC_CAST(cDevices, BYTE);

    // Load string templates
    if(!LoadString(hModule, IDS_DSC_DRIVERLD, szTemplate, NUMELMS(szTemplate)))
    {
        DPF(DPFLVL_ERROR, "Can't load driver template string");
        hr = DSERR_OUTOFMEMORY;
    }

    if(SUCCEEDED(hr) && !LoadString(hModule, IDS_EMULATED, szEmulated, NUMELMS(szEmulated)))
    {
        DPF(DPFLVL_ERROR, "Can't load emulated template string");
        hr = DSERR_OUTOFMEMORY;
    }

    // Enumerate each waveOut device and add it to the list
    for(bDeviceId = 0; bDeviceId < cDevices && SUCCEEDED(hr); bDeviceId++)
    {
        // Get the driver GUID
        g_pVadMgr->GetDriverGuid(m_vdtDeviceType, bDeviceId, &guid);

        // Create the device description object
        pDesc = NEW(CDeviceDescription(m_vdtDeviceType, guid, bDeviceId));
        hr = HRFROMP(pDesc);

        // Get the device name
        if(SUCCEEDED(hr))
        {
            mmr = waveInGetDevCaps(bDeviceId, &wic, sizeof(wic));
            hr = MMRESULTtoHRESULT(mmr);
        }

        if(SUCCEEDED(hr))
        {
            lstrcpy(szName, wic.szPname);
            lstrcat(szName, szEmulated);
        }

        if(SUCCEEDED(hr))
        {
            pDesc->m_strName = szName;
        }

        // Get the device path
        if(SUCCEEDED(hr))
        {
            wsprintf(szName, szTemplate, bDeviceId);
            pDesc->m_strPath = szName;
        }

        // Get the device interface
        if(SUCCEEDED(hr))
        {
            GetWaveDeviceInterface(bDeviceId, FALSE, &pszInterface);
            pDesc->m_strInterface = pszInterface;
        }

        // Get the device devnode
        if(SUCCEEDED(hr))
        {
            GetWaveDeviceDevnode(bDeviceId, FALSE, &pDesc->m_dwDevnode);
        }

        // Add the driver to the list
        if(SUCCEEDED(hr))
        {
            hr = HRFROMP(plstDrivers->AddNodeToList(pDesc));
        }

        // Clean up
        MEMFREE(pszInterface);
        RELEASE(pDesc);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the device.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: driver description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::Initialize"

HRESULT CEmCaptureDevice::Initialize(CDeviceDescription *pDesc)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Initialize the base class
    hr = CCaptureDevice::Initialize(pDesc);

    // Get the default format
    if(SUCCEEDED(hr))
    {
        m_pwfxFormat = AllocDefWfx();
        hr = HRFROMP(m_pwfxFormat);
    }

    if(SUCCEEDED(hr))
    {
        if(!EnumStandardFormats(m_pwfxFormat, m_pwfxFormat))
        {
            // If none of the formats worked, assume the device is allocated
            hr = DSERR_ALLOCATED;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCCAPS structure with the capabilities of the device.
 *
 *  Arguments:
 *      LPDSCCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::GetCaps"

HRESULT CEmCaptureDevice::GetCaps(LPDSCCAPS pCaps)
{
    WAVEINCAPS                  wic;
    MMRESULT                    mmr;
    HRESULT                     hr;

    DPF_ENTER();

    // Query the waveIn device
    mmr = waveInGetDevCaps(m_pDeviceDescription->m_uWaveDeviceId, &wic, sizeof(wic));
    hr = MMRESULTtoHRESULT(mmr);

    if(SUCCEEDED(hr))
    {
        pCaps->dwFlags = DSCCAPS_EMULDRIVER;
        pCaps->dwFormats = wic.dwFormats;
        pCaps->dwChannels = wic.wChannels;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateBuffer
 *
 *  Description:
 *      Creates a capture wave buffer.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      DWORD [in]: buffer size, in bytes.
 *      LPCWAVEFORMATEX [in]: buffer format.
 *      CCaptureWaveBuffer ** [out]: receives pointer to new wave buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::CreateBuffer"

HRESULT CEmCaptureDevice::CreateBuffer
(
    DWORD dwFlags,
    DWORD dwBufferBytes,
    LPCWAVEFORMATEX pwfxFormat,
    CCaptureEffectChain*,
    LPVOID pvInstance,
    CCaptureWaveBuffer** ppBuffer
)
{
    CEmCaptureWaveBuffer *  pBuffer = NULL;
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    if (m_lstBuffers.GetListHead())
    {
        hr = DSERR_ALLOCATED;
    }

    if (SUCCEEDED(hr))
    {
        #pragma warning(disable:4530)  // Disable the nag about compiling with -GX
        try
        {
            pBuffer = NEW(CEmCaptureWaveBuffer(this));
        }
        catch (...)
        {
            // This exception handler is silly, since it makes us leak the memory
            // allocated for CEmCaptureWaveBuffer above (which wasn't assigned to
            // pBuffer yet), and also possibly m_cs, which is something we really
            // don't want to do if we're low on memory in the first place.
            //
            // But InitializeCriticalSection is supposed to be fixed in Blackcomb
            // not to throw exceptions any more, so we can live with this for now.

            ASSERT(pBuffer == NULL);
            ASSERT(!"InitializeCriticalSection() threw an exception");
        }

        hr = HRFROMP(pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(dwFlags, dwBufferBytes, pwfxFormat);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetGlobalFormat
 *
 *  Description:
 *      Makes the specified WFX, the format for the capture buffer
 *
 *  Arguments:
 *      LPVOID [in] : pointer to the owner of the format
 *      LPCWAVEFORMATEX [in] : pointer to the new WFX to use
 *      DWORD [in]: callback, if any.
 *      DWORD [in]: flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::SetGlobalFormat"

HRESULT CEmCaptureDevice::SetGlobalFormat(LPVOID pOwner, LPCWAVEFORMATEX pwfx, LPVOID pvCallback, DWORD dwFlags)
{
    DPF_ENTER();

    DWORD       fdwOpen = 0;
    LPHWAVEIN   phw = &m_hwi;

    // Should we attempt to use the WAVE_MAPPER?
    if (DSCBCAPS_WAVEMAPPED & dwFlags)
    {
        fdwOpen |= WAVE_MAPPED;
    }

    // We don't allocate the device on focus aware buffers.
    if (DSCBCAPS_FOCUSAWARE & dwFlags)
    {
        fdwOpen |= WAVE_FORMAT_QUERY;
        phw = NULL;
    }
    else
    {
        fdwOpen |= (pvCallback ? CALLBACK_FUNCTION : CALLBACK_NULL);

        // The reason why we had to close the device if open, is that
        // EnumStandardFormatsCallback() used to allocate the device.
        // It no longer does so as of DX 7.1 and thus we can ax this
        // close.  If the device is allocated, it is REALLY in use.
    }

    HRESULT hr = OpenWaveIn(phw, m_pDeviceDescription->m_uWaveDeviceId, pwfx, (DWORD_PTR)pvCallback, (DWORD_PTR)pOwner, fdwOpen);

    if (FAILED(hr))
    {
        // Oops.  Try to get the device back with the old format.
        OpenWaveIn(phw, m_pDeviceDescription->m_uWaveDeviceId, m_pwfxFormat, (DWORD_PTR)pvCallback, (DWORD_PTR)pOwner, fdwOpen);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  EnumStandardFormatsCallback
 *
 *  Description:
 *      Callback function for EnumStandardFormats used when calling
 *      Initialize.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: format.
 *
 *  Returns:
 *      BOOL: TRUE to continue enumerating.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureDevice::EnumStandardFormatsCallback"

BOOL CEmCaptureDevice::EnumStandardFormatsCallback(LPCWAVEFORMATEX pwfx)
{
    DPF_ENTER();

    HRESULT hr = OpenWaveIn(NULL, m_pDeviceDescription->m_uWaveDeviceId, pwfx, 0, 0, WAVE_FORMAT_QUERY);

    DPF_LEAVE(FAILED(hr));
    return FAILED(hr);
}


/***************************************************************************
 *
 *  CEmCaptureWaveBuffer
 *
 *  Description:
 *      Constructor for CEmCaptureWaveBuffer
 *
 *  Arguments:
 *      CCaptureVad [in]: parent object.
 *
 *  Returns:
 *      Nothing
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::CEmCaptureWaveBuffer"

CEmCaptureWaveBuffer::CEmCaptureWaveBuffer(CCaptureDevice *pDevice) : CCaptureWaveBuffer(pDevice)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CEmCaptureWaveBuffer);

    ASSERT(0 == m_dwState);
    ASSERT(0 == m_fdwSavedState);

    ASSERT(0 == m_cwhdr);
    ASSERT(NULL == m_rgpwhdr);
    ASSERT(0 == m_cwhdrDone);
    ASSERT(0 == m_iwhdrDone);

    ASSERT(NULL == m_pBuffer);
    ASSERT(0 == m_cbBuffer);
    ASSERT(0 == m_cbRecordChunk);
    ASSERT(NULL == m_pBufferMac);
    ASSERT(NULL == m_pBufferNext);
    ASSERT(0 == m_cLoops);
    ASSERT(NULL == m_pwfx);
    ASSERT(NULL == m_hwi);

    ASSERT(0 == m_cpn);
    ASSERT(NULL == m_rgpdsbpn);
    ASSERT(0 == m_ipn);
    ASSERT(0 == m_cpnAllocated);

    m_fCritSectsValid = FALSE;
    InitializeCriticalSection(&m_cs);
    InitializeCriticalSection(&m_csPN);
    m_fCritSectsValid = TRUE;

    ASSERT(0 == m_dwCaptureCur);
    ASSERT(0 == m_dwCaptureLast);
    ASSERT(NULL == m_hThread);
    ASSERT(NULL == m_rghEvent[0]);
    ASSERT(NULL == m_rghEvent[chEvents-1]);

    ASSERT(0 == m_cwhdrDropped);
    ASSERT(NULL == m_pBufferProcessed);

    #ifdef DEBUG_CAPTURE
    ASSERT(0 == m_iwhdrExpected);
    #endif

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CEmCaptureWaveBuffer
 *
 *  Description:
 *      Destructor for CEmCaptureWaveBuffer
 *
 *  Arguments:
 *      None
 *
 *  Returns:
 *      Nothing
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::~CEmCaptureWaveBuffer"

CEmCaptureWaveBuffer::~CEmCaptureWaveBuffer()
{
    DPF_ENTER();
    DPF_DESTRUCT(CEmCaptureWaveBuffer);

    // If critical section(s) not intialized, nothing else did either
    if (!m_fCritSectsValid)
    {
        return;
    }

    // Set the Terminate Event so the capture thread will die
    if (m_rghEvent[ihEventTerminate])
    {
        SetEvent(m_rghEvent[ihEventTerminate]);
    }

    // Wait for the thread to die, then clean up
    if (m_hThread)
    {
        WaitObject(INFINITE, m_hThread);
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }

    // Clean up our HEVENTs - set them to NULL in case
    // the waveInOpen callback retires some buffers.
    for (int ihEvent = chEvents-1; ihEvent >= 0; --ihEvent)
    {
        if (m_rghEvent[ihEvent])
        {
            HANDLE h = m_rghEvent[ihEvent];
            m_rghEvent[ihEvent] = NULL;
            CloseHandle(h);
        }
    }

    if (m_hwi)
    {
        // Ignore errors since it's too late to do anything
        waveInReset(m_hwi);

        // Stop recording from input device, if we got cutoff
        if (m_dwState & VAD_BUFFERSTATE_STARTED)
        {
            waveInStop(m_hwi);
        }

        // Need to unprepare all the headers
        if (m_rgpwhdr)
        {
            int iwhdr;
            LPWAVEHDR pwhdr;

            for (iwhdr = m_cwhdr, pwhdr = m_rgpwhdr;
                 iwhdr > 0; --iwhdr, ++pwhdr)
            {
                if (WHDR_PREPARED & pwhdr->dwFlags)
                {
                    waveInUnprepareHeader(m_hwi, pwhdr, sizeof(WAVEHDR));
                }
            }
        }

        // Close the input device
        CloseWaveIn(&m_hwi);

        // If this is not focus aware, mark device as unallocated.
        if (!(m_dwFlags & DSCBCAPS_FOCUSAWARE) && m_pDevice)
        {
            ((CEmCaptureDevice *)m_pDevice)->m_fAllocated = FALSE;
            ((CEmCaptureDevice *)m_pDevice)->m_hwi        = NULL;
        }
    }

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    EnterCriticalSection(&m_cs);

    MEMFREE(m_pwfx);
    MEMFREE(m_rgpwhdr);
    MEMFREE(m_rgpdsbpn);

    LeaveCriticalSection(&m_cs);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    m_fCritSectsValid = FALSE;
    DeleteCriticalSection(&m_csPN);
    DeleteCriticalSection(&m_cs);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes CEmCaptureWaveBuffer object
 *
 *  Arguments:
 *      DWORD [in] : flags
 *      DWORD [in] : size of buffer in bytes
 *      LPCWAVEFORMATEX [in] : format for buffer
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::Initialize"

HRESULT CEmCaptureWaveBuffer::Initialize(DWORD dwFlags, DWORD dwBufferBytes, LPCWAVEFORMATEX pwfxFormat)
{
    HRESULT hr;

    DPF_ENTER();

    // Validate params
    if (!IS_VALID_READ_PTR(pwfxFormat, sizeof(WAVEFORMATEX)))
    {
        RPF(DPFLVL_ERROR, "Invalid wave format pointer");
        goto InvalidParam;
    }

    if(!IsValidWfx(pwfxFormat))
    {
        RPF(DPFLVL_ERROR, "Invalid wave format");
        goto InvalidParam;
    }

    if (pwfxFormat->nBlockAlign == 0 ||
        dwBufferBytes < pwfxFormat->nBlockAlign ||
        dwBufferBytes % pwfxFormat->nBlockAlign != 0)
    {
        RPF(DPFLVL_ERROR, "Invalid buffer size (must be a multiple of nBlockAlign)");
        goto InvalidParam;
    }

    if (~DSCBCAPS_VALIDFLAGS & dwFlags)
    {
        RPF(DPFLVL_ERROR, "Invalid DSCBCAPS flags");
        goto InvalidParam;
    }

    if (DSCBCAPS_CTRLFX & dwFlags)
    {
        RPF(DPFLVL_ERROR, "DSBCAPS_CTRLFX not allowed on emulated capture device");
        goto InvalidParam;
    }

    m_dwFlags = dwFlags;

    // Make a copy of the wave format
    m_pwfx = CopyWfxAlloc(pwfxFormat);
    if (NULL == m_pwfx)
    {
        DPF(DPFLVL_ERROR, "Unable to allocate WFX");
        hr = DSERR_OUTOFMEMORY;
        goto Error;
    }

    hr = CCaptureWaveBuffer::Initialize(dwBufferBytes);
    if (FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "Unable to initialize CCaptureWaveBuffer");
        goto Error;
    }

    // Make a copy of important info
    m_cbBuffer = m_pSysMemBuffer->GetSize();
    m_pBufferProcessed = m_pBufferNext = m_pBuffer = m_pSysMemBuffer->GetWriteBuffer();

    // Calculate the end of the buffer
    m_pBufferMac = m_pBuffer + m_cbBuffer;

    // Record Chunk should be 10 ms long to match the IRP sizes used by kmixer
    m_cbRecordChunk = m_pwfx->nAvgBytesPerSec / 32;

    // Round up to multiple of nBlockAlign (required for waveInAddBuffer recording)
    m_cbRecordChunk = BLOCKALIGNPAD(m_cbRecordChunk, m_pwfx->nBlockAlign);

    ASSERT(sizeof(m_rgszEvent[ihEventFocusChange]) >= 7+8+8+1);
    wsprintf(m_rgszEvent[ihEventFocusChange], TEXT("DSC-EFC%08lX%08lX"), GetCurrentProcessId(), this);

    ASSERT(sizeof(m_rgszEvent[ihEventWHDRDone]) >= 7+8+8+1);
    wsprintf(m_rgszEvent[ihEventWHDRDone], TEXT("DSC-EWD%08lX%08lX"), GetCurrentProcessId(), this);

    ASSERT(sizeof(m_rgszEvent[ihEventTerminate]) >= 6+8+8+1);
    wsprintf(m_rgszEvent[ihEventTerminate], TEXT("DSC-ET%08lX%08lX"), GetCurrentProcessId(), this);

    ASSERT(sizeof(m_rgszEvent[ihEventThreadStart]) >= 7+8+8+1);
    wsprintf(m_rgszEvent[ihEventThreadStart], TEXT("DSC-ETS%08lX%08lX"), GetCurrentProcessId(), this);

    // The first two events we want to be auto-reset
    // The third event, we want to stay signaled until reset
    static const BOOL rgfEvent[chEvents] = {FALSE, FALSE, FALSE, TRUE};

    for (int ihEvent = 0; ihEvent < chEvents; ++ihEvent)
    {
        m_rghEvent[ihEvent] = CreateEvent(NULL, rgfEvent[ihEvent], FALSE, m_rgszEvent[ihEvent]);
        if (NULL == m_rghEvent[ihEvent])
        {
            RPF(DPFLVL_ERROR, "Unable to create event");
            hr = WIN32ERRORtoHRESULT(GetLastError());
            goto Error;
        }
    }

    // Attempt to set the selected format
    CEmCaptureDevice *pDevice = (CEmCaptureDevice *)m_pDevice;
    hr = pDevice->SetGlobalFormat(this, m_pwfx, waveInCallback, dwFlags);
    m_hwi = pDevice->HWaveIn();

    if (FAILED(hr))
    {
        RPF(DPFLVL_ERROR, "Unable to set global device format");
        goto Error;
    }

    // Calculate number of blocks of size m_cbRecordChunk bytes
    m_cwhdr = m_cbBuffer / m_cbRecordChunk;

    // See if we have a partial-sized last block
    if (m_cbBuffer % m_cbRecordChunk)
        ++m_cwhdr;

    // Create at most cwhdrDefault WAVEHDRs
    if (m_cwhdr > cwhdrDefault)
        m_cwhdr = cwhdrDefault;

    ASSERT(m_cwhdr > 0);
    m_cwhdrDropped = m_cwhdr;

    // Allocate space for WAVEHDR arrays
    m_rgpwhdr = MEMALLOC_A(WAVEHDR, m_cwhdr);
    if (NULL == m_rgpwhdr)
    {
        DPF(DPFLVL_ERROR, "Unable to allocate WAVEHDRs");
        hr = DSERR_OUTOFMEMORY;
        goto Error;
    }

    // Create worker thread
    DWORD dwThreadID;
    m_hThread = CreateThread(NULL, 0, CEmCaptureWaveBuffer::CaptureThreadStatic, this, 0, &dwThreadID);
    if (NULL == m_hThread)
    {
        RPF(DPFLVL_ERROR, "Unable to create thread");
        hr = WIN32ERRORtoHRESULT(GetLastError());
        goto Error;
    }

    // If this is not focus aware, mark device as allocated.
    if (!(m_dwFlags & DSCBCAPS_FOCUSAWARE))
    {
        pDevice->m_fAllocated = TRUE;
    }

    hr = DS_OK;

Error:
    DPF_LEAVE_HRESULT(hr);
    return hr;

InvalidParam:
    hr = DSERR_INVALIDPARAM;
    goto Error;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Gets capabilities for the device.
 *
 *  Arguments:
 *      LPDSCBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::GetCaps"

HRESULT CEmCaptureWaveBuffer::GetCaps(LPDSCBCAPS pDsbcCaps)
{
    DPF_ENTER();

    ASSERT(sizeof(*pDsbcCaps) == pDsbcCaps->dwSize);

    pDsbcCaps->dwFlags = m_dwFlags;
    pDsbcCaps->dwBufferBytes = m_pSysMemBuffer->GetSize();
    pDsbcCaps->dwReserved = 0;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::GetState"

HRESULT CEmCaptureWaveBuffer::GetState(LPDWORD pdwState)
{
    DPF_ENTER();

    ASSERT(pdwState);

    *pdwState = m_dwState & VAD_SETSTATE_MASK;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Gets the current capture/read positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives capture cursor position.
 *      LPDWORD [out]: receives read cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::GetCursorPosition"

HRESULT CEmCaptureWaveBuffer::GetCursorPosition(LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition)
{
    HRESULT hr = DS_OK;
    DWORD dwRead;

    DPF_ENTER();

    if (!(DSCBCAPS_FOCUSAWARE & m_dwFlags))
    {
        // If we've successfully opened the waveIn device
        if (NULL == m_hwi)
        {
            hr = DSERR_INVALIDPARAM;
            goto Error;
        }
    }

    dwRead = ((m_dwCaptureCur + m_dwCaptureLast) % m_cbBuffer);

    // get the current positions
    if (pdwReadPosition)
    {
        *pdwReadPosition = dwRead;
    }

    if (pdwCapturePosition)
    {
        MMTIME      mmt;
        MMRESULT    mmr;

        //==========================================================//
        //                  Enter Critical section                  //
        //                                                          //
        EnterCriticalSection(&m_cs);

        if (m_hwi)
        {
            mmt.wType = TIME_BYTES;
            mmr = waveInGetPosition(m_hwi, &mmt, sizeof(mmt));
            if (MMSYSERR_NOERROR != mmr)
            {
                hr = MMRESULTtoHRESULT(mmr);
            }
            else
            {
                if ((TIME_BYTES == mmt.wType) && (m_dwState & VAD_BUFFERSTATE_STARTED))
                {
                    *pdwCapturePosition = ((mmt.u.cb + m_dwCaptureLast) % m_cbBuffer);
                }
                else
                {
                    // Don't know how to handle anything other than TIME_BYTES so
                    // we fall back to using the current valid recorded data offset
                    *pdwCapturePosition = dwRead;
                }
            }
        }
        else
        {
            // This is a focus aware buffer, and it is stopped.
            *pdwCapturePosition = dwRead;
        }

        LeaveCriticalSection(&m_cs);
        //                                                          //
        //                 Leave Critical Section                   //
        //==========================================================//
    }

Error:
    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::SetNotificationPositions"

HRESULT CEmCaptureWaveBuffer::SetNotificationPositions(DWORD cpn, LPCDSBPOSITIONNOTIFY pdsbpn)
{
    HRESULT hr = DS_OK;

    DPF_ENTER();

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    ASSERT(m_fCritSectsValid);
    EnterCriticalSection(&m_csPN);

    if (cpn)
    {
        // need to grow array?
        if (m_cpnAllocated < cpn)
        {
            LPDSBPOSITIONNOTIFY ppnT;

            ppnT = MEMALLOC_A(DSBPOSITIONNOTIFY, cpn);
            if (NULL == ppnT)
            {
                hr = DSERR_OUTOFMEMORY;
                goto Done;
            }

            MEMFREE(m_rgpdsbpn);

            m_rgpdsbpn = ppnT;
            m_cpnAllocated = cpn;
        }

        CopyMemory(m_rgpdsbpn, pdsbpn, sizeof(DSBPOSITIONNOTIFY)*cpn);
    }

    m_cpn = cpn;
    m_ipn = 0;

Done:
    LeaveCriticalSection(&m_csPN);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::SetState"

HRESULT CEmCaptureWaveBuffer::SetState(DWORD dwState)
{
    HRESULT     hr = DS_OK;
    MMRESULT    mmr = MMSYSERR_NOERROR;
    DWORD       fdwOpen;

    DPF_ENTER();

    ASSERT(IS_VALID_FLAGS(dwState, VAD_SETSTATE_MASK));
    ASSERT(m_hwi || (m_dwFlags & DSCBCAPS_FOCUSAWARE));

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    ASSERT(m_fCritSectsValid);
    EnterCriticalSection(&m_cs);

    if (dwState != m_dwState)
    {
        if (dwState & VAD_BUFFERSTATE_STARTED) // Need to start capturing
        {
            BOOL fStarted = TRUE;

            // If we're focus aware, check if we have focus...
            if (DSCBCAPS_FOCUSAWARE & m_dwFlags)
            {
                if (m_dwState & VAD_BUFFERSTATE_INFOCUS)
                {
                    fdwOpen = CALLBACK_FUNCTION;
                    fdwOpen |= ((DSCBCAPS_WAVEMAPPED & m_dwFlags) ? WAVE_MAPPED : 0);

                    if (NULL == m_hwi)
                    {
                        hr = OpenWaveIn(&m_hwi, m_pDevice->m_pDeviceDescription->m_uWaveDeviceId, m_pwfx,
                                        (DWORD_PTR)CEmCaptureWaveBuffer::waveInCallback, (DWORD_PTR)this, fdwOpen);
                    }
                }
                else
                {
                    // Set these flags so that when the buffer DOES get
                    // focus, it will start properly
                    DPF(DPFLVL_MOREINFO, "Start called but buffer has no focus: 0x%08lx (%08lx)", m_dwState, this);
                    m_fdwSavedState |= (dwState & (VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING));
                    fStarted = FALSE;
                }
            }

            if (SUCCEEDED(hr) && fStarted)
            {
                // Make sure worker thread is running
                DWORD dwResult = WaitObject(INFINITE, m_rghEvent[ihEventThreadStart]);
                ASSERT(WAIT_OBJECT_0 == dwResult);

                // Are we not capturing yet?
                if (!(m_dwState & VAD_BUFFERSTATE_STARTED))
                {
                    LONG iwhdr = 0;
                    while ((m_cwhdrDropped > 0) &&
                           ((dwState & VAD_BUFFERSTATE_LOOPING) || (m_cLoops == 0)))
                    {
                        LPWAVEHDR pwhdr = m_rgpwhdr + iwhdr;

                        hr = QueueWaveHeader(pwhdr);
                        if (FAILED(hr))
                        {
                            DPF(DPFLVL_ERROR, "QueueWaveHeader failed");
                            goto Error;
                        }

                        ++iwhdr;
                        ASSERT(iwhdr <= m_cwhdr);
                        InterlockedDecrement(&m_cwhdrDropped);
                    }

#ifdef DEBUG
                    if (m_cwhdrDropped != 0)
                        ASSERT(!(VAD_BUFFERSTATE_LOOPING & dwState));
#endif

                    // Calling waveInStart more than once doesn't result in errors
                    mmr = waveInStart(m_hwi);

                    hr = MMRESULTtoHRESULT(mmr);
                    if (SUCCEEDED(hr))
                    {
                        // We're not stopped, we're in capture mode now
                        m_dwState &= ~(DSCBSTATUS_STOPPING | DSCBSTATUS_STOPPED);
                        m_dwState |= VAD_BUFFERSTATE_STARTED;
                        m_fdwSavedState |= VAD_BUFFERSTATE_STARTED;

                        // Are we looping?
                        if (VAD_BUFFERSTATE_LOOPING & dwState)
                        {
                            m_dwState |= VAD_BUFFERSTATE_LOOPING;
                            m_fdwSavedState |= VAD_BUFFERSTATE_LOOPING;
                        }
                        else
                        {
                            m_dwState &= ~VAD_BUFFERSTATE_LOOPING;
                            m_fdwSavedState &= ~VAD_BUFFERSTATE_LOOPING;
                        }

                        // Update to next WAVEHDR expected
                        m_iwhdrDone = 0;

                        // Remember last valid position
                        m_dwCaptureLast += m_dwCaptureCur;

                        m_dwCaptureCur = 0;
                    }
                }
            }
        }
        else if (dwState == VAD_BUFFERSTATE_INFOCUS)
        {
            // Focus-aware buffers start capturing when they gain focus
            if ((m_dwFlags & DSCBCAPS_FOCUSAWARE) &&
                !((CEmCaptureDevice*)m_pDevice)->m_fAllocated)
            {
                // Update m_dwState according to the dwState argument
                m_dwState &= ~VAD_FOCUSFLAGS;
                m_dwState |= VAD_BUFFERSTATE_INFOCUS;

                // Signal CaptureThread to handle the state change
                if (!(m_dwState & VAD_BUFFERSTATE_STARTED))
                {
                    HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, m_rgszEvent[ihEventFocusChange]);
                    ASSERT(hEvent);
                    SetEvent(hEvent);
                    CloseHandle(hEvent);
                }
            }
        }
        else if (dwState & (VAD_BUFFERSTATE_OUTOFFOCUS | VAD_BUFFERSTATE_LOSTCONSOLE))
        {
            // If we are focus-aware and the capture focus state is changing...
            if ((m_dwFlags & DSCBCAPS_FOCUSAWARE) &&
                (m_dwState & VAD_FOCUSFLAGS) != dwState)
            {
                // Update m_dwState according to the dwState argument
                m_dwState &= ~VAD_FOCUSFLAGS;
                m_dwState |= dwState;

                // Signal CaptureThread to handle the state change
                HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, m_rgszEvent[ihEventFocusChange]);
                ASSERT(hEvent);
                SetEvent(hEvent);
                CloseHandle(hEvent);
            }
        }
        else // VAD_BUFFERSTATE_STOPPED case; need to stop capturing
        {
            ASSERT(dwState == VAD_BUFFERSTATE_STOPPED);  // By elimination

            // Are we currently capturing?
            if (VAD_BUFFERSTATE_STARTED & m_dwState)
            {
                // We're stopping capturing data
                m_dwState |= DSCBSTATUS_STOPPING;

                // Stop recording from input device
                if (m_hwi)
                {
                    // Make sure buffers are flushed
                    mmr = waveInReset(m_hwi);
#ifdef DEBUG_CAPTURE
                    DPF(DPFLVL_INFO, "Called waveInReset(0x%08lx) = 0x%08lx", m_hwi, mmr);
#endif
                    mmr = waveInStop(m_hwi);
#ifdef DEBUG_CAPTURE
                    DPF(DPFLVL_INFO, "Called waveInStop(0x%08lx) = 0x%08lx", m_hwi, mmr);
#endif
                }
                hr = MMRESULTtoHRESULT(mmr);

                // We've stopped capturing data
                m_dwState |= DSCBSTATUS_STOPPED;
                m_dwState &= ~(VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING);

                // CaptureThread will handle STOP position notifications
                // when the last living WAVEHDR is processed
            }

            // Not looping; not capturing.
            m_fdwSavedState = 0L;
        }
    }

Error:
    LeaveCriticalSection(&m_cs);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  NotifyStop
 *
 *  Description:
 *      Sets any events that are supposed to set when capturing stops
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      None.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::NotifyStop"

void CEmCaptureWaveBuffer::NotifyStop(void)
{
    DPF_ENTER();

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    ASSERT(m_fCritSectsValid);
    EnterCriticalSection(&m_csPN);

    // Signal any STOP notifications - only one allowed
    //
    if ((m_cpn > 0) && (DSBPN_OFFSETSTOP == m_rgpdsbpn[m_cpn-1].dwOffset))
    {
        // SetEvent can fault if handle was cleaned up out from under us
        // on process termination. In this case we will try to do a stop
        // notification when the capture buffer is being destroyed.
        try
        {
            SetEvent(m_rgpdsbpn[m_cpn-1].hEventNotify);
        }
        catch (...) {}
    }

    LeaveCriticalSection(&m_csPN);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  QueueWaveHeader
 *
 *  Description:
 *      Queues wave header in the waveIn queue
 *
 *  Arguments:
 *      LPWAVEHDR [in] : WAVEHDR to queue
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::QueueWaveHeader"

HRESULT CEmCaptureWaveBuffer::QueueWaveHeader(LPWAVEHDR pwhdr)
{
    DPF_ENTER();

    pwhdr->lpData = (LPSTR)m_pBufferNext;

    // does capture buffer extend beyond end of buffer?
    if ((m_pBufferNext + m_cbRecordChunk) > m_pBufferMac)
    {
        // then use whatever is left
        // this should only happen on last WAVEHDR
        pwhdr->dwBufferLength = PtrDiffToUlong(m_pBufferMac - m_pBufferNext);
    }
    else
    {
        pwhdr->dwBufferLength = m_cbRecordChunk;
    }

    ASSERT((LPBYTE)pwhdr->lpData == m_pBufferNext);
    ASSERT((m_pBufferNext + pwhdr->dwBufferLength) <= m_pBufferMac);

#ifdef DEBUG_CAPTURE
    // OutputDbgWHDR("Queue: ", pwhdr - m_rgpwhdr, pwhdr);  // Vestiges of old debug traces
#endif

    ASSERT(m_hwi);
    ASSERT(!(pwhdr->dwFlags & WHDR_PREPARED));
    ASSERT(!(pwhdr->dwFlags & WHDR_DONE));

    MMRESULT mmr = waveInPrepareHeader(m_hwi, pwhdr, sizeof(WAVEHDR));
    if (MMSYSERR_NOERROR == mmr)
    {
        mmr = waveInAddBuffer(m_hwi, pwhdr, sizeof(WAVEHDR));

        if (MMSYSERR_NOERROR != mmr)
        {
            DPF(DPFLVL_ERROR, "waveInAddBuffer failed: 0x%08lx", mmr);
            ASSERT(MMSYSERR_NOERROR == mmr);
        }

        // Mark header as queued
        pwhdr->dwUser = 0xdead0000;
    }
    else
    {
        DPF(DPFLVL_ERROR, "waveInPrepareHeader failed: 0x%08lx", mmr);
        ASSERT(MMSYSERR_NOERROR == mmr);
    }

    if (MMSYSERR_NOERROR != mmr)
    {
        waveInReset(m_hwi);
        DPF(DPFLVL_INFO, "Called waveInReset()");
    }
    else
    {
        m_pBufferNext += pwhdr->dwBufferLength;

        // Wraparound?
        if (m_pBufferNext >= m_pBufferMac)
        {
            m_pBufferNext = m_pBuffer;
            m_cLoops += 1;
        }
    }

    HRESULT hr = MMRESULTtoHRESULT(mmr);
    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  waveInCallback
 *
 *  Description:
 *      Called by system when a WAVEHDR has been processed
 *
 *  Arguments:
 *      HWAVEIN [in] :
 *      UINT [in] :
 *      DWORD [in] :
 *      DWORD [in] :
 *      DWORD [in] :
 *
 *  Returns:
 *      Nothing
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::waveInCallback"

void CALLBACK CEmCaptureWaveBuffer::waveInCallback(HWAVEIN hwi, UINT uMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2)
{
    CEmCaptureWaveBuffer *pThis = (CEmCaptureWaveBuffer *)dwInstance;
    if (WIM_DATA == uMsg && pThis->m_rghEvent[ihEventWHDRDone])
    {
        // Need this check for pThis->m_rghEvent[ihEventWHDRDone] != 0 here, because
        // during shutdown we may free up the event and still get some last callbacks

        InterlockedIncrement(&pThis->m_cwhdrDone);
        SetEvent(pThis->m_rghEvent[ihEventWHDRDone]);

        #ifdef DEBUG_CAPTURE
        DWORD iwhdr = (LPWAVEHDR)dwParam1 - pThis->m_rgpwhdr;
        if (iwhdr != pThis->m_iwhdrExpected)
            DPF(DPFLVL_ERROR, "Expected wave header #%u, and got #u instead!", pThis->m_iwhdrExpected, iwhdr);
        pThis->m_iwhdrExpected = (iwhdr + 1) % pThis->m_cwhdr;
        // OutputDbgWHDR("Callback: ", iwhdr, pwhdr);  // Vestiges of old debug traces
        #endif

        // Mark as done from the callback function
        ((LPWAVEHDR)dwParam1)->dwUser = 0xdead0001;
    }
}


/***************************************************************************
 *
 *  CaptureThreadStatic
 *
 *  Description:
 *      Static helper function used to launch CaptureThread.
 *
 *  Arguments:
 *      LPVOID [in] : pointer to instance data
 *
 *  Returns:
 *      DWORD: return code (ignored - always 0)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::CaptureThread"

DWORD WINAPI CEmCaptureWaveBuffer::CaptureThreadStatic(LPVOID pv)
{
    ((CEmCaptureWaveBuffer*)pv)->CaptureThread();
    return 0;
}


/***************************************************************************
 *
 *  CaptureThread
 *
 *  Description:
 *      Processes WAVEHDRs and requeues them if necessary.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CEmCaptureWaveBuffer::CaptureThread"

void CEmCaptureWaveBuffer::CaptureThread()
{
    HANDLE rghEvent[3] = { m_rghEvent[ihEventTerminate],
                           m_rghEvent[ihEventWHDRDone],
                           m_rghEvent[ihEventFocusChange] };
    HRESULT hr;

    ASSERT(m_rghEvent[ihEventThreadStart]);
    SetEvent(m_rghEvent[ihEventThreadStart]);

    // DSOUND does a similar thing for the waveOut thread
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

    while (TRUE)
    {
        // Wait for a Terminate or Capture Begin Event
        DWORD dwResultWait = WaitObjectArray(NUMELMS(rghEvent), INFINITE, FALSE, rghEvent);

        // Terminate?
        if (WAIT_OBJECT_0 + ihEventTerminate == dwResultWait)
            break;

        EnterCriticalSection(&m_cs);

        // Is this a focus change?
        if (WAIT_OBJECT_0 + ihEventFocusChange == dwResultWait)
        {
            DPF(DPFLVL_MOREINFO, "Focus change notification: 0x%08lx", m_dwState);

            if (m_dwState & VAD_BUFFERSTATE_INFOCUS)
            {
                if (VAD_BUFFERSTATE_STARTED & m_fdwSavedState)
                {
                    m_dwState &= ~(DSCBSTATUS_STOPPED | DSCBSTATUS_STOPPING);
                    m_dwState |= DSCBSTATUS_CAPTURING;

                    if (VAD_BUFFERSTATE_LOOPING & m_fdwSavedState)
                    {
                        m_dwState |= VAD_BUFFERSTATE_LOOPING;
                    }
                }
                else
                {
                    // Buffer is already started, simply leave.
                    LeaveCriticalSection(&m_cs);
                    continue;
                }

                DPF(DPFLVL_MOREINFO, "Focus starting thread.");

                hr = DS_OK;
                if (m_hwi == NULL)
                {
                    DWORD fdwOpen = CALLBACK_FUNCTION;
                    fdwOpen |= ((DSCBCAPS_WAVEMAPPED & m_dwFlags) ? WAVE_MAPPED : 0);

                    for (UINT jj = 4; jj; jj--)
                    {
                        hr = OpenWaveIn(&m_hwi, m_pDevice->m_pDeviceDescription->m_uWaveDeviceId,
                                        m_pwfx, (DWORD_PTR)waveInCallback, (DWORD_PTR)this, fdwOpen);

                        if (SUCCEEDED(hr))
                            break;

                        DPF(DPFLVL_MOREINFO, "Focus change: waveInOpen failed with 0x%08lx; retrying after 20ms", hr);
                        Sleep(20);
                    }
                }

                if (SUCCEEDED(hr))
                {
                    LONG ii = 0;
                    while ((m_cwhdrDropped > 0) &&
                           ((m_dwState & VAD_BUFFERSTATE_LOOPING) || (m_cLoops == 0)))
                    {
                        LPWAVEHDR pwhdr = m_rgpwhdr + ii;
                        hr = QueueWaveHeader(pwhdr);

                        if (FAILED(hr))
                        {
                            DPF(DPFLVL_ERROR, "QueueWaveHeader failed");
                            ASSERT(FALSE);
                        }

                        ++ii;
                        ASSERT(ii <= m_cwhdr);
                        InterlockedDecrement(&m_cwhdrDropped);
                    }

                    MMRESULT mmr = waveInStart(m_hwi);
                    ASSERT(MMSYSERR_NOERROR == mmr);

                    m_iwhdrDone = 0;
                }
            }
            else
            {
                if (m_dwState & VAD_BUFFERSTATE_STARTED)
                {
                    DPF(DPFLVL_MOREINFO, "Losing focus, stopping buffer");

                    m_dwState &= ~VAD_BUFFERSTATE_STOPPED;
                    m_dwState |= DSCBSTATUS_STOPPING;
                }
                else
                {
                    // Buffer is already stopped, simply leave.
                    LeaveCriticalSection(&m_cs);
                    continue;
                }

                if (m_hwi)
                {
                    DPF(DPFLVL_MOREINFO, "Focus stopping thread");
                    waveInReset(m_hwi);
                }
            }

            if (m_hEventFocus)
            {
                SetEvent(m_hEventFocus);
            }

            LeaveCriticalSection(&m_cs);
            continue;
        }

#ifdef DEBUG_CAPTURE
        DPF(DPFLVL_INFO, "Capture thread wakes");
#endif

        // If we get here, we must have been signaled on the only other
        // event we were listening for.  Let's make sure of that anyway.
        ASSERT(WAIT_OBJECT_0 + ihEventWHDRDone == dwResultWait);

        LONG l = InterlockedDecrement(&m_cwhdrDone);
        while (l >= 0)
        {
            // Quickly check if we should terminate
            dwResultWait = WaitObject(0, m_rghEvent[ihEventTerminate]);
            if (WAIT_OBJECT_0 == dwResultWait)
                break;

            WAVEHDR *pwhdr = m_rgpwhdr + m_iwhdrDone;

#ifdef DEBUG_CAPTURE
            DPF(DPFLVL_INFO, "Processing header #%u (pwhdr=0x%08lx)", m_iwhdrDone, pwhdr);
            // OutputDbgWHDR("Thread: ", m_iwhdrDone, pwhdr);  // Vestiges of old debug traces
#endif
            if (pwhdr->dwBytesRecorded)
            {
                BOOL fEndOfBuffer = FALSE;

                // Update number of recorded bytes
                m_dwCaptureCur += pwhdr->dwBytesRecorded;

                ASSERT(m_pBufferProcessed == (LPBYTE)pwhdr->lpData);
                m_pBufferProcessed += pwhdr->dwBytesRecorded;
                if (m_pBufferProcessed >= m_pBufferMac)
                {
                    m_pBufferProcessed = m_pBuffer;
                    fEndOfBuffer = TRUE;
                }

                // Grab critical section for position notify handling

                //==========================================================//
                //                  Enter Critical section                  //
                //                                                          //
                EnterCriticalSection(&m_csPN);

                // Scan for any position notifies that need to be signaled
                if (m_cpn)
                {
                    DWORD   ipnOld = m_ipn;
                    DWORD   dwBufferStart = PtrDiffToUlong((LPBYTE)pwhdr->lpData - m_pBuffer);
                    DWORD   dwBufferEnd = dwBufferStart + pwhdr->dwBytesRecorded;

                    // Is there a position.notify within the start.end of this
                    // captured data?
                    // Is the current position.notify to be signaled on Stop?

                    while (((m_rgpdsbpn[m_ipn].dwOffset >= dwBufferStart) &&
                            (m_rgpdsbpn[m_ipn].dwOffset < dwBufferEnd)) ||
                           (DSBPN_OFFSETSTOP == m_rgpdsbpn[m_ipn].dwOffset))
                    {
                        // Only signal if not for Stop pos.notify
                        if (DSBPN_OFFSETSTOP != m_rgpdsbpn[m_ipn].dwOffset)
                        {
                            SetEvent(m_rgpdsbpn[m_ipn].hEventNotify);
                        }

                        // go on to the next pos.notify
                        ++m_ipn;
                        // wraparound?
                        if (m_ipn >= m_cpn)
                        {
                            m_ipn = 0;
                        }

                        // Infinite loop?
                        if (m_ipn == ipnOld)
                        {
                            break;
                        }
                    }
                }

                LeaveCriticalSection(&m_csPN);
                //                                                          //
                //                 Leave Critical Section                   //
                //==========================================================//

                // Transition buffer to stop state:
                //   if the capture buffer end has been reached AND
                //   if the buffer is non-LOOPING AND
                //   if the buffer isn't in the middle of stopping
                //
                // Do this after the position notifications since STOP notification
                // is after any buffer-offset notification.

                if (fEndOfBuffer &&
                    !(m_dwState & VAD_BUFFERSTATE_LOOPING) &&
                    !(m_dwState & DSCBSTATUS_STOPPING))
                {
                    SetState(VAD_BUFFERSTATE_STOPPED);
                    ASSERT(m_dwState & DSCBSTATUS_STOPPING);
                    ASSERT((m_cwhdrDropped+1) == m_cwhdr);
                }
            }

            // Clear the WHDR_DONE flag
            pwhdr->dwFlags &= ~WHDR_DONE;

            // Reset to zero
            pwhdr->dwBytesRecorded = 0;

            MMRESULT mmr = waveInUnprepareHeader(m_hwi, pwhdr, sizeof(WAVEHDR));
            if (MMSYSERR_NOERROR != mmr)
            {
                DPF(DPFLVL_ERROR, "waveInUnprepareHeader returned %ld", mmr);
                if (WAVERR_STILLPLAYING == mmr)
                    DPF(DPFLVL_ERROR, "which is WAVERR_STILLPLAYING; reactivate bug 340919");
            }
            ASSERT(MMSYSERR_NOERROR == mmr);

            // We're stopping, let's drop everything
            if (m_dwState & DSCBSTATUS_STOPPING)
            {
Drop:
                InterlockedIncrement(&m_cwhdrDropped);

                // When all WAVEHDRs have been dropped
                if (m_cwhdrDropped == m_cwhdr)
                {
                    // Set the next point in the data buffer to capture to
                    m_pBufferNext = m_pBufferProcessed;
                    m_cLoops = 0;

                    // Notify user that we've stopped
                    NotifyStop();

                    // Focus aware buffers release the device on stop
                    if (DSCBCAPS_FOCUSAWARE & m_dwFlags)
                    {
                        if (m_hwi)
                        {
                            hr = CloseWaveIn(&m_hwi);
                            #ifdef DEBUG_CAPTURE
                                DPF(DPFLVL_INFO, "Closed waveIn and reset m_hwi = NULL");
                            #endif
                            ASSERT(SUCCEEDED(hr));
                        }
                        m_dwState &= ~(VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING);
                    }
                }
            }
            else
            {
                ASSERT(m_dwState & VAD_BUFFERSTATE_STARTED);

                // If we're LOOPING or we haven't reached the end of the buffer yet
                // then put the WAVEHDR back on to the queue with a new position
                // in the buffer, etc.
                BOOL fAddToQueue = (m_dwState & VAD_BUFFERSTATE_LOOPING) ||
                                   (m_pBufferNext > (LPBYTE)pwhdr->lpData);
                if (fAddToQueue)
                {
                    BOOL fDrop;
                    if (m_dwState & (DSCBSTATUS_STOPPED | DSCBSTATUS_STOPPING))
                    {
                        fDrop = TRUE;
                    }
                    else
                    {
                        hr = QueueWaveHeader(pwhdr);
                        ASSERT(SUCCEEDED(hr));
                        fDrop = FALSE;
                    }
                    if (fDrop)
                    {
                        goto Drop;
                    }
                }
                else
                {
                    InterlockedIncrement(&m_cwhdrDropped);

                    // If no WAVEHDRs are queued then if the user
                    // starts capturing again, we queue the WAVEHDRs from
                    // the beginning of our array
                    if (m_cwhdr == m_cwhdrDropped)
                    {
#ifdef DEBUG
                        if (!(m_dwState & VAD_BUFFERSTATE_LOOPING))
                            ASSERT(m_cLoops > 0);
#endif
                        // Notify user that we've stopped
                        NotifyStop();
                    }
                }
            }

            ++m_iwhdrDone;
            if (m_iwhdrDone >= m_cwhdr)
            {
                m_iwhdrDone = 0;
            }

            // On to the next one
            l = InterlockedDecrement(&m_cwhdrDone);
        }

        InterlockedIncrement(&m_cwhdrDone);
        if (WAIT_OBJECT_0 == dwResultWait)
        {
            LeaveCriticalSection(&m_cs);
            break;
        }
        LeaveCriticalSection(&m_cs);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\grsource.cpp ===
//--------------------------------------------------------------------------;
//
//  File: grsource.cpp
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/25/96    FrankYe     Created
//
//  Implementation notes:
//
// The CMixSource class is used in both ring 0 and ring 3.  MixSource
// objects are passed across the rings, so it is important that the physical
// layout of the class be consistent in both rings.  It is also crucial that
// member functions are called directly instead of through the vtable, as a
// MixSource object created in ring 3 will have a vtable pointing to ring 3
// functions, which of course ring 0 cannot call.  Ring 0 must call the ring 0
// implementation of these functions.
//
// If you do something to break this, it'll probably be apparent almost
// immediately when you test with ring 0 mixing.
//
// Also, because the MixSource objects are accessed in both rings, any
// member data that can be accessed by both rings simultaneously must be
// serialized via the MixerMutex.  Member data always accessed only by a single
// ring are probably okay.  Those called only in ring 3 are protected by the
// DLL mutex, and those called only in ring 0 are protected by the MixerMutex.
//
// Member functions called from ring 0 should not call the
// ENTER_MIXER_MUTEX / LEAVE_MIXER_MUTEX macros as these work only
// for ring 3.
//
//--------------------------------------------------------------------------;
#define NODSOUNDSERVICETABLE

#include "dsoundi.h"

#ifndef Not_VxD
#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG
#endif

PVOID MixSource_New(PVOID pMixer)
{
    return NEW(CMixSource((CMixer *)pMixer));
}

void MixSource_Delete(PVOID pMixSource)
{
    CMixSource *p = (CMixSource *)pMixSource;
    DELETE(p);
}

BOOL MixSource_Stop(PVOID pMixSource)
{
    return ((CMixSource *)pMixSource)->Stop();
}

void MixSource_Play(PVOID pMixSource, BOOL fLooping)
{
    ((CMixSource *)pMixSource)->Play(fLooping);
}

void MixSource_Update(PVOID pMixSource, int ibUpdate1, int cbUpdate1, int ibUpdate2, int cbUpdate2)
{
    ((CMixSource *)pMixSource)->Update(ibUpdate1, cbUpdate1, ibUpdate2, cbUpdate2);
}

HRESULT MixSource_Initialize(PVOID pMixSource, PVOID pBuffer, int cbBuffer, LPWAVEFORMATEX pwfx, PFIRCONTEXT *ppFirLeft, PFIRCONTEXT *ppFirRight)
{
    return ((CMixSource *)pMixSource)->Initialize(pBuffer, cbBuffer, pwfx, ppFirLeft, ppFirRight);
}

void MixSource_FilterOn(PVOID pMixSource)
{
    ((CMixSource *)pMixSource)->FilterOn();
}

void MixSource_FilterOff(PVOID pMixSource)
{
    ((CMixSource *)pMixSource)->FilterOff();
}

BOOL MixSource_HasFilter(PVOID pMixSource)
{
    return ((CMixSource *)pMixSource)->HasFilter();
}

void MixSource_SetVolumePan(PVOID pMixSource, PDSVOLUMEPAN pdsVolPan)
{
    ((CMixSource *)pMixSource)->SetVolumePan(pdsVolPan);
}

void MixSource_SetFrequency(PVOID pMixSource, ULONG nFrequency)
{
    ((CMixSource *)pMixSource)->SetFrequency(nFrequency);
}

ULONG MixSource_GetFrequency(PVOID pMixSource)
{
    return ((CMixSource *)pMixSource)->GetFrequency();
}

HRESULT MixSource_SetNotificationPositions(PVOID pMixSource, int cNotes, LPCDSBPOSITIONNOTIFY paNotes)
{
    return ((CMixSource *)pMixSource)->SetNotificationPositions(cNotes, paNotes);
}

void MixSource_MuteOn(PVOID pMixSource)
{
    ((CMixSource *)pMixSource)->m_fMute = TRUE;
}

void MixSource_MuteOff(PVOID pMixSource)
{
    ((CMixSource *)pMixSource)->m_fMute = FALSE;
}

void MixSource_SetBytePosition(PVOID pMixSource, int ibPosition)
{
    ((CMixSource *)pMixSource)->SetBytePosition(ibPosition);
}

void MixSource_GetBytePosition1(PVOID pMixSource, int *pibPlay, int *pibWrite)
{
    ((CMixSource *)pMixSource)->GetBytePosition1(pibPlay, pibWrite);
}

void MixSource_GetBytePosition(PVOID pMixSource, int *pibPlay, int *pibWrite, int *pibMix)
{
    ((CMixSource *)pMixSource)->GetBytePosition(pibPlay, pibWrite, pibMix);
}

BOOL MixSource_IsPlaying(PVOID pMixSource)
{
    return ((CMixSource *)pMixSource)->IsPlaying();
}


//--------------------------------------------------------------------------;
//
// CMixSource::CMixSource constructor
//
//--------------------------------------------------------------------------;
CMixSource::CMixSource(CMixer *pMixer)
{
    m_cSamplesMixed = 0;
    m_cSamplesRemixed = 0;
    m_pDsbNotes = NULL;
    m_MapTable = NULL;
    
    m_pMixer = pMixer;

    m_dwSignature = ~MIXSOURCE_SIGNATURE;
}

//--------------------------------------------------------------------------;
//
// CMixSource::~CMixSource destructor
//
//--------------------------------------------------------------------------;
CMixSource::~CMixSource(void)
{
#ifdef PROFILEREMIXING
    if (0 != (m_cSamplesMixed - m_cSamplesRemixed)) {
        int Percentage = MulDivRN(m_cSamplesRemixed, 100, (m_cSamplesMixed - m_cSamplesRemixed));
#ifdef Not_VxD
        DPF(3, "this MixSource=%08Xh remixed %d percent", this, Percentage);
#else
        DPF(("this MixSource=%08Xh remixed %d percent", this, Percentage));
#endif
    } else {
#ifdef Not_VxD
        DPF(3, "this MixSource=%08Xh had no net mix");
#else
        DPF(("this MixSource=%08Xh had no net mix"));
#endif
    }
#endif

    DELETE(m_pDsbNotes);
    MEMFREE(m_MapTable);
}

//--------------------------------------------------------------------------;
//
// CMixSource::Initialize
//
//--------------------------------------------------------------------------;
HRESULT CMixSource::Initialize(PVOID pBuffer, int cbBuffer, LPWAVEFORMATEX pwfx, PFIRCONTEXT *ppFirContextLeft, PFIRCONTEXT *ppFirContextRight)
{
#ifdef Not_VxD
    ASSERT(m_pBuffer == NULL);
    ASSERT(pwfx->wFormatTag == WAVE_FORMAT_PCM);

    m_pDsbNotes = NEW(CDsbNotes);
    HRESULT hr = m_pDsbNotes ? S_OK : E_OUTOFMEMORY;

    if (S_OK == hr)
    {
        hr = m_pDsbNotes->Initialize(cbBuffer);

        m_ppFirContextLeft = ppFirContextLeft;
        m_ppFirContextRight = ppFirContextRight;
        m_pBuffer = pBuffer;
        m_cbBuffer = cbBuffer;
        m_cSamples = m_cbBuffer >> m_nBlockAlignShift;

        m_dwLVolume = 0xffff;
        m_dwRVolume = 0xffff;
        m_dwMVolume = 0xffff;
        m_nFrequency = pwfx->nSamplesPerSec;

        m_dwFraction = 0;
        m_nLastMergeFrequency = m_nFrequency + 1;        // Different.
        m_MapTable   = NULL;
        m_dwLastLVolume = 0;
        m_dwLastRVolume = 0;

        // m_nUserFrequency = pwfx->nSamplesPerSec;

        m_hfFormat &= ~H_LOOP;

        if (pwfx->wBitsPerSample == 8)
            m_hfFormat |= (H_8_BITS | H_UNSIGNED);
        else
            m_hfFormat |= (H_16_BITS | H_SIGNED);
        if (pwfx->nChannels == 2)
            m_hfFormat |= (H_STEREO | H_ORDER_LR);
        else
            m_hfFormat |= H_MONO;

        m_cSamples = m_cbBuffer / pwfx->nBlockAlign;

        switch (pwfx->nBlockAlign)
        {
            case 1: m_nBlockAlignShift = 0; break;
            case 2: m_nBlockAlignShift = 1; break;
            case 4: m_nBlockAlignShift = 2; break;
            default: ASSERT(FALSE);
        }

#ifdef USE_INLINE_ASM
        #define CPU_ID _asm _emit 0x0f _asm _emit 0xa2  
        int No_MMX = 1;
        _asm 
        {
            push    ebx
            pushfd                      // Store original EFLAGS on stack
            pop     eax                 // Get original EFLAGS in EAX
            mov     ecx, eax            // Duplicate original EFLAGS in ECX for toggle check
            xor     eax, 0x00200000L    // Flip ID bit in EFLAGS
            push    eax                 // Save new EFLAGS value on stack
            popfd                       // Replace current EFLAGS value
            pushfd                      // Store new EFLAGS on stack
            pop     eax                 // Get new EFLAGS in EAX
            xor     eax, ecx            // Can we toggle ID bit?
            jz      Done                // Jump if no, Processor is older than a Pentium so CPU_ID is not supported
            mov     eax, 1              // Set EAX to tell the CPUID instruction what to return
            CPU_ID                      // Get family/model/stepping/features
            test    edx, 0x00800000L    // Check if mmx technology available
            jz      Done                // Jump if no
            dec     No_MMX              // MMX present
            Done:
            pop     ebx
        }
        m_fUse_MMX = !No_MMX;
//      m_fUse_MMX = 0; 
#endif // USE_INLINE_ASM
    }

    if (S_OK != hr) DELETE(m_pDsbNotes);
    if (S_OK == hr) m_dwSignature = MIXSOURCE_SIGNATURE;
    
    return hr;
#else // Not_VxD
    ASSERT(FALSE);
    return E_UNEXPECTED;
#endif // Not_VxD
}

//--------------------------------------------------------------------------;
//
// CMixSource::IsPlaying
//
//--------------------------------------------------------------------------;
BOOL CMixSource::IsPlaying()
{
    return MIXSOURCESTATE_STOPPED != m_kMixerState;
}

//--------------------------------------------------------------------------;
//
// CMixSource::Stop
//
//        Note this function does not notify the CMixSource's Stop event, if
// it has one.  The caller of this function should also call
// CMixSource::NotifyStop if appropriate.
//
//--------------------------------------------------------------------------;
BOOL CMixSource::Stop()
{
#ifdef Not_VxD
    int ibPlay;
    int dbNextNotify;

    if (MIXSOURCESTATE_STOPPED == m_kMixerState) return FALSE;
    
    m_pMixer->GetBytePosition(this, &ibPlay, NULL);
    m_pMixer->MixListRemove(this);
    m_posNextMix = ibPlay >> m_nBlockAlignShift;
    
    if (!m_fMute) m_pMixer->SignalRemix();

    ASSERT(m_pDsbNotes);

    m_pDsbNotes->NotifyToPosition(ibPlay, &dbNextNotify);

    return TRUE;
#else
    ASSERT(FALSE);
    return TRUE;
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::Play
//
//--------------------------------------------------------------------------;
void CMixSource::Play(BOOL fLooping)
{
#ifdef Not_VxD
    if (fLooping) {
        LoopingOn();
    } else {
        LoopingOff();
    }

    ENTER_MIXER_MUTEX();

    if (MIXSOURCESTATE_STOPPED == m_kMixerState) {
        
        // Add this source to the mixer's list
        m_pMixer->MixListAdd(this);
        SignalRemix();

        // Must move the notification position pointer otherwise we'll signal
        // everything from the beginning of the buffer.
        if (m_pDsbNotes) {
            int ibPlay;
            m_pMixer->GetBytePosition(this, &ibPlay, NULL);
            m_pDsbNotes->SetPosition(ibPlay);
        }
    }

    LEAVE_MIXER_MUTEX();
#else
    ASSERT(FALSE);
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::Update
//
//--------------------------------------------------------------------------;
void CMixSource::Update(int ibUpdate1, int cbUpdate1, int ibUpdate2, int cbUpdate2)
{
    int ibWrite, ibMix;
    int cbPremixed;
    BOOL fRegionsIntersect;
        
    if (MIXSOURCESTATE_STOPPED == m_kMixerState) return;

    GetBytePosition(NULL, &ibWrite, &ibMix);

    cbPremixed = ibMix - ibWrite;
    if (cbPremixed < 0) cbPremixed += m_cbBuffer;
    ASSERT(cbPremixed >= 0);

    fRegionsIntersect = CircularBufferRegionsIntersect(m_cbBuffer,
        ibWrite, cbPremixed, ibUpdate1, cbUpdate1);

    if (!fRegionsIntersect && ibUpdate2) {
        fRegionsIntersect = CircularBufferRegionsIntersect(m_cbBuffer,
            ibWrite, cbPremixed, ibUpdate2, cbUpdate2);
    }

    if (fRegionsIntersect) {
        // DPF(4, "Lock: note: unlocked premixed region");
        SignalRemix();
    }
}

//--------------------------------------------------------------------------;
//
// CMixSource::SetVolumePan
//
//--------------------------------------------------------------------------;
void CMixSource::SetVolumePan(PDSVOLUMEPAN pdsVolPan)
{
    m_dwLVolume = pdsVolPan->dwTotalLeftAmpFactor;
    m_dwRVolume = pdsVolPan->dwTotalRightAmpFactor;
    m_dwMVolume = (m_dwLVolume + m_dwRVolume) / 2;

    // Make MapTable for both left and right sides.  Low and high byte.
    if (m_dwRVolume != 0xffff || m_dwLVolume != 0xffff) {
        if (!m_fUse_MMX && !m_MapTable) {
            if (m_hfFormat & H_16_BITS) {
#ifdef USE_SLOWER_TABLES    // Of course, DONT!
                m_MapTable = MEMALLOC_A(LONG, (2 * 256) + (2 * 256));
#endif
            } else {
                m_MapTable = MEMALLOC_A(LONG, (2 * 256));
            }
        }
        if (m_MapTable &&
            (m_dwLastLVolume != m_dwLVolume || m_dwLastRVolume != m_dwRVolume))
            {
            m_dwLastLVolume = m_dwLVolume;
            m_dwLastRVolume = m_dwRVolume;

            // Fill low byte part.
            int  i;
            LONG volL, volLinc;
            LONG volR, volRinc;

            volLinc = m_dwLVolume;
            volRinc = m_dwRVolume;

            // Byte case.  Fold conversion into this.
            if (m_hfFormat & H_16_BITS) {
#ifdef USE_SLOWER_TABLES    // Of course, DONT!
                volL = m_dwLVolume;
                volR = m_dwRVolume;

                for (i = 0; i < 256; ++i)                   // Low byte.
                {
                    m_MapTable[i + 0  ] = volL >> 16;
                    m_MapTable[i + 256] = volR >> 16;
    
                    volL += m_dwLVolume;
                    volR += m_dwRVolume;
                }

                volL = - (LONG)(m_dwLVolume * 128 * 256);   // High byte.
                volR = - (LONG)(m_dwRVolume * 128 * 256);

                volLinc = m_dwLVolume * 256;
                volRinc = m_dwRVolume * 256;

                for (i = 0; i < 256; ++i)
                {
                    m_MapTable[512 + i + 0  ] = volL >> 16;
                    m_MapTable[512 + i + 256] = volR >> 16;
    
                    volL += volLinc;
                    volR += volRinc;
                }
#endif // USE_SLOWER_TABLES
            } else {
                volL = - (LONG)(m_dwLVolume * 128 * 256);
                volR = - (LONG)(m_dwRVolume * 128 * 256);

                volLinc = m_dwLVolume * 256;
                volRinc = m_dwRVolume * 256;

                for (i = 0; i < 256; ++i)
                {
                    m_MapTable[i + 0  ] = volL >> 16;
                    m_MapTable[i + 256] = volR >> 16;

                    volL += volLinc;
                    volR += volRinc;
                }
            }
        }
    }
}

//--------------------------------------------------------------------------;
//
// CMixSource::GetFrequency
//
//--------------------------------------------------------------------------;
ULONG CMixSource::GetFrequency()
{
    return m_nFrequency;
}

//--------------------------------------------------------------------------;
//
// CMixSource::SetFrequency
//
//--------------------------------------------------------------------------;
void CMixSource::SetFrequency(ULONG nFrequency)
{
    ASSERT(0 != nFrequency);
    ENTER_MIXER_MUTEX();
    m_nFrequency = nFrequency;
    LEAVE_MIXER_MUTEX();
    SignalRemix();
}

//--------------------------------------------------------------------------;
//
// CMixSource::GetNextMixBytePosition
//
//--------------------------------------------------------------------------;
int CMixSource::GetNextMixBytePosition()
{
    return (m_posNextMix << m_nBlockAlignShift);
}

//--------------------------------------------------------------------------;
//
// CMixSource::SetBytePosition
//
//--------------------------------------------------------------------------;
void CMixSource::SetBytePosition(int ibPosition)
{
    ENTER_MIXER_MUTEX();
    m_posNextMix = ibPosition >> m_nBlockAlignShift;

    if (MIXSOURCESTATE_STOPPED != m_kMixerState) {
        if (0 == (DSBMIXERSIGNAL_SETPOSITION & m_fdwMixerSignal)) {
            m_fdwMixerSignal |= DSBMIXERSIGNAL_SETPOSITION;
            // REMIND the following line should really be done in grace.cpp
            //  where we check for SETPOSITION flag set; and also, all those
            //  calls should call uMixNewBuffer, instead of looping/nonlooping.
            m_kMixerSubstate = MIXSOURCESUBSTATE_NEW;
        }
        SignalRemix();
    }

    m_pDsbNotes->SetPosition(m_posNextMix << m_nBlockAlignShift);

    LEAVE_MIXER_MUTEX();
}

//--------------------------------------------------------------------------;
//
// CMixSource::GetBytePosition1
//
// This is a version of GetBytePosition that maintains compatibility with
// DirectX 1 in which the reported play position is the actual write position,
// and the reported write position is one sample ahead of the actual write
// position.  This happenned in DirectX 1 only on wave emulation and therefore
// this function should be called only for wave emulated DirectSound buffers.
// 
//--------------------------------------------------------------------------;
void CMixSource::GetBytePosition1(int *pibPlay, int *pibWrite)
{
#ifdef Not_VxD
    if (MIXSOURCESTATE_STOPPED == m_kMixerState) {
        if (pibPlay)
            *pibPlay  = GetNextMixBytePosition();
        if (pibWrite)
            *pibWrite = GetNextMixBytePosition();
    } else {
        m_pMixer->GetBytePosition(this, pibPlay, pibWrite);
        if (pibPlay && pibWrite)
            *pibPlay = *pibWrite;
        if (pibWrite) {
            *pibWrite += 1 << m_nBlockAlignShift;
            if (*pibWrite >= m_cbBuffer) *pibWrite -= m_cbBuffer;
        }
    }
#else
    ASSERT(FALSE);
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::GetBytePosition
//
//--------------------------------------------------------------------------;
void CMixSource::GetBytePosition(int *pibPlay, int *pibWrite, int *pibMix)
{
#ifdef Not_VxD
    if (pibMix)
        *pibMix = GetNextMixBytePosition();
    if (MIXSOURCESTATE_STOPPED == m_kMixerState) {
        if (pibPlay)
            *pibPlay = GetNextMixBytePosition();
        if (pibWrite)
            *pibWrite = GetNextMixBytePosition();
    } else {
        m_pMixer->GetBytePosition(this, pibPlay, pibWrite);
    }
#else
    ASSERT(FALSE);
#endif
}

HRESULT CMixSource::SetNotificationPositions(int cNotes, LPCDSBPOSITIONNOTIFY paNotes)
{
#ifdef Not_VxD
    HRESULT hr;
    
    // Can only set notifications when buffer is stopped
    if (MIXSOURCESTATE_STOPPED != m_kMixerState) {
        DPF(0, "SetNotificationPositions called while playing");
        return DSERR_INVALIDCALL;
    }

    ENTER_MIXER_MUTEX();
    hr = m_pDsbNotes->SetNotificationPositions(cNotes, paNotes);
    LEAVE_MIXER_MUTEX();
    return hr;
#else
    ASSERT(FALSE);
    return E_NOTIMPL;
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::LoopingOn
//
//--------------------------------------------------------------------------;
void CMixSource::LoopingOn()
{
    m_hfFormat |= H_LOOP;
}

//--------------------------------------------------------------------------;
//
// CMixSource::LoopingOff
//
//--------------------------------------------------------------------------;
void CMixSource::LoopingOff()
{
    m_hfFormat &= ~H_LOOP;
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterOn
//
//--------------------------------------------------------------------------;
void CMixSource::FilterOn()
{
#ifdef Not_VxD
    m_pMixer->FilterOn(this);
#else
    ASSERT(FALSE);
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterOff
//
//--------------------------------------------------------------------------;
void CMixSource::FilterOff()
{
#ifdef Not_VxD
    m_pMixer->FilterOff(this);
#else
    ASSERT(FALSE);
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterClear
//
// This should be called only by the CMixer object.  It instructs the
// MixSource to clear its filter history.  That is, reset to initial state.
// 
//--------------------------------------------------------------------------;
void CMixSource::FilterClear()
{
    //DPF(3, "~`FC ");
    m_cSamplesInCache = 0;
    if (HasFilter() && !m_fFilterError) {
        ::FilterClear(*m_ppFirContextLeft);
        ::FilterClear(*m_ppFirContextRight);
    }
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterChunkUpdate
//
// This should be called only by the CMixer object.
// 
//--------------------------------------------------------------------------;
void CMixSource::FilterChunkUpdate(int cSamples)
{
    if (HasFilter() && !m_fFilterError) {
        ::FilterChunkUpdate(*m_ppFirContextLeft, cSamples);
        ::FilterChunkUpdate(*m_ppFirContextRight, cSamples);
    }
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterRewind
//
// This should be called only by the CMixer object.
// 
//--------------------------------------------------------------------------;
void CMixSource::FilterRewind(int cSamples)
{
    m_cSamplesInCache -= cSamples;
    //DPF(3, "~`FR%X %X ", cSamples, m_cSamplesInCache);
    ASSERT(0 == (m_cSamplesInCache % MIXER_REWINDGRANULARITY));
    
    if (HasFilter() && !m_fFilterError) {
        ::FilterRewind(*m_ppFirContextLeft, cSamples);
        ::FilterRewind(*m_ppFirContextRight, cSamples);
    }
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterAdvance
//
// This should be called only by the CMixer object.
// 
//--------------------------------------------------------------------------;
void CMixSource::FilterAdvance(int cSamples)
{
    m_cSamplesInCache += cSamples;
    //DPF(3, "~`FA%X %X ", cSamples, m_cSamplesInCache);
    if (HasFilter() && !m_fFilterError) {
        ::FilterAdvance(*m_ppFirContextLeft, cSamples);
        ::FilterAdvance(*m_ppFirContextRight, cSamples);
    }
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterPreprare
//
// This should be called only by the CMixer object.
// 
//--------------------------------------------------------------------------;
void CMixSource::FilterPrepare(int cMaxRewindSamples)
{
    BOOL fPrepared;
    
    //DPF(3, "~`FP ");
    m_cSamplesInCache = 0;
    fPrepared = TRUE;
    
    if (HasFilter()) {
        fPrepared = ::FilterPrepare(*m_ppFirContextLeft, cMaxRewindSamples);
        if (fPrepared) {
            fPrepared = ::FilterPrepare(*m_ppFirContextRight, cMaxRewindSamples);
            if (!fPrepared) {
                ::FilterUnprepare(*m_ppFirContextLeft);
            }
        }
    }
    
    m_fFilterError = !fPrepared;
}

//--------------------------------------------------------------------------;
//
// CMixSource::FilterUnprepare
//
// This should be called only by the CMixer object.
// 
//--------------------------------------------------------------------------;
void CMixSource::FilterUnprepare(void)
{
    if (HasFilter() && !m_fFilterError) {
        ::FilterUnprepare(*m_ppFirContextLeft);
        ::FilterUnprepare(*m_ppFirContextRight);
    }
    m_fFilterError = FALSE;
}

//--------------------------------------------------------------------------;
//
// CMixSource::SignalRemix
// 
//--------------------------------------------------------------------------;
void CMixSource::SignalRemix()
{
#ifdef Not_VxD
    if (IsPlaying() && !GetMute()) {
        m_pMixer->SignalRemix();
    }
#else
    ASSERT(FALSE);
#endif
}

//--------------------------------------------------------------------------;
//
// CMixSource::HasNotifications
//
//--------------------------------------------------------------------------;
BOOL CMixSource::HasNotifications(void)
{
    ASSERT(m_pDsbNotes);
    return m_pDsbNotes->HasNotifications();
}

//--------------------------------------------------------------------------;
//
// CMixSource::NotifyToPosition
//
// Notes:
//      This function should be called only from user mode
//
//--------------------------------------------------------------------------;
void CMixSource::NotifyToPosition(IN int ibPosition,
                                  OUT PLONG pdtimeToNextNotify)
{
    int dbNextNotify;
    
    m_pDsbNotes->NotifyToPosition(ibPosition, &dbNextNotify);
    *pdtimeToNextNotify = MulDivRD(dbNextNotify >> m_nBlockAlignShift,
                                   1000, m_nFrequency);
}

//--------------------------------------------------------------------------;
//
// CMixSource::NotifyStop
//
// Notes:
//      This function should be called only from user mode
//
//--------------------------------------------------------------------------;
void CMixSource::NotifyStop(void)
{
    m_pDsbNotes->NotifyStop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\grace.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#ifndef __GRACE_INCLUDED__
#define __GRACE_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

#include "modeflag.h"
    
#define N_EMU_WAVE_HDRS_INQUEUE     3
#define HW_WRITE_CURSOR_MSEC_PAD    10

#ifdef Not_VxD

__inline DWORD PadHardwareWriteCursor(DWORD dwPosition, DWORD cbBuffer, LPCWAVEFORMATEX pwfx)
{
    return PadCursor(dwPosition, cbBuffer, pwfx, HW_WRITE_CURSOR_MSEC_PAD);
}

#endif // Not_VxD

#ifndef NUMELMS
#define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif // NUMELMS

#define CACHE_MINSIZE   64          // big enough for LOWPASS_SIZE + delay
#define LOWPASS_SIZE    32          // how many samples to average
#define FILTER_SHIFT    5           // log2(LOWPASS_SIZE)

typedef struct _FIRSTATE {
    FLOAT       LastDryAttenuation;
    FLOAT       LastWetAttenuation;
#ifdef SMOOTH_ITD
    int         iLastDelay;
#endif
} FIRSTATE, *PFIRSTATE;

typedef struct _FIRCONTEXT {
    LONG*       pSampleCache;           // cache of previous samples
    int         cSampleCache;           // num samples in the cache
    int         iCurSample;             // next sample goes at this offset
    FIRSTATE*   pStateCache;            // remember state once in a while
    int         cStateCache;            // num entries in cache
    int         iCurState;              // where in the state cache we are
    int         iStateTick;             // when it's time to remember state
    FLOAT       DistAttenuation;        // attenuation from distance
    FLOAT       ConeAttenuation;        // attenuation from cone effect
    FLOAT       ConeShadow;             // shadow from cone effect
    FLOAT       PositionAttenuation;    // attenuation from 3D position & dist
    FLOAT       PositionShadow;         // dry/wet ratio, basically
    FLOAT       TotalDryAttenuation;    // multiply dry amplitude by this
    FLOAT       LastDryAttenuation;     // what we did last time
    FLOAT       TotalWetAttenuation;    // multiply wet amplitude by this
    FLOAT       LastWetAttenuation;     // what we did last time
    FLOAT       VolSmoothScale;         // constant for volume smoothing
    FLOAT       VolSmoothScaleRecip;    // its reciprocal
    FLOAT       VolSmoothScaleDry;      // constants to use for volume smoothing
    FLOAT       VolSmoothScaleWet;      // in inner loop
    int         iSmoothFreq;            // freq used to compute VolSmooth
    BOOL        fLeft;                  // are we making left or right channel?
    int         iDelay;                 // want to delay by this many samples
#ifdef SMOOTH_ITD
    int         iLastDelay;             // last time we delayed by this much
#endif
} FIRCONTEXT, *PFIRCONTEXT;

//
// Possible mixer signals, per ds object
//
#define DSMIXERSIGNAL_REMIX             0x00000001

//
// Possible reasons for signaling the mixer to remix, per buffer
//
#define DSBMIXERSIGNAL_SETPOSITION      0x00000001

//
// The number of samples in a remix interval.  The remix interval specifies
// the sample points at which we might perform remixes (that is, rewind to).
// This is specified in samples.  Make it a power of 2 so that some of the
// arithmatic compiles to efficient code.
//
#define MIXER_REWINDGRANULARITY         128
    
//
// Possible states of a Direct Sound buffer being mixed
//
typedef enum {
    MIXSOURCESTATE_STOPPED = 0,
    MIXSOURCESTATE_NEW,
    MIXSOURCESTATE_LOOPING,
    MIXSOURCESTATE_NOTLOOPING,
    MIXSOURCESTATE_ENDING_WAITINGPRIMARYWRAP,
    MIXSOURCESTATE_ENDING
} MIXSOURCESTATE;

typedef enum {
    MIXSOURCESUBSTATE_NEW = 0,
    MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP,
    MIXSOURCESUBSTATE_STARTING,
    MIXSOURCESUBSTATE_STARTED
} MIXSOURCESUBSTATE;

//
// Possible states of a Mixer
//
typedef enum {
    MIXERSTATE_STOPPED = 0,
    MIXERSTATE_IDLE,
    MIXERSTATE_STARTING,
    MIXERSTATE_LOOPING
} MIXERSTATE;

__inline LONG MulDivRD(LONG a, LONG b, LONG c)
{
    return (LONG)(Int32x32To64(a,b) / c);
}

__inline LONG MulDivRN(LONG a, LONG b, LONG c)
{
    return (LONG)((Int32x32To64(a,b)+c/2) / c);
}

__inline LONG MulDivRU(LONG a, LONG b, LONG c)
{
    return (LONG)((Int32x32To64(a,b)+(c-1)) / c);
}

__inline DWORD UMulDivRD(DWORD a, DWORD b, DWORD c)
{
    return (DWORD)(UInt32x32To64(a,b) / c);
}

__inline DWORD UMulDivRN(DWORD a, DWORD b, DWORD c)
{
    return (DWORD)((UInt32x32To64(a,b)+c/2) / c);
}

__inline DWORD UMulDivRDClip(DWORD a, DWORD b, DWORD c)
{
    DWORDLONG t;
    DWORDLONG q;
    DWORD result;

    t = UInt32x32To64(a, b);
    q = t / c;
    result = (DWORD) q;
    if (q > result) result = (DWORD)(-1);
    return result;
}

#ifdef __cplusplus

class CMixer;

#define MIXSOURCE_SIGNATURE ((DWORD)'CRSM')

class CMixSource {
    public:
        CMixSource(CMixer *pMixer);
        ~CMixSource(void);
        HRESULT     Initialize(PVOID pBuffer, int cbBuffer, LPWAVEFORMATEX pwfx, PFIRCONTEXT *ppFirContextLeft, PFIRCONTEXT *ppFirContextRight);
        BOOL        IsPlaying(void);
        void        SignalRemix(void);
        BOOL        Stop(void);
        void        Play(BOOL fLooping);
        void        Update(int ibUpdate1, int cbUpdate1, int ibUpdate2, int cbUpdate2);
        void        SetFrequency(ULONG nFrequency);
        ULONG       GetFrequency();
        void        SetVolumePan(PDSVOLUMEPAN pdsVolPan);
        void        SetBytePosition(int ibPosition);
        void        GetBytePosition1(int *pibPlay, int *pibWrite);
        void        GetBytePosition(int *pibPlay, int *pibWrite, int *pibMix);
        BOOL        GetMute(void) {return m_fMute || m_fFilterError || m_fMute3d;}
        void        FilterOn(void);
        void        FilterOff(void);
        BOOL        HasFilter(void) {return (m_hfFormat & H_FILTER) != 0;}

        void        NotifyToPosition(IN int ibPositoin, OUT PLONG pdtimeToNextNotify);
        BOOL        HasNotifications(void);
        void        NotifyStop(void);
        HRESULT     SetNotificationPositions(int cNotes, LPCDSBPOSITIONNOTIFY paNotes);

        void        CountSamplesMixed(int cSamples);
        void        CountSamplesRemixed(int cSamples);

        void        FilterPrepare(int cMaxRewindSamples);
        void        FilterUnprepare(void);
        void        FilterClear(void);
        void        FilterChunkUpdate(int cSamples);
        void        FilterRewind(int cSamples);
        void        FilterAdvance(int cSamples);

        DWORD               m_dwSignature;
        int                 m_cSamplesInCache;
        int                 m_cSamples;
        int                 m_cbBuffer;
        PVOID               m_pBuffer;
        PFIRCONTEXT*        m_ppFirContextLeft;
        PFIRCONTEXT*        m_ppFirContextRight;

        CMixer*             m_pMixer;
        CMixSource*         m_pNextMix;
        CMixSource*         m_pPrevMix;
        
        MIXSOURCESTATE      m_kMixerState;
        MIXSOURCESUBSTATE   m_kMixerSubstate;

        DWORD               m_hfFormat;             // PCM format flag desc of stream buffer
        int                 m_nBlockAlignShift;
        ULONG               m_nFrequency;           // real sample rate including Doppler

        BOOL                m_fMute;
        BOOL                m_fMute3d;
        DWORD               m_dwLVolume;            // For mixer use - linear Left Voume
        DWORD               m_dwRVolume;            // For mixer use - linear Right Voume
        DWORD               m_dwMVolume;            // For mixer use - linear MONO Voume

        ULONG               m_nLastFrequency;
        int                 m_posPStart;
        int                 m_posPEnd;
        int                 m_posPPlayLast;
        int                 m_posNextMix;
        DWORD               m_fdwMixerSignal;

        // Mix session data
        DWORD               m_step_fract;
        DWORD               m_step_whole[2];

        PLONG               m_MapTable;
        DWORD               m_dwLastLVolume;
        DWORD               m_dwLastRVolume;

        DWORD               m_dwFraction;
        ULONG               m_nLastMergeFrequency;  // Can't use m_nLastFrequency (set to m_nFrequency before call to mixMixSession).
        BOOL                m_fUse_MMX;

    private:
        int                 GetNextMixBytePosition();
        void                LoopingOn(void);
        void                LoopingOff(void);

        class CDsbNotes *   m_pDsbNotes;

        BOOL                m_fFilterError;

        int                 m_cSamplesMixed;
        int                 m_cSamplesRemixed;
};

#ifdef PROFILEREMIXING
__inline void CMixSource::CountSamplesMixed(int cSamples) { m_cSamplesMixed += cSamples; }
__inline void CMixSource::CountSamplesRemixed(int cSamples) { m_cSamplesRemixed += cSamples; }
#else
__inline void CMixSource::CountSamplesMixed(int cSamples) { return; }
__inline void CMixSource::CountSamplesRemixed(int cSamples) { return; }
#endif

//--------------------------------------------------------------------------;
//
// Woefully uncommented mixer destination abstract base class.
//
//--------------------------------------------------------------------------;

class CMixDest {
    public:
        virtual HRESULT Initialize(void) =0;
        virtual void Terminate(void) =0;
        virtual HRESULT SetFormat(LPWAVEFORMATEX pwfx) =0;
        virtual void SetFormatInfo(LPWAVEFORMATEX pwfx) =0;
        virtual HRESULT AllocMixer(CMixer **ppMixer) =0;
        virtual void FreeMixer(void) =0;
        virtual void Play(void) =0;
        virtual void Stop(void) =0;
        virtual HRESULT GetSamplePosition(int *pposPlay, int *pposWrite) =0;
        virtual ULONG GetFrequency(void) =0;
};

//--------------------------------------------------------------------------;
//
// Woefully uncommented mixer abstract base class.
//
//--------------------------------------------------------------------------;

class CMixer {
    public:
        virtual void Terminate(void) =0;
        virtual HRESULT Run(void) =0;
        virtual BOOL Stop(void) =0;
        virtual void PlayWhenIdle(void) =0;
        virtual void StopWhenIdle(void) =0;
        virtual void MixListAdd(CMixSource *pSource) =0;
        virtual void MixListRemove(CMixSource *pSource) =0;
        virtual void FilterOn(CMixSource *pSource) =0;
        virtual void FilterOff(CMixSource *pSource) =0;
        virtual void GetBytePosition(CMixSource *pSource, int *pibPlay, int *pibWrite) =0;
        virtual void SignalRemix() =0;
};


//--------------------------------------------------------------------------;
//
// Mixer destination class for mixers in dsound.dll (CWeGrace and CNagrace).
//
//--------------------------------------------------------------------------;

class CGrDest : public CMixDest {
    public:
        virtual HRESULT Initialize(void)=0;
        virtual void Terminate(void)=0;
        virtual HRESULT SetFormat(LPWAVEFORMATEX pwfx)=0;
        virtual void SetFormatInfo(LPWAVEFORMATEX pwfx);
        virtual HRESULT AllocMixer(CMixer **ppMixer)=0;
        virtual void FreeMixer(void)=0;
        virtual void Play(void)=0;
        virtual void Stop(void)=0;
        virtual HRESULT GetSamplePosition(int *pposPlay, int *pposWrite)=0;
        virtual HRESULT GetSamplePositionNoWin16(int *pposPlay, int *pposWrite)=0;
        virtual ULONG GetFrequency(void);
        virtual HRESULT Lock(PVOID *ppBuffer1, int *pcbBuffer1, PVOID *ppBuffer2, int *pcbBuffer2, int ibWrite, int cbWrite);
        virtual HRESULT Unlock(PVOID pBuffer1, int cbBuffer1, PVOID pBuffer2, int cbBuffer2);

        // REMIND try to get these outta here, or at least protected/private
        int             m_cSamples;
        int             m_cbBuffer;
        PVOID           m_pBuffer;

        DWORD           m_hfFormat;
        ULONG           m_nFrequency;
        int             m_nBlockAlignShift;

        WAVEFORMATEX    m_wfx;
};

//--------------------------------------------------------------------------;
//
// CGrace: base class for CMixer implementations in dsound.dll.
//
//--------------------------------------------------------------------------;

class CGrace : public CMixer {
    public:
        virtual HRESULT Initialize(CGrDest *pGrDest);
        virtual void Terminate(void);
        virtual HRESULT Run(void);
        virtual BOOL Stop(void);
        virtual void PlayWhenIdle(void);
        virtual void StopWhenIdle(void);
        virtual void MixListAdd(CMixSource *pSource);
        virtual void MixListRemove(CMixSource *pSource);
        virtual void FilterOn(CMixSource *pSource);
        virtual void FilterOff(CMixSource *pSource);
        virtual void GetBytePosition(CMixSource *pSource, int *pibPlay, int *pibWrite);

        virtual HRESULT ClearAndPlayDest(void);
        virtual void SignalRemix(void)=0;
        virtual int GetMaxRemix(void)=0;

        virtual void Refresh(BOOL fRemix, int cPremixMax, int *pcPremixed, PLONG pdtimeNextNotify);
        
    protected:
        CGrDest*    m_pDest;
        int         m_fdwMixerSignal;
        MIXERSTATE  m_kMixerState;
        
    private:
        void MixNewBuffer(               CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix);
        void MixLoopingBuffer(           CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix);
        void MixNotLoopingBuffer(        CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix);
        void MixEndingBufferWaitingWrap( CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix);
        void MixEndingBuffer(            CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix);

        BOOL MixListIsValid();
        CMixSource* MixListGetNext(CMixSource *pSource);
        BOOL MixListIsEmpty();

        void mixBeginSession(int cbOutput);
        int mixMixSession(CMixSource *pSource, PDWORD pdwInputPos, DWORD dwInputBytes, DWORD OutputOffset);
        void mixWriteSession(DWORD dwWriteOffset);

        PLONG       m_plBuildBuffer;
        int         m_cbBuildBuffer;
        PLONG       m_plBuildBound;
        int         m_n_voices;


        int         m_fPlayWhenIdle;
        int         m_posPWriteLast;
        int         m_posPNextMix;
        int         m_posPPlayLast;
        ULONG       m_nLastFrequency;

        // Ptr to doubly-linked list sentinel
        CMixSource* m_pSourceListZ;

        // Handle secondary mixes
        BOOL        m_fUseSecondaryBuffer;
        PLONG       m_pSecondaryBuffer;
        LONG        m_dwSecondaryBufferFrequency;
        LONG        m_cbSecondaryBuffer;
};

//--------------------------------------------------------------------------;
//
// CWeGrace and CNaGrace class declarations;
// Respectively, the "waveOut-emulated" and "native" mixers.
//
//--------------------------------------------------------------------------;
class CWeGrace : public CGrace {
    public:
        virtual void    SignalRemix(void) {m_fdwMixerSignal |= DSMIXERSIGNAL_REMIX;}
        virtual int     GetMaxRemix(void) {return 0;} // No remixing in emulation mode
        virtual void    Refresh(int cPremixMax);
};

#ifndef NOVXD

class CNaGrace : public CGrace {
    public:
        virtual HRESULT Initialize(CGrDest *pGrDest);
        virtual void    Terminate(void);
        virtual void    SignalRemix(void);
        virtual int     GetMaxRemix(void);
        virtual void    MixThread(void);

    private:
        // Named events shared across client processes and the mixer
        // thread.  Note these are format strings
        static const char strFormatMixEventRemix[];
        static const char strFormatMixEventTerminate[];

        // Maximum amount of data we will premix, expressed in milliseconds
        static const int MIXER_MINPREMIX;
        static const int MIXER_MAXPREMIX;

        HANDLE          m_hMixThread;
        DWORD           m_vxdhMixEventRemix;
        DWORD           m_vxdhMixEventTerminate;
};

//--------------------------------------------------------------------------;
//
// CThMixer: "thunk" mixer - forwards methods to the mixer in dsound.vxd.
//
//--------------------------------------------------------------------------;
class CThMixer : public CMixer {
    public:
        virtual void Terminate(void);
        virtual HRESULT Run(void);
        virtual BOOL Stop(void);
        virtual void PlayWhenIdle(void);
        virtual void StopWhenIdle(void);
        virtual void MixListAdd(CMixSource *pSource);
        virtual void MixListRemove(CMixSource *pSource);
        virtual void FilterOn(CMixSource *pSource);
        virtual void FilterOff(CMixSource *pSource);
        virtual void GetBytePosition(CMixSource *pSource, int *pibPlay, int *pibWrite);
        virtual void SignalRemix(void);

        virtual HRESULT Initialize(PVOID pKeMixer);

    private:
        PVOID m_pKeMixer;
};

#endif // NOVXD

//--------------------------------------------------------------------------;
//
// CWeGrDest and CNaGrDest class declarations.
// The mixer destinations corresponding to CWeGrace and CNaGrace.
//
//--------------------------------------------------------------------------;
class CWeGrDest : public CGrDest {
    friend DWORD WINAPI WaveThreadC(PVOID pThreadParams);
    friend VOID CALLBACK WaveCallbackC(HWAVE hwo, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);
    friend class CEmRenderDevice;
            
    public:
        CWeGrDest(UINT uWaveDeviceId);
        virtual HRESULT Initialize(void);
        virtual void Terminate(void);
        virtual HRESULT SetFormat(LPWAVEFORMATEX pwfx);
        virtual HRESULT AllocMixer(CMixer **ppMixer);
        virtual void FreeMixer(void);
        virtual HRESULT GetSamplePosition(int *pposPlay, int *pposWrite);
        virtual HRESULT GetSamplePositionNoWin16(int *pposPlay, int *pposWrite);
        virtual void Play();
        virtual void Stop();
        
    private:
        MMRESULT InitializeEmulator(void);
        MMRESULT ShutdownEmulator(void);
        void WaveThreadLoop(HANDLE heventTerminate);
        DWORD WaveThread(void);
        VOID CALLBACK WaveCallback(HWAVE hwo, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

        
        UINT        m_uDeviceId;
        HWAVEOUT    m_hwo;
        WAVEHDR*    m_awhWaveHeaders;
        int         m_cWaveHeaders;
        int         m_iawhPlaying;
        LONG        m_cwhDone;
        int         m_cbDMASize;
        HANDLE      m_hWaveThread;
        MMRESULT    m_mmrWaveThreadInit;
        TCHAR       m_szEventWaveThreadInitDone[32];
        TCHAR       m_szEventWaveHeaderDone[32];
        TCHAR       m_szEventTerminateWaveThread[32];
        HANDLE      m_hEventWaveHeaderDone;
    
        CWeGrace*   m_pWeGrace;
};

#ifndef NOVXD

typedef struct _NAGRDESTDATA {
    LPBYTE          pBuffer;
    DWORD           cbBuffer;
    HANDLE          hBuffer;
    LPHWAVEOUT      phwo;
    UINT            uDeviceId;
    DWORD           fdwDriverDesc;
} NAGRDESTDATA, *LPNAGRDESTDATA;

class CNaGrDest : public CGrDest {
    public:
        CNaGrDest(LPNAGRDESTDATA);
        virtual HRESULT Initialize(void);
        virtual void Terminate(void);
        virtual HRESULT SetFormat(LPWAVEFORMATEX pwfx);
        virtual HRESULT AllocMixer(CMixer **);
        virtual void FreeMixer(void);
        virtual HRESULT GetSamplePosition(int *pposPlay, int *pposWrite);
        virtual HRESULT GetSamplePositionNoWin16(int *pposPlay, int *pposWrite);
        virtual HRESULT Lock(PVOID *ppBuffer1, int *pcbBuffer1, PVOID *ppBuffer2, int *pcbBuffer2, int ibWrite, int cbWrite);
        virtual HRESULT Unlock(PVOID pBuffer1, int cbBuffer1, PVOID pBuffer2, int cbBuffer2);
        virtual void Play();
        virtual void Stop();

    private:
        HANDLE      m_hBuffer;
        LPBYTE      m_pHwBuffer;
        DWORD       m_fdwDriverDesc;
        LPHWAVEOUT  m_phwo;
        UINT        m_uDeviceId;
        CNaGrace*   m_pNaGrace;
};

inline HRESULT CNaGrDest::GetSamplePositionNoWin16(int *pposPlay, int *pposWrite)
{
    return GetSamplePosition(pposPlay, pposWrite);
}

//--------------------------------------------------------------------------;
//
// CThDest: "thunk" mixer destination - forwards methods to the dsound.vxd mixer
//
//--------------------------------------------------------------------------;
class CThDest : public CMixDest {
    public:
        CThDest(LPNAGRDESTDATA pData);
        virtual HRESULT New(void);
        virtual HRESULT Initialize(void);
        virtual void Terminate(void);
        virtual HRESULT SetFormat(LPWAVEFORMATEX pwfx);
        virtual void SetFormatInfo(LPWAVEFORMATEX pwfx);
        virtual HRESULT AllocMixer(CMixer **ppMixer);
        virtual void FreeMixer(void);
        virtual void Play(void);
        virtual void Stop(void);
        virtual HRESULT GetSamplePosition(int *pposPlay, int *pposWrite);
        virtual ULONG GetFrequency(void);

    private:
        PVOID           m_pKeDest;
        CThMixer*       m_pThMixer;
        NAGRDESTDATA    m_ngdd;
};

#endif // NOVXD

#endif // __cplusplus

extern BOOL FilterPrepare(PFIRCONTEXT pFilter, int cMaxRewindSamples);
extern void FilterUnprepare(PFIRCONTEXT pFilter);
extern void FilterClear(PFIRCONTEXT pFilter);
extern void FilterChunkUpdate(PFIRCONTEXT pFilter, int cSamples);
extern void FilterRewind(PFIRCONTEXT pFilter, int cSamples);
extern void FilterAdvance(PFIRCONTEXT pFilter, int cSamples);

//--------------------------------------------------------------------------;
//
// CircularBufferRegionsIntersect
//
//        Determines whether two regions of a circular buffer intersect.
//
// Note:  I'm sure there's some well known, nice, simple algorithm to
// do this.  But I don't know it.  Here's what I came up with.
//
//--------------------------------------------------------------------------;
__inline BOOL CircularBufferRegionsIntersect
(
    int cbBuffer,
    int iStart1,
    int iLen1,
    int iStart2,
    int iLen2
)
{
    int iEnd1;
    int iEnd2;

    ASSERT(iStart1 >= 0);
    ASSERT(iStart2 >= 0);
    ASSERT(iStart1 + iLen1 >= 0);
    ASSERT(iStart2 + iLen2 >= 0);

    iEnd1 = iStart1 + iLen1;
    iEnd2 = iStart2 + iLen2;

    if ((0 == iLen1) || (0 == iLen2)) return FALSE;
    if (iStart1 == iStart2) return TRUE;
    
    // Handle r1 does not wrap
    if ((iStart1 < iStart2) && (iEnd1 > iStart2)) return TRUE;

    // Handle r2 does not wrap
    if ((iStart2 < iStart1) && (iEnd2 > iStart1)) return TRUE;

    // Handle r1 wraps
    if (iEnd1 >= cbBuffer)
    {
        iEnd1 -= cbBuffer;
        ASSERT(iEnd1 < cbBuffer);
        if (iEnd1 > iStart2) return TRUE;
    }

    // Handle r2 wraps
    if (iEnd2 >= cbBuffer)
    {
        iEnd2 -= cbBuffer;
        ASSERT(iEnd2 < cbBuffer);
        if (iEnd2 > iStart1) return TRUE;
    }
    
    return FALSE;
}

typedef struct _LOCKCIRCULARBUFFER {
#ifdef Not_VxD
    HANDLE              pHwBuffer;      // Hardware buffer pointer
#else // Not_VxD
    PIDSDRIVERBUFFER    pHwBuffer;      // Hardware buffer pointer
#endif // Not_VxD
    LPVOID              pvBuffer;       // Memory buffer pointer
    DWORD               cbBuffer;       // Memory buffer size, in bytes
    BOOL                fPrimary;       // TRUE if this is a primary buffer
    DWORD               fdwDriverDesc;  // Driver description flags
    DWORD               ibRegion;       // Byte index of region to lock
    DWORD               cbRegion;       // Size, in bytes, of region to lock
    LPVOID              pvLock[2];      // Returned lock pointers
    DWORD               cbLock[2];      // Returned lock sizes
} LOCKCIRCULARBUFFER, *PLOCKCIRCULARBUFFER;

extern HRESULT LockCircularBuffer(PLOCKCIRCULARBUFFER);
extern HRESULT UnlockCircularBuffer(PLOCKCIRCULARBUFFER);

#ifdef Not_VxD
// kernel mixer synchronization macros
extern LONG lMixerMutexMutex;
extern PLONG gpMixerMutex;
extern DWORD tidMixerOwner;
extern int cMixerEntry;

__inline DWORD ENTER_MIXER_MUTEX_OR_EVENT(HANDLE hEvent)
{
    BOOL fWait = TRUE;
    DWORD tidThisThread = GetCurrentThreadId();
    DWORD dwWait = WAIT_TIMEOUT;

    while (fWait)
    {
        // Wait for access to the mutex
        while (InterlockedExchange(&lMixerMutexMutex, TRUE))
            Sleep(1);

        // Is the event signalled?
        if (hEvent)
        {
            dwWait = WaitObject(0, hEvent);
            if (WAIT_OBJECT_0 == dwWait)
                fWait = FALSE;
        }            

        if (fWait)
        {
            if (InterlockedExchange(gpMixerMutex, TRUE))
            {
                // Somebody's got the mixer, see if it is this thread
                if (tidMixerOwner == tidThisThread)
                {
                    ASSERT(cMixerEntry > 0);
                    cMixerEntry++;
                    fWait = FALSE;
                }
            }
            else
            {
                ASSERT(0 == cMixerEntry);
                tidMixerOwner = tidThisThread;
                cMixerEntry++;
                fWait = FALSE;
            }
        }

        // No longer accessing the mutex
        InterlockedExchange(&lMixerMutexMutex, FALSE);

        if (fWait)
            Sleep(1);
    }

    return dwWait;
}

__inline void ENTER_MIXER_MUTEX(void)
{
    ENTER_MIXER_MUTEX_OR_EVENT(NULL);
}

__inline void LEAVE_MIXER_MUTEX(void)
{
    DWORD tidThisThread = GetCurrentThreadId();
    
    // Wait for access to the mutex
    while (InterlockedExchange(&lMixerMutexMutex, TRUE)) Sleep(1);

    ASSERT(tidMixerOwner == tidThisThread);
    if (0 == --cMixerEntry) {
        tidMixerOwner = 0;
        InterlockedExchange(gpMixerMutex, FALSE);
    }

    InterlockedExchange(&lMixerMutexMutex, FALSE);
}
#else // Not_VxD
__inline void ENTER_MIXER_MUTEX(void) { ASSERT(FALSE); }
__inline void LEAVE_MIXER_MUTEX(void) { ASSERT(FALSE); }

#endif // Not_VxD

#ifdef __cplusplus
};
#endif

#endif // __GRACE_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\grace.cpp ===
//--------------------------------------------------------------------------;
//
// File: grace.cpp
//
// Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// Abstract:
//
// This file contains functions related to the mixing of secondary buffers
// into a primary buffer.  Collectively, this mixing is referred to as "grace"
// for no good reason other than hoping that it is a graceful solution to the
// mixing problem.  It could easily be called "mixer" but that would be
// ambiguous with the code that actually mixes the samples together.
//
// Contents:
//
// The contained functions include a thread function that wakes
// periodically to "refresh" the data in the primary buffer by mixing in data
// from secondary buffers.  The same thread can be signalled to immediately
// remix data into the primary buffer.
//
// This also contains functions to initialize and terminate the mixing
// thread, add/remove buffers to/from the list of buffers to be mixed, and
// query the position of secondary buffers that are being mixed.
//
// History:
//  06/15/95  FrankYe   Created
//  08/25/99  DuganP    Added effects processing for DirectX 8
//
//--------------------------------------------------------------------------;
#define NODSOUNDSERVICETABLE

#include "dsoundi.h"

#ifndef Not_VxD
#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG
#endif


//--------------------------------------------------------------------------;
//
// "C" wrappers around calls to CMixDest objects
//
//--------------------------------------------------------------------------;

void MixDest_Delete(PVOID pMixDest)
{
    CMixDest *p = (CMixDest *)pMixDest;
    DELETE(p);
}

HRESULT MixDest_Initialize(PVOID pMixDest)
{
    return ((CMixDest *)pMixDest)->Initialize();
}

void MixDest_Terminate(PVOID pMixDest)
{
    ((CMixDest *)pMixDest)->Terminate();
}

HRESULT MixDest_SetFormat(PVOID pMixDest, LPWAVEFORMATEX pwfx)
{
    return ((CMixDest *)pMixDest)->SetFormat(pwfx);
}

void MixDest_SetFormatInfo(PVOID pMixDest, LPWAVEFORMATEX pwfx)
{
    ((CMixDest *)pMixDest)->SetFormatInfo(pwfx);
}

HRESULT MixDest_AllocMixer(PVOID pMixDest, PVOID *ppMixer)
{
    return ((CMixDest *)pMixDest)->AllocMixer((CMixer**)ppMixer);
}

void MixDest_FreeMixer(PVOID pMixDest)
{
    ((CMixDest *)pMixDest)->FreeMixer();
}

void MixDest_Play(PVOID pMixDest)
{
    ((CMixDest *)pMixDest)->Play();
}

void MixDest_Stop(PVOID pMixDest)
{
    ((CMixDest *)pMixDest)->Stop();
}

ULONG MixDest_GetFrequency(PVOID pMixDest)
{
    return ((CMixDest *)pMixDest)->GetFrequency();
}

HRESULT MixDest_GetSamplePosition(PVOID pMixDest, int *pposPlay, int *pposWrite)
{
    return ((CMixDest *)pMixDest)->GetSamplePosition(pposPlay, pposWrite);
}


//--------------------------------------------------------------------------;
//
// CGrDest object
//
//--------------------------------------------------------------------------;

void CGrDest::SetFormatInfo(LPWAVEFORMATEX pwfx)
{
    ASSERT(pwfx->wFormatTag == WAVE_FORMAT_PCM);
    
    m_nFrequency = pwfx->nSamplesPerSec;

    m_hfFormat = H_LOOP;

    if(pwfx->wBitsPerSample == 8)
        m_hfFormat |= (H_8_BITS | H_UNSIGNED);
    else
        m_hfFormat |= (H_16_BITS | H_SIGNED);

    if(pwfx->nChannels == 2)
        m_hfFormat |= (H_STEREO | H_ORDER_LR);
    else
        m_hfFormat |= H_MONO;

    m_cSamples = m_cbBuffer / pwfx->nBlockAlign;

    switch (pwfx->nBlockAlign)
    {
        case 1:
            m_nBlockAlignShift = 0;
            break;
        case 2:
            m_nBlockAlignShift = 1;
            break;
        case 4:
            m_nBlockAlignShift = 2;
            break;
        default:
            ASSERT(FALSE);
    }

    CopyMemory(&m_wfx, pwfx, sizeof(m_wfx));
}

ULONG CGrDest::GetFrequency()
{
    return m_nFrequency;
}

HRESULT CGrDest::Lock(PVOID *ppBuffer1, int *pcbBuffer1, PVOID *ppBuffer2, int *pcbBuffer2, int ibWrite, int cbWrite)
{
    LPBYTE  pbBuffer;
    BOOL    fWrap;
    HRESULT hr = DSERR_GENERIC;
    
    if(m_pBuffer && cbWrite > 0)
    {
        pbBuffer = (LPBYTE)m_pBuffer;
        fWrap = (ibWrite + cbWrite) > m_cbBuffer;
                    
        *ppBuffer1 = pbBuffer + ibWrite;
        *pcbBuffer1 = fWrap ? m_cbBuffer - ibWrite : cbWrite;
    
        if (ppBuffer2) *ppBuffer2 = fWrap ? pbBuffer : NULL;
        if (pcbBuffer2) *pcbBuffer2 = fWrap ? ibWrite + cbWrite - m_cbBuffer : 0;

        hr = S_OK;
    }

    return hr;
}

HRESULT CGrDest::Unlock(PVOID pBuffer1, int cbBuffer1, PVOID pBuffer2, int cbBuffer2)
{
    return S_OK;
}


//--------------------------------------------------------------------------;
//
// "C" wrappers around calls to CMixer objects
//
//--------------------------------------------------------------------------;

void Mixer_SignalRemix(PVOID pMixer)
{
    ((CMixer *)pMixer)->SignalRemix();
}

HRESULT Mixer_Run(PVOID pMixer)
{
    return ((CMixer *)pMixer)->Run();
}

BOOL Mixer_Stop(PVOID pMixer)
{
    return ((CMixer *)pMixer)->Stop();
}

void Mixer_PlayWhenIdle(PVOID pMixer)
{
    ((CMixer *)pMixer)->PlayWhenIdle();
}

void Mixer_StopWhenIdle(PVOID pMixer)
{
    ((CMixer *)pMixer)->StopWhenIdle();
}

//--------------------------------------------------------------------------;
//
// CGrace object
//
//--------------------------------------------------------------------------;

HRESULT CGrace::Initialize(CGrDest *pDest)
{
    HRESULT hr;
    
    ASSERT(!m_pSourceListZ);
    ASSERT(!m_pDest);
    
    // initialize the doubly linked list sentinel
    m_pSourceListZ = NEW(CMixSource(this));
    if (m_pSourceListZ) {
        m_pSourceListZ->m_pNextMix = m_pSourceListZ;
        m_pSourceListZ->m_pPrevMix = m_pSourceListZ;

        m_cbBuildBuffer = pDest->m_cbBuffer * 4;
        m_plBuildBuffer = (PLONG)MEMALLOC_A(BYTE, m_cbBuildBuffer);
        if (m_plBuildBuffer) {
            m_pDest = pDest;
            hr = S_OK;
        } else {
            DELETE(m_pSourceListZ);
            hr = DSERR_OUTOFMEMORY;
        }
    } else {
        hr = DSERR_OUTOFMEMORY;
    }

    m_pSecondaryBuffer    = NULL;
    m_fUseSecondaryBuffer = FALSE;
    
    return hr;
}

void CGrace::Terminate()
{
    ASSERT(m_pSourceListZ);
    ASSERT(m_plBuildBuffer);
    DELETE(m_pSourceListZ);
    MEMFREE(m_plBuildBuffer);
    MEMFREE(m_pSecondaryBuffer);
}

void CGrace::MixEndingBuffer(CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix)
{
    //DPF(3, "~`S4");
    //DPF(4, "uMixEndingBuffer");

    // REMIND This assert will fail when a setposition call comes in.
    // We should change the setposition stuff and put this assert back in.
    // ASSERT(0 == pSource->m_posNextMix);

    if ((posPPlay >= pSource->m_posPEnd) || (posPPlay < pSource->m_posPPlayLast)) {

        LONG dbNextNotify;
        BOOL fSwitchedLooping;
        
        //DPF(3, "~`X");
        
        fSwitchedLooping  = (0 != (pSource->m_hfFormat & H_LOOP));

        pSource->NotifyToPosition(0, &dbNextNotify);
        MixListRemove(pSource);
        pSource->m_kMixerState = MIXSOURCESTATE_STOPPED;
        pSource->m_posNextMix = 0;

        // Since this buffer still has status = playing, we need to honor a
        // looping change even though the play position may have reached the
        // end of this buffer.
        if (fSwitchedLooping) {
            MixListAdd(pSource);
            MixNewBuffer(pSource, posPPlay, posPMix, dposPRemix, cPMix);
        } else {
            // We really did stop
            pSource->NotifyStop();
        }
        return;
    }

    if (posPMix > posPPlay)
        ASSERT(posPMix + dposPRemix >= pSource->m_posPEnd);

    //
    // Haven't reached end yet so let's check for a few remix events...
    //

    // Check for SETPOSITION signal
    if (0 != (DSBMIXERSIGNAL_SETPOSITION & pSource->m_fdwMixerSignal)) {
        pSource->m_kMixerState = MIXSOURCESTATE_NOTLOOPING;
        //DPF(3, "~`S42");
        MixNotLoopingBuffer(pSource, posPPlay, posPMix, 0, cPMix);
        return;
    }

    // Check for remix
    if (0 != dposPRemix) {

        // If the Mix position is outside of the range between the Play
        // and End positions, then we don't remix anything.
        if ((posPMix >= posPPlay) && (posPMix < pSource->m_posPEnd)) {
            if (dposPRemix < pSource->m_posPEnd - posPMix) {
                //DPF(3, "!dposPRemix=%04Xh, m_posPEnd=%04Xh, posPMIx=%04Xh", dposPRemix, pSource->m_posPEnd, posPMix);
            }
            
            dposPRemix = pSource->m_posPEnd - posPMix;

            pSource->m_kMixerState = MIXSOURCESTATE_NOTLOOPING;
            //DPF(3, "~`S42");
            MixNotLoopingBuffer(pSource, posPPlay, posPMix, dposPRemix, cPMix);
            return;
        }
        //DPF(3, "~`S44");
    }

    // Handle substate transition
    switch (pSource->m_kMixerSubstate)
    {
        case MIXSOURCESUBSTATE_NEW:
            ASSERT(FALSE);
            break;
        case MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP:
            ASSERT(posPPlay >= pSource->m_posPPlayLast);
            // A wrap would have been caught above and this buffer stopped
            break;
        case MIXSOURCESUBSTATE_STARTING:
            ASSERT(posPPlay >= pSource->m_posPPlayLast);
            // A wrap would have been caught above and this buffer stopped
            if (posPPlay >= pSource->m_posPStart)
                pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
            break;
        case MIXSOURCESUBSTATE_STARTED:
            break;
        default:
            ASSERT(FALSE);
    }

    pSource->m_posPPlayLast = posPPlay;
}

void CGrace::MixEndingBufferWaitingWrap(CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix)
{
    //DPF(4, "uMixEndingBufferWaitingWrap");

    if (posPPlay < pSource->m_posPPlayLast) {

        // handle substate transition
        switch (pSource->m_kMixerSubstate)
        {
            case MIXSOURCESUBSTATE_NEW:
                //DPF(3, "uMixEndingBufferWaitingWrap: error: encountered MIXSOURCESUBSTATE_NEW");
                // ASSERT(FALSE);
                break;
            case MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP:
                pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTING;
                break;
            case MIXSOURCESUBSTATE_STARTING:
                pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
                break;
            case MIXSOURCESUBSTATE_STARTED:
                break;
            default:
                ASSERT(FALSE);
        }

        pSource->m_posPPlayLast = posPPlay;
        pSource->m_kMixerState = MIXSOURCESTATE_ENDING;
        //DPF(3, "~`S34");
        MixEndingBuffer(pSource, posPPlay, posPMix, dposPRemix, cPMix);
        return;
    }

    // Haven't wrapped yet.

    if (0 != (DSBMIXERSIGNAL_SETPOSITION & pSource->m_fdwMixerSignal)) {
        pSource->m_kMixerState = MIXSOURCESTATE_NOTLOOPING;
        //DPF(3, "~`S32");
        MixNotLoopingBuffer(pSource, posPPlay, posPMix, 0, cPMix);
        return;
    }

    // Check for remix
    if (0 != dposPRemix) {

        // If the Mix position is outside of the range between the Play
        // and End positions, then we don't remix anything.
        if ((posPMix >= posPPlay) || (posPMix < pSource->m_posPEnd)) {
            dposPRemix = pSource->m_posPEnd - posPMix;

            if (dposPRemix < 0) dposPRemix += m_pDest->m_cSamples;
            ASSERT(dposPRemix >= 0);

            pSource->m_kMixerState = MIXSOURCESTATE_NOTLOOPING;
            //DPF(3, "~`S32");
            MixNotLoopingBuffer(pSource, posPPlay, posPMix, dposPRemix, cPMix);
            return;
        }
    }

    // handle substate transition
    switch (pSource->m_kMixerSubstate)
    {
        case MIXSOURCESUBSTATE_NEW:
            ASSERT(FALSE);
            break;
        case MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP:
            // A wrap would have been caught above and control sent to
            // uMixEndingBuffer.
            ASSERT(posPPlay >= pSource->m_posPPlayLast);
            break;
        case MIXSOURCESUBSTATE_STARTING:
            // A wrap would have been caught above and control sent to
            // uMixEndingBuffer.
            ASSERT(posPPlay >= pSource->m_posPPlayLast);
            if (posPPlay >= pSource->m_posPStart)
                pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
            break;
        case MIXSOURCESUBSTATE_STARTED:
            break;
        default:
            ASSERT(FALSE);
    }

    pSource->m_posPPlayLast = posPPlay;
}

void CGrace::MixNotLoopingBuffer(CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix)
{
    int     posMix;
    int     dposEnd;
    int     cPMixed;
    DWORD   dwPosition;

    //DPF(4, "uMixNotLoopingBuffer");

    if (0 != (H_LOOP & pSource->m_hfFormat)) {
        // We've switched from not looping to looping
        pSource->m_kMixerState = MIXSOURCESTATE_LOOPING;
        //DPF(3, "~`S21");
        MixLoopingBuffer(pSource, posPPlay, posPMix, dposPRemix, cPMix);
        return;
    }

    // On a SetPosition, we ignore the remix length and posNextMix will
    // contain the new position at which to start mixing the secondary buffer
    if (0 != (DSBMIXERSIGNAL_SETPOSITION & pSource->m_fdwMixerSignal)) {
        pSource->m_fdwMixerSignal  &= ~DSBMIXERSIGNAL_SETPOSITION;
        //DPF(3, "~`S20");
        MixNewBuffer(pSource, posPPlay, posPMix, 0, cPMix);
        return;
    }

    // Handle substate transition
    switch (pSource->m_kMixerSubstate)
    {
        case MIXSOURCESUBSTATE_NEW:
            ASSERT(FALSE);
            break;
        case MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP:
            if (posPPlay < pSource->m_posPPlayLast)
                if (posPPlay >= pSource->m_posPStart)
                    pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
                else
                    pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTING;
            break;
        case MIXSOURCESUBSTATE_STARTING:
            if ((posPPlay >= pSource->m_posPStart) || (posPPlay < pSource->m_posPPlayLast))
                pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
            break;
        case MIXSOURCESUBSTATE_STARTED:
            break;
        default:
            ASSERT(FALSE);
    }
            
    //
    if (0 == dposPRemix) {
        posMix = pSource->m_posNextMix;
    } else {
        LONG dposRemix;

        dposRemix = MulDivRN(dposPRemix, pSource->m_nLastFrequency, m_pDest->m_nFrequency);
        posMix = pSource->m_posNextMix - dposRemix;
        while (posMix < 0) posMix += pSource->m_cSamples;

        // Rewind the filter
        pSource->FilterRewind(dposPRemix);

#ifdef PROFILEREMIXING
        pSource->CountSamplesRemixed(dposRemix);
#endif
    }

    ASSERT(0 == (H_LOOP & pSource->m_hfFormat));

    dposEnd = pSource->m_cSamples - posMix;

    if (pSource->GetMute()) {
        int cMixMuted;

        cMixMuted = MulDivRN(cPMix, pSource->m_nFrequency, m_pDest->m_nFrequency);
        cPMixed = cPMix;
        if (dposEnd < cMixMuted) {
            cMixMuted = dposEnd;
            cPMixed = MulDivRN(cMixMuted, m_pDest->m_nFrequency, pSource->m_nFrequency);
        }

        // Advance the filter
        pSource->FilterAdvance(cPMixed);
        
        dwPosition = (posMix + cMixMuted) << pSource->m_nBlockAlignShift;

    } else {
        dwPosition = posMix << pSource->m_nBlockAlignShift;
        cPMixed = mixMixSession(pSource, &dwPosition, dposEnd << pSource->m_nBlockAlignShift, 0);
    }

    // See if this non-looping buffer has reached the end
    // //DPF(3, "~`S2pos:%08X", dwPosition);
    if (dwPosition >= (DWORD)pSource->m_cbBuffer) {

        dwPosition = 0;

        // determine position in primary buffer that corresponds to the
        // end of this secondary buffer
        pSource->m_posPEnd = posPMix + cPMixed;
        while (pSource->m_posPEnd >= m_pDest->m_cSamples) pSource->m_posPEnd -= m_pDest->m_cSamples;

        if (pSource->m_posPEnd < posPPlay) {
            //DPF(3, "~`S23");
            pSource->m_kMixerState = MIXSOURCESTATE_ENDING_WAITINGPRIMARYWRAP;
        } else {
            //DPF(3, "~`S24");
            pSource->m_kMixerState = MIXSOURCESTATE_ENDING;
        }
    }
    
    pSource->m_posPPlayLast = posPPlay;
    pSource->m_posNextMix = dwPosition >> pSource->m_nBlockAlignShift;
    pSource->m_nLastFrequency = pSource->m_nFrequency;

    // Profile remixing
#ifdef PROFILEREMIXING
    {
        int cMixed = pSource->m_posNextMix - posMix;
        if (cMixed < 0) cMixed += pSource->m_cSamples;
        pSource->CountSamplesMixed(cMixed);
    }
#endif
}

void CGrace::MixLoopingBuffer(CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix)
{
    LONG    posMix;
    DWORD   dwPosition;

    //DPF(4, "uMixLoopingBuffer");

    if (0 == (H_LOOP & pSource->m_hfFormat)) {
        // We've switched from looping to non-looping
        pSource->m_kMixerState = MIXSOURCESTATE_NOTLOOPING;
        //DPF(3, "~`S12");
        MixNotLoopingBuffer(pSource, posPPlay, posPMix, dposPRemix, cPMix);
        return;
    }
    
    // on a SetPosition, we ignore the remix length and posNextMix will
    // contain the new position at which to start mixing the secondary buffer
    if (0 != (DSBMIXERSIGNAL_SETPOSITION & pSource->m_fdwMixerSignal)) {
        pSource->m_fdwMixerSignal  &= ~DSBMIXERSIGNAL_SETPOSITION;
        //DPF(3, "~`S10");
        MixNewBuffer(pSource, posPPlay, posPMix, 0, cPMix);
        return;
    }

    // handle substate transition
    switch (pSource->m_kMixerSubstate)
    {
        case MIXSOURCESUBSTATE_NEW:
            ASSERT(FALSE);
            break;
        case MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP:
            if (posPPlay < pSource->m_posPPlayLast) {
                if (posPPlay >= pSource->m_posPStart) {
                    pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
                } else {
                    pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTING;
                }
            }
            break;
        case MIXSOURCESUBSTATE_STARTING:
            if ((posPPlay >= pSource->m_posPStart) || (posPPlay < pSource->m_posPPlayLast)) {
                pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTED;
            }
            break;
        case MIXSOURCESUBSTATE_STARTED:
            break;
        default:
            ASSERT(FALSE);
    }
            
    if (0 == dposPRemix) {
        posMix = pSource->m_posNextMix;
    } else {
        LONG dposRemix = MulDivRN(dposPRemix, pSource->m_nLastFrequency, m_pDest->m_nFrequency);
        posMix = pSource->m_posNextMix - dposRemix;
        while (posMix < 0)
            posMix += pSource->m_cSamples;

        // Rewind the filter
        pSource->FilterRewind(dposPRemix);
        
#ifdef PROFILEREMIXING
        pSource->CountSamplesRemixed(dposRemix);
#endif
    }

    ASSERT(H_LOOP & pSource->m_hfFormat);

    if (pSource->GetMute()) {
        int cMix = MulDivRN(cPMix, pSource->m_nFrequency, m_pDest->m_nFrequency);

        // Advance the filter
        pSource->FilterAdvance(cPMix);
        
        dwPosition = (posMix + cMix) << pSource->m_nBlockAlignShift;
        while (dwPosition >= (DWORD)pSource->m_cbBuffer)
            dwPosition -= (DWORD)pSource->m_cbBuffer;

    } else {
        dwPosition = posMix << pSource->m_nBlockAlignShift;
        mixMixSession(pSource, &dwPosition, 0, 0);
    }

    pSource->m_posPPlayLast = posPPlay;
    pSource->m_posNextMix = dwPosition >> pSource->m_nBlockAlignShift;
    pSource->m_nLastFrequency = pSource->m_nFrequency;

    // Profile remixing
#ifdef PROFILEREMIXING
    {
        int cMixed = pSource->m_posNextMix - posMix;
        if (cMixed < 0) cMixed += pSource->m_cSamples;
        pSource->CountSamplesMixed(cMixed);
    }
#endif
}

void CGrace::MixNewBuffer(CMixSource *pSource, LONG posPPlay, LONG posPMix, LONG dposPRemix, LONG cPMix)
{
    BOOL fLooping;

    //DPF(4, "uMixNewBuffer");

    //
    // Determine position in primary buffer at which this buffer starts playing
    //
    pSource->m_posPStart = posPMix;
    if (posPPlay < pSource->m_posPStart) {
        pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTING;
    } else {
        pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP;
    }

    pSource->m_posPPlayLast = posPPlay;

    pSource->FilterClear();

    fLooping = (0 != (H_LOOP & pSource->m_hfFormat));

    if (fLooping) {
        //DPF(3, "~`S01");
        pSource->m_kMixerState = MIXSOURCESTATE_LOOPING;
        MixLoopingBuffer(pSource, posPPlay, posPMix, 0, cPMix);
    } else {
        //DPF(3, "~`S02");
        pSource->m_kMixerState = MIXSOURCESTATE_NOTLOOPING;
        MixNotLoopingBuffer(pSource, posPPlay, posPMix, 0, cPMix);
    }
}

void CGrace::Refresh(IN  BOOL fRemix,
                     IN  int cPremixMax,
                     OUT int *pcPremixed,
                     OUT PLONG pdtimeNextNotify)
{
    int         posPPlay;
    int         posPWrite;
    int         posPMix;
    int         dposPRemix;
    int         cMix;
    int         cMixThisLoop;
    int         dcMixThisLoop;
    CMixSource  *pSourceNext;
    CMixSource  *pSource;
    HRESULT     hr;

    // REMIND do we need to worry about ApmSuspended or will we always be stopped?
    // ASSERT(!gpdsinfo->fApmSuspended);
    // if (gpdsinfo->fApmSuspended) goto retClean;

    *pcPremixed = cPremixMax;
    *pdtimeNextNotify = MAXLONG;
    if (MIXERSTATE_IDLE == m_kMixerState) return;
    
    hr = m_pDest->GetSamplePositionNoWin16(&posPPlay, &posPWrite);
    if (FAILED(hr)) return;
    ASSERT(posPPlay != posPWrite);
    
    // Just make sure we have valid values.
    ASSERT(posPPlay  < m_pDest->m_cSamples);
    ASSERT(posPWrite < m_pDest->m_cSamples);

    switch (m_kMixerState)
    {
        case MIXERSTATE_LOOPING:
            // We can make this assertion because we never mix up to
            // the write cursor.
            ASSERT(m_posPWriteLast != m_posPNextMix);

            // Under normal conditions, the Write position should be between
            // the WriteLast position and the NextMix position.  We can check
            // for an invalid state (resulting most likely from a very late
            // wakeup) by checking whether the Write position is beyond our
            // NextMix position.  If we find ourselves in this shakey
            // situation, then we treat this similar to the START state.
            // Note that if our wakeup is so late that the Write position wraps
            // all the way around past the WriteLast position, we can't detect
            // the fact that we're in a bad situation.

            if ((m_posPWriteLast < m_posPNextMix &&
                 (posPWrite > m_posPNextMix || posPWrite < m_posPWriteLast)) ||
                (m_posPWriteLast > m_posPNextMix &&
                 (posPWrite > m_posPNextMix && posPWrite < m_posPWriteLast)))
            {
                // We're in trouble
                #ifdef Not_VxD
                    DPF(DPFLVL_ERROR, "Slept late");
                #else
                    DPF(("Slept late"));
                #endif
                posPMix = posPWrite;
                dposPRemix = 0;
                break;
            }

            if (fRemix) {
                dposPRemix = m_posPNextMix - posPWrite;
                if (dposPRemix < 0) dposPRemix += m_pDest->m_cSamples;
                ASSERT(dposPRemix >= 0);
                dposPRemix -= dposPRemix % MIXER_REWINDGRANULARITY;
                posPMix = m_posPNextMix - dposPRemix;
                if (posPMix < 0) posPMix += m_pDest->m_cSamples;
                ASSERT(posPMix >= 0);
            } else {
                posPMix = m_posPNextMix;
                dposPRemix = 0;
            }
            break;

        case MIXERSTATE_STARTING:
            m_posPPlayLast = posPPlay;
            m_posPWriteLast = posPWrite;
            posPMix = posPWrite;
            dposPRemix = 0;
            m_kMixerState = MIXERSTATE_LOOPING;
            break;

        default:
            ASSERT(FALSE);
    }

    //
    // Determine how much to mix.
    //
    // We don't want to mix more than dtimePremixMax beyond the Write cursor,
    // nor do we want to wrap past the Play cursor.
    //
    // The assertions (cMix >= 0) below are valid because:
    //            -cPremixMax is always growing
    //            -the Write cursor is always advancing (or hasn't moved yet)
    //            -posPMix is never beyond the previous write cursor plus
    //                the previous cPremixMax.
    //
    // The only time cPremixMax is not growing is on a remix in which case
    // the Mix position is equal to the Write cursor, so the assertions
    // are still okay.  The only time the write cursor would not appear to be
    // advancing is if we had a very late wakeup.  A very late wakeup would
    // be caught and adjusted for in the MIXERSTATE_LOOPING handling above.
    //
    if (posPWrite <= posPMix) {
        cMix = posPWrite + cPremixMax - posPMix;
        ASSERT(cMix >= 0);
    } else {
        cMix = posPWrite + cPremixMax - (posPMix + m_pDest->m_cSamples);
        ASSERT(cMix >= 0);
    }

    //
    // If posPPlay==posPMix, then we think we're executing a mix again before
    // the play or write cursors have advanced at all.  cMix==0, and we don't
    // mix no more!
    //
    if (posPPlay >= posPMix) {
        cMix = min(cMix, posPPlay - posPMix);
    } else {
        cMix = min(cMix, posPPlay + m_pDest->m_cSamples - posPMix);
    }
        
    ASSERT(cMix < m_pDest->m_cSamples);        // sanity check
    ASSERT(cMix >= 0);

    //
    // Always mix a multiple of the remix interval
    //
    cMix -= cMix % MIXER_REWINDGRANULARITY;

    // We break the mixing up into small chunks, increasing the size of the
    // chunk as we go.  By doing this, data gets written into the primary
    // buffer sooner.  Otherwise, if we have a buttload of data to mix, we'd
    // spend a lot of time mixing into the mix buffer before any data gets
    // written to the primary buffer and the play cursor might catch up
    // to us.  Here, we start mixing a ~8ms chunk of data and increase the
    // chunk size each iteration.
    
    cMixThisLoop = m_pDest->m_nFrequency / 128;
    dcMixThisLoop = cMixThisLoop;
    
    ASSERT(MixListIsValid());
    
    while (cMix > 0) {
        LONG cThisMix;
        
        cThisMix = min(cMix, cMixThisLoop);
        cMixThisLoop += dcMixThisLoop;
        
        mixBeginSession(cThisMix << m_pDest->m_nBlockAlignShift);
                
        // Get data for each buffer
        pSourceNext = MixListGetNext(m_pSourceListZ);
        while (pSourceNext) {

            // The uMixXxx buffer mix state handlers called below may cause
            // the pSource to be removed from the mix list.  So, we get the
            // pointer to the next pSource in the mix list now before any
            // of the uMixXxx functions are called.
            pSource = pSourceNext;
            pSourceNext = MixListGetNext(pSource);

            // Prepare for 3D processing (the actual work is done as part of mixing)
            pSource->FilterChunkUpdate(cThisMix);
            
            switch (pSource->m_kMixerState)
            {
                case MIXSOURCESTATE_NEW:
                    MixNewBuffer(pSource, posPPlay, posPMix, dposPRemix, cThisMix);
                    break;
                case MIXSOURCESTATE_LOOPING:
                    MixLoopingBuffer(pSource, posPPlay, posPMix, dposPRemix, cThisMix);
                    break;
                case MIXSOURCESTATE_NOTLOOPING:
                    MixNotLoopingBuffer(pSource, posPPlay, posPMix, dposPRemix, cThisMix);
                    break;
                case MIXSOURCESTATE_ENDING_WAITINGPRIMARYWRAP:
                    MixEndingBufferWaitingWrap(pSource, posPPlay, posPMix, dposPRemix, cThisMix);
                    break;
                case MIXSOURCESTATE_ENDING:
                    MixEndingBuffer(pSource, posPPlay, posPMix, dposPRemix, cThisMix);
                    break;
                default:
                    ASSERT(FALSE);
                    break;
            }
        }

        //  Lock the output buffer, and if that is successful then write out
        //  the mix session.
        {
            PVOID pBuffer1;
            PVOID pBuffer2;
            int cbBuffer1;
            int cbBuffer2;
            int ibWrite;
            int cbWrite;
        
            ibWrite = posPMix << m_pDest->m_nBlockAlignShift;
            cbWrite = cThisMix << m_pDest->m_nBlockAlignShift;

            hr = m_pDest->Lock(&pBuffer1, &cbBuffer1, &pBuffer2, &cbBuffer2,
                               ibWrite, cbWrite);

            //DPF(5,"graceMix: lock primary buffer, bufptr=0x%8x, dwWriteOffset=%lu, dwSize=%lu, hr=%lu.",m_pDest->m_pBuffer,ibWrite,cbWrite,hr);

            // Validate that we really locked what we wanted or got an error.
            ASSERT(DS_OK != hr || pBuffer1 == (PBYTE)m_pDest->m_pBuffer + ibWrite);
            ASSERT(DS_OK != hr || pBuffer2 == m_pDest->m_pBuffer || 0 == cbBuffer2);
            ASSERT(DS_OK != hr || cbWrite == cbBuffer1+cbBuffer2);

            if(DS_OK == hr)
            {
                ASSERT(ibWrite < m_pDest->m_cbBuffer);
                mixWriteSession(ibWrite);

                // DPF(5, "Refresh: unlocking primary buffer");
                hr = m_pDest->Unlock(pBuffer1, cbBuffer1, pBuffer2, cbBuffer2);
            }
        }

        posPMix += cThisMix;
        if (posPMix >= m_pDest->m_cSamples) posPMix -= m_pDest->m_cSamples;
        ASSERT(posPMix < m_pDest->m_cSamples);

        dposPRemix = 0;
        cMix -= cThisMix;
    }

    m_posPNextMix = posPMix;
    
    // Calculate and return the amount of time from the current Write
    // cursor to the NextMix position.

    if (m_posPNextMix > posPWrite) {
        *pcPremixed = (m_posPNextMix - posPWrite);
    } else {
        *pcPremixed = (m_posPNextMix + m_pDest->m_cSamples - posPWrite);
    }

    // Remember the last Play and Write positions of the primary buffer.
    m_posPPlayLast  = posPPlay;
    m_posPWriteLast = posPWrite;
    
    // Process position events for each source
    for (pSource = MixListGetNext(m_pSourceListZ);
         pSource;
         pSource = MixListGetNext(pSource))
    {
        int ibPosition;
        LONG dtimeNextNotifyT;

        if (pSource->HasNotifications()) {
            GetBytePosition(pSource, &ibPosition, NULL);
            pSource->NotifyToPosition(ibPosition, &dtimeNextNotifyT);
            *pdtimeNextNotify = min(*pdtimeNextNotify, dtimeNextNotifyT);
        }
    }

    m_fdwMixerSignal &= ~DSMIXERSIGNAL_REMIX;
}

HRESULT CGrace::Run()
{
    if (MIXERSTATE_STOPPED != m_kMixerState) return S_OK;

    ASSERT(MixListIsEmpty());
    
    if (m_fPlayWhenIdle) ClearAndPlayDest();

    m_kMixerState = MIXERSTATE_IDLE;

    return S_OK;
}

BOOL CGrace::Stop()
{
    ASSERT(MixListIsEmpty());
    
    if (MIXERSTATE_STOPPED == m_kMixerState) return FALSE;

    m_kMixerState = MIXERSTATE_STOPPED;

    // if (m_fPlayWhenIdle || !MixListIsEmpty()) m_pDest->Stop();
    if (m_fPlayWhenIdle) m_pDest->Stop();

    return TRUE;
}

void CGrace::PlayWhenIdle()
{
    m_fPlayWhenIdle = TRUE;
    if (MixListIsEmpty()) ClearAndPlayDest();
}

void CGrace::StopWhenIdle()
{
    m_fPlayWhenIdle = FALSE;
    if (MixListIsEmpty()) m_pDest->Stop();
}

HRESULT CGrace::ClearAndPlayDest(void)
{
    PVOID   pvLockedBuffer;
    int     cbLockedBuffer;
    int     cbBuffer;
    HRESULT hr;

    //
    // 1) Lock the entire dest buffer
    // 2) Fill it with silence
    // 3) Unlock the dest buffer
    // 4) Play the darn thing
    //

    cbBuffer = m_pDest->m_cSamples << m_pDest->m_nBlockAlignShift;
    
    hr = m_pDest->Lock(&pvLockedBuffer, &cbLockedBuffer, NULL, NULL, 0, cbBuffer);

    if (S_OK == hr && pvLockedBuffer && cbLockedBuffer > 0)
    {
        //  Write the silence.
            FillMemory(pvLockedBuffer, cbLockedBuffer, (H_16_BITS & m_pDest->m_hfFormat) ? 0x00 : 0x80);
            m_pDest->Unlock(pvLockedBuffer, cbLockedBuffer, 0, 0);

            m_pDest->Play();
    }

    return hr;
}

void CGrace::MixListAdd(CMixSource *pSource)
{
    ASSERT(MixListIsValid());
    ASSERT(!pSource->m_pNextMix);
    ASSERT(!pSource->m_pPrevMix);
    ASSERT(MIXERSTATE_STOPPED != m_kMixerState);

    // if the mix list is empty, we may need to run the MixDest.  We may
    // also need to make a state transition from IDLE to STARTING.
    if (MixListIsEmpty()) {
        if (!m_fPlayWhenIdle) ClearAndPlayDest();
        if (MIXERSTATE_IDLE == m_kMixerState) m_kMixerState = MIXERSTATE_STARTING;
    } else {
        ASSERT(MIXERSTATE_IDLE != m_kMixerState);
    }

    // initialize source-specific mixer state
    pSource->m_kMixerState = MIXSOURCESTATE_NEW;
    pSource->m_kMixerSubstate = MIXSOURCESUBSTATE_NEW;
    pSource->m_nLastFrequency = pSource->m_nFrequency;

    // prepare the source's filter
    pSource->FilterPrepare(this->GetMaxRemix());

    // doubly linked list insertion
    pSource->m_pNextMix = m_pSourceListZ->m_pNextMix;
    m_pSourceListZ->m_pNextMix->m_pPrevMix = pSource;
    m_pSourceListZ->m_pNextMix = pSource;
    pSource->m_pPrevMix = m_pSourceListZ;
}

void CGrace::MixListRemove(CMixSource *pSource)
{
    ASSERT(MixListIsValid());
    ASSERT(pSource->m_pNextMix);
    ASSERT(pSource->m_pPrevMix);
    ASSERT(MIXERSTATE_STOPPED != m_kMixerState);
    ASSERT(MIXERSTATE_IDLE != m_kMixerState);

    // doubly linked list deletion
    pSource->m_pPrevMix->m_pNextMix = pSource->m_pNextMix;
    pSource->m_pNextMix->m_pPrevMix = pSource->m_pPrevMix;
    pSource->m_pNextMix = NULL;
    pSource->m_pPrevMix = NULL;

    // unpreprare the source's filter
    pSource->FilterUnprepare();
    //
    pSource->m_kMixerState = MIXSOURCESTATE_STOPPED;

    // if we should stop the MixDest when there's nothing to mix, then also
    // transition to the IDLE state.
    if (!m_fPlayWhenIdle && MixListIsEmpty()) {
        m_pDest->Stop();
        m_kMixerState = MIXERSTATE_IDLE;
    }
}

//--------------------------------------------------------------------------;
//
// CGrace::FilterOn
//
//        Instructs mixer to enable filtering of the MixSource
//
// If filtering is already on, then do nothing.  Otherwise, set the H_FILTER
// flag in the MixSource.  Also, if the MixSource is not stopped, then prepare
// and clear the filter.
//
//--------------------------------------------------------------------------;

void CGrace::FilterOn(CMixSource *pSource)
{
    if (0 == (H_FILTER & pSource->m_hfFormat)) {
        pSource->m_hfFormat |= H_FILTER;
        if (pSource->IsPlaying()) {
            pSource->FilterPrepare(this->GetMaxRemix());
            pSource->FilterClear();
        }
    }
}

//--------------------------------------------------------------------------;
//
// CGrace::FilterOff
//
//        Instructs mixer to disable filtering of the MixSource
//
// If filtering is already off, then do nothing.  Otherwise, clear the H_FILTER
// flag in the MixSource.  Also, if the MixSource is not stopped, then
// unprepare the filter.
//
//--------------------------------------------------------------------------;

void CGrace::FilterOff(CMixSource *pSource)
{
    if (H_FILTER & pSource->m_hfFormat) {
        if (pSource->IsPlaying()) {
            pSource->FilterUnprepare();
        }
        pSource->m_hfFormat &= ~H_FILTER;
    }
}

BOOL CGrace::MixListIsValid()
{
    CMixSource *pSourceT;

    for (pSourceT = MixListGetNext(m_pSourceListZ); pSourceT; pSourceT = MixListGetNext(pSourceT)) {
        // if (DSBUFFSIG != pSourceT->m_pdsb->dwSig) break;
        // if (DSB_INTERNALF_HARDWARE & pSourceT->m_pdsb->fdwDsbI) break;
        // if (0 == pSourceT->m_nFrequency) break;
        if (MIXSOURCE_SIGNATURE != pSourceT->m_dwSignature) break;
    }

    return (!pSourceT);
}

CMixSource* CGrace::MixListGetNext(CMixSource* pSource)
{
    if (pSource->m_pNextMix != m_pSourceListZ) {
        return pSource->m_pNextMix;
    } else {
        return NULL;
    }
}

BOOL CGrace::MixListIsEmpty(void)
{
    return (m_pSourceListZ->m_pNextMix == m_pSourceListZ);
}

//--------------------------------------------------------------------------;
//
// CGrace::GetBytePosition
//
// This function returns the play and write cursor positions of a secondary
// buffer that is being software mixed into a primary buffer.  The position is
// computed from the position of the primary buffer into which it is being
// mixed.  This function also returns the "mix cursor" which is the next
// position of the secondary buffer from which data will be mixed on a mixer
// refresh event.  The region from the write cursor to the mix cursor is the
// premixed region of the buffer.  Note that a remix event may cause the grace
// mixer to mix from a position before the mix cursor.
//
//--------------------------------------------------------------------------;

void CGrace::GetBytePosition(CMixSource *pSource, int *pibPlay, int *pibWrite)
{
    int     posPPlay;
    int     posPWrite;
    LONG    dposPPlay;
    LONG    dposPWrite;

    LONG    posSPlay;
    LONG    posSWrite;
    LONG    dposSPlay;
    LONG    dposSWrite;

    LONG    posP1;
    LONG    posP2;

    if (pibPlay) *pibPlay = 0;
    if (pibWrite) *pibWrite = 0;

    if (S_OK != m_pDest->GetSamplePosition(&posPPlay, &posPWrite)) {
#ifdef Not_VxD
        DPF(0, "Couldn't GetSamplePosition of primary");
#else
        DPF(("Couldn't GetSamplePosition of primary"));
#endif
        posPPlay = posPWrite = 0;
    }

    //
    // The logic below to compute source position is quite difficult
    // to understand and hard to explain without sufficient illustration.
    // I won't attempt to write paragraphs of comments here.  Instead I
    // hope to add a design document to this project describing this
    // logic.  I wonder if I'll ever really do it.
    //
    ASSERT(pSource->m_nLastFrequency);

    switch (pSource->m_kMixerSubstate)
    {
        case MIXSOURCESUBSTATE_NEW:
            posP1 = m_posPNextMix;
            dposSWrite = 0;
            break;

        case MIXSOURCESUBSTATE_STARTING_WAITINGPRIMARYWRAP:
        case MIXSOURCESUBSTATE_STARTING:
            posP1 = pSource->m_posPStart;
            dposPWrite = m_posPNextMix - posPWrite;
            if (dposPWrite < 0) dposPWrite += m_pDest->m_cSamples;
            ASSERT(dposPWrite >= 0);
            dposSWrite = MulDivRD(dposPWrite, pSource->m_nLastFrequency, m_pDest->m_nFrequency);
            break;
            
        case MIXSOURCESUBSTATE_STARTED:
            posP1 = posPPlay;
            dposPWrite = m_posPNextMix - posPWrite;
            if (dposPWrite < 0) dposPWrite += m_pDest->m_cSamples;
            ASSERT(dposPWrite >= 0);
            dposSWrite = MulDivRD(dposPWrite, pSource->m_nLastFrequency, m_pDest->m_nFrequency);
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    switch (pSource->m_kMixerState)
    {
        case MIXSOURCESTATE_STOPPED:
            ASSERT(FALSE);
            break;

        case MIXSOURCESTATE_NEW:
        case MIXSOURCESTATE_LOOPING:
        case MIXSOURCESTATE_NOTLOOPING:
            posP2 = m_posPNextMix;
            break;

        case MIXSOURCESTATE_ENDING_WAITINGPRIMARYWRAP:
            if (posPPlay < pSource->m_posPPlayLast)
                if (posPPlay >= pSource->m_posPEnd)
                    posP2 = posP1 + 1;
                else
                    posP2 = pSource->m_posPEnd;
            else
                posP2 = pSource->m_posPEnd;
            break;

        case MIXSOURCESTATE_ENDING:
            if (posPPlay >= pSource->m_posPEnd || posPPlay < pSource->m_posPPlayLast)
                posP2 = posP1 + 1;
            else
                posP2 = pSource->m_posPEnd;
            break;
        
        default:
            ASSERT(FALSE);
            break;
    }

    if (pSource->m_kMixerSubstate == MIXSOURCESUBSTATE_NEW) {
        dposPPlay = 0;
        dposSPlay = 0;
    } else {
        dposPPlay = posP2 - posP1;
        if (dposPPlay <= 0) dposPPlay += m_pDest->m_cSamples;
        ASSERT(dposPPlay >= 0);
        dposPPlay = max(0, dposPPlay-1);
        dposSPlay  = MulDivRD(dposPPlay, pSource->m_nLastFrequency, m_pDest->m_nFrequency);
    }

    posSPlay = pSource->m_posNextMix - dposSPlay;
    while (posSPlay < 0) posSPlay += pSource->m_cSamples;

    posSWrite = pSource->m_posNextMix - dposSWrite;
    posSWrite += pSource->m_nFrequency * HW_WRITE_CURSOR_MSEC_PAD / 1024;
    while (posSWrite >= pSource->m_cSamples) posSWrite -= pSource->m_cSamples;
    while (posSWrite < 0) posSWrite += pSource->m_cSamples;

    if (pibPlay)  *pibPlay  = posSPlay  << pSource->m_nBlockAlignShift;
    if (pibWrite) *pibWrite = posSWrite << pSource->m_nBlockAlignShift;
}

/***************************************************************************
 *
 *  LockCircularBuffer
 *
 *  Description:
 *      Locks a hardware or software sound buffer.
 *
 *  Arguments:
 *      PLOCKCIRCULARBUFFER [in/out]: lock parameters.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT LockCircularBuffer(PLOCKCIRCULARBUFFER pLock)
{
    const LPVOID pvInvalidLock = (LPVOID)-1;
    const DWORD  cbInvalidLock = (DWORD)-1;
    HRESULT      hr            = DS_OK;
    DWORD        dwMask;
    LPVOID       pvLock[2];
    DWORD        cbLock[2];
    
    // Calculate the valid lock pointers
    pvLock[0] = (LPBYTE)pLock->pvBuffer + pLock->ibRegion;

    if(pLock->ibRegion + pLock->cbRegion > pLock->cbBuffer)
    {
        cbLock[0] = pLock->cbBuffer - pLock->ibRegion;

        pvLock[1] = pLock->pvBuffer;
        cbLock[1] = pLock->cbRegion - cbLock[0];
    }
    else
    {
        cbLock[0] = pLock->cbRegion;

        pvLock[1] = NULL;
        cbLock[1] = 0;
    }

    // Do we really need to lock the hardware buffer?
    if(pLock->pHwBuffer)
    {
        if(pLock->fPrimary)
        {
            dwMask = DSDDESC_DONTNEEDPRIMARYLOCK;
        }
        else
        {
            dwMask = DSDDESC_DONTNEEDSECONDARYLOCK;
        }
        
        if(dwMask == (pLock->fdwDriverDesc & dwMask))
        {
            pLock->pHwBuffer = NULL;
        }
    }

    // Initialize the lock's out parameters
    if(pLock->pHwBuffer && pLock->fPrimary)
    {
        pLock->pvLock[0] = pLock->pvLock[1] = pvInvalidLock;
        pLock->cbLock[0] = pLock->cbLock[1] = cbInvalidLock;
    }
    else
    {
        pLock->pvLock[0] = pvLock[0];
        pLock->cbLock[0] = cbLock[0];
        
        pLock->pvLock[1] = pvLock[1];
        pLock->cbLock[1] = cbLock[1];
    }

    // Lock the hardware buffer
    if(pLock->pHwBuffer)
    {
        #ifndef NOVXD
            #ifdef Not_VxD
                hr = VxdBufferLock(pLock->pHwBuffer,
                                   &pLock->pvLock[0], &pLock->cbLock[0],
                                   &pLock->pvLock[1], &pLock->cbLock[1],
                                   pLock->ibRegion, pLock->cbRegion, 0);
            #else
                hr = pLock->pHwBuffer->Lock(&pLock->pvLock[0], &pLock->cbLock[0],
                                            &pLock->pvLock[1], &pLock->cbLock[1],
                                            pLock->ibRegion, pLock->cbRegion, 0);
            #endif
        #else // NOVXD
            ASSERT(!pLock->pHwBuffer);
        #endif // NOVXD
    }

    // If there's no driver present or the driver doesn't support locking, 
    // we'll just fill in the proper values ourselves
    if(DSERR_UNSUPPORTED == hr)
    {
        pLock->pvLock[0] = pvLock[0];
        pLock->cbLock[0] = cbLock[0];
        
        pLock->pvLock[1] = pvLock[1];
        pLock->cbLock[1] = cbLock[1];

        hr = DS_OK;
    }

    // Validate the returned pointers
    if(SUCCEEDED(hr) && pLock->pHwBuffer && pLock->fPrimary)
    {
        if(pvInvalidLock == pLock->pvLock[0] || pvInvalidLock == pLock->pvLock[1] ||
           cbInvalidLock == pLock->cbLock[0] || cbInvalidLock == pLock->cbLock[1])
        {
            #ifdef Not_VxD
                DPF(DPFLVL_ERROR, "This driver doesn't know how to lock a primary buffer!");
            #else // Not_VxD
                DPF(("This driver doesn't know how to lock a primary buffer!"));
            #endif // Not_VxD

            hr = DSERR_UNSUPPORTED;
        }
    }

    return hr;
}

/***************************************************************************
 *
 *  UnlockCircularBuffer
 *
 *  Description:
 *      Unlocks a hardware or software sound buffer.
 *
 *  Arguments:
 *      PLOCKCIRCULARBUFFER [in/out]: lock parameters.
 *
 *  Returns:  
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

HRESULT UnlockCircularBuffer(PLOCKCIRCULARBUFFER pLock)
{
    HRESULT hr = DS_OK;
    DWORD   dwMask;
    
    // Do we really need to unlock the hardware buffer?
    if(pLock->pHwBuffer)
    {
        if(pLock->fPrimary)
        {
            dwMask = DSDDESC_DONTNEEDPRIMARYLOCK;
        }
        else
        {
            dwMask = DSDDESC_DONTNEEDSECONDARYLOCK;
        }
        
        if(dwMask == (pLock->fdwDriverDesc & dwMask))
        {
            pLock->pHwBuffer = NULL;
        }
    }

    // Unlock the hardware buffer
    if(pLock->pHwBuffer)
    {
        #ifndef NOVXD
            #ifdef Not_VxD
                hr = VxdBufferUnlock(pLock->pHwBuffer,
                                     pLock->pvLock[0], pLock->cbLock[0],
                                     pLock->pvLock[1], pLock->cbLock[1]);
            #else
                hr = pLock->pHwBuffer->Unlock(pLock->pvLock[0], pLock->cbLock[0],
                                              pLock->pvLock[1], pLock->cbLock[1]);
            #endif
        #else // NOVXD
            ASSERT(!pLock->pHwBuffer);
        #endif // NOVXD
    }

    // If there's no driver present or the driver doesn't support unlocking, 
    // that's ok.
    if(DSERR_UNSUPPORTED == hr)
    {
        hr = DS_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\filter.c ===
//--------------------------------------------------------------------------;
//
//  File: filter.c
//
//  Copyright (c) 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  3D filter functions called by the mixer.  This code is built in ring 3
//  and ring 0.
//
//  History:
//  07/09/96    DannyMi     Created 
//
//--------------------------------------------------------------------------;

#define NODSOUNDSERVICETABLE

#include "dsoundi.h"
#include "vector.h"

#ifndef Not_VxD

#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG

// don't ask
BYTE _fltused;

#endif /* Not_VxD */


//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

// This is the 3D mixing code.  Grace gives us a sample that it was going to
// play, and we return a different number (that sample with 3D effects) which
// Grace will use instead.

// We cache a whole bunch of samples that she has sent us, because we are
// premixing some sound that may get thrown away, and we need be able to back
// up and find out what samples we were given BEFORE the point we rewind to.
// We also need to know some of the 3D parameters we were using at the point
// we rewind to, because if we don't revert to using the same parameters as
// we were the first time through, you will hear that as an audible glitch.

// But we are saving a sample cache of 10K samples or so, and to save the 3D
// state for each sample would take about 1Meg per 3D sound!  There's no way
// we can afford to do that.  So we save our state every 128 samples, and have
// a private agreement with Grace that she will always rewind us on 128 sample
// boundaries.

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

//
// Here is a simple float to long conversion that has unpredictable rounding
//
__inline LONG FloatToLongRX(float f)
{
    LONG l;

#ifdef USE_INLINE_ASM
    _asm fld f;
    _asm fistp l;
#else
    l = (long) f;
#endif

    return l;
}

// We will need to remember at least cSamples in our cache, because that is
// how much we may be asked to rewind.  The actual cache size we use must be
// a power of 2 for the math to work in FirNextSample
//
BOOL FilterPrepare(PFIRCONTEXT pfir, int cSamples)
{
#ifdef Not_VxD
    DPF(1, "FilterPrepare: this 3D channel needs a %d sample cache", cSamples);
#else
    DPF(("FilterPrepare: this 3D channel needs a %d sample cache", cSamples));
#endif

    //DPF(0, "~`FP ");

    // we already have a cache big enough
    if (pfir->cSampleCache && pfir->cSampleCache >= cSamples) {
#ifdef Not_VxD
        DPF(1, "Our current cache of %d is big enough", pfir->cSampleCache);
#else
        DPF(("Our current cache of %d is big enough", pfir->cSampleCache));
#endif
        return TRUE;
    }

    MEMFREE(pfir->pSampleCache);

    // !!! is this necessary?
    // find the next higher power of 2
    pfir->cSampleCache = 1;
    cSamples -= 1;
    while (cSamples >= 1) {
        cSamples >>= 1;
        pfir->cSampleCache <<= 1;
    }

    // if we're not at least this big, we can't do our left-right delay and low
    // pass filter
    if (pfir->cSampleCache < CACHE_MINSIZE)
        pfir->cSampleCache = CACHE_MINSIZE;

    pfir->pSampleCache = MEMALLOC_A(LONG, pfir->cSampleCache);
    if (pfir->pSampleCache == NULL) {
#ifdef Not_VxD
        DPF(0, "**** CAN'T ALLOC MEM FOR 3D cache - NO 3D EFFECTS!");
#else
        DPF(("**** CAN'T ALLOC MEM FOR 3D cache - NO 3D EFFECTS!"));
#endif
        pfir->cSampleCache = 0;
        return FALSE;
    }

    // We need 1/128th as many entries for saving our state
    pfir->cStateCache = pfir->cSampleCache / MIXER_REWINDGRANULARITY + 1;
    pfir->pStateCache = MEMALLOC_A(FIRSTATE, pfir->cStateCache);
    if (pfir->pStateCache == NULL) {
#ifdef Not_VxD
        DPF(0, "**** CAN'T ALLOC MEM FOR 3D cache - NO 3D EFFECTS!");
#else
        DPF(("**** CAN'T ALLOC MEM FOR 3D cache - NO 3D EFFECTS!"));
#endif
        MEMFREE(pfir->pSampleCache);
        pfir->cStateCache = 0;
        pfir->cSampleCache = 0;
        return FALSE;
    }

#ifdef Not_VxD
    DPF(1, "Using a %d sample and %d state cache", pfir->cSampleCache, pfir->cStateCache);
#else
    DPF(("Using a %d sample and %d state cache", pfir->cSampleCache, pfir->cStateCache));
#endif

    return TRUE;
}


// free our cache stuff
//
void FilterUnprepare(PFIRCONTEXT pfir)
{
#ifdef Not_VxD
    DPF(1, "FilterUnprepare:");
#else
    DPF(("FilterUnprepare:"));
#endif
    MEMFREE(pfir->pSampleCache);
    MEMFREE(pfir->pStateCache);
    pfir->pSampleCache = NULL;
    pfir->cSampleCache = 0;
    pfir->pStateCache = NULL;
    pfir->cStateCache = 0;
}

// clear our filter of cached samples - we're starting to play
//
void FilterClear(PFIRCONTEXT pfir)
{
#ifdef Not_VxD
    DPF(1, "FilterClear:");
#else
    DPF(("FilterClear:"));
#endif
    //DPF(0, "~`FC ");

    if (pfir->pSampleCache) {
        ZeroMemory(pfir->pSampleCache, pfir->cSampleCache * sizeof(LONG));
    }
    if (pfir->pStateCache) {
        ZeroMemory(pfir->pStateCache, pfir->cStateCache * sizeof(FIRSTATE));
        // clearing is a time to save our first state information.
        // !!! is this right?
        pfir->pStateCache[0].LastDryAttenuation = pfir->LastDryAttenuation;
        pfir->pStateCache[0].LastWetAttenuation = pfir->LastWetAttenuation;
#ifdef SMOOTH_ITD
        pfir->pStateCache[0].iLastDelay = pfir->iLastDelay;
#endif
    }
    pfir->iCurSample = 0;

    
    if (pfir->cStateCache > 1)
        pfir->iCurState = 1;    // next time we save it'll be at location 1
    pfir->iStateTick = 0;       // have seen no samples since saving

    return;
}

// Throw away the most recent cSamples we got - the filter is remixing them.
// Go back to our state cSamples ago, and do those samples over again.
// !!! Clear out the range being advanced over?
//
void FilterAdvance(PFIRCONTEXT pfir, int cSamples)
{
    pfir->iStateTick += cSamples;
    pfir->iStateTick %= MIXER_REWINDGRANULARITY;
    ASSERT(pfir->iStateTick < MIXER_REWINDGRANULARITY);
    //DPF(0, "~`FA%X %X ", cSamples, pfir->iStateTick);
}

void FilterRewind(PFIRCONTEXT pfir, int cSamples)
{
    int iRewind;

    ASSERT(pfir->iStateTick < MIXER_REWINDGRANULARITY);

    // !!! What if we back up to the beginning? we won't clear the cache!

    // we're only allowed to back up to a 128 sample boundary
    if (cSamples <=0 || cSamples > pfir->cSampleCache ||
        ((cSamples - pfir->iStateTick) & (MIXER_REWINDGRANULARITY - 1))) {
#ifdef Not_VxD
        DPF(0, "*** Error: Rewinding an invalid number %d (current remainder is %d)!", cSamples, pfir->iStateTick);
#else
        DPF(("*** Error: Rewinding an invalid number %d (current remainder is %d)!", cSamples, pfir->iStateTick));
#endif
        return;
    }
    //DPF(0, "~`FR%X %X ", cSamples, pfir->iStateTick);

    // how far back in our state cache do we go?  Each 128 samples we back up
    // means backing up 1 entry in our state cache, plus 1 because we're 
    // currently pointing one past the last one we saved.
    iRewind = (cSamples - pfir->iStateTick) / MIXER_REWINDGRANULARITY + 1;

    // rewind cSamples in our circular queue
    pfir->iCurSample = (pfir->iCurSample - cSamples) & (pfir->cSampleCache - 1);

#ifdef Not_VxD
    DPF(1, "FilterRewind: rewind %d samples, and %d states", cSamples, iRewind);
#else
    DPF(("FilterRewind: rewind %d samples, and %d states", cSamples, iRewind));
#endif

    // remember how we were doing 3D back then - restore our old state
    iRewind = pfir->iCurState - iRewind;
    if (iRewind < 0)
        iRewind += pfir->cStateCache;
    pfir->LastDryAttenuation = pfir->pStateCache[iRewind].LastDryAttenuation;
    pfir->LastWetAttenuation = pfir->pStateCache[iRewind].LastWetAttenuation;
#ifdef SMOOTH_ITD
    pfir->iLastDelay = pfir->pStateCache[iRewind].iLastDelay;
#endif
    pfir->iStateTick = 0;

    return;
}


// Before we mix 1000 (or so) 3D samples, we call this function to prepare
// to mix the next batch.  The only thing it has to worry about is our
// volume smoothing.
// We are currently using Last***Attenuation and want to get to
// Total***Attenuation. Instead of figuring out sample by sample how much
// closer to move each sample (too expensive) we figure out right now how
// much we will move closer and do that for every sample in this batch.  But
// the danger of extracting that test to this level is that maybe we will
// go too far and actually overshoot Total***Attenation, causing possible
// clipping, or oscillating if we later try to correct it, and over-correct.
// If we are going to overshoot, we will recalculate how much to move each    
// sample such that we will end up at our target at the end of this batch of
// samples. (Or you can compile it to be lazy and give up when it's close).
void FilterChunkUpdate(PFIRCONTEXT pfir, int cSamples)
{
    FLOAT attRatio, c, w, d;

    // Due to rounding error, we'll take forever to get exactly to where
    // we want to be, so close counts.  If we don't snap ourselves to where
    // we want to be, we could clip.
    d = pfir->TotalDryAttenuation - pfir->LastDryAttenuation;
    w = pfir->TotalWetAttenuation - pfir->LastWetAttenuation;
    if (d && d > -.0001f && d < .0001f) {
        //DPF(2, "~`x");
        pfir->LastDryAttenuation = pfir->TotalDryAttenuation;
    }
    if (w && w > -.0001f && w < .0001f) {
        //DPF(2, "~`X");
        pfir->LastWetAttenuation = pfir->TotalWetAttenuation;
    }

    // Dry attenuation wants to be higher than it is
    if (pfir->TotalDryAttenuation > pfir->LastDryAttenuation) {
        // or we may never get anywhere
        if (pfir->LastDryAttenuation == 0.f)
            pfir->LastDryAttenuation = .0001f; // small enough not to click
        // after gaining in volume throughout this entire range of samples
        // we will end up going too high!
         // VolSmoothScale is just 2^(8/f), so each sample goes up 
        // 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
        attRatio = pfir->TotalDryAttenuation / pfir->LastDryAttenuation;
        if (pow2(8. * cSamples / pfir->iSmoothFreq) > attRatio) {
#if 1
            // calculate what value besides 8 to use to end up at our
            // target after cSamples multiplies
            c = (FLOAT)fylog2x((double)pfir->iSmoothFreq / cSamples,
                attRatio);
            pfir->VolSmoothScaleDry = (FLOAT)pow2(c / pfir->iSmoothFreq);
            //DPF(2, "~`n");
#else
            // decide we're happy where we are.
            // we will never get to our real destination
            pfir->VolSmoothScaleDry = 1.f;
            pfir->TotalDryAttenuation = pfir->LastDryAttenuation;
            //DPF(2, "~`n");
#endif
        } else {
            // This is the value to multiply by every time
            pfir->VolSmoothScaleDry = pfir->VolSmoothScale;
            //DPF(2, "~`u");
        }

    // Dry attenuation wants to be less than it is
    } else if (pfir->TotalDryAttenuation < pfir->LastDryAttenuation) {

        // after lowering the volume throughout this entire range of samples
        // we will end up going too low!  going down from Last to Total is
        // the same as going up from Total to Last
         // VolSmoothScale is just 2^(8/f), so each sample goes up 
        // 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
        attRatio = pfir->TotalDryAttenuation ?
                   pfir->LastDryAttenuation / pfir->TotalDryAttenuation :
                   999999;
        if (pow2(8. * cSamples / pfir->iSmoothFreq) > attRatio) {
#if 1
            // calculate what value besides 8 to use to end up at our
            // target after cSamples multiplies
            c = (FLOAT)fylog2x((double)pfir->iSmoothFreq / cSamples,
                                                        attRatio);
            pfir->VolSmoothScaleDry = 1.f / (FLOAT)pow2(c / pfir->iSmoothFreq);
            //DPF(2, "~`p");
#else
            // decide we're happy where we are.
            // we will never get to our real destination
            pfir->VolSmoothScaleDry = 1.f;
            pfir->TotalDryAttenuation = pfir->LastDryAttenuation;
            //DPF(2, "~`p");
#endif
        } else {
            // This is the value to multiply by every time
            pfir->VolSmoothScaleDry = pfir->VolSmoothScaleRecip;
            //DPF(2, "~`d");
        }
    } else {
        // We're already where we want to be
        pfir->VolSmoothScaleDry = 1.f;
        //DPF(2, "~`.");
    }

    // Wet attenuation wants to be higher than it is
    if (pfir->TotalWetAttenuation > pfir->LastWetAttenuation) {
        // or we may never get anywhere
        if (pfir->LastWetAttenuation == 0.f)
            pfir->LastWetAttenuation = .0001f; // small enough not to click
        // after gaining in volume throughout this entire range of samples
        // we will end up going too high!
         // VolSmoothScale is just 2^(8/f), so each sample goes up 
        // 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
        attRatio = pfir->TotalWetAttenuation / pfir->LastWetAttenuation;
        if (pow2(8. * cSamples / pfir->iSmoothFreq) > attRatio) {
#if 1
            // calculate what value besides 8 to use to end up at our
            // target after cSamples multiplies
            c = (FLOAT)fylog2x((double)pfir->iSmoothFreq / cSamples, attRatio);
            pfir->VolSmoothScaleWet = (FLOAT)pow2(c / pfir->iSmoothFreq);
            //DPF(2, "~`N");
#else
            // decide we're happy where we are.
            // we will never get to our real destination
            pfir->VolSmoothScaleWet = 1.f;
            pfir->TotalWetAttenuation = pfir->LastWetAttenuation;
            //DPF(2, "~`N");
#endif
        } else {
            // This is the value to multiply by every time
            pfir->VolSmoothScaleWet = pfir->VolSmoothScale;
            //DPF(2, "~`U");
        }

    // Wet attenuation wants to be lower than it is
    } else if (pfir->TotalWetAttenuation < pfir->LastWetAttenuation) {

        // after lowering the volume throughout this entire range of samples
        // we will end up going too low!  going down from Last to Total is
        // the same as going up from Total to Last
         // VolSmoothScale is just 2^(8/f), so each sample goes up 
        // 2^(8/f), so n samples goes up (2^(8/f))^n or 2^(8n/f)
        attRatio = pfir->TotalWetAttenuation ?
                   pfir->LastWetAttenuation / pfir->TotalWetAttenuation :
                   999999;
        if (pow2(8. * cSamples / pfir->iSmoothFreq) > attRatio) {
#if 1
            // calculate what value besides 8 to use to end up at our
            // target after cSamples multiplies
            c = (FLOAT)fylog2x((double)pfir->iSmoothFreq / cSamples, attRatio);
            pfir->VolSmoothScaleWet = 1.f / (FLOAT)pow2(c / pfir->iSmoothFreq);
            //DPF(2, "~`P");
#else
            // decide we're happy where we are.
            // we will never get to our real destination
            pfir->VolSmoothScaleWet = 1.f;
            pfir->TotalWetAttenuation = pfir->LastWetAttenuation;
            //DPF(2, "~`P");
#endif
        } else {
            // This is the value to multiply by every time
            pfir->VolSmoothScaleWet = pfir->VolSmoothScaleRecip;
            //DPF(2, "~`D");
        }
    } else {
        // We're already where we want to be
        pfir->VolSmoothScaleWet = 1.f;
        //DPF(2, "~`.");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\iirlut.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iirlut.cpp
 *  Content:    DirectSound3D IIR algorithm look up table
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/22/98    jstokes  Created
 *
 ***************************************************************************/

// Project-specific INCLUDEs
#include "dsoundi.h"
#include "iirlut.h"
#include <limits.h>   
#include "rfcircvec.h"
#include <math.h>   

// ---------------------------------------------------------------------------
// Enumerations

enum EStateSpaceCoeffs {
    tagStateSpaceB0,
    tagStateSpaceB1,
    tagStateSpaceB2,
    tagStateSpaceA0,
    tagStateSpaceA1,
    tagStateSpaceA2,
    estatespacecoeffsCount
};

// ---------------------------------------------------------------------------
// Typedefs

typedef FLOAT TStateSpace[estatespacecoeffsCount];

// ---------------------------------------------------------------------------
// Defines

// Coefficient prologue code to obtain coefficient indices from parameters
#define COEFFICIENTPROLOGUECODE\
    ASSERT(Cd3dvalAzimuth >= Cd3dvalMinAzimuth && Cd3dvalAzimuth <= Cd3dvalMaxAzimuth);\
    ASSERT(Cd3dvalElevation >= Cd3dvalMinElevation && Cd3dvalElevation <= Cd3dvalMaxElevation);\
    ASSERT(CeSampleRate >= 0 && CeSampleRate < esamplerateCount);\
    int iAzimuthIndex;\
    UINT uiElevationIndex;\
    AnglesToIndices(Cd3dvalAzimuth, Cd3dvalElevation, iAzimuthIndex, uiElevationIndex);\
    ASSERT(uiElevationIndex >= 0 && uiElevationIndex < CuiNumElevationBins);\
    ASSERT(static_cast<UINT>(abs(iAzimuthIndex)) < CauiNumAzimuthBins[uiElevationIndex])

// ---------------------------------------------------------------------------
// Constants

#define CuiStateSpaceCoeffsHalf (estatespacecoeffsCount / 2)


/***************************************************************************
 *
 *  CIirLut
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIirLut::CIirLut"

CIirLut::CIirLut()
{
    DPF_ENTER();
    DPF_CONSTRUCT(CIirLut);

    m_pfCoeffs = NULL;
    m_psCoeffs = NULL;

    m_hLutFile = NULL;
    m_hLutFileMapping = NULL;
    m_pfLut = NULL;

    InitData();

    DPF_LEAVE_VOID();
}

/***************************************************************************
 *
 *  FreeCoefficientMemory
 *
 *  Description:
 *      Frees memory holding the coefficient LUT.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIirLut:FreeCoefficientMemory"

VOID CIirLut::FreeCoefficientMemory()
{
    DPF_ENTER();

    MEMFREE(m_pfCoeffs);
    MEMFREE(m_psCoeffs);

    DPF_LEAVE_VOID();
}

// Initialize (build LUT)
HRESULT CIirLut::Initialize
(
    const KSDS3D_HRTF_COEFF_FORMAT CeCoeffFormat, 
    const KSDS3D_HRTF_FILTER_QUALITY CeCoeffQuality,
    DWORD dwSpeakerConfig
)
{
    HRESULT hr;

    size_t  CstTotalBiquadCoeffsAlloc;
    size_t  CstTotalCanonicalCoeffsAlloc;
    UINT    uiCoeffIndex = 0;
    TCHAR   szDllName[MAX_PATH];

    ASSERT(CeCoeffFormat >= 0 && CeCoeffFormat < KSDS3D_COEFF_COUNT);
    ASSERT(CeCoeffQuality >= 0 && CeCoeffQuality < KSDS3D_FILTER_QUALITY_COUNT);

    // Store speaker configuration and coefficient format
    hr = ConvertDsSpeakerConfig(dwSpeakerConfig, &m_eSpeakerConfig);
    ASSERT(m_eSpeakerConfig >= 0 && m_eSpeakerConfig < espeakerconfigCount);

    if(SUCCEEDED(hr))
    {
        // Store speaker configuration and coefficient format and quality level
        m_eCoeffFormat = CeCoeffFormat;
        m_eCoeffQuality = CeCoeffQuality;

        // Reallocate memory
        CstTotalBiquadCoeffsAlloc = m_aauiNumBiquadCoeffs[CeCoeffQuality][m_eSpeakerConfig];
        CstTotalCanonicalCoeffsAlloc = m_aauiNumCanonicalCoeffs[CeCoeffQuality][m_eSpeakerConfig];
        FreeCoefficientMemory();
        switch(CeCoeffFormat) 
        {
            case FLOAT_COEFF:
                // Reallocate memory for FLOAT coefficients
                m_pfCoeffs = MEMALLOC_A(FLOAT, CstTotalCanonicalCoeffsAlloc);
                hr = HRFROMP(m_pfCoeffs);
                break;
            
            case SHORT_COEFF:
                // Reallocate memory for SHORT coefficients
                m_psCoeffs = MEMALLOC_A(SHORT, CstTotalBiquadCoeffsAlloc);
                hr = HRFROMP(m_psCoeffs);
                break;

            default:
                hr = DSERR_INVALIDPARAM;
                break;
        }
    }

    // Map the HRTF LUT located in dsound3d.dll
    if(SUCCEEDED(hr))
    {
        if(0 == GetSystemDirectory(szDllName, MAX_PATH))
        {
            //  Couldn't get the Window system dir!
            DPF(DPFLVL_ERROR, "Can't get system directory");
            hr = DSERR_GENERIC;
        }
    }

    if(SUCCEEDED(hr))
    {
        if(szDllName[lstrlen(szDllName)-1] != TEXT('\\'))
        {
            lstrcat(szDllName, TEXT("\\"));
        }
        lstrcat(szDllName, TEXT("dsound3d.dll"));

        m_hLutFile = LoadLibrary(szDllName);
        if(!m_hLutFile)
        {
            hr = DSERR_GENERIC;
            DPF(DPFLVL_ERROR, "Can't load dsound3d.dll");
        }
    }

    if(SUCCEEDED(hr))
    {
        m_pfLut = (PFLOAT)GetProcAddress(m_hLutFile, "CafBiquadCoeffs");
        hr = HRFROMP(m_pfLut);
    }
    
    if(SUCCEEDED(hr))
    { 

        // Go through complete coefficient LUT
        UINT uiTotalElevationFilters(0);
#ifdef DEBUG
        const DWORD CdwSpeakerConfigOffset(GetBiquadCoeffOffset(CeCoeffQuality, m_eSpeakerConfig, static_cast<ESampleRate>(0), 0, 0, TRUE));
        DWORD dwLastBiquadOffsetEnd(CdwSpeakerConfigOffset);
#endif
        for (UINT uiSampleRate(0); uiSampleRate<esamplerateCount && SUCCEEDED(hr); ++uiSampleRate)
            for (UINT uiElevation(0); uiElevation<CuiNumElevationBins && SUCCEEDED(hr); ++uiElevation) {
                // Store number of filters for up to one specific elevation
                m_aauiNumPreviousElevationFilters[uiSampleRate][uiElevation] = uiTotalElevationFilters;
                
                // Add up all elevation filters so far (subtract one for non-existent zero-degree delta filter)
                uiTotalElevationFilters += efilterCount * CauiNumAzimuthBins[uiElevation] - 1;
                
                // Go through all azimuth angles and filters (sigma and delta)
                for (UINT uiAzimuth(0); uiAzimuth<CauiNumAzimuthBins[uiElevation] && SUCCEEDED(hr); ++uiAzimuth)
                    for (UINT uiFilter(0); uiFilter<efilterCount && SUCCEEDED(hr); ++uiFilter) {
                        // Get number of biquad coefficients
                        const BYTE CbyNumBiquadCoeffs = CaaaaaabyNumBiquadCoeffs[CeCoeffQuality][m_eSpeakerConfig][uiSampleRate][uiFilter][uiElevation][uiAzimuth];

                        // Get biquad offset
                        DWORD dwBiquadOffset;
                        switch (uiFilter) {
                            case tagDelta:
                                dwBiquadOffset = GetBiquadCoeffOffset(CeCoeffQuality, m_eSpeakerConfig, static_cast<ESampleRate>(uiSampleRate), uiElevation, uiAzimuth, true);
                                break;
  
                            case tagSigma:
                                dwBiquadOffset = static_cast<DWORD>(GetBiquadCoeffOffset(CeCoeffQuality, m_eSpeakerConfig, static_cast<ESampleRate>(uiSampleRate), uiElevation, uiAzimuth, true) 
                                    + CaaaaaabyNumBiquadCoeffs[CeCoeffQuality][m_eSpeakerConfig][uiSampleRate][tagDelta][uiElevation][uiAzimuth]);
                                break;

                            default:
                                hr = DSERR_INVALIDPARAM;
                                break;
                        }
#ifdef DEBUG
                        ASSERT(dwBiquadOffset % ebiquadcoefftypeCount == 0);
                        ASSERT(dwLastBiquadOffsetEnd == dwBiquadOffset);
                        dwLastBiquadOffsetEnd = dwBiquadOffset + CbyNumBiquadCoeffs;
#endif // DEBUG

                        if (CbyNumBiquadCoeffs > 0)
                            // Convert coefficients
                            switch (CeCoeffFormat) {
                                case FLOAT_COEFF: {
                                    // Convert to FLOAT canonical representation
                                    ASSERT(m_pfCoeffs != NULL);
                                    const UINT CuiNumCanonicalCoeffs(NumBiquadCoeffsToNumCanonicalCoeffs(static_cast<UINT>(CbyNumBiquadCoeffs)));
#ifdef DEBUG
                                    UINT uiNumCanonicalCoeffs(0);
#endif // DEBUG
                                    TCanonicalCoeffs tCanonicalCoeffs;
                                    if (BiquadToCanonical(&m_pfLut[dwBiquadOffset], CbyNumBiquadCoeffs, tCanonicalCoeffs))
                                    {
                                        for (UINT uiCoeffType(0); uiCoeffType<ecanonicalcoefftypeCount; ++uiCoeffType)
                                            for (UINT ui(0); ui<NumCanonicalCoeffsToHalf(CuiNumCanonicalCoeffs); ++ui)
                                                // Skip a0 = 1
                                                if (uiCoeffType != tagCanonicalA || ui != 0) {
#ifdef DEBUG
                                                    uiNumCanonicalCoeffs++;
#endif // DEBUG
                                                    m_pfCoeffs[uiCoeffIndex++] = tCanonicalCoeffs[uiCoeffType][ui];
                                                }
                                    }
                                    else
                                    {
                                        //Let's assume that Biquad to Canonical only fails from memory constraints
                                        hr = DSERR_OUTOFMEMORY;
                                    }
#ifdef DEBUG
                                    ASSERT(uiNumCanonicalCoeffs == CuiNumCanonicalCoeffs);
#endif // DEBUG
                                }
                                break;

                                case SHORT_COEFF: {
                                    // Convert to SHORT biquad
                                    ASSERT(m_psCoeffs != NULL);
                                    for (DWORD dw(dwBiquadOffset); dw<dwBiquadOffset + CbyNumBiquadCoeffs; ++dw) {
                                        ASSERT(m_pfLut[dw] <= CfMaxBiquadCoeffMagnitude);
#ifdef DEBUG
                                        ASSERT(CdwSpeakerConfigOffset + uiCoeffIndex == dw);
#endif // DEBUG
                                        m_psCoeffs[uiCoeffIndex++] = FloatBiquadCoeffToShortBiquadCoeff(m_pfLut[dw]);
                                    }
                                }
                                break;

                                default:
                                    hr = DSERR_INVALIDPARAM;
                                    break;
                            }
                    }
            }
    }


#ifdef DEBUG
    if(SUCCEEDED(hr))
    {
        switch (CeCoeffFormat) {
            case FLOAT_COEFF:
                ASSERT(uiCoeffIndex == CstTotalCanonicalCoeffsAlloc);
            break;

            case SHORT_COEFF:
                ASSERT(uiCoeffIndex == CstTotalBiquadCoeffsAlloc);
            break;
        
            default:
                ASSERT(FALSE);
                break;
        }
    }
#endif //DEBUG

    return hr;
}

// Check if coefficients have changed since the last call to GetCoeffs
HRESULT CIirLut::ConvertDsSpeakerConfig
(
    DWORD dwSpeakerConfig,
    ESpeakerConfig* peSpeakerConfig
)
{
    HRESULT hr = DS_OK;

    switch(DSSPEAKER_CONFIG(dwSpeakerConfig))
    {
        case DSSPEAKER_HEADPHONE:
            *peSpeakerConfig = tagHeadphones;
            break;

        case DSSPEAKER_DIRECTOUT:
        case DSSPEAKER_STEREO:
        case DSSPEAKER_MONO:
        case DSSPEAKER_QUAD:
        case DSSPEAKER_SURROUND:
        case DSSPEAKER_5POINT1:
        case DSSPEAKER_7POINT1:
           
            switch(DSSPEAKER_GEOMETRY(dwSpeakerConfig))
            {
                case DSSPEAKER_GEOMETRY_NARROW:
                case DSSPEAKER_GEOMETRY_MIN:
                    *peSpeakerConfig = tagSpeakers10Degrees;
                    break;

                case DSSPEAKER_GEOMETRY_WIDE:
                case DSSPEAKER_GEOMETRY_MAX:
                case 0:
                    *peSpeakerConfig = tagSpeakers20Degrees;
                    break;

                // Anything else
                default:
                    hr = DSERR_INVALIDPARAM;
                    break;
            }

            break;

        default:
            hr = DSERR_INVALIDPARAM;
            break;
    }

    return hr;
}

// Check if coefficients have changed since the last call to GetCoeffs
BOOL CIirLut::HaveCoeffsChanged
(
    const D3DVALUE Cd3dvalAzimuth, 
    const D3DVALUE Cd3dvalElevation, 
    const ESampleRate CeSampleRate,
    const EFilter CeFilter
)
{
    // Coefficient prologue code to obtain coefficient indices from parameters
    COEFFICIENTPROLOGUECODE;
    
    // Check if coefficient index parameters have changed
    if (iAzimuthIndex == m_aiPreviousAzimuthIndex[CeFilter] && uiElevationIndex == m_auiPreviousElevationIndex[CeFilter] && CeSampleRate == m_aePreviousSampleRate[CeFilter]) {
        // Set this to be safe during debugging
        m_bZeroAzimuthTransition = false;
        m_bSymmetricalZeroAzimuthTransition = false;
        
        // Coefficient indices haven't changed
        return false;
    }
    else
        // Coefficient indices have changed
        return true;
}


// Get coefficients
const PVOID CIirLut::GetCoeffs
(
    const D3DVALUE Cd3dvalAzimuth, 
    const D3DVALUE Cd3dvalElevation, 
    const ESampleRate CeSampleRate, 
    const EFilter CeFilter, 
    PUINT ruiNumCoeffs
)
{
    PVOID  pvCoeffs;

    // Coefficient prologue code to obtain coefficient indices from parameters
    COEFFICIENTPROLOGUECODE;
    ASSERT(CeFilter >= 0 && CeFilter < efilterCount);

     // Check for zero azimuth transition
    if (((iAzimuthIndex >= 0 && m_aiPreviousAzimuthIndex[CeFilter] < 0) || (iAzimuthIndex < 0 && m_aiPreviousAzimuthIndex[CeFilter] == 0) ||(iAzimuthIndex < 0 && m_aiPreviousAzimuthIndex[CeFilter] > 0)) && m_aiPreviousAzimuthIndex[CeFilter] != INT_MAX)
        m_bZeroAzimuthTransition = true;
    else
        m_bZeroAzimuthTransition = false;

    // Check for symmetrical zero azimuth transition
    if (iAzimuthIndex == -m_aiPreviousAzimuthIndex[CeFilter])
        m_bSymmetricalZeroAzimuthTransition = true;
    else
        m_bSymmetricalZeroAzimuthTransition = false;
    
    // Set previous negative azimuth flag (for zero azimuth overlap calculation)
    if (m_aiPreviousAzimuthIndex[CeFilter] < 0)
        m_bPreviousNegativeAzimuth = true;
    else
        m_bPreviousNegativeAzimuth = false;

    // Set previous zero azimuth index flag (for zero azimuth overlap calculation)
    if (m_aiPreviousAzimuthIndex[CeFilter] == 0)
        m_bPreviousZeroAzimuthIndex = true;
    else
        m_bPreviousZeroAzimuthIndex = false;

#ifdef DEBUG
    // Sanity check
//    if (m_bSymmetricalZeroAzimuthTransition)
//        ASSERT(m_bZeroAzimuthTransition);
#endif

    // Cache away new coefficient index data
    m_aiPreviousAzimuthIndex[CeFilter] = iAzimuthIndex;
    m_auiPreviousElevationIndex[CeFilter] = uiElevationIndex;
    m_aePreviousSampleRate[CeFilter] = CeSampleRate;

    // Get number of biquad coefficients
    ASSERT(m_eSpeakerConfig >= 0 && m_eSpeakerConfig < espeakerconfigCount);
    const UINT CuiAzimuthIndex(abs(iAzimuthIndex));
    const BYTE CbyNumBiquadCoeffs(CaaaaaabyNumBiquadCoeffs[m_eCoeffQuality][m_eSpeakerConfig][CeSampleRate][CeFilter][uiElevationIndex][CuiAzimuthIndex]);
    
    // Get pointer to coefficients
    const DWORD CdwBiquadOffset(GetBiquadCoeffOffset(m_eCoeffQuality, m_eSpeakerConfig, CeSampleRate, uiElevationIndex, CuiAzimuthIndex, false));
    ASSERT(CdwBiquadOffset % ebiquadcoefftypeCount == 0);

    switch (m_eCoeffFormat) {
        case FLOAT_COEFF: {
            // Calculate offset
            UINT uiNumPreviousFilters(m_aauiNumPreviousElevationFilters[CeSampleRate][uiElevationIndex] + efilterCount * CuiAzimuthIndex);
            if (CuiAzimuthIndex > 0)
                // Subtract non-existent 0 degree delta filter
                uiNumPreviousFilters--;
            const DWORD CdwCanonicalOffset(4 * (CdwBiquadOffset / ebiquadcoefftypeCount) + uiNumPreviousFilters);
            
            // Get pointer
            ASSERT(m_pfCoeffs != NULL);
            switch (CeFilter) {
                case tagDelta:
                    pvCoeffs = &m_pfCoeffs[CdwCanonicalOffset];
                    break;

                case tagSigma:
                    pvCoeffs = &m_pfCoeffs[CdwCanonicalOffset + NumBiquadCoeffsToNumCanonicalCoeffs(CaaaaaabyNumBiquadCoeffs[m_eCoeffQuality][m_eSpeakerConfig][CeSampleRate][tagDelta][uiElevationIndex][CuiAzimuthIndex])];
                    break;

                default:
                    break;
            }
            
            // Get number of coefficients
            *ruiNumCoeffs = NumBiquadCoeffsToNumCanonicalCoeffs(CbyNumBiquadCoeffs);

/*  This optimization causes NT bug 266819
            PFLOAT pfCoeffs = (PFLOAT) pvCoeffs;
            if((LIGHT_FILTER == m_eCoeffQuality) && (0 != *ruiNumCoeffs) 
                && (0.0f == pfCoeffs[2]) && (0.0f == pfCoeffs[4]))
            {
                ASSERT(5 == *ruiNumCoeffs);    
                *ruiNumCoeffs = 3;

                pfCoeffs[2] = pfCoeffs[3];
                pfCoeffs[3] = 0.0f;
            }
*/

            break;
        }
        
        case SHORT_COEFF:
        {
            // Get pointer
            ASSERT(m_psCoeffs != NULL);
            switch (CeFilter) {
                case tagDelta:
                    pvCoeffs = &m_psCoeffs[CdwBiquadOffset];
                    break;

                case tagSigma:
                    pvCoeffs = &m_psCoeffs[CdwBiquadOffset + CaaaaaabyNumBiquadCoeffs[m_eCoeffQuality][m_eSpeakerConfig][CeSampleRate][tagDelta][uiElevationIndex][CuiAzimuthIndex]];
                    break;

                default:
                    break;
            }

            // Get number of coefficients
            *ruiNumCoeffs = CbyNumBiquadCoeffs;
            break;
        }

        default:
            break;
    }
    
    return pvCoeffs;

}

// Initialize data
VOID CIirLut::InitData()
{
    // Initialize variables
//    ASSERT(SIZE_OF_ARRAY(m_pfLut) == CuiTotalBiquadCoeffs);

    m_bNegativeAzimuth = false;
    m_bZeroAzimuthIndex = false;


    m_eSpeakerConfig = espeakerconfigCount;

    m_bNegativeAzimuth = false;
    m_bPreviousNegativeAzimuth = false;
    m_bZeroAzimuthIndex = false;
    m_bPreviousZeroAzimuthIndex = false;
    m_eCoeffFormat = KSDS3D_COEFF_COUNT;
    m_eCoeffQuality = KSDS3D_FILTER_QUALITY_COUNT;
    m_eSpeakerConfig = espeakerconfigCount;
    m_bZeroAzimuthTransition = false;
    m_bSymmetricalZeroAzimuthTransition = false;
    m_pfCoeffs = NULL;
    m_psCoeffs = NULL;
    
    // Initialize cache variables
    for (UINT ui(0); ui<efilterCount; ++ui) {
        m_auiPreviousElevationIndex[ui] = UINT_MAX;
        m_aiPreviousAzimuthIndex[ui] = INT_MAX;
        m_aePreviousSampleRate[ui] = esamplerateCount;
    }

    // Go through all coefficient quality levels and speaker configurations
#ifdef DEBUG
    const BYTE CbyMaxBiquadCoeffs(static_cast<BYTE>(NumBiquadsToNumBiquadCoeffs(CbyMaxBiquads)));
#endif
    m_byMaxBiquadCoeffs = 0;
    for (UINT uiCoeffQuality(0); uiCoeffQuality<KSDS3D_FILTER_QUALITY_COUNT; ++uiCoeffQuality)
        for (UINT uiSpeakerConfig(0); uiSpeakerConfig<espeakerconfigCount; ++uiSpeakerConfig) {
            // Calculate number of coefficients for each speaker configuration and coefficient quality level
            UINT uiNumBiquadCoeffs(0);
            UINT uiNumCanonicalCoeffs(0);
            
            // Go through all sample rates, filters, elevation and azimuth angles
            for (UINT uiSampleRate(0); uiSampleRate<esamplerateCount; ++uiSampleRate)
                for (UINT uiFilter(0); uiFilter<efilterCount; ++uiFilter)
                    for (UINT uiElevation(0); uiElevation<CuiNumElevationBins; ++uiElevation)
                        for (UINT uiAzimuth(0); uiAzimuth<CauiNumAzimuthBins[uiElevation]; ++uiAzimuth) {
                            // Add up number of biquad coefficients
                            const BYTE CbyNumBiquadCoeffs(CaaaaaabyNumBiquadCoeffs[uiCoeffQuality][uiSpeakerConfig][uiSampleRate][uiFilter][uiElevation][uiAzimuth]);
#ifdef DEBUG
                            ASSERT(CbyNumBiquadCoeffs <= CbyMaxBiquadCoeffs);
#endif // DEBUG
                            uiNumBiquadCoeffs += CbyNumBiquadCoeffs;
                            uiNumCanonicalCoeffs += NumBiquadCoeffsToNumCanonicalCoeffs(CbyNumBiquadCoeffs);

                            // Determine overall maximum number of coefficients
                            if (CbyNumBiquadCoeffs > m_byMaxBiquadCoeffs)
                                m_byMaxBiquadCoeffs = CbyNumBiquadCoeffs;
                        }
            
            // Store number of coefficients for each speaker configuration and quality level
            ASSERT(uiNumBiquadCoeffs < CuiTotalBiquadCoeffs);
#ifdef DEBUG
            ASSERT(uiNumBiquadCoeffs % ebiquadcoefftypeCount == 0);
#endif // DEBUG
            m_aauiNumBiquadCoeffs[uiCoeffQuality][uiSpeakerConfig] = uiNumBiquadCoeffs;
//            ASSERT((uiNumCanonicalCoeffs & 1) == 0);  // John Norris removed for final LUT drop
            m_aauiNumCanonicalCoeffs[uiCoeffQuality][uiSpeakerConfig] = uiNumCanonicalCoeffs;
        }

    
    ASSERT(m_byMaxBiquadCoeffs > 0);
    ASSERT(m_byMaxBiquadCoeffs <= CbyMaxBiquadCoeffs);
}

// Convert azimuth and elevation angles to indices into LUT
VOID CIirLut::AnglesToIndices
(
    D3DVALUE d3dvalAzimuth, 
    D3DVALUE d3dvalElevation, 
    int& riAzimuthIndex, 
    UINT& ruiElevationIndex
)
{
    ASSERT(d3dvalAzimuth >= Cd3dvalMinAzimuth && d3dvalAzimuth <= Cd3dvalMaxAzimuth);

    // Check for out of range elevations
    if (d3dvalElevation > Cd3dvalMaxElevationData)
        d3dvalElevation = Cd3dvalMaxElevationData;
    if (d3dvalElevation < Cd3dvalMinElevationData)
        d3dvalElevation = Cd3dvalMinElevationData;
    
    // Get elevation index by rounding floating-point elevation angle to the nearest integer elevation index
    ruiElevationIndex = static_cast<UINT>(((d3dvalElevation - Cd3dvalMinElevationData) / Cd3dvalElevationResolution) + 0.5f);
    
    // Check for out of range azimuthal angles
    if (d3dvalAzimuth > Cd3dvalMaxAzimuth)
        d3dvalAzimuth = Cd3dvalMaxAzimuth;
    if (d3dvalAzimuth < Cd3dvalMinAzimuth)
        d3dvalAzimuth = Cd3dvalMinAzimuth;
    
    // Get azimuth index by rounding floating-point azimuth angle to the nearest signed integer azimuth index (positive or negative)
    UINT uiAzimuthIndex(static_cast<int>((static_cast<FLOAT>(fabs(d3dvalAzimuth)) / (Cd3dvalAzimuthRange / (CauiNumAzimuthBins[ruiElevationIndex]))) + 0.5f));

    // Discard 180 degree azimuth data
    if (uiAzimuthIndex >= CauiNumAzimuthBins[ruiElevationIndex])
        uiAzimuthIndex = CauiNumAzimuthBins[ruiElevationIndex] - 1;

    // Take care of negative azimuth angles and set negative azimuth flag
    riAzimuthIndex = uiAzimuthIndex;
    if (d3dvalAzimuth < 0 && uiAzimuthIndex != 0) {
        m_bNegativeAzimuth = true;
        riAzimuthIndex = -riAzimuthIndex;
    }
    else
        m_bNegativeAzimuth = false;
}

// Convert coefficients into floating-point canonical form
BOOL CIirLut::BiquadToCanonical
(
    const FLOAT CpCfBiquadCoeffs[], 
    const UINT CuiNumBiquadCoeffs, 
    TCanonicalCoeffs &rtCanonicalCoeffs
)
{
    BOOL fRetVal = TRUE;
//    CHECK_POINTER(CpCfBiquadCoeffs);
    ASSERT(CuiNumBiquadCoeffs >= ebiquadcoefftypeCount);
    
    // Convert coefficients
    for (UINT uiCoeffType(0); uiCoeffType<ecanonicalcoefftypeCount; ++uiCoeffType) {
        // Allocate circular vectors
        const UINT CuiOffset(CuiStateSpaceCoeffsHalf * uiCoeffType);
        const UINT CuiNumBiquads(NumBiquadCoeffsToNumBiquads(CuiNumBiquadCoeffs));
        const size_t CstNumCoeffs(NumBiquadsToNumCanonicalCoeffsHalf(CuiNumBiquads));
        CRfCircVec circvecInput;
        if (!circvecInput.Init(CstNumCoeffs, 0.0f))
        {
            fRetVal = FALSE;
            break;
        }
        CRfCircVec circvecOutput;
        if (!circvecOutput.Init(CstNumCoeffs, 0.0f))
        {
            fRetVal = FALSE;
            break;
        }

        // Initialize input circular vector with unit impulse
        circvecInput.Write(1.0f);
        
        // Go through all biquads
        for (size_t stBiquad(0); stBiquad<CuiNumBiquads; ++stBiquad) {
            // Initialize state space vector
            TStateSpace tStateSpace;
            const UINT CuiBiquadIndex(ebiquadcoefftypeCount * stBiquad);
            const FLOAT CfScalingFactor(2.0f);
            tStateSpace[tagStateSpaceB0] = CfScalingFactor * CpCfBiquadCoeffs[CuiBiquadIndex + tagBiquadB0];
            tStateSpace[tagStateSpaceB1] = CfScalingFactor * CpCfBiquadCoeffs[CuiBiquadIndex + tagBiquadB1];
            tStateSpace[tagStateSpaceB2] = CfScalingFactor * CpCfBiquadCoeffs[CuiBiquadIndex + tagBiquadB2];
            tStateSpace[tagStateSpaceA0] = 1.0f;
            tStateSpace[tagStateSpaceA1] = CfScalingFactor * CpCfBiquadCoeffs[CuiBiquadIndex + tagBiquadA1];
            tStateSpace[tagStateSpaceA2] = CfScalingFactor * CpCfBiquadCoeffs[CuiBiquadIndex + tagBiquadA2];
/*
#ifdef DEBUG
            if((0.0f ==tStateSpace[tagStateSpaceA2]) && 
                (tStateSpace[tagStateSpaceA1]<-1.0f) || (tStateSpace[tagStateSpaceA1]>1.0f))
            {
                ASSERT(0);
            } 
#endif // DEBUG
*/

            // Go through all coefficients
            for (size_t stCoeff(0); stCoeff<CstNumCoeffs; ++stCoeff) {
                // Calculate output of FIR filter
                FLOAT fW(0.0f);
                for (UINT ui(0); ui<CuiStateSpaceCoeffsHalf; ++ui)
                    fW += tStateSpace[CuiOffset + ui] * circvecInput.LIFORead();
                
                // Save output of FIR filter
                circvecOutput.Write(fW);
                
                // Adjust input index for FIR feedback
                circvecInput.SetIndex(circvecOutput.GetIndex());
                circvecInput.SkipForward();
            }

            // Feed output back into input
            circvecInput.FIFOFill(circvecOutput);
            
            // Forward circular buffers
            circvecInput.SkipForward();
            circvecOutput.SkipForward();
        }

        // Save canonical coefficients
        circvecOutput.SkipBack();
        for (size_t stCoeff(0); stCoeff<CstNumCoeffs; ++stCoeff)
            rtCanonicalCoeffs[uiCoeffType][stCoeff] = circvecOutput.FIFORead();
    }
    return fRetVal;
}

/***************************************************************************
 *
 *  DsFrequencyToIirSampleRate
 *
 *  Description:
 *      Converts DirectSound SampleRate to IIR LUT Sample Rate.
 *
 *  Arguments:
 *      DWORD [in]:  DirectSound 3D mode.
 *      DWORD [out]: KS 3D mode.
 *
 *  Returns:  
 *      HRESULT: KSDATAFORMAT_DSOUND control flags.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DsFrequencyToIirSampleRate"

HRESULT 
CIirLut::DsFrequencyToIirSampleRate
(
    DWORD            dwDsFrequency,
    ESampleRate*    IirLutSampleRate
)
{
    HRESULT        hr = DS_OK;

    if(0<dwDsFrequency && 9512>=dwDsFrequency)
        *IirLutSampleRate = tag8000Hz;
    else if(9512<dwDsFrequency && 13512>=dwDsFrequency)
        *IirLutSampleRate = tag11025Hz;
    else if(13512<dwDsFrequency && 19025>=dwDsFrequency)
        *IirLutSampleRate = tag16000Hz;
    else if(19025<dwDsFrequency && 27025>=dwDsFrequency)
        *IirLutSampleRate = tag22050Hz;
    else if(27025<dwDsFrequency && 38050>=dwDsFrequency)
        *IirLutSampleRate = tag32000Hz;
    else if(38050<dwDsFrequency && 46050>=dwDsFrequency)
        *IirLutSampleRate = tag44100Hz;
    else
        *IirLutSampleRate = tag48000Hz;

    return hr;
}

// ---------------------------------------------------------------------------
// Undefines

#undef COEFFICIENTPROLOGUECODE

// ---------------------------------------------------------------------------
// Include inline definitions out-of-line in debug version

#ifdef DEBUG
#include "iirlut.inl"
#endif

// End of LUT.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\grsub.cpp ===
//--------------------------------------------------------------------------;
//
//  File: grsub.cpp
//
//  Copyright (c) 1995-2000 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//  Contents:
//
//  History:
//      06/25/96    FrankYe     Created
//      02/02/97    DerekS      Added support for constant dest size
//      08/30/00    DuganP      Many fixes - better MMSYSERR handling
//
//--------------------------------------------------------------------------;

#include "dsoundi.h"
#include "grace.h"

#ifndef NOVXD

// Internal Kernel32 API
extern "C" DWORD WINAPI OpenVxDHandle(HANDLE hSource);

const char CNaGrace::strFormatMixEventRemix[] = "%08XDirectSound_MixEvent_Remix";
const char CNaGrace::strFormatMixEventTerminate[] = "%08XDirectSound_MixEvent_Terminate";
const int CNaGrace::MIXER_MINPREMIX = 45;
const int CNaGrace::MIXER_MAXPREMIX = 200;

#endif // NOVXD

#define TIMEOUT_PERIOD 5000


//---------------------------------------------------------------------------
//
// WaveAllocAndPrepareLoopingBuffers
//
// Allocate the array of wavehdr's to point at the primary buffer.
// Prepare them and start them looping.
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "WaveAllocAndPrepareLoopingBuffers"

MMRESULT WaveAllocAndPrepareLoopingBuffers(HWAVEOUT hwo, LPWAVEFORMATEX pwfx,
                                           int cHeaders, int cHeadersToQueue,
                                           WAVEHDR **ppwh, int cbBuffer,
                                           PVOID *ppLoopingBuffer)
{
    int iawh;
    MMRESULT mmr;
    PBYTE pLoopingBuffer;
    PWAVEHDR pwh;

    enum WAVEHDR_STATUS {Allocated, Prepared, Successful};
    WAVEHDR_STATUS* pStatus;  // Used to track the state of the headers

    DPF_ENTER();

    pLoopingBuffer = MEMALLOC_A(BYTE, cHeaders * cbBuffer);
    if (!pLoopingBuffer)
    {
        DPF(DPFLVL_ERROR, "No memory for looping buffer!");
        return MMSYSERR_NOMEM;
    }

    pwh = MEMALLOC_A(WAVEHDR, cHeaders);
    if (!pwh)
    {
        DPF(DPFLVL_ERROR, "No memory for wave headers");
        MEMFREE(pLoopingBuffer);
        return MMSYSERR_NOMEM;
    }

    pStatus = MEMALLOC_A(WAVEHDR_STATUS, cHeaders);
    if (!pStatus)
    {
        DPF(DPFLVL_ERROR, "No memory for wave header status");
        MEMFREE(pLoopingBuffer);
        MEMFREE(pwh);
        return MMSYSERR_NOMEM;
    }

    // Initialize to 8 or 16-bit silence
    FillMemory(pLoopingBuffer, cHeaders * cbBuffer, (8 == pwfx->wBitsPerSample) ? 0x80 : 0x00);

    // Initialize the STATUS to all allocated
    for (iawh = 0; iawh < cHeaders; ++iawh)
    {
        pStatus[iawh] = Allocated;
    }

    // Build buffers and headers
    for (iawh = 0; iawh < cHeaders; ++iawh)
    {
        (pwh + iawh)->lpData = (char*)(pLoopingBuffer + (iawh * (cbBuffer)));
        (pwh + iawh)->dwBufferLength = cbBuffer;
        (pwh + iawh)->dwUser = iawh;
        (pwh + iawh)->dwFlags = 0;
    }

    DPF(DPFLVL_MOREINFO, "Note: first waveOutPrepareHeader and waveOutWrite");
    mmr = waveOutPrepareHeader(hwo, pwh, sizeof(WAVEHDR));

    ASSERT(MMSYSERR_NOERROR == mmr);
    if (MMSYSERR_NOERROR == mmr)
        pStatus[0] = Prepared;

    mmr = waveOutWrite(hwo, pwh, sizeof(WAVEHDR));

    // Note: on Whistler we've seen this call return MMSYSERR_INVALPARAM
    // (possibly due to low-mem conditions - see Manbug 44299).  So we'll
    // allow this error code in the ASSERT below for all WINNT builds.
    #ifdef WINNT
    ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr || MMSYSERR_INVALPARAM == mmr);
    #else
    ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr);
    #endif

    if (MMSYSERR_NOERROR == mmr)
    {
        pStatus[0] = Successful;
        mmr = waveOutPause(hwo);
        ASSERT(MMSYSERR_NOERROR == mmr);

        // Prepare the rest
        for (iawh = 1; iawh < cHeaders; ++iawh)
        {
            mmr = waveOutPrepareHeader(hwo, pwh + iawh, sizeof(WAVEHDR));
            ASSERT(MMSYSERR_NOERROR == mmr);
            if (MMSYSERR_NOERROR != mmr)
                break;
            pStatus[iawh] = Prepared;
        }

        if (MMSYSERR_NOERROR == mmr)
        {
            // Write the rest that we want queued to the wave device
            for (iawh = 1; iawh < cHeadersToQueue; ++iawh)
            {
                mmr = waveOutWrite(hwo, pwh + iawh, sizeof(WAVEHDR));
                ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr);
                if (MMSYSERR_NOERROR != mmr)
                    break;
                pStatus[iawh] = Successful;
            }
        }

        if (MMSYSERR_NOERROR == mmr)
        {
            // Start the device
            DPF(DPFLVL_MOREINFO, "Calling waveOutRestart()");
            mmr = waveOutRestart(hwo);
            ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr);
        }
    }

    if (MMSYSERR_NOERROR == mmr)
    {
        *ppLoopingBuffer = pLoopingBuffer;
        *ppwh = pwh;
    }
    else // Failure
    {
        // We're heading out of here - error condition. Let's call
        // waveOutReset() to get our headers back.
        if (waveOutReset(hwo) != MMSYSERR_NOERROR)
            ASSERT(!"waveOutReset() failed");
        
        // Cleanup: We have to unprepare the headers, but we may have to wait
        // until the "done" bit is set.  If the done bit gets set or 5 seconds
        // elapse, we go ahead and release the header if it was prepared.
        for (iawh = 0; iawh < cHeaders; ++iawh)
            if (pStatus[iawh] == Prepared)
                waveOutUnprepareHeader(hwo, pwh + iawh, sizeof(WAVEHDR));
        
        MEMFREE(pLoopingBuffer);
        MEMFREE(pwh);
    }

    // Free our header status array
    MEMFREE(pStatus);
    
    DPF_LEAVE(mmr);
    return mmr;
}

//---------------------------------------------------------------------------
//
// WaveUnprepareLoopingBuffers
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "WaveUnprepareLoopingBuffers"

MMRESULT WaveUnprepareLoopingBuffers(HWAVEOUT hwo, PWAVEHDR pwh, int cHeaders)
{
    for (int i=0; i<cHeaders; i++)
    {
        MMRESULT mmr = waveOutUnprepareHeader(hwo, pwh + i, sizeof(WAVEHDR));
        ASSERT(MMSYSERR_NOERROR == mmr);
    }
    return MMSYSERR_NOERROR;
}

//---------------------------------------------------------------------------
//
// WaveDetermineDMASize
//
// Determine DMA buffer size on the given emulated direct sound device and
// munge it to figure out the desired size for the emulator to allocate
// per wave header.
// 
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "WaveDetermineDMASize"

MMRESULT WaveDetermineDMASize(HWAVEOUT hwo, LPWAVEFORMATEX pwfx, int* pcbBigBuffer, int* pcDmaBuffers, int* pcbDmaBuffer)
{
    DWORD    dwTotalTime    = 0;
    UINT     mmResult       = MMSYSERR_NOERROR;

    DPF_ENTER();

    // If we're on a WinNT-based OS, we're either on WDM or NT4 drivers.
    // On WDM drivers, we can't discover the DMA size using the code below,
    // so we can skip it.  But what about NT4 drivers?
    
// #ifndef WINNT (Commented out until I get some info about NT4 drivers)

    // We'll send a packet of 4 bytes (that's at least 1 sample in every format)
    DWORD dwWaveData = (pwfx->wBitsPerSample == 16) ? 0x00000000 : 0x80808080;

    // Prepare wave header
    WAVEHDR whdr;
    whdr.lpData = (char*)&dwWaveData;
    whdr.dwBufferLength = sizeof(dwWaveData);
    whdr.dwFlags = 0;
    whdr.dwLoops = 0;
    whdr.dwUser =  0;
    mmResult = waveOutPrepareHeader(hwo, &whdr, sizeof(whdr));

    ASSERT(!mmResult);
    if (mmResult) return mmResult;

    DWORD dwBeginTime = timeGetTime();
    
    // Play our buffer
    mmResult = waveOutWrite(hwo, &whdr, sizeof(whdr));

    // Note: on Whistler we've seen this call return MMSYSERR_INVALPARAM
    // (possibly due to low-mem conditions - see Manbug 44299).  So we'll
    // allow this error code in the ASSERT below for all WINNT builds.
    #ifdef WINNT
    ASSERT(MMSYSERR_NOERROR == mmResult || MMSYSERR_NOMEM == mmResult || MMSYSERR_INVALPARAM == mmResult);
    #else
    ASSERT(MMSYSERR_NOERROR == mmResult || MMSYSERR_NOMEM == mmResult);
    #endif

    if (MMSYSERR_NOERROR != mmResult)
    {
        DPF(DPFLVL_WARNING, "waveOutWrite() failed with %lu", mmResult);
    }
    else
    {
        // Spin until the done bit is set, or 5 seconds
        while (!(whdr.dwFlags & WHDR_DONE))
        {
            if (dwTotalTime >= TIMEOUT_PERIOD)
            {
                DPF(DPFLVL_ERROR, "TIMEOUT getting DMA buffer size");
                mmResult = MMSYSERR_ERROR;
                break;
            }

            // This thread is THREAD_PRIORITY_TIME_CRITICAL so it would be
            // very dangerous to busy wait without explicitly giving up the
            // CPU for a while.
            Sleep(10);
            dwTotalTime = timeGetTime() - dwBeginTime;
        }
    }

    if (waveOutReset(hwo) != MMSYSERR_NOERROR)
        ASSERT(!"waveOutReset() failed");

    if (waveOutUnprepareHeader(hwo, &whdr, sizeof whdr) != MMSYSERR_NOERROR)
        ASSERT(!"waveOutUnprepareHeader() failed");

    DPF(DPFLVL_INFO, "Calculated dwTotalTime = %lu", dwTotalTime);

// #endif // WINNT

    if (MMSYSERR_NOERROR == mmResult)
    {
        // If it's smaller than 62ms, it probably isn't a DMA based card.
        dwTotalTime = max(dwTotalTime, 62);

        *pcbDmaBuffer = dwTotalTime * pwfx->nSamplesPerSec;
        *pcbDmaBuffer *= pwfx->nBlockAlign;
        *pcbDmaBuffer /= 1000;

        // Add in 10% for slop, and to account for drivers that deal with DMA wrapping
        *pcbDmaBuffer += (*pcbDmaBuffer * 10) / 100;

        // We have to recalculate the DMA buffer size based on the constant
        // size of the primary buffer.  Mathematically, this is a solvable
        // equation, but in the real world, it just doesn't fly.  We end
        // up with a situation where the total size of the buffer must be
        // evenly divisible by both the DMA buffer size and the count of
        // wave headers.  The easist way to fix this was to just create
        // a lookup table and find the closest match.

        // REMIND: we have to recalculate these numbers if MIXER_REWINDGRANULARITY
        // ever changes from 128 (the nSize values have to be multiples of it).

        *pcbBigBuffer = 81920;

        static const struct 
        {
            int nSize;
            int nCount;
        } aDmaTable[] = { { 1280, 64}, { 2560, 32 }, { 4096, 20 }, { 5120, 16 }, { 8192, 10 }, { 10240, 8 }, { 16384, 5 } };

        static const int cDmaTable = sizeof(aDmaTable) / sizeof(aDmaTable[0]);
        int i;

        if (*pcbDmaBuffer <= aDmaTable[0].nSize)
        {
            i = 0;
        }
        else if(*pcbDmaBuffer >= aDmaTable[cDmaTable - 1].nSize)
        {
            DPF(DPFLVL_INFO, "Processing took longer than expected");
            i = cDmaTable - 1;
        }
        else
        {
            for(i = 1; i < cDmaTable; i++)
            {
                if(*pcbDmaBuffer > aDmaTable[i-1].nSize && *pcbDmaBuffer <= aDmaTable[i].nSize)
                {
                    break;
                }
            }
        }

        *pcbDmaBuffer = aDmaTable[i].nSize;
        *pcDmaBuffers = aDmaTable[i].nCount;
    }

    DPF_LEAVE(mmResult);
    return mmResult;
}


//---------------------------------------------------------------------------
//
// CWeGrace implementation
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "CWeGrace::Refresh"

void CWeGrace::Refresh(int cPremixMax)
{
    LONG dtimeNextNotify;
    int cPremixed;
    BOOL fRemix;

    ENTER_MIXER_MUTEX();
    
    if (MIXERSTATE_STOPPED != m_kMixerState)
    {
        fRemix = DSMIXERSIGNAL_REMIX & m_fdwMixerSignal;
        CGrace::Refresh(fRemix, cPremixMax, &cPremixed, &dtimeNextNotify);
    }

    LEAVE_MIXER_MUTEX();
}


#ifndef NOVXD

#undef DPF_FNAME
#define DPF_FNAME "NaGrace_ThreadStartRoutine"

DWORD WINAPI NaGrace_ThreadStartRoutine(PVOID pNaGrace)
{
    ((CNaGrace *)pNaGrace)->MixThread();
    return 0;
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrace::SignalRemix"

void CNaGrace::SignalRemix()
{
    if (!(DSMIXERSIGNAL_REMIX & m_fdwMixerSignal))
    {
        m_fdwMixerSignal |= DSMIXERSIGNAL_REMIX;
        VxdEventScheduleWin32Event(m_vxdhMixEventRemix, 0);
    }
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrace::MixThread"

void CNaGrace::MixThread()
{
    HANDLE  hEventTerminate;
    HANDLE  hEventRemix;
    TCHAR   ach[256];
    DWORD   dwResult;
    BOOL    fResult;

    LONG    dtime;
    LONG    dtimeSleep;
    LONG    dtimePremix;
    LONG    ddtimePremix;
    LONG    dtimeInvalid;
    LONG    dtimeNextNotify;

    int     cSamplesPremixMax;
    int     cSamplesPremixed;

    DPF(DPFLVL_INFO, "Grace is in the building");

    // We mangle the event names by prepending the address of the DS
    // object for which this thread is running.  This allows unique
    // event names for each DS object.

    wsprintf(ach, strFormatMixEventTerminate, this);
    hEventTerminate = CreateEvent(NULL, FALSE, FALSE, ach);
    DPF(DPFLVL_INFO, "Terminate event name '%s'", ach);

    wsprintf(ach, strFormatMixEventRemix, this);
    hEventRemix = CreateEvent(NULL, FALSE, FALSE, ach);
    DPF(DPFLVL_INFO, "Remix event name '%s'", ach);

    // Here we do a simple handshake with the creator of this thread.  We
    // signal the IAH_TERMINATE event.  When our creator sees it, it will
    // signal the IAH_REMIX event.

    fResult = SetEvent(hEventTerminate);
    ASSERT(fResult);
    dwResult = WaitObject(INFINITE, hEventRemix);
    ASSERT(WAIT_OBJECT_0 == dwResult);

    dtimeSleep = MIXER_MAXPREMIX / 2;

    while (TRUE)
    {
        HANDLE ah[] = {hEventTerminate, hEventRemix};

        ASSERT(dtimeSleep <= MIXER_MAXPREMIX/2);

        dwResult = WaitObjectArray(2, INFINITE, FALSE, ah);
        if (WAIT_OBJECT_0 == dwResult) break;

        dwResult = ENTER_MIXER_MUTEX_OR_EVENT(hEventTerminate);
        if (WAIT_OBJECT_0 == dwResult) break;

        // Three cases:
        //   1) mixer is stopped
        //   2) mixer running and a remix is pending
        //   3) mixer running and no remix is pending

        if (MIXERSTATE_STOPPED == m_kMixerState)
        {
            dtimeSleep = INFINITE;
        }
        else
        {
            dtime = timeGetTime();

            if (m_fdwMixerSignal & DSMIXERSIGNAL_REMIX)
            {
                ResetEvent(hEventRemix);

                dtimePremix = MIXER_MINPREMIX;  // Initial premix length
                ddtimePremix = 2;               // increment

                cSamplesPremixMax = MulDivRD(dtimePremix, m_pDest->m_nFrequency, 1000);
                Refresh(TRUE, cSamplesPremixMax, &cSamplesPremixed, &dtimeNextNotify);
            }
            else
            {
                dtimePremix += ddtimePremix;
                if (dtimePremix > MIXER_MAXPREMIX)
                    dtimePremix = MIXER_MAXPREMIX;
                else
                    ddtimePremix += 2;

                cSamplesPremixMax = MulDivRD(dtimePremix, m_pDest->m_nFrequency, 1000);
                Refresh(FALSE, cSamplesPremixMax, &cSamplesPremixed, &dtimeNextNotify);
            }

            dtimeInvalid = MulDivRD(cSamplesPremixed, 1000, m_pDest->m_nFrequency);
            dtime = timeGetTime() - dtime;
            dtimeInvalid -= 2 * dtime;

            dtimeSleep = min(dtimeInvalid/2, dtimeNextNotify);
            dtimeSleep = max(dtimeSleep, MIXER_MINPREMIX/2);
        }

        LEAVE_MIXER_MUTEX();
    }

    CloseHandle(hEventRemix);
    CloseHandle(hEventTerminate);

    DPF(DPFLVL_INFO, "Grace is outta here");
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrace::Initialize"

HRESULT CNaGrace::Initialize(CGrDest *pDest)
{
    HANDLE  hMixEventTerminate;
    HANDLE  hMixEventRemix;
    TCHAR   ach[256];
    DWORD   dwResult;
    BOOL    fResult;
    HRESULT hr;

    hr = CGrace::Initialize(pDest);

    if (SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Creating mixer thread");

        ASSERT(NULL == m_hMixThread);
        ASSERT(NULL == m_vxdhMixEventTerminate);
        ASSERT(NULL == m_vxdhMixEventRemix);

        // We mangle the event names by prepending the address of the Grace
        // object for which this thread is running.  This allows unique
        // event names for each DS object.

        wsprintf(ach, strFormatMixEventTerminate, this);
        hMixEventTerminate = CreateEvent(NULL, FALSE, FALSE, ach);
        hr = HRFROMP(hMixEventTerminate);
    }

    if (SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Terminate event name '%s'", ach);

        wsprintf(ach, strFormatMixEventRemix, this);
        hMixEventRemix = CreateEvent(NULL, FALSE, FALSE, ach);
        hr = HRFROMP(hMixEventRemix);
    }
    
    if (SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Remix event name '%s'", ach);

        m_vxdhMixEventTerminate = OpenVxDHandle(hMixEventTerminate);
        ASSERT(m_vxdhMixEventTerminate != 0);

        m_vxdhMixEventRemix = OpenVxDHandle(hMixEventRemix);
        ASSERT(m_vxdhMixEventRemix != 0);

#ifdef SHARED
        m_hMixThread = HelperCreateDSMixerThread(NaGrace_ThreadStartRoutine, this, 0, NULL);
#else
        DWORD dwTid;
        m_hMixThread = CreateThread(NULL, 0, NaGrace_ThreadStartRoutine, this, 0, &dwTid);
#endif

        hr = HRFROMP(m_hMixThread);
        if (FAILED(hr))
            DPF(DPFLVL_MOREINFO, "Unable to create mixer thread");
        else
        {
            DPF(DPFLVL_MOREINFO, "Mixer thread created: 0x%p", m_hMixThread);

            dwResult = WaitObject(INFINITE, hMixEventTerminate);
            ASSERT(dwResult == WAIT_OBJECT_0);
            fResult = SetEvent(hMixEventRemix);
            ASSERT(fResult);

            fResult = CloseHandle(hMixEventTerminate);
            ASSERT(fResult);
            fResult = CloseHandle(hMixEventRemix);
            ASSERT(fResult);
        }
    }

    return hr;
}

//--------------------------------------------------------------------------;
//
// mxTerminate
//
// This function is called to terminate the grace mixer thread for the
// specified DS object.  It returns the handle to the thread that is being
// terminated.  After releasing any critical sections that the grace mixer
// thread may be waiting on, the caller should wait for the thread handle
// to become signaled.  For Win32 beginners: the thread handle is signalled
// after the thread terminates.
//
//--------------------------------------------------------------------------;

#undef DPF_FNAME
#define DPF_FNAME "CNaGrace::Terminate"

void CNaGrace::Terminate()
{
    VxdEventScheduleWin32Event(m_vxdhMixEventTerminate, 0);

    VxdEventCloseVxdHandle(m_vxdhMixEventTerminate);
    VxdEventCloseVxdHandle(m_vxdhMixEventRemix);

    // Wait for mixer thread to die

    if (m_hMixThread)
    {
        DWORD dwResult;
        HANDLE hHelper;
        HANDLE hMixThreadOurs;

        DPF(DPFLVL_MOREINFO, "Note: waiting for mixer thread to terminate");
        hHelper = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwHelperPid);
        if (hHelper)
        {
            if (DuplicateHandle(hHelper, m_hMixThread, GetCurrentProcess(),
                                &hMixThreadOurs, SYNCHRONIZE | THREAD_TERMINATE,
                                FALSE, DUPLICATE_CLOSE_SOURCE))
            {
                dwResult = WaitObject(INFINITE, hMixThreadOurs);
                ASSERT(WAIT_OBJECT_0 == dwResult);
                dwResult = CloseHandle(hMixThreadOurs);
                ASSERT(dwResult);
            }
            dwResult = CloseHandle(hHelper);
            ASSERT(dwResult);
        }
    }

    m_hMixThread = NULL;
    m_vxdhMixEventTerminate = NULL;
    m_vxdhMixEventRemix = NULL;

    CGrace::Terminate();
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrace::GetMaxRemix"

int CNaGrace::GetMaxRemix()
{
    // Return max number of samples we might remix
    return (MulDivRU(MIXER_MAXPREMIX, m_pDest->m_nFrequency, 1000));
}

#endif // NOVXD

#undef DPF_FNAME
#define DPF_FNAME "WeGrDest_New"

PVOID WeGrDest_New(UINT uDeviceId)
{
    return NEW(CWeGrDest(uDeviceId));
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::CWeGrDest"

CWeGrDest::CWeGrDest(UINT uWaveDeviceId)
{
    m_uDeviceId = uWaveDeviceId;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::Initialize"

HRESULT CWeGrDest::Initialize(void)
{
    MMRESULT mmr;
    ASSERT(!m_pBuffer);

    mmr = InitializeEmulator();
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF(DPFLVL_MOREINFO, "InitializeEmulator() returned %lu", mmr);
        return MMRESULTtoHRESULT(mmr);
    }

    m_cSamples = m_cbBuffer >> m_nBlockAlignShift;

    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::Terminate"

void CWeGrDest::Terminate(void)
{
    if (m_hWaveThread)
        ShutdownEmulator();

    MEMFREE(m_pBuffer);
    MEMFREE(m_awhWaveHeaders);
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::SetFormat"

HRESULT CWeGrDest::SetFormat(LPWAVEFORMATEX pwfx)
{
    MMRESULT mmr;
    HRESULT hr;

    DPF_ENTER();

    // ??? Can we optimize this process at all? Do we need to?

    if (m_hwo)
    {
        ShutdownEmulator();
        m_hwo = NULL;
    }

    // FIXME allocation and freeing of the looping buffer is
    // really screwy.  Need to review relevant code.  Esp. check
    // case where SetFormat fails and then attempts to restore the
    // original format
    
    // In this case, the looping buffer will not be free'd
    // because that is normally the job of the release code for
    // the primary. Do it now.

    MEMFREE(m_pBuffer);
    MEMFREE(m_awhWaveHeaders);

    SetFormatInfo(pwfx);

    mmr = InitializeEmulator();
    if (!mmr)
        hr = DS_OK;
    else
    {
        DPF(DPFLVL_WARNING, "Attempt to reinitialize emulator failed! %u",mmr);
        if (WAVERR_BADFORMAT == mmr)
            hr = DSERR_BADFORMAT;
        else if (MMSYSERR_NOMEM == mmr)
            hr = DSERR_OUTOFMEMORY;
        else
            hr = DSERR_GENERIC;
    }

    m_cSamples = m_cbBuffer >> m_nBlockAlignShift;

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::AllocMixer"

HRESULT CWeGrDest::AllocMixer(CMixer **ppMixer)
{
    HRESULT hr;
    ASSERT(m_pBuffer);
    
    *ppMixer = NULL;
    
    m_pWeGrace = NEW(CWeGrace);
    hr = HRFROMP(m_pWeGrace);

    if (SUCCEEDED(hr))
        hr = m_pWeGrace->Initialize(this);

    if (SUCCEEDED(hr))
        *ppMixer = m_pWeGrace;
    else
        DELETE(m_pWeGrace);

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::FreeMixer"

void CWeGrDest::FreeMixer()
{
    ASSERT(m_pWeGrace);

    m_pWeGrace->Terminate();
    DELETE(m_pWeGrace);
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::Play"

void CWeGrDest::Play()
{
    // REMIND must reimplement to actually play, especially if we ever fix
    // this to support DSSCL_WRITEPRIMARY apps in wave emulation mode.
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::Stop"

void CWeGrDest::Stop()
{
    // REMIND must reimplement to actually stop, especially if we ever fix
    // this to support DSSCL_WRITEPRIMARY apps in wave emulation mode.
    if (m_pBuffer)
        FillMemory(m_pBuffer, m_cbBuffer, (H_16_BITS & m_hfFormat) ? 0x00 : 0x80);
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::GetSamplePosition"

HRESULT CWeGrDest::GetSamplePosition(int *pposPlay, int *pposWrite)
{
    MMTIME mmt;
    int iawhWrite;
    int iawhPrevious;
    int posStartOfPreviousHeader;
    MMRESULT mmr;
    HRESULT hr = DSERR_GENERIC;

    if(pposPlay && pposWrite && m_hwo)
    {
        // For the play position, try to get sample position from wave driver.
        // If that doesn't work then we'll return a play position based on the
        // last done wave header.
        mmt.wType = TIME_SAMPLES;
        mmr = waveOutGetPosition(m_hwo, &mmt, sizeof(mmt));

        // Note: This assert might need to be #ifdef'd out on Win2K because of a
        // known bug in WDMAUD's memory error propagation (see Windows Bug 176033).
        ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr);
        // Want to catch bugs, but still handle error in case of bad drivers

        if (!mmr && (TIME_SAMPLES == mmt.wType))
            *pposPlay = mmt.u.sample % m_cSamples;
        else if (!mmr && (TIME_BYTES == mmt.wType))
            *pposPlay = (mmt.u.cb % m_cbBuffer) >> m_nBlockAlignShift;
        else
            *pposPlay = (m_iawhPlaying * m_cbDMASize) >> m_nBlockAlignShift;

        // Some ill-behaved drivers are completing headers before the wave
        // position gets past the data in the header.  Let's do a sanity check
        // to make sure the reported position is not in the last completed header

        iawhPrevious = (m_iawhPlaying + m_cWaveHeaders - 1) % m_cWaveHeaders;
        posStartOfPreviousHeader = iawhPrevious * (m_cbDMASize >> m_nBlockAlignShift);
        if (*pposPlay >= posStartOfPreviousHeader &&
            *pposPlay < posStartOfPreviousHeader + (int)(m_cbDMASize >> m_nBlockAlignShift))
        {
            *pposPlay = (m_iawhPlaying * m_cbDMASize) >> m_nBlockAlignShift;
        }
    
        // The write position is based on the last done header
        iawhWrite = (m_iawhPlaying + N_EMU_WAVE_HDRS_INQUEUE) % m_cWaveHeaders;
        *pposWrite = (iawhWrite * m_cbDMASize) >> m_nBlockAlignShift;

        hr = DS_OK;
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::GetSamplePositionNoWin16"

HRESULT CWeGrDest::GetSamplePositionNoWin16(int *pposPlay, int *pposWrite)
{
    int iawhWrite;
    
    // Estimate play position by just using position at start of
    // currently playing header
    *pposPlay = (m_iawhPlaying * m_cbDMASize) >> m_nBlockAlignShift;

    // The write position is based on the last done header
    iawhWrite = (m_iawhPlaying + N_EMU_WAVE_HDRS_INQUEUE) % m_cWaveHeaders;
    *pposWrite = (iawhWrite * m_cbDMASize) >> m_nBlockAlignShift;

    return DS_OK;
}

//---------------------------------------------------------------------------
//
// waveThreadLoop
//
//  This function is responsible for continuously writing our wave headers
// to the wave device.  It also calls the MixThreadCallback routine to
// mix more data into the wave headers.
//
//  This function waits for a WaveHeaderDone event signalled by
// waveThreadCallback, which is a waveOutProc callback function.  Upon
// receving the signal this function will write all done headers back to
// the wave device.  Normally one header will be done on each signal.  But
// there may be more in cases where more than one header finishex before this
// thread is scheduled.
//
//  Once all done headers are rewritten to the wave device, the header
// following the last one written is considered to be the one currently
// playing.  This header is called the "committed" header and an index to
// it is saved in pds->iawhPlaying.
//
//  The count of done headers is maintained using the Interlocked APIs.  The
// waveThreadCallback function will increment the count and this function will
// decrement it.
//
//  This function will also react to a terminate event.  This event is
// signalled during release of the DirectSound object.  This loop will
// terminate and return to the waveThread function which will clean up
// and terminate.
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::WaveThreadLoop"

void CWeGrDest::WaveThreadLoop(HANDLE hEventTerminate)
{
    MMRESULT mmr;

    while (TRUE)
    {
        DWORD dwResult;
        LPWAVEHDR pwh;
        int iawhWrite;
        HANDLE ah[2] = {hEventTerminate, m_hEventWaveHeaderDone};

        // The first wait is for either a terminate or headerdone event.
        // The second wait is for either a terminate or the DLL mutex.
        dwResult = WaitObjectArray(2, INFINITE, FALSE, ah);
        if (WAIT_OBJECT_0 == dwResult) break;

        InterlockedDecrement(&m_cwhDone);
        while (m_cwhDone >= 0)
        {
            dwResult = ENTER_MIXER_MUTEX_OR_EVENT(hEventTerminate);
            if (WAIT_OBJECT_0 == dwResult)
                break;

            m_iawhPlaying = (m_iawhPlaying + 1) % m_cWaveHeaders;

            if (m_pWeGrace)
                m_pWeGrace->Refresh(m_cbDMASize >> m_nBlockAlignShift);
            
            iawhWrite = (m_iawhPlaying + N_EMU_WAVE_HDRS_INQUEUE) % m_cWaveHeaders;
            pwh = m_awhWaveHeaders + iawhWrite;

            // Leave the mixer mutex in order to avoid deadlock situations
            // with the Win16Mutex and waveOutWrite.
            LEAVE_MIXER_MUTEX();

            mmr = waveOutWrite(m_hwo, pwh, sizeof(*pwh));
            ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr);

            InterlockedDecrement(&m_cwhDone);
        }
        InterlockedIncrement(&m_cwhDone);

        if (WAIT_OBJECT_0 == dwResult)
            break;
    }

    DPF_LEAVE_VOID();
}


//---------------------------------------------------------------------------
//
// WaveCallback
//
//  This is a waveOutProc callback function.  Its sole purpose is to
// increment a count of done headers and signal and event to waveThreadLoop
// that another header is done.
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "WaveCallbackC"

VOID CALLBACK WaveCallbackC
(
    HWAVE     hwo,
    UINT      uMsg,
    DWORD_PTR dwUser,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
)
{
    ((CWeGrDest *)dwUser)->WaveCallback(hwo, uMsg, dwParam1, dwParam2);
}

//---------------------------------------------------------------------------
//
// waveThreadCallback
//
//  This is a waveOutProc callback function.  Its sole purpose is to
// increment a count of done headers and signal and event to waveThreadLoop
// that another header is done.
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::WaveCallback"

VOID CWeGrDest::WaveCallback
(
    HWAVE     hwo,
    UINT      uMsg,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2
)
{
    if ((MM_WOM_DONE == uMsg) && (m_hEventWaveHeaderDone))
    {
        InterlockedIncrement(&m_cwhDone);
        SetEvent(m_hEventWaveHeaderDone);
    }
}

#undef DPF_FNAME
#define DPF_FNAME "WaveThreadC"

DWORD WINAPI WaveThreadC
(
    PVOID pThreadParams
)
{
    return ((CWeGrDest *)pThreadParams)->WaveThread();
}
    

//---------------------------------------------------------------------------
//
// WaveThread
//
// This thread proc initializes the wave device for DS emulation and then
// calls waveThreadLoop.  See the waveThreadLoop comment header.  Upon
// return from waveThreadLoop, this function will clean up and terminate.
//
//---------------------------------------------------------------------------

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::WaveThread"

DWORD CWeGrDest::WaveThread(void)
{
    HANDLE      hEventInitDone;
    HANDLE      hEventTerminate;
    DWORD       dwVolume;
    MMRESULT    mmrInit;
    MMRESULT    mmr;
    BOOL        f;

    // mmrInit - holds the result code to be passed back to the creator
    //  via pds->mmrWaveThreadInit.
    //
    // mmr - a temp result code
    
    DPF(DPFLVL_INFO, "WaveThread startup for pWeGrDest=%08lX", this);

    ASSERT(NULL == m_hwo);

    hEventInitDone = CreateEvent(NULL, FALSE, FALSE, m_szEventWaveThreadInitDone);
    if (!hEventInitDone)
    {
        DPF(DPFLVL_ERROR, "Couldn't create hEventInitDone");
        return 0;
    }

    // The waveOutOpen call below needs to happen at normal process
    // and thread priority, to prevent tedious deadlocks in WinMM

    HANDLE hProcess = GetCurrentProcess();
    HANDLE hThread  = GetCurrentThread();
    DWORD dwProcPri = GetPriorityClass(hProcess);
    INT nThreadPri  = GetThreadPriority(hThread);

    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
    SetThreadPriority(hThread, THREAD_PRIORITY_NORMAL);

    mmrInit = waveOutOpen(&m_hwo, m_uDeviceId, &m_wfx, (DWORD_PTR)WaveCallbackC, (DWORD_PTR)this, CALLBACK_FUNCTION);

    SetPriorityClass(hProcess, dwProcPri);
    SetThreadPriority(hThread, nThreadPri);

    if (MMSYSERR_NOERROR == mmrInit)
    {
        // Some mmsystem wave drivers will program their wave mixer
        // hardware only while the device is open.  By doing the
        // following, we can get such drivers to program the hardware:

        mmr = waveOutGetVolume(m_hwo, &dwVolume);
        if (MMSYSERR_NOERROR == mmr)
            mmr = waveOutSetVolume(m_hwo, dwVolume);

        #ifndef WINNT
        ASSERT(MMSYSERR_NOERROR == mmr || MMSYSERR_NOMEM == mmr);
        // Note: #ifdef'd out on NT for now because of a known bug in
        // WDMAUD's memory error propagation (see Windows Bug 176033).
        #endif

        f = SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
        ASSERT(f);
        
        mmrInit = WaveDetermineDMASize(m_hwo, &m_wfx, &m_cbBuffer, &m_cWaveHeaders, &m_cbDMASize);
        if (MMSYSERR_NOERROR == mmrInit) 
        {
            ASSERT(NULL == m_hEventWaveHeaderDone);
            m_cwhDone = 0;
            m_hEventWaveHeaderDone = CreateEvent(NULL, FALSE, FALSE, m_szEventWaveHeaderDone);
            if (!m_hEventWaveHeaderDone)
                mmrInit = MMSYSERR_NOMEM;
            if (!mmrInit)
            {
                m_iawhPlaying = 0;
                ASSERT(m_cbDMASize * m_cWaveHeaders == m_cbBuffer);

                mmrInit = WaveAllocAndPrepareLoopingBuffers(m_hwo, &m_wfx, m_cWaveHeaders,
                    N_EMU_WAVE_HDRS_INQUEUE, &m_awhWaveHeaders, m_cbDMASize, &m_pBuffer);
                
                if (!mmrInit)
                {
                    hEventTerminate = CreateEvent(NULL, FALSE, FALSE, m_szEventTerminateWaveThread);
                    if (!hEventTerminate) mmrInit = MMSYSERR_NOMEM;
                    if (!mmrInit)
                    {
                        // Signal that we're finished with initialization.
                        // mmrInit should not be modified below this point.
                        m_mmrWaveThreadInit = mmrInit;
                        SetEvent(hEventInitDone);

                        WaveThreadLoop(hEventTerminate);

                        CloseHandle(hEventTerminate);
                    }

                    mmr = waveOutReset(m_hwo);
                    ASSERT(MMSYSERR_NOERROR == mmr);

                    WaveUnprepareLoopingBuffers(m_hwo, m_awhWaveHeaders, m_cWaveHeaders);
                }

                CloseHandle(m_hEventWaveHeaderDone);
                m_hEventWaveHeaderDone = NULL;
            }
        }

        mmr = waveOutReset(m_hwo);
        ASSERT(MMSYSERR_NOERROR == mmr);

        mmr = waveOutClose(m_hwo);
        ASSERT(MMSYSERR_NOERROR == mmr);
        m_hwo = NULL;
    }

    // If init failed, set the result code and signal init done.
    if (MMSYSERR_NOERROR != mmrInit)
    {
        m_hwo = NULL;
        m_mmrWaveThreadInit = mmrInit;
        SetEvent(hEventInitDone);
    }
    
    CloseHandle(hEventInitDone);
    return 0;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::InitializeEmulator"

MMRESULT CWeGrDest::InitializeEmulator(void)
{
    DWORD       dwResult;
    HANDLE      hEventInitDone;
    MMRESULT    mmr;

    DPF_ENTER();

    ASSERT(sizeof(m_szEventWaveHeaderDone) >= 7+8+8+1);
    wsprintf(m_szEventWaveHeaderDone, TEXT("DS-EWHD%08lX%08lX"), GetCurrentProcessId(), this);

    ASSERT(sizeof(m_szEventWaveThreadInitDone) >= 8+8+8+1);
    wsprintf(m_szEventWaveThreadInitDone, TEXT("DS-EWTID%08lX%08lX"), GetCurrentProcessId(), this);

    ASSERT(sizeof(m_szEventTerminateWaveThread) >= 7+8+8+1);
    wsprintf(m_szEventTerminateWaveThread, TEXT("DS-ETWT%08lX%08lX"), GetCurrentProcessId(), this);

    hEventInitDone = CreateEvent(NULL, FALSE, FALSE, m_szEventWaveThreadInitDone);
    if (!hEventInitDone)
        return MMSYSERR_NOMEM;

    // Side effects begin (hEventInitDone created)
    // hWaveThread is the thread which recycles wave buffers

#ifdef SHARED

    m_hWaveThread = HelperCreateDSMixerThread(WaveThreadC, this, 0, NULL);

#else // SHARED

    DWORD dwTid;
    m_hWaveThread = CreateThread(NULL, 0, WaveThreadC, this, 0, &dwTid);

#endif // SHARED

    mmr = (m_hWaveThread) ? MMSYSERR_NOERROR : MMSYSERR_NOMEM;

    if (MMSYSERR_NOERROR == mmr)
    {
        DPF(DPFLVL_MOREINFO, "Mixer thread created: 0x%p", m_hWaveThread);

        dwResult = WaitObject(INFINITE, hEventInitDone);
        ASSERT(WAIT_OBJECT_0 == dwResult);
        mmr = m_mmrWaveThreadInit;

        if (mmr)
        {
            HANDLE hHelper;
            HANDLE hWaveThreadOurs;

            // Something went wrong.  Clean up.

            // Note that hWaveThread is relative to the helper process.
            hHelper = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwHelperPid);
            if (hHelper)
            {
                if (DuplicateHandle(hHelper, m_hWaveThread,
                                    GetCurrentProcess(), &hWaveThreadOurs,
                                    SYNCHRONIZE | THREAD_TERMINATE,
                                    FALSE, DUPLICATE_CLOSE_SOURCE))
                {
                    dwResult = WaitObject(INFINITE, hWaveThreadOurs);
                    ASSERT(WAIT_OBJECT_0 == dwResult);
                    dwResult = CloseHandle(hWaveThreadOurs);
                    ASSERT(dwResult);
                }
                dwResult = CloseHandle(hHelper);
                ASSERT(dwResult);
            }
            m_hWaveThread = NULL;
        }
    }
    else
    {
        DPF(DPFLVL_ERROR, "Unable to create mixer thread");
    }

    dwResult = CloseHandle(hEventInitDone);
    ASSERT(dwResult);
    
    return mmr;
}

#undef DPF_FNAME
#define DPF_FNAME "CWeGrDest::ShutdownEmulator"

MMRESULT CWeGrDest::ShutdownEmulator(void)
{
    HANDLE  hEventTerminate;
    HANDLE  hHelper;
    HANDLE  hWaveThreadOurs;
    DWORD   dwResult;

    DPF(DPFLVL_INFO, "About to shutdown emulator");

    ASSERT(m_hWaveThread);
    
    // Signal wave thread to go away.

    hEventTerminate = CreateEvent(NULL, FALSE, FALSE, m_szEventTerminateWaveThread);
    if (hEventTerminate)
    {
        SetEvent(hEventTerminate);
        CloseHandle(hEventTerminate);
        hEventTerminate = NULL;
    }

    DPF(DPFLVL_MOREINFO, "Emulator: Wait for callback thread to die");

    hHelper = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwHelperPid);
    if (hHelper)
    {
        if (DuplicateHandle(hHelper, m_hWaveThread, GetCurrentProcess(),
                            &hWaveThreadOurs, SYNCHRONIZE | THREAD_TERMINATE,
                            FALSE, DUPLICATE_CLOSE_SOURCE))
        {
            dwResult = WaitObject(INFINITE, hWaveThreadOurs);
            ASSERT(dwResult == WAIT_OBJECT_0);

            if(GetExitCodeThread(hWaveThreadOurs, &dwResult) && 0 == dwResult)
            {
                ASSERT(NULL == m_hwo);   // waveThread should do this if it terminates normally
                m_hwo = NULL;
            }

            dwResult = CloseHandle(hWaveThreadOurs);
            ASSERT(dwResult);
        }
        dwResult = CloseHandle(hHelper);
        ASSERT(dwResult);
    }
    else
    {
        DPF(DPFLVL_WARNING, "Emulator: couldn't open handle on helper");
    }

    m_hWaveThread = NULL;
        
    return MMSYSERR_NOERROR;
}


#ifndef NOVXD

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::CNaGrDest"

CNaGrDest::CNaGrDest(LPNAGRDESTDATA pData)
{
    m_pBuffer = pData->pBuffer;
    m_cbBuffer = pData->cbBuffer;
    m_hBuffer = pData->hBuffer;
    m_phwo = pData->phwo;
    m_uDeviceId = pData->uDeviceId;
    m_fdwDriverDesc = pData->fdwDriverDesc;
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Initialize"

HRESULT CNaGrDest::Initialize(void)
{
    m_cSamples = m_cbBuffer >> m_nBlockAlignShift;
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Terminate"

void CNaGrDest::Terminate(void)
{
    if(m_phwo)
        CloseWaveOut(m_phwo);
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Terminate"

HRESULT CNaGrDest::SetFormat(LPWAVEFORMATEX pwfx)
{
    HRESULT hr = DS_OK;

    SetFormatInfo(pwfx);

    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    if (DSDDESC_DOMMSYSTEMSETFORMAT & m_fdwDriverDesc)
    {
        // We need to set the wave format by doing a waveOutOpen
        // on the mmsystem wave device
        DPF(DPFLVL_MOREINFO, "DSDDESC_DOMMSYSTEMSETFORMAT");

        hr = CloseWaveOut(m_phwo);

        if (SUCCEEDED(hr))
            hr = OpenWaveOut(m_phwo, m_uDeviceId, pwfx);
    }

    if (SUCCEEDED(hr))
    {
        // If the driver specified DOMMSYSTEMSETFORMAT, this call
        // is just a notification to the DS driver that we've set the
        // format through waveOutOpen.  It is okay for the driver to
        // return DS_NOTSUPPORTED in that case.

        hr = VxdBufferSetFormat(m_hBuffer, pwfx);
        if ((DSDDESC_DOMMSYSTEMSETFORMAT & m_fdwDriverDesc) && (DSERR_UNSUPPORTED == hr))
            hr = DS_OK;
    
        if (FAILED(hr))
            DPF(DPFLVL_ERROR, "VxdBufferSetFormat returned %s", HRESULTtoSTRING(hr));
    }

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::AllocMixer"

HRESULT CNaGrDest::AllocMixer(CMixer **ppMixer)
{
    HRESULT hr;
    ASSERT(m_pBuffer);
    
    *ppMixer = NULL;
    
    m_pNaGrace = NEW(CNaGrace);
    hr = HRFROMP(m_pNaGrace);

    if (SUCCEEDED(hr))
        hr = m_pNaGrace->Initialize(this);

    if (SUCCEEDED(hr))
        *ppMixer = m_pNaGrace;
    else
        DELETE(m_pNaGrace);

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::FreeMixer"

void CNaGrDest::FreeMixer()
{
    ASSERT(m_pNaGrace);

    m_pNaGrace->Terminate();
    DELETE(m_pNaGrace);
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Play"

void CNaGrDest::Play()
{
    VxdBufferPlay(m_hBuffer, 0, 0, DSBPLAY_LOOPING);
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Stop"

void CNaGrDest::Stop()
{
    VxdBufferStop(m_hBuffer);
}
    
#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Lock"

HRESULT CNaGrDest::Lock(PVOID *ppBuffer1, int *pcbBuffer1, PVOID *ppBuffer2, int *pcbBuffer2, int ibWrite, int cbWrite)
{
    LOCKCIRCULARBUFFER lcb;
    HRESULT            hr;
    
    lcb.pHwBuffer = m_hBuffer;
    lcb.pvBuffer = m_pBuffer;
    lcb.cbBuffer = m_cbBuffer;
    lcb.fPrimary = TRUE;
    lcb.fdwDriverDesc = m_fdwDriverDesc;
    lcb.ibRegion = ibWrite;
    lcb.cbRegion = cbWrite;

    hr = LockCircularBuffer(&lcb);

    if(SUCCEEDED(hr))
    {
        *ppBuffer1 = lcb.pvLock[0];
        *pcbBuffer1 = lcb.cbLock[0];

        if(ppBuffer2)
        {
            *ppBuffer2 = lcb.pvLock[1];
        }
        else
        {
            ASSERT(!lcb.pvLock[1]);
        }

        if(pcbBuffer2)
        {
            *pcbBuffer2 = lcb.cbLock[1];
        }
        else
        {
            ASSERT(!lcb.cbLock[1]);
        }
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::Unlock"

HRESULT CNaGrDest::Unlock(PVOID pBuffer1, int cbBuffer1, PVOID pBuffer2, int cbBuffer2)
{
    LOCKCIRCULARBUFFER lcb;

    lcb.pHwBuffer = m_hBuffer;
    lcb.pvBuffer = m_pBuffer;
    lcb.cbBuffer = m_cbBuffer;
    lcb.fPrimary = TRUE;
    lcb.fdwDriverDesc = m_fdwDriverDesc;
    lcb.pvLock[0] = pBuffer1;
    lcb.cbLock[0] = cbBuffer1;
    lcb.pvLock[1] = pBuffer2;
    lcb.cbLock[1] = cbBuffer2;

    return UnlockCircularBuffer(&lcb);
}

#undef DPF_FNAME
#define DPF_FNAME "CNaGrDest::GetSamplePosition"

HRESULT CNaGrDest::GetSamplePosition(int *pposPlay, int *pposWrite)
{
    HRESULT hr;
    DWORD dwPlay, dwWrite;
    
    ASSERT(pposPlay && pposWrite);
    
    hr = VxdBufferGetPosition(m_hBuffer, &dwPlay, &dwWrite);
    if (SUCCEEDED(hr))
    {
        *pposPlay = dwPlay >> m_nBlockAlignShift;
        *pposWrite = dwWrite >> m_nBlockAlignShift;

        // Until we write code to actually profile the performance, we'll just
        // pad the write position with a hard coded amount
        *pposWrite += m_nFrequency * HW_WRITE_CURSOR_MSEC_PAD / 1024;
        if (*pposWrite >= m_cSamples) *pposWrite -= m_cSamples;
        ASSERT(*pposWrite < m_cSamples);
    }
    else
    {
        *pposPlay = *pposWrite = 0;
    }

    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::Terminate"

void CThMixer::Terminate(void)
{
    DPF_ENTER();
    
    m_pKeMixer = NULL;
    /*
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
    } ioparams;

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_Terminate,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);
    */
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::Run"

HRESULT CThMixer::Run(void)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    DPF_ENTER();

    struct {
        PVOID pKeMixer;
    } ioparams;

    ENTER_MIXER_MUTEX();
    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_Run,
                          &ioparams,
                          sizeof(ioparams),
                          &hr,
                          sizeof(hr),
                          &cbReturned,
                          NULL);

    if (!fOk)
    {
        DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
        hr = DSERR_GENERIC;
    }
    else
    {
        ASSERT(cbReturned == sizeof(hr));
    }

    LEAVE_MIXER_MUTEX();
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::Stop"

BOOL CThMixer::Stop(void)
{
    BOOL f;
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_Stop,
                          &ioparams,
                          sizeof(ioparams),
                          &f,
                          sizeof(f),
                          &cbReturned,
                          NULL);

    if (!fOk)
    {
        f = FALSE;
        DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    }
    else
    {
        ASSERT(cbReturned == sizeof(f));
    }

    LEAVE_MIXER_MUTEX();
    return f;
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::PlayWhenIdle"

void CThMixer::PlayWhenIdle(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_PlayWhenIdle,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::StopWhenIdle"

void CThMixer::StopWhenIdle(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_StopWhenIdle,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::MixListAdd"

void CThMixer::MixListAdd(CMixSource *pSource)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
        CMixSource *pSource;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);
    ASSERT(pSource);

    ioparams.pKeMixer = m_pKeMixer;
    ioparams.pSource = pSource;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_MixListAdd,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::MixListRemove"

void CThMixer::MixListRemove(CMixSource *pSource)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
        CMixSource *pSource;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    ioparams.pSource = pSource;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_MixListRemove,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::FilterOn"

void CThMixer::FilterOn(CMixSource *pSource)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
        CMixSource *pSource;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    ioparams.pSource = pSource;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_FilterOn,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::FilterOff"

void CThMixer::FilterOff(CMixSource *pSource)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
        CMixSource *pSource;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    ioparams.pSource = pSource;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_FilterOff,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::GetBytePosition"

void CThMixer::GetBytePosition(CMixSource *pSource, int *pibPlay, int *pibWrite)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
        CMixSource *pSource;
        int *pibPlay;
        int *pibWrite;
    } ioparams;

    ENTER_MIXER_MUTEX();
    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    ioparams.pSource = pSource;
    ioparams.pibPlay = pibPlay;
    ioparams.pibWrite = pibWrite;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_GetBytePosition,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE (%lu)", GetLastError());
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::SignalRemix"

void CThMixer::SignalRemix(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeMixer;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeMixer);

    ioparams.pKeMixer = m_pKeMixer;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_Mixer_SignalRemix,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThMixer::Initialize"

HRESULT CThMixer::Initialize(PVOID pKeMixer)
{
    DPF_ENTER();

    ASSERT(!m_pKeMixer);
    m_pKeMixer = pKeMixer;
    return DS_OK;
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::CThDest"

CThDest::CThDest(LPNAGRDESTDATA pData)
{
    CopyMemory(&m_ngdd, pData, sizeof(NAGRDESTDATA));
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::New"

HRESULT CThDest::New(void)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    struct {
        LPNAGRDESTDATA pData;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ioparams.pData = &m_ngdd;
    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_KeDest_New,
                          &ioparams,
                          sizeof(ioparams),
                          &m_pKeDest,
                          sizeof(m_pKeDest),
                          &cbReturned,
                          NULL);

    if (!fOk)
    {
        DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
        m_pKeDest = NULL;
        hr = DSERR_GENERIC;
    }
    else
    {
        ASSERT(cbReturned == sizeof(m_pKeDest));
    }

    hr = HRFROMP(m_pKeDest);

    LEAVE_MIXER_MUTEX();
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::Initialize"

HRESULT CThDest::Initialize(void)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
    } ioparams;
    
    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_Initialize,
                          &ioparams,
                          sizeof(ioparams),
                          &hr,
                          sizeof(hr),
                          &cbReturned,
                          NULL);

    if (!fOk)
    {
        DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
        hr = DSERR_GENERIC;
    }
    else
    {
        ASSERT(cbReturned == sizeof(hr));
    }

    LEAVE_MIXER_MUTEX();
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::Terminate"

void CThDest::Terminate(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_Terminate,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;

    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_Delete,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::SetFormatInfo"

void CThDest::SetFormatInfo(LPWAVEFORMATEX pwfx)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
        LPWAVEFORMATEX pwfx;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    ioparams.pwfx = pwfx;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_SetFormatInfo,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::SetFormat"

HRESULT CThDest::SetFormat(LPWAVEFORMATEX pwfx)
{
    HRESULT hr = DS_OK;

    SetFormatInfo(pwfx);

    DPF_ENTER();
    ENTER_MIXER_MUTEX();

    if (DSDDESC_DOMMSYSTEMSETFORMAT & m_ngdd.fdwDriverDesc)
    {
        // We need to set the wave format by doing a waveOutOpen
        // on the mmsystem wave device
        DPF(DPFLVL_MOREINFO, "DSDDESC_DOMMSYSTEMSETFORMAT");

        hr = CloseWaveOut(m_ngdd.phwo);

        if (SUCCEEDED(hr))
            hr = OpenWaveOut(m_ngdd.phwo, m_ngdd.uDeviceId, pwfx);
    }

    if (SUCCEEDED(hr))
    {
        // If the driver specified DOMMSYSTEMSETFORMAT, this call
        // is just a notification to the driver that we've set the
        // format through waveOutOpen.  It is OK for the driver to
        // return DS_NOTSUPPORTED in that case.

        struct {
            PVOID pKeDest;
            LPWAVEFORMATEX pwfx;
        } ioparams;

        ASSERT(m_pKeDest);

        ioparams.pKeDest = m_pKeDest;
        ioparams.pwfx = pwfx;
        DWORD cbReturned = 0;

        BOOL fOk = DeviceIoControl(g_hDsVxd,
                                   DSVXD_IOCTL_MixDest_SetFormat,
                                   &ioparams,
                                   sizeof(ioparams),
                                   &hr,
                                   sizeof(hr),
                                   &cbReturned,
                                   NULL);
        if (!fOk)
        {
            DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
            hr = DSERR_GENERIC;
        }
        else
            ASSERT(cbReturned == sizeof(hr));

        if ((DSDDESC_DOMMSYSTEMSETFORMAT & m_ngdd.fdwDriverDesc) && (DSERR_UNSUPPORTED == hr))
            // Drivers can return DSERR_UNSUPPORTED if they set DOMMSYSTEMSETFORMAT
            hr = DS_OK;

        if (FAILED(hr))
            DPF(DPFLVL_ERROR, "VxdBufferSetFormat returned %s", HRESULTtoSTRING(hr));
    }

    LEAVE_MIXER_MUTEX();
    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::AllocMixer"

HRESULT CThDest::AllocMixer(CMixer **ppMixer)
{
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
        PVOID *ppKeMixer;
    } ioparamsAlloc;

    struct {
        PVOID pKeDest;
    } ioparamsFree;

    PVOID pKeMixer;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);
    ASSERT(!m_pThMixer);

    // 1) Allocate a ThMixer object
    // 2) Call KeDest object to allocate a KeMixer object
    // 3) Initialize the ThMixer object, passing the KeMixer object

    *ppMixer = NULL;

    // Allocate the ThMixer object
    m_pThMixer = NEW(CThMixer);
    hr = HRFROMP(m_pThMixer);

    if (SUCCEEDED(hr))
    {
        // Call KeDest object to allocate the KeMixer object
        ioparamsAlloc.pKeDest = m_pKeDest;
        ioparamsAlloc.ppKeMixer = &pKeMixer;
        cbReturned = 0;
    
        fOk = DeviceIoControl(g_hDsVxd,
                              DSVXD_IOCTL_MixDest_AllocMixer,
                              &ioparamsAlloc,
                              sizeof(ioparamsAlloc),
                              &hr,
                              sizeof(hr),
                              &cbReturned,
                              NULL);
        ASSERT(fOk);
        ASSERT(SUCCEEDED(hr));
        
        if (!fOk)
            hr = DSERR_GENERIC;
        else
            ASSERT(cbReturned == sizeof(hr));

        if (SUCCEEDED(hr))
        {
            ASSERT(pKeMixer);

            // Initialize the ThMixer object with the KeMixer object
            hr = m_pThMixer->Initialize(pKeMixer);
            ASSERT(SUCCEEDED(hr));
            if (FAILED(hr))
            {
                ioparamsFree.pKeDest = m_pKeDest;
                cbReturned = 0;
            
                fOk = DeviceIoControl(g_hDsVxd,
                                      DSVXD_IOCTL_MixDest_FreeMixer,
                                      &ioparamsFree,
                                      sizeof(ioparamsFree),
                                      NULL,
                                      0,
                                      &cbReturned,
                                      NULL);
                ASSERT(fOk);
            }
        }

        if (FAILED(hr))
            DELETE(m_pThMixer);
    }

    if (SUCCEEDED(hr))
        *ppMixer = m_pThMixer;

    LEAVE_MIXER_MUTEX();
    return hr;
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::FreeMixer"

void CThDest::FreeMixer(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);
    ASSERT(m_pThMixer);

    m_pThMixer->Terminate();
    DELETE(m_pThMixer);
    
    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_FreeMixer,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_WARNING, "DeviceIoControl returned FALSE");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::Play"

void CThDest::Play(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_Play,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_ERROR, "DSVXD_IOCTL_MixDest_Play failed!");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::Stop"

void CThDest::Stop(void)
{
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_Stop,
                          &ioparams,
                          sizeof(ioparams),
                          NULL,
                          0,
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_ERROR, "DSVXD_IOCTL_MixDest_Stop failed!");
    ASSERT(cbReturned == 0);

    LEAVE_MIXER_MUTEX();
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::GetSamplePosition"

HRESULT CThDest::GetSamplePosition(int *pposPlay, int *pposWrite)
{
    ASSERT(FALSE);
    return DSERR_GENERIC;
    /*
    HRESULT hr;
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
        int *pposPlay;
        int *pposWrite;
    } ioparams;

    ENTER_MIXER_MUTEX();
    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    ioparams.pposPlay = pposPlay;
    ioparams.pposWrite = pposWrite;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_GetSamplePosition,
                          &ioparams,
                          sizeof(ioparams),
                          &hr,
                          sizeof(hr),
                          &cbReturned,
                          NULL);

    if (!fOk) {
        DPF(DPFLVL_ERROR, "DSVXD_IOCTL_MixDest_GetSamplePosition failed!");
        hr = DSERR_GENERIC;
    } else {
        ASSERT(cbReturned == sizeof(hr));
    }

    LEAVE_MIXER_MUTEX();
    return hr;
    */
}

#undef DPF_FNAME
#define DPF_FNAME "CThDest::GetFrequency"

ULONG CThDest::GetFrequency(void)
{
    ULONG nFrequency;
    DWORD cbReturned;
    BOOL fOk;

    struct {
        PVOID pKeDest;
    } ioparams;

    ENTER_MIXER_MUTEX();
    DPF_ENTER();

    ASSERT(m_pKeDest);

    ioparams.pKeDest = m_pKeDest;
    cbReturned = 0;
    
    fOk = DeviceIoControl(g_hDsVxd,
                          DSVXD_IOCTL_MixDest_GetFrequency,
                          &ioparams,
                          sizeof(ioparams),
                          &nFrequency,
                          sizeof(nFrequency),
                          &cbReturned,
                          NULL);

    if (!fOk) DPF(DPFLVL_ERROR, "DSVXD_IOCTL_MixDest_GetFrequency failed!");
    ASSERT(cbReturned == sizeof(nFrequency));

    LEAVE_MIXER_MUTEX();
    return nFrequency;
}

#endif // NOVXD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\iirlut.h ===
/***************************************************************************
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iirlut.h
 *  Content:    DirectSound3D IIR algorithm look up table
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/22/98    jstokes  Created
 *
 ***************************************************************************/

#if !defined(LUT_HEADER)
#define LUT_HEADER
#pragma once

// Project-specific INCLUDEs
#include "dsoundi.h"
#include "vmaxhead.h"
#include "vmaxcoef.h"

#ifdef __cplusplus

// ---------------------------------------------------------------------------
// Typedefs

typedef FLOAT TCanonicalCoeffs[KSDS3D_COEFF_COUNT][NumBiquadsToNumCanonicalCoeffsHalf(CbyMaxBiquads)];


// ---------------------------------------------------------------------------
// VMAx 3D Interactive look-up table (LUT)

class CIirLut 
{
public:
    CIirLut();
    ~CIirLut();
    
    HRESULT Initialize(KSDS3D_HRTF_COEFF_FORMAT, KSDS3D_HRTF_FILTER_QUALITY, DWORD);

    ULONG GetMaxBiquadCoeffs() const;
    const PVOID GetCoeffs(const D3DVALUE, const D3DVALUE, const ESampleRate, const EFilter, PUINT);
    BOOL HaveCoeffsChanged(const D3DVALUE, const D3DVALUE, const ESampleRate, const EFilter);
    BOOL GetNegativeAzimuth() const;
    BOOL GetPreviousNegativeAzimuth() const;
    BOOL GetZeroAzimuthIndex() const;
    BOOL GetPreviousZeroAzimuthIndex() const;
    BOOL GetZeroAzimuthTransition() const;
    BOOL GetSymmetricalZeroAzimuthTransition() const;
    KSDS3D_HRTF_FILTER_QUALITY GetCoeffQuality() const;
    KSDS3D_HRTF_COEFF_FORMAT GetCoeffFormat() const;
    DWORD GetFilterTransitionMuteLength(const KSDS3D_HRTF_FILTER_QUALITY, const ESampleRate);
    DWORD GetFilterOverlapBufferLength(const KSDS3D_HRTF_FILTER_QUALITY, const ESampleRate);
    DWORD GetOutputOverlapBufferLength(const ESampleRate);
    HRESULT DsFrequencyToIirSampleRate(DWORD,ESampleRate*);

private:
    // Prohibit copy construction and assignment
    CIirLut(const CIirLut&);
    CIirLut& operator=(const CIirLut&);

    HRESULT ConvertDsSpeakerConfig(DWORD,ESpeakerConfig*);
    VOID InitData();
    VOID AnglesToIndices(D3DVALUE, D3DVALUE, INT&, UINT&);
    BOOL BiquadToCanonical(const FLOAT[], const UINT, TCanonicalCoeffs&);
    VOID FreeCoefficientMemory();
    DWORD GetBiquadCoeffOffset(const KSDS3D_HRTF_FILTER_QUALITY, const ESpeakerConfig, const ESampleRate, const UINT, const UINT, const BOOL);
    PFLOAT m_pfCoeffs;
    PSHORT m_psCoeffs;
    UINT m_uiPreviousElevationIndex;

    UINT m_aauiNumBiquadCoeffs[KSDS3D_FILTER_QUALITY_COUNT][espeakerconfigCount];
    UINT m_aauiNumCanonicalCoeffs[KSDS3D_FILTER_QUALITY_COUNT][espeakerconfigCount];
    UINT m_aauiNumPreviousElevationFilters[esamplerateCount][CuiNumElevationBins];

    UINT m_auiPreviousElevationIndex[efilterCount];
    int m_aiPreviousAzimuthIndex[efilterCount];
    ESampleRate m_aePreviousSampleRate[efilterCount];
    
    UINT m_uiNumElevationFilters[CuiNumElevationBins];
//    UINT m_uiTotalElevationFilters;

    KSDS3D_HRTF_COEFF_FORMAT m_eCoeffFormat;
    KSDS3D_HRTF_FILTER_QUALITY m_eCoeffQuality;
    ESpeakerConfig m_eSpeakerConfig;
    BYTE m_byMaxBiquadCoeffs;              
    BOOL m_bNegativeAzimuth;
    BOOL m_bPreviousNegativeAzimuth;
    BOOL m_bZeroAzimuthIndex;
    BOOL m_bPreviousZeroAzimuthIndex;
    BOOL m_bZeroAzimuthTransition;
    BOOL m_bSymmetricalZeroAzimuthTransition;

    HINSTANCE  m_hLutFile;
    HANDLE m_hLutFileMapping;
    PFLOAT m_pfLut;


};

// ---------------------------------------------------------------------------
// Include inline definitions inline in release version

#ifndef DEBUG
#include "iirlut.inl"
#endif

#endif // __cplusplus

#endif

// End of LUT.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\ks3d.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ks3d.cpp
 *  Content:    WDM/CSA 3D object class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/6/98      dereks  Created.
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifdef NOKS
#error ks3d.cpp being built with NOKS defined
#endif // NOKS

#include "dsoundi.h"


/***************************************************************************
 *
 *  CKs3dListener
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKs3dListener::CKs3dListener"

CKs3dListener::CKs3dListener(void)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKs3dListener);

    // Initialize defaults
    m_dwSpeakerConfig = DSSPEAKER_DEFAULT;
    m_fAllocated = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKs3dListener
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKs3dListener::~CKs3dListener"

CKs3dListener::~CKs3dListener(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKs3dListener);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  UpdateAllObjects
 *
 *  Description:
 *      Updates all objects.
 *
 *  Arguments:
 *      DWORD [in]: parameters flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKs3dListener::UpdateAllObjects"

HRESULT CKs3dListener::UpdateAllObjects
(
    DWORD                   dwListener
)
{
    BOOL                    fTrue   = TRUE;
    BOOL                    fFalse  = FALSE;
    HRESULT                 hr;

    DPF_ENTER();

    // Place the driver into batch mode
    SetProperty
    (
        KSPROPSETID_DirectSound3DListener,
        KSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
        &fTrue,
        sizeof(fTrue)
    );

    // Update all objects
    hr =
        C3dListener::UpdateAllObjects
        (
            dwListener
        );

    // Remove the driver from batch mode
    SetProperty
    (
        KSPROPSETID_DirectSound3DListener,
        KSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
        &fFalse,
        sizeof(fFalse)
    );

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetProperty
 *
 *  Description:
 *      Sets a property on the object's 3D node.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKs3dListener::SetProperty"

HRESULT
CKs3dListener::SetProperty
(
    REFGUID                     guidPropertySet,
    ULONG                       ulPropertyId,
    LPCVOID                     pvData,
    ULONG                       cbData
)
{
    CNode<CKsHw3dObject *> *    pNode   = m_lstHw3dObjects.GetListHead();
    HRESULT                     hr      = DS_OK;

    DPF_ENTER();

    if(pNode)
    {
        hr =
            pNode->m_data->SetProperty
            (
                guidPropertySet,
                ulPropertyId,
                pvData,
                cbData
            );
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CKsItd3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKs3dListener * [in]: listener pointer.
 *      CKsSecondaryRenderWaveBuffer * [in]: owning buffer object.
 *      DWORD [in]: buffer frequency.
 *      HANDLE [in]: pin handle.
 *      BOOL [in]: TRUE to mute at max distance.
 *      ULONG [in]: ITD 3D node id.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsItd3dObject::CKsItd3dObject"

CKsItd3dObject::CKsItd3dObject
(
    CKs3dListener *                 pListener,
    BOOL                            fMuteAtMaxDistance,
    BOOL                            fDopplerEnabled,
    DWORD                           dwFrequency,
    CKsSecondaryRenderWaveBuffer *  pBuffer,
    HANDLE                          hPin,
    ULONG                           ulNodeId
)
    : CItd3dObject(pListener, fMuteAtMaxDistance, fDopplerEnabled, dwFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsItd3dObject);

    // Intialize defaults
    m_pBuffer = pBuffer;
    m_hPin = hPin;
    m_ulNodeId = ulNodeId;
    m_fMute = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsItd3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsItd3dObject::~CKsItd3dObject"

CKsItd3dObject::~CKsItd3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsItd3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Commit3dChanges
 *
 *  Description:
 *      Commits 3D data to the device
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsItd3dObject::Commit3dChanges"

HRESULT CKsItd3dObject::Commit3dChanges(void)
{
    KSDS3D_ITD_PARAMS_MSG     Params;
    HRESULT                   hr = DS_OK;

    DPF_ENTER();

    if(IsAtMaxDistance())
    {
        if(!m_fMute)
        {
            m_pBuffer->SetMute(TRUE);
        }
        m_fMute = TRUE;
    }
    else
    {
        if(m_fMute)
        {
            m_pBuffer->SetMute(FALSE);
            m_fMute = FALSE;
        }

        Params.Enabled = !(DS3DMODE_DISABLE == m_opCurrent.dwMode);
        Params.Reserved = 0;

        // Convert the OBJECT_ITD_CONTEXT structure to the KSDS3D_ITD3D_PARAMS
        // used by Kmixer.
        Params.LeftParams.Channel = 0;
        Params.RightParams.Channel = 1;

        CvtContext(&m_ofcLeft, &Params.LeftParams);
        CvtContext(&m_ofcRight, &Params.RightParams);

        // Apply the settings
        hr =
            KsSetNodeProperty
            (
                m_hPin,
                KSPROPSETID_Itd3d,
                KSPROPERTY_ITD3D_PARAMS,
                m_ulNodeId,
                &Params,
                sizeof(Params)
            );

        if(SUCCEEDED(hr) && m_fDopplerEnabled)
        {
            if(DS3DMODE_DISABLE == m_opCurrent.dwMode)
            {
                hr = m_pBuffer->SetFrequency(m_dwUserFrequency, FALSE);
            }
            else
            {
                hr = m_pBuffer->SetFrequency(m_dwDopplerFrequency, TRUE);
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CvtContext
 *
 *  Description:
 *      Converts an OBJECT_ITD_CONTEXT to a KSDS3D_ITD3D_PARAMS.
 *
 *  Arguments:
 *      LPOBJECTFIRCONTEXT [in]: source.
 *      PITD_CONTEXT [out]: destination.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsItd3dObject::CvtContext"

void CKsItd3dObject::CvtContext
(
    LPOBJECT_ITD_CONTEXT    pSource,
    PKSDS3D_ITD_PARAMS      pDest
)
{
    DPF_ENTER();

    pDest->VolSmoothScale = pSource->flVolSmoothScale;

    pDest->TotalDryAttenuation =
        pSource->flPositionAttenuation *
        pSource->flConeAttenuation *
        pSource->flConeShadow *
        pSource->flPositionShadow;

    pDest->TotalWetAttenuation =
        pSource->flPositionAttenuation *
        pSource->flConeAttenuation *
        (1.0f - pSource->flConeShadow * pSource->flPositionShadow);

    pDest->SmoothFrequency = pSource->dwSmoothFreq;
    pDest->Delay = pSource->dwDelay;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Get3dOutputSampleRate
 *
 *  Description:
 *      Gets the sample rate of the final output.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsItd3dObject::Get3dOutputSampleRate"

DWORD CKsItd3dObject::Get3dOutputSampleRate(void)
{
    DWORD                   dwFrequency;

    DPF_ENTER();

    dwFrequency = m_pBuffer->m_vrbd.pwfxFormat->nSamplesPerSec;

    DPF_LEAVE(dwFrequency);

    return dwFrequency;
}


/***************************************************************************
 *
 *  CKsIir3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKs3dListener * [in]: listener pointer.
 *      CKsSecondaryRenderWaveBuffer * [in]: owning buffer object.
 *      DWORD [in]: buffer frequency.
 *      HANDLE [in]: pin handle.
 *      BOOL [in]: TRUE to mute at max distance.
 *      ULONG [in]: IIR 3D node id.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsIir3dObject::CKsIir3dObject"

CKsIir3dObject::CKsIir3dObject
(
    CKs3dListener *                 pListener,
    REFGUID                         guidAlgorithm,
    BOOL                            fMuteAtMaxDistance,
    BOOL                            fDopplerEnabled,
    DWORD                           dwFrequency,
    CKsSecondaryRenderWaveBuffer *  pBuffer,
    HANDLE                          hPin,
    ULONG                           ulNodeId,
    ULONG                           ulNodeCpuResources
)
    : CIir3dObject(pListener, guidAlgorithm, fMuteAtMaxDistance, fDopplerEnabled, dwFrequency)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsIir3dObject);

    // Intialize defaults
    m_pBuffer = pBuffer;
    m_hPin = hPin;
    m_ulNodeId = ulNodeId;
    m_ulNodeCpuResources = ulNodeCpuResources;
    m_fMute = FALSE;
    m_flPrevAttenuation = FLT_MAX;
    m_flPrevAttDistance = FLT_MAX;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsIir3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsIir3dObject::~CKsIir3dObject"

CKsIir3dObject::~CKsIir3dObject(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsIir3dObject);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsIir3dObject::Initialize"

HRESULT
CKsIir3dObject::Initialize(void)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(IS_HARDWARE_NODE(m_ulNodeCpuResources))
    {
        hr =
            KsSetNodeProperty
            (
                m_hPin,
                KSPROPSETID_Audio,
                KSPROPERTY_AUDIO_3D_INTERFACE,
                m_ulNodeId,
                &m_guid3dAlgorithm,
                sizeof(m_guid3dAlgorithm)
            );
    }

    if(SUCCEEDED(hr))
    {
        hr = CIir3dObject::Initialize();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Commit3dChanges
 *
 *  Description:
 *      Commits 3D data to the device
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsIir3dObject::Commit3dChanges"

HRESULT CKsIir3dObject::Commit3dChanges(void)
{
    PKSDS3D_HRTF_PARAMS_MSG pParams;
    HRESULT                 hr = DS_OK;
    UINT                    coeff;
    PULONG                  pNumCoeffs;
    ULONG                   StructSize;
    ULONG                   FilterSize;
    ULONG                   TotalSize;
    DWORD                   dwHalfNumCoeffs;

    DPF_ENTER();

    if(IsAtMaxDistance())
    {
        if(!m_fMute)
        {
            m_pBuffer->SetMute(TRUE);
        }
        m_fMute = TRUE;
    }
    else
    {
        if(m_fMute)
        {
            m_pBuffer->SetMute(FALSE);
            m_fMute = FALSE;
        }

        if( m_fUpdatedCoeffs
            || (m_flAttenuation != m_flPrevAttenuation)
            || (m_flAttDistance != m_flPrevAttDistance))
        {
            m_fUpdatedCoeffs = FALSE;
            m_flPrevAttenuation = m_flAttenuation;
            m_flPrevAttDistance = m_flAttDistance;

            StructSize = sizeof(KSDS3D_HRTF_PARAMS_MSG);

            FilterSize = 2*sizeof(ULONG) +
                   (m_ulNumSigmaCoeffs + m_ulNumDeltaCoeffs)*sizeof(FLOAT);

            TotalSize = StructSize + FilterSize;

            pParams = (PKSDS3D_HRTF_PARAMS_MSG)MEMALLOC_A(BYTE, TotalSize);

            hr = HRFROMP(pParams);
            if (SUCCEEDED(hr))
            {
            
    
                pParams->Size = StructSize;
                pParams->FilterSize = FilterSize;
                pParams->Enabled = !(DS3DMODE_DISABLE == m_opCurrent.dwMode);
                pParams->SwapChannels = m_fSwapChannels;
    
                if (m_pLut->GetZeroAzimuthTransition())
                {
                    pParams->CrossFadeOutput = TRUE;
                }
                else
                {
                    pParams->CrossFadeOutput = FALSE;
                }

                switch(m_pLut->GetCoeffFormat())
                {
                    case FLOAT_COEFF:
                    {
                        // Write Number of Sigma Coeffs
                        pNumCoeffs = (PULONG)(pParams + 1);
                        *pNumCoeffs = m_ulNumSigmaCoeffs;
    
                        // Write Sigma Coeffs
                        PFLOAT pCoeff = (PFLOAT)(pNumCoeffs + 1);
                        PFLOAT pSigmaCoeffs = (PFLOAT)m_pSigmaCoeffs;
        
                        ASSERT(m_ulNumSigmaCoeffs > 0);
                        ASSERT(m_ulNumSigmaCoeffs % 2);
    
                        dwHalfNumCoeffs = m_ulNumSigmaCoeffs / 2;
                        for(coeff=0; coeff<=dwHalfNumCoeffs; coeff++)
                        {
                            *pCoeff = m_flAttenuation * m_flAttDistance *(*pSigmaCoeffs);
                            pCoeff++;
                            pSigmaCoeffs++;
                        }
    
                        for(coeff=dwHalfNumCoeffs+1; coeff<m_ulNumSigmaCoeffs; coeff++)
                        {
                            *pCoeff = (*pSigmaCoeffs);
                            pCoeff++;
                            pSigmaCoeffs++;
                        }
    
                        // Write Number of Delta Coeffs
                        pNumCoeffs = (PULONG)(pCoeff);
                        *pNumCoeffs = m_ulNumDeltaCoeffs;
    
                        if(m_ulNumDeltaCoeffs > 0)
                        {
                            pParams->ZeroAzimuth = FALSE;
                        }
                        else
                        {
                            pParams->ZeroAzimuth = TRUE;
                        }
    
                        // Write Delta Coeffs
                        pCoeff = (PFLOAT)(pNumCoeffs + 1);
                        PFLOAT pDeltaCoeffs = (PFLOAT)m_pDeltaCoeffs;
    
                        if (m_ulNumDeltaCoeffs > 0)
                        {
                            ASSERT(m_ulNumDeltaCoeffs % 2);
                            dwHalfNumCoeffs = m_ulNumDeltaCoeffs / 2;
    
    
                            for(coeff=0; coeff<=dwHalfNumCoeffs; coeff++)
                            {
                               *pCoeff = m_flAttenuation * m_flAttDistance * (*pDeltaCoeffs);
                               pCoeff++;
                               pDeltaCoeffs++;
                            }
    
                            for(coeff=dwHalfNumCoeffs+1;coeff<m_ulNumDeltaCoeffs; coeff++)
                            {
                               *pCoeff = (*pDeltaCoeffs);
                               pCoeff++;
                           pDeltaCoeffs++;
                            }
                        }
    
                        break;
                    }

                    case SHORT_COEFF:
                    {
                        // Write Number of Sigma Coeffs
                        pNumCoeffs = (PULONG)(pParams + 1);
                        *pNumCoeffs = m_ulNumSigmaCoeffs;
    
                        // Write Sigma Coeffs
                        PSHORT pCoeff = (PSHORT)(pNumCoeffs + 1);
                        PSHORT pSigmaCoeffs = (PSHORT)m_pSigmaCoeffs;
    
                        for(coeff=0; coeff<m_ulNumSigmaCoeffs; coeff++)
                        {
                           *pCoeff = (*pSigmaCoeffs);
                           pCoeff++;
                           pSigmaCoeffs++;
                        }
    
                        // Write Sigma Gain
                        PSHORT pGain = (PSHORT)(pCoeff);
                        *pGain = (SHORT)(MAX_SHORT * m_flAttenuation * m_flAttDistance);
    
                        // Write Number of Delta Coeffs
                        pNumCoeffs = (PULONG)(pGain + 1);
                        *(UNALIGNED ULONG *)pNumCoeffs = m_ulNumDeltaCoeffs;
    
                        if(m_ulNumDeltaCoeffs > 0)
                        {
                            pParams->ZeroAzimuth = FALSE;
                        }
                        else
                        {
                            pParams->ZeroAzimuth = TRUE;
                        }

                        // Write Delta Coeffs
                        pCoeff = (PSHORT)(pNumCoeffs + 1);
                        PSHORT pDeltaCoeffs = (PSHORT)m_pDeltaCoeffs;
    
                        for(coeff=0; coeff<m_ulNumDeltaCoeffs; coeff++)
                        {
                           *pCoeff = (*pDeltaCoeffs);
                           pCoeff++;
                           pDeltaCoeffs++;
                        }   

                        // Write Delta Gain
                        pGain = (PSHORT)(pCoeff);
                        *pGain = (SHORT)(MAX_SHORT * m_flAttenuation * m_flAttDistance);
    
                        break;
                    }
    
                    default:
                    break;

                }

                // Apply the settings
                hr =
                    KsSetNodeProperty
                    (
                        m_hPin,
                        KSPROPSETID_Hrtf3d,
                        KSPROPERTY_HRTF3D_PARAMS,
                        m_ulNodeId,
                        pParams,
                        TotalSize
                    );


                MEMFREE(pParams);

            }
        }

        if(SUCCEEDED(hr) && m_fDopplerEnabled)
        {
            if(DS3DMODE_DISABLE == m_opCurrent.dwMode)
            {
                hr = m_pBuffer->SetFrequency(m_dwUserFrequency, FALSE);
            }
            else
            {
                hr = m_pBuffer->SetFrequency(m_dwDopplerFrequency, TRUE);
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetFilterMethodAndCoeffFormat
 *
 *  Description:
 *      Gets the required filter coefficient format from either
 *      the device or kmixer.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsIir3dObject::GetFilterMethodAndCoeffFormat"

HRESULT CKsIir3dObject::GetFilterMethodAndCoeffFormat
(
    KSDS3D_HRTF_FILTER_METHOD *     pFilterMethod,
    KSDS3D_HRTF_COEFF_FORMAT *      pCoeffFormat
)
{

    KSDS3D_HRTF_FILTER_FORMAT_MSG   FilterFormat;
    HRESULT                         hr;

    DPF_ENTER();

    hr =
        KsGetNodeProperty
        (
            m_hPin,
            KSPROPSETID_Hrtf3d,
            KSPROPERTY_HRTF3D_FILTER_FORMAT,
            m_ulNodeId,
            &FilterFormat,
            sizeof(KSDS3D_HRTF_FILTER_FORMAT_MSG)
        );

    if(SUCCEEDED(hr))
    {
        *pFilterMethod = FilterFormat.FilterMethod;
        *pCoeffFormat = FilterFormat.CoeffFormat;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  InitializeFilters
 *
 *  Description:
 *      Sets the maximum IIR filter size.  If the filter is Direct Form,
 *      the max size is the order of the filter ( numerator and denominator
 *      have equal order).  If the filter is Cascade Form, the max size
 *      is the maximum number of biquads.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsIir3dObject::InitializeFilters"

HRESULT CKsIir3dObject::InitializeFilters
(
    KSDS3D_HRTF_FILTER_QUALITY  Quality,
    FLOAT                       flSampleRate,
    ULONG                       ulMaxFilterSize,
    ULONG                       ulFilterTransientMuteLength,
    ULONG                       ulFilterOverlapBufferLength,
    ULONG                       ulOutputOverlapBufferLength
)
{
    KSDS3D_HRTF_INIT_MSG Msg;
    HRESULT hr;

    DPF_ENTER();

    // Apply the settings
    Msg.Quality = Quality;
    Msg.SampleRate = flSampleRate;
    Msg.MaxFilterSize = ulMaxFilterSize;
    Msg.FilterTransientMuteLength = ulFilterTransientMuteLength;
    Msg.FilterOverlapBufferLength = ulFilterOverlapBufferLength;
    Msg.OutputOverlapBufferLength = ulOutputOverlapBufferLength;
    Msg.Reserved = 0;

    hr =
        KsSetNodeProperty
        (
            m_hPin,
            KSPROPSETID_Hrtf3d,
            KSPROPERTY_HRTF3D_INITIALIZE,
            m_ulNodeId,
            &Msg,
            sizeof(KSDS3D_HRTF_INIT_MSG)
        );

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CKsHw3dObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKs3dListener * [in]: pointer to the owning listener.
 *      HANDLE [in]: pin handle.
 *      LPVOID [in]: instance identifier.
 *      ULONG [in]: device-specific 3D node id.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::CKsHw3dObject"

CKsHw3dObject::CKsHw3dObject
(
    CKs3dListener *         p3dListener,
    BOOL                    fMuteAtMaxDistance,
    BOOL                    fDopplerEnabled,
    LPVOID                  pvInstance,
    ULONG                   ulNodeId,
    CKsSecondaryRenderWaveBuffer * pBuffer
)
    : CHw3dObject(p3dListener, fMuteAtMaxDistance, fDopplerEnabled)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsHw3dObject);

    m_pKsListener = p3dListener;
    m_pvInstance = pvInstance;
    m_ulNodeId = ulNodeId;
    m_pBuffer = pBuffer;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsHw3dObject
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::~CKsHw3dObject"

CKsHw3dObject::~CKsHw3dObject
(
    void
)
{
    BOOL                    fAlloc  = FALSE;
    HRESULT                 hr;

    DPF_ENTER();
    DPF_DESTRUCT(CKsHw3dObject);

    m_pKsListener->m_lstHw3dObjects.RemoveDataFromList(this);

    // If we're the last HW object to leave, we need to tell the
    // driver to free its listener data.
    if(m_pKsListener->m_fAllocated && !m_pKsListener->m_lstHw3dObjects.GetNodeCount())
    {
        hr =
            SetProperty
            (
                KSPROPSETID_DirectSound3DListener,
                KSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION,
                &fAlloc,
                sizeof(fAlloc)
            );

        if(SUCCEEDED(hr))
        {
            m_pKsListener->m_fAllocated = FALSE;
        }
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::Initialize"

HRESULT
CKsHw3dObject::Initialize
(
    void
)
{
    BOOL                    fAlloc  = TRUE;
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    // If we're the first object being added to the listener's world,
    // we need to tell the driver to allocate the listener.
    if(!m_pKsListener->m_fAllocated)
    {
        hr =
            SetProperty
            (
                KSPROPSETID_DirectSound3DListener,
                KSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION,
                &fAlloc,
                sizeof(fAlloc)
            );

        if(SUCCEEDED(hr))
        {
            m_pKsListener->m_fAllocated = TRUE;
        }
    }

    // Join the listener's world
    if(SUCCEEDED(hr))
    {
        hr = HRFROMP(m_pKsListener->m_lstHw3dObjects.AddNodeToList(this));
    }

    // Initialize the base class
    if(SUCCEEDED(hr))
    {
        hr = C3dObject::Initialize();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Recalc
 *
 *  Description:
 *      Recalculates and applies the object's data based on changed object
 *      or listener valiues.
 *
 *  Arguments:
 *      DWORD [in]: changed listener settings.
 *      DWORD [in]: changed object settings.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::Recalc"

HRESULT
CKsHw3dObject::Recalc
(
    DWORD                       dwListener,
    DWORD                       dwObject
)
{
    CNode<CKsHw3dObject *> *    pNode   = m_pKsListener->m_lstHw3dObjects.GetListHead();
    HRESULT                     hr      = DS_OK;

    DPF_ENTER();

    // Are we the 3D object that's responsible for setting listener parameters
    // and speaker config?  The first HW 3D object in the list is in charge of
    // that.
    if(dwListener && this == pNode->m_data)
    {
        hr = RecalcListener(dwListener);
    }

    if(SUCCEEDED(hr) && dwObject)
    {
        hr = RecalcObject(dwObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RecalcListener
 *
 *  Description:
 *      Recalculates and applies the object's data based on changed object
 *      or listener valiues.
 *
 *  Arguments:
 *      DWORD [in]: changed listener settings.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::RecalcListener"

HRESULT
CKsHw3dObject::RecalcListener
(
    DWORD                   dwListener
)
{
    HRESULT                 hr                          = DS_OK;
    DS3DLISTENER            ds3dl;
    KSDS3D_LISTENER_ALL     Ks3dListener;

    DPF_ENTER();

    if(dwListener & DS3DPARAM_LISTENER_PARAMMASK)
    {
        InitStruct(&ds3dl, sizeof(ds3dl));

        hr = m_pListener->GetAllParameters(&ds3dl);

        if(SUCCEEDED(hr))
        {
            COPY_VECTOR(Ks3dListener.Position, ds3dl.vPosition);
            COPY_VECTOR(Ks3dListener.Velocity, ds3dl.vVelocity);
            COPY_VECTOR(Ks3dListener.OrientFront, ds3dl.vOrientFront);
            COPY_VECTOR(Ks3dListener.OrientTop, ds3dl.vOrientTop);

            Ks3dListener.DistanceFactor = ds3dl.flDistanceFactor;
            Ks3dListener.RolloffFactor = ds3dl.flRolloffFactor;
            Ks3dListener.DopplerFactor = ds3dl.flDopplerFactor;
        }

        if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_PARAMMASK) == DS3DPARAM_LISTENER_PARAMMASK)
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DListener,
                    KSPROPERTY_DIRECTSOUND3DLISTENER_ALL,
                    &Ks3dListener,
                    sizeof(Ks3dListener)
                );
        }
        else
        {
            if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_DISTANCEFACTOR))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_DirectSound3DListener,
                        KSPROPERTY_DIRECTSOUND3DLISTENER_DISTANCEFACTOR,
                        &Ks3dListener.DistanceFactor,
                        sizeof(Ks3dListener.DistanceFactor)
                    );
            }

            if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_DOPPLERFACTOR))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_DirectSound3DListener,
                        KSPROPERTY_DIRECTSOUND3DLISTENER_DOPPLERFACTOR,
                        &Ks3dListener.DopplerFactor,
                        sizeof(Ks3dListener.DopplerFactor)
                    );
            }

            if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_ROLLOFFFACTOR))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_DirectSound3DListener,
                        KSPROPERTY_DIRECTSOUND3DLISTENER_ROLLOFFFACTOR,
                        &Ks3dListener.RolloffFactor,
                        sizeof(Ks3dListener.RolloffFactor)
                    );
            }

            if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_ORIENTATION))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_DirectSound3DListener,
                        KSPROPERTY_DIRECTSOUND3DLISTENER_ORIENTATION,
                        &Ks3dListener.OrientFront,
                        sizeof(Ks3dListener.OrientFront) + sizeof(Ks3dListener.OrientTop)
                    );
            }

            if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_POSITION))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_DirectSound3DListener,
                        KSPROPERTY_DIRECTSOUND3DLISTENER_POSITION,
                        &Ks3dListener.Position,
                        sizeof(Ks3dListener.Position)
                    );
            }

            if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_VELOCITY))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_DirectSound3DListener,
                        KSPROPERTY_DIRECTSOUND3DLISTENER_VELOCITY,
                        &Ks3dListener.Velocity,
                        sizeof(Ks3dListener.Velocity)
                    );
            }
        }
    }

    // Now we send the CHANNEL_CONFIG and SPEAKER_GEOMETRY properties to our
    // pin's 3D node.  This is the old, traditional, barely-specified way of
    // informing the driver of speaker config changes.  There is now a new,
    // well-defined way to do this (namely, sending these two properties to
    // the DAC node on the filter before any pins are instantiated), but the
    // code below lives on for the benefit of "legacy" WDM drivers.

    if(SUCCEEDED(hr) && (dwListener & DS3DPARAM_LISTENER_SPEAKERCONFIG))
    {
        DWORD dwSpeakerConfig;
        hr = m_pListener->GetSpeakerConfig(&dwSpeakerConfig);

        if(SUCCEEDED(hr))
        {
            LONG KsSpeakerConfig;
            LONG KsStereoSpeakerGeometry;

            hr = DsSpeakerConfigToKsProperties(dwSpeakerConfig, &KsSpeakerConfig, &KsStereoSpeakerGeometry);

            if(SUCCEEDED(hr))
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_Audio,
                        KSPROPERTY_AUDIO_CHANNEL_CONFIG,
                        &KsSpeakerConfig,
                        sizeof KsSpeakerConfig
                    );
            }

            if(SUCCEEDED(hr) && KsSpeakerConfig == KSAUDIO_SPEAKER_STEREO)
            {
                hr =
                    SetProperty
                    (
                        KSPROPSETID_Audio,
                        KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
                        &KsStereoSpeakerGeometry,
                        sizeof KsStereoSpeakerGeometry
                    );
            }
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RecalcObject
 *
 *  Description:
 *      Recalculates and applies the object's data based on changed object
 *      or listener valiues.
 *
 *  Arguments:
 *      DWORD [in]: changed object settings.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::RecalcObject"

HRESULT
CKsHw3dObject::RecalcObject
(
    DWORD                   dwObject
)
{
    HRESULT                 hr          = DS_OK;
    KSDS3D_BUFFER_ALL       Ks3dBuffer;

    DPF_ENTER();

    COPY_VECTOR(Ks3dBuffer.Position, m_opCurrent.vPosition);
    COPY_VECTOR(Ks3dBuffer.Velocity, m_opCurrent.vVelocity);

    Ks3dBuffer.InsideConeAngle = m_opCurrent.dwInsideConeAngle;
    Ks3dBuffer.OutsideConeAngle = m_opCurrent.dwOutsideConeAngle;

    COPY_VECTOR(Ks3dBuffer.ConeOrientation, m_opCurrent.vConeOrientation);

    Ks3dBuffer.ConeOutsideVolume = m_opCurrent.lConeOutsideVolume;
    Ks3dBuffer.MinDistance = m_opCurrent.flMinDistance;
    Ks3dBuffer.MaxDistance = m_opCurrent.flMaxDistance;

    Ks3dBuffer.Mode = Ds3dModeToKs3dMode(m_opCurrent.dwMode);

    if((dwObject & DS3DPARAM_OBJECT_PARAMMASK) == DS3DPARAM_OBJECT_PARAMMASK)
    {
        hr =
            SetProperty
            (
                KSPROPSETID_DirectSound3DBuffer,
                KSPROPERTY_DIRECTSOUND3DBUFFER_ALL,
                &Ks3dBuffer,
                sizeof(Ks3dBuffer)
            );
    }
    else
    {
        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_CONEANGLES))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEANGLES,
                    &Ks3dBuffer.InsideConeAngle,
                    sizeof(Ks3dBuffer.InsideConeAngle) + sizeof(Ks3dBuffer.OutsideConeAngle)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_CONEORIENTATION))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEORIENTATION,
                    &Ks3dBuffer.ConeOrientation,
                    sizeof(Ks3dBuffer.ConeOrientation)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_CONEOUTSIDEVOLUME))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEOUTSIDEVOLUME,
                    &Ks3dBuffer.ConeOutsideVolume,
                    sizeof(Ks3dBuffer.ConeOutsideVolume)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_MAXDISTANCE))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_MAXDISTANCE,
                    &Ks3dBuffer.MaxDistance,
                    sizeof(Ks3dBuffer.MaxDistance)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_MINDISTANCE))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_MINDISTANCE,
                    &Ks3dBuffer.MinDistance,
                    sizeof(Ks3dBuffer.MinDistance)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_MODE))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_MODE,
                    &Ks3dBuffer.Mode,
                    sizeof(Ks3dBuffer.Mode)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_POSITION))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_POSITION,
                    &Ks3dBuffer.Position,
                    sizeof(Ks3dBuffer.Position)
                );
        }

        if(SUCCEEDED(hr) && (dwObject & DS3DPARAM_OBJECT_VELOCITY))
        {
            hr =
                SetProperty
                (
                    KSPROPSETID_DirectSound3DBuffer,
                    KSPROPERTY_DIRECTSOUND3DBUFFER_VELOCITY,
                    &Ks3dBuffer.Velocity,
                    sizeof(Ks3dBuffer.Velocity)
                );
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetProperty
 *
 *  Description:
 *      Sets a property on the object's 3D node.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property data.
 *      ULONG [in]: property data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsHw3dObject::SetProperty"

HRESULT
CKsHw3dObject::SetProperty
(
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPCVOID                 pvData,
    ULONG                   cbData
)
{
    HRESULT                 hr  = DSERR_GENERIC;

    DPF_ENTER();

    if (m_pBuffer->m_pPin)
    {
        hr =
            KsSet3dNodeProperty
            (
                m_pBuffer->m_pPin->m_hPin,
                guidPropertySet,
                ulPropertyId,
                m_ulNodeId,
                m_pvInstance,
                (LPVOID)pvData,
                cbData
            );
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\ists.cpp ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include <windows.h>

/**************************************************************************

          Terminal Server helper functions

 **************************************************************************/

#define WINMM_CONSOLE_AUDIO_EVENT L"Global\\WinMMConsoleAudioEvent"

//
// Check if the Windows XP+ Personal Terminal Services feature is present
// (this enables both Remote Desktop/Assistance and Fast User Switching).
//
BOOL IsPersonalTerminalServicesEnabled(void)
{
    static BOOL fRet;
    static BOOL fVerified = FALSE;

    if (!fVerified)
    {
        DWORDLONG dwlConditionMask = 0;
        OSVERSIONINFOEX osVersionInfo;

        RtlZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
        osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        osVersionInfo.wProductType = VER_NT_WORKSTATION;
        osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;

        VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
        VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

        fRet = VerifyVersionInfo(&osVersionInfo, VER_PRODUCT_TYPE | VER_SUITENAME, dwlConditionMask);

        fVerified = TRUE;
    }

    return fRet;
}

//
// Check if we're in a remote session but playing audio directly to the console
// [Leave at remote machine set from the TS client in Local resources tab].
//
BOOL IsTsConsoleAudioEnabled(void)
{
    BOOL fRemoteConsoleAudio = FALSE;
    static HANDLE hConsoleAudioEvent = NULL;

    if (NtCurrentPeb()->SessionId == 0 || IsPersonalTerminalServicesEnabled())
    {
        if (hConsoleAudioEvent == NULL)
            hConsoleAudioEvent = OpenEvent(SYNCHRONIZE, FALSE, WINMM_CONSOLE_AUDIO_EVENT);

        if (hConsoleAudioEvent != NULL)
        {
            DWORD status = WaitForSingleObject(hConsoleAudioEvent, 0);
            if (status == WAIT_OBJECT_0)
                fRemoteConsoleAudio = TRUE;
        }
    }

    return fRemoteConsoleAudio;
}

//
// Returns TRUE if we are not on the console AND not playing audio on the console
//
BOOL IsRedirectedTSAudio(void)
{
    BOOL fOnConsole = (USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId);
    return !fOnConsole && !IsTsConsoleAudioEnabled();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\iirlut.inl ===
/***************************************************************************
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iirlut.inl
 *  Content:    DirectSound3D IIR algorithm look up table
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  4/22/98    jstokes  Created
 *
 ***************************************************************************/

#if !defined(LUT_INLINE)
#define LUT_INLINE
#pragma once

// ---------------------------------------------------------------------------
// Make sure inlines are out-of-line in debug version

#if !defined(_DEBUG)
#define INLINE _inline
#else
#define INLINE
#endif


/***************************************************************************
 *
 *  ~CIirLut
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CIirLut:~CIirLut"

INLINE CIirLut::~CIirLut()
{
    DPF_ENTER();
    DPF_DESTRUCT(CIirLut);

    // Free owned objects
    FreeLibrary(m_hLutFile);
    FreeCoefficientMemory();

    DPF_LEAVE_VOID();
}

// Get maximum filter length
INLINE ULONG CIirLut::GetMaxBiquadCoeffs() const
{
    return (ULONG)m_byMaxBiquadCoeffs;
}

// Get negative azimuth flag
INLINE BOOL CIirLut::GetNegativeAzimuth() const
{
    return m_bNegativeAzimuth;
}

// Get previous negative azimuth flag
INLINE BOOL CIirLut::GetPreviousNegativeAzimuth() const
{
    return m_bPreviousNegativeAzimuth;
}

// Get zero azimuth index flag
INLINE BOOL CIirLut::GetZeroAzimuthIndex() const
{
    return m_bZeroAzimuthIndex;
}

// Get previous zero azimuth index flag
INLINE BOOL CIirLut::GetPreviousZeroAzimuthIndex() const
{
    return m_bPreviousZeroAzimuthIndex;
}

// Get zero azimuth transition flag
INLINE BOOL CIirLut::GetZeroAzimuthTransition() const
{
    return m_bZeroAzimuthTransition;
}

// Get symmetrical zero azimuth transition flag
INLINE BOOL CIirLut::GetSymmetricalZeroAzimuthTransition() const
{
    return m_bSymmetricalZeroAzimuthTransition;
}

// Get zero azimuth index flag
INLINE KSDS3D_HRTF_COEFF_FORMAT CIirLut::GetCoeffFormat() const
{
    return m_eCoeffFormat;
}

// Get biquad coefficient offset
INLINE DWORD CIirLut::GetBiquadCoeffOffset
(
    const KSDS3D_HRTF_FILTER_QUALITY CeFilterQuality, 
    const ESpeakerConfig CeSpeakerConfig, 
    const ESampleRate CeSampleRate, 
    const UINT CuiElevationIndex, 
    const UINT CuiAzimuthIndex, 
    const BOOL CbTableLookup
)
{
    ASSERT(CeFilterQuality >= 0 && CeFilterQuality < KSDS3D_FILTER_QUALITY_COUNT);
    ASSERT(CeSpeakerConfig >= 0 && CeSpeakerConfig < espeakerconfigCount);
    ASSERT(CeSampleRate >= 0 && CeSampleRate < esamplerateCount);
    ASSERT(CuiElevationIndex >= 0 && CuiElevationIndex < CuiNumElevationBins);
    ASSERT(CuiAzimuthIndex >= 0 && CuiAzimuthIndex < CauiNumAzimuthBins[CuiElevationIndex]);
    
    DWORD dwOffset(CaaaaawBiquadCoeffOffset[CeFilterQuality][CeSpeakerConfig][CeSampleRate][CuiElevationIndex][CuiAzimuthIndex]);
    if (CbTableLookup == TRUE)
        dwOffset += CaadwBiquadCoeffOffsetOffset[CeFilterQuality][CeSpeakerConfig];
    return dwOffset * ebiquadcoefftypeCount;
}

// Get biquad coefficient offset
INLINE DWORD CIirLut::GetFilterTransitionMuteLength
(
    const KSDS3D_HRTF_FILTER_QUALITY CeFilterQuality, 
    const ESampleRate CeSampleRate
)
{
    ASSERT(CeFilterQuality >= 0 && CeFilterQuality < KSDS3D_FILTER_QUALITY_COUNT);
    ASSERT(CeSampleRate >= 0 && CeSampleRate < esamplerateCount);
    
    return CaastFilterMuteLength[CeFilterQuality][CeSampleRate];
}

// Get biquad coefficient offset
INLINE DWORD CIirLut::GetFilterOverlapBufferLength
(
    const KSDS3D_HRTF_FILTER_QUALITY CeFilterQuality, 
    const ESampleRate CeSampleRate
)
{
    ASSERT(CeFilterQuality >= 0 && CeFilterQuality < KSDS3D_FILTER_QUALITY_COUNT);
    ASSERT(CeSampleRate >= 0 && CeSampleRate < esamplerateCount);
    
    return CaastFilterOverlapLength[CeFilterQuality][CeSampleRate];
}

// Get biquad coefficient offset
INLINE DWORD CIirLut::GetOutputOverlapBufferLength
( 
    const ESampleRate CeSampleRate
)
{
    ASSERT(CeSampleRate >= 0 && CeSampleRate < esamplerateCount);
    
    return CastOutputOverlapLength[CeSampleRate];
}

#endif

// End of LUT.INL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\kscap.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       kscap.cpp
 *  Content:    WDM/CSA Virtual Audio Device audio capture class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/6/98      dereks  Created.
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifdef NOKS
#error kscap.cpp being built with NOKS defined
#endif

#include "dsoundi.h"


/***************************************************************************
 *
 *  CKsCaptureDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::CKsCaptureDevice"

CKsCaptureDevice::CKsCaptureDevice()
    : CCaptureDevice(VAD_DEVICETYPE_KSCAPTURE),
      CKsDevice(VAD_DEVICETYPE_KSCAPTURE)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsCaptureDevice);

    m_paTopologyInformation = NULL;
    m_fSplitter = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsCaptureDevice
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::~CKsCaptureDevice"

CKsCaptureDevice::~CKsCaptureDevice()
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsCaptureDevice);

    MEMFREE(m_paTopologyInformation);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the device.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: driver description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::Initialize"

HRESULT CKsCaptureDevice::Initialize(CDeviceDescription* pDesc)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    ASSERT(CDevice::m_vdtDeviceType == pDesc->m_vdtDeviceType);
    ASSERT(CKsDevice::m_vdtKsDevType == pDesc->m_vdtDeviceType);

    // Initialize the base classes
    hr = CKsDevice::Initialize(pDesc);

    if(SUCCEEDED(hr))
    {
        hr = CCaptureDevice::Initialize(pDesc);
    }

    // Get topology information
    if(SUCCEEDED(hr))
    {
        m_paTopologyInformation = MEMALLOC_A(KSCDTOPOLOGY, m_ulPinCount);
        hr = HRFROMP(m_paTopologyInformation);
    }

    for(ULONG i = 0; i < m_ulValidPinCount && SUCCEEDED(hr); ++i)
    {
        hr = GetTopologyInformation(m_paTopologies[m_pulValidPins[i]],
                                    &m_paTopologyInformation[m_pulValidPins[i]]);
    }

    m_fSplitter = g_pDsAdmin->IsCaptureSplitterAvailable();

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCCAPS structure with the capabilities of the device.
 *
 *  Arguments:
 *      LPDSCCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::GetCaps"

HRESULT CKsCaptureDevice::GetCaps
(
    LPDSCCAPS               pCaps
)
{
    HRESULT                 hr                  = DS_OK;
    KSDATARANGE_AUDIO       DataRange;
    KSDATARANGE_AUDIO       AggregateDataRange;
    PKSDATARANGE_AUDIO      pDataRange;

    DPF_ENTER();

    ASSERT(sizeof(*pCaps) == pCaps->dwSize);

    ZeroMemory(&AggregateDataRange, sizeof(AggregateDataRange));

    pDataRange = &AggregateDataRange;

    // Get the audio data ranges and number of pins for all valid pin IDs
    for(ULONG i = 0; i < m_ulValidPinCount; ++i)
    {
        // We're only looking for hardware pins
        if (FAILED(ValidatePinCaps(m_pulValidPins[i], DSCBCAPS_LOCHARDWARE)))
        {
            continue;
        }

        // Get audio datarange
        hr = KsGetPinPcmAudioDataRange(m_hDevice, m_pulValidPins[i], pDataRange, TRUE);

        if(FAILED(hr))
        {
            continue;
        }

        if (&AggregateDataRange == pDataRange)
        {
            pDataRange = &DataRange;
        }
        else
        {
            KsAggregatePinAudioDataRange(pDataRange, &AggregateDataRange);
        }
    }

    // Fill out caps structure
    if(SUCCEEDED(hr))
    {
        ZeroMemoryOffset(pCaps, pCaps->dwSize, sizeof(pCaps->dwSize));

        // Is the splitter installed?
        pCaps->dwFlags = m_fSplitter ? DSCCAPS_MULTIPLECAPTURE : 0;

        pCaps->dwFormats = KsGetSupportedFormats(&AggregateDataRange);
        pCaps->dwChannels = AggregateDataRange.MaximumChannels;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CreateBuffer
 *
 *  Description:
 *      Creates a wave buffer.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      DWORD [in]: buffer size, in bytes.
 *      LPWAVEFORMATEX [in]: buffer format.
 *      LPVOID [in]: instance data
 *      CCaptureWaveBuffer ** [out]: receives pointer to new wave
 *                                           buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::CreateBuffer"

HRESULT CKsCaptureDevice::CreateBuffer
(
    DWORD                           dwFlags,
    DWORD                           dwBufferBytes,
    LPCWAVEFORMATEX                 pwfxFormat,
    CCaptureEffectChain *           pFXChain,
    LPVOID                          pvInstance,
    CCaptureWaveBuffer **           ppBuffer
)
{
    CKsCaptureWaveBuffer *          pBuffer = NULL;
    HRESULT                         hr      = DS_OK;

    DPF_ENTER();

    #pragma warning(disable:4530)  // Disable the nag about compiling with -GX
    try
    {
        pBuffer = NEW(CKsCaptureWaveBuffer(this));
    }
    catch (...)
    {
        // This exception handler is silly, since it makes us leak the memory
        // allocated for CKsCaptureWaveBuffer above (which wasn't assigned to
        // pBuffer yet), and possibly also m_csSS and m_cs, which is exactly
        // what we don't want to do if we're low on memory in the first place.
        //
        // But InitializeCriticalSection is supposed to be fixed in Blackcomb
        // not to throw exceptions any more, so we can live with this for now.

        ASSERT(pBuffer == NULL);
        ASSERT(!"InitializeCriticalSection() threw an exception");
    }
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(dwFlags, dwBufferBytes, pwfxFormat, pFXChain);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CreateCapturePin
 *
 *  Description:
 *      Creates a pin.
 *
 *  Arguments:
 *      ULONG [in]: pin ID.
 *      LPWAVEFORMATEX [in]: pin format.
 *      LPHANDLE [out]: receives pin handle.
 *      PULONG [out]: receives pin ID.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::CreateCapturePin"

HRESULT
CKsCaptureDevice::CreateCapturePin
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    CCaptureEffectChain *   pFXChain,
    LPHANDLE                phPin,
    PULONG                  pulPinId
)
{
    PKSAUDIOPINDESC         pPinDesc    = NULL;
    ULONG                   ulNodeId    = NODE_UNINITIALIZED;
    HRESULT                 hr          = DSERR_NODRIVER;
    HANDLE                  hPin        = NULL;
    ULONG                   i;
    DPF_ENTER();

    // If no pin ID was specified, we'll try each pin ID until one succeeds
    if (-1 == ulPinId)
    {
        hr = DSERR_NODRIVER;
        for(i = 0; i < m_ulValidPinCount && FAILED(hr); ++i)
            hr = CreateCapturePin(m_pulValidPins[i], dwFlags, pwfxFormat, pFXChain, phPin, pulPinId);
    }
    else
    {
        // Validate that the pin ID is capable of creating this pin
        hr = ValidatePinCaps(ulPinId, dwFlags);

        if(SUCCEEDED(hr) && pFXChain)
        {
            // Validate that the pin ID is capable of creating this pin
            hr = m_paTopologies[ulPinId]->FindCapturePinFromEffectChain(NULL, NULL, pFXChain, pFXChain->GetFxCount()-1);
        }

        if(SUCCEEDED(hr) && pFXChain)
        {
            // Initialize the effect flags for the device
            i = 0;
            CNode<CCaptureEffect*>* pFxNode = pFXChain->m_fxList.GetListHead();

            while(SUCCEEDED(hr) && i<pFXChain->GetFxCount())
            {
                ulNodeId = pFxNode->m_data->m_ksNode.NodeId;

                if(IS_VALID_NODE(ulNodeId))
                {
                    if(SUCCEEDED(hr))
                    {
                        hr = KsSysAudioSelectGraph(m_hDevice, ulPinId, ulNodeId);

                        if(FAILED(hr))
                        {
                            DPF(DPFLVL_ERROR, "Unable to set SysAudio device instance");
                        }
                    }
                }
                pFxNode = pFxNode->m_pNext;
                i++;
            }
        }

        // Build the pin description
        if(SUCCEEDED(hr))
        {
            hr = KsBuildCapturePinDescription(ulPinId, pwfxFormat, &pPinDesc);
        }

        // Create the pin
        if(SUCCEEDED(hr))
        {
            hr = CreatePin(&pPinDesc->Connect, GENERIC_READ, KSSTATE_STOP, &hPin);
        }

        if(SUCCEEDED(hr) && pFXChain)
        {
            // Enable the effects in the kernel
            i = 0;
            CNode<CCaptureEffect*>* pFxNode = pFXChain->m_fxList.GetListHead();

            while(SUCCEEDED(hr) && i<pFXChain->GetFxCount())
            {
                ulNodeId = pFxNode->m_data->m_ksNode.NodeId;

                if(IS_VALID_NODE(ulNodeId))
                {
                    hr = pFxNode->m_data->m_pDMOProxy->InitializeNode(hPin, ulNodeId);

                    if(SUCCEEDED(hr))
                    {
                        hr = KsEnableTopologyNode(hPin, ulNodeId, TRUE);
                    }

                    if(SUCCEEDED(hr))
                    {
                        if(pFxNode->m_data->m_ksNode.CpuResources == KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU)
                        {
                            pFxNode->m_data->m_fxStatus = DSCFXR_LOCHARDWARE;
                        }
                        else
                        {
                            pFxNode->m_data->m_fxStatus = DSCFXR_LOCSOFTWARE;
                        }
                    }
                    else
                    {
                        DPF(DPFLVL_ERROR, "Unable to enable topology node %d", ulNodeId);
                    }
                }
                pFxNode = pFxNode->m_pNext;
                i++;
            }
        }

        // Transition the pin to the pause state
        if(SUCCEEDED(hr))
        {
            hr = KsTransitionState(hPin, KSSTATE_STOP, KSSTATE_PAUSE);
        }

        // Success
        if(SUCCEEDED(hr))
        {
            *phPin = hPin;

            if(pulPinId)
            {
                *pulPinId = pPinDesc->Connect.PinId;
            }
        }
        else
        {
            CLOSE_HANDLE(hPin);
        }

        // Clean up
        MEMFREE(pPinDesc);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetTopologyInformation
 *
 *  Description:
 *      Gets topology information.
 *
 *  Arguments:
 *      CKsDeviceTopology * [in]: topology object.
 *      PKSCDTOPOLOGY [out]: receives topology information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::GetTopologyInformation"

HRESULT
CKsCaptureDevice::GetTopologyInformation
(
    CKsTopology *           pTopology,
    PKSCDTOPOLOGY           pInfo
)
{
    PKSTOPOLOGY_CONNECTION  pSrcConnection;
    HRESULT                 hr;

    DPF_ENTER();

    // Find topology nodes
    pSrcConnection = pTopology->FindControlConnection(NULL, NULL, KSNODETYPE_SRC);

    // Fill in data about each node
    hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pSrcConnection), &pInfo->SrcNode);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  ValidatePinCaps
 *
 *  Description:
 *      Validates that certain capabilities of the pin are implemented.
 *
 *  Arguments:
 *      ULONG [in]: pin ID.
 *      DWORD [in]: buffer flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureDevice::ValidatePinCaps"

HRESULT
CKsCaptureDevice::ValidatePinCaps
(
    ULONG                   ulPinId,
    DWORD                   dwFlags
)
{
    ULONG                   ulInvalidCpuResources   = KSAUDIO_CPU_RESOURCES_UNINITIALIZED;
    HRESULT                 hr                      = DS_OK;

    DPF_ENTER();

    if(dwFlags & DSCBCAPS_LOCHARDWARE)
    {
        ulInvalidCpuResources = KSAUDIO_CPU_RESOURCES_HOST_CPU;
    }
    else if(dwFlags & DSCBCAPS_LOCSOFTWARE)
    {
        ulInvalidCpuResources = KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU;
    }

    // Check required SRC resources
    if(SUCCEEDED(hr) && KSAUDIO_CPU_RESOURCES_UNINITIALIZED != ulInvalidCpuResources)
    {
        if(ulInvalidCpuResources == m_paTopologyInformation[ulPinId].SrcNode.CpuResources)
        {
            hr = DSERR_INVALIDCALL;
        }

#if 0 // 4/25/00 jstokes, I added this code because it may be needed but I don't currently think so.
        if(SUCCEEDED(hr) && !IS_VALID_NODE(m_paTopologyInformation[ulPinId].SrcNode.NodeId))
        {
            hr = DSERR_CONTROLUNAVAIL;
        }
#endif // 0
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CKsCaptureWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKsRenderDevice * [in]: parent device.
 *      LPVOID [in]: buffer instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::CKsCaptureWaveBuffer"

CKsCaptureWaveBuffer::CKsCaptureWaveBuffer(
    CKsCaptureDevice *pKsDevice)
    : CCaptureWaveBuffer(pKsDevice)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsCaptureWaveBuffer);

    // Initialize defaults
    m_pKsDevice = pKsDevice;

    ASSERT(NULL == m_hPin);
    ASSERT(0 == m_dwState);
    ASSERT(0 == m_fdwSavedState);

    ASSERT(0 == m_dwFlags);

    ASSERT(NULL == m_pEmCaptureDevice);
    ASSERT(NULL == m_pEmCaptureWaveBuffer);

    ASSERT(NULL == m_rgpksio);
    ASSERT(0 == m_cksio);
    ASSERT(0 == m_iksioDone);
    ASSERT(0 == m_cksioDropped);

    ASSERT(NULL == m_pBuffer);
    ASSERT(NULL == m_pBufferMac);
    ASSERT(NULL == m_pBufferNext);
    ASSERT(0 == m_cbBuffer);
    ASSERT(0 == m_cbRecordChunk);
    ASSERT(0 == m_cLoops);

    ASSERT(0 == m_iNote);
    ASSERT(0 == m_cNotes);
    ASSERT(NULL == m_paNotes);
    ASSERT(NULL == m_pStopNote);

    ASSERT(NULL == m_pwfx);
    ASSERT(NULL == m_pFXChain);

#ifdef DEBUG
    ASSERT(NULL == m_hEventStop);
    ASSERT(m_cIrpsSubmitted == 0);
    ASSERT(m_cIrpsReturned == 0);
#endif

#ifdef SHARED
    ASSERT(NULL == m_hEventThread);
    ASSERT(NULL == m_hEventAck);
    ASSERT(NULL == m_hThread);
    ASSERT(0 == m_dwSetState);
    ASSERT(0 == m_hrReturn);

    InitializeCriticalSection(&m_csSS);
#endif // SHARED

    ASSERT(NULL == m_rgpCallbackEvent);

    // FIXME: Do we still need these critical sections, since the DLL mutex also
    // prevents the EventSignalCallback from interfering with the other methods?

    m_fCritSectsValid = FALSE;
    InitializeCriticalSection(&m_cs);
    InitializeCriticalSection(&m_csPN);
    m_fCritSectsValid = TRUE;
    m_fFirstSubmittedIrp = TRUE;
    m_PinState = KSSTATE_STOP;

    ASSERT(NULL == m_pBufferProcessed);
    ASSERT(0 == m_dwCaptureCur);
    ASSERT(0 == m_dwCaptureLast);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsCaptureWaveBuffer
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::~CKsCaptureWaveBuffer"

CKsCaptureWaveBuffer::~CKsCaptureWaveBuffer()
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsCaptureWaveBuffer);

    if (!m_fCritSectsValid)
    {
        return;
    }

    // Free the pin
    if(m_hPin)
    {
        // Stop the buffer
        SetState(VAD_BUFFERSTATE_STOPPED);

        // Free any leftover notifications
        FreeNotificationPositions();

        // Close the pin
        CloseHandle(m_hPin);
    }

#ifdef DEBUG
    DPF(DPFLVL_MOREINFO, "IRPs submitted=%lu, returned=%lu", m_cIrpsSubmitted, m_cIrpsReturned);
    ASSERT(m_cIrpsSubmitted == m_cIrpsReturned);
#endif

#ifdef SHARED

    if (m_hThread)
    {
        // Sending special code to terminate thread
        SetStateThread(TERMINATE_STATE_THREAD);

        CloseHandle(m_hThread);
        CloseHandle(m_hEventThread);
        CloseHandle(m_hEventAck);
        m_hEventAck     = NULL;
        m_hEventThread  = NULL;
        m_hThread       = NULL;
    }

    DeleteCriticalSection(&m_csSS);

#endif // SHARED

    if(m_rgpCallbackEvent)
    {
        for(LONG i = 0; i < m_cksio; ++i)
        {
            if(m_rgpCallbackEvent[i])
            {
                m_pKsDevice->m_pEventPool->FreeEvent(m_rgpCallbackEvent[i]);
            }
        }

        MEMFREE(m_rgpCallbackEvent);
    }

    // Allocated for focus aware support
    if (NULL != m_pwfx)
    {
        MEMFREE(m_pwfx);
    }

    RELEASE(m_pEmCaptureWaveBuffer);
    RELEASE(m_pEmCaptureDevice);

    // Free the overlapped IO data
    MEMFREE(m_rgpksio);

    m_fCritSectsValid = FALSE;
    DeleteCriticalSection(&m_csPN);
    DeleteCriticalSection(&m_cs);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the wave buffer object.  If this function fails, the
 *      object should be immediately deleted.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      DWORD [in]: buffer size, in bytes.
 *      LPWAVEFORMATEX [in]: buffer format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::Initialize"

HRESULT CKsCaptureWaveBuffer::Initialize
(
    DWORD                   dwFlags,
    DWORD                   dwBufferBytes,
    LPCWAVEFORMATEX         pwfxFormat,
    CCaptureEffectChain *   pFXChain
)
{
    DPF_ENTER();

    // Store the caps requested
    m_dwFlags = dwFlags;

    // Reset the First Submitted IRP flag.  Doing so will cause
    // the KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY flag to
    // be set on the first IRP submitted to the kernel.
    m_fFirstSubmittedIrp = TRUE;

    // Initialize the base class
    HRESULT hr = CCaptureWaveBuffer::Initialize(dwBufferBytes);

    // Try to create a pin on the device
    if(SUCCEEDED(hr))
    {
        // For focus aware buffers, we only allocate the device on Start
        if ((dwFlags & DSCBCAPS_FOCUSAWARE) && !m_pKsDevice->m_fSplitter)
        {
            // We'll need to save these...
            m_pwfx = CopyWfxAlloc(pwfxFormat);
            m_pFXChain = pFXChain;

#ifdef SHARED
            // Adding code to throw SetState to application thread
            m_hEventThread = CreateEvent(NULL, FALSE, FALSE, NULL);

            if (NULL == m_hEventThread)
            {
                DPF(DPFLVL_ERROR, "Unable to create event");
                hr = WIN32ERRORtoHRESULT(GetLastError());
            }

            if (SUCCEEDED(hr))
            {
                m_hEventAck = CreateEvent(NULL, FALSE, FALSE, NULL);

                if (NULL == m_hEventAck)
                {
                    DPF(DPFLVL_ERROR, "Unable to create ack event");
                    CLOSE_HANDLE(m_hEventThread);
                    hr = WIN32ERRORtoHRESULT(GetLastError());
                }
            }

            if (SUCCEEDED(hr))
            {
                DWORD dwThreadID;
                m_hThread = CreateThread(NULL, 0, CKsCaptureWaveBuffer::StateThread, this, 0, &dwThreadID);

                if (NULL == m_hThread)
                {
                    DPF(DPFLVL_ERROR, "Unable to create thread");
                    CLOSE_HANDLE(m_hEventAck);
                    CLOSE_HANDLE(m_hEventThread);
                    hr = WIN32ERRORtoHRESULT(GetLastError());
                }
            }
#endif // SHARED

        }
        else // Not a focus-aware buffer, or the splitter is available:
        {
            // Try to create a hardware pin first
            hr = m_pKsDevice->CreateCapturePin(-1, DSCBCAPS_LOCHARDWARE, pwfxFormat, pFXChain, &m_hPin, NULL);

            // If that failed, try to create a software pin
            if(FAILED(hr))
            {
                hr = m_pKsDevice->CreateCapturePin(-1, DSCBCAPS_LOCSOFTWARE, pwfxFormat, pFXChain, &m_hPin, NULL);
            }

            // If that failed and the user asked that we try the mapper, create an emulated buffer,
            // as long as there is no FX chain.  (Emulated buffers can't have capture effects.)
            if(FAILED(hr) && (dwFlags & DSCBCAPS_WAVEMAPPED) && pFXChain == NULL)
            {
                hr = CreateEmulatedBuffer(m_pKsDevice->m_pKsDevDescription->m_uWaveDeviceId, dwFlags, dwBufferBytes, const_cast<LPWAVEFORMATEX>(pwfxFormat), pFXChain, &m_pEmCaptureDevice, &m_pEmCaptureWaveBuffer);

                // We don't need the KS capture buffer's memory since the emulated
                // buffer has its own
                if(SUCCEEDED(hr))
                {
                    RELEASE(m_pSysMemBuffer);
                    m_pSysMemBuffer = ADDREF(m_pEmCaptureWaveBuffer->m_pSysMemBuffer);
                }
            }
        }
    }

    if(SUCCEEDED(hr) && (NULL == m_pEmCaptureDevice))
    {
        // Make a copy of important info
        m_cbBuffer = m_pSysMemBuffer->GetSize();

        m_pBufferProcessed = m_pBufferNext = m_pBuffer = m_pSysMemBuffer->GetWriteBuffer();

        // Calculate the end of the buffer
        m_pBufferMac = m_pBuffer + m_cbBuffer;

        // Record Chunk should be 10 msec. long to match the capture buffer used in the kernel.
        m_cbRecordChunk = pwfxFormat->nAvgBytesPerSec / 100;

        // Round up to multiple of nBlockAlign
        DWORD cbSize = m_cbRecordChunk % pwfxFormat->nBlockAlign;
        if (cbSize)
        {
            m_cbRecordChunk += pwfxFormat->nBlockAlign - cbSize;
        }

        // Calculate number of blocks
        {
            DWORD   cbLastBlock;

            // calculate number of blocks of size m_cbRecordChunk bytes
            m_cksio = m_cbBuffer / m_cbRecordChunk;

            // See if we have a partial-sized block
            cbLastBlock = (m_cbBuffer % m_cbRecordChunk);
            if (0 != cbLastBlock)
            {
                ++m_cksio;
            }
        }

        // Create at most cksioDefault KSSTREAMIOs
        if(m_cksio > cksioDefault)
        {
            m_cksio = cksioDefault;
        }

        ASSERT(0 < m_cksio);

        m_cksioDropped = m_cksio;

        // Allocate space for KSSTREAMIO array, etc.
        m_rgpksio = MEMALLOC_A(KSSTREAMIO, m_cksio);
        m_rgpCallbackEvent = MEMALLOC_A(CCallbackEvent *, m_cksio);

        if ((NULL == m_rgpksio) || (NULL == m_rgpCallbackEvent))
        {
            RPF(DPFLVL_ERROR, "Unable to alloc KSSTREAMIOs");
            hr = DSERR_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {
            for (LONG i = 0; (i < m_cksio) && SUCCEEDED(hr); ++i)
            {
                hr = AllocCallbackEvent(m_pKsDevice->m_pEventPool, &m_rgpCallbackEvent[i]);
            }
        }

        if(SUCCEEDED(hr))
        {
            for (LONG i = 0; i < m_cksio; ++i)
            {
                m_rgpksio[i].Overlapped.hEvent = m_rgpCallbackEvent[i]->GetEventHandle();
            }
        }

#ifdef DEBUG
        if(SUCCEEDED(hr))
        {
            m_hEventStop = CreateGlobalEvent(NULL, TRUE);
            hr = HRFROMP(m_hEventStop);
        }
#endif

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Gets capabilities for the buffer.
 *
 *  Arguments:
 *      LPDSCBCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::GetCaps"

HRESULT CKsCaptureWaveBuffer::GetCaps
(
    LPDSCBCAPS pDscbCaps
)
{
    DPF_ENTER();

    ASSERT(sizeof(*pDscbCaps) == pDscbCaps->dwSize);

    if(m_pEmCaptureWaveBuffer)
    {
        m_pEmCaptureWaveBuffer->GetCaps(pDscbCaps);
    }
    else
    {
        pDscbCaps->dwFlags = m_dwFlags;
        pDscbCaps->dwBufferBytes = m_cbBuffer;
        pDscbCaps->dwReserved = 0;
    }

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::GetState"

HRESULT CKsCaptureWaveBuffer::GetState
(
    LPDWORD                 pdwState
)
{
    HRESULT                 hr = DS_OK;

    DPF_ENTER();

    if(m_pEmCaptureWaveBuffer)
    {
        hr = m_pEmCaptureWaveBuffer->GetState(pdwState);
    }
    else
    {
        *pdwState = m_dwState & VAD_SETSTATE_MASK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  NotifyFocusChange
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::NotifyFocusChange"

HRESULT CKsCaptureWaveBuffer::NotifyFocusChange(void)
{
    HRESULT                 hr = DS_OK;

    DPF_ENTER();

    if (m_hEventFocus)
    {

#ifndef SHARED
        SetEvent(m_hEventFocus);
#else
        // Are we in the same process or in DDHelp?
        DWORD dwProcessID = GetOwnerProcessId();
        if (dwProcessID == GetCurrentProcessId())
        {
            SetEvent(m_hEventFocus);
        }
        else
        {
            HANDLE hEvent = GetLocalHandleCopy(m_hEventFocus, dwProcessID, FALSE);
            if (hEvent)
            {
                SetEvent(hEvent);
                CloseHandle(hEvent);
            }
            else
            {
                hr = WIN32ERRORtoHRESULT(GetLastError());
            }
        }
#endif // SHARED

    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  StateThread
 *
 *  Description:
 *      Processes focus changes under Win9x
 *
 *  Arguments:
 *      LPVOID [in] : pointer to instance data
 *
 *  Returns:
 *      DWORD
 *
 ***************************************************************************/

#ifdef SHARED

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::StateThread"

DWORD WINAPI CKsCaptureWaveBuffer::StateThread(LPVOID pv)
{
    CKsCaptureWaveBuffer   *pThis = (CKsCaptureWaveBuffer *)pv;

    DPF_ENTER();

    // This thread just sits during the duration of the buffer, it processes
    // SetState() calls from DDHelp in application process.

    while (TRUE)
    {
        WaitObject(INFINITE, pThis->m_hEventThread);

        if (pThis->m_dwSetState == TERMINATE_STATE_THREAD)
        {
            SetEvent(pThis->m_hEventAck);
            break;
        }
        else
        {
            pThis->m_hrReturn = pThis->SetState(pThis->m_dwSetState);
            SetEvent(pThis->m_hEventAck);
        }
    }

    DPF_LEAVE_VOID();
    return 0;
}

#endif // SHARED


/***************************************************************************
 *
 *  SetStateThread
 *
 *  Description:
 *      Sets buffer state on application thread.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#ifdef SHARED

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SetStateThread"

HRESULT CKsCaptureWaveBuffer::SetStateThread
(
    DWORD                   dwState
)
{
    HRESULT                 hr = DS_OK;
    HANDLE                  hEventSend, hEventAck;

    DPF_ENTER();

    DWORD dwProcessID = GetOwnerProcessId();

#ifdef SHARED
    BOOL fMapped = (dwProcessID != GetCurrentProcessId());
    if (fMapped)
    {
        hEventSend = GetLocalHandleCopy(m_hEventThread, dwProcessID, FALSE);
        hEventAck  = GetLocalHandleCopy(m_hEventAck, dwProcessID, FALSE);
    }
    else
#endif // SHARED

    {
        hEventSend = m_hEventThread;
        hEventAck  = m_hEventAck;
    }

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    EnterCriticalSection(&m_csSS);

    m_dwSetState = dwState;
    m_hrReturn   = DS_OK;

    // "Sending" the message.
    ResetEvent(hEventAck);
    SetEvent(hEventSend);
    WaitObject(INFINITE, hEventAck);

    hr = m_hrReturn;

    LeaveCriticalSection(&m_csSS);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

#ifdef SHARED
    if (fMapped)
    {
        CloseHandle(hEventSend);
        CloseHandle(hEventAck);
    }
#endif // SHARED

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#endif


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SetState"

HRESULT CKsCaptureWaveBuffer::SetState
(
    DWORD           dwState
)
{
    HRESULT         hr          = DS_OK;

    DPF_ENTER();

    ASSERT(IS_VALID_FLAGS(dwState, VAD_SETSTATE_MASK));

#ifdef DEBUG_CAPTURE
    DPF(DPFLVL_INFO, "SetState(%s) called", StateName(dwState));
    DPF(DPFLVL_INFO, "  Current state: %s", StateName(m_dwState));
#endif // DEBUG_CAPTURE

#ifdef SHARED
    if (GetOwnerProcessId() != GetCurrentProcessId())
    {
        if (!m_pKsDevice->m_fSplitter)
        {
            hr = SetStateThread(dwState);
            DPF_LEAVE_HRESULT(hr);
            return hr;
        }
    }
#endif

    if (m_pEmCaptureWaveBuffer)
    {
        hr = m_pEmCaptureWaveBuffer->SetState(dwState);
    }
    else
    {
        //==========================================================//
        //                  Enter Critical section                  //
        //                                                          //
        ASSERT(m_fCritSectsValid);
        EnterCriticalSection(&m_cs);

        if (dwState != m_dwState)
        {
            if(dwState & VAD_BUFFERSTATE_STARTED) // Need to start capturing
            {
                if ((m_dwFlags & DSCBCAPS_FOCUSAWARE) && !m_pKsDevice->m_fSplitter)
                {
                    // Focus aware buffer
                    if (m_dwState & VAD_BUFFERSTATE_INFOCUS)
                    {
                        if (NULL == m_hPin)
                        {
                            // Try to create a hardware pin first
                            hr = m_pKsDevice->CreateCapturePin(-1, DSCBCAPS_LOCHARDWARE, m_pwfx, m_pFXChain, &m_hPin, NULL);

                            // If that failed, try to create a software pin
                            if (FAILED(hr))
                                hr = m_pKsDevice->CreateCapturePin(-1, DSCBCAPS_LOCSOFTWARE, m_pwfx, m_pFXChain, &m_hPin, NULL);
                        }

                        if (SUCCEEDED(hr))
                        {
                            if (m_dwState & VAD_BUFFERSTATE_STARTED)
                                hr = UpdateCaptureState(MAKEBOOL(dwState & VAD_BUFFERSTATE_LOOPING));
                            else
                                hr = SetCaptureState(MAKEBOOL(dwState & VAD_BUFFERSTATE_LOOPING));
                        }
                        else
                        {
                            // We can't seem to allocate the device; let's save its state for now
                            m_fdwSavedState = dwState;
                        }
                    }
                    else
                    {
                        // We're not starting the device because we don't have focus, but we're saving the state.
                        m_fdwSavedState = dwState;
                    }
                }
                else
                {
                    // Regular buffer
                    if (m_dwState & VAD_BUFFERSTATE_STARTED)
                        hr = UpdateCaptureState(MAKEBOOL(dwState & VAD_BUFFERSTATE_LOOPING));
                    else
                        hr = SetCaptureState(MAKEBOOL(dwState & VAD_BUFFERSTATE_LOOPING));
                }
            }
            else if (dwState == VAD_BUFFERSTATE_INFOCUS)
            {
                // Only focus-aware buffers start capturing when they gain focus
                if (m_dwFlags & DSCBCAPS_FOCUSAWARE)
                {
                    // If the capture focus state is changing...
                    if ((m_dwState & VAD_FOCUSFLAGS) != VAD_BUFFERSTATE_INFOCUS)
                    {
                        // Update m_dwState according to the dwState argument
                        m_dwState &= ~VAD_FOCUSFLAGS;
                        m_dwState |= VAD_BUFFERSTATE_INFOCUS;

                        // Notify the application of the focus change
                        NotifyFocusChange();

                        // If we were capturing previously, get our pin back if necessary
                        if (m_fdwSavedState & VAD_BUFFERSTATE_STARTED)
                        {
                            if (NULL == m_hPin)
                            {
                                for (UINT ii = 4; ii; ii--)
                                {
                                    // Try to create a hardware pin first
                                    hr = m_pKsDevice->CreateCapturePin(-1, DSCBCAPS_LOCHARDWARE, m_pwfx, m_pFXChain, &m_hPin, NULL);

                                    // If that failed, try to create a software pin
                                    if (FAILED(hr))
                                        hr = m_pKsDevice->CreateCapturePin(-1, DSCBCAPS_LOCSOFTWARE, m_pwfx, m_pFXChain, &m_hPin, NULL);

                                    if (SUCCEEDED(hr))
                                        break;

                                    DPF(DPFLVL_ERROR, "CreateCapturePin failed for FA buffer; retrying after 20ms");
                                    Sleep(20);
                                }
                            }
                            hr = SetCaptureState(MAKEBOOL(m_fdwSavedState & VAD_BUFFERSTATE_LOOPING));
                        }
                    }
                }
            }
            else if (dwState & (VAD_BUFFERSTATE_OUTOFFOCUS | VAD_BUFFERSTATE_LOSTCONSOLE))
            {
                // Only focus-aware buffers stop capturing when they lose focus
                if (m_dwFlags & DSCBCAPS_FOCUSAWARE)
                {
                    // If the capture focus state is changing...
                    if ((m_dwState & VAD_FOCUSFLAGS) != dwState)
                    {
                        // Update m_dwState according to the dwState argument
                        m_dwState &= ~VAD_FOCUSFLAGS;
                        m_dwState |= dwState;

                        // Notify the application of the focus change
                        NotifyFocusChange();

                        // If there's no splitter OR we've lost the console, stop capturing
                        if (!m_pKsDevice->m_fSplitter || (dwState & VAD_BUFFERSTATE_LOSTCONSOLE))
                        {
                            if(m_dwState & VAD_BUFFERSTATE_STARTED)
                            {
                                m_fdwSavedState = m_dwState; // Save the buffer state
                                hr = SetStopState(TRUE);
                            }
                            // It's only necessary to actually release the pin if there's no splitter
                            if (!m_pKsDevice->m_fSplitter)
                            {
                                CLOSE_HANDLE(m_hPin);
                            }
                        }
                    }
                }
            }
            else // VAD_BUFFERSTATE_STOPPED case; need to stop capturing
            {
                ASSERT(dwState == VAD_BUFFERSTATE_STOPPED);  // By elimination

                if(m_dwState & VAD_BUFFERSTATE_STARTED)
                {
                    hr = SetStopState(TRUE);

                    if (DSCBCAPS_FOCUSAWARE & m_dwFlags)
                        CLOSE_HANDLE(m_hPin);
                }
                m_fdwSavedState = 0;
            }
        }

        LeaveCriticalSection(&m_cs);
        //                                                          //
        //                 Leave Critical Section                   //
        //==========================================================//
    }

#ifdef DEBUG_CAPTURE
    DPF(DPFLVL_INFO, "  Final state: %s", StateName(m_dwState));
    DPF(DPFLVL_INFO, "  (Saved state: %s)", StateName(m_fdwSavedState));
#endif // DEBUG_CAPTURE

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Gets the current capture/read positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives capture cursor position.
 *      LPDWORD [out]: receives read cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::GetCursorPosition"

HRESULT CKsCaptureWaveBuffer::GetCursorPosition
(
    LPDWORD                 pdwCapturePosition,
    LPDWORD                 pdwReadPosition
)
{
    HRESULT                 hr                  = DS_OK;

    DPF_ENTER();

    if(m_pEmCaptureWaveBuffer)
    {
        hr = m_pEmCaptureWaveBuffer->GetCursorPosition(pdwCapturePosition, pdwReadPosition);
    }
    else
    {
        KSAUDIO_POSITION    Position;
        DWORD               dwRead;

        dwRead = ((m_dwCaptureCur + m_dwCaptureLast) % m_cbBuffer);

        if(VAD_BUFFERSTATE_STARTED & m_dwState)
        {
            // Focus aware and stopped?
            ASSERT(NULL != m_hPin);

            hr =
                KsGetProperty
                (
                    m_hPin,
                    KSPROPSETID_Audio,
                    KSPROPERTY_AUDIO_POSITION,
                    &Position,
                    sizeof(KSAUDIO_POSITION)
                );

            if(SUCCEEDED(hr))
            {
                ASSERT(Position.WriteOffset <= MAX_DWORD);
                ASSERT(Position.PlayOffset <= MAX_DWORD);

                if(pdwCapturePosition)
                {
                    *pdwCapturePosition = (m_dwCaptureLast + (DWORD)Position.PlayOffset) % m_cbBuffer;
                }
            }
            else
            {
                DPF(DPFLVL_ERROR, "Unable to get cursor position");
            }
        }
        else
        {
            if(pdwCapturePosition)
            {
                *pdwCapturePosition = dwRead;
            }
        }

        if(SUCCEEDED(hr) && pdwReadPosition)
        {
            *pdwReadPosition = dwRead;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetCaptureState
 *
 *  Description:
 *      Sets the buffer to a "capture" state.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to capture looped.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SetCaptureState"

HRESULT CKsCaptureWaveBuffer::SetCaptureState(BOOL fLoop)
{
    HRESULT                 hr          = DS_OK;
    LONG                    iksio       = 0;
    HANDLE                  hPin        = m_hPin;

    DPF_ENTER();

    ASSERT(!m_pEmCaptureWaveBuffer);

#ifdef SHARED
    if (GetOwnerProcessId() != GetCurrentProcessId())
        hPin = GetLocalHandleCopy(m_hPin, GetOwnerProcessId(), FALSE);
#endif

    while ((m_cksioDropped > 0) &&
           (fLoop || (m_cLoops == 0)))
    {
        PKSSTREAMIO pksio = m_rgpksio + iksio;

        hr = SubmitKsStreamIo(pksio, hPin);
        if(FAILED(hr))
        {
            DPF(DPFLVL_ERROR, "SubmitKsStreamIo failed");
            break;
        }

        iksio += 1;
        ASSERT(iksio <= m_cksio);
        InterlockedDecrement(&m_cksioDropped);
    }

#ifdef DEBUG
    if(m_cksioDropped != 0)
    {
        ASSERT(!(VAD_BUFFERSTATE_LOOPING & m_dwState));
    }
#endif

    // Start capturing noise
    if(SUCCEEDED(hr))
    {
        hr = KsSetState(hPin, KSSTATE_RUN);
    }

#ifdef SHARED
    CLOSE_HANDLE(hPin);
#endif

    // Update our status
    if(SUCCEEDED(hr))
    {
        m_PinState = KSSTATE_RUN;
        m_dwState &= VAD_FOCUSFLAGS; // Preserve focus flags
        m_dwState |= VAD_BUFFERSTATE_STARTED;

        if(fLoop)
        {
            m_dwState |= VAD_BUFFERSTATE_LOOPING;
        }

        // update to next KSSTREAMIO expected
        m_iksioDone = 0;

        // Remember last valid position
        m_dwCaptureLast += m_dwCaptureCur;

        m_dwCaptureCur = 0;
    }
    else
    {
        DPF(DPFLVL_ERROR, "Failed to transition to KSSTATE_RUN; cancelling pending IRPs");
        SetStopState(TRUE);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CancelAllPendingIRPs
 *
 *  Description:
 *      Cancels all the pending READ IRPs
 *
 *  Arguments:
 *      BOOL [in]: TRUE to wait for all submitted IRPs.
 *      HANDLE [in]: Optional pin handle to use instead of m_hPin.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::CancelAllPendingIRPs"

HRESULT CKsCaptureWaveBuffer::CancelAllPendingIRPs(BOOL fWait, HANDLE hPin)
{
    HRESULT hr;

    DPF_ENTER();

    // If the calling process isn't our owning process, hPin is our pin handle
    // mapped to the calling process, so we should use it instead of m_hPin
    hPin = (hPin ? hPin : m_hPin);

    // DPF(DPFLVL_MOREINFO, "Calling KsResetState(hPin=%08x, KSRESET_BEGIN)", hPin);
    hr = KsResetState(hPin, KSRESET_BEGIN);

    // Wait for all the submitted KSSTREAMIOs to finish
    if(SUCCEEDED(hr) && fWait)
    {
        DWORD   iksio;
        DWORD   iksioOrig;
        DWORD   dwWait;

        iksioOrig = iksio = m_iksioDone;

        do
        {
            if(m_rgpksio[iksio].fPendingIrp)
            {
                DPF(DPFLVL_MOREINFO, "KSIO #%d at %p: Data=%p FrExt=%lu DataUsed=%lu Flags=0x%lx Event=0x%lx",
                    iksio,
                    m_rgpksio + iksio,
                    m_rgpksio[iksio].Header.DataUsed,
                    m_rgpksio[iksio].Header.FrameExtent,
                    m_rgpksio[iksio].Header.Data,
                    m_rgpksio[iksio].Header.OptionsFlags,
                    m_rgpCallbackEvent[iksio]->GetEventHandle());

                dwWait = m_rgpCallbackEvent[iksio]->Wait(INFINITE);
                if(WAIT_OBJECT_0 == dwWait)
                {
                    EventSignalCallback(m_rgpCallbackEvent[iksio]);
                    ASSERT(!m_rgpksio[iksio].fPendingIrp);
#ifdef DEBUG
                    ASSERT(WAIT_OBJECT_0 != m_rgpCallbackEvent[iksio]->Wait(0));
#endif
                }
            }

            iksio = (iksio + 1) % m_cksio;
        } while (iksio != iksioOrig);

        ASSERT(m_cksioDropped == m_cksio);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsResetState(hPin, KSRESET_END);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  UpdateCaptureState
 *
 *  Description:
 *      Changes the loop flag on a capturing buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to capture looped.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::UpdateCaptureState"

HRESULT CKsCaptureWaveBuffer::UpdateCaptureState(BOOL fLoop)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    ASSERT(m_dwState & VAD_BUFFERSTATE_STARTED);

    // Do we need to submit any read IRPs?
    if(fLoop != MAKEBOOL(VAD_BUFFERSTATE_LOOPING & m_dwState))
    {
        m_dwState |= DSCBSTATUS_STOPPING | DSCBSTATUS_PAUSE;

        // Pause the pin
        hr = KsSetState(m_hPin, KSSTATE_PAUSE);

        if(SUCCEEDED(hr))
        {
            // Update our current notion of the pin state
            m_PinState = KSSTATE_PAUSE;

            hr = CancelAllPendingIRPs(TRUE);

#ifdef DEBUG
            if(SUCCEEDED(hr))
            {
                ASSERT(WAIT_OBJECT_0 == WaitObject(0, m_hEventStop));
            }
#endif
        }

        // Update the buffer state flag
        if(SUCCEEDED(hr))
        {
            m_dwState &= VAD_FOCUSFLAGS;  // Preserve focus flags
            m_dwState |= VAD_BUFFERSTATE_STOPPED | DSCBSTATUS_STOPPED | DSCBSTATUS_STOPPING;
        }
        else
        {
            m_dwState &= ~(DSCBSTATUS_STOPPING | DSCBSTATUS_STOPPED | DSCBSTATUS_PAUSE);
        }

        // Resubmit the read IRP
        if(SUCCEEDED(hr))
        {
            hr = SetCaptureState(fLoop);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetStopState
 *
 *  Description:
 *      Sets the buffer to a "stop" state.
 *
 *  Arguments:
 *      BOOL [in] : if TRUE, wait for all submitted IRPs.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SetStopState"

HRESULT CKsCaptureWaveBuffer::SetStopState(BOOL fWait)
{
    HRESULT                 hr          = DS_OK;
    HANDLE                  hPin        = m_hPin;

    DPF_ENTER();

    ASSERT(!m_pEmCaptureWaveBuffer);
    ASSERT((m_PinState == KSSTATE_PAUSE) || (m_dwState & VAD_BUFFERSTATE_STARTED));

    m_dwState |= DSCBSTATUS_STOPPING;

#ifdef SHARED
    if (GetOwnerProcessId() != GetCurrentProcessId())
        hPin = GetLocalHandleCopy(m_hPin, GetOwnerProcessId(), FALSE);
#endif

    if (m_PinState == KSSTATE_RUN)
    {
        // Pause the pin
        hr = KsSetState(hPin, KSSTATE_PAUSE);

        // Update our internal pin state;
        if (SUCCEEDED(hr))
        {
            m_PinState = KSSTATE_PAUSE;
        }
    }

    // Cancel all the KSSTREAMIOs
    if(SUCCEEDED(hr))
    {
        hr = CancelAllPendingIRPs(fWait, hPin);

        ASSERT(SUCCEEDED(hr) && "Failed to CancelAllPendingIRPs");

#ifdef DEBUG
        if(SUCCEEDED(hr) && fWait)
        {
            ASSERT(WAIT_OBJECT_0 == WaitObject(0, m_hEventStop));
        }
#endif

    }

#ifdef DEBUG
    DPF(DPFLVL_MOREINFO, "IRPs submitted=%lu, returned=%lu", m_cIrpsSubmitted, m_cIrpsReturned);
    ASSERT(m_cIrpsSubmitted == m_cIrpsReturned);
#endif

#ifdef SHARED
    CLOSE_HANDLE(hPin);
#endif

    // Update the buffer state flag
    if(SUCCEEDED(hr))
    {
        // Preserving focus flags...
        m_dwState &= VAD_FOCUSFLAGS;
        m_dwState |= VAD_BUFFERSTATE_STOPPED | DSCBSTATUS_STOPPING | DSCBSTATUS_STOPPED;
    }
    else
    {
        m_dwState &= ~(VAD_BUFFERSTATE_STOPPED | DSCBSTATUS_STOPPING | DSCBSTATUS_STOPPED);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SetNotificationPositions"

HRESULT CKsCaptureWaveBuffer::SetNotificationPositions
(
    DWORD                   dwCount,
    LPCDSBPOSITIONNOTIFY    paNotes
)
{
    LPDSBPOSITIONNOTIFY     paNotesCopy = NULL;
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    if(m_pEmCaptureWaveBuffer)
    {
        hr = m_pEmCaptureWaveBuffer->SetNotificationPositions(dwCount, paNotes);
    }
    else
    {
        //==========================================================//
        //                  Enter Critical section                  //
        //                                                          //
        ASSERT(m_fCritSectsValid);
        EnterCriticalSection(&m_csPN);

        // Make a local copy of the notifications
        if(paNotes)
        {
            paNotesCopy = MEMALLOC_A_COPY(DSBPOSITIONNOTIFY, dwCount, paNotes);
            hr = HRFROMP(paNotesCopy);
        }

        // Disable any current events
        if(SUCCEEDED(hr))
        {
            hr = FreeNotificationPositions();
        }

        // Save the new events
        if(SUCCEEDED(hr))
        {
            m_paNotes = paNotesCopy;
            m_cNotes = dwCount;
        }

        // Set new position notifications
        if(SUCCEEDED(hr) && (0 != dwCount) &&
           (DSBPN_OFFSETSTOP == m_paNotes[dwCount-1].dwOffset))
        {
            // We won't actually pass the stop event down to KS, but
            // instead will keep our own copy of it
            ASSERT(!m_pStopNote);
            m_pStopNote = &m_paNotes[dwCount-1];
        }

        LeaveCriticalSection(&m_csPN);
        //                                                          //
        //                 Leave Critical Section                   //
        //==========================================================//
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  FreeNotificationPositions
 *
 *  Description:
 *      Removes all position notifications and frees allocated resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::FreeNotificationPositions"

HRESULT CKsCaptureWaveBuffer::FreeNotificationPositions(void)
{
    DPF_ENTER();

    ASSERT(!m_pEmCaptureWaveBuffer);

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    ASSERT(m_fCritSectsValid);
    EnterCriticalSection(&m_csPN);

    // Clean up
    MEMFREE(m_paNotes);

    m_pStopNote = NULL;
    m_cNotes = 0;

    LeaveCriticalSection(&m_csPN);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SignalNotificationPositions"

void CKsCaptureWaveBuffer::SignalNotificationPositions(PKSSTREAMIO pksio)
{
    DPF_ENTER();

    // grab critical section for position notify handling
    //

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    ASSERT(m_fCritSectsValid);
    EnterCriticalSection(&m_csPN);

    // Scan for any position notifies that need to be signaled
    if (m_cNotes)
    {
        DWORD   iNoteOld = m_iNote;
        DWORD   dwBufferStart = PtrDiffToUlong((LPBYTE)pksio->Header.Data - m_pBuffer);
        DWORD   dwBufferEnd = dwBufferStart + pksio->Header.DataUsed;

        DPF(DPFLVL_MOREINFO, "Checking NP:  %8.8ld - %8.8ld (%8.8lX - %8.8lX)",
            dwBufferStart, dwBufferEnd, dwBufferStart, dwBufferEnd);

        // Is there a position.notify within the start.end of this
        // captured data?
        // Is the current position.notify to be signaled on Stop?
        //
        while (((m_paNotes[m_iNote].dwOffset >= dwBufferStart) &&
                (m_paNotes[m_iNote].dwOffset < dwBufferEnd)) ||
               (DSBPN_OFFSETSTOP == m_paNotes[m_iNote].dwOffset))
        {
            // Only signal if not for Stop pos.notify
            if(DSBPN_OFFSETSTOP != m_paNotes[m_iNote].dwOffset)
            {
                DPF(DPFLVL_INFO, "Signalled:  %8.8ld (%08X) [%d]",
                    m_paNotes[m_iNote].dwOffset, m_paNotes[m_iNote].dwOffset, m_iNote);
                try
                {
                    SetEvent(m_paNotes[m_iNote].hEventNotify);
                } catch (...) {}
            }

            // go on to the next pos.notify
            m_iNote = (m_iNote + 1) % m_cNotes;

            // Infinite loop?
            if(m_iNote == iNoteOld)
            {
                break;
            }
        }
    }

    LeaveCriticalSection(&m_csPN);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EventSignalCallback
 *
 *  Description:
 *      Callback function called when a pin's IO completion event is
 *      signalled.  This function is called from within the callback event
 *      pool's lock, so we get thread synchronization for free.
 *
 *  Arguments:
 *      CCallbackEvent * [in]: callback event.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::EventSignalCallback"

void CKsCaptureWaveBuffer::EventSignalCallback(CCallbackEvent *pEvent)
{
    PKSSTREAMIO pksio;
    LONG        iksioExpect;
    LONG        iksioCurrent;
    LONG        cksioToProcess;
    HANDLE      hEvent;
    LONG        i;

    DPF_ENTER();

    ASSERT(!m_pEmCaptureWaveBuffer);

    iksioExpect = m_iksioDone;

    // WaitForMultipleObjects seems to return the first
    // signaled event in the array.
    //
    // So if we're expecting the fifth IRP, the first IRP
    // may have completed as well and WFMO will say that the
    // first IRP has finished even though 5...8 have also
    // finished.
    //
    // So we check for the expected IRP.
    // If we see it, then we're fine.
    // Otherwise, we have to determine what position
    // that the signaled event maps to. Then
    // we have to process all the IRPs from the
    // expected IRP to the IRP that we were told about.

    // This is the signaled handle that
    // WaitForMultipleObjects returned
    hEvent = pEvent->GetEventHandle();

    // Is this the expected event?
    if(hEvent == m_rgpCallbackEvent[iksioExpect]->GetEventHandle())
    {
        i = iksioExpect;
    }
    else
    {
        // Find the position for the signaled event in our list
        for (i = 0; i < m_cksio; ++i)
        {
            if (hEvent == m_rgpCallbackEvent[i]->GetEventHandle())
            {
                break;
            }
        }
    }

    // We've never seen this event before
    ASSERT(m_cksio != i);

    // Remember the current signaled IRP
    iksioCurrent = i;

    // Determine number of IRPs to process
    if (iksioCurrent >= iksioExpect)
    {
        cksioToProcess = iksioCurrent - iksioExpect + 1;
    }
    else
    {
        cksioToProcess = (m_cksio - iksioExpect) + iksioCurrent + 1;
    }

    DPF(DPFLVL_MOREINFO, "ToProcess:%d Current:%d Expected:%d (event %lX)", cksioToProcess, iksioCurrent, iksioExpect, hEvent);

    // Can only have 1...m_cksio IRPs to process
    ASSERT((cksioToProcess > 0) && (cksioToProcess <= m_cksio));

    while (cksioToProcess > 0)
    {
        pksio = m_rgpksio + m_iksioDone;

        DPF(DPFLVL_MOREINFO, "Got KSIO #%d at 0x%p: Data=0x%p FrExt=%lu DataUsed=%lu Flags=0x%lx Event=0x%lX",
            m_iksioDone,
            pksio,
            pksio->Header.Data,
            pksio->Header.FrameExtent,
            pksio->Header.DataUsed,
            pksio->Header.OptionsFlags,
            pksio->Overlapped.hEvent);

        DWORD dwWait = WaitObject(10000, pksio->Overlapped.hEvent);
        ASSERT(WAIT_OBJECT_0 == dwWait);
#ifdef DEBUG
        ++m_cIrpsReturned;
#endif

        if (pksio->fPendingIrp && !(DSCBSTATUS_STOPPING & m_dwState))
        {
#if 0
            ASSERT(0 != pksio->Header.DataUsed);
#endif
        }

        // If the user calls Stop, (which grabs the DLL mutex), KS
        // may signal that an IRP has completed and so the EventPool's
        // worker thread will try to process the IRP associated with the
        // signalled event. Before the worker thread calls our
        // EventSignalCallback method, it tries to grab the DLL mutex.
        // If we're already processing the Stop method, we will "complete"
        // all the IRPs before the worker thread can grab the mutex and
        // tell us about the completed IRP it knows about.
        //
        // So we need to check that fPendingIRP is TRUE in case
        // we've already seen this IRP before.
        //
        if ((0 != pksio->Header.DataUsed) &&
            pksio->fPendingIrp &&
            !(DSCBSTATUS_STOPPED & m_dwState))
        {
            BOOL    fEndOfBuffer = FALSE;

            ASSERT(WAIT_OBJECT_0 == m_rgpCallbackEvent[m_iksioDone]->Wait(0));
            ASSERT(TRUE == pksio->fPendingIrp);

            // update number of recorded bytes
            m_dwCaptureCur += pksio->Header.DataUsed;

#if 0
            ASSERT(m_pBufferProcessed == (LPBYTE)pksio->Header.Data);
#endif
            m_pBufferProcessed += pksio->Header.DataUsed;
            if(m_pBufferProcessed >= m_pBufferMac)
            {
                m_pBufferProcessed = m_pBuffer;
                fEndOfBuffer = TRUE;
            }

            SignalNotificationPositions(pksio);

            // Transition buffer to stop state:
            // if the capture buffer end has been reached AND
            // if the buffer is non-LOOPING AND
            // if the buffer isn't in the middle of stopping
            //
            // Do this after the position notifications since STOP notification
            // is after any buffer-offset notification.
            //
            if(fEndOfBuffer &&
               (0 == (VAD_BUFFERSTATE_LOOPING & m_dwState)) &&
               (0 == (DSCBSTATUS_STOPPING & m_dwState)))
            {
                //==========================================================//
                //                  Enter Critical section                  //
                //                                                          //
                ASSERT(m_fCritSectsValid && "NT bug 306910 - notify dsound team");
                EnterCriticalSection(&m_cs);

                SetStopState(FALSE);

                LeaveCriticalSection(&m_cs);
                //                                                          //
                //                 Leave Critical Section                   //
                //==========================================================//

                ASSERT(DSCBSTATUS_STOPPING & m_dwState);
                ASSERT((m_cksioDropped+1) == m_cksio);
            }

            pksio->Header.DataUsed = 0;
        }

        pksio->fPendingIrp = FALSE;
        m_rgpCallbackEvent[m_iksioDone]->Reset();

        // We're stopping, let's drop everything
        if(DSCBSTATUS_STOPPING & m_dwState)
        {
Drop:
            InterlockedIncrement(&m_cksioDropped);

            // when all KSSTREAMIOs have been dropped
            if(m_cksioDropped == m_cksio)
            {
                // set the next point in the data buffer to capture to
                m_pBufferNext = m_pBufferProcessed;
                m_cLoops = 0;
#ifdef DEBUG
                SetEvent(m_hEventStop);
#endif
                // Notify user that we've stopped
                if (!(DSCBSTATUS_PAUSE & m_dwState))
                {
                    NotifyStop();
                }
            }
            else if (m_cksioDropped > m_cksio)
            {
                ASSERT(FALSE);
            }
        }
        else
        {
            ASSERT(VAD_BUFFERSTATE_STARTED & m_dwState);

            // If we're LOOPING or we haven't reached the end of the buffer yet
            // then put the KSSTREAMIO back on to the queue with a new position
            // in the buffer, etc.
            BOOL fAddToQueue = (VAD_BUFFERSTATE_LOOPING & m_dwState) ||
                               (m_pBufferNext > (LPBYTE)pksio->Header.Data);

            if (fAddToQueue)
            {
                HRESULT hr;
                BOOL    fDrop;

                //==========================================================//
                //                  Enter Critical section                  //
                //                                                          //
                ASSERT(m_fCritSectsValid && "NT bug 306910 - notify dsound team");
                EnterCriticalSection(&m_cs);

                if ((DSCBSTATUS_STOPPED | DSCBSTATUS_STOPPING) & m_dwState)
                {
                    fDrop = TRUE;
                }
                else
                {
                    hr = SubmitKsStreamIo(pksio);
                    fDrop = FALSE;
                }

                LeaveCriticalSection(&m_cs);
                //                                                          //
                //                 Leave Critical Section                   //
                //==========================================================//

                if (fDrop)
                {
                    goto Drop;
                }

                // What can we do if there's an error?
                ASSERT(SUCCEEDED(hr));
            }
            else
            {
                InterlockedIncrement(&m_cksioDropped);

                // If no KSSTREAMIOs are submitted then if the user
                // starts capturing again, we submit the KSSTREAMIOs
                // from the beginning
                if (m_cksio == m_cksioDropped)
                {
#ifdef DEBUG
                    if (!(VAD_BUFFERSTATE_LOOPING & m_dwState))
                        ASSERT(m_cLoops > 0);
                    SetEvent(m_hEventStop);
#endif
                    // Notify user that we've stopped
                    NotifyStop();
                }
                else if (m_cksioDropped > m_cksio)
                {
                    ASSERT(FALSE);
                }
            }
        }

        m_iksioDone = (m_iksioDone + 1) % m_cksio;

        cksioToProcess -= 1;
    }

    if (iksioCurrent >= m_iksioDone)
    {
        ASSERT(iksioCurrent == (m_cksio - 1));
        ASSERT(0 == m_iksioDone);
    }
    else
    {
        ASSERT(iksioCurrent == (m_iksioDone-1));
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  NotifyStop
 *
 *  Description:
 *      Sets any events that are supposed to set when capturing stops
 *
 *  Arguments:
 *      None.
 *
 *  Returns:
 *      None.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::NotifyStop"

void CKsCaptureWaveBuffer::NotifyStop(void)
{
    DPF_ENTER();

    //==========================================================//
    //                  Enter Critical section                  //
    //                                                          //
    ASSERT(m_fCritSectsValid);
    EnterCriticalSection(&m_csPN);

    // Signal any STOP pos.notifies - only one allowed
    //
    if (m_pStopNote)
    {
        try
        {
            SetEvent(m_pStopNote->hEventNotify);
        }
        catch (...) {}
    }

    LeaveCriticalSection(&m_csPN);
    //                                                          //
    //                 Leave Critical Section                   //
    //==========================================================//

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  SubmitKsStreamIo
 *
 *  Description:
 *      Submits a Read IRP to KS.
 *
 *  Arguments:
 *      PKSSTREAMIO [in] : KSSTREAMIO to submit.
 *      HANDLE [in]: Optional pin handle to use instead of m_hPin.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::SubmitKsStreamIo"

HRESULT CKsCaptureWaveBuffer::SubmitKsStreamIo
(
    PKSSTREAMIO                     pksio,
    HANDLE                          hPin
)
{
    HRESULT     hr;
    DWORD       dwFlags = 0;

    DPF_ENTER();

    // If the calling process isn't our owning process, hPin is our pin handle
    // mapped to the calling process, so we should use it instead of m_hPin
    hPin = (hPin ? hPin : m_hPin);

    ULONG cbBuffer = m_cbRecordChunk;

    // does capture buffer extend beyond end of buffer?
    //
    // If the amount left at end of buffer is less than threshold,
    // make this IRP extend to the end of the buffer so we don't
    // end up submitting a tiny IRP next time
    if (m_pBufferMac < (m_pBufferNext + m_cbRecordChunk))
    {
        cbBuffer = PtrDiffToUlong(m_pBufferMac - m_pBufferNext);
    }

    // Submit the IR
    hr = KsReadStream(hPin, m_pBufferNext, cbBuffer, dwFlags, pksio);

    if(SUCCEEDED(hr))
    {
        ASSERT((LPBYTE)pksio->Header.Data == m_pBufferNext);
        ASSERT((m_pBufferNext + pksio->Header.FrameExtent) <= m_pBufferMac);

        m_pBufferNext += cbBuffer;

#ifdef DEBUG
        ++m_cIrpsSubmitted;
#endif

        // Wraparound?
        if (m_pBufferNext >= m_pBufferMac)
        {
            m_pBufferNext = m_pBuffer;
            m_cLoops += 1;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CreateEmulatedBuffer
 *
 *  Description:
 *      Opens the emulated capture device and buffer with the given
 *      parameters.  This function is used strictly as a backup.
 *
 *  Arguments:
 *      UINT [in]: waveIn device ID.
 *      DWORD [in]: buffer flags.
 *      DWORD [in]: buffer size, in bytes.
 *      LPCWAVEFORMATEX [in]: buffer format.
 *      CEmCaptureDevice ** [out]: receives device pointer.
 *      CEmCaptureWaveBuffer ** [out]: receives buffer pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsCaptureWaveBuffer::CreateEmulatedBuffer"

HRESULT CKsCaptureWaveBuffer::CreateEmulatedBuffer
(
    UINT                            uDeviceId,
    DWORD                           dwFlags,
    DWORD                           dwBufferBytes,
    LPCWAVEFORMATEX                 pwfx,
    CCaptureEffectChain *           pFXChain,
    CEmCaptureDevice **             ppDevice,
    CEmCaptureWaveBuffer **         ppBuffer
)
{
    CEmCaptureDevice *              pDevice     = NULL;
    CEmCaptureWaveBuffer *          pBuffer     = NULL;
    HRESULT                         hr          = DS_OK;
    CObjectList<CDeviceDescription> lstDrivers;
    CNode<CDeviceDescription *> *   pNode;

    DPF_ENTER();

    ASSERT(DSCBCAPS_WAVEMAPPED & dwFlags);

    // Create an emulated device using the same waveIn device ID as the one
    // the KS device is using.
    hr = g_pVadMgr->EnumDrivers(VAD_DEVICETYPE_EMULATEDCAPTURE, 0, &lstDrivers);

    if(SUCCEEDED(hr))
    {
        for(pNode = lstDrivers.GetListHead(); pNode; pNode = pNode->m_pNext)
        {
            if(uDeviceId == pNode->m_data->m_uWaveDeviceId)
            {
                break;
            }
        }

        if (!pNode)
        {
            hr = DSERR_NODRIVER;
        }
    }

    if(SUCCEEDED(hr))
    {
        pDevice = NEW(CEmCaptureDevice);
        hr = HRFROMP(pDevice);
    }

    if(SUCCEEDED(hr))
    {
        hr = pDevice->Initialize(pNode->m_data);
    }

    // Try and create the buffer
    if(SUCCEEDED(hr))
    {
        hr = pDevice->CreateBuffer(dwFlags, dwBufferBytes, pwfx, pFXChain, NULL, (CCaptureWaveBuffer **)&pBuffer);
    }

    if(SUCCEEDED(hr))
    {
        *ppDevice = pDevice;
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
        ABSOLUTE_RELEASE(pDevice);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\ks3d.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ks3d.h
 *  Content:    WDM/CSA 3D object class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/6/98      dereks  Created.
 *
 ***************************************************************************/

#ifdef NOKS
#error ks3d.h included with NOKS defined
#endif // NOKS

#ifndef __KS3D_H__
#define __KS3D_H__

#ifdef __cplusplus

#include "multi3d.h" // For the CMultiPan3dListener base class

// Forward declarations
class CKs3dListener;
class CKsHw3dObject;
class CKsIir3dObject;
class CKsItd3dObject;

class CKsSecondaryRenderWaveBuffer;

// KS 3D listener
class CKs3dListener
    : public CMultiPan3dListener
{
    friend class CKsHw3dObject;
    friend class CKsItd3dObject;

protected:
    CList<CKsHw3dObject *>  m_lstHw3dObjects;       // List of hardware 3D objects
    BOOL                    m_fAllocated;           // Is the HW 3D listener allocated?

public:
    CKs3dListener(void);
    virtual ~CKs3dListener(void);

public:
    // Listener location
    virtual DWORD GetListenerLocation(void);

protected:
    // C3dListener overrides
    virtual HRESULT UpdateAllObjects(DWORD);

    // Properties
    virtual HRESULT SetProperty(REFGUID, ULONG, LPCVOID, ULONG);
};

inline DWORD CKs3dListener::GetListenerLocation(void)
{
    return DSBCAPS_LOCSOFTWARE | DSBCAPS_LOCHARDWARE;
}

// KS ITD software 3D object
class CKsItd3dObject
    : public CItd3dObject
{
private:
    CKsSecondaryRenderWaveBuffer *  m_pBuffer;              // Owning buffer object
    HANDLE                          m_hPin;                 // Pin handle
    ULONG                           m_ulNodeId;             // 3D node id
    BOOL                            m_fMute;                // Are we muting at max distance?

public:
    CKsItd3dObject(CKs3dListener *, BOOL, BOOL, DWORD, CKsSecondaryRenderWaveBuffer *, HANDLE, ULONG);
    virtual ~CKsItd3dObject(void);

protected:
    // Commiting 3D data to the device
    virtual HRESULT Commit3dChanges(void);

    // The final 3D output sample rate
    virtual DWORD Get3dOutputSampleRate(void);

private:
    virtual void CvtContext(LPOBJECT_ITD_CONTEXT, PKSDS3D_ITD_PARAMS);
};

// KS IIR 3D object
class CKsIir3dObject
    : public CIir3dObject
{
private:
    CKsSecondaryRenderWaveBuffer *  m_pBuffer;              // Owning buffer object
    HANDLE                          m_hPin;                 // Pin handle
    ULONG                           m_ulNodeId;             // 3D node id
    ULONG                           m_ulNodeCpuResources;   // 3D node CPU resources
    KSDS3D_HRTF_COEFF_FORMAT        m_eCoeffFormat;         // 3d IIR coefficient format.
    BOOL                            m_fMute;                // Are we muting at max distance?
    FLOAT                           m_flPrevAttenuation;    // Previous Attnuation
    FLOAT                           m_flPrevAttDistance;    // Previous Distance Attenuation


public:
    CKsIir3dObject(CKs3dListener *, REFGUID, BOOL, BOOL, DWORD, CKsSecondaryRenderWaveBuffer *, HANDLE, ULONG, ULONG);
    virtual ~CKsIir3dObject(void);

public:
    virtual HRESULT Initialize(void);

protected:
    // Commiting 3D data to the device
    virtual HRESULT Commit3dChanges(void);

private:
    // Desired Filter Coefficient Format
    virtual HRESULT GetFilterMethodAndCoeffFormat(KSDS3D_HRTF_FILTER_METHOD*,KSDS3D_HRTF_COEFF_FORMAT*);
    virtual HRESULT InitializeFilters(KSDS3D_HRTF_FILTER_QUALITY, FLOAT, ULONG, ULONG, ULONG, ULONG);
};

// KS hardware 3D object
class CKsHw3dObject
    : public CHw3dObject
{
    friend class CKs3dListener;

protected:
    CKs3dListener *         m_pKsListener;          // KS listener
    LPVOID                  m_pvInstance;           // Instance identifier
    ULONG                   m_ulNodeId;             // 3D node identifier
    CKsSecondaryRenderWaveBuffer * m_pBuffer;       // Owning buffer

public:
    CKsHw3dObject(CKs3dListener *, BOOL, BOOL, LPVOID, ULONG, CKsSecondaryRenderWaveBuffer *);
    virtual ~CKsHw3dObject(void);

public:
    // Initialization
    virtual HRESULT Initialize(void);

    // Object calculation
    virtual HRESULT Recalc(DWORD, DWORD);

protected:
    // Properties
    virtual HRESULT SetProperty(REFGUID, ULONG, LPCVOID, ULONG);

private:
    // Object calculation
    virtual HRESULT RecalcListener(DWORD);
    virtual HRESULT RecalcObject(DWORD);
};

#endif // __cplusplus

#endif // __KS3D_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\ksuserw.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:    DLL entry point
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   1/19/00    jimge   Created
 *
 ***************************************************************************/

#ifndef __KSUSERW__H_
#define __KSUSERW__H_

extern DWORD DsKsCreatePin(
    IN HANDLE           hFilter,
    IN PKSPIN_CONNECT   pConnect,
    IN ACCESS_MASK      dwDesiredAccess,
    OUT PHANDLE         pConnectionHandle);
    
extern VOID RemovePerProcessKsUser(
    DWORD dwProcessId);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\ksvad.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ksvad.cpp
 *  Content:    WDM/CSA Virtual Audio Device class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/25/97     dereks  Created
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifdef NOKS
#error ksvad.cpp being built with NOKS defined
#endif

#include "ksvad.h"      // Our public interface

// Default speaker index table; maps the first speaker (LEFT)
// to channel 0 and the second speaker (RIGHT) to channel 1.

INT CKsRenderDevice::m_anDefaultSpeakerIndexTable[] = {0, 1};


/***************************************************************************
 *
 *  CKsRenderDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::CKsRenderDevice"

CKsRenderDevice::CKsRenderDevice
(
    void
)
    : CRenderDevice(VAD_DEVICETYPE_KSRENDER), CKsDevice(VAD_DEVICETYPE_KSRENDER)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsRenderDevice);

    // Initialize defaults
    m_pPinCache = NULL;
    m_paTopologyInformation = NULL;
    m_pwfxFormat = NULL;
    m_nSrcQuality = DIRECTSOUNDMIXER_SRCQUALITY_DEFAULT;
    m_dwSpeakerConfig = -1;  // Invalid value; forces first SetSpeakerConfig() call to set it up
    m_hPin = NULL;
    m_liDriverVersion.QuadPart = 0;
    m_lSpeakerPositions = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
    m_ulChannelCount = 2;
    m_pnSpeakerIndexTable = m_anDefaultSpeakerIndexTable;
    m_ulPanNodeId = NODE_UNINITIALIZED;
    m_ulSurroundNodeId = NODE_UNINITIALIZED;
    m_ulDacNodeId = NODE_UNINITIALIZED;
    m_dwMinHwSampleRate = -1;
    m_dwMaxHwSampleRate = -1;
    m_fIncludeAec = FALSE;
    
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsRenderDevice
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::~CKsRenderDevice"

CKsRenderDevice::~CKsRenderDevice
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsRenderDevice);

    CLOSE_HANDLE(m_hPin);

    RELEASE(m_pPinCache);

    MEMFREE(m_paTopologyInformation);
    MEMFREE(m_pwfxFormat);
    if (m_pnSpeakerIndexTable != m_anDefaultSpeakerIndexTable)
        MEMFREE(m_pnSpeakerIndexTable);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the device.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: driver description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::Initialize"

HRESULT
CKsRenderDevice::Initialize
(
    CDeviceDescription *    pDesc
)
{
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    ASSERT(CDevice::m_vdtDeviceType == pDesc->m_vdtDeviceType);
    ASSERT(CKsDevice::m_vdtKsDevType == pDesc->m_vdtDeviceType);

    // Initialize the base classes
    hr = CKsDevice::Initialize(pDesc);

    if(SUCCEEDED(hr))
    {
        hr = CRenderDevice::Initialize(pDesc);
    }

    // Get topology information
    if(SUCCEEDED(hr))
    {
        m_paTopologyInformation = MEMALLOC_A(KSRDTOPOLOGY, m_ulPinCount);
        hr = HRFROMP(m_paTopologyInformation);
    }

    for(ULONG i = 0; i < m_ulValidPinCount && SUCCEEDED(hr); i++)
    {
        hr = GetTopologyInformation(m_paTopologies[m_pulValidPins[i]],
                                   &m_paTopologyInformation[m_pulValidPins[i]]);
    }

    // Order the valid pins from least-capable to most-capable (manbug 30402)
    if(SUCCEEDED(hr))
    {
        PULONG pulValidPinsCopy = MEMALLOC_A(ULONG, m_ulValidPinCount);
        hr = HRFROMP(pulValidPinsCopy);
        if(SUCCEEDED(hr))
        {
            CopyMemory(pulValidPinsCopy, m_pulValidPins, sizeof(ULONG) * m_ulValidPinCount);

            HRESULT hrTemp;
            ULONG i;
            int nCurSlot = 0;

            // Place the pins not capable of HW 3D first in the list
            for(i = 0; i < m_ulValidPinCount; i++)
            {
                hrTemp = ValidatePinCaps(m_pulValidPins[i], DSBCAPS_LOCHARDWARE|DSBCAPS_CTRL3D, GUID_NULL);
                if (FAILED(hrTemp))
                {
                    m_pulValidPins[nCurSlot++] = pulValidPinsCopy[i];
                    pulValidPinsCopy[i] = -1;
                }
            }

            // Now place all the others pins
            for(i = 0; i < m_ulValidPinCount; i++)
            {
                if (pulValidPinsCopy[i] != -1)
                {
                    m_pulValidPins[nCurSlot++] = pulValidPinsCopy[i];
                }
            }

            MEMFREE(pulValidPinsCopy);
        }
    }

    // Determine the Virtual Source Index which will be used to associate
    // each pin with the Wave Out master volume.
    if(SUCCEEDED(hr))
    {
        hr = KsCreateSysAudioVirtualSource(m_hDevice, &m_ulVirtualSourceIndex);

        if(FAILED(hr))
        {
            DPF(DPFLVL_ERROR, "Can't create virtual source");
        }
    }

    // Initialize the default format
    if(SUCCEEDED(hr))
    {
        m_pwfxFormat = AllocDefWfx();
        hr = HRFROMP(m_pwfxFormat);
    }

    // Create the pin cache
    if(SUCCEEDED(hr))
    {
        m_pPinCache = NEW(CKsRenderPinCache);
        hr = HRFROMP(m_pPinCache);
    }

    // Get the driver version number
    if(SUCCEEDED(hr))
    {
        GetDriverVersion(&m_liDriverVersion);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetCaps
 *
 *  Description:
 *      Fills a DSCAPS structure with the capabilities of the device.
 *
 *  Arguments:
 *      LPDSCAPS [out]: receives caps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::GetCaps"

HRESULT
CKsRenderDevice::GetCaps
(
    LPDSCAPS                pCaps
)
{
    BOOL                    fHardwareRenderer   = TRUE;
    HRESULT                 hr                  = DS_OK;
    KSDATARANGE_AUDIO       DataRange;
    KSPIN_CINSTANCES        PinInstances;
    KSPIN_CINSTANCES        ThreedPinInstances;

    DPF_ENTER();

    ASSERT(sizeof(*pCaps) == pCaps->dwSize);

    // Get caps for the hardware renderer
    hr = GetKsDeviceCaps(DSBCAPS_LOCHARDWARE, GUID_NULL, &DataRange, &PinInstances, &ThreedPinInstances);

    // If we failed to find a hardware renderer, go ahead and get software caps
    if(S_FALSE == hr)
    {
        DPF(DPFLVL_MOREINFO, "No hardware renderer found.  Getting software renderer caps");
        fHardwareRenderer = FALSE;
        hr = GetKsDeviceCaps(DSBCAPS_LOCSOFTWARE, GUID_NULL, &DataRange, &PinInstances, &ThreedPinInstances);
    }

    if(S_FALSE == hr)
    {
        DPF(DPFLVL_ERROR, "No usable renderer found!");
        ASSERT(S_FALSE != hr);
        hr = DSERR_NODRIVER;
    }

    // Fill out caps structure
    if(SUCCEEDED(hr))
    {
        ZeroMemoryOffset(pCaps, pCaps->dwSize, sizeof(pCaps->dwSize));

#pragma TODO("We should qualify whether or not the driver really does support CONTINUOUSRATE")

        pCaps->dwFlags = DSCAPS_CONTINUOUSRATE;

        if(DataRange.MaximumChannels >= 1)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARYMONO | DSCAPS_SECONDARYMONO;
        }

        if(DataRange.MaximumChannels >= 2)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARYSTEREO | DSCAPS_SECONDARYSTEREO;
        }

        if(DataRange.MinimumBitsPerSample <= 8 && DataRange.MaximumBitsPerSample >= 8)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARY8BIT | DSCAPS_SECONDARY8BIT;
        }

        if(DataRange.MinimumBitsPerSample <= 16 && DataRange.MaximumBitsPerSample >= 16)
        {
            pCaps->dwFlags |= DSCAPS_PRIMARY16BIT | DSCAPS_SECONDARY16BIT;
        }

        pCaps->dwMinSecondarySampleRate = DataRange.MinimumSampleFrequency;
        pCaps->dwMaxSecondarySampleRate = DataRange.MaximumSampleFrequency;

        // Cache this data for use by GetFrequencyRange()
        m_dwMinHwSampleRate = pCaps->dwMinSecondarySampleRate;
        m_dwMaxHwSampleRate = pCaps->dwMaxSecondarySampleRate;

        if(fHardwareRenderer)
        {
            pCaps->dwMaxHwMixingAllBuffers  = pCaps->dwMaxHwMixingStaticBuffers  = pCaps->dwMaxHwMixingStreamingBuffers  = PinInstances.PossibleCount;
            pCaps->dwFreeHwMixingAllBuffers = pCaps->dwFreeHwMixingStaticBuffers = pCaps->dwFreeHwMixingStreamingBuffers = PinInstances.PossibleCount - PinInstances.CurrentCount;
            pCaps->dwMaxHw3DAllBuffers      = pCaps->dwMaxHw3DStaticBuffers      = pCaps->dwMaxHw3DStreamingBuffers      = ThreedPinInstances.PossibleCount;
            pCaps->dwFreeHw3DAllBuffers     = pCaps->dwFreeHw3DStaticBuffers     = pCaps->dwFreeHw3DStreamingBuffers     = ThreedPinInstances.PossibleCount - ThreedPinInstances.CurrentCount;
        }

        pCaps->dwReserved1 = m_liDriverVersion.LowPart;
        pCaps->dwReserved2 = m_liDriverVersion.HighPart;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetFrequencyRange
 *
 *  Description:
 *      Obtains this device's minimum and maximum supported frequencies.
 *      Caches this information to avoid repeated calls to GetCaps().
 *
 *  Arguments:
 *      LPDWORD [out]: 
 *      LPDWORD [out]: 
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::GetFrequencyRange"

HRESULT CKsRenderDevice::GetFrequencyRange(LPDWORD pdwMinHwSampleRate, LPDWORD pdwMaxHwSampleRate)
{
    HRESULT hr = DSERR_GENERIC;
    DPF_ENTER();

    ASSERT(pdwMinHwSampleRate && pdwMaxHwSampleRate);

    if (m_dwMinHwSampleRate == -1)
    {
        DSCAPS dscaps;
        InitStruct(&dscaps, sizeof dscaps);
        GetCaps(&dscaps);
    }

    if (m_dwMinHwSampleRate != -1)
    {
        *pdwMinHwSampleRate = m_dwMinHwSampleRate;
        *pdwMaxHwSampleRate = m_dwMaxHwSampleRate;
        hr = DS_OK;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetKsDeviceCaps
 *
 *  Description:
 *      Gets capabilities for the underlying KS device.
 *
 *  Arguments:
 *      DWORD [in]: device location flags.
 *      REFGUID [in]: 3D algorithm identifier.
 *      PKSDATARANGE_AUDIO [out]: receives aggregate dataranges for all
 *                                pins.
 *      PKSPIN_CINSTANCES [out]: receives aggregate instance count of
 *                               pins.
 *      PKSPIN_CINSTANCES [out]: receives aggregate instance count of
 *                               3D pins.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::GetKsDeviceCaps"

HRESULT
CKsRenderDevice::GetKsDeviceCaps
(
    DWORD                   dwLocation,
    REFGUID                 guid3dAlgorithm,
    PKSDATARANGE_AUDIO      pAggregateDataRange,
    PKSPIN_CINSTANCES       pAggregatePinInstances,
    PKSPIN_CINSTANCES       pAggregateThreedPinInstances
)
{
    HRESULT                 hr                          = S_FALSE;
    KSDATARANGE_AUDIO       DataRange;
    PKSDATARANGE_AUDIO      pDataRange;
    KSPIN_CINSTANCES        PinInstances;
    PKSPIN_CINSTANCES       pPinInstances;
    KSPIN_CINSTANCES        ThreedPinInstances;
    PKSPIN_CINSTANCES       pThreedPinInstances;
    HRESULT                 hrTemp;

    DPF_ENTER();

    ASSERT(DSBCAPS_LOCSOFTWARE == dwLocation || DSBCAPS_LOCHARDWARE == dwLocation);

    ZeroMemory(pAggregateDataRange, sizeof(*pAggregateDataRange));
    ZeroMemory(pAggregatePinInstances, sizeof(*pAggregatePinInstances));
    ZeroMemory(pAggregateThreedPinInstances, sizeof(*pAggregateThreedPinInstances));

    pDataRange = pAggregateDataRange;
    pPinInstances = pAggregatePinInstances;
    pThreedPinInstances = pAggregateThreedPinInstances;

    // Get the audio data ranges and number of pins for all valid pins
    for(ULONG i = 0; i < m_ulValidPinCount; i++)
    {
        // Qualify the basic pin capabilities
        hrTemp = ValidatePinCaps(m_pulValidPins[i], dwLocation, guid3dAlgorithm);
        if(FAILED(hrTemp))
            continue;

        // Get audio datarange
        hr = KsGetPinPcmAudioDataRange(m_hDevice, m_pulValidPins[i], pDataRange);
        if(FAILED(hr))
            continue;

        if(pAggregateDataRange == pDataRange)
            pDataRange = &DataRange;
        else
            KsAggregatePinAudioDataRange(pDataRange, pAggregateDataRange);

        // Are we allowed to look for 2D pins?
        if((DSBCAPS_LOCHARDWARE == dwLocation) && (m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWBUFFERS))
            continue;

        // Get 2D pin instances. On WDM 1.0, fall back on the sysaudio property
        // to ask how many there really are
        hr = (g_ulWdmVersion == WDM_1_0) ? KsGetRenderPinInstances(m_hDevice, m_pulValidPins[i], pPinInstances)
                                         : KsGetPinInstances(m_hDevice, m_pulValidPins[i], pPinInstances);
        if(FAILED(hr))
            break;

        if(pAggregatePinInstances == pPinInstances)
            pPinInstances = &PinInstances;
        else
            KsAggregatePinInstances(pPinInstances, pAggregatePinInstances);

        // Are we allowed to look for 3D pins?
        if((DSBCAPS_LOCHARDWARE == dwLocation) && (m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHW3D))
            continue;

        // Does the device even support 3D?
        hrTemp = ValidatePinCaps(m_pulValidPins[i], dwLocation | DSBCAPS_CTRL3D, GUID_NULL);
        if(FAILED(hrTemp))
            continue;

        // Get 3D pin instances
        hr = KsGetPinInstances(m_hDevice, m_pulValidPins[i], pThreedPinInstances);
        if(FAILED(hr))
            break;

        if(pAggregateThreedPinInstances == pThreedPinInstances)
            pThreedPinInstances = &ThreedPinInstances;
        else
            KsAggregatePinInstances(pThreedPinInstances, pAggregateThreedPinInstances);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreatePrimaryBuffer
 *
 *  Description:
 *      Creates a primary buffer object.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *      LPVOID [in]: buffer instance identifier.
 *      CPrimaryRenderWaveBuffer ** [out]: receives pointer to primary
 *                                         buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::CreatePrimaryBuffer"

HRESULT
CKsRenderDevice::CreatePrimaryBuffer
(
    DWORD                       dwFlags,
    LPVOID                      pvInstance,
    CPrimaryRenderWaveBuffer ** ppBuffer
)
{
    CKsPrimaryRenderWaveBuffer *pBuffer;
    HRESULT                     hr;

    DPF_ENTER();

    pBuffer = NEW(CKsPrimaryRenderWaveBuffer(this, pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(dwFlags);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateSecondaryBuffer
 *
 *  Description:
 *      Creates a wave buffer.
 *
 *  Arguments:
 *      LPVADRBUFFERDESC [in]: buffer description.
 *      LPVOID [in]: buffer instance identifier.
 *      CSecondaryRenderWaveBuffer ** [out]: receives pointer to new wave
 *                                           buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::CreateSecondaryBuffer"

HRESULT
CKsRenderDevice::CreateSecondaryBuffer
(
    LPCVADRBUFFERDESC               pDesc,
    LPVOID                          pvInstance,
    CSecondaryRenderWaveBuffer **   ppBuffer
)
{
    CKsSecondaryRenderWaveBuffer *  pBuffer;
    HRESULT                         hr;

    DPF_ENTER();

    pBuffer = NEW(CKsSecondaryRenderWaveBuffer(this, pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(pDesc, NULL);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateKsSecondaryBuffer
 *
 *  Description:
 *      Creates a wave buffer.
 *
 *  Arguments:
 *      LPVADRBUFFERDESC [in]: buffer description.
 *      LPVOID [in]: buffer instance identifier.
 *      CSecondaryRenderWaveBuffer ** [out]: receives pointer to new wave
 *                                           buffer.
 *      CSysMemBuffer * [in]: System memory buffer to use.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::CreateKsSecondaryBuffer"

HRESULT
CKsRenderDevice::CreateKsSecondaryBuffer
(
    LPCVADRBUFFERDESC               pDesc,
    LPVOID                          pvInstance,
    CSecondaryRenderWaveBuffer **   ppBuffer,
    CSysMemBuffer *                 pSysMemBuffer
)
{
    CKsSecondaryRenderWaveBuffer *  pBuffer;
    HRESULT                         hr;

    DPF_ENTER();

    pBuffer = NEW(CKsSecondaryRenderWaveBuffer(this, pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(pDesc, NULL, pSysMemBuffer);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetGlobalFormat
 *
 *  Description:
 *      Retrieves the format for the device.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [out]: receives format.
 *      LPDWORD [in/out]: size of the above format.  On entry, this argument
 *                        contains the size of the buffer.  On exit, this
 *                        contains the required size of the buffer.  Call
 *                        this function twice: once to get the size, and
 *                        again to get the actual data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::GetGlobalFormat"

HRESULT
CKsRenderDevice::GetGlobalFormat
(
    LPWAVEFORMATEX          pwfxFormat,
    LPDWORD                 pdwSize
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = CopyWfxApi(m_pwfxFormat, pwfxFormat, pdwSize);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetGlobalFormat
 *
 *  Description:
 *      Sets the format for the device.
 *
 *  Arguments:
 *      LPWAVEFORMATEX [in]: new format, or NULL to reapply the current
 *                           format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::SetGlobalFormat"

HRESULT
CKsRenderDevice::SetGlobalFormat
(
    LPCWAVEFORMATEX                     pwfxFormat
)
{
    LPWAVEFORMATEX                      pwfxOld = m_pwfxFormat;
    CNode<CPrimaryRenderWaveBuffer *> * pNode;
    HRESULT                             hr;

    DPF_ENTER();

    // Save a copy of the new format
    m_pwfxFormat = CopyWfxAlloc(pwfxFormat);
    hr = HRFROMP(m_pwfxFormat);

    // Update all primary buffers
    for(pNode = m_lstPrimaryBuffers.GetListHead(); pNode && SUCCEEDED(hr); pNode = pNode->m_pNext)
    {
        hr = ((CKsPrimaryRenderWaveBuffer *)pNode->m_data)->OnSetFormat();
    }

    // Clean up
    if(SUCCEEDED(hr))
    {
        MEMFREE(pwfxOld);
    }
    else
    {
        MEMFREE(m_pwfxFormat);
        m_pwfxFormat = pwfxOld;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetSrcQuality
 *
 *  Description:
 *      Sets the mixer's SRC quality.
 *
 *  Arguments:
 *      DIRECTSOUNDMIXER_SRCQUALITY [in]: mixer SRC quality.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::SetSrcQuality"

HRESULT
CKsRenderDevice::SetSrcQuality
(
    DIRECTSOUNDMIXER_SRCQUALITY             SrcQuality
)
{
    CNode<CSecondaryRenderWaveBuffer *> *   pNode;

    DPF_ENTER();

    // Update all existing buffers.  We don't care if they succeed or not.
    for(pNode = m_lstSecondaryBuffers.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        ((CKsSecondaryRenderWaveBuffer *)pNode->m_data)->SetSrcQuality(SrcQuality);
    }

    // Save the new SRC quality as the default
    m_nSrcQuality = SrcQuality;

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  SetSpeakerConfig
 *
 *  Description:
 *      Tries to set the device's speaker configuration.  If successful,
 *      stores it in m_dwSpeakerConfig.  Some pseudocode follows:
 *
 *      1. If no pins have yet been instantiated: set the config and geometry
 *      on the DAC node, if found. (Assumes that this node can only be found
 *      on the driver.)  (If the config is Surround and the card has a Dolby
 *      encoder, this should force the card into 4-channel mode.)
 *
 *      2. If no pins instantiated: if the speaker config is Surround, try to
 *      enable kmixer's encoder.  (Will fail if the card's in 4-channel mode,
 *      which is correct.)
 *
 *      3. If pins instantiated: read the pan node's channel config, and see
 *      if it supports the requested spk. config - otherwise, fail the call.
 *
 *      Usage A: When dsound opens a KS device, SetSpeakerConfig() gets called
 *      twice (once before any pins are instantiated, once after), so if all
 *      goes well the second call should succeed.
 *
 *      Usage B: When an app calls the API's SetSpeakerConfig(), the KS device
 *      must already be open, hence the call will fail unless we're already in
 *      the configuration requested - which is correct.  (I'm not about to try
 *      to tear down all the pins, change the config and recreate them - apart
 *      from the glitching involved, this isn't guaranteed to work anyway,
 *      since most drivers can't change mode if ANY streams are active on them,
 *      including non-dsound ones.)  This API call always changes the config in
 *      the registry and returns DS_OK, even if it fails, so next time dsound
 *      starts up another attempt will be made to set the config.
 *
 *      The astute reader will have noticed a flaw in all this: if we enable
 *      kmixer's surround encoder, and the app creates a Pan3D buffer which
 *      happens to get a HW-accelerated pin, we'll only have two channels to
 *      play with, not four.  To handle this, CreateMultiPan3dObject() checks
 *      the supermix table on the pin, and if it doesn't have the expected no.
 *      of outputs we drop down to stereo Pan3D.
 *
 *  Arguments:
 *      DWORD [in]: speaker configuration in dsound DSSPEAKER format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::SetSpeakerConfig"

HRESULT CKsRenderDevice::SetSpeakerConfig(DWORD dwReqSpeakerConfig)
{
    LONG lKsSpeakerConfig;
    LONG lKsStereoSpeakerGeometry;
    HRESULT hr, hrTemp;
    DPF_ENTER();

    DPF(DPFLVL_MOREINFO, "Current configuration is 0x%8.8lX; requested 0x%8.8lX; %s created",
        m_dwSpeakerConfig, dwReqSpeakerConfig, m_hPin ? TEXT("some pins already") : TEXT("no pins yet"));

    // First let the base class do its thing
    hr = CRenderDevice::SetSpeakerConfig(dwReqSpeakerConfig);

    // Only do any work if the speaker config is changing
    if (SUCCEEDED(hr) && (dwReqSpeakerConfig != m_dwSpeakerConfig))
    {
        DsSpeakerConfigToKsProperties(dwReqSpeakerConfig, &lKsSpeakerConfig, &lKsStereoSpeakerGeometry);

        // Inform the driver (via its DAC node) of the speaker config change.
        // This will fail (harmlessly) on some cards with DS3D acceleration,
        // which expect this info on the 3D node of a specific pin instance;
        // these cards will be handled by the legacy code in ks3d.cpp.
        if (IS_VALID_NODE(m_ulDacNodeId))  // We found a DAC node
        {
            hrTemp = KsSetNodeProperty(m_hDevice, KSPROPSETID_Audio, KSPROPERTY_AUDIO_CHANNEL_CONFIG,
                                       m_ulDacNodeId, &lKsSpeakerConfig, sizeof lKsSpeakerConfig);
            DPF(DPFLVL_MOREINFO, "Setting the CHANNEL_CONFIG property on the DAC returned %s", HRESULTtoSTRING(hrTemp));

            // NOTE: if the speaker config is Surround, and the card supports it, this call will succeed
            // and set up a >2 channel config on the card, which will make kmixer refuse to enable its
            // surround node below; that should make multichannel Pan3D work fine, so all is well.

            if (SUCCEEDED(hrTemp) && lKsSpeakerConfig == KSAUDIO_SPEAKER_STEREO)
            {
                // In this case, we should set the speaker "geometry" (angular separation) too.
                hrTemp = KsSetNodeProperty(m_hDevice, KSPROPSETID_Audio, KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
                                           m_ulDacNodeId, &lKsStereoSpeakerGeometry, sizeof lKsStereoSpeakerGeometry);
                DPF(DPFLVL_MOREINFO, "Setting the SPEAKER_GEOMETRY property on the DAC returned %s", HRESULTtoSTRING(hrTemp));
            }

            // NOTE 2: we don't care whether these calls succeed or fail (either because the driver
            // doesn't support them, or because it has active streams and can't reconfigure itself);
            // what matters is whether the card ends up in the requested speaker, and we check this
            // below, indirectly, by looking at kmixer's output format.
        }

        // Enable of disable the Prologic surround encoder node in KMixer if necessary.
        // This only works if no pins have yet been instantiated.
        if (IS_VALID_NODE(m_ulSurroundNodeId) &&            // We have a Surround node...
            (m_hPin == NULL) &&                             // No pins have been created yet...
            (m_dwSpeakerConfig == -1 ||                     // We haven't got a speaker config yet...
            ((dwReqSpeakerConfig == DSSPEAKER_SURROUND) !=  // or the surround state is changing
             (m_dwSpeakerConfig == DSSPEAKER_SURROUND))))
        {
            BOOL fEnable = (dwReqSpeakerConfig == DSSPEAKER_SURROUND);
            hrTemp = KsSetNodeProperty(m_hDevice, KSPROPSETID_Audio, KSPROPERTY_AUDIO_SURROUND_ENCODE,
                                       m_ulSurroundNodeId, &fEnable, sizeof fEnable);

            DPF(FAILED(hrTemp) ? DPFLVL_WARNING : DPFLVL_MOREINFO,
                "%sabling KMixer's Surround encoder returned %s (failure expected on Win2K)",
                fEnable ? TEXT("En") : TEXT("Dis"), HRESULTtoSTRING(hrTemp));
        }

        // Ask the pan node (immediately after supermix) for its channel positions table.
        // This can only work if some pin has been instantiated - any will do; we use m_hPin.
        if (IS_VALID_NODE(m_ulPanNodeId) && (m_hPin != NULL))
        {
            KSAUDIO_CHANNEL_CONFIG ChannelConfig;
            hr = KsGetNodeProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_CHANNEL_CONFIG,
                                   m_ulPanNodeId, &ChannelConfig, sizeof ChannelConfig);
            if (FAILED(hr))
            {
                DPF(DPFLVL_WARNING, "Failed to obtain the pan node's channel config (%s)", HRESULTtoSTRING(hr));
            }
            else // Save the channel positions, to support SetChannelVolume()
            {
                if (m_pnSpeakerIndexTable != m_anDefaultSpeakerIndexTable)
                    MEMFREE(m_pnSpeakerIndexTable);
                m_pnSpeakerIndexTable = MEMALLOC_A(int, MAX_SPEAKER_POSITIONS);
                hr = HRFROMP(m_pnSpeakerIndexTable);

                if (FAILED(hr))
                    m_pnSpeakerIndexTable = m_anDefaultSpeakerIndexTable;
                else
                {
                    m_lSpeakerPositions = ChannelConfig.ActiveSpeakerPositions;
                    m_ulChannelCount = 0;
                    int nIndex = 0;

                    for (LONG lSpkr = 1; lSpkr != SPEAKER_ALL; lSpkr <<= 1)
                        m_pnSpeakerIndexTable[nIndex++] = (m_lSpeakerPositions & lSpkr) ? m_ulChannelCount++ : -1;
                    ASSERT(m_ulChannelCount == ULONG(CountBits(m_lSpeakerPositions)));

                    // Figure out if our channel positions now match the requested speaker config
                    if (m_lSpeakerPositions == lKsSpeakerConfig)
                    {
                        // Success; update our copy of the speaker configuration
                        m_dwSpeakerConfig = dwReqSpeakerConfig;
                    }
                    else
                    {
                        DPF(DPFLVL_WARNING, "Pan node's channel config (0x%lX) doesn't match requested config (0x%lX)",
                            m_lSpeakerPositions, lKsSpeakerConfig);
                    }

                    // FIXME: for now we require a perfect match between our
                    // desired speaker config and the real channel config.
                    // Later on we could allow cases in which the former is
                    // a subset of the latter, but we'd have to maintain a
                    // mapping from our speaker positions to KS's channels.
                }
            }
        }

        // Finally, make sure we return a useful return code
        if (SUCCEEDED(hr) && (m_dwSpeakerConfig != dwReqSpeakerConfig))
        {
            hr = DSERR_CONTROLUNAVAIL;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CreateRenderPin
 *
 *  Description:
 *      Creates a pin.
 *
 *  Arguments:
 *      ULONG [in]: pin id.
 *      DWORD [in]: buffer flags.
 *      LPCWAVEFORMATEX [in]: pin format.
 *      REFGUID [in]: pin 3D algorithm.
 *      LPHANDLE [out]: receives pin handle.
 *      PULONG [out]: receives pin id.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::CreateRenderPin"

HRESULT
CKsRenderDevice::CreateRenderPin
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    LPHANDLE                phPin,
    PULONG                  pulPinId
)
{
#ifdef NO_DSOUND_FORMAT_SPECIFIER
    PKSAUDIOPINDESC         pPinDesc    = NULL;
#else
    LPVOID                  pPinDesc    = NULL;
#endif

    HANDLE                  hPin        = NULL;
    HRESULT                 hr;
    PKSPIN_CONNECT          pConnect    = NULL;

    DPF_ENTER();

    // If no pin id was specified, we'll try each pin id until one succeeds

    if(-1 == ulPinId)
    {
        hr = DSERR_NODRIVER;
        for(ULONG i = 0; i < m_ulValidPinCount && FAILED(hr); i++)
            hr = CreateRenderPin(m_pulValidPins[i], dwFlags, pwfxFormat, guid3dAlgorithm, phPin, pulPinId);
    }
    else
    {
        // Validate that the pin id is capable of creating this pin
        hr = ValidatePinCaps(ulPinId, dwFlags, guid3dAlgorithm);

        // If specified, make sysaudio include AEC in the render graph
        if(SUCCEEDED(hr) && m_fIncludeAec)
        {
            // Validate that the pin id is capable of creating this pin
            hr = m_paTopologies[ulPinId]->FindRenderPinWithAec
                 (
                     phPin,
                     NULL,
                     NULL,
                     m_guidAecInstance,
                     m_dwAecFlags,
                     &m_paTopologyInformation[ulPinId].AecNode
                 );

            if(SUCCEEDED(hr) && IS_VALID_NODE(m_paTopologyInformation[ulPinId].AecNode.NodeId))
            {
                hr = KsSysAudioSelectGraph
                     (
                         m_hDevice,
                         ulPinId,
                         m_paTopologyInformation[ulPinId].AecNode.NodeId
                     );

                if(FAILED(hr))
                {
                    DPF(DPFLVL_ERROR, "Unable to set SysAudio device instance");

                    // If KsSysAudioSelectGraph() fails, we assume that it is
                    // because the graph has already been built without AEC,
                    // and return a useful return code:
                    hr = DSERR_FXUNAVAILABLE;
                }
            }
        }

        // Build the pin description
        if(SUCCEEDED(hr))
        {
#ifdef NO_DSOUND_FORMAT_SPECIFIER

            hr = KsBuildRenderPinDescription(ulPinId, pwfxFormat, &pPinDesc);
            pConnect = &pPinDesc->Connect;

#else // NO_DSOUND_FORMAT_SPECIFIER

            if (g_ulWdmVersion == WDM_1_0)
            {
                hr = KsBuildRenderPinDescription_10(ulPinId, dwFlags, pwfxFormat, guid3dAlgorithm, (PKSDSRENDERPINDESC_10 *)&pPinDesc);
                pConnect = &((PKSDSRENDERPINDESC_10)pPinDesc)->Connect;
            }
            else
            {
                hr = KsBuildRenderPinDescription(ulPinId, dwFlags, pwfxFormat, guid3dAlgorithm, (PKSDSRENDERPINDESC *)&pPinDesc);
                pConnect = &((PKSDSRENDERPINDESC)pPinDesc)->Connect;
            }

#endif // NO_DSOUND_FORMAT_SPECIFIER

        }

        // Create the pin
        if(SUCCEEDED(hr))
        {
            hr = CreatePin(pConnect, GENERIC_WRITE, KSSTATE_STOP, &hPin);
        }

        if(SUCCEEDED(hr))
        {
            if(!MakeHandleGlobal(&hPin))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }

#ifdef NO_DSOUND_FORMAT_SPECIFIER

        // Enable required nodes
        if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRL3D))
        {
            hr = KsEnableTopologyNode(hPin, m_paTopologyInformation[ulPinId].ThreedNode.NodeId, TRUE);
        }

        if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLFREQUENCY))
        {
            hr = KsEnableTopologyNode(hPin, m_paTopologyInformation[ulPinId].SrcNode.NodeId, TRUE);
        }

        if(SUCCEEDED(hr) && (dwFlags & (DSBCAPS_CTRLPAN
#ifdef FUTURE_MULTIPAN_SUPPORT
            | DSBCAPS_CTRLCHANNELVOLUME
#endif
            )))
        {
            hr = KsEnableTopologyNode(hPin, m_paTopologyInformation[ulPinId].PanNode.Node.NodeId, TRUE);
        }

        if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLVOLUME))
        {
            hr = KsEnableTopologyNode(hPin, m_paTopologyInformation[ulPinId].VolumeNode.Node.NodeId, TRUE);
        }

        // Tell the 3D node which algorithm to use

#pragma TODO("Tell the 3D node which algorithm to use")

#endif // NO_DSOUND_FORMAT_SPECIFIER

        // Transition the pin to the pause state
        if(SUCCEEDED(hr))
        {
            hr = KsTransitionState(hPin, KSSTATE_STOP, KSSTATE_PAUSE);
        }

        // Success
        if(SUCCEEDED(hr))
        {
            *phPin = hPin;

            if(pulPinId)
            {
                *pulPinId = pConnect->PinId;
            }
        }
        else
        {
            CLOSE_HANDLE(hPin);
        }

        MEMFREE(pPinDesc);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetTopologyInformation
 *
 *  Description:
 *      Gets topology information.
 *
 *  Arguments:
 *      CKsDeviceTopology * [in]: topology object.
 *      PKSRDTOPOLOGY [out]: receives topology information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::GetTopologyInformation"

HRESULT
CKsRenderDevice::GetTopologyInformation
(
    CKsTopology *           pTopology,
    PKSRDTOPOLOGY           pInfo
)
{
    PKSTOPOLOGY_CONNECTION  pSummingConnection;
    PKSTOPOLOGY_CONNECTION  pSuperMixerConnection;
    PKSTOPOLOGY_CONNECTION  pSrcConnection;
    PKSTOPOLOGY_CONNECTION  pVolumeConnection;
    PKSTOPOLOGY_CONNECTION  pPanConnection;
    PKSTOPOLOGY_CONNECTION  pThreedConnection;
    PKSTOPOLOGY_CONNECTION  pMuteConnection;
    PKSTOPOLOGY_CONNECTION  pSurroundConnection;
    PKSTOPOLOGY_CONNECTION  pDacConnection;
    HRESULT                 hr;

    DPF_ENTER();

    // Find topology nodes
    pSummingConnection = pTopology->FindControlConnection(NULL, NULL, KSNODETYPE_SUM);
    pSuperMixerConnection = pTopology->FindControlConnection(NULL, pSummingConnection, KSNODETYPE_SUPERMIX);
    pSrcConnection = pTopology->FindControlConnection(NULL, pSummingConnection, KSNODETYPE_SRC);
    pVolumeConnection = pTopology->FindControlConnection(NULL, pSummingConnection, KSNODETYPE_VOLUME);
    pPanConnection = pTopology->FindControlConnection(pSuperMixerConnection, pSummingConnection, KSNODETYPE_VOLUME);
    pThreedConnection = pTopology->FindControlConnection(NULL, pSummingConnection, KSNODETYPE_3D_EFFECTS);
    pMuteConnection = pTopology->FindControlConnection(NULL, pSummingConnection, KSNODETYPE_MUTE);
    pSurroundConnection = pTopology->FindControlConnection(NULL, NULL, KSNODETYPE_SURROUND_ENCODER);
    pDacConnection = pTopology->FindControlConnection(NULL, NULL, KSNODETYPE_DAC);

    // Fill in data about each node
    hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pSummingConnection), &pInfo->SummingNode);

    if(SUCCEEDED(hr))
    {
        hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pSuperMixerConnection), &pInfo->SuperMixNode);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pSrcConnection), &pInfo->SrcNode);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetVolumeNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pVolumeConnection), &pInfo->VolumeNode);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetVolumeNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pPanConnection), &pInfo->PanNode);

        // This code is a little odd. We have as many CKsTopology objects as valid pins,
        // all identical except for the m_ulPinId member; and m_ulPinCount KSRDTOPOLOGY
        // structs, most of which are never filled in. Pending a full rewrite, we store
        // the node IDs we need to use in CKsRenderDevice in this hackish manner:
        if (IS_VALID_NODE(pInfo->PanNode.Node.NodeId) && pInfo->PanNode.Node.CpuResources == KSAUDIO_CPU_RESOURCES_HOST_CPU)
        {
            if (m_ulPanNodeId == NODE_UNINITIALIZED)
            {
                m_ulPanNodeId = pInfo->PanNode.Node.NodeId;
                DPF(DPFLVL_MOREINFO, "Found kmixer's pan node id: %d", m_ulPanNodeId);
            }
            else
            {
                // Complain if we find two different SW pan nodes in the topology
                ASSERT(m_ulPanNodeId == pInfo->PanNode.Node.NodeId);
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pThreedConnection), &pInfo->ThreedNode);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pMuteConnection), &pInfo->MuteNode);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pSurroundConnection), &pInfo->SurroundNode);

        // Bogus code follows - see comment above
        if (IS_VALID_NODE(pInfo->SurroundNode.NodeId) && pInfo->SurroundNode.CpuResources != KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU)
        {
            // We don't use "CpuResources == KSAUDIO_CPU_RESOURCES_HOST_CPU" because kmixer
            // appears not to support KSPROPERTY_AUDIO_CPU_RESOURCES on its surround node.
            if (m_ulSurroundNodeId == NODE_UNINITIALIZED)
            {
                m_ulSurroundNodeId = pInfo->SurroundNode.NodeId;
                DPF(DPFLVL_MOREINFO, "Found kmixer's Surround node id: %d", m_ulSurroundNodeId);
            }
            else
            {
                // Complain if we find 2 different SW surround nodes in the topology
                ASSERT(m_ulSurroundNodeId == pInfo->SurroundNode.NodeId);
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetNodeInformation(m_hDevice, pTopology->GetNodeIdFromConnection(pDacConnection), &pInfo->DacNode);

        // Bogus code follows - see comment above
        if (IS_VALID_NODE(pInfo->DacNode.NodeId) && pInfo->DacNode.CpuResources != KSAUDIO_CPU_RESOURCES_HOST_CPU)
        {
            if (m_ulDacNodeId == NODE_UNINITIALIZED)
            {
                m_ulDacNodeId = pInfo->DacNode.NodeId;
                DPF(DPFLVL_MOREINFO, "Found driver's DAC node id: %d", m_ulDacNodeId);
            }
            else
            {
                // Complain if we find two different DACs on the card
                ASSERT(m_ulDacNodeId == pInfo->DacNode.NodeId);
            }
        }
    }

    // Set the AecNode to UNITIALIZED since we cannot determine the
    // NodeId and the CpuResources until the FullDuplexObject is created.
    if(SUCCEEDED(hr))
    {
        pInfo->AecNode.NodeId = NODE_UNINITIALIZED;
        pInfo->AecNode.CpuResources = KSAUDIO_CPU_RESOURCES_UNINITIALIZED;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  ValidatePinCaps
 *
 *  Description:
 *      Validates that certain capabilities of the pin are implemented.
 *
 *  Arguments:
 *      ULONG [in]: pin id.
 *      DWORD [in]: buffer flags.
 *      REFGUID [in]: 3D algorithm.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::ValidatePinCaps"

HRESULT
CKsRenderDevice::ValidatePinCaps
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    REFGUID                 guid3dAlgorithm
)
{
    ULONG                   ulInvalidCpuResources   = KSAUDIO_CPU_RESOURCES_UNINITIALIZED;
    HRESULT                 hr                      = DS_OK;

    DPF_ENTER();

    ASSERT(IS_VALID_READ_PTR(m_paTopologyInformation, (ulPinId+1) * sizeof *m_paTopologyInformation));
    if (!m_paTopologyInformation)
    {
        // This should never happen, but it has happened, in stress.
        // So we treat the symptom and at least don't GPF (OSR 139942).
        hr = DSERR_GENERIC;
    }

    // Determine which CPU resource identifier is invalid.  We look for an
    // invalid identifier instead of a valid identifier because the node
    // may not actually exist (or may not support KSPROPERTY_AUDIO_CPU_RESOURCES).
    // If we don't have any resource information about the node, we assume
    // the best.

    if (SUCCEEDED(hr))
    {
        if(dwFlags & DSBCAPS_LOCHARDWARE)
        {
            ulInvalidCpuResources = KSAUDIO_CPU_RESOURCES_HOST_CPU;
        }
        else if(dwFlags & DSBCAPS_LOCSOFTWARE)
        {
            ulInvalidCpuResources = KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU;
        }

        // Check required mixer resources
        if(KSAUDIO_CPU_RESOURCES_UNINITIALIZED != ulInvalidCpuResources)
        {
            if(ulInvalidCpuResources == m_paTopologyInformation[ulPinId].SummingNode.CpuResources)
            {
                DPF(DPFLVL_INFO, "Pin %d: Invalid CPU resources on summing node (%s)", ulPinId,
                    m_paTopologyInformation[ulPinId].SummingNode.CpuResources == KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU ? TEXT("NOT_HOST_CPU") :
                    m_paTopologyInformation[ulPinId].SummingNode.CpuResources == KSAUDIO_CPU_RESOURCES_HOST_CPU ? TEXT("HOST_CPU") :
                    m_paTopologyInformation[ulPinId].SummingNode.CpuResources == KSAUDIO_CPU_RESOURCES_UNINITIALIZED ? TEXT("uninitialized") :
                    TEXT("impossible value!"));
                hr = DSERR_INVALIDCALL;
            }
        }
    }

    // Check required SRC resources
    if(SUCCEEDED(hr) && KSAUDIO_CPU_RESOURCES_UNINITIALIZED != ulInvalidCpuResources)
    {
        if(ulInvalidCpuResources == m_paTopologyInformation[ulPinId].SrcNode.CpuResources)
        {
            DPF(DPFLVL_INFO, "Pin %d: Invalid CPU resources on SRC node (%s)", ulPinId,
                m_paTopologyInformation[ulPinId].SrcNode.CpuResources == KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU ? TEXT("NOT_HOST_CPU") :
                m_paTopologyInformation[ulPinId].SrcNode.CpuResources == KSAUDIO_CPU_RESOURCES_HOST_CPU ? TEXT("HOST_CPU") :
                m_paTopologyInformation[ulPinId].SrcNode.CpuResources == KSAUDIO_CPU_RESOURCES_UNINITIALIZED ? TEXT("uninitialized") :
                TEXT("impossible value!"));
            hr = DSERR_INVALIDPARAM;
        }
    }

    // Check optional 3D resources
    if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRL3D))
    {
        if(!IS_VALID_NODE(m_paTopologyInformation[ulPinId].ThreedNode.NodeId))
        {
            // DPF(DPFLVL_MOREINFO, "Pin %d: Invalid 3D node", ulPinId);  // Too noisy
            hr = DSERR_CONTROLUNAVAIL;
        }

        if(SUCCEEDED(hr) && KSAUDIO_CPU_RESOURCES_UNINITIALIZED != ulInvalidCpuResources)
        {
            if(ulInvalidCpuResources == m_paTopologyInformation[ulPinId].ThreedNode.CpuResources)
            {
                DPF(DPFLVL_INFO, "Pin %d: Invalid CPU resources on 3D node (%s)", ulPinId,
                    m_paTopologyInformation[ulPinId].ThreedNode.CpuResources == KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU ? TEXT("NOT_HOST_CPU") :
                    m_paTopologyInformation[ulPinId].ThreedNode.CpuResources == KSAUDIO_CPU_RESOURCES_HOST_CPU ? TEXT("HOST_CPU") :
                    m_paTopologyInformation[ulPinId].ThreedNode.CpuResources == KSAUDIO_CPU_RESOURCES_UNINITIALIZED ? TEXT("uninitialized") :
                    TEXT("impossible value!"));
                hr = DSERR_INVALIDCALL;
            }
        }
    }

    // Check optional SRC resources
    if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLFREQUENCY))
    {
        if(!IS_VALID_NODE(m_paTopologyInformation[ulPinId].SrcNode.NodeId))
        {
            DPF(DPFLVL_INFO, "Pin %d: Invalid SRC node", ulPinId);
            hr = DSERR_CONTROLUNAVAIL;
        }
    }

    // Check optional volume resources
    if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLVOLUME))
    {
        if(!IS_VALID_NODE(m_paTopologyInformation[ulPinId].VolumeNode.Node.NodeId))
        {
            DPF(DPFLVL_INFO, "Pin %d: Invalid volume node", ulPinId);
            hr = DSERR_CONTROLUNAVAIL;
        }
    }

    // Check optional pan resources
    if(SUCCEEDED(hr) && (dwFlags & (DSBCAPS_CTRLPAN
#ifdef FUTURE_MULTIPAN_SUPPORT
        | DSBCAPS_CTRLCHANNELVOLUME
#endif
        )))
    {
        if(!IS_VALID_NODE(m_paTopologyInformation[ulPinId].PanNode.Node.NodeId))
        {
            DPF(DPFLVL_INFO, "Pin %d: Invalid pan node", ulPinId);
            hr = DSERR_CONTROLUNAVAIL;
        }
    }

#ifdef FUTURE_MULTIPAN_SUPPORT
    // Check optional channel volume resources
    if(SUCCEEDED(hr) && (dwFlags & DSBCAPS_CTRLCHANNELVOLUME))
    {
        // To support CTRLCHANNELVOLUME we need CTRLPAN support, plus support for the
        // KSPROPERTY_AUDIO_MIX_LEVEL_CAPS/TABLE on the Supermix node

        ULONG ulSuperMixNodeId = m_paTopologyInformation[ulPinId].SuperMixNode.NodeId;

        if(!IS_VALID_NODE(ulSuperMixNodeId))
        {
            DPF(DPFLVL_INFO, "Pin %d: Invalid supermix node", ulPinId);
            hr = DSERR_CONTROLUNAVAIL;
        }
        else
        {
            // FIXME: Check support for the properties above?
        }
    }
#endif // FUTURE_MULTIPAN_SUPPORT

#pragma TODO("Validate the 3D algorithm")

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  PreloadSoftwareGraph
 *
 *  Description:
 *      Pre-loads the software render graph.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderDevice::PreloadSoftwareGraph"

HRESULT
CKsRenderDevice::PreloadSoftwareGraph
(
    void
)
{
    HRESULT                 hr          = DSERR_NODRIVER;
    KSDATARANGE_AUDIO       DataRange;
    WAVEFORMATEX            wfx;

    DPF_ENTER();
    ASSERT(IS_VALID_READ_PTR(m_pulValidPins, m_ulValidPinCount * sizeof *m_pulValidPins));

    if (m_hPin == NULL)
    {
        // Create the pin we use to preload kmixer.  Note: if kmixer appears in more
        // than one pin ID's graph, only the first will be loaded.

        for(ULONG i = 0; i < m_ulValidPinCount && FAILED(hr); i++)
        {
            hr = ValidatePinCaps(m_pulValidPins[i], DSBCAPS_LOCSOFTWARE, GUID_NULL);

            if(SUCCEEDED(hr))
            {
                hr = KsGetPinPcmAudioDataRange(m_hDevice, m_pulValidPins[i], &DataRange);
            }

            if(SUCCEEDED(hr))
            {
                FillPcmWfx(&wfx, 1, DataRange.MinimumSampleFrequency, (WORD)DataRange.MinimumBitsPerSample);

                hr = CreateRenderPin(m_pulValidPins[i], DSBCAPS_LOCSOFTWARE, &wfx, GUID_NULL, &m_hPin, NULL);
            }
        }
    }
    else
    {
        // Got one last time
        hr = S_OK;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CKsPrimaryRenderWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKsRenderDevice * [in]: parent device.
 *      LPVOID [in]: buffer instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::CKsPrimaryRenderWaveBuffer"

CKsPrimaryRenderWaveBuffer::CKsPrimaryRenderWaveBuffer
(
    CKsRenderDevice *       pKsDevice,
    LPVOID                  pvInstance
)
    : CPrimaryRenderWaveBuffer(pKsDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsPrimaryRenderWaveBuffer);

    // Initialize defaults
    m_pKsDevice = pKsDevice;
    m_p3dListener = NULL;
    m_pSecondaryBuffer = NULL;
    m_dwState = VAD_BUFFERSTATE_STOPPED;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsPrimaryRenderWaveBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::~CKsPrimaryRenderWaveBuffer"

CKsPrimaryRenderWaveBuffer::~CKsPrimaryRenderWaveBuffer
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsPrimaryRenderWaveBuffer);

    // Free owned objects
    ABSOLUTE_RELEASE(m_p3dListener);
    ABSOLUTE_RELEASE(m_pSecondaryBuffer);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      DWORD [in]: buffer flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::Initialize"

HRESULT
CKsPrimaryRenderWaveBuffer::Initialize
(
    DWORD                   dwFlags
)
{
    HRESULT                 hr;
    VADRBUFFERDESC          vrbd;

    DPF_ENTER();

    // Preload the software graph
    hr = m_pKsDevice->PreloadSoftwareGraph();

    if(SUCCEEDED(hr))
    {
        vrbd.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_LOCSOFTWARE;
        vrbd.dwBufferBytes = DEF_PRIMARY_SIZE;
        vrbd.pwfxFormat = m_pKsDevice->m_pwfxFormat;
        vrbd.guid3dAlgorithm = GUID_NULL;

        hr = CPrimaryRenderWaveBuffer::Initialize(&vrbd, m_pSecondaryBuffer, NULL);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RequestWriteAccess
 *
 *  Description:
 *      Requests write access to the primary buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to request primary access, FALSE to relenquish it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::RequestWriteAccess"

HRESULT
CKsPrimaryRenderWaveBuffer::RequestWriteAccess
(
    BOOL                    fRequest
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // If we're becoming WRITEPRIMARY, we need to create a pin
    if(fRequest)
    {
        if(!m_pSecondaryBuffer)
        {
            hr = m_pKsDevice->CreateKsSecondaryBuffer(&m_vrbd, m_pvInstance, (CSecondaryRenderWaveBuffer **)&m_pSecondaryBuffer, m_pSysMemBuffer);

            if(SUCCEEDED(hr))
            {
                hr = SetState(m_dwState);
            }

            if(FAILED(hr))
            {
                RELEASE(m_pSecondaryBuffer);
            }
        }
    }
    else
    {
        RELEASE(m_pSecondaryBuffer);
    }

    if(SUCCEEDED(hr))
    {
        hr = FixUpBaseClass();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitToDevice
 *
 *  Description:
 *      Commits changed buffer wave data to the device.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the system memory buffer of the changed
 *                  data.
 *      DWORD [in]: size, in bytes, of the changed data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::CommitToDevice"

HRESULT
CKsPrimaryRenderWaveBuffer::CommitToDevice
(
    DWORD                   ibCommit,
    DWORD                   cbCommit
)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pSecondaryBuffer);

    hr = m_pSecondaryBuffer->CommitToDevice(ibCommit, cbCommit);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::GetState"

HRESULT
CKsPrimaryRenderWaveBuffer::GetState(LPDWORD pdwState)
{
    DPF_ENTER();

    *pdwState = m_dwState;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::SetState"

HRESULT
CKsPrimaryRenderWaveBuffer::SetState(DWORD dwState)
{
    static const DWORD      dwValidMask     = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING | VAD_BUFFERSTATE_WHENIDLE;
    static const DWORD      dwSecondaryMask = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING;
    static const DWORD      dwPwiMask       = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_WHENIDLE;
    HRESULT                 hr              = DS_OK;

    DPF_ENTER();

    ASSERT(IS_VALID_FLAGS(dwState, dwValidMask));

    // Ignore any play when idle calls.  This state doesn't apply to
    // KS buffers.
    if((dwState & dwPwiMask) != dwPwiMask && m_pSecondaryBuffer)
    {
        hr = m_pSecondaryBuffer->SetState(dwState & dwSecondaryMask);

        if(SUCCEEDED(hr) && !(dwState & VAD_BUFFERSTATE_STARTED))
        {
            hr = m_pSecondaryBuffer->SetCursorPosition(0);
        }
    }

    if (SUCCEEDED(hr))
    {
        m_dwState = dwState;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Gets the current play/write positions for the given buffer.
 *
 *  Arguments:
 *      LPDWORD [out]: receives play cursor position.
 *      LPDWORD [out]: receives write cursor position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::GetCursorPosition"

HRESULT
CKsPrimaryRenderWaveBuffer::GetCursorPosition
(
    LPDWORD                 pdwPlay,
    LPDWORD                 pdwWrite
)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(m_pSecondaryBuffer);

    hr = m_pSecondaryBuffer->GetCursorPosition(pdwPlay, pdwWrite);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  OnSetFormat
 *
 *  Description:
 *      Informs the primary buffer of a format change.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::OnSetFormat"

HRESULT
CKsPrimaryRenderWaveBuffer::OnSetFormat
(
    void
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    LPWAVEFORMATEX pwfex = CopyWfxAlloc(m_pKsDevice->m_pwfxFormat);
    hr = HRFROMP(pwfex);

    // Change the format of the secondary buffer
    if(SUCCEEDED(hr) && m_pSecondaryBuffer)
    {
        hr = m_pSecondaryBuffer->SetFormat(m_pKsDevice->m_pwfxFormat);
    }

    // Save format
    if (SUCCEEDED(hr))
    {
        MEMFREE(m_vrbd.pwfxFormat);
        m_vrbd.pwfxFormat = pwfex;
    }
    else
    {
        MEMFREE(pwfex);
    }

    // Fix up the base class
    if(SUCCEEDED(hr))
    {
        hr = FixUpBaseClass();
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Create3dListener
 *
 *  Description:
 *      Creates the 3D listener.
 *
 *  Arguments:
 *      C3dListener ** [out]: receives pointer to the 3D listener object.
 *                            The caller is responsible for freeing this
 *                            object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::Create3dListener"

HRESULT
CKsPrimaryRenderWaveBuffer::Create3dListener
(
    C3dListener **          pp3dListener
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(!m_p3dListener)
    {
        m_p3dListener = NEW(CKs3dListener);
        hr = HRFROMP(m_p3dListener);
    }

    if(SUCCEEDED(hr))
    {
        *pp3dListener = ADDREF(m_p3dListener);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FixUpBaseClass
 *
 *  Description:
 *      Fixes up the CRenderWaveBuffer base class.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPrimaryRenderWaveBuffer::FixUpBaseClass"

HRESULT
CKsPrimaryRenderWaveBuffer::FixUpBaseClass
(
    void
)
{
    HRESULT                 hr      = DS_OK;
    VADRBUFFERCAPS          vrbc;

    DPF_ENTER();

    if(m_pSecondaryBuffer)
    {
        hr = m_pSecondaryBuffer->GetCaps(&vrbc);

        if(SUCCEEDED(hr))
        {
            ASSERT(LXOR(vrbc.dwFlags & DSBCAPS_LOCHARDWARE, vrbc.dwFlags & DSBCAPS_LOCSOFTWARE));
            m_vrbd.dwFlags = (m_vrbd.dwFlags & ~DSBCAPS_LOCMASK) | (vrbc.dwFlags & DSBCAPS_LOCMASK);
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CKsSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKsRenderDevice * [in]: parent device.
 *      LPVOID [in]: buffer instance identifier.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CKsSecondaryRenderWaveBuffer"

CKsSecondaryRenderWaveBuffer::CKsSecondaryRenderWaveBuffer
(
    CKsRenderDevice *       pKsDevice,
    LPVOID                  pvInstance
)
    : CSecondaryRenderWaveBuffer(pKsDevice, pvInstance)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsSecondaryRenderWaveBuffer);

    // Initialize defaults
    m_pKsDevice = pKsDevice;
    m_pPin = NULL;
    m_dwState = VAD_BUFFERSTATE_STOPPED;
    m_pCallbackEvent = NULL;
    m_pLoopingEvent = NULL;
    m_paNotes = NULL;
    m_pStopNote = NULL;
    m_cNotes = 0;
    m_dwPositionCache = 0;
    m_fNoVirtRequested = FALSE;
    m_fSoft3dAlgUnavail = FALSE;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsSecondaryRenderWaveBuffer
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::~CKsSecondaryRenderWaveBuffer"

CKsSecondaryRenderWaveBuffer::~CKsSecondaryRenderWaveBuffer
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsSecondaryRenderWaveBuffer);

    // Stop the buffer
    SetStopState(FALSE, FALSE);

    // Forcibly release stuff in case SetStopState() failed
    if (m_pCallbackEvent)
    {
        m_pKsDevice->m_pEventPool->FreeEvent(m_pCallbackEvent);
        m_pCallbackEvent = NULL;
    }
    RELEASE(m_pLoopingEvent);

    // Free notification positions
    FreeNotificationPositions();

    // Free the pin
    FreePin(TRUE);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the wave buffer object.  If this function fails, the
 *      object should be immediately deleted.
 *
 *  Arguments:
 *      LPCVADRBUFFERDESC [in]: buffer description.
 *      CKsSecondaryRenderWaveBuffer* [in]: pointer to the buffer to duplicate
 *                                          from, or NULL to initialize as a
 *                                          new buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::Initialize"

HRESULT
CKsSecondaryRenderWaveBuffer::Initialize
(
    LPCVADRBUFFERDESC               pDesc,
    CKsSecondaryRenderWaveBuffer *  pSource,
    CSysMemBuffer *                 pSysMemBuffer
)
{
    DWORD                           dwLocationFlags;
    HRESULT                         hr;

    DPF_ENTER();

    ASSERT(LXOR(pDesc, pSource));

    // Initialize the base class
    hr = CSecondaryRenderWaveBuffer::Initialize(pDesc, pSource, pSysMemBuffer);

    // Mask off the location flags since they're not used here (only in AcquireResources)
    dwLocationFlags = m_vrbd.dwFlags & DSBCAPS_LOCMASK;
    m_vrbd.dwFlags &= ~DSBCAPS_LOCMASK;

    // If this is a 3D buffer, set up the fallback software 3D algorithm mechanism
    if(SUCCEEDED(hr) && (m_vrbd.dwFlags & DSBCAPS_CTRL3D))
    {
        // If NoVirt specifically requested, enable the fallback to 2D NoVirt hardware
        if(m_vrbd.guid3dAlgorithm == DS3DALG_NO_VIRTUALIZATION)
        {
            m_fNoVirtRequested = TRUE;
        }
        // If 3D algorithm is DS3DALG_DEFAULT (i.e. NULL), replace with default
        if(IS_NULL_GUID(&m_vrbd.guid3dAlgorithm))
        {
            m_vrbd.guid3dAlgorithm = *m_pKsDevice->GetDefault3dAlgorithm();
            DPF(DPFLVL_MOREINFO, "Using default 3D algorithm " DPF_GUID_STRING, DPF_GUID_VAL(m_vrbd.guid3dAlgorithm));
        }
        // The HRTF algorithms aren't supported on WDM 1.0, so in this case we
        // fall back to a NoVirt 2D software pin.
        if (g_ulWdmVersion == WDM_1_0 && (m_vrbd.guid3dAlgorithm == DS3DALG_HRTF_LIGHT ||
                                          m_vrbd.guid3dAlgorithm == DS3DALG_HRTF_FULL))
        {
            m_vrbd.guid3dAlgorithm = DS3DALG_NO_VIRTUALIZATION;
            m_fSoft3dAlgUnavail = TRUE;
            RPF(DPFLVL_MOREINFO, "WDM 1.0: Replacing HRTF 3D algorithm with NO_VIRTUALIZATION");
        }
        // 3D buffers need a frequency control for Doppler, unless they use effects, and the are not sink
        if (!(m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN))
        {
            m_vrbd.dwFlags |= DSBCAPS_CTRLFREQUENCY;
        }
    }

    // Set up the default buffer properties
    if(SUCCEEDED(hr))
    {
        if(pSource)
        {
            m_lVolume = pSource->m_lVolume;
            m_lPan = pSource->m_lPan;
            m_fMute = pSource->m_fMute;
            m_nSrcQuality = pSource->m_nSrcQuality;
        }
        else
        {
            m_lVolume = DSBVOLUME_MAX;
            m_lPan = DSBPAN_CENTER;
            m_fMute = FALSE;
            m_nSrcQuality = m_pKsDevice->m_nSrcQuality;
        }
    }

    // Acquire resources
    if(SUCCEEDED(hr) && !(m_vrbd.dwFlags & DSBCAPS_LOCDEFER))
    {
        hr = AcquireResources(dwLocationFlags);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  AcquireResources
 *
 *  Description:
 *      Acquires hardware resources for the buffer.
 *
 *  Arguments:
 *      DWORD [in]: location flags.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::AcquireResources"

HRESULT
CKsSecondaryRenderWaveBuffer::AcquireResources
(
    DWORD                   dwLocationFlags
)
{
    CKsRenderPin *          pPin    = NULL;
    HRESULT                 hr      = DS_OK;

    DPF_ENTER();

    ASSERT(!HasAcquiredResources());

    dwLocationFlags &= DSBCAPS_LOCMASK;

    // Modify the buffer flags to conform to the acceleration flags
    if(m_pKsDevice->m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWBUFFERS)
    {
        if(dwLocationFlags & DSBCAPS_LOCHARDWARE)
        {
            RPF(DPFLVL_ERROR, "Specified LOCHARDWARE with hardware buffer acceleration features disabled");
            hr = DSERR_INVALIDCALL;
        }
        else
        {
            dwLocationFlags = DSBCAPS_LOCSOFTWARE;
        }
    }

    if(SUCCEEDED(hr) && (m_vrbd.dwFlags & DSBCAPS_CTRL3D))
    {
        if(m_pKsDevice->m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHW3D)
        {
            if(dwLocationFlags & DSBCAPS_LOCHARDWARE)
            {
                RPF(DPFLVL_ERROR, "Specified LOCHARDWARE | CTRL3D with hardware 3D acceleration features disabled");
                hr = DSERR_INVALIDCALL;
            }
            else
            {
                dwLocationFlags = DSBCAPS_LOCSOFTWARE;
            }
        }
    }

    // Acquire pin resources
    if(SUCCEEDED(hr))
    {
        hr = DSERR_GENERIC;
        m_hrSuccessCode = DS_OK;

        if(!(dwLocationFlags & DSBCAPS_LOCSOFTWARE))
        {
            // Try to create a hardware pin
            hr = CreatePin(m_vrbd.dwFlags | DSBCAPS_LOCHARDWARE, m_vrbd.pwfxFormat, GUID_NULL, &pPin);

            if(FAILED(hr) && m_fNoVirtRequested)
            {
                // The app specifically requested DS3DALG_NO_VIRTUALIZATION,
                // so try to create a NoVirt 2D hardware pin
                hr = CreatePin((m_vrbd.dwFlags & ~DSBCAPS_CTRL3D) | DSBCAPS_LOCHARDWARE | DSBCAPS_CTRLNOVIRT, m_vrbd.pwfxFormat, GUID_NULL, &pPin);
            }
        }
        if(FAILED(hr) && !(dwLocationFlags & DSBCAPS_LOCHARDWARE))
        {
            if ((m_vrbd.dwFlags & DSBCAPS_CTRL3D) && (m_vrbd.guid3dAlgorithm == DS3DALG_NO_VIRTUALIZATION))
            {
                // The app either wants NoVirt, or wanted an HRTF algorithm
                // which isn't supported on WDM 1.0; in either case, we try
                // to create a NoVirt 2D software pin.
                hr = CreatePin((m_vrbd.dwFlags & ~DSBCAPS_CTRL3D) | DSBCAPS_LOCSOFTWARE | DSBCAPS_CTRLNOVIRT, m_vrbd.pwfxFormat, GUID_NULL, &pPin);
                if (m_fSoft3dAlgUnavail)
                {
                    // The app had asked for an unsupported HRTF algorithm;
                    // return special success code DS_NO_VIRTUALIZATION.
                    m_hrSuccessCode = DS_NO_VIRTUALIZATION;
                }
            }
            else
            {
                // Try to create a software pin
                hr = CreatePin(m_vrbd.dwFlags | DSBCAPS_LOCSOFTWARE, m_vrbd.pwfxFormat, m_vrbd.guid3dAlgorithm, &pPin);
            }
        }
    }

    // Handle resource acquistion
    if(SUCCEEDED(hr))
    {
        hr = HandleResourceAcquisition(pPin);
        if (FAILED(hr))
            RELEASE(pPin);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  StealResources
 *
 *  Description:
 *      Steals hardware resources from another object.
 *
 *  Arguments:
 *      CSecondaryRenderWaveBuffer * [in]: source object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::StealResources"

HRESULT
CKsSecondaryRenderWaveBuffer::StealResources
(
    CSecondaryRenderWaveBuffer *    pSource
)
{
    CKsSecondaryRenderWaveBuffer *  pKsSource   = (CKsSecondaryRenderWaveBuffer *)pSource;
    CKsRenderPin *                  pPin;
    HRESULT                         hr;

    DPF_ENTER();

    ASSERT(!HasAcquiredResources());
    ASSERT(pKsSource->HasAcquiredResources());

    // Steal the pin
    pPin = ADDREF(pKsSource->m_pPin);

    // Free the source buffer's resources
    hr = pKsSource->FreeResources();

    // Synch up buffer and pin properties
    if(SUCCEEDED(hr))
    {
        hr = HandleResourceAcquisition(pPin);
        if (FAILED(hr))
            RELEASE(pPin);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreatePin
 *
 *  Description:
 *      Creates a pin.
 *
 *  Arguments:
 *      DWORD [in]: flags.
 *      LPCWAVEFORMATEX [in]: format.
 *      REFGUID [in]: 3D algorithm.
 *      CKsRenderPin ** [out]: receives pin.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CreatePin"

HRESULT
CKsSecondaryRenderWaveBuffer::CreatePin
(
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    CKsRenderPin **         ppPin
)
{
    CKsRenderPin *          pPin    = NULL;
    HRESULT                 hr;

    DPF_ENTER();

    // Can we get a pin from the cache?  If not, create a new one
    hr = m_pKsDevice->m_pPinCache->GetPinFromCache(dwFlags, pwfxFormat, guid3dAlgorithm, &pPin);

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p reusing pin at 0x%p", this, pPin);
    }
    else
    {
        pPin = NEW(CKsRenderPin(m_pKsDevice));
        hr = HRFROMP(pPin);

        if(SUCCEEDED(hr))
        {
            hr = pPin->Initialize(dwFlags, pwfxFormat, guid3dAlgorithm);
        }
    }

    if(SUCCEEDED(hr))
    {
        *ppPin = pPin;
    }
    else
    {
        ABSOLUTE_RELEASE(pPin);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  HandleResourceAcquisition
 *
 *  Description:
 *      Applies all buffer properties to the pin.
 *
 *  Arguments:
 *      CKsRenderPin * [in]: pin.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::HandleResourceAcquisition"

HRESULT
CKsSecondaryRenderWaveBuffer::HandleResourceAcquisition
(
    CKsRenderPin *          pPin
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    ASSERT(!HasAcquiredResources());

    // If we're CTRLCHANNELVOLUME, set up the supermix table accordingly.
    // FIXME: we only have to keep redoing this here if the pin can be used
    // for non-CTRLCHANNELVOLUME playback too, which is impossible?

    // FIXME: if a pin has previously had SetSuperMix() called on it and is
    // then stolen or recycled as a normal pin, we should set the supermix
    // table back to the usual "only first 2 channels active" mode.

#ifdef FUTURE_MULTIPAN_SUPPORT
    if(m_vrbd.dwFlags & DSBCAPS_CTRLCHANNELVOLUME)
    {
        hr = pPin->SetSuperMix();
    }
#endif

    // Set attenuation levels
    if (SUCCEEDED(hr) && (pPin->m_dwFlags & DSBCAPS_CTRLVOLUME))
    {
        hr = pPin->SetVolume(m_lVolume);
    }

    if(SUCCEEDED(hr) && (pPin->m_dwFlags & DSBCAPS_CTRLPAN))
    {
        hr = pPin->SetPan(m_lPan);
    }

    // Set mute.  We have to set mute after setting volume because
    // SetMute may change the current pin volume.
    if(SUCCEEDED(hr))
    {
        hr = pPin->SetMute(m_fMute);
    }

    // Set frequency
    if(SUCCEEDED(hr) && (pPin->m_dwFlags & DSBCAPS_CTRLFREQUENCY))
    {
        hr = pPin->SetFrequency(m_vrbd.pwfxFormat->nSamplesPerSec);
    }

    // Set SRC quality.  We don't care if this succeeds or not.
    if(SUCCEEDED(hr))
    {
        pPin->SetSrcQuality(m_nSrcQuality);
    }

    // Enable notification positions
    if(SUCCEEDED(hr))
    {
        hr = pPin->EnableNotificationPositions(m_paNotes, m_cNotes);
    }

    // Set the pin position
    if(SUCCEEDED(hr))
    {
        hr = pPin->SetCursorPosition(m_dwPositionCache);
    }

    // Success
    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has acquired resources at 0x%p", this, pPin);

        // Save a pointer to the pin object
        m_pPin = pPin;

        // Set our buffer location according to the pin's location
        m_vrbd.dwFlags |= (pPin->m_dwFlags & DSBCAPS_LOCMASK);

        ASSERT(HasAcquiredResources());
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeResources
 *
 *  Description:
 *      Frees the pin and all resources attached to it.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::FreeResources"

HRESULT
CKsSecondaryRenderWaveBuffer::FreeResources
(
    void
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = FreePin(FALSE);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreePin
 *
 *  Description:
 *      Frees the pin.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to cache the pin before freeing.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::FreePin"

HRESULT
CKsSecondaryRenderWaveBuffer::FreePin
(
    BOOL                    fCache
)
{
    const DWORD             dwNoCacheMask   = DSBCAPS_PRIMARYBUFFER | DSBCAPS_LOCHARDWARE;
    HRESULT                 hr              = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        // Make sure the pin is stopped
        hr = SetStopState(FALSE, TRUE);

        // Save the buffer position
        if(SUCCEEDED(hr))
        {
            hr = GetCursorPosition(&m_dwPositionCache, NULL);
        }

        // Never cache a DRM pin
        if (FormatTagFromWfx(m_vrbd.pwfxFormat) == WAVE_FORMAT_DRM)
        {
            DPF(DPFLVL_INFO, "Not caching DRM format pin");
            fCache = FALSE;
        }

        // Cache the pin
        if(SUCCEEDED(hr) && fCache && !(m_vrbd.dwFlags & dwNoCacheMask))
        {
            hr = m_pKsDevice->m_pPinCache->AddPinToCache(m_pPin);
        }

        // Free the pin
        if(SUCCEEDED(hr))
        {
            RELEASE(m_pPin);
        }

        // Remove the buffer location flags
        if(SUCCEEDED(hr))
        {
            m_vrbd.dwFlags &= ~DSBCAPS_LOCMASK;
        }

        if(SUCCEEDED(hr))
        {
            DPF(DPFLVL_MOREINFO, "Buffer at 0x%p has freed its resources", this);
        }
    }

    if (HasAcquiredResources())
    {
        DPF(DPFLVL_ERROR, "Buffer at 0x%p failed to free pin resources", this);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Duplicate
 *
 *  Description:
 *      Duplicates the buffer.
 *
 *  Arguments:
 *      CSecondaryRenderWaveBuffer ** [out]: receives duplicate buffer.  Use
 *                                           Release to free this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::Duplicate"

HRESULT
CKsSecondaryRenderWaveBuffer::Duplicate
(
    CSecondaryRenderWaveBuffer **   ppBuffer
)
{
    CKsSecondaryRenderWaveBuffer *  pBuffer;
    HRESULT                         hr;

    DPF_ENTER();

    pBuffer = NEW(CKsSecondaryRenderWaveBuffer(m_pKsDevice, m_pvInstance));
    hr = HRFROMP(pBuffer);

    if(SUCCEEDED(hr))
    {
        hr = pBuffer->Initialize(NULL, this, m_pSysMemBuffer);
    }

    if(SUCCEEDED(hr))
    {
        *ppBuffer = pBuffer;
    }
    else
    {
        ABSOLUTE_RELEASE(pBuffer);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CommitToDevice
 *
 *  Description:
 *      Commits changed buffer wave data to the device.
 *
 *  Arguments:
 *      DWORD [in]: byte index into the system memory buffer of the changed
 *                  data.
 *      DWORD [in]: size, in bytes, of the changed data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CommitToDevice"

HRESULT
CKsSecondaryRenderWaveBuffer::CommitToDevice
(
    DWORD                   ibCommit,
    DWORD                   cbCommit
)
{
    DPF_ENTER();

    // Kmixer uses our system memory buffer, so there's nothing to do

    DPF_LEAVE_HRESULT(DS_OK);

    return DS_OK;
}


/***************************************************************************
 *
 *  GetState
 *
 *  Description:
 *      Gets buffer state.
 *
 *  Arguments:
 *      LPDWORD [out]: receives buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::GetState"

HRESULT
CKsSecondaryRenderWaveBuffer::GetState(LPDWORD pdwState)
{
    DPF_ENTER();

    // Get the buffer state
    if(m_dwState & VAD_BUFFERSTATE_STARTED && !(m_dwState & VAD_BUFFERSTATE_LOOPING))
    {
        ASSERT(HasAcquiredResources());
        ASSERT(m_pCallbackEvent);

        // Are we really still playing?
        if(WAIT_OBJECT_0 == m_pCallbackEvent->Wait(0))
        {
            // No
            EventSignalCallback(m_pCallbackEvent);
        }
    }

    *pdwState = m_dwState;

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  SetState
 *
 *  Description:
 *      Sets buffer state.
 *
 *  Arguments:
 *      DWORD [in]: buffer state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetState"

HRESULT
CKsSecondaryRenderWaveBuffer::SetState(DWORD dwState)
{
    const DWORD             dwValidMask = VAD_BUFFERSTATE_STARTED | VAD_BUFFERSTATE_LOOPING;
    const BOOL              fLoop       = MAKEBOOL(dwState & VAD_BUFFERSTATE_LOOPING);
    HRESULT                 hr          = DS_OK;

    DPF_ENTER();

    ASSERT(IS_VALID_FLAGS(dwState, dwValidMask));

    // Update the buffer state
    if((dwState & dwValidMask) != m_dwState)
    {
        if(dwState & VAD_BUFFERSTATE_STARTED)
        {
            // If we're LOCDEFER and need resources, get them
            if((m_vrbd.dwFlags & DSBCAPS_LOCDEFER) && !HasAcquiredResources())
                AcquireResources(m_vrbd.dwFlags & DSBCAPS_LOCMASK);
            if(SUCCEEDED(hr))
                hr = SetPlayState(fLoop);
        }
        else
        {
            hr = SetStopState(FALSE, TRUE);
            // If we're LOCDEFER and stopped, free our resources
            if(SUCCEEDED(hr) && (m_vrbd.dwFlags & DSBCAPS_LOCDEFER))
                FreePin(TRUE);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetPlayState
 *
 *  Description:
 *      Sets the buffer to a "play" state.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to play looped.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetPlayState"

HRESULT
CKsSecondaryRenderWaveBuffer::SetPlayState
(
    BOOL                    fLoop
)
{
    HRESULT                 hr      = DS_OK;
    CEvent *                pEvent;

    DPF_ENTER();

    ASSERT(HasAcquiredResources());

    // Set up the OVERLAPPED event
    if(fLoop)
    {
        if(!m_pLoopingEvent)
        {
            m_pLoopingEvent = NEW(CEvent);
            hr = HRFROMP(m_pLoopingEvent);
        }

        if(SUCCEEDED(hr))
        {
            pEvent = m_pLoopingEvent;
        }
    }
    else
    {
        if(!m_pCallbackEvent)
        {
            hr = AllocCallbackEvent(m_pKsDevice->m_pEventPool, &m_pCallbackEvent);
        }

        if(SUCCEEDED(hr))
        {
            pEvent = m_pCallbackEvent;
        }
    }

    // Start the pin playing
    if(SUCCEEDED(hr))
    {
        hr = m_pPin->SetPlayState(m_pSysMemBuffer->GetPlayBuffer(), m_pSysMemBuffer->GetSize(), fLoop, pEvent->GetEventHandle());
    }

    // Update the buffer state flags
    if(SUCCEEDED(hr))
    {
        m_dwState = VAD_BUFFERSTATE_STARTED;

        if(fLoop)
        {
            m_dwState |= VAD_BUFFERSTATE_LOOPING;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetStopState
 *
 *  Description:
 *      Sets the buffer to a "stop" state.
 *
 *  Arguments:
 *      BOOL: TRUE if there's a pending write IRP.
 *      BOOL: whether to cache the current position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetStopState"

HRESULT
CKsSecondaryRenderWaveBuffer::SetStopState
(
    BOOL                    fNaturalStop,
    BOOL                    fCachePosition
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(m_dwState & VAD_BUFFERSTATE_STARTED)
    {
        ASSERT(HasAcquiredResources());

        // Stop the pin
        hr = m_pPin->SetStopState(fNaturalStop, fCachePosition);

        // Free the overlapped events
        if(SUCCEEDED(hr))
        {
            if(m_pCallbackEvent)
            {
                m_pKsDevice->m_pEventPool->FreeEvent(m_pCallbackEvent);
                m_pCallbackEvent = NULL;
            }

            RELEASE(m_pLoopingEvent);
        }

        // Signal the application's stop event
        if(SUCCEEDED(hr) && m_pStopNote)
        {
            SetEvent(m_pStopNote->hEventNotify);
        }

        // Update the buffer state flags
        if(SUCCEEDED(hr))
        {
            m_dwState = VAD_BUFFERSTATE_STOPPED;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Retrieves the current play and write cursor positions.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the play position.
 *      LPDWORD [out]: receives the write position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::GetCursorPosition"

HRESULT
CKsSecondaryRenderWaveBuffer::GetCursorPosition
(
    LPDWORD                 pdwPlay,
    LPDWORD                 pdwWrite
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pPin->GetCursorPosition(pdwPlay, pdwWrite);
    }
    else
    {
        ASSERT(&m_dwPositionCache != pdwPlay);
        ASSERT(&m_dwPositionCache != pdwWrite);

        if(pdwPlay)
        {
            *pdwPlay = m_dwPositionCache;
        }

        if(pdwWrite)
        {
            *pdwWrite = m_dwPositionCache;
        }
    }

    if(SUCCEEDED(hr) && pdwWrite && (m_vrbd.dwFlags & DSBCAPS_LOCHARDWARE) && (m_dwState & VAD_BUFFERSTATE_STARTED))
    {
        *pdwWrite = PadHardwareWriteCursor(*pdwWrite, m_pSysMemBuffer->GetSize(), m_vrbd.pwfxFormat);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetCursorPosition
 *
 *  Description:
 *      Sets the current play cursor position.
 *
 *  Arguments:
 *      DWORD [in]: play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetCursorPosition"

HRESULT
CKsSecondaryRenderWaveBuffer::SetCursorPosition
(
    DWORD                   dwPlay
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pPin->SetCursorPosition(dwPlay);
    }
    else
    {
        m_dwPositionCache = dwPlay;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the buffer frequency.
 *
 *  Arguments:
 *      DWORD [in]: new frequency.
 *      BOOL [in]: whether to clamp to the driver's supported frequency
 *                 range, if the call fails on a hardware buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetFrequency"

HRESULT
CKsSecondaryRenderWaveBuffer::SetFrequency
(
    DWORD                   dwFrequency,
    BOOL                    fClamp
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if (m_vrbd.dwFlags & DSBCAPS_CTRLFX)
    {
        DPF(DPFLVL_INFO, "Called on FX buffer - ignored");
    }
    else
    {
        if (HasAcquiredResources())
        {
            hr = m_pPin->SetFrequency(dwFrequency);

            if (FAILED(hr) && (m_vrbd.dwFlags & DSBCAPS_LOCHARDWARE) && fClamp)
            {
                DWORD dwMinHwSampleRate, dwMaxHwSampleRate;
                hr = m_pKsDevice->GetFrequencyRange(&dwMinHwSampleRate, &dwMaxHwSampleRate);
                if (SUCCEEDED(hr))
                {
                    dwFrequency = BETWEEN(dwFrequency, dwMinHwSampleRate, dwMaxHwSampleRate);
                    hr = m_pPin->SetFrequency(dwFrequency);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            m_vrbd.pwfxFormat->nSamplesPerSec = dwFrequency;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Mutes or unmutes the buffer.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to mute the buffer, FALSE to restore it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetMute"

HRESULT
CKsSecondaryRenderWaveBuffer::SetMute
(
    BOOL                    fMute
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pPin->SetMute(fMute);
    }

    if(SUCCEEDED(hr))
    {
        m_fMute = fMute;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetSrcQuality
 *
 *  Description:
 *      Sets the quality of the buffer's sample rate converter.
 *
 *  Arguments:
 *      DIRECTSOUNDMIXER_SRCQUALITY [in]: new quality.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetSrcQuality"

HRESULT
CKsSecondaryRenderWaveBuffer::SetSrcQuality
(
    DIRECTSOUNDMIXER_SRCQUALITY nSrcQuality
)
{
    HRESULT                     hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        hr = m_pPin->SetSrcQuality(nSrcQuality);
    }

    if(SUCCEEDED(hr))
    {
        m_nSrcQuality = nSrcQuality;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetAttenuation
 *
 *  Description:
 *      Sets the attenuation for two stereo channels.
 *
 *  Arguments:
 *      PDSVOLUMEPAN [in]: attenuation structure.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetAttenuation"

HRESULT
CKsSecondaryRenderWaveBuffer::SetAttenuation
(
    PDSVOLUMEPAN            pdsvp
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(HasAcquiredResources())
    {
        if (!m_fMute)
            hr = m_pPin->SetVolume(pdsvp->lVolume);

        if(SUCCEEDED(hr))
            hr = m_pPin->SetPan(pdsvp->lPan);
    }

    if(SUCCEEDED(hr))
    {
        m_lVolume = pdsvp->lVolume;
        m_lPan = pdsvp->lPan;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


#ifdef FUTURE_MULTIPAN_SUPPORT
/***************************************************************************
 *
 *  SetChannelAttenuations
 *
 *  Description:
 *      Sets this buffer's attenuation on the channels corresponding to
 *      the requested speaker positions.
 *
 *      We get called from CDirectSoundSecondaryBuffer's methods SetVolume()
 *      and SetChannelVolume(), since both of them modify the channel levels
 *      matrix.  This is analogous to how SetVolume() and SetPan() both end
 *      up calling SetAttenuation(), for regular CTRLPAN buffers.
 *
 *      Note: we're using the term "speaker" here for a channel's positional
 *      destination, even though our device's output channels may not feed
 *      into speakers at all. This is to avoid ambiguity with the "channels"
 *      present in our audio data stream.
 *
 *  Arguments:
 *      LONG [in]: main volume level
 *      DWORD [in]: number of speaker positions
 *      const DWORD* [in]: array of speaker position codes
 *      const LONG* [in]: array of speaker position levels
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetChannelAttenuations"

HRESULT
CKsSecondaryRenderWaveBuffer::SetChannelAttenuations
(
    LONG                    lVolume,
    DWORD                   dwSpeakerCount,
    const DWORD *           pdwSpeakers,
    const LONG *            plSpeakerVolumes
)
{
    HRESULT                 hr = DS_OK;

    DPF_ENTER();

    ASSERT(m_pPin->m_dwFlags & DSBCAPS_CTRLCHANNELVOLUME);

    if (dwSpeakerCount == 0)
    {
        // We're in a SetVolume() API call and SetChannelVolume() has not been
        // called yet; so we translate directly into a SetVolume() on our pin
        ASSERT(!pdwSpeakers && !plSpeakerVolumes);  // Sanity checking

        if (!m_fMute)
            hr = m_pPin->SetVolume(lVolume);
    }
    else  // Non-zero dwSpeakerCount:
    {
        ASSERT(pdwSpeakers && plSpeakerVolumes);

        // We set up a complete array of channel levels, then fill it in according
        // to the values passed in plSpeakerVolumes.

        LONG * plAllChannelVolumes = MEMALLOC_A(LONG, m_pKsDevice->m_ulChannelCount);
        hr = HRFROMP(plAllChannelVolumes);

        if (SUCCEEDED(hr))
            for (ULONG i=0; i < m_pKsDevice->m_ulChannelCount; ++i)
                plAllChannelVolumes[i] = DSBVOLUME_MIN;

        for (DWORD i=0; i < dwSpeakerCount && SUCCEEDED(hr); ++i)
        {
            // See if the requested speaker position is available on the device
            if (pdwSpeakers[i] & m_pKsDevice->m_lSpeakerPositions)
            {
                // If so, find out which of our output channels has that position
                // (m_pnSpeakerIndexTable maps from speaker positions to channels)
                DWORD dwSpeaker = HighestBit(pdwSpeakers[i]) - 1;
                ASSERT(dwSpeaker < m_pKsDevice->m_ulChannelCount);
                plAllChannelVolumes[m_pKsDevice->m_pnSpeakerIndexTable[dwSpeaker]] = plSpeakerVolumes[i];
            }
            else
            {
                hr = DSERR_INVALIDPARAM;
                RPF(DPFLVL_ERROR, "Channel position 0x$lx is not available", pdwSpeakers[i]);
            }
        }

        if (SUCCEEDED(hr))
            hr = SetAllChannelAttenuations(lVolume, m_pKsDevice->m_ulChannelCount, plAllChannelVolumes);

        MEMFREE(plAllChannelVolumes);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}
#endif // FUTURE_MULTIPAN_SUPPORT


/***************************************************************************
 *
 *  SetAllChannelAttenuations
 *
 *  Description:
 *      Sets the attenuation on all channels of this buffer.
 *
 *  Arguments:
 *      LONG [in]:  main volume level
 *      DWORD [in]: number of channels
 *      PLONG [in]: channel attenuation levels
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetAllChannelAttenuations"

HRESULT
CKsSecondaryRenderWaveBuffer::SetAllChannelAttenuations
(
    LONG                    lVolume,
    DWORD                   dwChannelCount,
    LPLONG                  plChannelVolumes
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if (HasAcquiredResources())
    {
        if (!m_fMute)
            hr = m_pPin->SetVolume(lVolume);

        if (SUCCEEDED(hr))
            hr = m_pPin->SetChannelLevels(dwChannelCount, plChannelVolumes);
    }

    if (SUCCEEDED(hr))
        m_lVolume = lVolume;

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetNotificationPositions
 *
 *  Description:
 *      Sets buffer notification positions.
 *
 *  Arguments:
 *      DWORD [in]: DSBPOSITIONNOTIFY structure count.
 *      LPCDSBPOSITIONNOTIFY [in]: offsets and events.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetNotificationPositions"

HRESULT
CKsSecondaryRenderWaveBuffer::SetNotificationPositions
(
    DWORD                   dwCount,
    LPCDSBPOSITIONNOTIFY    paNotes
)
{
    const DWORD             dwProcessId = GetCurrentProcessId();
    LPDSBPOSITIONNOTIFY     paNotesCopy = NULL;
    HRESULT                 hr          = DS_OK;
    DWORD                   i;

    DPF_ENTER();

    // Make a local copy of the notifications, converting all the
    // handles to global.
    if(paNotes)
    {
        paNotesCopy = MEMALLOC_A_COPY(DSBPOSITIONNOTIFY, dwCount, paNotes);
        hr = HRFROMP(paNotesCopy);
    }

    if(paNotesCopy)
    {
        for(i = 0; i < dwCount && SUCCEEDED(hr); i++)
        {
            paNotesCopy[i].hEventNotify = GetGlobalHandleCopy(paNotesCopy[i].hEventNotify, dwProcessId, FALSE);
            hr = HRFROMP(paNotesCopy[i].hEventNotify);
        }
    }

    // Disable any current events
    if(SUCCEEDED(hr))
    {
        hr = FreeNotificationPositions();
    }

    // Save the new events
    if(SUCCEEDED(hr))
    {
        m_paNotes = paNotesCopy;
        m_cNotes = dwCount;
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < m_cNotes; i++)
        {
            if(DSBPN_OFFSETSTOP == m_paNotes[i].dwOffset)
            {
                // We won't actually pass the stop event down to Kmixer, but
                // instead will keep our own copy of it
                m_pStopNote = &m_paNotes[i];
                break;
            }
        }
    }

    // Enable position notifications
    if(SUCCEEDED(hr) && HasAcquiredResources())
    {
        hr = m_pPin->EnableNotificationPositions(m_paNotes, m_cNotes);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  FreeNotificationPositions
 *
 *  Description:
 *      Removes all position notifications and frees allocated resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::FreeNotificationPositions"

HRESULT
CKsSecondaryRenderWaveBuffer::FreeNotificationPositions
(
    void
)
{
    HRESULT                 hr  = DS_OK;
    UINT                    i;

    DPF_ENTER();

    // Disable all position notification events
    if(HasAcquiredResources())
    {
        hr = m_pPin->DisableNotificationPositions();
    }

    // Clean up
    if(SUCCEEDED(hr))
    {
        for(i = 0; i < m_cNotes; i++)
        {
            CLOSE_HANDLE(m_paNotes[i].hEventNotify);
        }

        MEMFREE(m_paNotes);

        m_pStopNote = NULL;
        m_cNotes = 0;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFormat
 *
 *  Description:
 *      Sets the buffer format.
 *
 *  Arguments:
 *      LPCWAVEFORMATEX [in]: new format.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::SetFormat"

HRESULT
CKsSecondaryRenderWaveBuffer::SetFormat
(
    LPCWAVEFORMATEX                 pwfxFormat
)
{
    const DWORD                     dwLocationFlags = (m_vrbd.dwFlags & DSBCAPS_LOCMASK);
    DWORD                           dwState;
    HRESULT                         hr;

    DPF_ENTER();

    // Fix up the buffer description
    MEMFREE(m_vrbd.pwfxFormat);

    m_vrbd.pwfxFormat = CopyWfxAlloc(pwfxFormat);
    hr = HRFROMP(m_vrbd.pwfxFormat);

    // Save the buffer state
    if(SUCCEEDED(hr))
    {
        hr = GetState(&dwState);
    }

    // We can't change the format of the pin, so we'll free and reaquire
    // resources.
    if(SUCCEEDED(hr) && HasAcquiredResources())
    {
        hr = FreePin(TRUE);

        if(SUCCEEDED(hr))
        {
            hr = AcquireResources(dwLocationFlags);
        }

        if(SUCCEEDED(hr))
        {
            hr = SetState(dwState);
        }
    }

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_INFO, "Buffer format set to %lu Hz, %u-bit, %s...", pwfxFormat->nSamplesPerSec, pwfxFormat->wBitsPerSample, (1 == pwfxFormat->nChannels) ? TEXT("mono") : TEXT("stereo"));
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  EventSignalCallback
 *
 *  Description:
 *      Callback function called when a pin's IO completion event is
 *      signalled.  This function is called from within the callback event
 *      pool's lock, so we get thread synchronization for free.
 *
 *  Arguments:
 *      CCallbackEvent * [in]: callback event.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::EventSignalCallback"

void
CKsSecondaryRenderWaveBuffer::EventSignalCallback
(
    CCallbackEvent *        pEvent
)
{
    DPF_ENTER();

    ASSERT(HasAcquiredResources());

    // Allow the buffer to handle the stop event
    SetStopState(TRUE, FALSE);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CreatePropertySet
 *
 *  Description:
 *      Creates the property set object.
 *
 *  Arguments:
 *      CPropertySet ** [out]: receives pointer to the property set object.
 *                             The caller is responsible for freeing this
 *                             object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CreatePropertySet"

HRESULT
CKsSecondaryRenderWaveBuffer::CreatePropertySet
(
    CPropertySet **         ppPropertySet
)
{
    HRESULT                 hr              = DS_OK;
    CKsPropertySet *        pPropertySet;

    DPF_ENTER();

    ASSERT(HasAcquiredResources());

    if(m_pKsDevice->m_dwAccelerationFlags & DIRECTSOUNDMIXER_ACCELERATIONF_NOHWPROPSETS)
    {
        hr = DSERR_UNSUPPORTED;
    }

    if(SUCCEEDED(hr))
    {
        pPropertySet = NEW(CKsPropertySet(m_pPin->m_hPin, m_pvInstance, m_pKsDevice->m_paTopologies[m_pPin->m_ulPinId]));
        hr = HRFROMP(pPropertySet);
    }

    if(SUCCEEDED(hr))
    {
        *ppPropertySet = pPropertySet;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  Create3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::Create3dObject"

HRESULT
CKsSecondaryRenderWaveBuffer::Create3dObject
(
    C3dListener *           p3dListener,
    C3dObject **            pp3dObject
)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(m_vrbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    C3dObject *             p3dObject               = NULL;
    HRESULT                 hr                      = DSERR_UNSUPPORTED;

    DPF_ENTER();

    ASSERT(HasAcquiredResources());
    ASSERT(m_vrbd.dwFlags & DSBCAPS_CTRL3D);

    if(m_pPin->m_dwFlags & DSBCAPS_CTRL3D)
    {
        if(IS_HARDWARE_NODE(m_pKsDevice->m_paTopologyInformation[m_pPin->m_ulPinId].ThreedNode.CpuResources))
        {
            // The IIR 3D object supports both hardware and software pins.  We'll
            // try to create that one first.  If it fails, we'll fall back on
            // a standard hardware 3D object.
            if(DS3DALG_HRTF_FULL == m_vrbd.guid3dAlgorithm || DS3DALG_HRTF_LIGHT == m_vrbd.guid3dAlgorithm)
            {
                hr = CreateIir3dObject(p3dListener, &p3dObject);
            }

            if(FAILED(hr))
            {
                hr = CreateHw3dObject(p3dListener, &p3dObject);
            }
        }
        else if(DS3DALG_HRTF_FULL == m_vrbd.guid3dAlgorithm || DS3DALG_HRTF_LIGHT == m_vrbd.guid3dAlgorithm)
        {
            hr = CreateIir3dObject(p3dListener, &p3dObject);
        }
        else if(DS3DALG_ITD == m_vrbd.guid3dAlgorithm)
        {
            hr = CreateItd3dObject(p3dListener, &p3dObject);
        }
    }
    else if(DS3DALG_NO_VIRTUALIZATION == m_vrbd.guid3dAlgorithm)
    {
        // See if we have a multichannel speaker configuration
        BYTE bSpkConf = DSSPEAKER_CONFIG(m_pKsDevice->m_dwSpeakerConfig);

        BOOL fMultiChannel = bSpkConf == DSSPEAKER_QUAD ||
                             bSpkConf == DSSPEAKER_SURROUND ||
                             bSpkConf == DSSPEAKER_5POINT1 ||
                             bSpkConf == DSSPEAKER_7POINT1;
        if (fMultiChannel)
        {
            hr = CreateMultiPan3dObject(p3dListener, fMute3dAtMaxDistance, m_vrbd.pwfxFormat->nSamplesPerSec, &p3dObject);
            if (FAILED(hr))
            {
                DPF(DPFLVL_INFO, "Multichannel pan object creation failed with %s", HRESULTtoSTRING(hr));
            }
        }
        if (!fMultiChannel || FAILED(hr))
        {
            hr = CreatePan3dObject(p3dListener, fMute3dAtMaxDistance, m_vrbd.pwfxFormat->nSamplesPerSec, &p3dObject);
        }
    }

    if(SUCCEEDED(hr))
    {
        *pp3dObject = p3dObject;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateHw3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CreateHw3dObject"

HRESULT
CKsSecondaryRenderWaveBuffer::CreateHw3dObject
(
    C3dListener *           p3dListener,
    C3dObject **            pp3dObject
)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(m_vrbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    const BOOL              fDopplerEnabled         = !MAKEBOOL((m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN));
    const PKSNODE           pNode                   = &m_pKsDevice->m_paTopologyInformation[m_pPin->m_ulPinId].ThreedNode;
    CKsHw3dObject *         p3dObject;
    HRESULT                 hr;

    DPF_ENTER();

    p3dObject = NEW(CKsHw3dObject((CKs3dListener *)p3dListener, fMute3dAtMaxDistance, fDopplerEnabled, m_pvInstance, pNode->NodeId, this));
    hr = HRFROMP(p3dObject);

    if(SUCCEEDED(hr))
    {
        hr = p3dObject->Initialize();
    }

    if(SUCCEEDED(hr))
    {
        *pp3dObject = p3dObject;
    }
    else
    {
        RELEASE(p3dObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateIir3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CreateIir3dObject"

HRESULT
CKsSecondaryRenderWaveBuffer::CreateIir3dObject
(
    C3dListener *           p3dListener,
    C3dObject **            pp3dObject
)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(m_vrbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    const BOOL              fDopplerEnabled         = !MAKEBOOL((m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN));
    const PKSNODE           pNode                   = &m_pKsDevice->m_paTopologyInformation[m_pPin->m_ulPinId].ThreedNode;
    CKsIir3dObject *        p3dObject;
    HRESULT                 hr;

    DPF_ENTER();

    p3dObject = NEW(CKsIir3dObject((CKs3dListener *)p3dListener, m_vrbd.guid3dAlgorithm, fMute3dAtMaxDistance, fDopplerEnabled, m_vrbd.pwfxFormat->nSamplesPerSec, this, m_pPin->m_hPin, pNode->NodeId, pNode->CpuResources));
    hr = HRFROMP(p3dObject);

    if(SUCCEEDED(hr))
    {
        hr = p3dObject->Initialize();
    }

    if(SUCCEEDED(hr))
    {
        *pp3dObject = p3dObject;
    }
    else
    {
        RELEASE(p3dObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateItd3dObject
 *
 *  Description:
 *      Creates the 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: listener object.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CreateItd3dObject"

HRESULT
CKsSecondaryRenderWaveBuffer::CreateItd3dObject
(
    C3dListener *           p3dListener,
    C3dObject **            pp3dObject
)
{
    const BOOL              fMute3dAtMaxDistance    = MAKEBOOL(m_vrbd.dwFlags & DSBCAPS_MUTE3DATMAXDISTANCE);
    const BOOL              fDopplerEnabled         = !MAKEBOOL((m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN));
    const PKSNODE           pNode                   = &m_pKsDevice->m_paTopologyInformation[m_pPin->m_ulPinId].ThreedNode;
    CKsItd3dObject *        p3dObject;
    HRESULT                 hr;

    DPF_ENTER();

    p3dObject = NEW(CKsItd3dObject((CKs3dListener *)p3dListener, fMute3dAtMaxDistance, fDopplerEnabled, m_vrbd.pwfxFormat->nSamplesPerSec, this, m_pPin->m_hPin, pNode->NodeId));
    hr = HRFROMP(p3dObject);

    if(SUCCEEDED(hr))
    {
        hr = p3dObject->Initialize();
    }

    if(SUCCEEDED(hr))
    {
        *pp3dObject = p3dObject;
    }
    else
    {
        RELEASE(p3dObject);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  CreateMultiPan3dObject
 *
 *  Description:
 *      Creates a multichannel panning 3D object.
 *
 *  Arguments:
 *      C3dListener * [in]: 3D listener object.
 *      BOOL [in]:          whether to mute the sound at max distance.
 *      DWORD [in]:         buffer frequency.
 *      C3dObject ** [out]: receives pointer to 3D object.  The caller is
 *                          responsible for freeing this object.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::CreateMultiPan3dObject"

HRESULT
CKsSecondaryRenderWaveBuffer::CreateMultiPan3dObject
(
    C3dListener *           p3dListener,
    BOOL                    fMute3dAtMaxDistance,
    DWORD                   dwFrequency,
    C3dObject **            pp3dObject
)
{
    const BOOL              fDopplerEnabled         = !MAKEBOOL((m_vrbd.dwFlags & DSBCAPS_CTRLFX) && !(m_vrbd.dwFlags & DSBCAPS_SINKIN));
    CMultiPan3dObject *     p3dObject = NULL;
    HRESULT                 hr;

    DPF_ENTER();

    // First set up the supermix table properly for this buffer's pin;
    // if this fails, there is no need to create the CMultiPan3dObject.
    hr = m_pPin->SetSuperMix();

    if (SUCCEEDED(hr))
    {
        p3dObject = NEW(CMultiPan3dObject((CMultiPan3dListener*)p3dListener, fMute3dAtMaxDistance, fDopplerEnabled, dwFrequency, this));
        hr = HRFROMP(p3dObject);
    }

    if (SUCCEEDED(hr))
        hr = p3dObject->Initialize();

    if (SUCCEEDED(hr))
        *pp3dObject = p3dObject;
    else
        RELEASE(p3dObject);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  HasAcquiredResources
 *
 *  Description:
 *      Determines whether or not hardware resources have been acquired.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      BOOL: TRUE if resources have been acquired.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsSecondaryRenderWaveBuffer::HasAcquiredResources"

BOOL
CKsSecondaryRenderWaveBuffer::HasAcquiredResources
(
    void
)
{
    if(m_pPin)
    {
        ASSERT(LXOR(m_vrbd.dwFlags & DSBCAPS_LOCHARDWARE, m_vrbd.dwFlags & DSBCAPS_LOCSOFTWARE));
    }
    else
    {
        ASSERT(!(m_vrbd.dwFlags & DSBCAPS_LOCMASK));
    }

    return MAKEBOOL(m_pPin);
}


/***************************************************************************
 *
 *  CKsRenderPin
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      CKsRenderDevice * [in]: parent device.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::CKsRenderPin"

CKsRenderPin::CKsRenderPin
(
    CKsRenderDevice *       pKsDevice
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsRenderPin);

    // Initialize defaults
    m_pKsDevice = pKsDevice;
    m_ulPinId = MAX_ULONG;
    m_dwFlags = 0;
    m_pwfxFormat = NULL;
    m_guid3dAlgorithm = GUID_NULL;
    m_hPin = NULL;
    m_dwState = VAD_BUFFERSTATE_STOPPED;
    m_paEventData = NULL;
    m_cEventData = 0;
    m_dwPositionCache = 0;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsRenderPin
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::~CKsRenderPin"

CKsRenderPin::~CKsRenderPin
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsRenderPin);

    SetStopState(FALSE, FALSE);

    DisableNotificationPositions();

    CLOSE_HANDLE(m_hPin);

    MEMFREE(m_pwfxFormat);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the render pin object.  If this function fails, the
 *      object should be immediately deleted.
 *
 *  Arguments:
 *      DWORD [in]: Pin creation flags.
 *      LPCVADRBUFFERDESC [in]: buffer description.
 *      REFGUID [in]: GUID of 3D algorithm to be used, if applicable.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::Initialize"

HRESULT
CKsRenderPin::Initialize
(
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm
)
{
    HRESULT                 hr;

    DPF_ENTER();

    if(dwFlags & DSBCAPS_CTRL3D)
    {
        ASSERT(DS3DALG_NO_VIRTUALIZATION != guid3dAlgorithm);
    }
    else
    {
        ASSERT(IS_NULL_GUID(&guid3dAlgorithm));
    }

    m_dwFlags = dwFlags;
    m_guid3dAlgorithm = guid3dAlgorithm;

    // For non-PCM formats we don't always require the VOLUME/PAN/FREQUENCY caps.
    // This fixes Millennium bug 139752 (cannot play AC3 format, DVD is blocked)

    WORD wFormatTag = FormatTagFromWfx(pwfxFormat);
    if (wFormatTag == WAVE_FORMAT_PCM || wFormatTag == WAVE_FORMAT_IEEE_FLOAT)
    {
        m_dwFlags |= DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPAN | DSBCAPS_CTRLFREQUENCY;
    }

    m_pwfxFormat = CopyWfxAlloc(pwfxFormat);
    hr = HRFROMP(m_pwfxFormat);

    // Create the pin
    if(SUCCEEDED(hr))
    {
        hr = m_pKsDevice->CreateRenderPin(-1, m_dwFlags, m_pwfxFormat, m_guid3dAlgorithm, &m_hPin, &m_ulPinId);
    }

#ifdef FUTURE_MULTIPAN_SUPPORT
    // If we're CTRLCHANNELVOLUME, set up the supermix table accordingly.
    // This is done here so we will correctly return DSERR_CONTROLUNAVAIL if a
    // driver's Supermix node doesn't support the MIX_LEVEL_TABLE properties.
    if(SUCCEEDED(hr) && (m_dwFlags & DSBCAPS_CTRLCHANNELVOLUME))
    {
        hr = SetSuperMix();
    }
#endif

    // Attach the new pin to the render device's virtual source to allow
    // wave out volume/pan changes to affect the pin.
    if(SUCCEEDED(hr))
    {
        hr = KsAttachVirtualSource(m_hPin, m_pKsDevice->m_ulVirtualSourceIndex);
    }

    // Set up the default pin properties
    if(SUCCEEDED(hr))
    {
        m_lVolume = DSBVOLUME_MAX;
        m_lPan = DSBPAN_CENTER;
        m_fMute = FALSE;
        m_nSrcQuality = DIRECTSOUNDMIXER_SRCQUALITY_PINDEFAULT;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/****************************************************************************
 *
 *  GetCursorPosition
 *
 *  Description:
 *      Retrieves the pin's current play and write cursor positions.
 *
 *  Arguments:
 *      LPDWORD [out]: receives the play position.
 *      LPDWORD [out]: receives the write position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::GetCursorPosition"

HRESULT
CKsRenderPin::GetCursorPosition
(
    LPDWORD                 pdwPlay,
    LPDWORD                 pdwWrite
)
{
    HRESULT                 hr          = DS_OK;
    KSAUDIO_POSITION        Position;

    DPF_ENTER();

    if(m_dwState & VAD_BUFFERSTATE_STARTED)
    {
        hr = KsGetProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_POSITION, &Position, sizeof(Position));
    }
    else
    {
        ASSERT(&m_dwPositionCache != pdwPlay);
        ASSERT(&m_dwPositionCache != pdwWrite);

        Position.PlayOffset = m_dwPositionCache;
        Position.WriteOffset = m_dwPositionCache;
    }

    if(SUCCEEDED(hr))
    {
        if(pdwPlay)
        {
            *pdwPlay = (DWORD)Position.PlayOffset;
        }

        if(pdwWrite)
        {
            *pdwWrite = (DWORD)Position.WriteOffset;
        }
    }
    else
    {
        DPF(DPFLVL_ERROR, "Unable to get cursor position");
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetCursorPosition
 *
 *  Description:
 *      Sets the current play cursor position.
 *
 *  Arguments:
 *      DWORD [in]: play position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetCursorPosition"

HRESULT
CKsRenderPin::SetCursorPosition
(
    DWORD                   dwPosition
)
{
    HRESULT                 hr          = DS_OK;
    KSAUDIO_POSITION        Position;

    DPF_ENTER();

    if(m_dwState & VAD_BUFFERSTATE_STARTED)
    {
        Position.PlayOffset = dwPosition;

        hr = KsSetProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_POSITION, &Position, sizeof(Position));
    }
    else
    {
        m_dwPositionCache = dwPosition;
    }

    if(FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "Unable to set cursor position");
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetFrequency
 *
 *  Description:
 *      Sets the pin's frequency.
 *
 *  Arguments:
 *      DWORD [in]: new frequency.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetFrequency"

HRESULT
CKsRenderPin::SetFrequency
(
    DWORD                   dwFrequency
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(dwFrequency != m_pwfxFormat->nSamplesPerSec)
    {
        ASSERT(m_dwFlags & DSBCAPS_CTRLFREQUENCY);
        ASSERT(IS_VALID_NODE(m_pKsDevice->m_paTopologyInformation[m_ulPinId].SrcNode.NodeId));

        hr = KsSetNodeProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_SAMPLING_RATE, m_pKsDevice->m_paTopologyInformation[m_ulPinId].SrcNode.NodeId, &dwFrequency, sizeof(dwFrequency));

        if(SUCCEEDED(hr))
        {
            m_pwfxFormat->nSamplesPerSec = dwFrequency;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetMute
 *
 *  Description:
 *      Mutes or unmutes the pin.
 *
 *  Arguments:
 *      BOOL [in]: TRUE to mute the buffer, FALSE to restore it.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetMute"

HRESULT
CKsRenderPin::SetMute
(
    BOOL                    fMute
)
{
    HRESULT                 hr      = DS_OK;
    LONG                    lVolume;

    DPF_ENTER();

    if(fMute != m_fMute)
    {
        if(IS_VALID_NODE(m_pKsDevice->m_paTopologyInformation[m_ulPinId].MuteNode.NodeId))
        {
            hr = KsSetPinMute(m_hPin, m_pKsDevice->m_paTopologyInformation[m_ulPinId].MuteNode.NodeId, fMute);
        }
        else if (m_dwFlags & DSBCAPS_CTRLVOLUME)  // Only try the below if we have a volume node; otherwise, just return OK
        {
            lVolume = m_lVolume;
            m_lVolume = ~m_lVolume;

            hr = SetVolume(fMute ? DSBVOLUME_MIN : lVolume);

            if(SUCCEEDED(hr))
            {
                m_lVolume = lVolume;
            }
        }

        if(SUCCEEDED(hr))
        {
            m_fMute = fMute;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetSrcQuality
 *
 *  Description:
 *      Sets the quality of the pin's sample rate converter.
 *
 *  Arguments:
 *      DIRECTSOUNDMIXER_SRCQUALITY [in]: new quality.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetSrcQuality"

HRESULT
CKsRenderPin::SetSrcQuality
(
    DIRECTSOUNDMIXER_SRCQUALITY nSrcQuality
)
{
    ULONG                       aulKsQuality[]  = { KSAUDIO_QUALITY_WORST, KSAUDIO_QUALITY_PC, KSAUDIO_QUALITY_BASIC, KSAUDIO_QUALITY_ADVANCED };
    HRESULT                     hr              = DS_OK;

    DPF_ENTER();

    ASSERT(nSrcQuality >= 0 && nSrcQuality < NUMELMS(aulKsQuality));

    if(nSrcQuality != m_nSrcQuality)
    {
        if(IS_VALID_NODE(m_pKsDevice->m_paTopologyInformation[m_ulPinId].SrcNode.NodeId))
        {
            hr = KsSetNodeProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_QUALITY, m_pKsDevice->m_paTopologyInformation[m_ulPinId].SrcNode.NodeId, &aulKsQuality[nSrcQuality], sizeof(aulKsQuality[nSrcQuality]));
        }
        else
        {
            hr = DSERR_UNSUPPORTED;
        }

        if(SUCCEEDED(hr))
        {
            m_nSrcQuality = nSrcQuality;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetVolume
 *
 *  Description:
 *      Sets the attenuation for each channel.
 *
 *  Arguments:
 *      LONG [in]: attenuation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetVolume"

HRESULT
CKsRenderPin::SetVolume
(
    LONG                    lVolume
)
{
    HRESULT                 hr      = DS_OK;
    LONG                    lLevel;

    DPF_ENTER();

    if(lVolume != m_lVolume)
    {
        ASSERT(m_dwFlags & DSBCAPS_CTRLVOLUME);
        ASSERT(IS_VALID_NODE(m_pKsDevice->m_paTopologyInformation[m_ulPinId].VolumeNode.Node.NodeId));

        lLevel = DsAttenuationToKsVolume(lVolume, &m_pKsDevice->m_paTopologyInformation[m_ulPinId].VolumeNode.VolumeRange);

        hr = KsSetChannelProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_VOLUMELEVEL, m_pKsDevice->m_paTopologyInformation[m_ulPinId].VolumeNode.Node.NodeId, -1, &lLevel, sizeof(lLevel));

        if(SUCCEEDED(hr))
        {
            m_lVolume = lVolume;
        }
        else
        {
            DPF(DPFLVL_ERROR, "Unable to set local volume");
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetPan
 *
 *  Description:
 *      Sets the attenuation for each channel.
 *
 *  Arguments:
 *      LONG [in]: attenuation.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetPan"

HRESULT
CKsRenderPin::SetPan
(
    LONG                    lPan
)
{
    HRESULT                 hr              = DS_OK;
    ULONG                   ulChannel;
    LONG                    lLevel;
    LONG                    lPanValue[2];

    DPF_ENTER();

    if(lPan != m_lPan)
    {
        ASSERT(m_dwFlags & DSBCAPS_CTRLPAN);
        ASSERT(IS_VALID_NODE(m_pKsDevice->m_paTopologyInformation[m_ulPinId].PanNode.Node.NodeId));

        VolumePanToAttenuation(DSBVOLUME_MAX, lPan, &lPanValue[0], &lPanValue[1]);

        for(ulChannel = 0; ulChannel < 2; ulChannel++)
        {
            lLevel = DsAttenuationToKsVolume(lPanValue[ulChannel], &m_pKsDevice->m_paTopologyInformation[m_ulPinId].PanNode.VolumeRange);

            hr = KsSetChannelProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_VOLUMELEVEL, m_pKsDevice->m_paTopologyInformation[m_ulPinId].PanNode.Node.NodeId, ulChannel, &lLevel, sizeof(lLevel));

            if(FAILED(hr))
            {
                DPF(DPFLVL_ERROR, "Unable to set local pan on channel %lu", ulChannel);
                break;
            }
        }

        if(SUCCEEDED(hr))
        {
            m_lPan = lPan;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetSuperMix
 *
 *  Description:
 *      Sets up this pin's supermix node for multichannel pan control.
 *      (By making every input channel present on all output channels.)
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetSuperMix"

HRESULT
CKsRenderPin::SetSuperMix(void)
{
    PKSAUDIO_MIXCAP_TABLE   pMixcapTable     = NULL;
    PKSAUDIO_MIXLEVEL       pMixLevels       = NULL;
    ULONG                   ulSuperMixNodeId = m_pKsDevice->m_paTopologyInformation[m_ulPinId].SuperMixNode.NodeId;
    HRESULT                 hr = DS_OK;

    DPF_ENTER();

    ASSERT(IS_VALID_NODE(ulSuperMixNodeId));

    // If this is a common-or-garden 2-channel pin, it already has the supermix
    // table set up correctly for CTRLCHANNELVOLUME, so we just return success.

    if (m_pKsDevice->m_ulChannelCount != 2)
    {
        // In the interest of speed, rather than make two system calls we
        // assume that there are at most 2 inputs and 32 outputs, so that
        // the most MixCaps structures we can ever get back are 64:
        size_t nMixcapTableSize = sizeof(KSAUDIO_MIXCAP_TABLE) + 64 * sizeof(KSAUDIO_MIX_CAPS);

        pMixcapTable = (PKSAUDIO_MIXCAP_TABLE) MEMALLOC_A(CHAR, nMixcapTableSize);
        hr = HRFROMP(pMixcapTable);

        if (SUCCEEDED(hr))
        {
            DPF(DPFLVL_MOREINFO, "Reading supermix table on node id %d", ulSuperMixNodeId);
            hr = KsGetNodeProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
                                   ulSuperMixNodeId, pMixcapTable, nMixcapTableSize);
        }

        if (SUCCEEDED(hr))
        {
            DPF(DPFLVL_MOREINFO, "Supermix table has %d inputs and %d outputs", pMixcapTable->InputChannels, pMixcapTable->OutputChannels);
            ASSERT(pMixcapTable->InputChannels <= 2);
            ASSERT(pMixcapTable->OutputChannels <= 32);

            if (pMixcapTable->OutputChannels != m_pKsDevice->m_ulChannelCount)
                DPF(DPFLVL_WARNING, "Supermix node has %d outputs, but there are %d bits set in the pan node's CHANNEL_CONFIG", pMixcapTable->OutputChannels, m_pKsDevice->m_ulChannelCount);

            pMixLevels = MEMALLOC_A(KSAUDIO_MIXLEVEL, pMixcapTable->InputChannels * pMixcapTable->OutputChannels);
            hr = HRFROMP(pMixLevels);
        }

        if (SUCCEEDED(hr))
        {
            hr = KsGetNodeProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_MIX_LEVEL_TABLE, ulSuperMixNodeId, pMixLevels,
                                   sizeof(KSAUDIO_MIXLEVEL) * pMixcapTable->InputChannels * pMixcapTable->OutputChannels);
        }

        if (SUCCEEDED(hr))
        {
            // Set up the supermix table so that every input is present on all outputs.
            for (ULONG m=0; m<pMixcapTable->InputChannels; ++m)
            {
                for (ULONG n=0; n<pMixcapTable->OutputChannels; ++n)
                {
                    PKSAUDIO_MIXLEVEL pMixLevel = pMixLevels + m*pMixcapTable->OutputChannels + n;
                    pMixLevel->Mute = FALSE;
                    pMixLevel->Level = 0;   // Means "no attenuation" - full signal.
                }
            }

            hr = KsSetNodeProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_MIX_LEVEL_TABLE, ulSuperMixNodeId, pMixLevels,
                                   sizeof(KSAUDIO_MIXLEVEL) * pMixcapTable->InputChannels * pMixcapTable->OutputChannels);
        }

        if (pMixLevels)
            MEMFREE(pMixLevels);

        if (pMixcapTable)
            MEMFREE(pMixcapTable);

        // If the property set calls failed, return DSERR_CONTROLUNAVAIL
        if (FAILED(hr) && hr != DSERR_OUTOFMEMORY)
            hr = DSERR_CONTROLUNAVAIL;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetChannelLevels
 *
 *  Description:
 *      Sets the attenuation for each channel.
 *
 *  Arguments:
 *      DWORD [in]: number of channels
 *      const LONG * [in]: channel attenuation levels
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetChannelLevels"

HRESULT
CKsRenderPin::SetChannelLevels
(
    DWORD                   dwChannelCount,
    const LONG *            plChannelVolumes
)
{
    ULONG                   ulPanNodeId     = m_pKsDevice->m_paTopologyInformation[m_ulPinId].PanNode.Node.NodeId;
    HRESULT                 hr              = DS_OK;

    DPF_ENTER();

    ASSERT(IS_VALID_NODE(ulPanNodeId));

    if (dwChannelCount != m_pKsDevice->m_ulChannelCount)
        DPF(DPFLVL_WARNING, "Called with dwChannelCount = %d, but no. of bits set in pan node's CHANNEL_CONFIG = %d", dwChannelCount, m_pKsDevice->m_ulChannelCount);

    for (DWORD dwChan=0; dwChan<dwChannelCount && SUCCEEDED(hr); ++dwChan)
    {
        LONG lLevel = DsAttenuationToKsVolume(plChannelVolumes[dwChan], &m_pKsDevice->m_paTopologyInformation[m_ulPinId].PanNode.VolumeRange);
        hr = KsSetChannelProperty(m_hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_VOLUMELEVEL, ulPanNodeId, dwChan, &lLevel, sizeof lLevel);
        if (FAILED(hr))
            DPF(DPFLVL_WARNING, "Failed to set level %ld on channel %d", lLevel, dwChan);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetPlayState
 *
 *  Description:
 *      Sets the buffer to a "play" state.
 *
 *  Arguments:
 *      LPCVOID [in]: data buffer pointer.
 *      DWORD [in]: size of data bufer.
 *      BOOL [in]: TRUE to play looped.
 *      HANDLE [in]: overlapped event handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetPlayState"

HRESULT
CKsRenderPin::SetPlayState
(
    LPCVOID                 pvBuffer,
    DWORD                   cbBuffer,
    BOOL                    fLoop,
    HANDLE                  hEvent
)
{
    HRESULT                 hr;
    BOOL                    fStreamStarted = FALSE;

    DPF_ENTER();

    // If we're already playing, stop the buffer before contining
    hr = SetStopState(FALSE, TRUE);

    // Update the buffer state flags
    if(SUCCEEDED(hr))
    {
        m_dwState = VAD_BUFFERSTATE_STARTED;

        if(fLoop)
        {
            m_dwState |= VAD_BUFFERSTATE_LOOPING;
        }
    }

    // Set up the OVERLAPPED data
    if(SUCCEEDED(hr))
    {
        m_kssio.Overlapped.hEvent = hEvent;
    }

    // Feed the stream
    if(SUCCEEDED(hr))
    {
        hr = KsWriteStream(m_hPin, pvBuffer, cbBuffer, fLoop ? KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA : 0, &m_kssio);
    }

    // Set the play cursor position
    if(SUCCEEDED(hr))
    {
        fStreamStarted = TRUE;
        hr = SetCursorPosition(m_dwPositionCache);
    }

    // Start making noise
    if(SUCCEEDED(hr))
    {
        hr = KsSetState(m_hPin, KSSTATE_RUN);
    }

    // Clean up
    if(FAILED(hr))
    {
        if (fStreamStarted)
        {
            // Stream was started, but we're going back to the stop state.
            // Make sure we don't leave stream I/O hanging around.
            KsCancelPendingIrps(m_hPin, &m_kssio, TRUE);
        }
        m_dwState = VAD_BUFFERSTATE_STOPPED;
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  SetStopState
 *
 *  Description:
 *      Sets the buffer to a "stop" state.
 *
 *  Arguments:
 *      BOOL [in]: TRUE if pin played to completion and is being notified
 *                 of the event.
 *      BOOL [in]: TRUE to cache the pin position.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::SetStopState"

HRESULT
CKsRenderPin::SetStopState
(
    BOOL                    fNaturalStop,
    BOOL                    fCachePosition
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    if(m_dwState & VAD_BUFFERSTATE_STARTED)
    {
        if(fNaturalStop)
        {
            ASSERT(m_kssio.fPendingIrp);
            m_kssio.fPendingIrp = FALSE;
            fCachePosition = FALSE;
        }

        // Pause the pin
        hr = KsSetState(m_hPin, KSSTATE_PAUSE);

        // Cache the play cursor position
        if(SUCCEEDED(hr))
        {
            if(fCachePosition)
            {
                hr = GetCursorPosition(&m_dwPositionCache, NULL);
            }
            else
            {
                m_dwPositionCache = 0;
            }
        }

        // Cancel the pending write IRP
        if(SUCCEEDED(hr) && m_kssio.fPendingIrp)
        {
            hr = KsCancelPendingIrps(m_hPin, &m_kssio, TRUE);
        }

        // Update the buffer state flags
        if(SUCCEEDED(hr))
        {
            m_dwState = VAD_BUFFERSTATE_STOPPED;
        }
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  EnableNotificationPositions
 *
 *  Description:
 *      Enables set position notifications.
 *
 *  Arguments:
 *      LPCDSBPOSITIONNOTIFY [in]: notification positions.
 *      DWORD [in]: count of notification positions.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::EnableNotificationPositions"

HRESULT
CKsRenderPin::EnableNotificationPositions
(
    LPCDSBPOSITIONNOTIFY                    paNotes,
    DWORD                                   cNotes
)
{
    PLOOPEDSTREAMING_POSITION_EVENT_DATA    pEventData;
    HRESULT                                 hr;
    DPF_ENTER();

    // Disable any current notifications
    hr = DisableNotificationPositions();

    // Count the number of notifications
    for(DWORD i=0; i<cNotes && SUCCEEDED(hr); i++)
    {
        if(DSBPN_OFFSETSTOP != paNotes[i].dwOffset)
        {
            m_cEventData++;
        }
    }

    // Allocate event data
    if(SUCCEEDED(hr))
    {
        m_paEventData = MEMALLOC_A(LOOPEDSTREAMING_POSITION_EVENT_DATA, m_cEventData);
        hr = HRFROMP(m_paEventData);
    }

    // Enable notifications
    for(pEventData = m_paEventData, i = 0; i < cNotes && SUCCEEDED(hr); i++)
    {
        if(DSBPN_OFFSETSTOP == paNotes[i].dwOffset)
        {
            continue;
        }

        hr = KsEnablePositionEvent(m_hPin, paNotes[i].dwOffset, paNotes[i].hEventNotify, pEventData++);

        if(FAILED(hr))
        {
            RPF(DPFLVL_ERROR, "Unable to set notify number %lu", i);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DisableNotificationPositions
 *
 *  Description:
 *      Removes position notifications and frees allocated resources.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPin::DisableNotificationPositions"

HRESULT
CKsRenderPin::DisableNotificationPositions
(
    void
)
{
    HRESULT hr = DS_OK;
    DPF_ENTER();

    // Disable all position notification events
    for(DWORD i=0; i<m_cEventData && SUCCEEDED(hr); i++)
    {
        hr = KsDisablePositionEvent(m_hPin, &m_paEventData[i]);
        if(FAILED(hr))
            DPF(DPFLVL_ERROR, "Unable to disable notify number %lu", i);
    }

    MEMFREE(m_paEventData);
    m_cEventData = 0;

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CKsRenderPinCache
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::CKsRenderPinCache"

const DWORD CKsRenderPinCache::m_dwTimeout = 5000;   // 5 seconds

CKsRenderPinCache::CKsRenderPinCache
(
    void
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsRenderPinCache);
    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsRenderPinCache
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::~CKsRenderPinCache"

CKsRenderPinCache::~CKsRenderPinCache
(
    void
)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsRenderPinCache);

    // Flush any remaining pins from the cache
    FlushCache();

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  AddPinToCache
 *
 *  Description:
 *      Adds a pin to the cache.
 *
 *  Arguments:
 *      CKsRenderPin * [in]: pin cache data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::AddPinToCache"

HRESULT
CKsRenderPinCache::AddPinToCache
(
    CKsRenderPin *          pPin
)
{
    CNode<KSPINCACHE> *     pNode;
    KSPINCACHE              kspc;
    HRESULT                 hr;

    DPF_ENTER();

    // Remove any expired pins from the cache
    FlushExpiredPins();

    // Add the pin to the cache list
    kspc.Pin = ADDREF(pPin);
    kspc.CacheTime = GetTickCount();

    pNode = m_lstPinCache.AddNodeToList(kspc);
    hr = HRFROMP(pNode);

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  GetPinFromCache
 *
 *  Description:
 *      Gets a pin from the cache.
 *
 *  Arguments:
 *      DWORD [in]: dsound buffer flags.
 *      LPCWAVEFORMATEX:
 *      REFGUID:
 *      CKsRenderPin ** [out]: receives pin data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::GetPinFromCache"

HRESULT
CKsRenderPinCache::GetPinFromCache
(
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    CKsRenderPin **         ppPin
)
{
    HRESULT                 hr      = DS_OK;
    COMPAREBUFFER           cmp[2];
    CNode<KSPINCACHE> *     pNode;

    DPF_ENTER();

    cmp[0].dwFlags = dwFlags;
    cmp[0].pwfxFormat = pwfxFormat;
    cmp[0].guid3dAlgorithm = guid3dAlgorithm;

    for(pNode = m_lstPinCache.GetListHead(); pNode; pNode = pNode->m_pNext)
    {
        cmp[1].dwFlags = pNode->m_data.Pin->m_dwFlags;
        cmp[1].pwfxFormat = pNode->m_data.Pin->m_pwfxFormat;
        cmp[1].guid3dAlgorithm = pNode->m_data.Pin->m_guid3dAlgorithm;

        if(CompareBufferProperties(&cmp[0], &cmp[1]))
        {
            break;
        }
    }

    if(!pNode)
    {
        hr = DSERR_BADFORMAT;
    }

    if(SUCCEEDED(hr))
    {
        *ppPin = ADDREF(pNode->m_data.Pin);
        RemovePinFromCache(pNode);
    }

    DPF_LEAVE_HRESULT(hr);

    return hr;
}


/***************************************************************************
 *
 *  RemovePinFromCache
 *
 *  Description:
 *      Removes a pin from the cache.
 *
 *  Arguments:
 *      CNode<KSPINCACHE> * [in]: pin node.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::RemovePinFromCache"

void CKsRenderPinCache::RemovePinFromCache
(
    CNode<KSPINCACHE> *     pNode
)
{
    DPF_ENTER();

    // Free the pin
    RELEASE(pNode->m_data.Pin);

    // Remove the pin from the list
    m_lstPinCache.RemoveNodeFromList(pNode);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  FlushExpiredPins
 *
 *  Description:
 *      Removes expired pins from the cache.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::FlushExpiredPins"

void CKsRenderPinCache::FlushExpiredPins
(
    void
)
{
    const DWORD             dwTime  = GetTickCount();
    CNode<KSPINCACHE> *     pNode;
    CNode<KSPINCACHE> *     pNext;

    DPF_ENTER();

    // Remove all pins whose timeouts have elapsed
    pNode = m_lstPinCache.GetListHead();

    while(pNode)
    {
        pNext = pNode->m_pNext;

        if(pNode->m_data.CacheTime + m_dwTimeout <= dwTime)
        {
            RemovePinFromCache(pNode);
        }

        pNode = pNext;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  FlushCache
 *
 *  Description:
 *      Removes all pins from the cache.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsRenderPinCache::FlushCache"

void CKsRenderPinCache::FlushCache
(
    void
)
{
    CNode<KSPINCACHE> *     pNode;

    DPF_ENTER();

    // Remove all pins from the cache
    while(pNode = m_lstPinCache.GetListHead())
    {
        RemovePinFromCache(pNode);
    }

    DPF_LEAVE_VOID();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\kscap.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       kscap.h
 *  Content:    WDM/CSA Virtual Audio Device audio capture class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/6/98      dereks  Created.
 *
 ***************************************************************************/

#ifdef NOKS
#error kscap.h included with NOKS defined
#endif // NOKS

#ifndef __KSCAP_H__
#define __KSCAP_H__

// Capture device topology info
typedef struct tagKSCDTOPOLOGY
{
    KSNODE          SrcNode;
} KSCDTOPOLOGY, *PKSCDTOPOLOGY;

// Flag used to terminate the StateThread
#define TERMINATE_STATE_THREAD 0xffffffff

#ifdef __cplusplus

// Fwd decl
class CKsCaptureDevice;
class CKsCaptureWaveBuffer;

// The KS Audio Capture Device class
class CKsCaptureDevice
    : public CCaptureDevice, public CKsDevice
{
    friend class CKsCaptureWaveBuffer;

protected:
    PKSCDTOPOLOGY               m_paTopologyInformation;    // Topology information
    BOOL                        m_fSplitter;

public:
    CKsCaptureDevice(void);
    virtual ~CKsCaptureDevice(void);

public:
    // Driver enumeration
    virtual HRESULT EnumDrivers(CObjectList<CDeviceDescription> *);

    // Initialization
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device capabilities
    virtual HRESULT GetCaps(LPDSCCAPS);
    virtual HRESULT GetCertification(LPDWORD, BOOL);

    // Buffer management
    virtual HRESULT CreateBuffer(DWORD, DWORD, LPCWAVEFORMATEX, CCaptureEffectChain *, LPVOID, CCaptureWaveBuffer **);

    // Pin helpers
    virtual HRESULT CreateCapturePin(ULONG, DWORD, LPCWAVEFORMATEX, CCaptureEffectChain *, LPHANDLE, PULONG);

protected:
    // Pin/topology helpers
    virtual HRESULT ValidatePinCaps(ULONG, DWORD);

private:
    // Topology helpers
    virtual HRESULT GetTopologyInformation(CKsTopology *, PKSCDTOPOLOGY);
};

inline HRESULT CKsCaptureDevice::EnumDrivers(CObjectList<CDeviceDescription> *plst)
{
    return CKsDevice::EnumDrivers(plst);
}

inline HRESULT CKsCaptureDevice::GetCertification(LPDWORD pdwCertification, BOOL fGetCaps)
{
    return CKsDevice::GetCertification(pdwCertification, fGetCaps);
}


// The KS capture wave buffer
class CKsCaptureWaveBuffer
    : public CCaptureWaveBuffer, private CUsesCallbackEvent
{
    friend class CKsCaptureDevice;

private:
    enum { cksioDefault = 25 };
    enum { IKSIO_INVALID = -1 };
    enum { DSCBSTATUS_PAUSE = 0x20000000 };

    PKSSTREAMIO                             m_rgpksio;              // array of KSSTREAMIO for capturing
    LONG                                    m_cksio;                // number of capture KSTREAMIO buffers
    LONG                                    m_iksioDone;
    LONG                                    m_cksioDropped;

    LPBYTE                                  m_pBuffer;              // buffer for data
    LPBYTE                                  m_pBufferMac;           // end of buffer for data
    LPBYTE                                  m_pBufferNext;          // next part of buffer to be queued
    DWORD                                   m_cbBuffer;             // size of buffer
    DWORD                                   m_cbRecordChunk;        // capture chunk size used for waveInAddBuffer
    DWORD                                   m_cLoops;               // how many times we've looped around

    DWORD                                   m_iNote;
    DWORD                                   m_cNotes;               // Count of notification positions
    LPDSBPOSITIONNOTIFY                     m_paNotes;              // Current notification positions
    LPDSBPOSITIONNOTIFY                     m_pStopNote;            // Stop notification

    LPWAVEFORMATEX                          m_pwfx;                 // WaveFormat stored for focus aware support
    CCaptureEffectChain *                   m_pFXChain;             // Capture Effects chain stored for FA support
    KSSTATE                                 m_PinState;             // The current state of m_hPin

#ifdef DEBUG
    HANDLE                                  m_hEventStop;
    DWORD                                   m_cIrpsSubmitted;       // Total number of capture IRPs submitted
    DWORD                                   m_cIrpsReturned;        // Total number of capture IRPs returned
#endif

#ifdef SHARED
    HANDLE                                  m_hEventThread;         // Event to signal focus change thread
    HANDLE                                  m_hEventAck;            // Event to acknoledge call
    HANDLE                                  m_hThread;              // Thread handle for focus change
    DWORD                                   m_dwSetState;           // State sent to the SetState() API
    DWORD                                   m_hrReturn;             // Return value
    CRITICAL_SECTION                        m_csSS;                 // critial section to protect multi-threaded access
#endif // SHARED

    CCallbackEvent **                       m_rgpCallbackEvent;     // array of callback events

    BOOL                                    m_fCritSectsValid;      // Critical sections currently OK
    CRITICAL_SECTION                        m_cs;                   // critical section to protect multi-thread access
    CRITICAL_SECTION                        m_csPN;                 // critical section to protect multi-thread access
                                                                    // used for position notification processing

    LPBYTE                                  m_pBufferProcessed;
    DWORD                                   m_dwCaptureCur;         // offset to last processed capture head position
                                                                    // i.e. data up to this point is valid
    DWORD                                   m_dwCaptureLast;        // offset into buffer where capturing stopped last
    BOOL                                    m_fFirstSubmittedIrp;   // allows setting of the DATADISCONTINUITY flag 
                                                                    // for the first IRP.
protected:
    CKsCaptureDevice *                      m_pKsDevice;            // KS audio device
    HANDLE                                  m_hPin;                 // Audio device pin
    DWORD                                   m_dwState;              // Current buffer state
    DWORD                                   m_fdwSavedState;        // Last buffer state set (ignoring capture focus)
    CEmCaptureDevice *                      m_pEmCaptureDevice;     // emulated capture device (WAVE_MAPPED)
    CEmCaptureWaveBuffer *                  m_pEmCaptureWaveBuffer; // emulated capture buffer (WAVE_MAPPED)

public:
    CKsCaptureWaveBuffer(CKsCaptureDevice *);
    virtual ~CKsCaptureWaveBuffer();

public:
    // Initialization
    virtual HRESULT Initialize(DWORD, DWORD, LPCWAVEFORMATEX, CCaptureEffectChain *);

    // Buffer capabilities
    virtual HRESULT GetCaps(LPDSCBCAPS);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);

    // Notification positions
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);

#ifdef SHARED
    static DWORD WINAPI StateThread(LPVOID pv);
#endif // SHARED 

private:
    virtual HRESULT SetCaptureState(BOOL);
    virtual HRESULT UpdateCaptureState(BOOL);
    virtual HRESULT SetStopState(BOOL);
    virtual HRESULT FreeNotificationPositions(void);
    virtual void EventSignalCallback(CCallbackEvent *);
    virtual HRESULT CreateEmulatedBuffer(UINT, DWORD, DWORD, LPCWAVEFORMATEX, CCaptureEffectChain *, CEmCaptureDevice **, CEmCaptureWaveBuffer **);

    // Focus management support
    void    NotifyStop(void);
    HRESULT NotifyFocusChange(void);
    HRESULT SubmitKsStreamIo(PKSSTREAMIO, HANDLE hPin = NULL);
    HRESULT CancelAllPendingIRPs(BOOL, HANDLE hPin = NULL);
    void    SignalNotificationPositions(PKSSTREAMIO);
    
#ifdef SHARED
    HRESULT SetStateThread(DWORD);
#endif // SHARED 
    
};

#endif // __cplusplus

#endif // __KSCAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\kshlp.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       kshlp.h
 *  Content:    WDM/CSA helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/5/98      dereks  Created.
 *
 ***************************************************************************/

#ifdef NOKS
#error kshlp.h included with NOKS defined
#endif // NOKS

#ifndef __KSHLP_H__
#define __KSHLP_H__

#include "pset.h"

// #define NO_DSOUND_FORMAT_SPECIFIER

#define KSPIN_DATAFLOW_CAPTURE  KSPIN_DATAFLOW_OUT
#define KSPIN_DATAFLOW_RENDER   KSPIN_DATAFLOW_IN

// Device-specific DirectSound property sets
typedef struct tagKSDSPROPERTY
{
    GUID    PropertySet;
    ULONG   PropertyId;
    ULONG   NodeId;
    ULONG   AccessFlags;
} KSDSPROPERTY, *PKSDSPROPERTY;

// KS stream data
typedef struct tagKSSTREAMIO
{
    KSSTREAM_HEADER Header;
    OVERLAPPED      Overlapped;
    BOOL            fPendingIrp;
} KSSTREAMIO, *PKSSTREAMIO;

// System audio device properties
typedef struct tagKSSADPROPERTY
{
    KSPROPERTY  Property;
    ULONG       DeviceId;
    ULONG       Reserved;
} KSSADPROPERTY, *PKSSADPROPERTY;

// WAVEFORMATEX pin description
typedef struct tagKSAUDIOPINDESC
{
    KSPIN_CONNECT               Connect;
    KSDATAFORMAT_WAVEFORMATEX   DataFormat;
} KSAUDIOPINDESC, *PKSAUDIOPINDESC;

// DirectSound render pin description

#ifndef NO_DSOUND_FORMAT_SPECIFIER

typedef struct tagKSDSRENDERPINDESC
{
    KSPIN_CONNECT       Connect;
    KSDATAFORMAT_DSOUND DataFormat;
} KSDSRENDERPINDESC, *PKSDSRENDERPINDESC;

// This is ugly. KSDATAFORMAT_DSOUND was changed between WDM 1.0 and 1.1.
// We need to old structure to run on 1.0.
//
#include <pshpack1.h>
// DirectSound buffer description
typedef struct {
    ULONG               Flags;
    ULONG               Control;
    ULONG               BufferSize;     // Does not exist in 1.1
    WAVEFORMATEX        WaveFormatEx;
} KSDSOUND_BUFFERDESC_10, *PKSDSOUND_BUFFERDESC_10;

// DirectSound format
typedef struct {
    KSDATAFORMAT            DataFormat;
    KSDSOUND_BUFFERDESC_10  BufferDesc;
} KSDATAFORMAT_DSOUND_10, *PKSDATAFORMAT_DSOUND_10;
#include <poppack.h>

typedef struct tagKSDSRENDERPINDESC_10
{
    KSPIN_CONNECT           Connect;
    KSDATAFORMAT_DSOUND_10  DataFormat;
} KSDSRENDERPINDESC_10, *PKSDSRENDERPINDESC_10;


#endif // NO_DSOUND_FORMAT_SPECIFIER

// Topology node information
typedef struct tagKSNODE
{
    ULONG   NodeId;
    ULONG   CpuResources;
} KSNODE, *PKSNODE;

typedef struct tagKSVOLUMENODE
{
    KSNODE                      Node;
    KSPROPERTY_STEPPING_LONG    VolumeRange;
} KSVOLUMENODE, *PKSVOLUMENODE;

// Our own version of NTSTATUS
typedef LONG NTSTATUS;

#define NT_SUCCESS(s)       ((NTSTATUS)(s) >= 0)
#define NT_INFORMATION(s)   ((ULONG)(s) >> 30 == 1)
#define NT_WARNING(s)       ((ULONG)(s) >> 30 == 2)
#define NT_ERROR(s)         ((ULONG)(s) >> 30 == 3)

// Reserved node identifiers
#define NODE_UNINITIALIZED  0xFFFFFFFF
#define NODE_WILDCARD       0xFFFFFFFE

#define NODE_PIN_UNINITIALIZED  0xFFFFFFFF

#define IS_VALID_NODE(nodeid) \
            (NODE_UNINITIALIZED != (nodeid))

// Node implementation
#define KSAUDIO_CPU_RESOURCES_UNINITIALIZED 'ENON'

#define IS_HARDWARE_NODE(impl) \
            (KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU == (impl))

#define IS_SOFTWARE_NODE(impl) \
            (KSAUDIO_CPU_RESOURCES_HOST_CPU == (impl))

#ifdef __cplusplus

// Helper functions
void 
KsQueryWdmVersion();

#define WDM_NONE            (0)
#define WDM_1_0             (0x0100)
#define WDM_1_1             (0x0101)    // or better

extern ULONG g_ulWdmVersion;

HRESULT 
PostDevIoctl
(
    HANDLE                  hDevice, 
    DWORD                   dwControlCode, 
    LPVOID                  pvIn            = NULL,
    DWORD                   cbIn            = 0,
    LPVOID                  pvOut           = NULL,
    DWORD                   cbOut           = 0,
    LPDWORD                 pcbReturned     = NULL,
    LPOVERLAPPED            pOverlapped     = NULL
);

HRESULT 
KsGetProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned     = NULL
);

HRESULT 
KsSetProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    LPVOID                  pvData, 
    ULONG                   cbData
);

HRESULT 
KsGetState
(
    HANDLE                  hDevice, 
    PKSSTATE                pState
);

HRESULT 
KsSetState
(
    HANDLE                  hDevice, 
    KSSTATE                 State
);

HRESULT 
KsTransitionState
(
    HANDLE                  hDevice, 
    KSSTATE                 nCurrentState,
    KSSTATE                 nNewState
);

HRESULT 
KsResetState
(
    HANDLE                  hDevice, 
    KSRESET                 ResetValue
);

HRESULT 
KsGetPinProperty
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    ULONG                   ulPinId, 
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned = NULL
);

HRESULT 
KsSetPinProperty
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    ULONG                   ulPinId, 
    LPVOID                  pvData, 
    ULONG                   cbData
);

PKSTOPOLOGY_CONNECTION 
KsFindConnection
(
    PKSTOPOLOGY_CONNECTION  paConnections,
    ULONG                   cConnections,
    PKSTOPOLOGY_CONNECTION  pNext
);

HRESULT 
KsGetFirstPinConnection
(
    HANDLE                  hDevice, 
    PULONG                  pIndex
);

HRESULT 
KsWriteStream
(
    HANDLE                  hDevice, 
    LPCVOID                 pvData, 
    ULONG                   cbData, 
    ULONG                   ulFlags, 
    PKSSTREAMIO             pKsStreamIo
);

HRESULT 
KsReadStream
(
    HANDLE                  hDevice,
    LPVOID                  pvData, 
    ULONG                   cbData, 
    ULONG                   ulFlags, 
    PKSSTREAMIO             pKsStreamIo
);

HRESULT 
KsGetNodeProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    ULONG                   ulNodeId, 
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned     = NULL
);

HRESULT 
KsSetNodeProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    ULONG                   ulNodeId, 
    LPVOID                  pvData, 
    ULONG                   cbData
);

#ifdef DEAD_CODE
HRESULT 
KsGet3dNodeProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    ULONG                   ulNodeId, 
    LPVOID                  pvInstance,
    LPVOID                  pvData, 
    ULONG                   cbData,
    PULONG                  pcbDataReturned     = NULL
);
#endif

HRESULT 
KsSet3dNodeProperty
(
    HANDLE                  hDevice, 
    REFGUID                 guidPropertySet, 
    ULONG                   ulPropertyId, 
    ULONG                   ulNodeId, 
    LPVOID                  pvInstance,
    LPVOID                  pvData, 
    DWORD                   cbData
);

HRESULT 
DsSpeakerConfigToKsProperties
(
    DWORD                   dwSpeakerConfig,
    PLONG                   pKsSpeakerConfig,
    PLONG                   pKsStereoSpeakerGeometry
);

DWORD 
DsBufferFlagsToKsPinFlags
(
    DWORD                   dwDsFlags
);

DWORD 
DsBufferFlagsToKsControlFlags
(
    DWORD                   dwDsFlags,
    REFGUID                 guid3dAlgorithm
);

DWORD
Ds3dModeToKs3dMode
(
    DWORD                   dwDsMode
);

HRESULT 
KsGetMultiplePinProperties
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    ULONG                   ulPinId, 
    PKSMULTIPLE_ITEM *      ppKsMultipleItem
);

HRESULT 
KsGetMultipleTopologyProperties
(
    HANDLE                  hDevice, 
    ULONG                   ulPropertyId, 
    PKSMULTIPLE_ITEM *      ppKsMultipleItem
);

HRESULT 
KsGetPinPcmAudioDataRange
(
    HANDLE                  hDevice, 
    ULONG                   ulPinId,
    PKSDATARANGE_AUDIO      pDataRange,
    BOOL                    fCapture = FALSE
);

HRESULT 
KsOpenSysAudioDevice
(
    LPHANDLE                phDevice
);

HRESULT 
KsGetSysAudioProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulDeviceId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned = NULL
);

HRESULT 
KsSetSysAudioProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulDeviceId,
    LPVOID                  pvData,
    ULONG                   cbData
);

HRESULT 
KsCreateSysAudioVirtualSource
(
    HANDLE                  hDevice,
    PULONG                  pulVirtualSourceIndex 
);

HRESULT 
KsAttachVirtualSource
(
    HANDLE                  hDevice,
    ULONG                   ulVirtualSourceIndex 
);

HRESULT 
KsSysAudioSelectGraph
(
    HANDLE                  hDevice,
    ULONG                   ulPinId, 
    ULONG                   ulNodeId 
);

HRESULT 
KsCancelPendingIrps
(
    HANDLE                  hPin,
    PKSSTREAMIO             pKsStreamIo = NULL,
    BOOL                    fWait       = FALSE
);

HRESULT 
KsBuildAudioPinDescription
(
    KSINTERFACE_STANDARD    nInterface,
    ULONG                   ulPinId,
    LPCWAVEFORMATEX         pwfxFormat,
    PKSAUDIOPINDESC *       ppPinDesc
);

#ifdef NO_DSOUND_FORMAT_SPECIFIER

HRESULT 
KsBuildRenderPinDescription
(
    ULONG                   ulPinId,
    LPCWAVEFORMATEX         pwfxFormat,
    PKSAUDIOPINDESC *       ppPinDesc
);

#else // NO_DSOUND_FORMAT_SPECIFIER

HRESULT 
KsBuildRenderPinDescription
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    PKSDSRENDERPINDESC *    ppPinDesc
);

HRESULT 
KsBuildRenderPinDescription_10
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    PKSDSRENDERPINDESC_10 * ppPinDesc
);

#endif // NO_DSOUND_FORMAT_SPECIFIER

HRESULT 
KsBuildCapturePinDescription
(
    ULONG                   ulPinId,
    LPCWAVEFORMATEX         pwfxFormat,
    PKSAUDIOPINDESC *       ppPinDesc
);

HRESULT 
KsCreateAudioPin
(
    HANDLE                  hDevice,
    PKSPIN_CONNECT          pConnect,
    ACCESS_MASK             dwDesiredAccess,
    KSSTATE                 nState,
    LPHANDLE                phPin
);

HRESULT 
KsEnableEvent
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulProperty,
    PKSEVENTDATA            pEventData,
    ULONG                   cbEventData
);

HRESULT 
KsDisableEvent
(
    HANDLE                  hDevice,
    PKSEVENTDATA            pEventData,
    ULONG                   cbEventData
);

HRESULT 
KsEnablePositionEvent
(
    HANDLE                                  hDevice,
    QWORD                                   qwSample,
    HANDLE                                  hEvent,
    PLOOPEDSTREAMING_POSITION_EVENT_DATA    pNotify
);

HRESULT 
KsDisablePositionEvent
(
    HANDLE                                  hDevice,
    PLOOPEDSTREAMING_POSITION_EVENT_DATA    pNotify
);

HRESULT 
KsGetCpuResources
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId, 
    PULONG                  pulCpuResources
);

DWORD KsGetSupportedFormats
(
    PKSDATARANGE_AUDIO      AudioDataRange
);

HRESULT 
KsGetDeviceInterfaceName
(
    HANDLE                  hDevice,
    ULONG                   ulDeviceId,
    LPTSTR *                ppszInterfaceName
);

HRESULT 
KsGetDeviceFriendlyName
(
    HANDLE                  hDevice,
    ULONG                   ulDeviceId,
    LPTSTR *                ppszName
);

HRESULT 
KsGetDeviceDriverPathAndDevnode
(
    LPCTSTR                 pszInterface,
    LPTSTR  *               ppszPath,
    LPDWORD                 pdwDevnode
);

HRESULT 
KsIsUsablePin
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    KSPIN_DATAFLOW          PinDataFlow,
    KSPIN_COMMUNICATION     PinCommunication,
    PKSAUDIOPINDESC         pPinDesc
);

HRESULT 
KsEnumDevicePins
(
    HANDLE                  hDevice,
    BOOL                    fCapture,
    ULONG **                ppulValidPinIds,
    ULONG                   ulPinCount,
    PULONG                  pulPinCount
);

HRESULT 
KsGetChannelProperty
(
    HANDLE                  hPin,
    GUID                    guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    ULONG                   ulChannelId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned = NULL
);

HRESULT 
KsSetChannelProperty
(
    HANDLE                  hPin,
    GUID                    guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    ULONG                   ulChannelId,
    LPVOID                  pvData,
    ULONG                   cbData
);

HRESULT 
KsGetPinMute
(
    HANDLE                  hPin,
    ULONG                   ulNodeId,
    LPBOOL                  pfMute
);

HRESULT 
KsSetPinMute
(
    HANDLE                  hPin,
    ULONG                   ulNodeId,
    BOOL                    fMute
);

HRESULT 
KsGetBasicSupport
(
    HANDLE                      hDevice,
    REFGUID                     guidPropertySet,
    ULONG                       ulPropertyId,
    ULONG                       ulNodeId,
    PKSPROPERTY_DESCRIPTION *   ppPropDesc
);

DWORD 
KsGetDriverCertification
(
    LPCTSTR                 pszInterface
);

HRESULT 
KsGetPinInstances
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    PKSPIN_CINSTANCES       pInstances
);

HRESULT 
KsGetRenderPinInstances
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    PKSPIN_CINSTANCES       pInstances
);

HRESULT 
KsGetFirstHardwareConnection
(
    HANDLE                  hDevice, 
    ULONG                   ulPinId,
    PULONG                  pIndex
);

HRESULT 
KsGetVolumeRange
(
    HANDLE                      hPin,
    ULONG                       ulNodeId,
    PKSPROPERTY_STEPPING_LONG   pVolumeRange
);

inline
LONG 
DsAttenuationToKsVolume
(
    LONG                        lVolume,
    PKSPROPERTY_STEPPING_LONG   pVolumeRange
)       
{
    lVolume = (LONG)((FLOAT)lVolume * 65536.0f / 100.0f);
    lVolume += pVolumeRange->Bounds.SignedMaximum;
    lVolume = max(lVolume, pVolumeRange->Bounds.SignedMinimum);
    
    return lVolume;
}

HRESULT
KsSetSysAudioDeviceInstance
(
    HANDLE                  hDevice,
    ULONG                   ulDeviceId
);

void
KsAggregatePinAudioDataRange
(
    PKSDATARANGE_AUDIO      pDataRange,
    PKSDATARANGE_AUDIO      pAggregateDataRange
);

void 
KsAggregatePinInstances
(
    PKSPIN_CINSTANCES       pInstances,
    PKSPIN_CINSTANCES       pAggregateInstances
);

HRESULT
KsGetNodeInformation
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    PKSNODE                 pNode
);

HRESULT
KsGetAlgorithmInstance
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    LPGUID                  lpGuidAlgorithmInstance
);

HRESULT
KsSetAlgorithmInstance
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    GUID                    guidAlgorithmInstance
);

HRESULT
KsGetVolumeNodeInformation
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    PKSVOLUMENODE           pNode
);

inline 
PKSTOPOLOGY_CONNECTION
KsValidateConnection
(
    PKSTOPOLOGY_CONNECTION  pConnection
)
{
    if(pConnection && KSFILTER_NODE == pConnection->ToNode)
    {
        pConnection = NULL;
    }

    return pConnection;
}

HRESULT
KsEnableTopologyNode
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    BOOL                    fEnable
);

// Fwd decl
class CKsTopology;
class CCaptureEffect;

// The KS Audio Device class
class CKsDevice 
{
protected:
    const VADDEVICETYPE         m_vdtKsDevType;         // Device type
    CDeviceDescription *        m_pKsDevDescription;    // Device description
    HANDLE                      m_hDevice;              // System audio device handle
    ULONG                       m_ulDeviceId;           // Device id
    ULONG                       m_ulPinCount;           // Count of pins on the device
    ULONG                       m_ulValidPinCount;      // Count of usable pins on the device
    PULONG                      m_pulValidPins;         // Array of usable pin IDs
    CKsTopology **              m_paTopologies;         // Array of pin topologies
    CCallbackEventPool *        m_pEventPool;           // Event pool

public:
    CKsDevice(VADDEVICETYPE);
    virtual ~CKsDevice(void);

public:
    // Driver enumeration
    virtual HRESULT EnumDrivers(CObjectList<CDeviceDescription> *);

    // Initialization
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device capabilities
    virtual HRESULT GetCertification(LPDWORD, BOOL);

    // Pin creation
    virtual HRESULT CreatePin(PKSPIN_CONNECT, ACCESS_MASK, KSSTATE, LPHANDLE);

private:
    // Device creation
    virtual HRESULT OpenSysAudioDevice(ULONG);

    // Device enumeration
    virtual HRESULT GetDeviceCount(PULONG);
    virtual HRESULT GetPinCount(ULONG, PULONG);
};

// KS topology object
class CKsTopology
    : public CDsBasicRuntime
{
protected:
    HANDLE                  m_hDevice;
    ULONG                   m_ulPinCount;
    ULONG                   m_ulPinId;
    PKSMULTIPLE_ITEM        m_paNodeItems;
    LPGUID                  m_paNodes;
    PKSMULTIPLE_ITEM        m_paConnectionItems;
    PKSTOPOLOGY_CONNECTION  m_paConnections;

public:
    CKsTopology(HANDLE, ULONG, ULONG);
    virtual ~CKsTopology(void);

public:
    // Initialization
    virtual HRESULT Initialize(KSPIN_DATAFLOW);

    // Basic topology helpers
    virtual REFGUID GetControlFromNodeId(ULONG);
    virtual ULONG GetNodeIdFromConnection(PKSTOPOLOGY_CONNECTION);

    // Advanced topology helpers
    virtual PKSTOPOLOGY_CONNECTION GetNextConnection(PKSTOPOLOGY_CONNECTION);
    virtual PKSTOPOLOGY_CONNECTION FindControlConnection(PKSTOPOLOGY_CONNECTION, PKSTOPOLOGY_CONNECTION, REFGUID);
    virtual HRESULT FindNodeIdsFromControl(REFGUID, PULONG, PULONG*);
    virtual HRESULT FindNodeIdFromEffectDesc(HANDLE, CCaptureEffect*, PULONG);
    virtual HRESULT FindMultipleToNodes(ULONG, ULONG, PULONG, PULONG*);
    virtual BOOL VerifyCaptureFxCpuResources(ULONG, ULONG);
    virtual HRESULT FindCapturePinFromEffectChain(PKSTOPOLOGY_CONNECTION, PKSTOPOLOGY_CONNECTION, CCaptureEffectChain *, ULONG);
    virtual HRESULT FindRenderPinWithAec(HANDLE, PKSTOPOLOGY_CONNECTION, PKSTOPOLOGY_CONNECTION, REFGUID, DWORD, PKSNODE);

private:
    virtual PKSTOPOLOGY_CONNECTION ValidateConnectionIndex(ULONG);
    virtual HRESULT OrderConnectionItems(KSPIN_DATAFLOW);
    virtual HRESULT RemovePanicConnections(void);
};

inline REFGUID CKsTopology::GetControlFromNodeId(ULONG ulNodeId)
{
    ASSERT(ulNodeId < m_paNodeItems->Count);
    return m_paNodes[ulNodeId];
}

inline ULONG CKsTopology::GetNodeIdFromConnection(PKSTOPOLOGY_CONNECTION pConnection)
{
    pConnection = KsValidateConnection(pConnection);
    return pConnection ? pConnection->ToNode : NODE_UNINITIALIZED;
}

inline PKSTOPOLOGY_CONNECTION CKsTopology::ValidateConnectionIndex(ULONG ulIndex)
{
    PKSTOPOLOGY_CONNECTION  pConnection = NULL;
    
    if(ulIndex < m_paConnectionItems->Count)
    {
        pConnection = KsValidateConnection(m_paConnections + ulIndex);
    }

    return pConnection;
}

// KS property set object
class CKsPropertySet
    : public CPropertySet
{
protected:
    HANDLE              m_hPin;             // Pin handle
    LPVOID              m_pvInstance;       // Instance identifer
    CKsTopology *       m_pTopology;        // Pin topology
    CList<KSDSPROPERTY> m_lstProperties;    // List of supported properties

public:
    CKsPropertySet(HANDLE, LPVOID, CKsTopology *);
    virtual ~CKsPropertySet(void);

public:
    // Property support
    virtual HRESULT QuerySupport(REFGUID, ULONG, PULONG);
    
    // Property data
    virtual HRESULT GetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, PULONG);
    virtual HRESULT SetProperty(REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG);

private:
    // Property data
    virtual HRESULT DoProperty(REFGUID, ULONG, DWORD, LPVOID, ULONG, LPVOID, PULONG);

    // Converting property descriptions to topology nodes
    virtual HRESULT FindNodeFromProperty(REFGUID, ULONG, PKSDSPROPERTY);
};

#ifdef DEBUG

extern ULONG g_ulKsIoctlCount;

#endif // DEBUG

#endif // __cplusplus

#endif // __KSHLP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\kshlp.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       kshlp.cpp
 *  Content:    WDM/CSA helper functions.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  8/5/98      dereks  Created.
 *  1999-2001   duganp  Fixes and updates
 *
 ***************************************************************************/

#ifdef NOKS
#error kshlp.cpp being built with NOKS defined
#endif

#include "dsoundi.h"
#include <devioctl.h>
#include <tchar.h>      // For _tcsrchr()

ULONG g_ulKsIoctlCount = 0;
ULONG g_ulWdmVersion = WDM_NONE;


/***************************************************************************
 *
 *  KsQueryWDMVersion
 *
 *  Description:
 *      Determine the WDM version available by looking at the OS version
 *      and set the global g_ulWdmVersion appropriately.
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsQueryWdmVersion"

void
KsQueryWdmVersion()
{
    DPF_ENTER();

    OSVERSIONINFO   OsVersion;

    OsVersion.dwOSVersionInfoSize = sizeof(OsVersion);
    GetVersionEx(&OsVersion);

    g_ulWdmVersion = WDM_NONE;

    switch (OsVersion.dwPlatformId)
    {
        case VER_PLATFORM_WIN32_WINDOWS:
            // Running on Win9x. GetVersionEx on Win9x puts the version
            // in the high word of the build number
            OsVersion.dwBuildNumber &= 0x0000FFFF;

            if (OsVersion.dwMajorVersion > 4)
            {
                // We will have at least 1.1 on future Win9x versions
                g_ulWdmVersion = WDM_1_1;
            }
            else if (OsVersion.dwMajorVersion == 4)
            {
                // Less than 10 is Win95 (4.0.950) or some OSR of it, which
                // therefore has no WDM support
                if (OsVersion.dwMinorVersion == 10)
                {
                    // Some build of Windows 98
                    if (OsVersion.dwBuildNumber == 1998)
                    {
                        // Windows 98 gold, WDM 1.0
                        g_ulWdmVersion = WDM_1_0;
                    }
                    else if (OsVersion.dwBuildNumber > 1998)
                    {
                        // Windows 98 SE or Millenium, WDM 1.1
                        g_ulWdmVersion = WDM_1_1;
                    }
                }
                else if (OsVersion.dwMinorVersion > 10)
                {
                    // Some later version we don't know about now.
                    g_ulWdmVersion = WDM_1_1;
                }
            }
            break;

        case VER_PLATFORM_WIN32_NT:
            // NT is easy since WDM 1.0 never shipped on it.
            // 5.0 and above have at least 1.1, before has nothing.
            if (OsVersion.dwMajorVersion >= 5)
            {
                g_ulWdmVersion = WDM_1_1;
            }
            break;

        default:
            // Windows CE or some other thing that we don't understand.
            break;
    }

    switch (g_ulWdmVersion)
    {
        case WDM_NONE:
            DPF(DPFLVL_INFO, "No WDM on this platform");
            break;

        case WDM_1_0:
            DPF(DPFLVL_INFO, "WDM Version 1.0 on this platform");
            break;

        case WDM_1_1:
            DPF(DPFLVL_INFO, "WDM Version 1.1 or better on this platform");
            break;

        default:
            ASSERT(!"Unknown platform - can't determine WDM version");
            break;
    }

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  CKsDevice
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *     VADDEVICETYPE [in]: device type.
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::CKsDevice"

CKsDevice::CKsDevice
(
    VADDEVICETYPE           vdtDeviceType
)
    : m_vdtKsDevType(vdtDeviceType)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsDevice);

    // Initialize defaults
    m_pKsDevDescription = NULL;
    m_hDevice = NULL;
    m_ulDeviceId = MAX_ULONG;
    m_ulPinCount = 0;
    m_ulValidPinCount = 0;
    m_pulValidPins = NULL;
    m_paTopologies = NULL;
    m_pEventPool = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsDevice
 *
 *  Description:
 *      Object destructor
 *
 *  Arguments:
 *     (void)
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::~CKsDevice"

CKsDevice::~CKsDevice(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsDevice);

    // Workaround for an unexplained stress failure in which we enter
    // this destructor TWICE (the second time with m_ulPinCount == -1):
    if (LONG(m_ulPinCount) > 0 && m_paTopologies)
        while(m_ulPinCount--)
            RELEASE(m_paTopologies[m_ulPinCount]);

    MEMFREE(m_pulValidPins);
    MEMFREE(m_paTopologies);
    RELEASE(m_pEventPool);
    CLOSE_HANDLE(m_hDevice);
    RELEASE(m_pKsDevDescription);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  EnumDrivers
 *
 *  Description:
 *      Creates a list of driver GUIDs that can be used to initialize this
 *      device.
 *
 *  Arguments:
 *      CList* [in/out]: CList object that will be filled with DRVNAME
 *                       structures.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::EnumDrivers"

HRESULT
CKsDevice::EnumDrivers
(
    CObjectList<CDeviceDescription> *   plstDrivers
)
{
    LPTSTR                              pszName         = NULL;
    LPTSTR                              pszPath         = NULL;
    LPTSTR                              pszInterface    = NULL;
    ULONG                               cDevices        = 0;
    ULONG                               ulDeviceId;
    ULONG                               cPins;
    CDeviceDescription *                pDesc           = NULL;
    HRESULT                             hr;

    DPF_ENTER();

    // Open the system audio device
    hr = OpenSysAudioDevice(-1);

    // Get the total count of devices that SAD knows about
    if(SUCCEEDED(hr))
    {
        hr = GetDeviceCount(&cDevices);
    }

    // LIMITATION: We can't support more than 0xFF WDM devices,
    // because we pack the device ID into a byte member of a GUID.
    if(SUCCEEDED(hr))
    {
        cDevices = NUMERIC_CAST(cDevices, BYTE);
    }

    // Examine each device to determine if it suits our needs
    for(ulDeviceId = 0; (ulDeviceId < cDevices) && SUCCEEDED(hr); ulDeviceId++)
    {
        // Reopen the system audio device
        hr = OpenSysAudioDevice(ulDeviceId);

        // Get the count of pins on this device
        if(SUCCEEDED(hr))
        {
            hr = GetPinCount(ulDeviceId, &cPins);
        }

        // Get the count of usable pins
        if(SUCCEEDED(hr))
        {
            hr = KsEnumDevicePins(m_hDevice, IS_CAPTURE_VAD(m_vdtKsDevType), NULL, cPins, &cPins);
        }

        if(SUCCEEDED(hr) && !cPins)
        {
            continue;
        }

        // Create the device description
        if(SUCCEEDED(hr))
        {
            pDesc = NEW(CDeviceDescription(m_vdtKsDevType));
            hr = HRFROMP(pDesc);
        }

        // Get the device GUID
        if(SUCCEEDED(hr))
        {
            g_pVadMgr->GetDriverGuid(m_vdtKsDevType, (BYTE)ulDeviceId, &pDesc->m_guidDeviceId);
        }

        // Get the device interface path
        if(SUCCEEDED(hr))
        {
            hr = KsGetDeviceInterfaceName(m_hDevice, ulDeviceId, &pszInterface);
        }

        if(SUCCEEDED(hr))
        {
            pDesc->m_strInterface = pszInterface;
        }

        // Get the device's friendly name
        if(SUCCEEDED(hr))
        {
            hr = KsGetDeviceFriendlyName(m_hDevice, ulDeviceId, &pszName);
        }

        if(SUCCEEDED(hr))
        {
            pDesc->m_strName = pszName;
        }

        // Get the driver filename
        if(SUCCEEDED(hr))
        {
            hr = KsGetDeviceDriverPathAndDevnode(pszInterface, &pszPath, &pDesc->m_dwDevnode);
        }

        if(SUCCEEDED(hr))
        {
            pDesc->m_strPath = pszPath;
        }

        // Get the device's wave id
        if(SUCCEEDED(hr))
        {
#ifdef WINNT
            GetWaveDeviceIdFromInterface(pszInterface, IS_CAPTURE_VAD(m_vdtKsDevType), &pDesc->m_uWaveDeviceId);
#else // WINNT
            GetWaveDeviceIdFromDevnode(pDesc->m_dwDevnode, IS_CAPTURE_VAD(m_vdtKsDevType), &pDesc->m_uWaveDeviceId);
#endif // WINNT
        }

        // Success
        if(SUCCEEDED(hr))
        {
            hr = HRFROMP(plstDrivers->AddNodeToList(pDesc));
        }

        // Clean up
        MEMFREE(pszInterface);
        MEMFREE(pszName);
        MEMFREE(pszPath);
        RELEASE(pDesc);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the device.  If this function fails, the object should
 *      be immediately deleted.
 *
 *  Arguments:
 *      CDeviceDescription * [in]: device description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::Initialize"

HRESULT
CKsDevice::Initialize
(
    CDeviceDescription *    pDesc
)
{
    BYTE                    bData;
    HRESULT                 hr = DS_OK;

    DPF_ENTER();
    ASSERT(m_vdtKsDevType == pDesc->m_vdtDeviceType);

    if (pDesc == NULL)
        hr = DSERR_INVALIDPARAM;

    if (SUCCEEDED(hr))
    {
        // Save a copy of the device description
        m_pKsDevDescription = ADDREF(pDesc);

        // Get the device ID from the driver GUID
        g_pVadMgr->GetDriverDataFromGuid(m_vdtKsDevType, pDesc->m_guidDeviceId, &bData);
        m_ulDeviceId = bData;

        // Open the system audio device
        hr = OpenSysAudioDevice(m_ulDeviceId);
    }

    // Get the count of pins on this device
    if(SUCCEEDED(hr))
    {
        hr = GetPinCount(m_ulDeviceId, &m_ulPinCount);
    }

    // Build the usable pin list
    if(SUCCEEDED(hr))
    {
        hr = KsEnumDevicePins(m_hDevice, IS_CAPTURE_VAD(m_vdtKsDevType), &m_pulValidPins, m_ulPinCount, &m_ulValidPinCount);
    }

    // Allocate memory for topology objects
    if(SUCCEEDED(hr))
    {
        ASSERT(m_ulPinCount);
        m_paTopologies = MEMALLOC_A(CKsTopology *, m_ulPinCount);
        hr = HRFROMP(m_paTopologies);
    }

    // Get device topology
    for(ULONG i = 0; i < m_ulValidPinCount && SUCCEEDED(hr); i++)
    {
        m_paTopologies[m_pulValidPins[i]] = NEW(CKsTopology(m_hDevice, m_ulPinCount, m_pulValidPins[i]));
        hr = HRFROMP(m_paTopologies[m_pulValidPins[i]]);

        if(SUCCEEDED(hr))
        {
            hr = m_paTopologies[m_pulValidPins[i]]->Initialize(IS_CAPTURE_VAD(m_vdtKsDevType) ? KSPIN_DATAFLOW_CAPTURE : KSPIN_DATAFLOW_RENDER);
        }
    }

    // Create the event pool
    if(SUCCEEDED(hr))
    {
        m_pEventPool = NEW(CMultipleCallbackEventPool(IS_RENDER_VAD(m_vdtKsDevType), 1));
        hr = HRFROMP(m_pEventPool);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pEventPool->Initialize();
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetCertification
 *
 *  Description:
 *      Returns the certification status of the driver.
 *
 *  Arguments:
 *      LPDWORD [out]: receives certification status.
 *      BOOL [in]: whether we're called from GetCaps.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::GetCertification"

HRESULT
CKsDevice::GetCertification
(
    LPDWORD                 pdwCertification,
    BOOL                    fGetCaps
)
{
    DPF_ENTER();

    // Millenium bug #127578
    // Disabling only for KS for GetCaps.

    if (fGetCaps)
    {
        *pdwCertification = VERIFY_CERTIFIED;
    }
    else
    {
        *pdwCertification = KsGetDriverCertification(m_pKsDevDescription->m_strInterface);
    }

    DPF_LEAVE_HRESULT(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  CreatePin
 *
 *  Description:
 *      Creates a pin on the device.
 *
 *  Arguments:
 *      PKSPIN_CONNECT [in/out]: pin description.  On exit, the PinId member
 *                               of this structure will be filled in.
 *      ACCESS_MASK [in]: access mask.
 *      KSSTATE [in]: pin state.
 *      LPHANDLE [out]: receives pin handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::CreatePin"

HRESULT
CKsDevice::CreatePin
(
    PKSPIN_CONNECT          pConnect,
    ACCESS_MASK             dwAccessMask,
    KSSTATE                 nState,
    LPHANDLE                phPin
)
{
    HRESULT                 hr;

    DPF_ENTER();

    if(-1 == pConnect->PinId)
    {
        hr = DSERR_NODRIVER;
        for(ULONG i = 0; i < m_ulValidPinCount && FAILED(hr); i++)
        {
            pConnect->PinId = m_pulValidPins[i];
            hr = CreatePin(pConnect, dwAccessMask, nState, phPin);
        }
    }
    else
    {
        hr = KsCreateAudioPin(m_hDevice, pConnect, dwAccessMask, nState, phPin);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  OpenSysAudioDevice
 *
 *  Description:
 *      Initializes the system audio device.
 *
 *  Arguments:
 *      ULONG [in]: device instance to use, or -1 for none.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::OpenSysAudioDevice"

HRESULT
CKsDevice::OpenSysAudioDevice
(
    ULONG                   ulDeviceId
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    // Open the system audio device
    if(SUCCEEDED(hr) && !m_hDevice)
    {
        hr = KsOpenSysAudioDevice(&m_hDevice);

        if(SUCCEEDED(hr) && IS_RENDER_VAD(m_vdtKsDevType))
        {
            if(!MakeHandleGlobal(&m_hDevice))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }
    }

    // Set the device instance
    if(SUCCEEDED(hr) && -1 != ulDeviceId)
    {
        hr = KsSetSysAudioDeviceInstance(m_hDevice, ulDeviceId);

        if(FAILED(hr))
        {
            DPF(DPFLVL_ERROR, "Unable to set SysAudio device instance");
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetDeviceCount
 *
 *  Description:
 *      Gets the count of devices managed by SysAudio.
 *
 *  Arguments:
 *      PULONG [out]: receives device count.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::GetDeviceCount"

HRESULT
CKsDevice::GetDeviceCount
(
    PULONG                  pulDeviceCount
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetSysAudioProperty(m_hDevice, KSPROPERTY_SYSAUDIO_DEVICE_COUNT, 0, pulDeviceCount, sizeof(*pulDeviceCount));

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "SysAudio manages %lu devices", *pulDeviceCount);
    }
    else
    {
        DPF(DPFLVL_ERROR, "Can't get SysAudio device count");
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetPinCount
 *
 *  Description:
 *      Gets the count of pins managed by a given device.
 *
 *  Arguments:
 *      ULONG [in]: device id.  It's assumed that this device has already
 *                  been selected as the device instance.
 *      PULONG [out]: receives pin count.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsDevice::GetPinCount"

HRESULT
CKsDevice::GetPinCount
(
    ULONG                   ulDeviceId,
    PULONG                  pulPinCount
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetPinProperty(m_hDevice, KSPROPERTY_PIN_CTYPES, 0, pulPinCount, sizeof(*pulPinCount));

    if(SUCCEEDED(hr))
    {
        DPF(DPFLVL_MOREINFO, "Device %lu sprouts %lu pins", ulDeviceId, *pulPinCount);
    }
    else
    {
        DPF(DPFLVL_ERROR, "Can't get count of pin types");
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  CKsTopology
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: pin id.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::CKsTopology"

CKsTopology::CKsTopology
(
    HANDLE                  hDevice,
    ULONG                   ulPinCount,
    ULONG                   ulPinId
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsTopology);

    // Initialize defaults
    m_hDevice = hDevice;
    m_ulPinCount = ulPinCount;
    m_ulPinId = ulPinId;
    m_paNodeItems = NULL;
    m_paNodes = NULL;
    m_paConnectionItems = NULL;
    m_paConnections = NULL;

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsTopology
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::~CKsTopology"

CKsTopology::~CKsTopology(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsTopology);

    // Free memory
    MEMFREE(m_paNodeItems);
    MEMFREE(m_paConnectionItems);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  Initialize
 *
 *  Description:
 *      Initializes the object.
 *
 *  Arguments:
 *      KSPIN_DATAFLOW [in]: device dataflow.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::Initialize"

HRESULT
CKsTopology::Initialize
(
    KSPIN_DATAFLOW          DataFlow
)
{
    HRESULT                 hr;

    DPF_ENTER();

    // Get the array of node GUIDs
    hr = KsGetMultipleTopologyProperties(m_hDevice, KSPROPERTY_TOPOLOGY_NODES, &m_paNodeItems);

    if(SUCCEEDED(hr))
    {
        m_paNodes = (LPGUID)(m_paNodeItems + 1);
    }

    // Get the array of connections
    if(SUCCEEDED(hr))
    {
        hr = KsGetMultipleTopologyProperties(m_hDevice, KSPROPERTY_TOPOLOGY_CONNECTIONS, &m_paConnectionItems);
    }

    if(SUCCEEDED(hr))
    {
        m_paConnections = (PKSTOPOLOGY_CONNECTION)(m_paConnectionItems + 1);
    }

    // Reorder the connections
    if(SUCCEEDED(hr))
    {
        hr = OrderConnectionItems(DataFlow);
    }
#if 0  // Breaks with AEC
    // Remove any connections that have multiple destination nodes
    if(SUCCEEDED(hr))
    {
        hr = RemovePanicConnections();
    }
#endif // 0

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetNextConnection
 *
 *  Description:
 *      Gets the next connection for a given pin topology.
 *
 *  Arguments:
 *      PKSTOPOLOGY_CONNECTION [in]: current connection.
 *
 *  Returns:
 *      PKSTOPOLOGY_CONNECTION: Next connection, or NULL.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::GetNextConnection"

PKSTOPOLOGY_CONNECTION
CKsTopology::GetNextConnection
(
    PKSTOPOLOGY_CONNECTION  pConnection
)
{
    KSTOPOLOGY_CONNECTION   Next;

    DPF_ENTER();

    if(pConnection)
    {
        Next.FromNode = pConnection->ToNode;
        // The new FromNodePin is most likely the exclusive OR of the
        // current ToNodePin with 1.  For two pin filters, this means
        // 1->0.  For Aec, this means 3->2 for capture or 1->0 for playback.
        // This will need to further special cased if we decide to handle
        // muxes or demuxes.
        Next.FromNodePin = pConnection->ToNodePin ^ 1;
    }
    else
    {
        Next.FromNode = KSFILTER_NODE;
        Next.FromNodePin = m_ulPinId;
    }

    Next.ToNode = NODE_WILDCARD;
    Next.ToNodePin = NODE_WILDCARD;

    pConnection = KsFindConnection(m_paConnections, m_paConnectionItems->Count, &Next);

    DPF_LEAVE(pConnection);
    return pConnection;
}


/***************************************************************************
 *
 *  FindControlConnection
 *
 *  Description:
 *      Finds a topology connection based on the control id.
 *
 *  Arguments:
 *      PKSTOPOLOGY_CONNECTION [in]: connection index to start with.
 *      PKSTOPOLOGY_CONNECTION [in]: connection index to stop at.
 *      REFGUID [in]: control id.
 *
 *  Returns:
 *      PKSTOPOLOGY_CONNECTION: connection pointer.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::FindControlConnection"

PKSTOPOLOGY_CONNECTION
CKsTopology::FindControlConnection
(
    PKSTOPOLOGY_CONNECTION  pStartConnection,
    PKSTOPOLOGY_CONNECTION  pEndConnection,
    REFGUID                 ControlId
)
{
    PKSTOPOLOGY_CONNECTION  pConnection = NULL;

    DPF_ENTER();

    // Initialize the starting connection point
    if(pStartConnection)
    {
        pConnection = pStartConnection;
    }
    else
    {
        pConnection = GetNextConnection(NULL);
    }

    // Find the connection that matches the control id
    while(pConnection && pConnection != pEndConnection)
    {
        if(GetControlFromNodeId(pConnection->ToNode) == ControlId)
        {
            break;
        }

        pConnection = GetNextConnection(pConnection);
    }

    // If we hit the end, return failure
    if(pConnection == pEndConnection)
    {
        pConnection = NULL;
    }

    DPF_LEAVE(pConnection);
    return pConnection;
}


/***************************************************************************
 *
 *  OrderConnectionItems
 *
 *  Description:
 *      Reorders the connection structure based on the device dataflow.
 *
 *  Arguments:
 *      KSPIN_DATAFLOW [in]: dataflow.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::OrderConnectionItems"

HRESULT
CKsTopology::OrderConnectionItems
(
    KSPIN_DATAFLOW          DataFlow
)
{
    ULONG                   i;

    DPF_ENTER();

    if(KSPIN_DATAFLOW_OUT == DataFlow)
    {
        for(i = 0; i < m_paConnectionItems->Count; i++)
        {
            SwapValues(&m_paConnections[i].FromNode, &m_paConnections[i].ToNode);
            SwapValues(&m_paConnections[i].FromNodePin, &m_paConnections[i].ToNodePin);
        }
    }

    DPF_LEAVE(DS_OK);
    return DS_OK;
}


/***************************************************************************
 *
 *  RemovePanicConnections
 *
 *  Description:
 *      Removes any connections that have multiple "to" destinations.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::RemovePanicConnections"

HRESULT
CKsTopology::RemovePanicConnections
(
    void
)
{
    const ULONG             cFilterConnections          = m_ulPinCount;
    const ULONG             cNodeConnections            = m_paNodeItems->Count;
    const ULONG             cConnectionItems            = m_paConnectionItems->Count;
    PULONG                  pacFilterConnectionCounts   = NULL;
    PULONG                  pacNodeConnectionCounts     = NULL;
    ULONG                   cCount;
    HRESULT                 hr;
    ULONG                   i;

    DPF_ENTER();

    pacFilterConnectionCounts = MEMALLOC_A(ULONG, cFilterConnections);
    hr = HRFROMP(pacFilterConnectionCounts);

    if(SUCCEEDED(hr))
    {
        pacNodeConnectionCounts = MEMALLOC_A(ULONG, cNodeConnections);
        hr = HRFROMP(pacNodeConnectionCounts);
    }

    if(SUCCEEDED(hr))
    {
        for(i = 0; i < cConnectionItems; i++)
        {
            if(KSFILTER_NODE == m_paConnections[i].FromNode)
            {
                ASSERT(m_paConnections[i].FromNodePin < cFilterConnections);
                pacFilterConnectionCounts[m_paConnections[i].FromNodePin]++;
            }
            else
            {
                ASSERT(m_paConnections[i].FromNode < cNodeConnections);
                pacNodeConnectionCounts[m_paConnections[i].FromNode]++;
            }
        }

        for(i = 0; i < cConnectionItems; i++)
        {
            if(KSFILTER_NODE == m_paConnections[i].FromNode)
            {
                ASSERT(m_paConnections[i].FromNodePin < cFilterConnections);
                cCount = pacFilterConnectionCounts[m_paConnections[i].FromNodePin];
            }
            else
            {
                ASSERT(m_paConnections[i].FromNode < cNodeConnections);
                cCount = pacNodeConnectionCounts[m_paConnections[i].FromNode];
            }

            if(cCount > 1)
            {
                // DPF(DPFLVL_MOREINFO, "Removing panic connection %lu", i);  // Too noisy
                m_paConnections[i].ToNode = -1;
                m_paConnections[i].ToNodePin = -1;
            }
        }
    }

    MEMFREE(pacFilterConnectionCounts);
    MEMFREE(pacNodeConnectionCounts);

    DPF_LEAVE(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindNodeIdsFromControl
 *
 *  Description:
 *      Searches the Node table for all nodes which match
 *      the control GUID.  JStokes added the method
 *      for finding all instances of the AEC node since
 *      FindControlConnection fails to find it given
 *      the bypass path in the topology around the
 *      node on the render side.  This function may be removed
 *      if the topology is parsed smarter or SysAudio
 *      provides additional helper functions in the future.
 *
 *  Arguments:
 *      REFGUID [in]: control.
 *      PULONG  [out]: number of nodes found which match the control GUID
 *      PPULONG [out]: pointer to the array containing node ids
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::FindNodeIdsFromControl"

HRESULT
CKsTopology::FindNodeIdsFromControl
(
    REFGUID     gControl,
    PULONG      pCount,
    PULONG*     ppNodes
)
{
    ULONG       i;
    ULONG       j;
    HRESULT     hr;

    DPF_ENTER();

    // Count all instances of nodes which match the Control GUID.
    *pCount = 0;
    for(i = 0; i < m_paNodeItems->Count; i++)
    {
        if(gControl == m_paNodes[i])
        {
            (*pCount)++;
        }
    }

    // Allocate the array to hold the node numbers
    *ppNodes = MEMALLOC_A(ULONG, *pCount);
    hr = HRFROMP(*ppNodes);

    // Fill the array with the Node IDs which match
    // the control GUID.
    if(SUCCEEDED(hr))
    {
        j = 0;
        for(i = 0; i < m_paNodeItems->Count; i++)
        {
            if(gControl == m_paNodes[i])
            {
                (*ppNodes)[j++] = i;
            }
        }
    }

    DPF_LEAVE(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindNodeIdFromEffectDesc
 *
 *  Description:
 *      Searches the Node table for all nodes which match
 *      the control GUID.  JStokes added the method
 *      for finding all instances of the AEC node since
 *      FindControlConnection fails to find it given
 *      the bypass path in the topology around the
 *      node on the render side.  This function may be removed
 *      if the topology is parsed smarter or SysAudio
 *      provides additional helper functions in the future.
 *
 *  Arguments:
 *      REFGUID [in]: control.
 *      PULONG  [out]: number of nodes found which match the control GUID
 *      PPULONG [out]: pointer to the array containing node ids
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::FindNodeIdFromEffectDesc"

HRESULT
CKsTopology::FindNodeIdFromEffectDesc
(
    HANDLE      hPin,
    CCaptureEffect* pDSCEffect,
    PULONG      pNodeId
)
{
    DWORD       i;
    HRESULT     hr = DSERR_UNSUPPORTED;
    HRESULT     hrTemp;
    ULONG       ulCpuResources;

    DPF_ENTER();

    // Find all instances of nodes which match the Control GUID.
    for(i = 0; i < m_paNodeItems->Count; i++)
    {
        if(pDSCEffect->m_fxDescriptor.guidDSCFXClass == m_paNodes[i])
        {
            // Do the CPU Resources match?
            hrTemp = KsGetCpuResources(hPin, i, &ulCpuResources);

            // FIXME: Why do we ignore ulCpuResources here?

            // Does the Instance GUID match?
            if(SUCCEEDED(hrTemp))
            {
                //hrTemp = KsGetAlgorithmInstance(hPin, i, guidInstance);
            }

            // If CPU resources and Instance GUID match, then break
            if(SUCCEEDED(hrTemp))
            {
                *pNodeId = i;
                hr = DS_OK;
            }
        }
    }

    DPF_LEAVE(hr);
    return hr;
}


/***************************************************************************
 *
 *  VerifyCaptureFxCpuResources
 *
 *  Description:
 *      Searches the Node table for all nodes which match
 *      the control GUID.  JStokes added the method
 *      for finding all instances of the AEC node since
 *      FindControlConnection fails to find it given
 *      the bypass path in the topology around the
 *      node on the render side.  This function may be removed
 *      if the topology is parsed smarter or SysAudio
 *      provides additional helper functions in the future.
 *
 *  Arguments:
 *      REFGUID [in]: control.
 *      PULONG  [out]: number of nodes found which match the control GUID
 *      PPULONG [out]: pointer to the array containing node ids
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::VerifyCaptureFxCpuResources"

BOOL
CKsTopology::VerifyCaptureFxCpuResources
(
    ULONG   ulFlags,
    ULONG   ulCpuResources
)
{
    BOOL fOk = FALSE;  // Assume the flags do not match the CPU resources

    DPF_ENTER();

    if(ulCpuResources == KSAUDIO_CPU_RESOURCES_HOST_CPU)
    {
        if(!(ulFlags & DSCFX_LOCHARDWARE))
        {
            fOk = TRUE;
        }
    }
    else
    {
        if(!(ulFlags & DSCFX_LOCSOFTWARE))
        {
            fOk = TRUE;
        }
    }

    DPF_LEAVE(fOk);
    return fOk;
}


/***************************************************************************
 *
 *  FindCapturePinFromEffectChain
 *
 *  Description:
 *      Searches the Connection and Node lists to find a
 *      capture pin that can support the desired
 *      capture FX chain.  This is a recursive routine.
 *
 *  Arguments:
 *   PKSTOPOLOGY_CONNECTION [in]: starting connection to search
 *   PKSTOPOLOGY_CONNECTION [in]: ending connection to search
 *   CCaptureEffectChain *  [in]: FX chain to match
 *   ULONG                  [in]: current effect in the chain to match.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::FindCapturePinFromEffectChain"

HRESULT
CKsTopology::FindCapturePinFromEffectChain
(
    PKSTOPOLOGY_CONNECTION  pStartConnection,
    PKSTOPOLOGY_CONNECTION  pEndConnection,
    CCaptureEffectChain *   pFXChain,
    ULONG                   ulCurrentEffect
)
{
    DWORD                   i;
    HRESULT                 hr = DSERR_FXUNAVAILABLE;
    HRESULT                 hrTemp = DS_OK;
    PKSTOPOLOGY_CONNECTION  pConnection = NULL;
    ULONG                   ulMatchingConnectionCount;
    PULONG                  pulConnectionIndexes = NULL;
    KSTOPOLOGY_CONNECTION   tempConnection;
    KSNODE                  tempKsNode;
    BOOL                    fSupportsAlgorithmInstance;
    KSCOMPONENTID           ComponentId;
    const GUID GUID_MICROSOFT = {DEFINE_MMREG_MID_GUID(MM_MICROSOFT)};

    DPF_ENTER();

    // Initialize the starting connection point
    if(pStartConnection)
    {
        pConnection = pStartConnection;
    }
    else
    {
        pConnection = GetNextConnection(NULL);
    }

    CNode<CCaptureEffect*>* pFxNode = pFXChain->m_fxList.GetNodeByIndex(ulCurrentEffect);

    // Walk the topology until we get to the end
    while(SUCCEEDED(hrTemp) && pFxNode && pConnection && pConnection != pEndConnection)
    {
        // Are there multiple ToNodes?
        if((pConnection->FromNode != NODE_UNINITIALIZED) ||
           (pConnection->FromNodePin != NODE_PIN_UNINITIALIZED))
            hrTemp = FindMultipleToNodes
            (
                pConnection->FromNode,
                pConnection->FromNodePin,
                &ulMatchingConnectionCount,
                &pulConnectionIndexes
            );
        else
            ulMatchingConnectionCount = 1;

        // Yes; call ourselves recursively
        if(SUCCEEDED(hrTemp))
        {
            if(ulMatchingConnectionCount > 1)
            {
                for(i=0; i<ulMatchingConnectionCount; i++)
                {
                    tempConnection = m_paConnections[pulConnectionIndexes[i]];
                    tempConnection.FromNode = NODE_UNINITIALIZED;
                    tempConnection.FromNodePin = NODE_PIN_UNINITIALIZED;

                    hrTemp = FindCapturePinFromEffectChain
                             (
                                 &tempConnection,
                                 pEndConnection,
                                 pFXChain,
                                 ulCurrentEffect
                             );

                    if(SUCCEEDED(hrTemp))
                    {
                        hr = DS_OK;
                        pConnection = pEndConnection;
                        if(pulConnectionIndexes)
                            MEMFREE(pulConnectionIndexes);
                        break;
                    }
                }
            }
            else
            {
                // Does this node type match the GUID in the effect descriptor?
                GUID guidToNode = GetControlFromNodeId(pConnection->ToNode);
                if(guidToNode == pFxNode->m_data->m_fxDescriptor.guidDSCFXClass)
                {
                    // Initialize
                    hrTemp = KsGetNodeInformation(m_hDevice, pConnection->ToNode, &tempKsNode);

                    if(SUCCEEDED(hrTemp))
                    {
                        GUID& guidInstance = pFxNode->m_data->m_fxDescriptor.guidDSCFXInstance;
                        hrTemp = KsSetAlgorithmInstance(m_hDevice, pConnection->ToNode, guidInstance);

                        if(SUCCEEDED(hrTemp))
                        {
                            // We don't allow any non-MS software filter to be the default system AEC.
                            // If this node is in software and a system full-duplex effect was requested,
                            // check that its ComponentId.Manufacturer is GUID_MICROSOFT.
                            fSupportsAlgorithmInstance = TRUE;
                            if(tempKsNode.CpuResources != KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU)
                            {
                                if((guidInstance == GUID_DSCFX_SYSTEM_AEC) ||
                                   (guidInstance == GUID_DSCFX_SYSTEM_NS)  ||
                                   (guidInstance == GUID_DSCFX_SYSTEM_AGC))
                                {
                                    hrTemp = KsGetNodeProperty(m_hDevice, KSPROPSETID_General, KSPROPERTY_GENERAL_COMPONENTID, pConnection->ToNode, &ComponentId, sizeof(ComponentId));

                                    if(FAILED(hrTemp) || ComponentId.Manufacturer != GUID_MICROSOFT)
                                    {
                                        fSupportsAlgorithmInstance = FALSE;
                                    }
                                    else
                                    {
                                        if (guidInstance == GUID_DSCFX_SYSTEM_AEC)
                                            guidInstance = GUID_DSCFX_MS_AEC;
                                        else if (guidInstance == GUID_DSCFX_SYSTEM_NS)
                                            guidInstance = GUID_DSCFX_MS_NS;
                                        else if (guidInstance == GUID_DSCFX_SYSTEM_AGC)
                                            guidInstance = GUID_DSCFX_MS_AGC;
                                    }
                                }
                            }
                        }
                        else
                            fSupportsAlgorithmInstance = FALSE;

                        if(fSupportsAlgorithmInstance &&
                           VerifyCaptureFxCpuResources(pFxNode->m_data->m_fxDescriptor.dwFlags, tempKsNode.CpuResources))
                        {
                            pFxNode->m_data->m_ksNode = tempKsNode;

                            if(!ulCurrentEffect)
                            {
                                hr = DS_OK;
                                pConnection = pEndConnection;
                                if(pulConnectionIndexes)
                                    MEMFREE(pulConnectionIndexes);
                                break;
                            }
                            else
                            {
                                ulCurrentEffect--;
                                pFxNode = pFxNode->m_pPrev;
                            }
                        }
                        else if(guidToNode == KSNODETYPE_ADC)
                        {
                            pConnection = pEndConnection;
                            if(pulConnectionIndexes)
                                MEMFREE(pulConnectionIndexes);
                            break;
                        }
                    }
                }
                else if(guidToNode == KSNODETYPE_ADC)
                {
                    pConnection = pEndConnection;
                    if(pulConnectionIndexes)
                        MEMFREE(pulConnectionIndexes);
                    break;
                }

                pConnection = GetNextConnection(pConnection);
            }

            if(pulConnectionIndexes)
                MEMFREE(pulConnectionIndexes);
        }
    }

    DPF_LEAVE(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindRenderPinWithAec
 *
 *  Description:
 *      Searches the Connection and Node lists to find a
 *      render pin that can support the desired
 *      AEC.  This is a recursive routine
 *
 *  Arguments:
 *   HANDLE                 [in]: handle to the pin to check.
 *   PKSTOPOLOGY_CONNECTION [in]: starting connection to search
 *   PKSTOPOLOGY_CONNECTION [in]: ending connection to search
 *   REFGUID                [in]: desired AEC instance GUID
 *   DWORD                  [in]: desired AEC flags
 *   PKSNODE                [out]: pointer to the AEC node
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::FindRenderPinWithAec"

HRESULT
CKsTopology::FindRenderPinWithAec
(
    HANDLE                  hPin,
    PKSTOPOLOGY_CONNECTION  pStartConnection,
    PKSTOPOLOGY_CONNECTION  pEndConnection,
    REFGUID                 guidDSCFXInstance,
    DWORD                   dwFlags,
    PKSNODE                 pAecNode
)
{
    DWORD                   i;
    HRESULT                 hr = DSERR_UNSUPPORTED;
    HRESULT                 hrTemp = DS_OK;
    PKSTOPOLOGY_CONNECTION  pConnection = NULL;
    ULONG                   ulMatchingConnectionCount;
    PULONG                  pulConnectionIndexes = NULL;
    KSTOPOLOGY_CONNECTION   tempConnection;
    KSNODE                  tempKsNode;
    BOOL                    fSupportsAlgorithmInstance;
    KSCOMPONENTID           ComponentId;
    const GUID GUID_MICROSOFT = {DEFINE_MMREG_MID_GUID(MM_MICROSOFT)};

    DPF_ENTER();

    // Initialize the starting connection point
    if(pStartConnection)
    {
        pConnection = pStartConnection;
    }
    else
    {
        pConnection = GetNextConnection(NULL);
    }

    // Walk the topology until you get to the end
    while(SUCCEEDED(hrTemp) && pConnection && pConnection != pEndConnection)
    {
        // Are there multiple ToNodes?
        if((pConnection->FromNode != NODE_UNINITIALIZED) ||
           (pConnection->FromNodePin != NODE_PIN_UNINITIALIZED))
            hrTemp = FindMultipleToNodes
            (
                pConnection->FromNode,
                pConnection->FromNodePin,
                &ulMatchingConnectionCount,
                &pulConnectionIndexes
            );
        else
            ulMatchingConnectionCount = 1;

        // Yes; call ourselves recursively
        if(SUCCEEDED(hrTemp))
        {
            if(ulMatchingConnectionCount > 1)
            {
                for(i=0; i<ulMatchingConnectionCount; i++)
                {
                    tempConnection = m_paConnections[pulConnectionIndexes[i]];
                    tempConnection.FromNode = NODE_UNINITIALIZED;
                    tempConnection.FromNodePin = NODE_PIN_UNINITIALIZED;

                    hrTemp = FindRenderPinWithAec
                             (
                                 hPin,
                                 &tempConnection,
                                 pEndConnection,
                                 guidDSCFXInstance,
                                 dwFlags,
                                 pAecNode
                             );

                    if(SUCCEEDED(hrTemp))
                    {
                        hr = DS_OK;
                        pConnection = pEndConnection;
                        if(pulConnectionIndexes)
                            MEMFREE(pulConnectionIndexes);
                        break;
                    }
                }
            }
            else
            {
                // Does this node type match the GUID in the effect descriptor?
                GUID guidToNode = GetControlFromNodeId(pConnection->ToNode);
                if(guidToNode == GUID_DSCFX_CLASS_AEC)
                {
                    // Initialize
                    hrTemp = KsGetNodeInformation(m_hDevice, pConnection->ToNode, &tempKsNode);

                    if(SUCCEEDED(hrTemp))
                    {
                        hrTemp = KsSetAlgorithmInstance
                                 (
                                     m_hDevice,
                                     pConnection->ToNode,
                                     guidDSCFXInstance
                                 );

                        if(SUCCEEDED(hrTemp))
                        {
                            fSupportsAlgorithmInstance = TRUE;
                            if(tempKsNode.CpuResources != KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU)
                            {
                                if(guidDSCFXInstance == GUID_DSCFX_SYSTEM_AEC)
                                {
                                    hrTemp = KsGetNodeProperty(m_hDevice, KSPROPSETID_General, KSPROPERTY_GENERAL_COMPONENTID, pConnection->ToNode, &ComponentId, sizeof(ComponentId));

                                    if(FAILED(hrTemp) || ComponentId.Manufacturer != GUID_MICROSOFT)
                                        fSupportsAlgorithmInstance = FALSE;
                                }
                            }
                        }
                        else
                            fSupportsAlgorithmInstance = FALSE;

                        if(fSupportsAlgorithmInstance &&
                           VerifyCaptureFxCpuResources(dwFlags, tempKsNode.CpuResources))
                        {
                            *pAecNode = tempKsNode;
                            hr = DS_OK;
                            pConnection = pEndConnection;
                            if(pulConnectionIndexes)
                                MEMFREE(pulConnectionIndexes);
                            break;
                        }
                    }
                }
                else if(guidToNode == KSNODETYPE_DAC)
                {
                    pConnection = pEndConnection;
                    if(pulConnectionIndexes)
                        MEMFREE(pulConnectionIndexes);
                    break;
                }

                pConnection = GetNextConnection(pConnection);
            }

            if(pulConnectionIndexes)
                MEMFREE(pulConnectionIndexes);
        }
    }

    DPF_LEAVE(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindMultipleToNodes
 *
 *  Description:
 *      Searches the connection table for all connections which share
 *      the same FromNode and FromNodePin.  JStokes added the method
 *      for correctly parsing the capture pin topology.  This function
 *      may be removed if the topology is parsed smarter or SysAudio
 *      provides additional helper functions in the future.
 *
 *  Arguments:
 *      REFGUID [in]: control.
 *      PULONG  [out]: number of nodes found which match the control GUID
 *      PPULONG [out]: pointer to the array containing node ids
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsTopology::FindMultipleToNodes"

HRESULT
CKsTopology::FindMultipleToNodes
(
    ULONG       ulFromNode,
    ULONG       ulFromNodePin,
    PULONG      pCount,
    PULONG*     ppConnectionIndexes
)
{
    ULONG       i;
    ULONG       j;
    HRESULT     hr;

    DPF_ENTER();

    // Count all instances of connection which match the FromNode and FromNodePin.
    *pCount = 0;
    for(i = 0; i < m_paConnectionItems->Count; i++)
    {
        if((ulFromNode == m_paConnections[i].FromNode) &&
           (ulFromNodePin == m_paConnections[i].FromNodePin))
        {
            (*pCount)++;
        }
    }

    // Allocate the array to hold the node numbers
    *ppConnectionIndexes = MEMALLOC_A(ULONG, *pCount);
    hr = HRFROMP(*ppConnectionIndexes);

    // Fill the array with the Node IDs which match
    // the control GUID.
    if(SUCCEEDED(hr))
    {
        j = 0;
        for(i = 0; i < m_paConnectionItems->Count; i++)
        {
            if((ulFromNode == m_paConnections[i].FromNode) &&
               (ulFromNodePin == m_paConnections[i].FromNodePin))
            {
                (*ppConnectionIndexes)[j++] = i;
            }
        }
    }

    DPF_LEAVE(hr);
    return hr;
}


/***************************************************************************
 *
 *  CKsPropertySet
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      LPVOID [in]: instance identifier.
 *      CKsTopology * [in]: pin topology.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::CKsPropertySet"

CKsPropertySet::CKsPropertySet
(
    HANDLE                  hPin,
    LPVOID                  pvInstance,
    CKsTopology *           pTopology
)
{
    DPF_ENTER();
    DPF_CONSTRUCT(CKsPropertySet);

    // Intialize defaults
    m_hPin = hPin;
    m_pvInstance = pvInstance;
    m_pTopology = ADDREF(pTopology);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  ~CKsPropertySet
 *
 *  Description:
 *      Object destructor.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::~CKsPropertySet"

CKsPropertySet::~CKsPropertySet(void)
{
    DPF_ENTER();
    DPF_DESTRUCT(CKsPropertySet);

    // Release the topology object
    RELEASE(m_pTopology);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  QuerySupport
 *
 *  Description:
 *      Queries for property set support.
 *
 *  Arguments:
 *      REFGUID [in]: property set to query for.
 *      ULONG [in]: property id.
 *      LPVOID [in]: property paramaters.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::QuerySupport"

HRESULT
CKsPropertySet::QuerySupport
(
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    PULONG                  pulSupport
)
{
    KSDSPROPERTY            KsDsProperty;
    HRESULT                 hr;

    DPF_ENTER();

    // Search for the node id corresponding to the property set and id
    hr = FindNodeFromProperty(guidPropertySet, ulPropertyId, &KsDsProperty);

    // Convert the access flags to support flags
    if(SUCCEEDED(hr))
    {
        *pulSupport = 0;

        if(KsDsProperty.AccessFlags & KSPROPERTY_TYPE_GET)
        {
            *pulSupport |= KSPROPERTY_SUPPORT_GET;
        }

        if(KsDsProperty.AccessFlags & KSPROPERTY_TYPE_SET)
        {
            *pulSupport |= KSPROPERTY_SUPPORT_SET;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  GetProperty
 *
 *  Description:
 *      Gets a property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: context data.
 *      ULONG [in]: size of context data.
 *      LPVOID [in]: property data.
 *      PULONG [in/out]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::GetProperty"

HRESULT
CKsPropertySet::GetProperty
(
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPVOID                  pvParam,
    ULONG                   cbParam,
    LPVOID                  pvData,
    PULONG                  pcbData
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = DoProperty(guidPropertySet, ulPropertyId, KSPROPERTY_TYPE_GET, pvParam, cbParam, pvData, pcbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  SetProperty
 *
 *  Description:
 *      Sets a property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      LPVOID [in]: context data.
 *      ULONG [in]: size of context data.
 *      LPVOID [in]: property data.
 *      ULONG [in]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::SetProperty"

HRESULT
CKsPropertySet::SetProperty
(
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPVOID                  pvParam,
    ULONG                   cbParam,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = DoProperty(guidPropertySet, ulPropertyId, KSPROPERTY_TYPE_SET, pvParam, cbParam, pvData, &cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DoProperty
 *
 *  Description:
 *      Gets or sets a property.
 *
 *  Arguments:
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      DWORD [in]: Get/set flags.
 *      LPVOID [in]: context data.
 *      ULONG [in]: size of context data.
 *      LPVOID [in]: property data.
 *      PULONG [in/out]: size of property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::DoProperty"

HRESULT
CKsPropertySet::DoProperty
(
    REFGUID                         guidPropertySet,
    ULONG                           ulPropertyId,
    DWORD                           dwFlags,
    LPVOID                          pvParam,
    ULONG                           cbParam,
    LPVOID                          pvData,
    PULONG                          pcbData
)
{
    PKSNODEPROPERTY_AUDIO_PROPERTY  pProperty       = NULL;
    DWORD                           cbProperty      = BLOCKALIGNPAD(sizeof(*pProperty) + cbParam, 8);
    KSDSPROPERTY                    KsDsProperty;
    HRESULT                         hr;

    DPF_ENTER();

    ASSERT(KSPROPERTY_TYPE_GET == dwFlags || KSPROPERTY_TYPE_SET == dwFlags);

    // Search for the node id corresponding to the property set and id
    hr = FindNodeFromProperty(guidPropertySet, ulPropertyId, &KsDsProperty);

    if(SUCCEEDED(hr) && !(KsDsProperty.AccessFlags & dwFlags))
    {
        RPF(DPFLVL_ERROR, "The property does not support this method");
        hr = DSERR_UNSUPPORTED;
    }

    // Create the property description
    if(SUCCEEDED(hr))
    {
        pProperty = (PKSNODEPROPERTY_AUDIO_PROPERTY)MEMALLOC_A(BYTE, cbProperty);
        hr = HRFROMP(pProperty);
    }

    if(SUCCEEDED(hr))
    {
        pProperty->NodeProperty.Property.Set = KsDsProperty.PropertySet;
        pProperty->NodeProperty.Property.Id = KsDsProperty.PropertyId;
        pProperty->NodeProperty.Property.Flags = KSPROPERTY_TYPE_TOPOLOGY | dwFlags;

        pProperty->NodeProperty.NodeId = KsDsProperty.NodeId;
        pProperty->NodeProperty.Reserved = 0;

        pProperty->AppContext = m_pvInstance;
        pProperty->Length = cbParam;

#ifndef WIN64

        pProperty->Reserved = 0;

#endif // WIN64

        if(cbParam)
        {
            CopyMemory(pProperty + 1, pvParam, cbParam);
        }
    }

    // Get the property
    if(SUCCEEDED(hr))
    {
        hr = PostDevIoctl(m_hPin, IOCTL_KS_PROPERTY, pProperty, cbProperty, pvData, *pcbData, pcbData);
    }

    // Clean up
    MEMFREE(pProperty);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  FindNodeFromProperty
 *
 *  Description:
 *      Searches the linked list associating the property set and id
 *      with the Device Specific node Id.
 *
 *  Arguments:
 *      REFGUID [in]: property set to query for.
 *      ULONG [in]: property id.
 *      PKSDSPROPERTY [out]: receives property data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "CKsPropertySet::FindNodeFromProperty"

HRESULT
CKsPropertySet::FindNodeFromProperty
(
    REFGUID                         guidPropertySet,
    ULONG                           ulPropertyId,
    PKSDSPROPERTY                   pKsDsProperty
)
{
    HRESULT                         hr              = DS_OK;
    PKSTOPOLOGY_CONNECTION          pConnection     = NULL;
    KSNODEPROPERTY_AUDIO_PROPERTY   Property;
    KSPROPERTY_DESCRIPTION          Description;
    CNode<KSDSPROPERTY> *           pPropertyNode;

    DPF_ENTER();

    // Do we already know about this property?
    for(pPropertyNode = m_lstProperties.GetListHead(); pPropertyNode; pPropertyNode = pPropertyNode->m_pNext)
    {
        if(guidPropertySet == pPropertyNode->m_data.PropertySet)
        {
            if(ulPropertyId == pPropertyNode->m_data.PropertyId)
            {
                break;
            }
        }
    }

    if(pPropertyNode)
    {
        // Yup.  Fill in the property.
        CopyMemory(pKsDsProperty, &pPropertyNode->m_data, sizeof(pPropertyNode->m_data));
    }
    else
    {
        // Nope.  Let's query the driver for it.

        // Since in general we'll only find the first node that supports the property we're interested in,
        // for "special" properties we'll try to increase the likelihood of getting the correct node

        if(guidPropertySet == KSPROPSETID_Audio && ulPropertyId == KSPROPERTY_AUDIO_QUALITY)
        {
            // Get the same SRC connection that dsound uses internally for SRC quality setting
            PKSTOPOLOGY_CONNECTION pSummingConnection = m_pTopology->FindControlConnection(NULL, NULL, KSNODETYPE_SUM);
            pConnection = m_pTopology->FindControlConnection(NULL, pSummingConnection, KSNODETYPE_SRC);
        }

        Property.NodeProperty.Property.Set = guidPropertySet;
        Property.NodeProperty.Property.Id = ulPropertyId;
        Property.NodeProperty.Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_TOPOLOGY;
        Property.NodeProperty.Reserved = 0;
        Property.AppContext = 0;
        Property.Length = 0;

        if(pConnection)
        {
            // this is a special case property and we've already found the node we're interested in
            Property.NodeProperty.NodeId = m_pTopology->GetNodeIdFromConnection(pConnection);

            hr = PostDevIoctl(m_hPin, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &Description, sizeof(Description));

            // We found a node that supports the property.  Add it to the list of known properties.
            if(SUCCEEDED(hr))
            {
                pKsDsProperty->PropertySet = Property.NodeProperty.Property.Set;
                pKsDsProperty->PropertyId = Property.NodeProperty.Property.Id;
                pKsDsProperty->NodeId = Property.NodeProperty.NodeId;
                pKsDsProperty->AccessFlags = Description.AccessFlags;

                pPropertyNode = m_lstProperties.AddNodeToList(*pKsDsProperty);
                hr = HRFROMP(pPropertyNode);
            }
        }
        else
        {
            // Else traverse through the connections looking for the first node that supports this property
            while(pConnection = m_pTopology->GetNextConnection(pConnection))
            {
                Property.NodeProperty.NodeId = m_pTopology->GetNodeIdFromConnection(pConnection);

                hr = PostDevIoctl(m_hPin, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &Description, sizeof(Description));

                // We found a node that supports the property.  Add it to the list of known properties.
                if(SUCCEEDED(hr))
                {
                    pKsDsProperty->PropertySet = Property.NodeProperty.Property.Set;
                    pKsDsProperty->PropertyId = Property.NodeProperty.Property.Id;
                    pKsDsProperty->NodeId = Property.NodeProperty.NodeId;
                    pKsDsProperty->AccessFlags = Description.AccessFlags;

                    pPropertyNode = m_lstProperties.AddNodeToList(*pKsDsProperty);
                    hr = HRFROMP(pPropertyNode);

                    break;
                }
            }
        }
    }

    if(FAILED(hr) || (SUCCEEDED(hr) && !pPropertyNode))
    {
        RPF(DPFLVL_ERROR, "Unable to find a topology node supporting the requested property");
        hr = DSERR_UNSUPPORTED;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  PostDevIoctl
 *
 *  Description:
 *      Wrapper for DeviceIoControl.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: control code.
 *      LPVOID [in]: input data.
 *      DWORD [in]: size of input data.
 *      LPVOID [out]: receives output data.
 *      DWORD [in]: size of output data buffer.
 *      LPOVERLAPPED [in]: overlapped IO data.  This argument may be NULL.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "PostDevIoctl"

HRESULT
PostDevIoctl
(
    HANDLE                  hDevice,
    DWORD                   dwControlCode,
    LPVOID                  pvIn,
    DWORD                   cbIn,
    LPVOID                  pvOut,
    DWORD                   cbOut,
    LPDWORD                 pcbReturned,
    LPOVERLAPPED            pOverlapped
)
{
    HRESULT                 hr          = DS_OK;
    static OVERLAPPED       ovlAsynch;
    DWORD                   cbReturned;
    BOOL                    fSuccess;
    DWORD                   dwError;
    DWORD                   dwWait;

    DPF_ENTER();

    // The returned size parameter is optional
    if(!pcbReturned)
    {
        pcbReturned = &cbReturned;
    }

    *pcbReturned = MAX_DWORD;

    // All IOCTLs must have an overlapped structure.  This function cannot
    // be used for any devices that were not opened with FILE_FLAG_OVERLAPPED.
    if(!pOverlapped)
    {
        if(!ovlAsynch.hEvent)
        {
            // We're going to leak this event when the DLL unloads, but
            // that's OK; Windows will clean up for us.  Note: because
            // we're using a static structure and a single event, this
            // function must ALWAYS be synchronized across threads.
            ovlAsynch.hEvent = CreateGlobalEvent(NULL, FALSE);

            if(!IsValidHandleValue(ovlAsynch.hEvent))
            {
                hr = GetLastErrorToHRESULT();
            }
        }

        pOverlapped = &ovlAsynch;
    }

    // Post the IOCTL
    if(SUCCEEDED(hr))
    {
        fSuccess = DeviceIoControl(hDevice, dwControlCode, pvIn, cbIn, pvOut, cbOut, pcbReturned, pOverlapped);

        if(fSuccess)
        {
            dwError = ERROR_SUCCESS;
        }
        else
        {
            dwError = GetLastError();
            ASSERT(ERROR_SUCCESS != dwError);
        }

        // Check the return value for ERROR_IO_PENDING.  If we sent an
        // asynchronous IOCTL, DeviceIoControl will actually fail with
        // ERROR_IO_PENDING.  As long as the calling function specified an
        // overlapped object, that's ok.
        if(ERROR_IO_PENDING == dwError)
        {
            dwError = ERROR_SUCCESS;

            if(&ovlAsynch == pOverlapped)
            {
                dwWait = WaitObject(INFINITE, pOverlapped->hEvent);
                ASSERT(WAIT_OBJECT_0 == dwWait);

                fSuccess = GetOverlappedResult(hDevice, pOverlapped, pcbReturned, FALSE);

                if(!fSuccess)
                {
                    dwError = GetLastError();
                    ASSERT(ERROR_SUCCESS != dwError);
                    ASSERT(ERROR_IO_PENDING != dwError);
                }
            }
        }

        // Check the return value for any variations of ERROR_INSUFFICIENT_BUFFER.
        // It's possible that more data is available.
        if(ERROR_BUFFER_OVERFLOW == dwError || ERROR_MORE_DATA == dwError || ERROR_INSUFFICIENT_BUFFER == dwError)
        {
            ASSERT(MAX_DWORD != *pcbReturned);

            if(&cbReturned != pcbReturned)
            {
                dwError = ERROR_SUCCESS;
            }
        }

        // Done with error handling
        if(ERROR_SUCCESS != dwError)
        {
            if (dwError == ERROR_NOT_FOUND || dwError == ERROR_SET_NOT_FOUND)
            {
                // These are very common return codes from KS in normal operation
                DPF(DPFLVL_MOREINFO, "DeviceIoControl failed with ERROR_%sNOT_FOUND",
                    dwError == ERROR_SET_NOT_FOUND ? TEXT("SET_") : TEXT(""));
            }
            else
            {
                DPF(DPFLVL_WARNING, "DeviceIoControl failed with error %lu", dwError);
            }
            hr = WIN32ERRORtoHRESULT(dwError);
        }
    }

#ifdef DEBUG
    g_ulKsIoctlCount++;
#endif // DEBUG

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetProperty
 *
 *  Description:
 *      Retrieves a particular property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      DWORD [in]: property id.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetProperty"

HRESULT
KsGetProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSPROPERTY              Property;
    HRESULT                 hr;

    DPF_ENTER();

    Property.Set = guidPropertySet;
    Property.Id = ulPropertyId;
    Property.Flags = KSPROPERTY_TYPE_GET;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Property, sizeof(Property), pvData, cbData, pcbDataReturned);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetProperty
 *
 *  Description:
 *      Sets a particular property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      DWORD [in]: property id.
 *      LPVOID [in]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetProperty"

HRESULT
KsSetProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSPROPERTY              Property;
    HRESULT                 hr;

    DPF_ENTER();

    Property.Set = guidPropertySet;
    Property.Id = ulPropertyId;
    Property.Flags = KSPROPERTY_TYPE_SET;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Property, sizeof(Property), pvData, cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetState
 *
 *  Description:
 *      Retrieves a state property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSSTATE [out]: receives state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetState"

HRESULT
KsGetState
(
    HANDLE                  hDevice,
    PKSSTATE                pState
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetProperty(hDevice, KSPROPSETID_Connection, KSPROPERTY_CONNECTION_STATE, pState, sizeof(*pState));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetState
 *
 *  Description:
 *      Sets a state property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      KSSTATE [in]: state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetState"

HRESULT
KsSetState
(
    HANDLE                  hDevice,
    KSSTATE                 State
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsSetProperty(hDevice, KSPROPSETID_Connection, KSPROPERTY_CONNECTION_STATE, &State, sizeof(State));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsTransitionState
 *
 *  Description:
 *      Sets a state property on a device.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      KSSTATE [in]: current state.
 *      KSSTATE [in]: new state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsTransitionState"

HRESULT
KsTransitionState
(
    HANDLE                  hDevice,
    KSSTATE                 nCurrentState,
    KSSTATE                 nNewState
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    while(nCurrentState != nNewState)
    {
        if(nCurrentState < nNewState)
        {
            nCurrentState = (KSSTATE)(nCurrentState + 1);
        }
        else
        {
            nCurrentState = (KSSTATE)(nCurrentState - 1);
        }

        hr = KsSetState(hDevice, nCurrentState);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsResetState
 *
 *  Description:
 *      Resets the state of a pin back to the state
 *      it was in upon being set to PAUSE originally.
 *      Dsound is using it to cancel pending irps on the
 *      capture and render devices.  The pin must be
 *      in the PAUSE state when calling this function.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      KSSTATE [in]: state.
 *      PKSSTREAMIO [in/out]: stream data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsResetState"

HRESULT
KsResetState
(
    HANDLE                  hDevice,
    KSRESET                 ResetValue
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = PostDevIoctl(hDevice, IOCTL_KS_RESET_STATE, &ResetValue, sizeof(ResetValue));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetPinProperty
 *
 *  Description:
 *      Retrieves a particular property on a pin.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: property id.
 *      DWORD [in]: pin id.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetPinProperty"

HRESULT
KsGetPinProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulPinId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSP_PIN                 Pin;
    HRESULT                 hr;

    DPF_ENTER();

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = ulPropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;

    Pin.PinId = ulPinId;
    Pin.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), pvData, cbData, pcbDataReturned);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetPinProperty
 *
 *  Description:
 *      Sets a particular property on a pin.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: property id.
 *      DWORD [in]: pin id.
 *      LPVOID [out]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetPinProperty"

HRESULT
KsSetPinProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulPinId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSP_PIN                 Pin;
    HRESULT                 hr;

    DPF_ENTER();

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = ulPropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_SET;

    Pin.PinId = ulPinId;
    Pin.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), pvData, cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsFindConnection
 *
 *  Description:
 *      Finds a particular topology connection structure from an array.
 *
 *  Arguments:
 *      PKSTOPOLOGY_CONNECTION [in]: connection structure array.
 *      ULONG [in]: count of items in the connection array.
 *      PKSTOPOLOGY_CONNECTION [in]: item to find.
 *
 *  Returns:
 *      PKSTOPOLOGY_CONNECTION: connection.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsFindConnection"

PKSTOPOLOGY_CONNECTION
KsFindConnection
(
    PKSTOPOLOGY_CONNECTION  paConnections,
    ULONG                   cConnections,
    PKSTOPOLOGY_CONNECTION  pNext
)
{
    PKSTOPOLOGY_CONNECTION  pConnection = NULL;

    DPF_ENTER();

    while(cConnections--)
    {
        if(NODE_WILDCARD == pNext->FromNode || pNext->FromNode == paConnections->FromNode)
        {
            if(NODE_WILDCARD == pNext->FromNodePin || pNext->FromNodePin == paConnections->FromNodePin)
            {
                if(NODE_WILDCARD == pNext->ToNode || pNext->ToNode == paConnections->ToNode)
                {
                    if(NODE_WILDCARD == pNext->ToNodePin || pNext->ToNodePin == paConnections->ToNodePin)
                    {
                        pConnection = paConnections;
                        break;
                    }
                }
            }
        }

        paConnections++;
    }

    pConnection = KsValidateConnection(pConnection);

    DPF_LEAVE(pConnection);
    return pConnection;
}


/***************************************************************************
 *
 *  KsGetFirstPinConnection
 *
 *  Description:
 *      Gets the index of the first topology connection.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PULONG [out]: receives index identifier.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetFirstPinConnection"

HRESULT
KsGetFirstPinConnection
(
    HANDLE                  hDevice,
    PULONG                  pIndex
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetProperty(hDevice, KSPROPSETID_Sysaudio_Pin, KSPROPERTY_SYSAUDIO_TOPOLOGY_CONNECTION_INDEX, pIndex, sizeof(*pIndex));

    if(SUCCEEDED(hr) && MAX_ULONG == *pIndex)
    {
        hr = DSERR_GENERIC;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsWriteStream
 *
 *  Description:
 *      Writes data to a stream pin.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      LPVOID [out]: data.
 *      ULONG [in]: size of above buffer.
 *      ULONG [in]: flags.
 *      PKSSTREAMIO [in]: overlapped io data.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsWriteStream"

HRESULT
KsWriteStream
(
    HANDLE                  hDevice,
    LPCVOID                 pvData,
    ULONG                   cbData,
    ULONG                   ulFlags,
    PKSSTREAMIO             pKsStreamIo
)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(!pKsStreamIo->fPendingIrp);

    pKsStreamIo->Header.Size = sizeof(pKsStreamIo->Header);
    pKsStreamIo->Header.TypeSpecificFlags = 0;

    pKsStreamIo->Header.PresentationTime.Time = 0;
    pKsStreamIo->Header.PresentationTime.Numerator = 1;
    pKsStreamIo->Header.PresentationTime.Denominator = 1;

    pKsStreamIo->Header.Duration = 0;
    pKsStreamIo->Header.FrameExtent = cbData;
    pKsStreamIo->Header.DataUsed = cbData;
    pKsStreamIo->Header.Data = (LPVOID)pvData;
    pKsStreamIo->Header.OptionsFlags = ulFlags;

    hr = PostDevIoctl(hDevice, IOCTL_KS_WRITE_STREAM, NULL, 0, &pKsStreamIo->Header, pKsStreamIo->Header.Size, NULL, &pKsStreamIo->Overlapped);

    if(SUCCEEDED(hr))
    {
        pKsStreamIo->fPendingIrp = TRUE;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsReadStream
 *
 *  Description:
 *      Reads data from a stream pin.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      LPVOID [out]: data.
 *      ULONG [in]: size of above buffer.
 *      ULONG [in]: flags.
 *      PKSSTREAMIO [in]: stream overlapped io data block.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsReadStream"

HRESULT
KsReadStream
(
    HANDLE                  hDevice,
    LPVOID                  pvData,
    ULONG                   cbData,
    ULONG                   ulFlags,
    PKSSTREAMIO             pKsStreamIo
)
{
    HRESULT                 hr;

    DPF_ENTER();

    ASSERT(!pKsStreamIo->fPendingIrp);

    pKsStreamIo->Header.Size = sizeof(pKsStreamIo->Header);
    pKsStreamIo->Header.TypeSpecificFlags = 0;

    pKsStreamIo->Header.PresentationTime.Time = 0;
    pKsStreamIo->Header.PresentationTime.Numerator = 1;
    pKsStreamIo->Header.PresentationTime.Denominator = 1;

    pKsStreamIo->Header.Duration = 0;
    pKsStreamIo->Header.FrameExtent = cbData;
    pKsStreamIo->Header.DataUsed = 0;
    pKsStreamIo->Header.Data = pvData;
    pKsStreamIo->Header.OptionsFlags = ulFlags;

    hr = PostDevIoctl(hDevice, IOCTL_KS_READ_STREAM, NULL, 0, &pKsStreamIo->Header, pKsStreamIo->Header.Size, NULL, &pKsStreamIo->Overlapped);

    if(SUCCEEDED(hr))
    {
        pKsStreamIo->fPendingIrp = TRUE;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetNodeProperty
 *
 *  Description:
 *      Retrieves a particular property on a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      ULONG [in]: flags.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetNodeProperty"

HRESULT
KsGetNodeProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSNODEPROPERTY          NodeProperty;
    HRESULT                 hr;

    DPF_ENTER();

    NodeProperty.Property.Set = guidPropertySet;
    NodeProperty.Property.Id = ulPropertyId;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    NodeProperty.NodeId = ulNodeId;
    NodeProperty.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &NodeProperty, sizeof(NodeProperty), pvData, cbData, pcbDataReturned);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetNodeProperty
 *
 *  Description:
 *      Sets a particular property on a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      ULONG [in]: flags.
 *      LPVOID [in]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetNodeProperty"

HRESULT
KsSetNodeProperty
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulPropertyId,
    ULONG                   ulNodeId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSNODEPROPERTY          NodeProperty;
    HRESULT                 hr;

    DPF_ENTER();

    NodeProperty.Property.Set = guidPropertySet;
    NodeProperty.Property.Id = ulPropertyId;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    NodeProperty.NodeId = ulNodeId;
    NodeProperty.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &NodeProperty, sizeof(NodeProperty), pvData, cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


#ifdef DEAD_CODE
/***************************************************************************
 *
 *  KsGet3dNodeProperty
 *
 *  Description:
 *      Retrieves a particular property on a 3d listener or effects
 *      topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      LPVOID [in]: instance data.
 *      LPVOID [out]: receives property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGet3dNodeProperty"

HRESULT
KsGet3dNodeProperty
(
    HANDLE                              hDevice,
    REFGUID                             guidPropertySet,
    ULONG                               ulPropertyId,
    ULONG                               ulNodeId,
    LPVOID                              pvInstance,
    LPVOID                              pvData,
    ULONG                               cbData,
    PULONG                              pcbDataReturned
)
{
    KSNODEPROPERTY_AUDIO_3D_LISTENER    Listener;
    HRESULT                             hr;

    DPF_ENTER();

    Listener.NodeProperty.Property.Set = guidPropertySet;
    Listener.NodeProperty.Property.Id = ulPropertyId;
    Listener.NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    Listener.NodeProperty.NodeId = ulNodeId;
    Listener.NodeProperty.Reserved = 0;

    Listener.ListenerId = pvInstance;

#ifndef WIN64

    Listener.Reserved = 0;

#endif // WIN64

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Listener, sizeof(Listener), pvData, cbData, pcbDataReturned);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // DEAD_CODE


/***************************************************************************
 *
 *  KsSet3dNodeProperty
 *
 *  Description:
 *      Sets a particular property on a 3d listener or effects
 *      topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: node id.
 *      LPVOID [in]: instance data.
 *      LPVOID [in]: property data.
 *      DWORD [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSet3dNodeProperty"

HRESULT
KsSet3dNodeProperty
(
    HANDLE                              hDevice,
    REFGUID                             guidPropertySet,
    ULONG                               ulPropertyId,
    ULONG                               ulNodeId,
    LPVOID                              pvInstance,
    LPVOID                              pvData,
    DWORD                               cbData
)
{
    KSNODEPROPERTY_AUDIO_3D_LISTENER    Listener;
    HRESULT                             hr;

    DPF_ENTER();

    Listener.NodeProperty.Property.Set = guidPropertySet;
    Listener.NodeProperty.Property.Id = ulPropertyId;
    Listener.NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    Listener.NodeProperty.NodeId = ulNodeId;
    Listener.NodeProperty.Reserved = 0;

    Listener.ListenerId = pvInstance;

#ifndef WIN64

    Listener.Reserved = 0;

#endif // WIN64

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Listener, sizeof(Listener), pvData, cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DsSpeakerConfigToKsProperties
 *
 *  Description:
 *      Translates a DirectSound speaker config code into the values taken
 *      by the corresponding KS properties: KSPROPERTY_AUDIO_CHANNEL_CONFIG
 *      and KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY.
 *
 *  Arguments:
 *      DWORD [in]: DirectSound speaker configuration.
 *      PLONG [out]: receives KsSpeakerConfig value.
 *      PLONG [out]: receives KsStereoSpeakerGeometry value.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DsSpeakerConfigToKsProperties"

HRESULT
DsSpeakerConfigToKsProperties
(
    DWORD                               dwSpeakerConfig,
    PLONG                               pKsSpeakerConfig,
    PLONG                               pKsStereoSpeakerGeometry
)
{
    HRESULT                             hr = DS_OK;

    DPF_ENTER();

    switch (DSSPEAKER_CONFIG(dwSpeakerConfig))
    {
        case DSSPEAKER_DIRECTOUT:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_DIRECTOUT;
            break;

        case DSSPEAKER_HEADPHONE:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_STEREO;
            *pKsStereoSpeakerGeometry = KSAUDIO_STEREO_SPEAKER_GEOMETRY_HEADPHONE;
            break;

        case DSSPEAKER_MONO:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_MONO;
            break;

        case DSSPEAKER_STEREO:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_STEREO;
            *pKsStereoSpeakerGeometry = (LONG)DSSPEAKER_GEOMETRY(dwSpeakerConfig);
            if (!*pKsStereoSpeakerGeometry)
                *pKsStereoSpeakerGeometry = KSAUDIO_STEREO_SPEAKER_GEOMETRY_WIDE;
            break;

        case DSSPEAKER_QUAD:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_QUAD;
            break;

        case DSSPEAKER_SURROUND:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_SURROUND;
            break;

        case DSSPEAKER_5POINT1:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_5POINT1;
            break;

        case DSSPEAKER_7POINT1:
            *pKsSpeakerConfig = KSAUDIO_SPEAKER_7POINT1;
            break;

        default:
            ASSERT(FALSE);
            hr = DSERR_GENERIC;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  DsBufferFlagsToKsPinFlags
 *
 *  Description:
 *      Converts DirectSound flags to KSDATAFORMAT_DSOUND flags.
 *
 *  Arguments:
 *      DWORD [in]: DirectSound buffer flags.
 *
 *  Returns:
 *      DWORD: KSDATAFORMAT_DSOUND flags.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DsBufferFlagsToKsPinFlags"

DWORD
DsBufferFlagsToKsPinFlags
(
    DWORD                   dwDsFlags
)
{
    DWORD                   dwKsFlags   = 0;

    DPF_ENTER();

    if(dwDsFlags & DSBCAPS_PRIMARYBUFFER)
    {
        dwKsFlags |= KSDSOUND_BUFFER_PRIMARY;
    }

    if(dwDsFlags & DSBCAPS_STATIC)
    {
        dwKsFlags |= KSDSOUND_BUFFER_STATIC;
    }

    if(dwDsFlags & DSBCAPS_LOCHARDWARE)
    {
        dwKsFlags |= KSDSOUND_BUFFER_LOCHARDWARE;
    }
    else if(dwDsFlags & DSBCAPS_LOCSOFTWARE)
    {
        dwKsFlags |= KSDSOUND_BUFFER_LOCSOFTWARE;
    }

    DPF_LEAVE(dwKsFlags);
    return dwKsFlags;
}


/***************************************************************************
 *
 *  DsBufferFlagsToKsControlFlags
 *
 *  Description:
 *      Converts DirectSound flags to KSDATAFORMAT_DSOUND control flags.
 *
 *  Arguments:
 *      DWORD [in]: DirectSound buffer flags.
 *      REFGUID [in]: 3D algorithm GUID.
 *
 *  Returns:
 *      DWORD: KSDATAFORMAT_DSOUND control flags.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DsBufferFlagsToKsControlFlags"

DWORD
DsBufferFlagsToKsControlFlags
(
    DWORD                   dwDsFlags,
    REFGUID                 guid3dAlgorithm
)
{
    DWORD                   dwKsFlags   = 0;

    DPF_ENTER();

    if(dwDsFlags & DSBCAPS_CTRLFREQUENCY)
    {
        dwKsFlags |= KSDSOUND_BUFFER_CTRL_FREQUENCY;
    }

    if(dwDsFlags & DSBCAPS_CTRLPAN)
    {
        dwKsFlags |= KSDSOUND_BUFFER_CTRL_PAN;
    }

    if(dwDsFlags & DSBCAPS_CTRLVOLUME)
    {
        dwKsFlags |= KSDSOUND_BUFFER_CTRL_VOLUME;
    }

    if(dwDsFlags & DSBCAPS_CTRLPOSITIONNOTIFY)
    {
        dwKsFlags |= KSDSOUND_BUFFER_CTRL_POSITIONNOTIFY;
    }

    if(dwDsFlags & DSBCAPS_CTRL3D)
    {
        dwKsFlags |= KSDSOUND_BUFFER_CTRL_3D;

        if(DS3DALG_HRTF_FULL == guid3dAlgorithm || DS3DALG_HRTF_LIGHT == guid3dAlgorithm)
        {
            dwKsFlags |= KSDSOUND_BUFFER_CTRL_HRTF_3D;
        }
    }

    DPF_LEAVE(dwKsFlags);
    return dwKsFlags;
}


/***************************************************************************
 *
 *  Ds3dModeToKs3dMode
 *
 *  Description:
 *      Converts DirectSound 3D mode to KS 3D Mode.
 *
 *  Arguments:
 *      DWORD [in]:  DirectSound 3D mode.
 *
 *  Returns:
 *      DWORD: KS 3D mode.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "Ds3dModeToKs3dMode"

DWORD
Ds3dModeToKs3dMode
(
    DWORD                   dwDsMode
)
{
    DWORD                   dwKsMode;

    switch(dwDsMode)
    {
        default:
            ASSERT(!"Impossible dwDsMode");
            // Fall through to set the mode to NORMAL

        case DS3DMODE_NORMAL:
            dwKsMode = KSDSOUND_3D_MODE_NORMAL;
            break;

        case DS3DMODE_HEADRELATIVE:
            dwKsMode = KSDSOUND_3D_MODE_HEADRELATIVE;
            break;

        case DS3DMODE_DISABLE:
            dwKsMode = KSDSOUND_3D_MODE_DISABLE;
            break;
    }

    return dwKsMode;
}


/***************************************************************************
 *
 *  KsGetMultiplePinProperties
 *
 *  Description:
 *      Retrieves a particular property on a pin.  Use this function when
 *      the property is expected to come back in KSMULTIPLE_ITEM format.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: property id.
 *      DWORD [in]: pin id.
 *      PKSMULTIPLE_ITEM * [out]: receives pointer to property data.  This
 *                                memory must be freed by the caller.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetMultiplePinProperties"

HRESULT
KsGetMultiplePinProperties
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulPinId,
    PKSMULTIPLE_ITEM *      ppKsMultipleItem
)
{
    LPVOID                  pvProperty  = NULL;
    ULONG                   cbProperty  = 0;
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetPinProperty(hDevice, ulPropertyId, ulPinId, NULL, 0, &cbProperty);

    if(SUCCEEDED(hr) && !cbProperty)
    {
        DPF(DPFLVL_ERROR, "Property size is 0");
        hr = DSERR_GENERIC;
    }

    if(SUCCEEDED(hr))
    {
        pvProperty = MEMALLOC_A(BYTE, cbProperty);
        hr = HRFROMP(pvProperty);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetPinProperty(hDevice, ulPropertyId, ulPinId, pvProperty, cbProperty);
    }

    if(SUCCEEDED(hr))
    {
        *ppKsMultipleItem = (PKSMULTIPLE_ITEM)pvProperty;
    }
    else
    {
        MEMFREE(pvProperty);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetMultipleTopologyProperties
 *
 *  Description:
 *      Retrieves a particular property on a node.  Use this function when
 *      the property is expected to come back in KSMULTIPLE_ITEM format.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      DWORD [in]: property id.
 *      DWORD [in]: node id.
 *      PKSMULTIPLE_ITEM * [out]: receives pointer to property data.  This
 *                                memory must be freed by the caller.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetMultipleTopologyProperties"

HRESULT
KsGetMultipleTopologyProperties
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    PKSMULTIPLE_ITEM *      ppKsMultipleItem
)
{
    LPVOID                  pvProperty  = NULL;
    ULONG                   cbProperty  = 0;
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetProperty(hDevice, KSPROPSETID_Topology, ulPropertyId, NULL, 0, &cbProperty);

    if(SUCCEEDED(hr) && !cbProperty)
    {
        DPF(DPFLVL_ERROR, "Property size is 0");
        hr = DSERR_GENERIC;
    }

    if(SUCCEEDED(hr))
    {
        pvProperty = MEMALLOC_A(BYTE, cbProperty);
        hr = HRFROMP(pvProperty);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetProperty(hDevice, KSPROPSETID_Topology, ulPropertyId, pvProperty, cbProperty);
    }

    if(SUCCEEDED(hr))
    {
        *ppKsMultipleItem = (PKSMULTIPLE_ITEM)pvProperty;
    }
    else
    {
        MEMFREE(pvProperty);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetPinPcmAudioDataRange
 *
 *  Description:
 *      Retrieves PCM audio data range for a pin.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: pin id.
 *      PKSDATARANGE_AUDIO [out]: receives aggregate data range.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetPinPcmAudioDataRange"

HRESULT
KsGetPinPcmAudioDataRange
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    PKSDATARANGE_AUDIO      pDataRange,
    BOOL                    fCapture
)
{
    PKSMULTIPLE_ITEM        pMultiItem      = NULL;
    PKSDATARANGE_AUDIO      pLocalDataRange;
    BOOL                    fFoundIt;
    HRESULT                 hr;

    DPF_ENTER();

    // Get supported data range(s)
    hr = KsGetMultiplePinProperties(hDevice, KSPROPERTY_PIN_DATARANGES, ulPinId, &pMultiItem);

    // Look for the audio data range(s)
    if(SUCCEEDED(hr))
    {
        for(pLocalDataRange = (PKSDATARANGE_AUDIO)(pMultiItem + 1), fFoundIt = FALSE; pMultiItem->Count; pMultiItem->Count--, pLocalDataRange = (PKSDATARANGE_AUDIO)((LPBYTE)pLocalDataRange + pLocalDataRange->DataRange.FormatSize))
        {
            if(pLocalDataRange->DataRange.MajorFormat == GUID_NULL ||
               pLocalDataRange->DataRange.MajorFormat == KSDATAFORMAT_TYPE_AUDIO)
            {
                if(pLocalDataRange->DataRange.SubFormat == GUID_NULL ||
                   pLocalDataRange->DataRange.SubFormat == KSDATAFORMAT_SUBTYPE_PCM)
                {
#ifdef NO_DSOUND_FORMAT_SPECIFIER
                    if (pLocalDataRange->DataRange.Specifier == KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)
#else
                    // Note: we only use the DSOUND format specifier for render pins
                    if (pLocalDataRange->DataRange.Specifier == (fCapture ? KSDATAFORMAT_SPECIFIER_WAVEFORMATEX : KSDATAFORMAT_SPECIFIER_DSOUND))
#endif
                    {
                        // The pin may support multiple data ranges, so we'll
                        // use an aggregate of all the values
                        if(fFoundIt)
                        {
                            KsAggregatePinAudioDataRange(pLocalDataRange, pDataRange);
                        }
                        else
                        {
                            CopyMemory(pDataRange, pLocalDataRange, sizeof(*pDataRange));
                            fFoundIt = TRUE;
                        }
                    }
                }
            }
        }

        if(!fFoundIt)
        {
            DPF(DPFLVL_ERROR, "Can't find PCM audio data range on pin %u", ulPinId);
            hr = DSERR_GENERIC;
        }
    }

    // Clean up
    MEMFREE(pMultiItem);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsOpenSysAudioDevice
 *
 *  Description:
 *      Opens the system audio device device.
 *
 *  Arguments:
 *      LPHANDLE [out]: receives system audio device handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsOpenSysAudioDevice"

HRESULT
KsOpenSysAudioDevice
(
    LPHANDLE                    phDevice
)
{
    CPnpHelper *                pPnp                = NULL;
    SP_DEVICE_INTERFACE_DATA    DeviceInterfaceData;
    HRESULT                     hr;

    DPF_ENTER();

    // Create the PnP helper object
    pPnp = NEW(CPnpHelper);
    hr = HRFROMP(pPnp);

    if(SUCCEEDED(hr))
    {
        hr = pPnp->Initialize(KSCATEGORY_SYSAUDIO, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
    }

    // Get the first interface in the set
    if(SUCCEEDED(hr))
    {
        hr = pPnp->EnumDeviceInterface(KSCATEGORY_SYSAUDIO, 0, &DeviceInterfaceData);

        if(S_FALSE == hr)
        {
            DPF(DPFLVL_ERROR, "No interfaces matching KSCATEGORY_SYSAUDIO exist");
            hr = DSERR_NODRIVER;
        }
    }

    // Open the interface
    if(SUCCEEDED(hr))
    {
        hr = pPnp->OpenDeviceInterface(&DeviceInterfaceData, phDevice);
    }

    // Clean up
    RELEASE(pPnp);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetSysAudioProperty
 *
 *  Description:
 *      Gets a SAD property.
 *
 *  Arguments:
 *      HANDLE [in]: SAD device handle.
 *      ULONG [in]: property id.
 *      ULONG [in]: device index.
 *      LPVOID [out]: data buffer.
 *      ULONG [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetSysAudioProperty"

HRESULT
KsGetSysAudioProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulDeviceId,
    LPVOID                  pvData,
    ULONG                   cbData,
    PULONG                  pcbDataReturned
)
{
    KSSADPROPERTY           SadProperty;
    HRESULT                 hr;

    DPF_ENTER();

    SadProperty.Property.Set = KSPROPSETID_Sysaudio;
    SadProperty.Property.Id = ulPropertyId;
    SadProperty.Property.Flags = KSPROPERTY_TYPE_GET;

    SadProperty.DeviceId = ulDeviceId;
    SadProperty.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &SadProperty, sizeof(SadProperty), pvData, cbData, pcbDataReturned);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetSysAudioProperty
 *
 *  Description:
 *      Sets a SAD property.
 *
 *  Arguments:
 *      HANDLE [in]: SAD device handle.
 *      ULONG [in]: property id.
 *      ULONG [in]: device index.
 *      LPVOID [in]: data buffer.
 *      ULONG [in]: size of above buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetSysAudioProperty"

HRESULT
KsSetSysAudioProperty
(
    HANDLE                  hDevice,
    ULONG                   ulPropertyId,
    ULONG                   ulDeviceId,
    LPVOID                  pvData,
    ULONG                   cbData
)
{
    KSSADPROPERTY           SadProperty;
    HRESULT                 hr;

    DPF_ENTER();

    SadProperty.Property.Set = KSPROPSETID_Sysaudio;
    SadProperty.Property.Id = ulPropertyId;
    SadProperty.Property.Flags = KSPROPERTY_TYPE_SET;

    SadProperty.DeviceId = ulDeviceId;
    SadProperty.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &SadProperty, sizeof(SadProperty), pvData, cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsCreateSysAudioVirtualSource
 *
 *  Description:
 *      Create a virtual source on SAD.
 *
 *  Arguments:
 *      HANDLE [in]: SAD device handle.
 *      PULONG [out]: Virtual source index pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsCreateSysAudioVirtualSource"

HRESULT
KsCreateSysAudioVirtualSource
(
    HANDLE                          hDevice,
    PULONG                          pulVirtualSourceIndex
)
{
    SYSAUDIO_CREATE_VIRTUAL_SOURCE  CreateVirtualSource;
    HRESULT                         hr;

    DPF_ENTER();

    CreateVirtualSource.Property.Set = KSPROPSETID_Sysaudio;
    CreateVirtualSource.Property.Id = KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE;
    CreateVirtualSource.Property.Flags = KSPROPERTY_TYPE_GET;

    CreateVirtualSource.PinCategory = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;
    CreateVirtualSource.PinName = KSNODETYPE_LEGACY_AUDIO_CONNECTOR;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &CreateVirtualSource, sizeof(CreateVirtualSource), pulVirtualSourceIndex, sizeof(*pulVirtualSourceIndex));

    if(SUCCEEDED(hr) && MAX_ULONG == *pulVirtualSourceIndex)
    {
        hr = DSERR_GENERIC;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsAttachVirtualSource
 *
 *  Description:
 *      Attachs a pin to a virtual source on SAD.
 *
 *  Arguments:
 *      HANDLE [in]: SAD device handle.
 *      ULONG [in]: virtual source index.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsAttachVirtualSource"

HRESULT
KsAttachVirtualSource
(
    HANDLE                          hDevice,
    ULONG                           ulVirtualSourceIndex
)
{
    SYSAUDIO_ATTACH_VIRTUAL_SOURCE  AttachVirtualSource;
    HRESULT                         hr;

    DPF_ENTER();

    AttachVirtualSource.Property.Set = KSPROPSETID_Sysaudio_Pin;
    AttachVirtualSource.Property.Id = KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE;
    AttachVirtualSource.Property.Flags = KSPROPERTY_TYPE_SET;

    AttachVirtualSource.MixerPinId = ulVirtualSourceIndex;
    AttachVirtualSource.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &AttachVirtualSource, sizeof(AttachVirtualSource));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsCreateSysAudioVirtualSource
 *
 *  Description:
 *      Create a virtual source on SAD.
 *
 *  Arguments:
 *      HANDLE [in]: SAD device handle.
 *      PULONG [out]: Virtual source index pointer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSysAudioSelectGraph"

HRESULT
KsSysAudioSelectGraph
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    ULONG                   ulNodeId
)
{
    SYSAUDIO_SELECT_GRAPH   SelectGraph;
    HRESULT                 hr;

    DPF_ENTER();

    SelectGraph.Property.Set = KSPROPSETID_Sysaudio;
    SelectGraph.Property.Id = KSPROPERTY_SYSAUDIO_SELECT_GRAPH;
    SelectGraph.Property.Flags = KSPROPERTY_TYPE_SET;

    SelectGraph.PinId = ulPinId;
    SelectGraph.NodeId = ulNodeId;
    SelectGraph.Flags = 0;
    SelectGraph.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &SelectGraph, sizeof(SelectGraph), NULL, 0);

    if(FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "KsSysAudioSelectGraph's IOCTL failed");
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsCancelPendingIrps
 *
 *  Description:
 *      Cancels any pending IRPs.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      PKSSTREAMIO [in/out]: stream IO data.
 *      BOOL [in]: TRUE to wait for all IRPs to complete.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsCancelPendingIrps"

HRESULT
KsCancelPendingIrps
(
    HANDLE                  hPin,
    PKSSTREAMIO             pKsStreamIo,
    BOOL                    fWait
)
{
    HRESULT                 hr      = DS_OK;
    DWORD                   dwWait;

    DPF_ENTER();

    // Don't bother actually doing anything if there's no pending IRP(s).
    // If no KSSTREAMIO was provided, we'll just reset the pin state
    // without updating any information.
    if(!pKsStreamIo || pKsStreamIo->fPendingIrp)
    {
        // Don't wait if there's no known pending IRP(s)
        if(!pKsStreamIo)
        {
            fWait = FALSE;
        }

        // Begin the reset of the pin state
        hr = KsResetState(hPin, KSRESET_BEGIN);

        // Wait for completion of the outstanding IRP(s)
        if(SUCCEEDED(hr) && fWait)
        {
            dwWait = WaitObject(INFINITE, pKsStreamIo->Overlapped.hEvent);
            ASSERT(WAIT_OBJECT_0 == dwWait);

            ResetEvent(pKsStreamIo->Overlapped.hEvent);
        }

        // There is no longer any pending IRP(s)
        if(SUCCEEDED(hr) && pKsStreamIo)
        {
            pKsStreamIo->fPendingIrp = FALSE;
        }

        // End the pin state reset
        if(SUCCEEDED(hr))
        {
            hr = KsResetState(hPin, KSRESET_END);
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsBuildAudioPinDescription
 *
 *  Description:
 *      Builds the description for a dsound pin.
 *
 *  Arguments:
 *      KSINTERFACE_STANDARD [in]: pin interface.
 *      ULONG [in]: pin instance id.
 *      LPWAVEFORMATEX [in]: pin format.
 *      PKSAUDIOPINDESC * [out]: receives pin description.  The caller is
 *                                  responsible for freeing this structure.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsBuildAudioPinDescription"

HRESULT
KsBuildAudioPinDescription
(
    KSINTERFACE_STANDARD    nInterface,
    ULONG                   ulPinId,
    LPCWAVEFORMATEX         pwfxFormat,
    PKSAUDIOPINDESC *       ppPinDesc
)
{
    PKSAUDIOPINDESC         pPinDesc;
    ULONG                   cbPinDesc;
    ULONG                   cbWfx = sizeof(WAVEFORMATEX);;
    HRESULT                 hr;

    DPF_ENTER();

    cbPinDesc = sizeof(*pPinDesc);

    if(pwfxFormat)
    {
        cbWfx = GetWfxSize(pwfxFormat, GENERIC_WRITE);

        if(cbWfx > sizeof(WAVEFORMATEX))
        {
            cbPinDesc += cbWfx - sizeof(WAVEFORMATEX);
        }
    }

    pPinDesc = (PKSAUDIOPINDESC)MEMALLOC_A(BYTE, cbPinDesc);
    hr = HRFROMP(pPinDesc);

    if(SUCCEEDED(hr))
    {
        pPinDesc->Connect.Interface.Set = KSINTERFACESETID_Standard;
        pPinDesc->Connect.Interface.Id = nInterface;

        pPinDesc->Connect.Medium.Set = KSMEDIUMSETID_Standard;
        pPinDesc->Connect.Medium.Id = KSMEDIUM_STANDARD_DEVIO;

        pPinDesc->Connect.PinId = ulPinId;

        pPinDesc->Connect.Priority.PriorityClass = KSPRIORITY_NORMAL;
        pPinDesc->Connect.Priority.PrioritySubClass = 1;

        pPinDesc->DataFormat.DataFormat.FormatSize = sizeof(pPinDesc->DataFormat) + cbWfx - sizeof(WAVEFORMATEX);

        pPinDesc->DataFormat.DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;

        // Compute KSDATAFORMAT.SubFormat from WAVEFORMATEX
        if (pwfxFormat)
        {
            if (pwfxFormat->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
            {
                PWAVEFORMATEXTENSIBLE pwfext = (PWAVEFORMATEXTENSIBLE)pwfxFormat;
                ASSERT(pwfxFormat->cbSize >= (sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)));
                pPinDesc->DataFormat.DataFormat.SubFormat = pwfext->SubFormat;
            }
            else
            {
                INIT_WAVEFORMATEX_GUID(&pPinDesc->DataFormat.DataFormat.SubFormat, pwfxFormat->wFormatTag);
            }

            // KS1 kmixer has a bug that prevents SubFormat=IEEE_FLOAT from working
            // FIXME: this workaround should be restricted to some subset of platforms
            if (pPinDesc->DataFormat.DataFormat.SubFormat == KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)
            {
                pPinDesc->DataFormat.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
            }
        }
        else
        {
            pPinDesc->DataFormat.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
        }

        pPinDesc->DataFormat.DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_WAVEFORMATEX;

        if(pwfxFormat)
        {
            pPinDesc->DataFormat.DataFormat.SampleSize = pwfxFormat->nBlockAlign;
            CopyWfx(pwfxFormat, &pPinDesc->DataFormat.WaveFormatEx);
        }

        *ppPinDesc = pPinDesc;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsBuildRenderPinDescription
 *
 *  Description:
 *      Builds the description for a dsound render pin.
 *
 *  Arguments:
 *      ULONG [in]: pin instance id.
 *      DWORD [in]: dsound buffer flags.
 *      LPWAVEFORMATEX [in]: pin format.
 *      PKSAUDIOPINDESC * [out]: receives pin description.  The caller is
 *                                responsible for freeing this structure.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsBuildRenderPinDescription"

#ifdef NO_DSOUND_FORMAT_SPECIFIER

HRESULT
KsBuildRenderPinDescription
(
    ULONG                   ulPinId,
    LPCWAVEFORMATEX         pwfxFormat,
    PKSAUDIOPINDESC *       ppPinDesc
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsBuildAudioPinDescription(KSINTERFACE_STANDARD_LOOPED_STREAMING, ulPinId, pwfxFormat, ppPinDesc);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

#else // NO_DSOUND_FORMAT_SPECIFIER

HRESULT
KsBuildRenderPinDescription
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    PKSDSRENDERPINDESC *    ppPinDesc
)
{
    PKSDSRENDERPINDESC      pPinDesc;
    ULONG                   cbPinDesc;
    ULONG                   cbWfx = sizeof(WAVEFORMATEX);

    HRESULT                 hr;

    DPF_ENTER();

    cbPinDesc = sizeof(*pPinDesc);

    if(pwfxFormat)
    {
        cbWfx = GetWfxSize(pwfxFormat, GENERIC_WRITE);

        if(cbWfx > sizeof(WAVEFORMATEX))
        {
            cbPinDesc += cbWfx - sizeof(WAVEFORMATEX);
        }
    }

    pPinDesc = (PKSDSRENDERPINDESC)MEMALLOC_A(BYTE, cbPinDesc);
    hr = HRFROMP(pPinDesc);

    if(SUCCEEDED(hr))
    {
        pPinDesc->Connect.Interface.Set = KSINTERFACESETID_Standard;
        pPinDesc->Connect.Interface.Id = KSINTERFACE_STANDARD_LOOPED_STREAMING;

        pPinDesc->Connect.Medium.Set = KSMEDIUMSETID_Standard;
        pPinDesc->Connect.Medium.Id = KSMEDIUM_STANDARD_DEVIO;

        pPinDesc->Connect.PinId = ulPinId;

        pPinDesc->Connect.Priority.PriorityClass = KSPRIORITY_NORMAL;
        pPinDesc->Connect.Priority.PrioritySubClass = 1;

        pPinDesc->DataFormat.DataFormat.FormatSize = sizeof(pPinDesc->DataFormat) + cbWfx - sizeof(WAVEFORMATEX);

        pPinDesc->DataFormat.DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;

        // Compute KSDATAFORMAT.SubFormat from WAVEFORMATEX
        if (pwfxFormat)
        {
            if (pwfxFormat->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
            {
                PWAVEFORMATEXTENSIBLE pwfext = (PWAVEFORMATEXTENSIBLE)pwfxFormat;
                ASSERT(pwfxFormat->cbSize >= (sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)));
                pPinDesc->DataFormat.DataFormat.SubFormat = pwfext->SubFormat;
            }
            else
            {
                INIT_WAVEFORMATEX_GUID(&pPinDesc->DataFormat.DataFormat.SubFormat, pwfxFormat->wFormatTag);
            }
            // KS1 kmixer has a bug that prevents SubFormat=IEEE_FLOAT from working
            // FIXME: this workaround should be restricted to some subset of platforms
            if (pPinDesc->DataFormat.DataFormat.SubFormat == KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)
            {
                pPinDesc->DataFormat.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
            }
        }
        else
        {
            pPinDesc->DataFormat.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
        }

        pPinDesc->DataFormat.DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_DSOUND;

        pPinDesc->DataFormat.BufferDesc.Flags = DsBufferFlagsToKsPinFlags(dwFlags);
        pPinDesc->DataFormat.BufferDesc.Control = DsBufferFlagsToKsControlFlags(dwFlags, guid3dAlgorithm);

        if(pwfxFormat)
        {
            pPinDesc->DataFormat.DataFormat.SampleSize = pwfxFormat->nBlockAlign;
            CopyWfx(pwfxFormat, &pPinDesc->DataFormat.BufferDesc.WaveFormatEx);
        }

        *ppPinDesc = pPinDesc;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}

HRESULT
KsBuildRenderPinDescription_10
(
    ULONG                   ulPinId,
    DWORD                   dwFlags,
    LPCWAVEFORMATEX         pwfxFormat,
    REFGUID                 guid3dAlgorithm,
    PKSDSRENDERPINDESC_10 * ppPinDesc
)
{
    PKSDSRENDERPINDESC_10   pPinDesc;
    ULONG                   cbPinDesc;
    ULONG                   cbWfx = sizeof(WAVEFORMATEX);

    HRESULT                 hr;

    DPF_ENTER();

    cbPinDesc = sizeof(*pPinDesc);

    if(pwfxFormat)
    {
        cbWfx = GetWfxSize(pwfxFormat, GENERIC_WRITE);

        if(cbWfx > sizeof(WAVEFORMATEX))
        {
            cbPinDesc += cbWfx - sizeof(WAVEFORMATEX);
        }
    }

    pPinDesc = (PKSDSRENDERPINDESC_10)MEMALLOC_A(BYTE, cbPinDesc);
    hr = HRFROMP(pPinDesc);

    if(SUCCEEDED(hr))
    {
        pPinDesc->Connect.Interface.Set = KSINTERFACESETID_Standard;
        pPinDesc->Connect.Interface.Id = KSINTERFACE_STANDARD_LOOPED_STREAMING;

        pPinDesc->Connect.Medium.Set = KSMEDIUMSETID_Standard;
        pPinDesc->Connect.Medium.Id = KSMEDIUM_STANDARD_DEVIO;

        pPinDesc->Connect.PinId = ulPinId;

        pPinDesc->Connect.Priority.PriorityClass = KSPRIORITY_NORMAL;
        pPinDesc->Connect.Priority.PrioritySubClass = 1;

        pPinDesc->DataFormat.DataFormat.FormatSize = sizeof(pPinDesc->DataFormat) + cbWfx - sizeof(WAVEFORMATEX);

        pPinDesc->DataFormat.DataFormat.MajorFormat = KSDATAFORMAT_TYPE_AUDIO;

        // Compute KSDATAFORMAT.SubFormat from WAVEFORMATEX
        if (pwfxFormat)
        {
            if (pwfxFormat->wFormatTag == WAVE_FORMAT_EXTENSIBLE)
            {
                PWAVEFORMATEXTENSIBLE pwfext = (PWAVEFORMATEXTENSIBLE)pwfxFormat;
                ASSERT(pwfxFormat->cbSize >= (sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX)));
                pPinDesc->DataFormat.DataFormat.SubFormat = pwfext->SubFormat;
            }
            else
            {
                INIT_WAVEFORMATEX_GUID(&pPinDesc->DataFormat.DataFormat.SubFormat, pwfxFormat->wFormatTag);
            }
            // KS1 kmixer has a bug that prevents SubFormat=IEEE_FLOAT from working
            // FIXME: this workaround should be restricted to some subset of platforms
            if (pPinDesc->DataFormat.DataFormat.SubFormat == KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)
            {
                pPinDesc->DataFormat.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
            }
        }
        else
        {
            pPinDesc->DataFormat.DataFormat.SubFormat = KSDATAFORMAT_SUBTYPE_PCM;
        }

        pPinDesc->DataFormat.DataFormat.Specifier = KSDATAFORMAT_SPECIFIER_DSOUND;

        pPinDesc->DataFormat.BufferDesc.Flags = DsBufferFlagsToKsPinFlags(dwFlags);
        pPinDesc->DataFormat.BufferDesc.Control = DsBufferFlagsToKsControlFlags(dwFlags, guid3dAlgorithm);
        pPinDesc->DataFormat.BufferDesc.BufferSize = 0; // Unused

        if(pwfxFormat)
        {
            pPinDesc->DataFormat.DataFormat.SampleSize = pwfxFormat->nBlockAlign;
            CopyWfx(pwfxFormat, &pPinDesc->DataFormat.BufferDesc.WaveFormatEx);
        }

        *ppPinDesc = pPinDesc;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
#endif // NO_DSOUND_FORMAT_SPECIFIER


/***************************************************************************
 *
 *  KsBuildCapturePinDescription
 *
 *  Description:
 *      Builds the description for a dsound capture pin.
 *
 *  Arguments:
 *      ULONG [in]: pin instance id.
 *      LPWAVEFORMATEX [in]: pin format.
 *      PPKSAUDIOPINDESC [out]: receives pin description.  The caller is
 *                                  responsible for freeing this structure.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsBuildCapturePinDescription"

HRESULT
KsBuildCapturePinDescription
(
    ULONG                   ulPinId,
    LPCWAVEFORMATEX         pwfxFormat,
    PKSAUDIOPINDESC *       ppPinDesc
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsBuildAudioPinDescription(KSINTERFACE_STANDARD_STREAMING, ulPinId, pwfxFormat, ppPinDesc);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsCreateAudioPin
 *
 *  Description:
 *      Creates a pin.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSPIN_CONNECT [in]: pin description.
 *      ACCESS_MASK [in]: desired access flags.
 *      KSSTATE [in]: desired pin state.
 *      LPHANDLE [out]: receives pin handle.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsCreateAudioPin"

HRESULT
KsCreateAudioPin
(
    HANDLE                  hDevice,
    PKSPIN_CONNECT          pConnect,
    ACCESS_MASK             dwDesiredAccess,
    KSSTATE                 nState,
    LPHANDLE                phPin
)
{
    HANDLE                  hPin        = NULL;
    DWORD                   dwError;
    HRESULT                 hr;

    DPF_ENTER();

    dwError = DsKsCreatePin(hDevice, pConnect, dwDesiredAccess, &hPin);
    hr = WIN32ERRORtoHRESULT(dwError);

    if(FAILED(hr))
    {
        DPF(DPFLVL_MOREINFO, "KsCreatePin(PinId=%d) failed with %s (%lu)", pConnect->PinId, HRESULTtoSTRING(hr), dwError);
    }
    else
    {
        hr = KsTransitionState(hPin, KSSTATE_STOP, nState);
    }

    if(SUCCEEDED(hr))
    {
        *phPin = hPin;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsEnableEvent
 *
 *  Description:
 *      Enables a KS event.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: Property set id.
 *      ULONG [in]: property id.
 *      PKSEVENTDATA [in]: event data.
 *      ULONG [in]: event data size.
 *
 *  Returns:
 *     HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsEnableEvent"

HRESULT
KsEnableEvent
(
    HANDLE                  hDevice,
    REFGUID                 guidPropertySet,
    ULONG                   ulProperty,
    PKSEVENTDATA            pEventData,
    ULONG                   cbEventData
)
{
    KSEVENT                 Event;
    HRESULT                 hr;

    DPF_ENTER();

    Event.Set = guidPropertySet;
    Event.Id = ulProperty;
    Event.Flags = KSEVENT_TYPE_ENABLE;

    hr = PostDevIoctl(hDevice, IOCTL_KS_ENABLE_EVENT, &Event, sizeof(Event), pEventData, cbEventData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsDisableEvent
 *
 *  Description:
 *      Disables a KS event.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSEVENTDATA [in]: event data.
 *      ULONG [in]: event data size.
 *
 *  Returns:
 *     HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsDisableEvent"

HRESULT
KsDisableEvent
(
    HANDLE                  hDevice,
    PKSEVENTDATA            pEventData,
    ULONG                   cbEventData
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = PostDevIoctl(hDevice, IOCTL_KS_DISABLE_EVENT, pEventData, cbEventData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsEnablePositionEvent
 *
 *  Description:
 *      Enables a KS LOOPED_STREAMING position event.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      QWORD [in]: position offset, in samples.
 *      HANDLE [in]: event handle.
 *      PLOOPEDSTREAMING_POSITION_EVENT_DATA [in/out]: receives event data.
 *
 *  Returns:
 *     HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsEnablePositionEvent"

HRESULT
KsEnablePositionEvent
(
    HANDLE                                  hDevice,
    QWORD                                   qwSample,
    HANDLE                                  hEvent,
    PLOOPEDSTREAMING_POSITION_EVENT_DATA    pNotify
)
{
    HRESULT                                 hr;

    DPF_ENTER();

    // KS requires that the event data sent to the event enable and disable
    // IOCTLs be at the same location in memory.
    pNotify->KsEventData.NotificationType = KSEVENTF_EVENT_HANDLE;
    pNotify->KsEventData.EventHandle.Event = hEvent;
    pNotify->KsEventData.EventHandle.Reserved[0] = 0;
    pNotify->KsEventData.EventHandle.Reserved[1] = 0;

    pNotify->Position = qwSample;

    hr = KsEnableEvent(hDevice, KSEVENTSETID_LoopedStreaming, KSEVENT_LOOPEDSTREAMING_POSITION, &pNotify->KsEventData, sizeof(*pNotify));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsDisablePositionEvent
 *
 *  Description:
 *      Disables a KS LOOPED_STREAMING position event.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PLOOPEDSTREAMING_POSITION_EVENT_DATA [in]: event data.
 *
 *  Returns:
 *     HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsDisablePositionEvent"

HRESULT
KsDisablePositionEvent
(
    HANDLE                                  hDevice,
    PLOOPEDSTREAMING_POSITION_EVENT_DATA    pNotify
)
{
    HRESULT                                 hr;

    DPF_ENTER();

    // KS requires that the event data sent to the event enable and disable
    // IOCTLs be at the same location in memory.
    hr = KsDisableEvent(hDevice, &pNotify->KsEventData, sizeof(*pNotify));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetCpuResources
 *
 *  Description:
 *      Determines whether or not the node uses the host CPU resources.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: node id.
 *      PULONG [out]: receives the CPU resources value.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetCpuResources"

HRESULT
KsGetCpuResources
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    PULONG                  pulCpuResources
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetNodeProperty(hDevice, KSPROPSETID_Audio, KSPROPERTY_AUDIO_CPU_RESOURCES, ulNodeId, pulCpuResources, sizeof(*pulCpuResources));

    if(FAILED(hr))
    {
        // Changed this to a warning because it's very frequent and non-critical
        DPF(DPFLVL_WARNING, "Unable to get CPU resources for node %lu", ulNodeId);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetSupportedFormats
 *
 *  Description:
 *      Converts a KSDATARANGE_AUDIO structure into a DWORD compatible with
 *      waveInGetDevCaps
 *
 *  Arguments:
 *      PKSDATARANGE_AUDIO [in]: data range audio struct describing
 *                               capapabilities of audio pin
 *
 *  Returns:
 *      DWORD: describes caps of audio pin
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetSupportedFormats"

DWORD KsGetSupportedFormats
(
    PKSDATARANGE_AUDIO      pDataRange
)
{
    DWORD                   dwSamples   = 0;
    DWORD                   dwChannels  = 0;
    DWORD                   dwBits      = 0;

    DPF_ENTER();

    // The WAVE_FORMAT_XXXX flags are bit flags
    //
    // So we take advantage of that by determining three
    // sets of information:
    // - frequencies that are in the valid range
    // - valid bits per sample
    // - number of channels
    //
    // We than bitwise-AND the three values to get
    // the intersection of valid formats
    //

    // Is 11.025 KHz valid?
    if(pDataRange->MinimumSampleFrequency <= 11025 && pDataRange->MaximumSampleFrequency >= 11025)
    {
        dwSamples |= WAVE_FORMAT_1M08 | WAVE_FORMAT_1S08 | WAVE_FORMAT_1M16 | WAVE_FORMAT_1S16;
    }

    // Is 22.05 KHz valid?
    if(pDataRange->MinimumSampleFrequency <= 22050 && pDataRange->MaximumSampleFrequency >= 22050)
    {
        dwSamples |= WAVE_FORMAT_2M08 | WAVE_FORMAT_2S08 | WAVE_FORMAT_2M16 | WAVE_FORMAT_2S16;
    }

    // Is 44.1KHz valid?
    if(pDataRange->MinimumSampleFrequency <= 44100 && pDataRange->MaximumSampleFrequency >= 44100)
    {
        dwSamples |= WAVE_FORMAT_4M08 | WAVE_FORMAT_4S08 | WAVE_FORMAT_4M16 | WAVE_FORMAT_4S16;
    }

    // Is 8 bit per sample valid?
    if(pDataRange->MinimumBitsPerSample <= 8 && pDataRange->MaximumBitsPerSample >= 8)
    {
        dwBits |= WAVE_FORMAT_1M08 | WAVE_FORMAT_1S08 | WAVE_FORMAT_2M08 | WAVE_FORMAT_2S08 | WAVE_FORMAT_4M08 | WAVE_FORMAT_4S08;
    }

    // Is 16 bits per sample valid?
    if(pDataRange->MinimumBitsPerSample <= 16 && pDataRange->MaximumBitsPerSample >= 16)
    {
        dwBits |= WAVE_FORMAT_1M16 | WAVE_FORMAT_1S16 | WAVE_FORMAT_2M16 | WAVE_FORMAT_2S16 | WAVE_FORMAT_4M16 | WAVE_FORMAT_4S16;
    }

    // Is one channel (aka mono sound) valid?
    if(pDataRange->MaximumChannels >= 1)
    {
        dwChannels |= WAVE_FORMAT_1M08 | WAVE_FORMAT_1M16 | WAVE_FORMAT_2M08 | WAVE_FORMAT_2M16 | WAVE_FORMAT_4M08 | WAVE_FORMAT_4M16;
    }

    // Are two channels (aka stereo sound) valid?
    if(pDataRange->MaximumChannels >= 2)
    {
        dwChannels |= WAVE_FORMAT_1S08 | WAVE_FORMAT_1S16 | WAVE_FORMAT_2S08 | WAVE_FORMAT_2S16 | WAVE_FORMAT_4S08 | WAVE_FORMAT_4S16;
    }

    dwSamples = dwSamples & dwBits & dwChannels;

#ifdef DEBUG

    // Let's double check our result using a simpler method
    DWORD dwFormats = 0;

    if(pDataRange->MinimumSampleFrequency <= 11025 && pDataRange->MaximumSampleFrequency >= 11025)
    {
        if(pDataRange->MinimumBitsPerSample <= 8 && pDataRange->MaximumBitsPerSample >= 8)
        {
            if(pDataRange->MaximumChannels >= 1)
            {
                dwFormats |= WAVE_FORMAT_1M08;
            }

            if(pDataRange->MaximumChannels >= 2)
            {
                dwFormats |= WAVE_FORMAT_1S08;
            }
        }

        if(pDataRange->MinimumBitsPerSample <= 16 && pDataRange->MaximumBitsPerSample >= 16)
        {
            if(pDataRange->MaximumChannels >= 1)
            {
                dwFormats |= WAVE_FORMAT_1M16;
            }

            if(pDataRange->MaximumChannels >= 2)
            {
                dwFormats |= WAVE_FORMAT_1S16;
            }
        }
    }

    if(pDataRange->MinimumSampleFrequency <= 22050 && pDataRange->MaximumSampleFrequency >= 22050)
    {
        if(pDataRange->MinimumBitsPerSample <= 8 && pDataRange->MaximumBitsPerSample >= 8)
        {
            if(pDataRange->MaximumChannels >= 1)
            {
                dwFormats |= WAVE_FORMAT_2M08;
            }

            if(pDataRange->MaximumChannels >= 2)
            {
                dwFormats |= WAVE_FORMAT_2S08;
            }
        }

        if(pDataRange->MinimumBitsPerSample <= 16 && pDataRange->MaximumBitsPerSample >= 16)
        {
            if(pDataRange->MaximumChannels >= 1)
            {
                dwFormats |= WAVE_FORMAT_2M16;
            }

            if(pDataRange->MaximumChannels >= 2)
            {
                dwFormats |= WAVE_FORMAT_2S16;
            }
        }
    }

    if(pDataRange->MinimumSampleFrequency <= 44100 && pDataRange->MaximumSampleFrequency >= 44100)
    {
        if(pDataRange->MinimumBitsPerSample <= 8 && pDataRange->MaximumBitsPerSample >= 8)
        {
            if(pDataRange->MaximumChannels >= 1)
            {
                dwFormats |= WAVE_FORMAT_4M08;
            }

            if(pDataRange->MaximumChannels >= 2)
            {
                dwFormats |= WAVE_FORMAT_4S08;
            }
        }

        if(pDataRange->MinimumBitsPerSample <= 16 && pDataRange->MaximumBitsPerSample >= 16)
        {
            if(pDataRange->MaximumChannels >= 1)
            {
                dwFormats |= WAVE_FORMAT_4M16;
            }

            if(pDataRange->MaximumChannels >= 2)
            {
                dwFormats |= WAVE_FORMAT_4S16;
            }
        }
    }

    ASSERT(dwFormats == dwSamples);

#endif

    DPF_LEAVE(dwSamples);
    return dwSamples;
}


/***************************************************************************
 *
 *  KsGetDeviceInterfaceName
 *
 *  Description:
 *      Gets the device interface name.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: device id.
 *      LPTSTR * [out]: receives pointer to interface name.  This pointer
 *                      must be freed by the caller.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetDeviceInterfaceName"

HRESULT
KsGetDeviceInterfaceName
(
    HANDLE                  hDevice,
    ULONG                   ulDeviceId,
    LPTSTR *                ppszInterfaceName
)
{

#ifdef WINNT

    const LPCTSTR           pszMask0        = TEXT("\\??");
    const LPCTSTR           pszMask3        = TEXT("\\\\?");

#else // WINNT

    const LPCTSTR           pszMask0        = TEXT("\\DosDevices");
    const LPCTSTR           pszMask3        = TEXT("\\\\.");

#endif // WINNT

    const ULONG             ccMask0         = lstrlen(pszMask0);
    const ULONG             ccMask3         = lstrlen(pszMask3);
    LPWSTR                  pszInterfaceW   = NULL;
    LPTSTR                  pszInterface0   = NULL;
    LPTSTR                  pszInterface3   = NULL;
    HANDLE                  hInterface      = NULL;
    ULONG                   cbInterfaceW;
    ULONG                   ccInterface0;
    ULONG                   ccInterface3;
    HRESULT                 hr;

    DPF_ENTER();

    // Get the device interface name
    hr = KsGetSysAudioProperty(hDevice, KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME, ulDeviceId, NULL, 0, &cbInterfaceW);

    if(SUCCEEDED(hr) && !cbInterfaceW)
    {
        DPF(DPFLVL_ERROR, "Interface size is 0");
        hr = DSERR_GENERIC;
    }

    if(FAILED(hr))
    {
        DPF(DPFLVL_ERROR, "Unable to get device interface name size");
    }

    if(SUCCEEDED(hr))
    {
        pszInterfaceW = (LPWSTR)MEMALLOC_A(BYTE, cbInterfaceW);
        hr = HRFROMP(pszInterfaceW);
    }

    if(SUCCEEDED(hr))
    {
        hr = KsGetSysAudioProperty(hDevice, KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME, ulDeviceId, pszInterfaceW, cbInterfaceW);

        if(FAILED(hr))
        {
            DPF(DPFLVL_ERROR, "Unable to get device interface name");
        }
    }

    if(SUCCEEDED(hr))
    {
        pszInterface0 = UnicodeToTcharAlloc(pszInterfaceW);
        hr = HRFROMP(pszInterface0);
    }

    // Convert the device name to its ring-3 equivalent
    if(SUCCEEDED(hr))
    {
        ccInterface0 = lstrlen(pszInterface0) + 1;
        ccInterface3 = ccInterface0 - ccMask0 + ccMask3;

        pszInterface3 = MEMALLOC_A(TCHAR, ccInterface3);
        hr = HRFROMP(pszInterface3);
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(ccInterface0 > ccMask0);
        ASSERT(CompareMemory(pszInterface0, pszMask0, ccMask0 * sizeof(TCHAR)));

        lstrcpy(pszInterface3, pszMask3);
        lstrcat(pszInterface3, pszInterface0 + ccMask0);
    }

    if(SUCCEEDED(hr))
    {
        *ppszInterfaceName = pszInterface3;
    }
    else
    {
        MEMFREE(pszInterface3);
    }

    MEMFREE(pszInterface0);
    MEMFREE(pszInterfaceW);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetDeviceFriendlyName
 *
 *  Description:
 *      Gets a KS device's friendly name.
 *
 *  Arguments:
 *      HANDLE [in]: sysaudio device handle.
 *      ULONG [in]: device id.
 *      LPTSTR * [out]: receives friendly name.  The caller is responsible
 *                      for freeing this buffer.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetDeviceFriendlyName"

HRESULT
KsGetDeviceFriendlyName
(
    HANDLE                  hDevice,
    ULONG                   ulDeviceId,
    LPTSTR *                ppszName
)
{
    KSCOMPONENTID           ComponentId;
    LPTSTR                  pszName     = NULL;
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetSysAudioProperty(hDevice, KSPROPERTY_SYSAUDIO_COMPONENT_ID, ulDeviceId, &ComponentId, sizeof(ComponentId));

    if(SUCCEEDED(hr))
    {
        HKEY hkeyName;
        TCHAR NameGuidString[80];

        wsprintf(NameGuidString, TEXT(DPF_GUID_STRING), DPF_GUID_VAL(ComponentId.Name));

        hr = RhRegOpenPath(HKEY_LOCAL_MACHINE, &hkeyName, 0, 2, REGSTR_MEDIACATEGORIES, NameGuidString);

        if(SUCCEEDED(hr))
        {
            pszName = (LPTSTR)MEMALLOC_A(TCHAR, MAXNAME);
            hr = HRFROMP(pszName);

            if(SUCCEEDED(hr))
            {
                hr = RhRegGetStringValue(hkeyName, REGSTR_NAME, pszName, MAXNAME);
            }

            if(FAILED(hr))
            {
                DPF(DPFLVL_MOREINFO, "Failed to find Name GUID in registry for this Component ID");
                MEMFREE(pszName);
            }

            // Clean up
            RhRegCloseKey(&hkeyName);
        }
    }

    //  If the Component ID method failed, fall back on the friendly name method
    if(FAILED(hr))
    {
        LPWSTR pszNameW = NULL;
        ULONG cbName;

        hr = KsGetSysAudioProperty(hDevice, KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME, ulDeviceId, NULL, 0, &cbName);

        if(SUCCEEDED(hr))
        {
            pszNameW = (LPWSTR)MEMALLOC_A(BYTE, cbName);
            hr = HRFROMP(pszNameW);
        }

        if(SUCCEEDED(hr))
        {
            hr = KsGetSysAudioProperty(hDevice, KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME, ulDeviceId, pszNameW, cbName);
        }

        if(SUCCEEDED(hr))
        {
            pszName = UnicodeToTcharAlloc(pszNameW);
            hr = HRFROMP(pszName);
        }

        MEMFREE(pszNameW);
    }

    if(SUCCEEDED(hr))
    {
        *ppszName = pszName;
    }
    else
    {
        MEMFREE(pszName);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetDeviceDriverPathAndDevnode
 *
 *  Description:
 *      Gets the fully qualified path for a KS device driver.
 *
 *  Arguments:
 *      LPTSTR [in]: interface path.
 *      LPTSTR * [out]: receives driver path.  The caller is responsible
 *                      for freeing this buffer.
 *      LPDWORD [out]: receives devnode.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetDeviceDriverPathAndDevnode"

HRESULT
KsGetDeviceDriverPathAndDevnode
(
    LPCTSTR                     pszInterface,
    LPTSTR *                    ppszPath,
    LPDWORD                     pdwDevnode
)
{

#ifdef WINNT

    const LPCTSTR               pszDotSys           = TEXT(".sys");
    LPTSTR                      pszService          = NULL;
    SC_HANDLE                   hscManager          = NULL;
    SC_HANDLE                   hscService          = NULL;
    LPQUERY_SERVICE_CONFIG      pqsc                = NULL;
    DWORD                       cbRequired;
    BOOL                        f;

#else // WINNT

    HKEY                        hkey                = NULL;
    SP_DEVINFO_DATA             DeviceInfoData;

#endif // WINNT

    CPnpHelper *                pPnp                = NULL;
    LPTSTR                      pszPath             = NULL;
    DWORD                       dwDevnode           = 0;
    LPTSTR                      pszName             = NULL;
    HRESULT                     hr;

    DPF_ENTER();

    // Create the PnP helper object
    pPnp = NEW(CPnpHelper);
    hr = HRFROMP(pPnp);

    if(SUCCEEDED(hr))
    {
        hr = pPnp->Initialize(KSCATEGORY_AUDIO, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
    }

#ifdef WINNT

    // Get the device's service name
    if(SUCCEEDED(hr))
    {
        hr = pPnp->GetDeviceInterfaceRegistryProperty(pszInterface, KSCATEGORY_AUDIO, SPDRP_SERVICE, NULL, NULL, 0, &cbRequired);
    }

    if(SUCCEEDED(hr))
    {
        pszService = (LPTSTR)MEMALLOC_A(BYTE, cbRequired);
        hr = HRFROMP(pszService);
    }

    if(SUCCEEDED(hr))
    {
        hr = pPnp->GetDeviceInterfaceRegistryProperty(pszInterface, KSCATEGORY_AUDIO, SPDRP_SERVICE, NULL, pszService, cbRequired, &cbRequired);
    }

    if(SUCCEEDED(hr))
    {
        // Open default database on local machine
        hscManager = OpenSCManager(NULL, NULL, GENERIC_READ);

        if(!hscManager)
        {
            DPF(DPFLVL_ERROR, "Unable to open SC manager");
            hr = DSERR_GENERIC;
        }

        // Open the specific service
        if(SUCCEEDED(hr))
        {
            hscService = OpenService(hscManager, pszService, GENERIC_READ);

            if(!hscService)
            {
                DPF(DPFLVL_ERROR, "Unable to open service \"%s\"", pszService);
                hr = DSERR_GENERIC;
            }
        }

        // Try to get the binary path name
        if(SUCCEEDED(hr))
        {
            f = QueryServiceConfig(hscService, NULL, 0, &cbRequired);

            if(f || ERROR_INSUFFICIENT_BUFFER != GetLastError())
            {
                DPF(DPFLVL_ERROR, "Error %lu ocurred trying to get service config size", GetLastError());
                hr = DSERR_GENERIC;
            }
        }

        if(SUCCEEDED(hr))
        {
            pqsc = (LPQUERY_SERVICE_CONFIG)MEMALLOC_A(BYTE, cbRequired);
            hr = HRFROMP(pqsc);
        }

        if(SUCCEEDED(hr))
        {
            f = QueryServiceConfig(hscService, pqsc, cbRequired, &cbRequired);

            if(!f)
            {
                DPF(DPFLVL_ERROR, "Error %lu ocurred trying to get service config", GetLastError());
                hr = DSERR_GENERIC;
            }
        }

        // Create the full path
        //
        if(SUCCEEDED(hr))
        {
            // We only want the base part of the path
            //
            pszName = _tcsrchr(pqsc->lpBinaryPathName, TCHAR('\\'));
            if (pszName == NULL)
            {
                pszName = pqsc->lpBinaryPathName;
            }
            else
            {
                pszName++;
            }
            pszPath = TcharToTcharAlloc(pszName);
            hr = HRFROMP(pszPath);
        }
        else
        {
            pszPath = MEMALLOC_A(TCHAR, lstrlen(pszService) + lstrlen(pszDotSys) + 1);
            hr = HRFROMP(pszPath);

            if(SUCCEEDED(hr))
            {
                lstrcat(pszPath, pszService);
                lstrcat(pszPath, pszDotSys);
            }
        }
    }

    // Clean up
    MEMFREE(pqsc);
    MEMFREE(pszService);

    if(hscService)
    {
        CloseServiceHandle(hscService);
    }

    if(hscManager)
    {
        CloseServiceHandle(hscManager);
    }

#else // WINNT

    // Allocate memory
    if(SUCCEEDED(hr))
    {
        pszPath = MEMALLOC_A(TCHAR, MAX_PATH);
        hr = HRFROMP(pszPath);
    }

    // Get the interface's device info data
    if(SUCCEEDED(hr))
    {
        hr = pPnp->GetDeviceInterfaceDeviceInfo(pszInterface, KSCATEGORY_AUDIO, &DeviceInfoData);
    }

    // Save the devnode
    if(SUCCEEDED(hr))
    {
        dwDevnode = DeviceInfoData.DevInst;
    }

    // Open the device registry key
    if(SUCCEEDED(hr))
    {
        hr = pPnp->OpenDeviceRegistryKey(&DeviceInfoData, DIREG_DRV, FALSE, &hkey);
    }

    // Get the driver filename
    if(SUCCEEDED(hr))
    {
        hr = RhRegGetStringValue(hkey, TEXT("Driver"), pszPath, MAX_PATH * sizeof(TCHAR));
    }

    // Clean up
    RhRegCloseKey(&hkey);

#endif // WINNT

    RELEASE(pPnp);

    // Success
    if(SUCCEEDED(hr))
    {
        *ppszPath = pszPath;
        *pdwDevnode = dwDevnode;
    }
    else
    {
        MEMFREE(pszPath);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsIsUsablePin
 *
 *  Description:
 *      Determines if a pin is usable by DirectSound.
 *
 *  Arguments:
 *      HANDLE [in]: system audio device handle.
 *      ULONG [in]: pin id.  It's assumed that the proper device is already
 *                  set up as the default.
 *      KSPIN_DATAFLOW [in]: pin data flow.
 *      KSPIN_COMMUNICATION [in]: pin communication.
 *      PKSAUDIOPINDESC [in]: pin description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.  Returns DS_OK if the device
 *               is usable, S_FALSE if it is not.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsIsUsablePin"

HRESULT
KsIsUsablePin
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    KSPIN_DATAFLOW          PinDataFlow,
    KSPIN_COMMUNICATION     PinCommunication,
    PKSAUDIOPINDESC         pPinDesc
)
{
    PKSMULTIPLE_ITEM        pMultiItem      = NULL;
    PKSPIN_INTERFACE        pInterface;
    PKSPIN_MEDIUM           pMedium;
    PKSDATARANGE            pDataRange;
    KSPIN_DATAFLOW          DataFlow;
    KSPIN_COMMUNICATION     Communication;
    HRESULT                 hr;

    DPF_ENTER();

#ifdef DEBUG
    static const TCHAR* pszDataFlows[] = {TEXT("Invalid"), TEXT("In"), TEXT("Out")};
    static const TCHAR* pszCommunications[] = {TEXT("None"), TEXT("Sink"), TEXT("Source"), TEXT("Both"), TEXT("Bridge")};
#endif

    // Check data flow
    hr = KsGetPinProperty(hDevice, KSPROPERTY_PIN_DATAFLOW, ulPinId, &DataFlow, sizeof(DataFlow));

    if(SUCCEEDED(hr))
    {
        if(DataFlow != PinDataFlow)
        {
            DPF(DPFLVL_MOREINFO, "Pin %lu does not support dataflow (%s; wanted %s)", ulPinId, pszDataFlows[DataFlow], pszDataFlows[PinDataFlow]);
            hr = S_FALSE;
        }
    }
    else
    {
        DPF(DPFLVL_ERROR, "Can't get pin dataflow");
    }

    // Check communication type
    if(DS_OK == hr)
    {
        hr = KsGetPinProperty(hDevice, KSPROPERTY_PIN_COMMUNICATION, ulPinId, &Communication, sizeof(Communication));

        if(SUCCEEDED(hr))
        {
            if(Communication != PinCommunication)
            {
                DPF(DPFLVL_MOREINFO, "Pin %lu does not support communication (%s; wanted %s)", ulPinId, pszCommunications[Communication], pszCommunications[PinCommunication]);
                hr = S_FALSE;
            }
        }
        else
        {
            DPF(DPFLVL_ERROR, "Can't get pin communication");
        }
    }

    // Check interfaces
    if(DS_OK == hr)
    {
        hr = KsGetMultiplePinProperties(hDevice, KSPROPERTY_PIN_INTERFACES, ulPinId, &pMultiItem);

        if(SUCCEEDED(hr))
        {
            for(pInterface = (PKSPIN_INTERFACE)(pMultiItem + 1), hr = S_FALSE; pMultiItem->Count; pInterface++, pMultiItem->Count--)
            {
                if(pInterface->Set == pPinDesc->Connect.Interface.Set && pInterface->Id == pPinDesc->Connect.Interface.Id)
                {
                    hr = DS_OK;
                    break;
                }
            }

            if(S_FALSE == hr)
            {
                DPF(DPFLVL_MOREINFO, "Pin %lu does not support interface", ulPinId);
            }
        }
        else
        {
            DPF(DPFLVL_ERROR, "Can't get pin interfaces");
        }

        MEMFREE(pMultiItem);
    }

    // Check mediums
    if(DS_OK == hr)
    {
        hr = KsGetMultiplePinProperties(hDevice, KSPROPERTY_PIN_MEDIUMS, ulPinId, &pMultiItem);

        if(SUCCEEDED(hr))
        {
            for(pMedium = (PKSPIN_MEDIUM)(pMultiItem + 1), hr = S_FALSE; pMultiItem->Count; pMedium++, pMultiItem->Count--)
            {
                if(pMedium->Set == pPinDesc->Connect.Medium.Set && pMedium->Id == pPinDesc->Connect.Medium.Id)
                {
                    hr = DS_OK;
                    break;
                }
            }

            if(S_FALSE == hr)
            {
                DPF(DPFLVL_MOREINFO, "Pin %lu does not support medium", ulPinId);
            }
        }
        else
        {
            DPF(DPFLVL_ERROR, "Can't get pin mediums");
        }

        MEMFREE(pMultiItem);
    }

    // Check dataranges
    if(DS_OK == hr)
    {
        hr = KsGetMultiplePinProperties(hDevice, KSPROPERTY_PIN_DATARANGES, ulPinId, &pMultiItem);

        if(SUCCEEDED(hr))
        {
            for(pDataRange = (PKSDATARANGE)(pMultiItem + 1), hr = S_FALSE; pMultiItem->Count; pDataRange = (PKSDATARANGE)((LPBYTE)pDataRange + pDataRange->FormatSize), pMultiItem->Count--)
            {
                if(pDataRange->MajorFormat == pPinDesc->DataFormat.DataFormat.MajorFormat && pDataRange->Specifier == pPinDesc->DataFormat.DataFormat.Specifier)
                {
                    hr = DS_OK;
                    break;
                }
            }

            if(S_FALSE == hr)
            {
                DPF(DPFLVL_MOREINFO, "Pin %lu does not support data range", ulPinId);
            }
        }
        else
        {
            DPF(DPFLVL_ERROR, "Can't get pin dataranges");
        }

        MEMFREE(pMultiItem);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsEnumDevicePins
 *
 *  Description:
 *      Builds a list of available audio pins on the current device.
 *
 *  Arguments:
 *      HANDLE [in]: system audio device handle.
 *      BOOL [in]: TRUE if capture.
 *      ULONG ** [out]: receives array of valid pins.
 *      ULONG [in]: count of pins on the device.
 *      PULONG [out]: receives count of valid pins.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsEnumDevicePins"

HRESULT
KsEnumDevicePins
(
    HANDLE                      hDevice,
    BOOL                        fCapture,
    ULONG **                    ppulValidPinIds,
    ULONG                       ulPinCount,
    PULONG                      pulValidPinCount
)
{
    const KSPIN_DATAFLOW        nDataFlow       = fCapture ? KSPIN_DATAFLOW_CAPTURE : KSPIN_DATAFLOW_RENDER;
    const KSPIN_COMMUNICATION   nCommunication  = KSPIN_COMMUNICATION_SINK;
    PKSAUDIOPINDESC             pPinDesc        = NULL;
    ULONG *                     pulPinIds       = NULL;
    HRESULT                     hr              = DS_OK;

    DPF_ENTER();
    ASSERT(pulValidPinCount);

    *pulValidPinCount = 0;

    if(ppulValidPinIds)
    {
        pulPinIds = MEMALLOC_A(ULONG, ulPinCount);
        hr = HRFROMP(pulPinIds);
    }

    if (SUCCEEDED(hr))
    {
        // Build the pin description
        if(fCapture)
        {
            hr = KsBuildCapturePinDescription(-1, NULL, &pPinDesc);
        }
        else
        {

#ifdef NO_DSOUND_FORMAT_SPECIFIER
            hr = KsBuildRenderPinDescription(-1, NULL, &pPinDesc);
#else // NO_DSOUND_FORMAT_SPECIFIER
            if (g_ulWdmVersion == WDM_1_0)
            {
                hr = KsBuildRenderPinDescription_10(-1, 0, NULL, GUID_NULL, (PKSDSRENDERPINDESC_10 *)&pPinDesc);
            }
            else
            {
                hr = KsBuildRenderPinDescription(-1, 0, NULL, GUID_NULL, (PKSDSRENDERPINDESC *)&pPinDesc);
            }
#endif // NO_DSOUND_FORMAT_SPECIFIER

        }

        // Examine each pin to determine if it suits our needs
        for(ULONG ulPinId = 0; SUCCEEDED(hr) && ulPinId < ulPinCount; ulPinId++)
        {
            hr = KsIsUsablePin(hDevice, ulPinId, nDataFlow, nCommunication, pPinDesc);
            if(hr == DS_OK)
            {
                if(pulPinIds)
                {
                    pulPinIds[*pulValidPinCount] = ulPinId;
                }
                ++*pulValidPinCount;
            }
        }

        if(SUCCEEDED(hr) && ppulValidPinIds)
        {
            *ppulValidPinIds = MEMALLOC_A(ULONG, *pulValidPinCount);
            hr = HRFROMP(*ppulValidPinIds);

            if(SUCCEEDED(hr))
            {
                CopyMemory(*ppulValidPinIds, pulPinIds, *pulValidPinCount * sizeof(ULONG));
            }
        }

        // Clean up
        MEMFREE(pPinDesc);
        MEMFREE(pulPinIds);

        // Useful logging info
        #ifdef DEBUG
        if (ppulValidPinIds)
        {
            const int nMaxPins = 100;   // Limitation OK - only affects internal builds
            const int nPinStrLen = 3;   // Space for 1 space character and 2 digits
            TCHAR szValidPins[nPinStrLen * nMaxPins];
            for (ULONG i=0; i < MIN(nMaxPins, *pulValidPinCount); ++i)
                wsprintf(szValidPins + i*nPinStrLen, TEXT(" %2d"), (*ppulValidPinIds)[i]);
            DPF(DPFLVL_INFO, "Found %d valid %s pins:%s", *pulValidPinCount, fCapture ? TEXT("capture") : TEXT("render"), szValidPins);
        }
        else
        {
            DPF(DPFLVL_INFO, "Found %d valid %s pins", *pulValidPinCount, fCapture ? TEXT("capture") : TEXT("render"));
        }
        #endif // DEBUG

        // Let's not propagate a success code other than DS_OK
        if(SUCCEEDED(hr))
        {
            hr = DS_OK;
        }
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetChannelProperty
 *
 *  Description:
 *      Gets a property for a particular channel on a pin.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      ULONG [in]: volume node id.
 *      ULONG [in]: channel index or -1 for master.
 *      LPVOID [out]: receives data.
 *      ULONG [in]: data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetChannelProperty"

HRESULT
KsGetChannelProperty
(
    HANDLE                          hPin,
    GUID                            guidPropertySet,
    ULONG                           ulPropertyId,
    ULONG                           ulNodeId,
    ULONG                           ulChannelId,
    LPVOID                          pvData,
    ULONG                           cbData,
    PULONG                          pcbDataReturned
)
{
    KSNODEPROPERTY_AUDIO_CHANNEL    Channel;
    HRESULT                         hr;

    DPF_ENTER();

    Channel.NodeProperty.Property.Set = guidPropertySet;
    Channel.NodeProperty.Property.Id = ulPropertyId;
    Channel.NodeProperty.Property.Flags = KSPROPERTY_TYPE_GET | KSPROPERTY_TYPE_TOPOLOGY;

    Channel.NodeProperty.NodeId = ulNodeId;
    Channel.NodeProperty.Reserved = 0;

    Channel.Channel = ulChannelId;
    Channel.Reserved = 0;

    hr = PostDevIoctl(hPin, IOCTL_KS_PROPERTY, &Channel, sizeof(Channel), pvData, cbData, pcbDataReturned);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetChannelProperty
 *
 *  Description:
 *      Sets a property for a particular channel on a pin.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      ULONG [in]: volume node id.
 *      ULONG [in]: channel index or -1 for master.
 *      LPVOID [in]: data.
 *      ULONG [in]: data size.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetChannelProperty"

HRESULT
KsSetChannelProperty
(
    HANDLE                          hPin,
    GUID                            guidPropertySet,
    ULONG                           ulPropertyId,
    ULONG                           ulNodeId,
    ULONG                           ulChannelId,
    LPVOID                          pvData,
    ULONG                           cbData
)
{
    KSNODEPROPERTY_AUDIO_CHANNEL    Channel;
    HRESULT                         hr;

    DPF_ENTER();

    Channel.NodeProperty.Property.Set = guidPropertySet;
    Channel.NodeProperty.Property.Id = ulPropertyId;
    Channel.NodeProperty.Property.Flags = KSPROPERTY_TYPE_SET | KSPROPERTY_TYPE_TOPOLOGY;

    Channel.NodeProperty.NodeId = ulNodeId;
    Channel.NodeProperty.Reserved = 0;

    Channel.Channel = ulChannelId;
    Channel.Reserved = 0;

    hr = PostDevIoctl(hPin, IOCTL_KS_PROPERTY, &Channel, sizeof(Channel), pvData, cbData);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetPinMute
 *
 *  Description:
 *      Gets the mute state for a pin.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      ULONG [in]: volume node id.
 *      LPBOOL [out]: receives mute state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetPinMute"

HRESULT
KsGetPinMute
(
    HANDLE                  hPin,
    ULONG                   ulNodeId,
    LPBOOL                  pfMute
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetChannelProperty(hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_MUTE, ulNodeId, -1, pfMute, sizeof(*pfMute));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetPinMute
 *
 *  Description:
 *      Sets the mute state for a pin.
 *
 *  Arguments:
 *      HANDLE [in]: pin handle.
 *      ULONG [in]: volume node id.
 *      BOOL [in]: mute state.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetPinMute"

HRESULT
KsSetPinMute
(
    HANDLE                  hPin,
    ULONG                   ulNodeId,
    BOOL                    fMute
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsSetChannelProperty(hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_MUTE, ulNodeId, -1, &fMute, sizeof(fMute));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetBasicSupport
 *
 *  Description:
 *      Gets a range for a given KS property.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      REFGUID [in]: property set id.
 *      ULONG [in]: property id.
 *      ULONG [in]: pin id.
 *      PKSPROPERTY_DESCRIPTION * [out]: receives property description.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetBasicSupport"

HRESULT
KsGetBasicSupport
(
    HANDLE                      hDevice,
    REFGUID                     guidPropertySet,
    ULONG                       ulPropertyId,
    ULONG                       ulNodeId,
    PKSPROPERTY_DESCRIPTION *   ppPropDesc
)
{
    PKSPROPERTY_DESCRIPTION     pPropDesc       = NULL;
    KSNODEPROPERTY              NodeProperty;
    KSPROPERTY_DESCRIPTION      Description;
    HRESULT                     hr;

    DPF_ENTER();

    NodeProperty.Property.Set = guidPropertySet;
    NodeProperty.Property.Id = ulPropertyId;
    NodeProperty.Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT | KSPROPERTY_TYPE_TOPOLOGY;

    NodeProperty.NodeId = ulNodeId;
    NodeProperty.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &NodeProperty, sizeof(NodeProperty), &Description, sizeof(Description));

    if(SUCCEEDED(hr) && !Description.DescriptionSize)
    {
        DPF(DPFLVL_ERROR, "Description size is 0");
        hr = DSERR_GENERIC;
    }

    if(SUCCEEDED(hr))
    {
        pPropDesc = (PKSPROPERTY_DESCRIPTION)MEMALLOC_A(BYTE, Description.DescriptionSize);
        hr = HRFROMP(pPropDesc);
    }

    if(SUCCEEDED(hr))
    {
        hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &NodeProperty, sizeof(NodeProperty), pPropDesc, Description.DescriptionSize);
    }

    if(SUCCEEDED(hr))
    {
        *ppPropDesc = pPropDesc;
    }
    else
    {
        MEMFREE(pPropDesc);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetDriverCertification
 *
 *  Description:
 *      Checks driver certification for a given devnode.
 *
 *  Arguments:
 *      LPCTSTR [in]: driver interface.
 *
 *  Returns:
 *      DWORD [in]: VERIFY_* flag.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetDriverCertification"

DWORD KsGetDriverCertification
(
    LPCTSTR                 pszInterface
)
{

#ifdef DEBUG
    DWORD                   dwTime;
#endif

    BOOL                    fCertified;
    DWORD                   dwCertified;

    DPF_ENTER();

#ifdef DEBUG
    dwTime = timeGetTime();
#endif

    fCertified = GetDriverCertificationStatus(pszInterface);

#ifdef DEBUG
    DPF(DPFLVL_MOREINFO, "Certification check took %lu ms", timeGetTime() - dwTime);
#endif

    dwCertified = fCertified ? VERIFY_CERTIFIED : VERIFY_UNCERTIFIED;

    DPF_LEAVE(dwCertified);
    return dwCertified;
}


/***************************************************************************
 *
 *  KsGetPinInstances
 *
 *  Description:
 *      Gets the number of pins on the renderer.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: pin id.
 *      PKSPIN_CINSTANCES [out]: receives instance data.
 *
 *  Returns:
 *     HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetPinInstances"

HRESULT
KsGetPinInstances
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    PKSPIN_CINSTANCES       pInstances
)
{
    KSP_PIN                 Pin;
    HRESULT                 hr;

    DPF_ENTER();

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = KSPROPERTY_PIN_CINSTANCES;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;

    Pin.PinId = ulPinId;
    Pin.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), pInstances, sizeof(*pInstances));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetRenderPinInstances
 *
 *  Description:
 *      Gets the number of pins on the renderer.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: pin id.
 *      PKSPIN_CINSTANCES [out]: receives instance data.
 *
 *  Returns:
 *     HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetRenderPinInstances"

HRESULT
KsGetRenderPinInstances
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    PKSPIN_CINSTANCES       pInstances
)
{
    KSP_PIN                 Pin;
    HRESULT                 hr;

    DPF_ENTER();

    Pin.Property.Set = KSPROPSETID_Sysaudio;
    Pin.Property.Id = KSPROPERTY_SYSAUDIO_RENDER_PIN_INSTANCES;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;

    Pin.PinId = ulPinId;
    Pin.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), pInstances, sizeof(*pInstances));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetFirstHardwareConnection
 *
 *  Description:
 *      Gets the index of the first topology connection.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: pin id.
 *      PULONG [out]: receives index identifier.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetFirstHardwareConnection"

HRESULT
KsGetFirstHardwareConnection
(
    HANDLE                  hDevice,
    ULONG                   ulPinId,
    PULONG                  pIndex
)
{
    KSP_PIN                 Pin;
    HRESULT                 hr;

    DPF_ENTER();

    Pin.Property.Set = KSPROPSETID_Sysaudio;
    Pin.Property.Id = KSPROPERTY_SYSAUDIO_RENDER_CONNECTION_INDEX;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;

    Pin.PinId = ulPinId;
    Pin.Reserved = 0;

    hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Pin, sizeof(Pin), pIndex, sizeof(*pIndex));

    if(SUCCEEDED(hr) && MAX_ULONG == *pIndex)
    {
        hr = DSERR_GENERIC;
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetVolumeRange
 *
 *  Description:
 *      Gets the volume level range for a node.
 *
 *  Arguments:
 *      HANDLE [in]: pin id.
 *      ULONG [in]: node id.
 *      PKSPROPERTY_STEPPING_LONG [out]: receives volume range.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetVolumeRange"

HRESULT
KsGetVolumeRange
(
    HANDLE                      hPin,
    ULONG                       ulNodeId,
    PKSPROPERTY_STEPPING_LONG   pVolumeRange
)
{
    PKSPROPERTY_DESCRIPTION     pPropDesc       = NULL;
    HRESULT                     hr              = DS_OK;

    DPF_ENTER();

    hr = KsGetBasicSupport(hPin, KSPROPSETID_Audio, KSPROPERTY_AUDIO_VOLUMELEVEL, ulNodeId, &pPropDesc);

    if(FAILED(hr))
    {
        // Changed this to a warning because it's very frequent and non-critical
        DPF(DPFLVL_WARNING, "Unable to get volume range for node %lu", ulNodeId);
    }

    if(SUCCEEDED(hr))
    {
        CopyMemory(pVolumeRange, ((PKSPROPERTY_MEMBERSHEADER)(pPropDesc + 1)) + 1, sizeof(*pVolumeRange));
    }

    MEMFREE(pPropDesc);

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetSysAudioDeviceInstance
 *
 *  Description:
 *      Sets the device instance that the System Audio Device should use.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: device id.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetSysAudioDeviceInstance"

HRESULT
KsSetSysAudioDeviceInstance
(
    HANDLE                  hDevice,
    ULONG                   ulDeviceId
)
{
    SYSAUDIO_INSTANCE_INFO  InstanceInfo;
    HRESULT                 hr;

    DPF_ENTER();

    if (g_ulWdmVersion == WDM_1_0)
    {
        // WDM 1.0 sysaudio does not understand about not combining pins
        //
        KSPROPERTY  Property;

        Property.Set = KSPROPSETID_Sysaudio;
        Property.Id = KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE;
        Property.Flags = KSPROPERTY_TYPE_SET;

        hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &Property, sizeof(Property), &ulDeviceId, sizeof(ulDeviceId));
    }
    else
    {
        InstanceInfo.Property.Set = KSPROPSETID_Sysaudio;
        InstanceInfo.Property.Id = KSPROPERTY_SYSAUDIO_INSTANCE_INFO;
        InstanceInfo.Property.Flags = KSPROPERTY_TYPE_SET;

        InstanceInfo.Flags = SYSAUDIO_FLAGS_DONT_COMBINE_PINS;
        InstanceInfo.DeviceNumber = ulDeviceId;

        hr = PostDevIoctl(hDevice, IOCTL_KS_PROPERTY, &InstanceInfo, sizeof(InstanceInfo));
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsAggregatePinAudioDataRange
 *
 *  Description:
 *      Aggregates values in a KSDATARANGE_AUDIO structure.
 *
 *  Arguments:
 *      PKSDATARANGE_AUDIO [in]: data range.
 *      PKSDATARANGE_AUDIO [in/out]: receives aggregate data range.  It
 *                                   is assumed that this parameter has
 *                                   already had its values initialized.
 *
 *  Returns:
 *      (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsAggregatePinAudioDataRange"

void
KsAggregatePinAudioDataRange
(
    PKSDATARANGE_AUDIO      pDataRange,
    PKSDATARANGE_AUDIO      pAggregateDataRange
)
{
    DPF_ENTER();

    pAggregateDataRange->MaximumChannels = max(pAggregateDataRange->MaximumChannels, pDataRange->MaximumChannels);
    pAggregateDataRange->MinimumBitsPerSample = min(pAggregateDataRange->MinimumBitsPerSample, pDataRange->MinimumBitsPerSample);
    pAggregateDataRange->MaximumBitsPerSample = max(pAggregateDataRange->MaximumBitsPerSample, pDataRange->MaximumBitsPerSample);
    pAggregateDataRange->MinimumSampleFrequency = min(pAggregateDataRange->MinimumSampleFrequency, pDataRange->MinimumSampleFrequency);
    pAggregateDataRange->MaximumSampleFrequency = max(pAggregateDataRange->MaximumSampleFrequency, pDataRange->MaximumSampleFrequency);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  KsAggregatePinInstances
 *
 *  Description:
 *      Aggregates values in a KSPIN_CINSTANCES structure.
 *
 *  Arguments:
 *      PKSPIN_CINSTANCES [in]: instance data.
 *      PKSPIN_CINSTANCES [out]: receives aggregate instance data.
 *                               It's assumed that this parameter has
 *                               already had its values initialized.
 *
 *  Returns:
 *     (void)
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsAggregatePinInstances"

void
KsAggregatePinInstances
(
    PKSPIN_CINSTANCES       pInstances,
    PKSPIN_CINSTANCES       pAggregateInstances
)
{
    ULONGLONG               ullAggregate;

    DPF_ENTER();

    ullAggregate = (ULONGLONG)pAggregateInstances->PossibleCount + (ULONGLONG)pInstances->PossibleCount;
    pAggregateInstances->PossibleCount = NUMERIC_CAST(ullAggregate, ULONG);

    ullAggregate = (ULONGLONG)pAggregateInstances->CurrentCount + (ULONGLONG)pInstances->CurrentCount;
    pAggregateInstances->CurrentCount = NUMERIC_CAST(ullAggregate, ULONG);

    DPF_LEAVE_VOID();
}


/***************************************************************************
 *
 *  KsGetNodeInformation
 *
 *  Description:
 *      Gets information about a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSNODE [in/out]: node information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetNodeInformation"

HRESULT
KsGetNodeInformation
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    PKSNODE                 pNode
)
{
    HRESULT                 hr  = DS_OK;

    DPF_ENTER();

    pNode->NodeId = ulNodeId;
    pNode->CpuResources = KSAUDIO_CPU_RESOURCES_UNINITIALIZED;

    if(IS_VALID_NODE(ulNodeId))
    {

#pragma TODO("KSPROPERTY_AUDIO_CPU_RESOURCES must be supported")

        /*hr = */KsGetCpuResources(hDevice, ulNodeId, &pNode->CpuResources);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetAlgorithmInstance
 *
 *  Description:
 *      Get the primary algorithm instance for the topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSNODE [in/out]: node information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetAlgorithmInstance"

HRESULT
KsGetAlgorithmInstance
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    LPGUID                  lpGuidAlgorithmInstance
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsGetNodeProperty
         (
             hDevice,
             KSPROPSETID_Audio,
             KSPROPERTY_AUDIO_ALGORITHM_INSTANCE,
             ulNodeId,
             lpGuidAlgorithmInstance,
             sizeof(GUID)
         );

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsSetAlgorithmInstance
 *
 *  Description:
 *      Set a topology node to a particular algorithm instance.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSNODE [in/out]: node information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsSetAlgorithmInstance"

HRESULT
KsSetAlgorithmInstance
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    GUID                    guidAlgorithmInstance
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsSetNodeProperty
         (
             hDevice,
             KSPROPSETID_Audio,
             KSPROPERTY_AUDIO_ALGORITHM_INSTANCE,
             ulNodeId,
             &guidAlgorithmInstance,
             sizeof(guidAlgorithmInstance)
         );

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsGetVolumeNodeInformation
 *
 *  Description:
 *      Gets information about a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      PKSVOLUMENODE [in/out]: node information.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsGetVolumeNodeInformation"

HRESULT
KsGetVolumeNodeInformation
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    PKSVOLUMENODE           pNode
)
{
    HRESULT                 hr;

    DPF_ENTER();

    pNode->VolumeRange.SteppingDelta = 1;
    pNode->VolumeRange.Reserved = 0;
    pNode->VolumeRange.Bounds.SignedMinimum = MIN_LONG;
    pNode->VolumeRange.Bounds.SignedMaximum = 0;

    hr = KsGetNodeInformation(hDevice, ulNodeId, &pNode->Node);

    if(SUCCEEDED(hr) && IS_VALID_NODE(ulNodeId))
    {
        // If the node doesn't support KSPROPERTY_AUDIO_VOLUMERANGE,
        // we'll just go with the defaults
        KsGetVolumeRange(hDevice, ulNodeId, &pNode->VolumeRange);
    }

    DPF_LEAVE_HRESULT(hr);
    return hr;
}


/***************************************************************************
 *
 *  KsEnableTopologyNode
 *
 *  Description:
 *      Enables or disables a topology node.
 *
 *  Arguments:
 *      HANDLE [in]: device handle.
 *      ULONG [in]: node id.
 *      BOOL [in]: enable value.
 *
 *  Returns:
 *      HRESULT: DirectSound/COM result code.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "KsEnableTopologyNode"

HRESULT
KsEnableTopologyNode
(
    HANDLE                  hDevice,
    ULONG                   ulNodeId,
    BOOL                    fEnable
)
{
    HRESULT                 hr;

    DPF_ENTER();

    hr = KsSetNodeProperty(hDevice, KSPROPSETID_TopologyNode, KSPROPERTY_TOPOLOGYNODE_ENABLE, ulNodeId, &fEnable, sizeof(fEnable));

    DPF_LEAVE_HRESULT(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\makefile.inc ===
#############################################################################
#
#       Copyright (C) Microsoft Corporation 1997-1998
#       All Rights Reserved.
#
#############################################################################

misc: ..\dsdriver.h ..\dsdrvi.h ..\modeflag.h ..\modeflag.inc ..\mix.cpp \
      ..\dpf.c ..\w95help.c

..\dsdriver.h: ..\dsdriver.x
        hsplit -o $@ nul -bt2 BEGIN_MSINTERNAL END_MSINTERNAL -c @@ $?

..\dpf.c: $(DXROOT)\misc\dpf.c
        copy $? $@

..\dsdrvi.h: ..\dsdriver.x
        copy $? $@

..\mix.cpp: ..\mix.m4
        m4 ..\mix.m4 > ..\mix.cpp

..\modeflag.h: ..\modeflag.m4
        m4 -Dmodeflag_h ..\modeflag.m4 > ..\modeflag.h

..\modeflag.inc: ..\modeflag.m4
        m4 -Dmodeflag_inc ..\modeflag.m4 > ..\modeflag.inc

..\w95help.c: $(DXROOT)\misc\w95help.c
        copy $? $@

placeVxD:
        binplace ..\..\dsvxd\dsound.vxd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\ksuserw.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ksuserw.cpp
 *  Content:    Wrapper functions for ksuser
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  01/13/00    jimge   Created
 *
 ***************************************************************************/

#include "dsoundi.h"

typedef DWORD (*PKSCREATEPIN)(
    IN HANDLE           hFilter,
    IN PKSPIN_CONNECT   pConnect,
    IN ACCESS_MASK      dwDesiredAccess,
    OUT PHANDLE         pConnectionHandle
);

struct KsUserProcessInstance    
{
    DWORD                   dwProcessId;
    HMODULE                 hKsUser;
    PKSCREATEPIN            pCreatePin;
    KsUserProcessInstance   *pNext;
};

static KsUserProcessInstance *pKsUserList;

/***************************************************************************
 *
 *  DsKsCreatePin
 *
 *  Description:
 *      Wraps the KsCreatePin from ksuser.dll. For performance reasons
 *      we only want to load ksuser.dll once per process, so this
 *      function tracks process ID's and loads ksuser on first request.
 * 
 *      Unfortunately we cannot unload the DLL on process cleanup because
 *      FreeLibrary is spec'ed as not being safe from DllMain. However,
 *      we can clean up the list.
 *
 *      Note that the list is protected by the DLL mutex, which is held
 *      by any call attempting to create a pin.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "DsKsCreatePin"

DWORD DsKsCreatePin(
    IN HANDLE           hFilter,
    IN PKSPIN_CONNECT   pConnect,
    IN ACCESS_MASK      dwDesiredAccess,
    OUT PHANDLE         pConnectionHandle)
{
    DPF_ENTER();

    DWORD dwThisProcessId = GetCurrentProcessId();
    KsUserProcessInstance *pInstance;

    for (pInstance = pKsUserList; pInstance; pInstance = pInstance->pNext) 
    {
        if (pInstance->dwProcessId == dwThisProcessId)
        {
            break;
        }
    }

    if (pInstance == NULL)
    {
        pInstance = NEW(KsUserProcessInstance);
        if (!pInstance)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        pInstance->hKsUser = LoadLibrary(TEXT("KsUser.dll"));
        if (pInstance->hKsUser == (HANDLE)NULL)
        {
            DELETE(pInstance);
            return GetLastError();
        }

        pInstance->pCreatePin = (PKSCREATEPIN)GetProcAddress(
            pInstance->hKsUser,
            "KsCreatePin");
        if (pInstance->pCreatePin == NULL) 
        {
            FreeLibrary(pInstance->hKsUser);
            DELETE(pInstance);
            return ERROR_INVALID_HANDLE;
        }

        pInstance->dwProcessId = dwThisProcessId;
        pInstance->pNext = pKsUserList;
        pKsUserList = pInstance;
    }

    DWORD dw = (*pInstance->pCreatePin)(
        hFilter, 
        pConnect, 
        dwDesiredAccess, 
        pConnectionHandle);

    DPF_LEAVE(dw);

    return dw;
}

/***************************************************************************
 *
 *  KsCreatePin
 *
 *  Description:
 *      Wraps the KsCreatePin from ksuser.dll. For performance reasons
 *      we only want to load ksuser.dll once per process, so this
 *      function tracks process ID's and loads ksuser on first request.
 * 
 *      Unfortunately we cannot unload the DLL on process cleanup because
 *      FreeLibrary is spec'ed as not being safe from DllMain. However,
 *      we can clean up the list.
 *
 *      Note that the list is protected by the DLL mutex, which is held
 *      by any call attempting to create a pin.
 *
 ***************************************************************************/

#undef DPF_FNAME
#define DPF_FNAME "RemovePerProcessKsUser"

VOID RemovePerProcessKsUser(
    DWORD dwProcessId)
{
    DPF_ENTER();

    KsUserProcessInstance *prev;
    KsUserProcessInstance *curr;

    for (prev = NULL, curr = pKsUserList; curr; prev = curr, curr = curr->pNext)
    {
        if (curr->dwProcessId == dwProcessId)
        {
            break;
        }
    }

    if (curr)
    {
        if (prev)
        {
            prev->pNext = curr->pNext;
        }
        else
        {
            pKsUserList = curr->pNext;
        }

        DELETE(curr);
    }

    DPF_LEAVE_VOID();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\ksvad.h ===
/***************************************************************************
 *
 *  Copyright (C) 1995-2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ksvad.h
 *  Content:    WDM/CSA Virtual Audio Device class
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  2/25/97     dereks  Created.
 *
 ***************************************************************************/

#ifdef NOKS
#error ksvad.h included with NOKS defined
#endif

#ifndef __KSVAD_H__
#define __KSVAD_H__

#include "dsoundi.h"
#include "kshlp.h"
#include "ks3d.h"

#define DIRECTSOUNDMIXER_SRCQUALITY_PINDEFAULT  ((DIRECTSOUNDMIXER_SRCQUALITY)-1)

// Highest possible number of SPEAKER_FRONT_LEFT-style position codes,
// given that they are DWORDs and 2^31 is already taken by SPEAKER_ALL

#define MAX_SPEAKER_POSITIONS (8 * sizeof(DWORD) - 1)  // I.e. 31

// Render device topology info
typedef struct tagKSRDTOPOLOGY
{
    KSNODE          SummingNode;
    KSNODE          SuperMixNode;
    KSNODE          SrcNode;
    KSVOLUMENODE    VolumeNode;
    KSVOLUMENODE    PanNode;
    KSNODE          ThreedNode;
    KSNODE          MuteNode;
    KSNODE          SurroundNode;
    KSNODE          DacNode;
    KSNODE          AecNode;
} KSRDTOPOLOGY, *PKSRDTOPOLOGY;


#ifdef __cplusplus

// FormatTagFromWfx(): Extracts the format tag from any kind of wave format
// structure, including WAVEFORMATEXTENSIBLE.  This function should migrate
// to misc.cpp/h if it becomes useful elsewhere in the code.

__inline WORD FormatTagFromWfx(LPCWAVEFORMATEX pwfx)
{
    if (pwfx->wFormatTag != WAVE_FORMAT_EXTENSIBLE)
        return pwfx->wFormatTag;
    else if (CompareMemoryOffset(&PWAVEFORMATEXTENSIBLE(pwfx)->SubFormat, &KSDATAFORMAT_SUBTYPE_WAVEFORMATEX, sizeof(GUID), sizeof(WORD)))
        return WORD(PWAVEFORMATEXTENSIBLE(pwfx)->SubFormat.Data1);
    else
        return WAVE_FORMAT_UNKNOWN;
}

// Fwd decl
class CKsRenderDevice;
class CKsPrimaryRenderWaveBuffer;
class CKsSecondaryRenderWaveBuffer;
class CKsPropertySet;
class CKsRenderPin;
class CKsRenderPinCache;

// Pin reuse data
typedef struct tagKSPINCACHE
{
    CKsRenderPin *  Pin;
    DWORD           CacheTime;
} KSPINCACHE, *PKSPINCACHE;


// The KS Render Audio Device class
class CKsRenderDevice : public CRenderDevice, public CKsDevice
{
    friend class CKsPrimaryRenderWaveBuffer;
    friend class CKsSecondaryRenderWaveBuffer;
    friend class CKsRenderPin;

private:
    CKsRenderPinCache *         m_pPinCache;                        // Pin cache
    PKSRDTOPOLOGY               m_paTopologyInformation;            // Topology information
    LPWAVEFORMATEX              m_pwfxFormat;                       // Device format
    DIRECTSOUNDMIXER_SRCQUALITY m_nSrcQuality;                      // Current mixer SRC quality
    DWORD                       m_dwSpeakerConfig;                  // Speaker configuration
    ULONG                       m_ulVirtualSourceIndex;             // Virtual source index for global volume
    HANDLE                      m_hPin;                             // Kmixer preload pin handle
    LARGE_INTEGER               m_liDriverVersion;                  // Driver version

    // To support SetChannelVolume() and multichannel 3D panning:
    LONG                        m_lSpeakerPositions;                // As obtained by KSPROPERTY_AUDIO_CHANNEL_CONFIG
    ULONG                       m_ulChannelCount;                   // No. of bits set in m_lSpeakerPositions
    LPINT                       m_pnSpeakerIndexTable;              // Maps speaker positions to output channels
    static INT                  m_anDefaultSpeakerIndexTable[];     // Default value for m_pnSpeakerIndexTable

    // Used to cache the driver's supported frequency range
    DWORD                       m_dwMinHwSampleRate;
    DWORD                       m_dwMaxHwSampleRate;

    // For AEC control
    BOOL                        m_fIncludeAec;
    GUID                        m_guidAecInstance;
    DWORD                       m_dwAecFlags;

public:
    CKsRenderDevice(void);
    virtual ~CKsRenderDevice(void);

    // Driver enumeration
    virtual HRESULT EnumDrivers(CObjectList<CDeviceDescription> *);

    // Initialization
    virtual HRESULT Initialize(CDeviceDescription *);

    // Device capabilities
    virtual HRESULT GetCaps(LPDSCAPS);
    virtual HRESULT GetCertification(LPDWORD, BOOL);
    HRESULT GetFrequencyRange(LPDWORD, LPDWORD);

    // Device properties
    virtual HRESULT GetGlobalFormat(LPWAVEFORMATEX, LPDWORD);
    virtual HRESULT SetGlobalFormat(LPCWAVEFORMATEX);
    virtual HRESULT SetSrcQuality(DIRECTSOUNDMIXER_SRCQUALITY);
    virtual HRESULT SetSpeakerConfig(DWORD);

    // Buffer creation
    virtual HRESULT CreatePrimaryBuffer(DWORD, LPVOID, CPrimaryRenderWaveBuffer **);
    virtual HRESULT CreateSecondaryBuffer(LPCVADRBUFFERDESC, LPVOID, CSecondaryRenderWaveBuffer **);
    virtual HRESULT CreateKsSecondaryBuffer(LPCVADRBUFFERDESC, LPVOID, CSecondaryRenderWaveBuffer **, CSysMemBuffer *);

    // Pin helpers
    virtual HRESULT CreateRenderPin(ULONG, DWORD, LPCWAVEFORMATEX, REFGUID, LPHANDLE, PULONG);

    // AEC
    virtual HRESULT IncludeAEC(BOOL, REFGUID, DWORD);

private:
    // Pin/topology helpers
    virtual HRESULT ValidatePinCaps(ULONG, DWORD, REFGUID);

    // Misc
    virtual HRESULT PreloadSoftwareGraph(void);

private:
    // Topology helpers
    virtual HRESULT GetTopologyInformation(CKsTopology *, PKSRDTOPOLOGY);

    // Device capabilities
    virtual HRESULT GetKsDeviceCaps(DWORD, REFGUID, PKSDATARANGE_AUDIO, PKSPIN_CINSTANCES, PKSPIN_CINSTANCES);

    // IDs of the nodes we need to be able to manipulate in CKsRenderDevice
    // (horribly hacky - see the comment in ksvad.cpp)
    ULONG m_ulPanNodeId;
    ULONG m_ulSurroundNodeId;
    ULONG m_ulDacNodeId;
};

inline HRESULT CKsRenderDevice::EnumDrivers(CObjectList<CDeviceDescription> *plst)
{
    return CKsDevice::EnumDrivers(plst);
}

inline HRESULT CKsRenderDevice::GetCertification(LPDWORD pdwCertification, BOOL fGetCaps)
{
    return CKsDevice::GetCertification(pdwCertification, fGetCaps);
}

inline HRESULT CKsRenderDevice::IncludeAEC(BOOL fEnable, REFGUID guidInstance, DWORD dwFlags)
{
    m_fIncludeAec = fEnable;
    m_guidAecInstance = guidInstance;
    m_dwAecFlags = dwFlags;
    return DS_OK;
}
 

// The KS primary wave buffer
class CKsPrimaryRenderWaveBuffer : public CPrimaryRenderWaveBuffer
{
    friend class CKsRenderDevice;

private:
    CKsRenderDevice *               m_pKsDevice;        // KS audio device
    CKs3dListener *                 m_p3dListener;      // 3D listener
    CKsSecondaryRenderWaveBuffer *  m_pSecondaryBuffer; // The secondary buffer
    DWORD                           m_dwState;          // Current buffer state

public:
    CKsPrimaryRenderWaveBuffer(CKsRenderDevice *, LPVOID);
    virtual ~CKsPrimaryRenderWaveBuffer(void);

    // Initialization
    virtual HRESULT Initialize(DWORD);

    // Access rights
    virtual HRESULT RequestWriteAccess(BOOL);

    // Buffer data
    virtual HRESULT CommitToDevice(DWORD, DWORD);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);

    // Owned objects
    virtual HRESULT CreatePropertySet(CPropertySet **);
    virtual HRESULT Create3dListener(C3dListener **);

private:
    virtual HRESULT OnSetFormat(void);
    virtual HRESULT FixUpBaseClass(void);
};

inline HRESULT CKsPrimaryRenderWaveBuffer::CreatePropertySet(CPropertySet **)
{
    return DSERR_UNSUPPORTED;
}


// The KS secondary wave buffer
class CKsSecondaryRenderWaveBuffer : public CSecondaryRenderWaveBuffer, private CUsesCallbackEvent
{
    friend class CKsRenderDevice;
    friend class CKsPrimaryRenderWaveBuffer;
    friend class CKsItd3dObject;
    friend class CKsIir3dObject;
    friend class CKsHw3dObject;

private:
    CKsRenderDevice *               m_pKsDevice;                // KS audio device
    CKsRenderPin *                  m_pPin;                     // KS render pin
    DWORD                           m_dwState;                  // Current buffer state
    CCallbackEvent *                m_pCallbackEvent;           // The callback event
    CEvent *                        m_pLoopingEvent;            // Looping buffer event
    LPDSBPOSITIONNOTIFY             m_paNotes;                  // Current notification positions
    LPDSBPOSITIONNOTIFY             m_pStopNote;                // Stop notification
    DWORD                           m_cNotes;                   // Count of notification positions
    LONG                            m_lVolume;                  // Buffer volume
    LONG                            m_lPan;                     // Buffer pan
    BOOL                            m_fMute;                    // Buffer mute
    DIRECTSOUNDMIXER_SRCQUALITY     m_nSrcQuality;              // Buffer SRC quality
    DWORD                           m_dwPositionCache;          // Position cache

    // Flags to help with 3D algorithm selection/fallback:
    BOOL                            m_fNoVirtRequested;         // DS3DALG_NO_VIRTUALIZATION requested?
    BOOL                            m_fSoft3dAlgUnavail;        // Unsupported HRTF algorithm requested?

public:
    CKsSecondaryRenderWaveBuffer(CKsRenderDevice *, LPVOID);
    virtual ~CKsSecondaryRenderWaveBuffer(void);

    // Initialization
    virtual HRESULT Initialize(LPCVADRBUFFERDESC, CKsSecondaryRenderWaveBuffer *, CSysMemBuffer *pBuffer = NULL);

    // Resource allocation
    virtual HRESULT AcquireResources(DWORD);
    virtual HRESULT StealResources(CSecondaryRenderWaveBuffer *);
    virtual HRESULT FreeResources(void);

    // Buffer creation
    virtual HRESULT Duplicate(CSecondaryRenderWaveBuffer **);

    // Buffer data
    virtual HRESULT CommitToDevice(DWORD, DWORD);

    // Buffer control
    virtual HRESULT GetState(LPDWORD);
    virtual HRESULT SetState(DWORD);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetCursorPosition(DWORD);

    // Buffer properties
    virtual HRESULT SetAttenuation(PDSVOLUMEPAN);
#ifdef FUTURE_MULTIPAN_SUPPORT
    virtual HRESULT SetChannelAttenuations(LONG, DWORD, const DWORD*, const LONG*);
#endif
    virtual HRESULT SetAllChannelAttenuations(LONG, DWORD, LPLONG);
    virtual HRESULT SetFrequency(DWORD, BOOL fClamp =FALSE);
    virtual HRESULT SetMute(BOOL);
    virtual HRESULT SetFormat(LPCWAVEFORMATEX);

    // Position notifications
    virtual HRESULT SetNotificationPositions(DWORD, LPCDSBPOSITIONNOTIFY);
    virtual HRESULT FreeNotificationPositions(void);

    // Owned objects
    virtual HRESULT CreatePropertySet(CPropertySet **);
    virtual HRESULT Create3dObject(C3dListener *, C3dObject **);

private:
    // Buffer properties
    virtual HRESULT SetSrcQuality(DIRECTSOUNDMIXER_SRCQUALITY);

    // Pin creation
    virtual HRESULT CreatePin(DWORD, LPCWAVEFORMATEX, REFGUID, CKsRenderPin **);
    virtual HRESULT HandleResourceAcquisition(CKsRenderPin *);
    virtual BOOL HasAcquiredResources(void);

    // Pin freedom
    virtual HRESULT FreePin(BOOL);

    // Buffer control
    virtual HRESULT SetPlayState(BOOL);
    virtual HRESULT SetStopState(BOOL, BOOL);

    // Buffer events
    virtual void EventSignalCallback(CCallbackEvent *);

    // Owned objects
    virtual HRESULT CreateHw3dObject(C3dListener *, C3dObject **);
    virtual HRESULT CreateIir3dObject(C3dListener *, C3dObject **);
    virtual HRESULT CreateItd3dObject(C3dListener *, C3dObject **);
    virtual HRESULT CreateMultiPan3dObject(C3dListener *, BOOL, DWORD, C3dObject **);
};


// The KS render pin object
class CKsRenderPin : public CDsBasicRuntime
{
    friend class CKsSecondaryRenderWaveBuffer;
    friend class CKsRenderPinCache;
    friend class CKsHw3dObject;

private:
    CKsRenderDevice *                       m_pKsDevice;            // KS audio device
    ULONG                                   m_ulPinId;              // KS pin id
    HANDLE                                  m_hPin;                 // Audio device pin
    DWORD                                   m_dwFlags;              // Pin flags
    LPWAVEFORMATEX                          m_pwfxFormat;           // Pin format
    GUID                                    m_guid3dAlgorithm;      // Pin 3D algorithm
    DWORD                                   m_dwState;              // Current buffer state
    PLOOPEDSTREAMING_POSITION_EVENT_DATA    m_paEventData;          // Position notification event data
    DWORD                                   m_cEventData;           // Count of events
    KSSTREAMIO                              m_kssio;                // KS stream IO data
    LONG                                    m_lVolume;              // Pin volume
    LONG                                    m_lPan;                 // Pin pan
    BOOL                                    m_fMute;                // Pin mute
    DIRECTSOUNDMIXER_SRCQUALITY             m_nSrcQuality;          // Pin SRC quality
    DWORD                                   m_dwPositionCache;      // Cached buffer position

public:
    CKsRenderPin(CKsRenderDevice *);
    virtual ~CKsRenderPin(void);

    // Initialization
    virtual HRESULT Initialize(DWORD, LPCWAVEFORMATEX, REFGUID);

    // Pin properties
    virtual HRESULT SetVolume(LONG);
    virtual HRESULT SetPan(LONG);
    virtual HRESULT SetChannelLevels(DWORD, const LONG *);
    virtual HRESULT SetFrequency(DWORD);
    virtual HRESULT SetMute(BOOL);
    virtual HRESULT SetSrcQuality(DIRECTSOUNDMIXER_SRCQUALITY);
    virtual HRESULT SetSuperMix(void);

    // Pin control
    virtual HRESULT SetPlayState(LPCVOID, DWORD, BOOL, HANDLE);
    virtual HRESULT SetStopState(BOOL, BOOL);
    virtual HRESULT GetCursorPosition(LPDWORD, LPDWORD);
    virtual HRESULT SetCursorPosition(DWORD);

    // Position notifications
    virtual HRESULT EnableNotificationPositions(LPCDSBPOSITIONNOTIFY, DWORD);
    virtual HRESULT DisableNotificationPositions(void);
};


// Pin cache
class CKsRenderPinCache : public CDsBasicRuntime
{
private:
    static const DWORD          m_dwTimeout;            // Timeout for old pins
    CList<KSPINCACHE>           m_lstPinCache;          // Pin-reuse pool

public:
    CKsRenderPinCache(void);
    virtual ~CKsRenderPinCache(void);

    virtual HRESULT AddPinToCache(CKsRenderPin *);
    virtual HRESULT GetPinFromCache(DWORD, LPCWAVEFORMATEX, REFGUID, CKsRenderPin **);
    virtual void FlushCache(void);

private:
    virtual void RemovePinFromCache(CNode<KSPINCACHE> *);
    virtual void FlushExpiredPins(void);
};

#endif // __cplusplus

#endif // __KSVAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\merge101.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge101 */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE101ASM
BOOL Merge101Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

#if 1
	if (1 || !pMixSource->m_fUse_MMX)	//Non-MMX is faster.
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	movsx	ecx, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	edi, 8			// plBuild += 2
	add	ecx, ebx		// NewSample += x
	mov	ebx, DWORD PTR [edi-8]
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ebx, ecx
	add	eax, ebp		// dwFraction += dwStep
	mov	DWORD PTR [edi-8], ebx	// *plBuild += x

	mov	ebx, DWORD PTR [edi-4]
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov	ebp, eax
Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	movsx	ecx, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	edi, 8			// plBuild += 2
	add	ecx, ebx		// NewSample += x

	movd		mm1, ecx
	punpckldq	mm1, mm1
	paddd		mm1, QWORD PTR [edi-8]
	movq		QWORD PTR [edi-8], mm1

//	mov	ebx, DWORD PTR [edi-8]
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	add	ebx, ecx
	add	eax, ebp		// dwFraction += dwStep
//	mov	DWORD PTR [edi-8], ebx	// *plBuild += x

//	mov	ebx, DWORD PTR [edi-4]
//	add	ebx, ecx
	mov	ecx, eax
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
    LONG SampleNext, SampleSave;
    while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
    {
      LONG Sample;
      Sample = ((LONG)*((SHORT*)(XpSource)));
      SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
      LONG dwFrac = dwFraction & FRACT_MASK;
      SampleSave = Sample;
      Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
      dwFraction += dwStep;
      *XplBuild += Sample;
      *(XplBuild + 1) += Sample;
      plBuild += 2;
    }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\merge162.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge162 */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE162ASM
BOOL Merge162Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define USE_ITERS		// Keep separate from RESAMPLE to ease removal.
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
    LONG iters, i;
    i     = plBuildEnd - plBuild;
    iters = pSourceEnd - pSource;
    iters /= STEP_SIZE;
    i /= 2;;
    if (i < iters) iters = i;
    i = iters;

    ASSERT((pMixSource->m_dwLVolume & 0xffff0000) == 0);
    ASSERT((pMixSource->m_dwRVolume & 0xffff0000) == 0);

#if 0 // {
#ifdef Not_VxD
    DPF(0, "Merge162: LVolume 0x%08lx RVolume 0x%08lx", pMixSource->m_dwLVolume, pMixSource->m_dwRVolume);
#else
    DPF(("Merge162: LVolume 0x%08lx RVolume 0x%08lx", pMixSource->m_dwLVolume, pMixSource->m_dwRVolume));
#endif
#endif // }

#if 1
    if (iters) {
      _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*2-2]
	push	ebp
	cmp	ebx, 14
        mov	edi, plBuild
	mov	ebp, pMixSource
	jl	LastSamples

	mov	eax, [ebp]pMixSource.m_fUse_MMX
	test	eax, eax
	je	LastSamples

	sub	ebx, 6
	pxor	mm0, mm0
	mov	eax, 128
	movd		mm5, eax	// 0, 0, 0, 128
	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128


	mov	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	eax, DWORD PTR [ebp]pMixSource.m_dwLVolume
	shr	eax, 1
	shr	ecx, 1
	shl	ecx, 16
	and	eax, 0xffff
	or	ecx, eax
	movd		mm6, ecx
	punpckldq	mm6, mm6

	lea	ecx, [esi+ebx]
	test	ecx, 6
	je	DoMMX

	add	ebx, 6

FirstSamples:	
	xor	edx, edx
	xor	ecx, ecx

	mov	dl, BYTE PTR [esi+ebx]
	mov	cl, BYTE PTR [esi+ebx+1]

	sub	edx, 128
	sub	ecx, 128

	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*4]

	sar	edx, 16

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], edx
	add	eax, ecx

	sub	ebx, 2

	mov	DWORD PTR [edi+ebx*4+12], eax
	lea	ecx, [esi+ebx]

	and	ecx, 7
	cmp	ecx, 6

	jne	FirstSamples

	sub	ebx, 6

DoMMX:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load 4 samples.
	movq		mm3, mm1
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	punpckhbw	mm3, mm0
	psubw		mm1, mm5
	psubw		mm3, mm5
	psllw		mm1, 8				// * 256
	psllw		mm3, 8
	pmulhw		mm1, mm6			// Only need high parts.

	jmp	DoMMX100

DoMMX10:
	movq		mm1, QWORD PTR [esi+ebx]	// Load 4 samples.

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	movq		mm3, mm1

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	punpckhbw	mm3, mm0

	psubw		mm1, mm5
	psubw		mm3, mm5

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	psllw		mm1, 8				// * 256

	psllw		mm3, 8
	pmulhw		mm1, mm6			// Only need high parts.

DoMMX100:
	punpckhwd	mm2, mm1			// 32 bit stereo...

	pmulhw		mm3, mm6

	punpcklwd	mm1, mm1
	sub		ebx, 8

	psrad		mm1, 15

	punpckhwd	mm4, mm3

	paddd		mm1, QWORD PTR [edi+ebx*4+32]
	punpcklwd	mm3, mm3

	psrad		mm3, 15

	paddd		mm3, QWORD PTR [edi+ebx*4+16+32]
	psrad		mm4, 15

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	psrad		mm2, 15

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	jge		DoMMX10

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load 4 samples.
	movq		mm3, mm1
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	punpckhbw	mm3, mm0
	psubw		mm1, mm5
	psubw		mm3, mm5
	psllw		mm1, 8				// * 256
	psllw		mm3, 8
	
	pmulhw		mm1, mm6			// Only need high parts.
	pmulhw		mm3, mm6

	punpckhwd	mm2, mm1			// 32 bit stereo...
	punpcklwd	mm1, mm1
	punpckhwd	mm4, mm3
	punpcklwd	mm3, mm3

	psrad		mm1, 15
	psrad		mm2, 15
	psrad		mm3, 15
	psrad		mm4, 15
	
	paddd		mm1, QWORD PTR [edi+ebx*4]
	paddd		mm2, QWORD PTR [edi+ebx*4+8]
	paddd		mm3, QWORD PTR [edi+ebx*4+16]
	paddd		mm4, QWORD PTR [edi+ebx*4+24]
	movq		QWORD PTR [edi+ebx*4],    mm1
	movq		QWORD PTR [edi+ebx*4+8],  mm2
	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX
#endif

	emms
	add	ebx, 8
	je	Done

	sub	ebx, 2
	
LastSamples:	
	mov	eax, [ebp]pMixSource.m_MapTable
	test	eax, eax
	je	NoMapTable
	
	mov	ebp, eax

UseMapTable:
	xor	edx, edx
	xor	ecx, ecx

	mov	dl, BYTE PTR [esi+ebx]
	mov	cl, BYTE PTR [esi+ebx+1]

	mov	ecx, DWORD PTR [ebp+ecx*4+1024]
	mov	edx, DWORD PTR [ebp+edx*4+0]

//	sub	edx, 128
//	sub	ecx, 128

//	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
//	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

//	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*4]

//	sar	edx, 16

//	shl	ecx, 8
	add	edx, eax

//	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], edx
	add	eax, ecx

	sub	ebx, 2

	mov	DWORD PTR [edi+ebx*4+12], eax
	jge	UseMapTable

	jmp	Done

NoMapTable:
	xor	edx, edx
	xor	ecx, ecx

	mov	dl, BYTE PTR [esi+ebx]
	mov	cl, BYTE PTR [esi+ebx+1]

	sub	edx, 128
	sub	ecx, 128

	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*4]

	sar	edx, 16

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], edx
	add	eax, ecx

	sub	ebx, 2

	mov	DWORD PTR [edi+ebx*4+12], eax
	jge	NoMapTable
Done:
	pop	ebp
        }
       }
#elif 0
	if (iters)
	_asm {
	mov	esi, pSource
	mov	edi, plBuild
	mov	ebx, iters
	push	ebp
	mov	ebp, pMixSource

	lea	ebx, [ebx*2-2]
Lab:
	xor	edx, edx
	xor	ecx, ecx

	mov	dl, BYTE PTR [esi+ebx]
	mov	cl, BYTE PTR [esi+ebx+1]

	sub	edx, 128
	sub	ecx, 128

	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*4]

	sar	edx, 16

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], edx
	add	eax, ecx

	sub	ebx, 2
	mov	DWORD PTR [edi+ebx*4+12], eax

	jge	Lab

	pop	ebp
	}
#else
    while(--iters >= 0)
    {
      LONG SampleL;
      LONG SampleR;
      SampleL = ((LONG)(*((BYTE*)(XpSource))))     * 256 - 32768L;
      SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
      *XplBuild += SampleL;
      *(XplBuild + 1) += SampleR;
    }
#endif
    iters = i;
    i *= 2;;
    plBuild  += i;
    pSource          = XpSource;
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
  pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\merge160.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge160 */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE160ASM
BOOL Merge160Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
    LONG iters, i;
    i     = plBuildEnd - plBuild;
    iters = pSourceEnd - pSource;
    iters /= STEP_SIZE;
    i /= 2;;
    if (i < iters) iters = i;
    i = iters;

    ASSERT((pMixSource->m_dwLVolume & 0xffff0000) == 0);
    ASSERT((pMixSource->m_dwRVolume & 0xffff0000) == 0);

#if 0 // {
#ifdef Not_VxD
    DPF(0, "Merge160: LVolume 0x%08lx RVolume 0x%08lx", pMixSource->m_dwLVolume, pMixSource->m_dwRVolume);
#else
    DPF(("Merge160: LVolume 0x%08lx RVolume 0x%08lx", pMixSource->m_dwLVolume, pMixSource->m_dwRVolume));
#endif
#endif // }

#if 1
    if (iters) {
      _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*1-1]
	xor	edx, edx
	push	ebp
	cmp	ebx, 7
        mov	edi, plBuild
	mov	ebp, pMixSource
	jl	LastSamples

	mov	eax, [ebp]pMixSource.m_fUse_MMX
	test	eax, eax
	je	LastSamples

	sub	ebx, 3

	pxor		mm0, mm0
	mov		eax, 128
	movd		mm5, eax	// 0, 0, 0, 128
	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128

	mov	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	eax, DWORD PTR [ebp]pMixSource.m_dwLVolume
	shr	ecx, 1			// Only have positive values.
	shr	eax, 1
	and	eax, 0xffff
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	lea	ecx, [esi+ebx]
	test	ecx, 3
	je	DoMMX

	add	ebx, 3

FirstSamples:	
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*8]

	sar	edx, 16

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*8+4]

	mov	DWORD PTR [edi+ebx*8], edx
	add	eax, ecx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], eax
	lea	ecx, [esi+ebx]

	and	ecx, 3
	cmp	ecx, 3

	jne	FirstSamples

	sub	ebx, 3

DoMMX:
#ifdef GTW_REORDER
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// * 256
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	jmp	DoMMX100

DoMMX10:
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*8+8 +32],  mm2
	psubw		mm1, mm5

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	psllw		mm1, 8				// * 256

	movq		mm3, mm1			// Mono samples
	punpcklwd	mm1, mm1			// Make stereo

	movq		QWORD PTR [edi+ebx*8+24+32], mm4
	punpckhwd	mm3, mm3

DoMMX100:
	pmulhw		mm1, mm6			// Only need high parts.

	punpckhwd	mm2, mm1			// 32 bit stereo...

	pmulhw		mm3, mm6
	punpcklwd	mm1, mm1

	psrad		mm1, 15				// Approx. shr16, shl 1.

	paddd		mm1, QWORD PTR [edi+ebx*8]
	punpckhwd	mm4, mm3

	punpcklwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*8],    mm1
	psrad		mm2, 15

	paddd		mm2, QWORD PTR [edi+ebx*8+8]
	psrad		mm3, 15

	paddd		mm3, QWORD PTR [edi+ebx*8+16]
	psrad		mm4, 15
	
	sub		ebx, 4
	jge		DoMMX10

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]
	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	movq		QWORD PTR [edi+ebx*8+24+32], mm4
#else
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// * 256
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6			// Only need high parts.
	pmulhw		mm3, mm6

	punpckhwd	mm2, mm1			// 32 bit stereo...
	punpcklwd	mm1, mm1
	punpckhwd	mm4, mm3
	punpcklwd	mm3, mm3

	psrad		mm1, 15				// Approx. shr16, shl 1.
	psrad		mm2, 15
	psrad		mm3, 15
	psrad		mm4, 15
	
	paddd		mm1, QWORD PTR [edi+ebx*8]
	paddd		mm2, QWORD PTR [edi+ebx*8+8]
	paddd		mm3, QWORD PTR [edi+ebx*8+16]
	paddd		mm4, QWORD PTR [edi+ebx*8+24]
	movq		QWORD PTR [edi+ebx*8],    mm1
	movq		QWORD PTR [edi+ebx*8+8],  mm2
	movq		QWORD PTR [edi+ebx*8+16], mm3
	movq		QWORD PTR [edi+ebx*8+24], mm4
	
	sub		ebx, 4
	jge		DoMMX
#endif

	emms
	add	ebx, 4
	je	Done

	dec	ebx
	xor	edx, edx
	
LastSamples:	
	mov	eax, [ebp]pMixSource.m_MapTable
	test	eax, eax
	je	NoMapTable
	
	mov	ebp, eax

UseMapTable:
	mov	dl, BYTE PTR [esi+ebx]

//	sub	edx, 128
//	mov	ecx, edx

	
	mov	ecx, DWORD PTR [ebp+edx*4+1024]
	mov	edx, DWORD PTR [ebp+edx*4+0]

//	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
//	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

//	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*8]

//	sar	edx, 16

//	shl	ecx, 8
	add	edx, eax

//	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*8+4]

	mov	DWORD PTR [edi+ebx*8], edx
	add	eax, ecx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], eax
	jge	UseMapTable

	jmp	Done

NoMapTable:
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*8]

	sar	edx, 16

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*8+4]

	mov	DWORD PTR [edi+ebx*8], edx
	add	eax, ecx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], eax
	jge	NoMapTable
Done:
	pop	ebp
        }
       }
#elif 0
	if (iters)
	_asm {
	mov	esi, pSource
	mov	edi, plBuild
	mov	ebx, iters
	push	ebp
	mov	ebp, pMixSource

	dec	ebx
	xor	edx, edx
Lab:
	mov	dl, BYTE PTR [esi+ebx]

	sub	edx, 128
	mov	ecx, edx

	imul	edx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	shl	edx, 8
	mov	eax, DWORD PTR [edi+ebx*8]

	sar	edx, 16

	shl	ecx, 8
	add	edx, eax

	sar	ecx, 16
	mov	eax, DWORD PTR [edi+ebx*8+4]

	mov	DWORD PTR [edi+ebx*8], edx
	add	eax, ecx

	xor	edx, edx
	dec	ebx

	mov	DWORD PTR [edi+ebx*8+12], eax
	jge	Lab

	pop	ebp
	}
#else
    while(--iters >= 0)
    {
      LONG Sample;
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
      *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
      *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    }
#endif

    iters = i;
    i *= 2;;
    plBuild  += i;
    pSource          = XpSource;
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\merge165.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge165 */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE165ASM
BOOL Merge165Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
    LONG iters, i;
    i     = plBuildEnd - plBuild;
    iters = pSourceEnd - pSource;
    iters /= STEP_SIZE;
    i /= 2;;
    if (i < iters) iters = i;
    i = iters;
#if 1
     if (iters) {
       _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*2-2]				// 2 at a time.
	cmp	ebx, 14
        mov	edi, plBuild
	push	ebp
        mov	ebp, pMixSource
	jl	LastSamples

	mov	eax, [ebp]pMixSource.m_fUse_MMX
	test	eax, eax
	je	LastSamples

	mov	eax, DWORD PTR [ebp]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	shr	eax, 1
	shr	ecx, 1
	and	ecx, 0xffff
	shl	eax, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	sub	ebx, 6
	pxor	mm0, mm0
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX

	add	ebx, 6

FirstSamples:	
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx

	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	edx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	sar	ecx, 16
	sar	edx, 16

	add	DWORD PTR [edi+ebx*4], ecx
	add	DWORD PTR [edi+ebx*4+4], edx

	sub	ebx, 2
	lea	ecx, [esi+ebx]

	and	ecx, 7
	cmp	ecx, 6

	jne	FirstSamples

	sub	ebx, 6

DoMMX:
#ifdef GTW_REORDER
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6
	jmp	DoMMX100

DoMMX10:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	movq		mm3, mm1			// Mono samples

	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	punpcklwd	mm1, mm1

	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	punpckhwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+24+32], mm4
	pmulhw		mm1, mm6

DoMMX100:
	punpckhwd	mm2, mm1
	sub		ebx, 8

	pmulhw		mm3, mm6
	
	punpcklwd	mm1, mm1

	psrad		mm1, 15

	paddd		mm1, QWORD PTR [edi+ebx*4+32]
	punpckhwd	mm4, mm3

	punpcklwd	mm3, mm3

	movq		QWORD PTR [edi+ebx*4+32],    mm1
	psrad		mm2, 15

	paddd		mm2, QWORD PTR [edi+ebx*4+8+32]
	psrad		mm3, 15

	paddd		mm3, QWORD PTR [edi+ebx*4+16+32]
	psrad		mm4, 15

	jge		DoMMX10

	movq		QWORD PTR [edi+ebx*4+16+32], mm3
	paddd		mm4, QWORD PTR [edi+ebx*4+24+32]
	movq		QWORD PTR [edi+ebx*4+8 +32], mm2
	movq		QWORD PTR [edi+ebx*4+24+32], mm4
#else
	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1
	punpckhwd	mm3, mm3

	pmulhw		mm1, mm6
	pmulhw		mm3, mm6
	
	punpckhwd	mm2, mm1
	punpcklwd	mm1, mm1
	punpckhwd	mm4, mm3
	punpcklwd	mm3, mm3

	psrad		mm1, 15
	psrad		mm2, 15
	psrad		mm3, 15
	psrad		mm4, 15

	paddd		mm1, QWORD PTR [edi+ebx*4]
	paddd		mm2, QWORD PTR [edi+ebx*4+8]
	paddd		mm3, QWORD PTR [edi+ebx*4+16]
	paddd		mm4, QWORD PTR [edi+ebx*4+24]
	movq		QWORD PTR [edi+ebx*4],    mm1
	movq		QWORD PTR [edi+ebx*4+8],  mm2
	movq		QWORD PTR [edi+ebx*4+16], mm3
	movq		QWORD PTR [edi+ebx*4+24], mm4
	
	sub		ebx, 8
	jge		DoMMX
#endif

	emms
	add	ebx, 8
	je	Done

	sub	ebx, 2
	
LastSamples:	
#ifdef USE_SLOWER_TABLE
	mov	eax, [ebp]pMixSource.m_MapTable
	test	eax, eax
	je	NoMapTable
	
	mov	ebp, eax

UseMapTable:
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx

	mov	eax, ecx
	and	ecx, 0xff
	sar	eax, 8
	mov	ecx, DWORD PTR [ebp+ecx*4]
	mov	eax, DWORD PTR [ebp+eax*4+2048+512]
	add	ecx, eax

	mov	eax, DWORD PTR [edi+ebx*4]
	add	eax, ecx

//	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
//	imul	edx, DWORD PTR [ebp]pMixSource.m_dwRVolume

//	sar	ecx, 16
//	sar	edx, 16

	mov	ecx, edx
	mov	DWORD PTR [edi+ebx*4], eax
	and	edx, 0xff
	sar	ecx, 8
	mov	edx, DWORD PTR [ebp+edx*4+1024]
	mov	ecx, DWORD PTR [ebp+ecx*4+1024+2048+512]
	add	edx, ecx

        mov	ecx, DWORD PTR [edi+ebx*4+4]
        add	ecx, edx
	mov	DWORD PTR [edi+ebx*4+4], ecx
        sub	ebx, 2

	jge	UseMapTable

	jmp	Done
#endif

NoMapTable:
	movsx	ecx, WORD PTR [esi+ebx]
	mov	edx, ecx
	mov	eax, DWORD PTR [edi+ebx*4]

	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	edx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	sar	ecx, 16
	sar	edx, 16

	add	eax, ecx
        mov	ecx, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], eax
        add	ecx, edx

	mov	DWORD PTR [edi+ebx*4+4], ecx
        sub	ebx, 2

	jge	NoMapTable
Done:
	pop	ebp
	}
    }
#elif 1
    if (iters) {
	_asm {
        mov	ebx, iters
        mov	esi, pSource
        mov	edi, plBuild
        push	ebp
	mov	ebp, pMixSource
	lea	ebx, [ebx*2-2]
	movsx	ecx, WORD PTR [esi+ebx]

Lab:
	mov	edx, ecx
	mov	eax, DWORD PTR [edi+ebx*4]

	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	edx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	sar	ecx, 16
	sar	edx, 16

	add	eax, ecx
        mov	ecx, DWORD PTR [edi+ebx*4+4]

	mov	DWORD PTR [edi+ebx*4], eax
        add	ecx, edx

	mov	DWORD PTR [edi+ebx*4+4], ecx
        sub	ebx, 2

	movsx	ecx, WORD PTR [esi+ebx]
        jne	Lab
	pop	ebp
	}
    }
#else
    while(--iters >= 0)
    {
      LONG Sample;
      Sample = ((LONG)*((SHORT*)(XpSource)));
      *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
      *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    }
#endif

    iters = i;
    i *= 2;;
    plBuild  += i;
    pSource          = XpSource;
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\merge167.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge167 */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE167ASM
BOOL Merge167Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  
  #define USE_ITERS		// Keep separate from RESAMPLE to ease removal.
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
    LONG iters, i;
    i     = plBuildEnd - plBuild;
    iters = pSourceEnd - pSource;
    iters /= STEP_SIZE;
    i /= 2;;
    if (i < iters) iters = i;
    i = iters;
#if 1
     if (iters) {
      if (pMixSource->m_fUse_MMX)
      _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*4-4]				// 2 at a time.
	cmp	ebx, 12
        mov	edi, plBuild
	push	ebp
	mov	ebp, pMixSource
	jl	OneSample

	mov	eax, DWORD PTR [ebp]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	shr	eax, 1					   // Keep positive.
	shr	ecx, 1
	and	ecx, 0xffff
	shl	eax, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	sub	ebx, 4
	lea	ecx, [esi+ebx]
	test	ecx, 7
	je	DoMMX

	add	ebx, 4

OneSample:	
	movsx	ecx, WORD PTR [esi+ebx]
	movsx	edx, WORD PTR [esi+ebx+2]

	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	edx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	sar	ecx, 16
	sar	edx, 16

	add	DWORD PTR [edi+ebx*2], ecx
	add	DWORD PTR [edi+ebx*2+4], edx

	test	ebx, ebx
	je	Done

	sub	ebx, 4
	je	OneSample

	sub	ebx, 4
DoMMX:
#ifdef GTW_REORDER
	cmp	ebx, 16
	jl	DoMMX001


	movq		mm1, QWORD PTR [esi+ebx]	// Load source
	pmulhw		mm1, mm6
	punpckhwd	mm2, mm1			// First stereo sample
	sub	ebx, 16
	punpcklwd	mm1, mm1			// Second stereo sample
	psrad		mm1, 15
	psrad		mm2, 15

	movq		mm3, QWORD PTR [esi+ebx-8+16]	// Load source
	jmp	DoMMX0001
DoMMX01:
	movq		mm3, QWORD PTR [esi+ebx-8+16]	// Load source
	psrad		mm2, 15
DoMMX0001:
	paddd		mm1, QWORD PTR [edi+ebx*2+32]
	pmulhw		mm3, mm6

	paddd		mm2, QWORD PTR [edi+ebx*2+8+32]
	punpckhwd	mm4, mm3			// First stereo sample

	movq		QWORD PTR [edi+ebx*2+32], mm1
	punpcklwd	mm3, mm3			// Second stereo sample

	movq		QWORD PTR [edi+ebx*2+8+32], mm2
	psrad		mm3, 15

	movq		mm1, QWORD PTR [esi+ebx-16+16]	// Load source
	psrad		mm4, 15

	paddd		mm3, QWORD PTR [edi+ebx*2-16+32]
	pmulhw		mm1, mm6

	paddd		mm4, QWORD PTR [edi+ebx*2+8-16+32]
	punpckhwd	mm2, mm1			// First stereo sample

	movq		QWORD PTR [edi+ebx*2-16+32], mm3
	punpcklwd	mm1, mm1			// Second stereo sample

	movq		QWORD PTR [edi+ebx*2+8-16+32], mm4
	psrad		mm1, 15

	sub	ebx, 16
	jge	DoMMX01

	psrad		mm2, 15
	paddd		mm1, QWORD PTR [edi+ebx*2+32]
	paddd		mm2, QWORD PTR [edi+ebx*2+8+32]
	movq		QWORD PTR [edi+ebx*2+32], mm1
	movq		QWORD PTR [edi+ebx*2+8+32], mm2

	add		ebx, 8
	jge		DoMMX001

	add		ebx, 4
	je		OneSample
	jmp		Done
	
#endif
DoMMX001:
	movq		mm1, QWORD PTR [esi+ebx]	// Load source

	pmulhw		mm1, mm6
	
	punpckhwd	mm2, mm1			// First stereo sample
	punpcklwd	mm1, mm1			// Second stereo sample
	psrad		mm1, 15
	psrad		mm2, 15
	paddd		mm1, QWORD PTR [edi+ebx*2]
	paddd		mm2, QWORD PTR [edi+ebx*2+8]
	movq		QWORD PTR [edi+ebx*2], mm1
	movq		QWORD PTR [edi+ebx*2+8], mm2
	
	sub		ebx, 8
	jge		DoMMX001

	add	ebx, 4
	je	OneSample
	
Done:
	emms
	pop	ebp
	}
      else if (0 && pMixSource->m_MapTable) {
        _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*4-4]
        mov	edi, plBuild
        push	ebp
	mov	ebp, pMixSource
	mov	ebp, [ebp]pMixSource.m_MapTable
UseMapTable:
	movsx	ecx, WORD PTR [esi+ebx]

	mov	eax, ecx
	and	ecx, 0xff
	sar	eax, 8
	mov	ecx, DWORD PTR [ebp+ecx*4]
	mov	eax, DWORD PTR [ebp+eax*4+2048+512]
	add	ecx, eax

	mov	eax, DWORD PTR [edi+ebx*4]
	add	eax, ecx

	movsx	ecx, WORD PTR [esi+ebx+2]
	mov	DWORD PTR [edi+ebx*4], eax
	mov	edx, ecx
	and	ecx, 0xff
	sar	edx, 8
	mov	ecx, DWORD PTR [ebp+ecx*4+1024]
	mov	edx, DWORD PTR [ebp+edx*4+1024+2048+512]
	add	edx, ecx

        mov	ecx, DWORD PTR [edi+ebx*4+4]
        add	ecx, edx
	mov	DWORD PTR [edi+ebx*4+4], ecx
        sub	ebx, 4

	jge	UseMapTable
	
	pop	ebp
      }
    }
    else
        _asm {
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*4-4]
        mov	edi, plBuild
        push	ebp
	mov	ebp, pMixSource
	push	[ebp]pMixSource.m_dwRVolume
	push	[ebp]pMixSource.m_dwLVolume
	mov	ebp, DWORD PTR [esi+ebx]
Lab:
	mov	edx, ebp

	sal	ebp, 16
	mov	ecx, DWORD PTR[edi+ebx*2]

	sar	edx, 16
	mov	eax, DWORD PTR[edi+ebx*2+4]

	sar	ebp, 16

	imul	edx, DWORD PTR [esp+4]
	imul	ebp, DWORD PTR [esp+0]

	sar	edx, 16
	sar	ebp, 16

	add	edx, eax

	add	ecx, ebp
	sub	ebx, 4

	mov	DWORD PTR [edi+ebx*2+8], ecx
	mov	ebp, DWORD PTR [esi+ebx]

	mov	DWORD PTR [edi+ebx*2+12], edx
	jge	SHORT Lab

	add	esp, 8
        pop	ebp
      }
    }
#elif 0
    if (iters) {
	_asm {
        mov	ebx, iters
        mov	esi, pSource
        mov	edi, plBuild
        push	ebp
	mov	ebp, pMixSource
	lea	ebx, [ebx*4-4]

	mov	ecx, DWORD PTR [esi+ebx]	// !!!
Lab:
//	movsx	ecx, WORD PTR [esi+ebx]
//	movsx	edx, WORD PTR [esi+ebx+2]

	mov	edx, ecx
	shl	ecx, 16
	sar	edx, 16
	sar	ecx, 16

	mov	eax, DWORD PTR [edi+ebx*2]

	imul	ecx, DWORD PTR [ebp]pMixSource.m_dwLVolume
	imul	edx, DWORD PTR [ebp]pMixSource.m_dwRVolume

	sar	ecx, 16
	sar	edx, 16

	add	eax, ecx
        mov	ecx, DWORD PTR [edi+ebx*2+4]

	mov	DWORD PTR [edi+ebx*2], eax
        add	ecx, edx

	mov	DWORD PTR [edi+ebx*2+4], ecx
        sub	ebx,4

	mov	ecx, DWORD PTR [esi+ebx]	// !!!
        jne	Lab
	pop	ebp
	}
    }
#else
    while(--iters >= 0)
    {
      LONG SampleL;
      LONG SampleR;
      SampleL = *((SHORT*)(XpSource));
      SampleR = *(((SHORT*)(XpSource))+1);
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
      *XplBuild += SampleL;
      *(XplBuild + 1) += SampleR;
    }
#endif
    iters = i;
    i *= 2;;
    plBuild  += i;
    pSource          = XpSource;
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
  pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\merge103.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge103 */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE103ASM
BOOL Merge103Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
 
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;
#if 1
	if (!pMixSource->m_fUse_MMX)
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*4]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	movsx	ecx, WORD PTR [esi+4]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	mov	DWORD PTR [edi], ebx

	movsx	ecx, WORD PTR [esi+6]
	movsx	ebx, WORD PTR [esi+2]
	sub	ecx, ebx		// x   = NewSample - OldSample
	add	edi, 8			// plBuild += 2
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ecx, ebx		// NewSample += x
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*4]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*4]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov	ebp, eax
Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	movq		mm1, QWORD PTR [esi]
	movq		mm2, mm1
	punpckhdq	mm2, mm2	// Put next sample in low half.
	psubw		mm2, mm1

//	movsx	ecx, WORD PTR [esi+4]
//	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff

	movd		mm5, ebp
	punpcklwd	mm1, mm1
	punpcklwd	mm5, mm5	// dwFrac.  Lower dword has 2 copies.

	movq		mm3, mm2	// Use for high half of multiply.
	psrad		mm1, 16

	pmullw		mm2, mm5	// Low word.
	pmulhw		mm3, mm5	// High word results.

	punpcklwd	mm2, mm3	// Low bits are Left, high are Right.
	psrad		mm2, 12
	paddd		mm1, mm2
	paddd		mm1, QWORD PTR [edi]
	movq		QWORD PTR [edi], mm1

//	sub	ecx, ebx		// x   = NewSample - OldSample
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi]
//	add	ebx, ecx
//	mov	DWORD PTR [edi], ebx

//	movsx	ecx, WORD PTR [esi+6]
//	movsx	ebx, WORD PTR [esi+2]
//	sub	ecx, ebx		// x   = NewSample - OldSample
	add	edi, 8			// plBuild += 2
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
//	add	ebx, ecx
	mov	ecx, eax
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*4]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
       LONG SampleLNext;
       LONG SampleRNext;

       while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
       {
       LONG SampleL;
       LONG SampleR;
       SampleL = *((SHORT*)(XpSource));
       SampleR = *(((SHORT*)(XpSource))+1);
       SampleLNext = *(((SHORT*)(XpSource))+2);
       SampleRNext = *(((SHORT*)(XpSource))+3);

       LONG dwFrac = dwFraction & FRACT_MASK;
       SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
       SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
       dwFraction += dwStep;
       *XplBuild += SampleL;
       *(XplBuild + 1) += SampleR;
   
       plBuild += 2;
       }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }


  *((LONG **)ppSource) = (LONG *)pSource;
   pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
   pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\merge226.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge226 */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE226ASM
BOOL Merge226Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#if 1
    if (!pMixSource->m_fUse_MMX) {
	if (!pMixSource->m_MapTable)
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp			// Create local frame...
	mov	ecx,  DWORD PTR pMixSource
	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
	xor	ecx, ecx
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	mov	cl, BYTE PTR [esi+2]
	xor	ebx, ebx
	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
	shl	ecx, 8
	sub	ebx, 128
	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	imul	ecx, DWORD PTR [esp+12]
	sar	ecx, 16
	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	xor	ecx, ecx
	mov	DWORD PTR [edi], ebx
	mov	cl, BYTE PTR [esi+3]
	xor	ebx, ebx
	sub	ecx, 128
	mov	bl, BYTE PTR [esi+1]
	shl	ecx, 8
	sub	ebx, 128
	shl	ebx, 8
	add	edi, 8			// plBuild += 2
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ecx, ebx		// NewSample += x
	imul	ecx, DWORD PTR [esp+16]
	sar	ecx, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 20
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp			// Create local frame...
	mov	ecx,  DWORD PTR pMixSource
	push	edx
	mov	edx, DWORD PTR [ecx]pMixSource.m_MapTable
//	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
//	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit1

	mov	ebp, eax
	xor	ecx, ecx
Lab1:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit1

	mov	cl, BYTE PTR [esi+2]
	xor	ebx, ebx
//	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
//	shl	ecx, 8
//	sub	ebx, 128
//	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ecx, DWORD PTR [edx+ecx*4]
//	imul	ecx, DWORD PTR [esp+12]
//	sar	ecx, 16
	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	xor	ecx, ecx
	mov	DWORD PTR [edi], ebx
	mov	cl, BYTE PTR [esi+3]
	xor	ebx, ebx
//	sub	ecx, 128
	mov	bl, BYTE PTR [esi+1]
//	shl	ecx, 8
//	sub	ebx, 128
//	shl	ebx, 8
	add	edi, 8			// plBuild += 2
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ecx, ebx		// NewSample += x
	mov	ecx, DWORD PTR [edx+ecx*4+1024]
//	imul	ecx, DWORD PTR [esp+16]
//	sar	ecx, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	shr	ecx, 12
	mov	ebx, DWORD PTR [esp+12]
	mov	ebp, eax
	lea	esi, [ebx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab1
Exit1:
	add	esp, 16
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
    }
    else
	_asm {
	mov	eax, pMixSource
	mov	ecx, DWORD PTR [eax]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	eax, DWORD PTR [eax]pMixSource.m_dwLVolume
	shr	ecx, 1			// Only have positive values.
	shr	eax, 1
//	and	eax, 0xffff
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
//	punpckldq	mm6, mm6

	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov		ecx, 128
	movd		mm7, ecx	// 0, 0, 0, 128
	punpcklwd	mm7, mm7	// 0, 0, 128, 128
	punpckldq	mm7, mm7	// 128, 128, 128, 128

	mov	ebp, eax
	xor	ecx, ecx

Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	movd		mm1, DWORD PTR [esi]
	punpcklbw	mm1, mm0
	psubw		mm1, mm7
	psllw		mm1, 8

	movq		mm2, mm1
	punpckhdq	mm2, mm2	// Put next sample in low half.
	psubw		mm2, mm1

//	mov	cl, BYTE PTR [esi+2]
//	xor	ebx, ebx
//	sub	ecx, 128
//	mov	bl, BYTE PTR [esi]
//	shl	ecx, 8
//	sub	ebx, 128
//	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff

	movd		mm5, ebp
	punpcklwd	mm1, mm1	
	punpcklwd	mm5, mm5	
	psrad		mm1, 16
#ifdef DO_MORE_ACCURATE_VERSION
	movq		mm3, mm2	// Use for high half of multiply.

	pmullw		mm2, mm5	// Low word.
	pmulhw		mm3, mm5	// High word results.

	punpcklwd	mm2, mm3	// Low bits are Left, high are Right.
#else
	pmulhw		mm2, mm5
	punpcklwd	mm2, mm2	// Lower 4 bits are randomized.
#endif
	psrad		mm2, 12
	paddd		mm1, mm2

	packssdw	mm1, mm1	// Shift low 16 bits of high dword 16.

	pmulhw		mm1, mm6
	punpcklwd	mm1, mm1	// Move to high part.
	psrad		mm1, 15

	paddd		mm1, QWORD PTR [edi]
	movq		QWORD PTR [edi], mm1

//	sub	ecx, ebx		// x   = NewSample - OldSample
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi]
//	add	ebx, ecx
//	xor	ecx, ecx
//	mov	DWORD PTR [edi], ebx
//	mov	cl, BYTE PTR [esi+3]
//	xor	ebx, ebx
//	sub	ecx, 128
//	mov	bl, BYTE PTR [esi+1]
//	shl	ecx, 8
//	sub	ebx, 128
//	shl	ebx, 8
	add	edi, 8			// plBuild += 2
//	sub	ecx, ebx		// x   = NewSample - OldSample
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
//	add	ebx, ecx
	mov	ecx, eax
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
    LONG SampleLNext;
    LONG SampleRNext;

    while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
    {
      LONG SampleL;
      LONG SampleR;
      SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
      SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
      SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
      SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
      LONG dwFrac = dwFraction & FRACT_MASK;
      SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
      SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
      dwFraction += dwStep;
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
      *XplBuild += SampleL;
      *(XplBuild + 1) += SampleR;
      plBuild += 2;
    }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\merge224.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge224 */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE224ASM
BOOL Merge224Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

#if 1
    if (!pMixSource->m_fUse_MMX) {
	if (!pMixSource->m_MapTable)
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	add	esi, ecx		// pSource
	push	ebp			// Create local frame...
	mov	ecx,  DWORD PTR pMixSource
	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
	xor	ecx, ecx
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	mov	cl, BYTE PTR [esi+1]
	xor	ebx, ebx
	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
	shl	ecx, 8
	sub	ebx, 128
	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebp, ecx
	imul	ecx, DWORD PTR [esp+12]
	sar	ecx, 16
	mov	ebx, DWORD PTR [edi]
	add	edi, 8			// plBuild += 2
	add	ebx, ecx
	mov	DWORD PTR [edi-8], ebx
	imul	ebp, DWORD PTR [esp+16]
	mov	ecx, DWORD PTR [esp+8]	// dwStep
	sar	ebp, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ecx		// dwFraction += dwStep
	add	ebx, ebp
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*1]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 20
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	add	esi, ecx		// pSource
	push	ebp			// Create local frame...
	mov	ecx,  DWORD PTR pMixSource
	push	edx
	mov	edx, DWORD PTR [ecx]pMixSource.m_MapTable
//	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
//	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit1

	mov	ebp, eax
	xor	ecx, ecx
Lab1:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit1

	mov	cl, BYTE PTR [esi+1]
	xor	ebx, ebx
//	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
//	shl	ecx, 8
//	sub	ebx, 128
//	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebp, ecx
	mov	ecx, DWORD PTR [edx+ecx*4]
//	imul	ecx, DWORD PTR [esp+12]
//	sar	ecx, 16
	mov	ebx, DWORD PTR [edi]
	add	edi, 8			// plBuild += 2
	add	ebx, ecx
	mov	DWORD PTR [edi-8], ebx
	mov	ebp, DWORD PTR [edx+ebp*4+1024]
//	imul	ebp, DWORD PTR [esp+16]
	mov	ecx, DWORD PTR [esp+8]	// dwStep
//	sar	ebp, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ecx		// dwFraction += dwStep
	add	ebx, ebp
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	mov	ebx, DWORD PTR [esp+12]
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [ebx+ecx*1]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab1
Exit1:
	add	esp, 16
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
    }
    else
	_asm {
	mov	eax, pMixSource
	mov	ecx, DWORD PTR [eax]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	eax, DWORD PTR [eax]pMixSource.m_dwLVolume
	shr	ecx, 1			// Only have positive values.
	shr	eax, 1
//	and	eax, 0xffff
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
//	punpckldq	mm6, mm6

	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	add	esi, ecx		// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov	ebp, eax
	xor	ecx, ecx
Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	mov	cl, BYTE PTR [esi+1]
	xor	ebx, ebx
	sub	ecx, 128
	mov	bl, BYTE PTR [esi]
	shl	ecx, 8
	sub	ebx, 128
	shl	ebx, 8
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
//	mov	ebp, DWORD PTR [edi]
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x

	movd		mm1, ecx
	punpcklwd	mm1, mm1
	
	pmulhw		mm1, mm6			// Only need high parts.
	punpcklwd	mm1, mm1
	psrad		mm1, 15

	paddd		mm1, QWORD PTR [edi]
	movq		QWORD PTR [edi], mm1
	
//	mov	ebx, DWORD PTR [edi+4]
//	add	ebp, ecx
//	add	ebx, ecx
//	mov	DWORD PTR [edi], ebp
	add	edi, 8			// plBuild += 2
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	add	eax, ebp		// dwFraction += dwStep
	mov	ecx, eax
	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*1]	// pSource + (dwFraction >> 12) * 4
	xor	ecx, ecx

	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
    LONG SampleNext, SampleSave;
    while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
    {
      LONG Sample;
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
      SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
      LONG dwFrac = dwFraction & FRACT_MASK;
      SampleSave = Sample;
      Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
      dwFraction += dwStep;
      *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
      *(XplBuild+1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
      plBuild += 2;
    }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\merge231.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge231 */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE231ASM
BOOL Merge231Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
  {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#if 1 
    if (!pMixSource->m_fUse_MMX) {
	if (1 || !pMixSource->m_MapTable)
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*4]	// pSource
	push	ebp
	mov	ecx, DWORD PTR pMixSource
	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	movsx	ecx, WORD PTR [esi+4]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	imul	ecx, DWORD PTR [esp+12]
	sar	ecx, 16
	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	mov	DWORD PTR [edi], ebx

	movsx	ecx, WORD PTR [esi+6]
	movsx	ebx, WORD PTR [esi+2]
	sub	ecx, ebx		// x   = NewSample - OldSample
	add	edi, 8			// plBuild += 2
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ecx, ebx		// NewSample += x
	imul	ecx, DWORD PTR [esp+16]
	sar	ecx, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*4]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 20
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*4]	// pSource
	push	ebp
	mov	ecx, DWORD PTR pMixSource
	push	edx
	mov	edx, DWORD PTR [ecx]pMixSource.m_MapTable
//	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
//	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit1

	mov	ebp, eax
Lab1:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit1

	movsx	ecx, WORD PTR [esi+4]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
//	imul	ecx, DWORD PTR [esp+12]
//	sar	ecx, 16

	mov	ebx, ecx
	and	ecx, 0xff
	sar	ebx, 8
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edx+ebx*4+2048+512]
	add	ecx, ebx

	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	mov	DWORD PTR [edi], ebx

	movsx	ecx, WORD PTR [esi+6]
	movsx	ebx, WORD PTR [esi+2]
	sub	ecx, ebx		// x   = NewSample - OldSample
	add	edi, 8			// plBuild += 2
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
	add	ecx, ebx		// NewSample += x
//	imul	ecx, DWORD PTR [esp+16]
//	sar	ecx, 16

	mov	ebx, ecx
	and	ecx, 0xff
	sar	ebx, 8
	mov	ecx, DWORD PTR [edx+ecx*4+1024]
	mov	ebx, DWORD PTR [edx+ebx*4+1024+2048+512]
	add	ecx, ebx

	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
	add	ebx, ecx
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebx, DWORD PTR [esp+12]
	mov	ebp, eax
	lea	esi, [ebx+ecx*4]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab1
Exit1:
	add	esp, 16
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
    }
    else
	_asm {
	mov	eax, pMixSource
	mov	ecx, DWORD PTR [eax]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	eax, DWORD PTR [eax]pMixSource.m_dwLVolume
	shr	ecx, 1			// Only have positive values.
	shr	eax, 1
//	and	eax, 0xffff
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
//	punpckldq	mm6, mm6

	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*4]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov	ebp, eax
Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	movq		mm1, QWORD PTR [esi]
	movq		mm2, mm1
	punpckhdq	mm2, mm2	// Put next sample in low half.
	psubw		mm2, mm1

//	movsx	ecx, WORD PTR [esi+4]
//	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff

	movd		mm5, ebp
	punpcklwd	mm1, mm1	// Make 32 bits.
	punpcklwd	mm5, mm5	// dwFrac.  Lower dword has 2 copies.

	movq		mm3, mm2	// Use for high half of multiply.
	psrad		mm1, 16

	pmullw		mm2, mm5	// Low word.
	pmulhw		mm3, mm5	// High word results.

	punpcklwd	mm2, mm3	// Low bits are Left, high are Right.
	psrad		mm2, 12
	paddd		mm1, mm2

	packssdw	mm1, mm1	// Shift low 16 bits of high dword 16.

	pmulhw		mm1, mm6
	punpcklwd	mm1, mm1	// Move to high part.
	psrad		mm1, 15

	paddd		mm1, QWORD PTR [edi]
	movq		QWORD PTR [edi], mm1

//	sub	ecx, ebx		// x   = NewSample - OldSample
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi]
//	add	ebx, ecx
//	mov	DWORD PTR [edi], ebx

//	movsx	ecx, WORD PTR [esi+6]
//	movsx	ebx, WORD PTR [esi+2]
//	sub	ecx, ebx		// x   = NewSample - OldSample
	add	edi, 8			// plBuild += 2
//	imul	ecx, ebp		// x  *= Frac
//	sar	ecx, 12			// x >>= 12
	mov	ebp, DWORD PTR [esp+8]	// dwStep
//	add	ecx, ebx		// NewSample += x
//	mov	ebx, DWORD PTR [edi-4]
	add	eax, ebp		// dwFraction += dwStep
//	add	ebx, ecx
	mov	ecx, eax
//	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*4]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab0
Exit0:
	emms
	add	esp, 12
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
#else
    LONG SampleLNext;
    LONG SampleRNext;
    while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
    {
      LONG SampleL;
      LONG SampleR;
      SampleL = *((SHORT*)(XpSource));
      SampleR = *(((SHORT*)(XpSource))+1);
      SampleLNext = *(((SHORT*)(XpSource))+2);
      SampleRNext = *(((SHORT*)(XpSource))+3);
      LONG dwFrac = dwFraction & FRACT_MASK;
      SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
      SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
      dwFraction += dwStep;
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
      *XplBuild += SampleL;
      *(XplBuild + 1) += SampleR;
      plBuild += 2;
    }
#endif

    pSource          = XpSource;
    dwFraction &= FRACT_MASK;		// Eliminate accumulated offsets.
    nInputByteCount -=  pSource - pSourceStart;

    if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\merge32.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge32 */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE32ASM
BOOL Merge32Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;

  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(BYTE))
  
  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  
  #define USE_ITERS		// Keep separate from RESAMPLE to ease removal.
  #define XpSource (pSource + (iters * STEP_SIZE))
  #define XplBuild (plBuild + (iters * 2))
  

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;
    
       LONG iters, i;
       i     = plBuildEnd - plBuild;
       iters = pSourceEnd - pSource;
       iters /= STEP_SIZE;
       i /= 2;;
       if (i < iters) iters = i;
       i = iters;
#if 1
       if (iters) {
        _asm {
	mov	ecx, pMixSource
        mov	ebx, iters
        mov	esi, pSource
	lea	ebx, [ebx*1-1]
	xor	eax, eax
	cmp	ebx, 7
        mov	edi, plBuild
	jl	LastSamples

	mov	ecx, [ecx]pMixSource.m_fUse_MMX
	test	ecx, ecx
	jmp	LastSamples
	je	LastSamples

	sub	ebx, 3
	lea	ecx, [esi+ebx]
	pxor	mm0, mm0

	mov	edx, 128
	movd		mm5, edx	// 0, 0, 0, 128
	punpcklwd	mm5, mm5	// 0, 0, 128, 128
	punpckldq	mm5, mm5	// 128, 128, 128, 128


	test	ecx, 3
	je	DoMMX

	add	ebx, 3

FirstSamples:	
	mov	al, BYTE PTR [esi+ebx]
	mov	edx, DWORD PTR [edi+ebx*8]

	sub	eax, 128

	shl	eax, 8
	mov	ecx, DWORD PTR [edi+ebx*8+4]

	add	edx, eax
	add	ecx, eax

	xor	eax, eax
	mov	DWORD PTR [edi+ebx*8], edx

	mov	DWORD PTR [edi+ebx*8+4], ecx
	dec	ebx
	lea	ecx, [esi+ebx]
	and	ecx, 3
	cmp	ecx, 3
	jne	FirstSamples

	sub	ebx, 3

DoMMX:
#ifdef GTW_REORDER
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	jmp	DoMMX00

DoMMX0:
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpckhdq	mm4, mm4

	paddd		mm3, QWORD PTR [edi+ebx*8+16+32]
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	psubw		mm1, mm5

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	punpckhwd	mm3, mm1

	movq		QWORD PTR [edi+ebx*8+24+32], mm4
	punpcklwd	mm1, mm1
DoMMX00:
	psrad		mm1, 16
	sub		ebx, 4

	psrad		mm3, 16
	movq		mm2, mm1

	punpckldq	mm1, mm1
	movq		mm4, mm3

	paddd		mm1, QWORD PTR [edi+ebx*8+32]
	punpckhdq	mm2, mm2

	paddd		mm2, QWORD PTR [edi+ebx*8+8+32]
	punpckldq	mm3, mm3

	movq		QWORD PTR [edi+ebx*8+32],    mm1
	jge		DoMMX0

	paddd		mm3, QWORD PTR [edi+ebx*8+16+32]
	punpckhdq	mm4, mm4

	paddd		mm4, QWORD PTR [edi+ebx*8+24+32]

	movq		QWORD PTR [edi+ebx*8+8 +32], mm2
	movq		QWORD PTR [edi+ebx*8+16+32], mm3
	movq		QWORD PTR [edi+ebx*8+24+32], mm4
#else
#if 0
	movd		mm1, DWORD PTR [esi+ebx]	// Load 4 bytes.
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.
	
	movq		mm3, mm1			// Mono samples

	punpcklwd	mm1, mm1			// Make stereo
	punpckhwd	mm3, mm3

	punpckhwd	mm2, mm1			// 32 bit stereo...
	punpcklwd	mm1, mm1
	punpckhwd	mm4, mm3
	punpcklwd	mm3, mm3

	psrad		mm1, 16
	psrad		mm2, 16
	psrad		mm3, 16
	psrad		mm4, 16
#else
	movd		mm1, DWORD PTR [esi+ebx]	// Load source
	punpcklbw	mm1, mm0			// Make unsigned 16 bit.
	psubw		mm1, mm5
	psllw		mm1, 8				// 4 Signed 16 bit mono.

	punpckhwd	mm3, mm1
	punpcklwd	mm1, mm1

	psrad		mm1, 16
	psrad		mm3, 16

	movq		mm2, mm1
	movq		mm4, mm3

	punpckldq	mm1, mm1
	punpckhdq	mm2, mm2
	punpckldq	mm3, mm3
	punpckhdq	mm4, mm4
#endif
	paddd		mm1, QWORD PTR [edi+ebx*8]
	paddd		mm2, QWORD PTR [edi+ebx*8+8]
	paddd		mm3, QWORD PTR [edi+ebx*8+16]
	paddd		mm4, QWORD PTR [edi+ebx*8+24]
	movq		QWORD PTR [edi+ebx*8],    mm1
	movq		QWORD PTR [edi+ebx*8+8],  mm2
	movq		QWORD PTR [edi+ebx*8+16], mm3
	movq		QWORD PTR [edi+ebx*8+24], mm4
	
	sub		ebx, 4
	jge		DoMMX
#endif

	emms
	add	ebx, 4
	je	Done

	dec	ebx
	xor	eax, eax
	
LastSamples:	
	mov	al, BYTE PTR [esi+ebx]
	mov	edx, DWORD PTR [edi+ebx*8]

	sub	eax, 128

	shl	eax, 8
	mov	ecx, DWORD PTR [edi+ebx*8+4]

	add	edx, eax
	add	ecx, eax

	xor	eax, eax
	mov	DWORD PTR [edi+ebx*8], edx

	mov	DWORD PTR [edi+ebx*8+4], ecx
	dec	ebx
	jge	LastSamples
Done:
        }
       }
#elif 0
	if (iters)
	_asm {
	mov	esi, pSource
	mov	edi, plBuild
	mov	ebx, iters
	push	ebp

	dec	ebx
	xor	eax, eax
Lab:
	mov	al, BYTE PTR [esi+ebx]
	mov	edx, DWORD PTR [edi+ebx*8]

	sub	eax, 128

	shl	eax, 8
	mov	ebp, DWORD PTR [edi+ebx*8+4]

	add	edx, eax
	add	ebp, eax

	xor	eax, eax
	mov	DWORD PTR [edi+ebx*8], edx

	mov	DWORD PTR [edi+ebx*8+4], ebp
	dec	ebx
	jge	Lab

	pop	ebp
	}
#else
       while(--iters >= 0)
       {
          LONG Sample;
	  Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
         *XplBuild += Sample;
         *(XplBuild + 1) += Sample;
        
       }
#endif
       iters = i;
       i *= 2;;
       plBuild  += i;
     
       pSource          = XpSource;
       nInputByteCount -=  pSource - pSourceStart;

       if (pSource >= pSourceWrap) {	// Goes to -1 position if necessary.
          pSource -= pMixSource->m_cbBuffer;
       }

    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
    }

  *((LONG **)ppSource) = (LONG *)pSource;
    pMixSource->m_cSamplesInCache += ((plBuild - plBuildStart) / 2);
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dsound\dsound\merge229.inc ===
/***************************************************************************
 * Copyright (C) 1997-1998 Microsoft Corporation.  All Rights Reserved.
 ***************************************************************************/

/* Merge229 */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE229ASM
BOOL Merge229Asm (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource) {
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
  #undef STEP_SIZE
  #define STEP_SIZE (sizeof(WORD))

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))

  if (nInputByteCount == LONG_MAX) {	// Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     nInputByteCount = pSourceEnd - pSource;
     if (nInputByteCount > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
  }
  
  *((BYTE **)&pSourceWrap) -= STEP_SIZE;
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#if 1
    if (!pMixSource->m_fUse_MMX) {
	if (1 || !pMixSource->m_MapTable)
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	mov	ecx, DWORD PTR pMixSource
	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit

	mov	ebp, eax
Lab:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit

	movsx	ecx, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebp, ecx
	imul	ecx, DWORD PTR [esp+12]
	sar	ecx, 16
	mov	ebx, DWORD PTR [edi]
	add	ebx, ecx
	mov	DWORD PTR [edi], ebx

	add	edi, 8			// plBuild += 2
	mov	ecx, DWORD PTR [esp+8]	// dwStep
	imul	ebp, DWORD PTR [esp+16]
	sar	ebp, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ecx		// dwFraction += dwStep
	add	ebx, ebp
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab
Exit:
	add	esp, 20
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
	else
	_asm {
	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	push	edx
	mov	ecx, DWORD PTR pMixSource
	mov	ecx, DWORD PTR [ecx]pMixSource.m_MapTable
	push	ecx
//	push	DWORD PTR [ecx]pMixSource.m_dwRVolume
//	push	DWORD PTR [ecx]pMixSource.m_dwLVolume
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit1

	mov	ebp, eax
Lab1:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit1

	movsx	ecx, WORD PTR [esi+2]
	movsx	ebx, WORD PTR [esi]
	and	ebp, 4095		// dwFrac = dwFraction & 0x0fff
	sub	ecx, ebx		// x   = NewSample - OldSample
	imul	ecx, ebp		// x  *= Frac
	sar	ecx, 12			// x >>= 12
	add	ecx, ebx		// NewSample += x
	mov	ebp, ecx
	and	ecx, 0xff
	mov	ebx, ebp
	mov	edx, DWORD PTR [esp+12]
	sar	ebx, 8
	mov	ecx, DWORD PTR [edx+ecx*4]
	mov	ebx, DWORD PTR [edx+ebx*4+2048+512]
	add	edi, 8			// plBuild += 2
	add	ecx, ebx
//	imul	ecx, DWORD PTR [esp+12]
//	sar	ecx, 16
	mov	ebx, DWORD PTR [edi-8]
	add	ebx, ecx
	mov	DWORD PTR [edi-8], ebx

	mov	ebx, ebp
	and	ebp, 0xff
	sar	ebx, 8
	mov	ebp, DWORD PTR [edx+ebp*4+1024]
	mov	edx, DWORD PTR [edx+ebx*4+1024+2048+512]
	mov	ecx, DWORD PTR [esp+8]	// dwStep
	add	ebp, edx
//	imul	ebp, DWORD PTR [esp+16]
//	sar	ebp, 16
	mov	ebx, DWORD PTR [edi-4]
	add	eax, ecx		// dwFraction += dwStep
	add	ebx, ebp
	mov	ecx, eax
	mov	DWORD PTR [edi-4], ebx	// (*plBuild+1) += x
	mov	edx, DWORD PTR [esp+16]

	shr	ecx, 12
	mov	ebp, eax
	lea	esi, [edx+ecx*2]	// pSource + (dwFraction >> 12) * 4
	cmp	edi, DWORD PTR [esp+0]	// plBuild < plBuildEnd
	jb	Lab1
Exit1:
	add	esp, 20
	pop	ebp
	mov	dwFraction, eax
	mov	plBuild, edi
	}
     }
     else
	_asm {
	mov	eax, pMixSource
	mov	ecx, DWORD PTR [eax]pMixSource.m_dwRVolume // Use lower 16 bits
	mov	eax, DWORD PTR [eax]pMixSource.m_dwLVolume
	shr	ecx, 1			// Only have positive values.
	shr	eax, 1
//	and	eax, 0xffff
	shl	ecx, 16
	or	ecx, eax
	movd	mm6, ecx
	punpckldq	mm6, mm6

	mov	esi, pSource
	mov	edx, esi
	mov	eax, dwFraction
	mov	edi, plBuild		// plBuild
	mov	ecx, eax
	shr	ecx, 12
	lea	esi, [esi+ecx*2]	// pSource
	push	ebp
	push	DWORD PTR dwStep
	push	DWORD PTR pSourceEnd
	push	DWORD PTR plBuildEnd

	cmp	edi, DWORD PTR [esp+0]	// plBuild >= plBuildEnd
	jae	Exit0

	mov	ebp, eax
Lab0:
	cmp	esi, DWORD PTR [esp+4]	// pSource >= pSourceEnd
	jae	Exit0

	movsx	ecx, WORD PTR [